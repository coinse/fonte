{"sha": "c9dedff12e98a34ab4225bc65f810c0954207f11", "log": "CSV-67 UnicodeUnescapeReader should not be applied before parsing  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private final char escape;\n     private final boolean leadingSpacesIgnored;\n     private final boolean trailingSpacesIgnored;\n-    private final boolean unicodeEscapesInterpreted;\n     private final boolean emptyLinesIgnored;\n     private final String lineSeparator; // for outputs\n     private final String[] header;\n     static final char DISABLED = '\\ufffe';\n \n     /** Standard comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>. */\n-    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, false, true, CRLF, null);\n+    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, true, CRLF, null);\n \n     /**\n      * Excel file format (using a comma as the value delimiter).\n      * \n      * <pre>CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');</pre>\n      */\n-    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', DISABLED, DISABLED, false, false, false, false, CRLF, null);\n+    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', DISABLED, DISABLED, false, false, false, CRLF, null);\n \n     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n-    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', DISABLED, DISABLED, true, true, false, true, CRLF, null);\n+    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', DISABLED, DISABLED, true, true, true, CRLF, null);\n \n     /**\n      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and\n      * \n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n-    public static final CSVFormat MYSQL = new CSVFormat('\\t', DISABLED, DISABLED, '\\\\', false, false, false, false, \"\\n\", null);\n+    public static final CSVFormat MYSQL = new CSVFormat('\\t', DISABLED, DISABLED, '\\\\', false, false, false, \"\\n\", null);\n \n \n     /**\n      * @param escape                    the char used to escape special characters in values\n      * @param leadingSpacesIgnored      <tt>true</tt> when leading whitespaces should be ignored\n      * @param trailingSpacesIgnored     <tt>true</tt> when trailing whitespaces should be ignored\n-     * @param unicodeEscapesInterpreted <tt>true</tt> when unicode escapes should be interpreted\n      * @param emptyLinesIgnored         <tt>true</tt> when the parser should skip emtpy lines\n      * @param lineSeparator             the line separator to use for output\n      * @param header                    the header\n             char escape,\n             boolean leadingSpacesIgnored,\n             boolean trailingSpacesIgnored,\n-            boolean unicodeEscapesInterpreted,\n             boolean emptyLinesIgnored,\n             String lineSeparator,\n             String[] header) {\n         this.escape = escape;\n         this.leadingSpacesIgnored = leadingSpacesIgnored;\n         this.trailingSpacesIgnored = trailingSpacesIgnored;\n-        this.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n         this.emptyLinesIgnored = emptyLinesIgnored;\n         this.lineSeparator = lineSeparator;\n         this.header = header;\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     boolean isEncapsulating() {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     boolean isEscaping() {\n      * @return A copy of this format with the specified left trimming behavior.\n      */\n     public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format with the specified right trimming behavior.\n      */\n     public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format with the specified trimming behavior.\n      */\n     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n-    }\n-\n-    /**\n-     * Tells if unicode escape sequences (e.g. {@literal \\u1234}) are turned into their corresponding character\n-     * when parsing input.\n-     * \n-     * @return <tt>true</tt> if unicode escape sequences are interpreted, <tt>false</tt> if they are left as is.\n-     */\n-    public boolean isUnicodeEscapesInterpreted() {\n-        return unicodeEscapesInterpreted;\n-    }\n-\n-    /**\n-     * Returns a copy of this format with the specified unicode escaping behavior.\n-     *\n-     * @param unicodeEscapesInterpreted the escaping behavior, <tt>true</tt> to interpret unicode escape sequences,\n-     *                                  <tt>false</tt> to leave the escape sequences as is.\n-     * @return A copy of this format with the specified unicode escaping behavior.\n-     */\n-    public CSVFormat withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format  with the specified empty line skipping behavior.\n      */\n     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     String[] getHeader() {\n      * @return A copy of this format using the specified header\n      */\n     public CSVFormat withHeader(String... header) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      */\n     public CSVParser(Reader input, CSVFormat format) throws IOException {\n         format.validate();\n-        \n-        if (format.isUnicodeEscapesInterpreted()) {\n-            input = new UnicodeUnescapeReader(input);\n-        }\n         \n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n         \n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test\n     public void testImmutalibity() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, \"\\r\\n\", null);\n         \n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n         format.withLeadingSpacesIgnored(false);\n         format.withTrailingSpacesIgnored(false);\n         format.withEmptyLinesIgnored(false);\n-        format.withUnicodeEscapesInterpreted(false);\n         \n         assertEquals('!', format.getDelimiter());\n         assertEquals('!', format.getEncapsulator());\n         assertTrue(format.isLeadingSpacesIgnored());\n         assertTrue(format.isTrailingSpacesIgnored());\n         assertTrue(format.isEmptyLinesIgnored());\n-        assertTrue(format.isUnicodeEscapesInterpreted());\n     }\n \n     @Test\n     public void testMutators() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, \"\\r\\n\", null);\n         \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n         assertFalse(format.withSurroundingSpacesIgnored(false).isLeadingSpacesIgnored());\n         assertFalse(format.withSurroundingSpacesIgnored(false).isTrailingSpacesIgnored());\n         assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());\n-        assertFalse(format.withUnicodeEscapesInterpreted(false).isUnicodeEscapesInterpreted());\n     }\n \n     @Test\n         assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());\n         assertEquals(\"line separator\", CSVFormat.DEFAULT.getLineSeparator(), format.getLineSeparator());\n         assertEquals(\"escape\", CSVFormat.DEFAULT.getEscape(), format.getEscape());\n-        assertEquals(\"unicode escape\", CSVFormat.DEFAULT.isUnicodeEscapesInterpreted(), format.isUnicodeEscapesInterpreted());\n         assertEquals(\"trim left\", CSVFormat.DEFAULT.isLeadingSpacesIgnored(), format.isLeadingSpacesIgnored());\n         assertEquals(\"trim right\", CSVFormat.DEFAULT.isTrailingSpacesIgnored(), format.isTrailingSpacesIgnored());\n         assertEquals(\"empty lines\", CSVFormat.DEFAULT.isEmptyLinesIgnored(), format.isEmptyLinesIgnored());\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         };\n \n \n-        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, \"\\r\\n\", null);\n \n         CSVParser parser = new CSVParser(code, format);\n         List<CSVRecord> records = parser.getRecords();\n         };\n \n \n-        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\", null);\n+        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, \"\\r\\n\", null);\n \n         CSVParser parser = new CSVParser(code, format);\n         List<CSVRecord> records = parser.getRecords();\n         records = parser.getRecords();\n         \n         assertTrue(CSVPrinterTest.equals(res_comments, records));\n-    }\n-\n-    @Test\n-    public void testUnicodeEscape() throws Exception {\n-        String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n-        CSVParser parser = new CSVParser(code, CSVFormat.DEFAULT.withUnicodeEscapesInterpreted(true));\n-        final Iterator<CSVRecord> iterator = parser.iterator();\n-        CSVRecord record = iterator.next();\n-        assertEquals(2, record.size());\n-        assertEquals(\"abc\", record.get(0));\n-        assertEquals(\"public\", record.get(1));\n-        assertFalse(\"Should not have any more records\", iterator.hasNext());\n-    }\n-\n-    @Test\n-    public void testUnicodeEscapeMySQL() throws Exception {\n-        String code = \"abc\\t\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n-        CSVParser parser = new CSVParser(code, CSVFormat.MYSQL.withUnicodeEscapesInterpreted(true));\n-        final Iterator<CSVRecord> iterator = parser.iterator();\n-        CSVRecord record = iterator.next();\n-        assertEquals(2, record.size());\n-        assertEquals(\"abc\", record.get(0));\n-        assertEquals(\"public\", record.get(1));\n-        assertFalse(\"Should not have any more records\", iterator.hasNext());\n     }\n \n     @Test", "timestamp": 1331987355, "metainfo": ""}