{"sha": "53fd86dfbc75633b9820868c6119a75952da9bde", "log": "More constants clean ups.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n package org.apache.commons.csv;\n \n import static org.apache.commons.csv.Constants.COMMA;\n-import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.DOUBLE_QUOTE;\n import static org.apache.commons.csv.Constants.ESCAPE;\n import static org.apache.commons.csv.Constants.LF;\n  */\n public class CSVFormat implements Serializable {\n \n-    private static final String LF_STR = \"\" + LF;\n-\n     private static final long serialVersionUID = 1L;\n-\n-    /** According to RFC 4180, line breaks are delimited by CRLF */\n-    public static final String CRLF = \"\" + CR + LF;\n \n     private final char delimiter;\n     private final char encapsulator;\n             PRISTINE\n             .withDelimiter(TAB)\n             .withEscape(ESCAPE)\n-            .withLineSeparator(LF_STR);\n+            .withLineSeparator(LF);\n \n     /**\n      * Creates a customized CSV format.\n      *\n      * @return A copy of this format using the specified output line separator\n      */\n+    public CSVFormat withLineSeparator(final char lineSeparator) {\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, String.valueOf(lineSeparator), header);\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified output line separator.\n+     *\n+     * @param lineSeparator\n+     *            the line separator to be used for output.\n+     *\n+     * @return A copy of this format using the specified output line separator\n+     */\n     public CSVFormat withLineSeparator(final String lineSeparator) {\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, lineSeparator, header);\n--- a/src/main/java/org/apache/commons/csv/Constants.java\n+++ b/src/main/java/org/apache/commons/csv/Constants.java\n \n     /** Undefined state for the lookahead char */\n     static final int UNDEFINED = -2;\n+    \n+    /** According to RFC 4180, line breaks are delimited by CRLF */\n+    public static final String CRLF = EMPTY + CR + LF;\n+\n \n \n }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.CRLF;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n \n     @Test\n     public void testImmutalibity() {\n-        final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n+        final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CRLF, null);\n \n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n         assertEquals('!', format.getEncapsulator());\n         assertEquals('!', format.getCommentStart());\n         assertEquals('!', format.getEscape());\n-        assertEquals(CSVFormat.CRLF, format.getLineSeparator());\n+        assertEquals(CRLF, format.getLineSeparator());\n \n         assertTrue(format.getIgnoreSurroundingSpaces());\n         assertTrue(format.getIgnoreEmptyLines());\n \n     @Test\n     public void testMutators() {\n-        final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n+        final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CRLF, null);\n \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.CRLF;\n+import static org.apache.commons.csv.Constants.LF;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n \n \n         final CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\\'').withEscape('/')\n-                               .withIgnoreEmptyLines(true).withLineSeparator(CSVFormat.CRLF);\n+                               .withIgnoreEmptyLines(true).withLineSeparator(CRLF);\n \n         final CSVParser parser = new CSVParser(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n \n \n         final CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEscape('/')\n-                .withIgnoreEmptyLines(true).withLineSeparator(CSVFormat.CRLF);\n+                .withIgnoreEmptyLines(true).withLineSeparator(CRLF);\n \n         final CSVParser parser = new CSVParser(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n \n     @Test\n     public void testGetLineNumberWithLF() throws Exception {\n-        final CSVParser parser = new CSVParser(\"a\\nb\\nc\", CSVFormat.DEFAULT.withLineSeparator(\"\\n\"));\n+        final CSVParser parser = new CSVParser(\"a\\nb\\nc\", CSVFormat.DEFAULT.withLineSeparator(LF));\n \n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n \n     @Test\n     public void testGetLineNumberWithCRLF() throws Exception {\n-        final CSVParser parser = new CSVParser(\"a\\r\\nb\\r\\nc\", CSVFormat.DEFAULT.withLineSeparator(CSVFormat.CRLF));\n+        final CSVParser parser = new CSVParser(\"a\\r\\nb\\r\\nc\", CSVFormat.DEFAULT.withLineSeparator(CRLF));\n \n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());", "timestamp": 1350047730, "metainfo": ""}