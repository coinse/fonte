{"sha": "cacb79dab96cc98209cf14bf1b1fc6eb6f357c88", "log": "Changed the visibility of the Token types and the protected methods to package private  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n import java.io.InputStreamReader;\n import java.io.Reader;\n import java.util.ArrayList;\n+import java.util.List;\n \n \n /**\n  */\n public class CSVParser {\n \n-    /**\n-     * length of the initial token (content-)buffer\n-     */\n+    /** length of the initial token (content-)buffer */\n     private static final int INITIAL_TOKEN_LENGTH = 50;\n \n     // the token types\n-    /**\n-     * Token has no valid content, i.e. is in its initialized state.\n-     */\n-    protected static final int TT_INVALID = -1;\n-    /**\n-     * Token with content, at beginning or in the middle of a line.\n-     */\n-    protected static final int TT_TOKEN = 0;\n-    /**\n-     * Token (which can have content) when end of file is reached.\n-     */\n-    protected static final int TT_EOF = 1;\n-    /**\n-     * Token with content when end of a line is reached.\n-     */\n-    protected static final int TT_EORECORD = 2;\n-\n-    /**\n-     * Immutable empty String array.\n-     */\n+    /** Token has no valid content, i.e. is in its initialized state. */\n+    static final int TT_INVALID = -1;\n+    \n+    /** Token with content, at beginning or in the middle of a line. */\n+    static final int TT_TOKEN = 0;\n+    \n+    /** Token (which can have content) when end of file is reached. */\n+    static final int TT_EOF = 1;\n+    \n+    /** Token with content when end of a line is reached. */\n+    static final int TT_EORECORD = 2;\n+\n+    /** Immutable empty String array. */\n     private static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n     // the input stream\n     /**\n      * A record buffer for getLine(). Grows as necessary and is reused.\n      */\n-    private final ArrayList record = new ArrayList();\n+    private final List record = new ArrayList();\n     private final Token reusableToken = new Token();\n     private final CharBuffer wsBuf = new CharBuffer();\n     private final CharBuffer code = new CharBuffer(4);\n      * @throws IOException on parse error or input read-failure\n      */\n     public String[][] getAllValues() throws IOException {\n-        ArrayList records = new ArrayList();\n+        List records = new ArrayList();\n         String[] values;\n         String[][] ret = null;\n         while ((values = getLine()) != null) {\n     /**\n      * Convenience method for <code>nextToken(null)</code>.\n      */\n-    protected Token nextToken() throws IOException {\n+    Token nextToken() throws IOException {\n         return nextToken(new Token());\n     }\n \n      * @return the next token found\n      * @throws IOException on stream access error\n      */\n-    protected Token nextToken(Token tkn) throws IOException {\n+    Token nextToken(Token tkn) throws IOException {\n         wsBuf.clear(); // reuse\n \n         // get the last read char (required for empty line detection)\n      * @return the decoded character\n      * @throws IOException on wrong unicode escape sequence or read error\n      */\n-    protected int unicodeEscapeLexer(int c) throws IOException {\n+    private int unicodeEscapeLexer(int c) throws IOException {\n         int ret = 0;\n         // ignore 'u' (assume c==\\ now) and read 4 hex digits\n         c = in.read();", "timestamp": 1320848769, "metainfo": ""}