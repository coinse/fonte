{"sha": "e23e79e0ceacf38d3298e7f5207c4518ad2b5955", "log": "import of csv parser code, as donated by netcetera [code grant recorded]  ", "commit": "\n--- /dev/null\n+++ b/src/java/ch/netcetera/wake/core/format/csv/CSVParser.java\n+/*\n+ * The copyright to the computer program(s) herein is the property of\n+ * Netcetera AG, Switzerland. The program(s) may be used and/or copied\n+ * only with the written permission of Netcetera AG or in accordance\n+ * with the terms and conditions stipulated in the agreement/contract\n+ * under which the program(s) have been supplied.\n+ *\n+ * @(#) $Id: CSVParser.java,v 1.10 2004/09/30 13:37:10 hagger Exp $\n+ */\n+package ch.netcetera.wake.core.format.csv;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Vector;\n+\n+\n+/**\n+ * Parses cvs files according to the specified configuration.\n+ *\n+ * Because CSV appears in many different dialects the parser supports many\n+ * configuration settings. One of the most popular CSV format as supported\n+ * by the M$ corporation (excel-spreadsheets) are supported out-of-the-box\n+ * by the corresponding strategy setter (see {@link #setExcelStrategy()}).\n+ * \n+ * <p>Parsing of a csv-string having ';' as separator:</p>\n+ * <pre>\n+ *  String[][] data = \n+ *         (new CSVParser(new StringReader(\"a;b\\nc;d\"),';')).getAllValues();\n+ * </pre>\n+ * \n+ * <p>\n+ * Internal parser state is completely covered by the strategy\n+ * and the reader-state.</p>\n+ * \n+ * <p>see <a href=\"package-summary.html\">package documentation</a> \n+ * for more details</p>\n+ */\n+public class CSVParser {\n+  \n+  /** length of the initial token (content-)buffer */\n+  private static final int INITIAL_TOKEN_LENGTH = 50;\n+  \n+  // the token types\n+  protected static final int TT_INVALID = -1;\n+  protected static final int TT_TOKEN = 0;\n+  protected static final int TT_EOF = 1;\n+  protected static final int TT_EORECORD = 2;\n+   \n+  // the csv definition\n+  private char delimiter;\n+  private char encapsulator;\n+  private char commentStart;\n+  private boolean ignoreLeadingWhitespaces;\n+  private boolean interpretUnicodeEscapes;\n+  private boolean ignoreEmptyLines;\n+  \n+  // the input stream\n+  private ExtendedBufferedReader in;\n+  \n+  /**\n+   * Token is an internal token representation.\n+   * \n+   * It is used as contract between the lexer and the parser. \n+   */\n+  class Token {\n+    // token type see TT_xxx constants\n+    int type;\n+    // the content buffer\n+    StringBuffer content;\n+    // token ready flag: indicates a valid token (ready for the parser)\n+    boolean isReady;\n+    Token() {\n+      content = new StringBuffer(INITIAL_TOKEN_LENGTH);\n+      type = TT_INVALID;\n+      isReady = false;\n+    }\n+  }\n+  \n+  // ======================================================\n+  //  static parsers\n+  // ======================================================\n+  \n+  /**\n+   * Parses the given String according to the default CSV strategy.\n+   * \n+   * @return parsed String matrix (which is never null)\n+   * @throws IOException in case of error\n+   * @see #setCSVStrategy()\n+   */\n+  public static String[][] parse(String s) throws IOException {\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Null argument not allowed.\");\n+    }\n+    return (new CSVParser(new StringReader(s))).getAllValues();\n+  }\n+  \n+  /**\n+   * Parses the first line only according to the default CSV strategy.\n+   * \n+   * Parsing empty string will be handled as valid records containing zero\n+   * elements, so the following property holds: parseLine(\"\").length == 0.\n+   * \n+   * @return parsed String vector (which is never null)\n+   * @throws IOException in case of error\n+   * @see #setCSVStrategy()\n+   */\n+  public static String[] parseLine(String s) throws IOException {\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Null argument not allowed.\");\n+    }\n+    // uh,jh: make sure that parseLine(\"\").length == 0\n+    if (s.length() == 0) {\n+      return new String[0];\n+    }\n+    return (new CSVParser(new StringReader(s))).getLine();\n+  }\n+  \n+  // ======================================================\n+  //  the constructor\n+  // ======================================================\n+  \n+  /**\n+   * Default strategy for the parser follows the default CSV Strategy.\n+   * \n+   * @param input an InputStream containing \"csv-formatted\" stream\n+   * @see #setCSVStrategy()\n+   */\n+  public CSVParser(InputStream input) {\n+    this(new InputStreamReader(input));\n+  }\n+  \n+  /**\n+   * Default strategy for the parser follows the default CSV Strategy.\n+   * \n+   * @param input a Reader based on \"csv-formatted\" input\n+   * @see #setCSVStrategy()\n+   */\n+  public CSVParser(Reader input) {\n+    // note: must match default-CSV-strategy !!\n+    this(input, ',');\n+  }\n+  \n+  /**\n+   * Customized value delimiter parser.\n+   * \n+   * The parser follows the default CSV strategy as defined in \n+   * {@link #setCSVStrategy()} except for the delimiter setting.\n+   * \n+   * @param input a Reader based on \"csv-formatted\" input\n+   * @param delimiter a Char used for value separation\n+   */\n+  public CSVParser(Reader input, char delimiter) {\n+    this(input, delimiter, '\"', (char) 0);\n+  }\n+  \n+  /**\n+   * Customized csv parser.\n+   * \n+   * The parser parses according to the given CSV dialect settings.\n+   * Leading whitespaces are truncated whereas unicode escapes are\n+   * not interpreted.\n+   * \n+   * @param input a Reader based on \"csv-formatted\" input\n+   * @param delimiter a Char used for value separation\n+   * @param encapsulator a Char used as value encapsulation marker\n+   * @param commentStart a Char used for comment identification\n+   */\n+  public CSVParser(\n+    Reader input,\n+    char delimiter,\n+    char encapsulator,\n+    char commentStart) {\n+    this.in = new ExtendedBufferedReader(input);\n+    this.setDelimiter(delimiter);\n+    this.setEncapsulator(encapsulator);\n+    this.setCommentStart(commentStart);\n+    this.setIgnoreLeadingWhitespaces(true);\n+    this.setUnicodeEscapeInterpretation(false);\n+    this.setIgnoreEmptyLines(true);\n+  }\n+  \n+  // ======================================================\n+  //  the parser\n+  // ======================================================\n+  \n+  /**\n+   * Parses the CSV according to the given strategy\n+   * and returns the content as an array of records\n+   * (whereas records are arrays of single values).\n+   * <p>\n+   * The returned content starts at the current parse-position in\n+   * the stream.\n+   * \n+   * @return matrix of records x values ('null' when end of file)\n+   */\n+  public String[][] getAllValues() throws IOException {\n+    Vector records = new Vector();\n+    String[] values;\n+    String[][] ret = null;\n+    while ((values = getLine()) != null)  {\n+      records.add(values);\n+    }\n+    if (records.size() > 0) {\n+      ret = new String[records.size()][];\n+      records.toArray(ret);\n+    }\n+    return ret;\n+  }\n+  \n+  /**\n+   * Parses the CSV according to the given strategy\n+   * and returns the next csv-value as string.\n+   * \n+   * @return next value in the input stream ('null' when end of file)\n+   * @throws IOException\n+   */\n+  public String nextValue() throws IOException {\n+    Token tkn = nextToken();\n+    String ret = null;\n+    switch (tkn.type) {\n+      case TT_TOKEN:\n+      case TT_EORECORD: \n+        ret = tkn.content.toString();\n+        break;\n+      case TT_EOF:\n+        ret = null;\n+        break;\n+      case TT_INVALID:\n+      default:\n+        // error no token available (or error)\n+        throw new IOException(\n+          \"(line \" + getLineNumber() \n+          + \") invalid parse sequence\");\n+        // unreachable: break;\n+    }\n+    return ret;\n+  }\n+  \n+  /**\n+   * Parses from the current point in the stream til\n+   * the end of the current line.\n+   * \n+   * @return array of values til end of line \n+   *        ('null' when end of file has been reached)\n+   * @throws IOException on parse error or input read-failure\n+   */\n+  public String[] getLine() throws IOException {\n+    Vector record = new Vector();\n+    String[] ret = new String[0];\n+    Token tkn;\n+    while ((tkn = nextToken()).type == TT_TOKEN) {\n+      record.add(tkn.content.toString());  \n+    }\n+    // did we reached eorecord or eof ?\n+    switch (tkn.type) {\n+      case TT_EORECORD:\n+        record.add(tkn.content.toString());\n+        break;\n+      case TT_EOF:\n+        ret = null;\n+        break;\n+      case TT_INVALID:\n+      default:\n+        // error: throw IOException\n+        throw new IOException(\n+          \"(line \" + getLineNumber() \n+          + \") invalid parse sequence\");\n+        // unreachable: break;\n+    }\n+    if (record.size() > 0) {\n+      ret = new String[record.size()];\n+      record.toArray(ret);\n+    }\n+    return ret;\n+  }\n+  \n+  /**\n+   * Returns the current line number in the input stream.\n+   * \n+   * ATTENTION: in case your csv has multiline-values the returned\n+   *            number does not correspond to the record-number\n+   * \n+   * @return  current line number\n+   * @throws IOException\n+   */\n+  public int getLineNumber() throws IOException {\n+    return in.getLineNumber();  \n+  }\n+  \n+  // ======================================================\n+  //  the lexer(s)\n+  // ======================================================\n+ \n+ /**\n+  * Returns the next token \n+  * \n+  * a token coresponds to a term, a record change\n+  * or and end-of-file indicator\n+  */\n+  protected Token nextToken() throws IOException {\n+    Token tkn = new Token();\n+    StringBuffer wsBuf = new StringBuffer();\n+    // boolean skipEmptyLines = false;\n+    \n+    // get the last read char (required for empty line detection)\n+    int lastChar = in.readAgain();\n+    \n+    //  read the next char and set eol\n+    /* note: unfourtunately isEndOfLine may consumes a character silently.\n+     *       this has no effect outside of the method. so a simple workaround\n+     *       is to call 'readAgain' on the stream...\n+     *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)\n+     */\n+    int c = in.read();\n+    boolean eol = isEndOfLine(c);\n+    c = in.readAgain();\n+     \n+    //  empty line detection: eol AND (last char was EOL or beginning)\n+    while (ignoreEmptyLines && eol \n+      && (lastChar == '\\n' \n+      || lastChar == ExtendedBufferedReader.UNDEFINED) \n+      && !isEndOfFile(lastChar)) {\n+      // go on char ahead ...\n+      lastChar = c;\n+      c = in.read();\n+      eol = isEndOfLine(c);\n+      c = in.readAgain();\n+      // reached end of file without any content (empty line at the end)\n+      if (isEndOfFile(c)) {\n+        tkn.type = TT_EOF;\n+        return tkn;\n+      }\n+    }\n+\n+    // did we reached eof during the last iteration already ? TT_EOF\n+    if (isEndOfFile(lastChar)) {\n+      tkn.type = TT_EOF;\n+      return tkn;\n+    } \n+    \n+    //  important: make sure a new char gets consumed in each iteration\n+    while (!tkn.isReady) {\n+      // ignore whitespaces at beginning of a token\n+      while (isWhitespace(c) && !eol) {\n+        wsBuf.append((char) c);\n+        c = in.read();\n+        eol = isEndOfLine(c);\n+      }\n+      // ok, start of token reached: comment, encapsulated, or token\n+      if (c == commentStart) {\n+        // ignore everything till end of line and continue (incr linecount)\n+        in.readLine();\n+        tkn = nextToken();\n+      } else if (c == delimiter) {\n+        // empty token return TT_TOKEN(\"\")\n+        tkn.type = TT_TOKEN;\n+        tkn.isReady = true;\n+      } else if (eol) {\n+        // empty token return TT_EORECORD(\"\")\n+        tkn.content.append(\"\");\n+        tkn.type = TT_EORECORD;\n+        tkn.isReady = true;\n+      } else if (c == encapsulator) {\n+        // consume encapsulated token\n+        encapsulatedTokenLexer(tkn, c);\n+      } else if (isEndOfFile(c)) {\n+        // end of file return TT_EOF()\n+        tkn.content.append(\"\");\n+        tkn.type = TT_EORECORD;\n+        // tkn.type = TT_EOF;\n+        tkn.isReady = true;\n+      } else {\n+        // next token must be a simple token\n+        // add removed blanks when not ignoring whitespace chars...\n+        if (!this.ignoreLeadingWhitespaces) {\n+          tkn.content.append(wsBuf.toString());\n+        }\n+        simpleTokenLexer(tkn, c);\n+      }\n+    }\n+    return tkn;  \n+  }\n+  \n+  /**\n+   * A simple token lexer\n+   * \n+   * Simple token are tokens which are not surrounded by encapsulators.\n+   * A simple token might contain escaped delimiters (as \\, or \\;). The\n+   * token is finished when one of the following conditions become true:\n+   * <ul>\n+   *   <li>end of line has been reached (TT_EORECORD)</li>\n+   *   <li>end of stream has been reached (TT_EOF)</li>\n+   *   <li>an unescaped delimiter has been reached (TT_TOKEN)</li>\n+   * </ul>\n+   *  \n+   * @param tkn  the current token\n+   * @param c    the current character\n+   * @return the filled token\n+   * \n+   * @throws IOException on stream access error\n+   */\n+  private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n+    StringBuffer wsBuf = new StringBuffer();\n+    while (!tkn.isReady) {\n+      if (isEndOfLine(c)) {\n+        // end of record\n+        tkn.type = TT_EORECORD;\n+        tkn.isReady = true;\n+      } else if (isEndOfFile(c)) {\n+        // end of file\n+        // tkn.type = TT_EOF;\n+        tkn.type = TT_EORECORD;\n+        tkn.isReady = true;\n+      } else if (c == delimiter) {\n+        // end of token\n+        tkn.type = TT_TOKEN;\n+        tkn.isReady = true;\n+      } else if (c == '\\\\') {\n+        // handle escaped delimiters (remove escaping)\n+        if (in.lookAhead() == this.delimiter) {\n+          tkn.content.append((char) in.read());\n+        } else if (interpretUnicodeEscapes && in.lookAhead() == 'u') {\n+          // interpret unicode escaped chars (like \\u0070 -> p)\n+          tkn.content.append((char) unicodeEscapeLexer(c));\n+        } else {\n+          tkn.content.append((char) c);\n+        }\n+      } else if (isWhitespace(c)) {\n+        // gather whitespaces \n+        // (as long as they are not at the beginning of a token)\n+        if (tkn.content.length() > 0) {\n+          wsBuf.append((char) c);\n+        }\n+      } else {\n+        // prepend whitespaces (if we have)\n+        if (wsBuf.length() > 0) {\n+          tkn.content.append(wsBuf);\n+          wsBuf.delete(0, wsBuf.length());\n+        }\n+        tkn.content.append((char) c);\n+      }\n+      // get the next char\n+      if (!tkn.isReady) {\n+        c = in.read();\n+      }\n+    }\n+    return tkn;\n+  }\n+  \n+  \n+  /**\n+   * An encapsulated token lexer\n+   * \n+   * Encapsulated tokens are surrounded by the given encapsulating-string.\n+   * The encapsulator itself might be included in the token using a\n+   * doubling syntax (as \"\", '') or using escaping (as in \\\", \\').\n+   * Whitespaces before and after an encapsulated token are ignored.\n+   * \n+   * @param tkn    the current token\n+   * @param c      the current character\n+   * @return a valid token object\n+   * @throws IOException on invalid state\n+   */\n+  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {\n+    // save current line\n+    int startLineNumber = getLineNumber();\n+    // ignore the given delimiter\n+    // assert c == delimiter;\n+    c = in.read();\n+    while (!tkn.isReady) {\n+      if (c == encapsulator || c == '\\\\') {\n+        // check lookahead\n+        if (in.lookAhead() == encapsulator) {\n+          // double or escaped encapsulator -> add single encapsulator to token\n+          c = in.read();\n+          tkn.content.append((char) c);\n+        } else if (c == '\\\\' && in.lookAhead() == '\\\\') {\n+          // doubled escape character -> add single escape char to stream\n+          c = in.read();\n+          tkn.content.append((char) c);\n+        } else if (\n+          interpretUnicodeEscapes \n+          && c == '\\\\' \n+          && in.lookAhead() == 'u') {\n+          // interpret unicode escaped chars (like \\u0070 -> p)\n+          tkn.content.append((char) unicodeEscapeLexer(c));\n+        } else {\n+          // token finish mark reached: ignore ws till delimiter\n+          while (!tkn.isReady) {\n+            int n = in.lookAhead();\n+            if (n == delimiter) {\n+              tkn.type = TT_TOKEN;\n+              tkn.isReady = true;\n+            } else if (isEndOfFile(n)) {\n+              // tkn.type = TT_EOF;\n+              tkn.type = TT_EORECORD;\n+              tkn.isReady = true;\n+            } else if (isEndOfLine(n)) {\n+              // ok eo token reached\n+              tkn.type = TT_EORECORD;\n+              tkn.isReady = true;\n+            } else if (!isWhitespace(n)) {\n+              // error invalid char between token and next delimiter\n+              throw new IOException(\n+                \"(line \" + getLineNumber() \n+                + \") invalid char between encapsualted token end delimiter\"\n+              );\n+            }\n+            c = in.read();\n+          }\n+        }\n+      } else if (isEndOfFile(c)) {\n+        // error condition (end of file before end of token)\n+        throw new IOException(\n+          \"(startline \" + startLineNumber + \")\"\n+          + \"eof reached before encapsulated token finished\"\n+          );\n+      } else {\n+        // consume character\n+        tkn.content.append((char) c);\n+      }\n+      // get the next char\n+      if (!tkn.isReady) {\n+        c = in.read();  \n+      }\n+    }\n+    return tkn;\n+  }\n+  \n+  \n+  /**\n+   * Decodes Unicode escapes \n+   * \n+   * Interpretation of \"\\\\uXXXX\" escape sequences\n+   * where XXXX is a hex-number\n+   * @param c\n+   * @return the decoded character\n+   * @throws IOException on wrong unicode escape sequence or read error\n+   */\n+  protected int unicodeEscapeLexer(int c) throws IOException {\n+    int ret = 0;\n+    // ignore 'u' (assume c==\\ now) and read 4 hex digits\n+    c = in.read();\n+    StringBuffer code = new StringBuffer(4);\n+    try {\n+      for (int i = 0; i < 4; i++) {\n+        c  = in.read();\n+        if (isEndOfFile(c) || isEndOfLine(c)) {\n+          throw new NumberFormatException(\"number too short\");\n+        }\n+        code.append((char) c);\n+      }\n+      ret = Integer.parseInt(code.toString(), 16);\n+    } catch (NumberFormatException e) {\n+      throw new IOException(\n+        \"(line \" + getLineNumber() + \") Wrong unicode escape sequence found '\" \n+        + code.toString() + \"'\" + e.toString());\n+    }\n+    return ret;\n+  }\n+  \n+  // ======================================================\n+  //  strategy utilities\n+  // ======================================================\n+  \n+  /**\n+   * Sets the \"Default CSV\" settings.\n+   * \n+   * The default csv settings are relatively restrictive but implement\n+   * something like the \"least-common-basis\" of CSV.\n+   * \n+   * Values are separated by ',' (as the C in \"CSV\"). Complex values must\n+   * be surrounded by '\"'. Comments are not supported. Leading whitespaces\n+   * are ignored, unicode escapes are not interpreted and empty lines\n+   * are skiped.\n+   */\n+  public void setCSVStrategy() {\n+    setStrategy(',', '\"', (char) 0, true, false, true);\n+  }\n+  \n+  /**\n+   * Sets the \"Excel CSV\" settings.\n+   * \n+   * There are companies out there which interpret \"C\" as an abbreviation for\n+   * \"Semicolon\". For these companies the following settings might be\n+   * appropriate: \n+   * <p>\n+   * Delimiter Semicolon ';', Complex-values surrounded by '\"', leading \n+   * whitespaces are not ignored and unicode escapes are not interpreted.\n+   */\n+  public void setExcelStrategy() {\n+    setStrategy(';', '\"', (char) 0, false, false, false);\n+  }\n+  \n+  /**\n+   * Customized CSV strategy setter.\n+   * \n+   * @param delimiter a Char used for value separation\n+   * @param encapsulator a Char used as value encapsulation marker\n+   * @param commentStart a Char used for comment identification\n+   * @param ignoreLeadingWhitespace TRUE when leading whitespaces should be\n+   *                                ignored\n+   * @param interpretUnicodeEscapes TRUE when unicode escapes should be \n+   *                                interpreted\n+   * @param ignoreEmptyLines TRUE when the parser should skip emtpy lines\n+   */\n+  public void setStrategy(\n+    char delimiter, \n+    char encapsulator, \n+    char commentStart, \n+    boolean ignoreLeadingWhitespace, \n+    boolean interpretUnicodeEscapes,\n+    boolean ignoreEmptyLines) {\n+    this.setDelimiter(delimiter);\n+    this.setEncapsulator(encapsulator);\n+    this.setCommentStart(commentStart);\n+    this.setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);\n+    this.setUnicodeEscapeInterpretation(interpretUnicodeEscapes);\n+    this.setIgnoreEmptyLines(ignoreEmptyLines);\n+  }\n+  \n+  /**\n+   * Set the desired delimiter\n+   *\n+   * @param c a Char used for value separation\n+   */\n+  public void setDelimiter(char c) {\n+    this.delimiter = c;\n+  }\n+  \n+  /**\n+   * Gets the delimiter.\n+   *  \n+   * @return the delimiter character\n+   */\n+  public char getDelimiter() {\n+    return this.delimiter;\n+  }\n+  \n+  /**\n+   * Set the desired encapsulator\n+   * \n+   * @param c a Char used as value encapsulation marker\n+   */\n+  public void setEncapsulator(char c) {\n+    this.encapsulator = c;\n+  }\n+  \n+  /**\n+   * Gets the encapsulator character.\n+   *  \n+   * @return the encapsulator marker\n+   */\n+  public char getEncapsulator() {\n+    return this.encapsulator;\n+  }\n+  \n+  /**\n+   * Set the desired comment start character\n+   * \n+   * @param c a Char used for comment identification\n+   */\n+  public void setCommentStart(char c) {\n+    this.commentStart = c;\n+  }\n+  \n+  /**\n+   * Gets the comment identifier\n+   * \n+   * @return the comment identifier character\n+   */\n+  public char getCommentStart() {\n+    return this.commentStart;\n+  }\n+  \n+  /**\n+   * Enables unicode escape interpretation\n+   * \n+   * @param b TRUE when interpretation should be enabled\n+   */\n+  public void setUnicodeEscapeInterpretation(boolean b) {\n+    this.interpretUnicodeEscapes = b;\n+  }\n+  \n+  /**\n+   * Shows wether unicode interpretation is enabled\n+   * \n+   * @return TRUE when unicode interpretation is enabled\n+   */\n+  public boolean getUnicodeEscapeInterpretation() {\n+    return this.interpretUnicodeEscapes;\n+  }\n+  \n+  /**\n+   * Sets the ignore-leading-whitespaces behaviour.\n+   * \n+   * Should the lexer ignore leading whitespaces when parsing non \n+   * encapsulated tokens\n+   * \n+   * @param b TRUE when leading whitespaces should be ignored\n+   */\n+  public void setIgnoreLeadingWhitespaces(boolean b) {\n+    this.ignoreLeadingWhitespaces = b;\n+  }\n+  \n+  /**\n+   * Shows wether unicode interpretation is enabled\n+   * \n+   * @return TRUE when unicode interpretation is enabled\n+   */\n+  public boolean getIgnoreLeadingWhitespaces() {\n+    return this.ignoreLeadingWhitespaces;\n+  }\n+  \n+  /**\n+   * Sets the ignore-empty-line behaviour.\n+   * \n+   * When set to 'true' empty lines in the input will be ignored.\n+   * \n+   * @param b\n+   */\n+  public void setIgnoreEmptyLines(boolean b) {\n+    this.ignoreEmptyLines = b;  \n+  }\n+  \n+  // ======================================================\n+  //  Character class checker\n+  // ======================================================\n+  \n+  /**\n+   * @return true if the given char is a whitespache character\n+   */\n+  private boolean isWhitespace(int c) {\n+    return Character.isWhitespace((char) c);\n+  }\n+  \n+  /**\n+   * Greedy - accepts \\n and \\r\\n \n+   * This checker consumes silently the second control-character...\n+   * \n+   * @return true if the given character is a line-terminator\n+   */\n+  private boolean isEndOfLine(int c) throws IOException {\n+    // check if we have \\r\\n...\n+    if (c == '\\r') {\n+      if (in.lookAhead() == '\\n') {\n+        // note: does not change c outside of this method !!\n+        c = in.read();\n+      }\n+    }\n+    return (c == '\\n');\n+  }\n+  \n+  /**\n+   * @return true if the given character indicates end of file\n+   */\n+  private boolean isEndOfFile(int c) {\n+    return c == ExtendedBufferedReader.END_OF_STREAM;\n+  }\n+}\n--- /dev/null\n+++ b/src/java/ch/netcetera/wake/core/format/csv/CSVPrinter.java\n+/*\n+ * Copyright (C) 2002-2004 by Netcetera AG.\n+ * All rights reserved.\n+ *\n+ * The copyright to the computer program(s) herein is the property of\n+ * Netcetera AG, Switzerland.  The program(s) may be used and/or copied\n+ * only with the written permission of Netcetera AG or in accordance\n+ * with the terms and conditions stipulated in the agreement/contract\n+ * under which the program(s) have been supplied.\n+ *\n+ * @(#) $Id: CSVPrinter.java,v 1.4 2004/08/10 12:35:27 rgrunder Exp $\n+ */\n+\n+package ch.netcetera.wake.core.format.csv;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+/**\n+ * Print values as a comma separated list.\n+ */\n+public class CSVPrinter {\n+\n+  /** The place that the values get written. */\n+  protected PrintWriter out;\n+\n+  /** True if we just began a new line. */\n+  protected boolean newLine = true;\n+\n+  /** Character used to start comments. (Default is '#') */\n+  protected char commentStart = '#';\n+  \n+  /** Character used to separate entities. (Default is ',') */\n+  protected char separatorChar = ',';\n+\n+  /**\n+   * Create a printer that will print values to the given\n+   * stream. Character to byte conversion is done using\n+   * the default character encoding. Comments will be\n+   * written using the default comment character '#'.\n+   *\n+   * @param out stream to which to print.\n+   */\n+  public CSVPrinter(OutputStream out) {\n+    this.out = new PrintWriter(out);\n+  }\n+\n+\n+  /**\n+   * Create a printer that will print values to the given\n+   * stream. Comments will be\n+   * written using the default comment character '#'.\n+   *\n+   * @param out stream to which to print.\n+   */\n+  public CSVPrinter(Writer out) {\n+    if (out instanceof PrintWriter) {\n+      this.out = (PrintWriter) out;\n+    } else {\n+      this.out = new PrintWriter(out);\n+    }\n+  }\n+\n+\n+  /**\n+   * Create a printer that will print values to the given\n+   * stream. Character to byte conversion is done using\n+   * the default character encoding.\n+   *\n+   * @param out stream to which to print.\n+   * @param commentStart Character used to start comments.\n+   */\n+  public CSVPrinter(OutputStream out, char commentStart) {\n+    this(out);\n+    this.commentStart = commentStart;\n+  }\n+\n+\n+  /**\n+   * Create a printer that will print values to the given\n+   * stream.\n+   *\n+   * @param out stream to which to print.\n+   * @param commentStart Character used to start comments.\n+   */\n+  public CSVPrinter(Writer out, char commentStart) {\n+    this(out);\n+    this.commentStart = commentStart;\n+  }\n+\n+  /**\n+   * Gets the comment start character.\n+   * \n+   * @return the commentStart character\n+   */\n+  public char getCommentStart() {\n+    return commentStart;\n+  }\n+  \n+  /**\n+   * Sets the comment start character.\n+   * \n+   * @param commentStart commentStart character to set.\n+   */\n+  public void setCommentStart(char commentStart) {\n+    this.commentStart = commentStart;\n+  }\n+  \n+  /**\n+   * Gets the separator character.\n+   * \n+   * @return Returns the separatorChar.\n+   */\n+  public char getSeparatorChar() {\n+    return separatorChar;\n+  }\n+  /**\n+   * Sets the separator character.\n+   * \n+   * @param separatorChar The separatorChar to set.\n+   */\n+  public void setSeparatorChar(char separatorChar) {\n+    this.separatorChar = separatorChar;\n+  }\n+  \n+  /**\n+   * Print the string as the last value on the line. The value\n+   * will be quoted if needed.\n+   *\n+   * @param value value to be outputted.\n+   */\n+  public void println(String value) {\n+    print(value);\n+    out.println();\n+    out.flush();\n+    newLine = true;\n+  }\n+\n+\n+  /**\n+   * Output a blank line\n+   */\n+  public void println() {\n+    out.println();\n+    out.flush();\n+    newLine = true;\n+  }\n+\n+\n+  /**\n+   * Print a single line of comma separated values.\n+   * The values will be quoted if needed.  Quotes and\n+   * newLine characters will be escaped.\n+   *\n+   * @param values values to be outputted.\n+   */\n+  public void println(String[] values) {\n+    for (int i = 0; i < values.length; i++) {\n+      print(values[i]);\n+    }\n+    out.println();\n+    out.flush();\n+    newLine = true;\n+  }\n+\n+\n+  /**\n+   * Print several lines of comma separated values.\n+   * The values will be quoted if needed.  Quotes and\n+   * newLine characters will be escaped.\n+   *\n+   * @param values values to be outputted.\n+   */\n+  public void println(String[][] values) {\n+    for (int i = 0; i < values.length; i++) {\n+      println(values[i]);\n+    }\n+    if (values.length == 0) {\n+      out.println();\n+    }\n+    out.flush();\n+    newLine = true;\n+  }\n+\n+\n+  /**\n+   * Put a comment among the comma separated values.\n+   * Comments will always begin on a new line and occupy a\n+   * least one full line. The character specified to star\n+   * comments and a space will be inserted at the beginning of\n+   * each new line in the comment.\n+   *\n+   * @param comment the comment to output\n+   */\n+  public void printlnComment(String comment) {\n+    if (!newLine) {\n+      out.println();\n+    }\n+    out.print(commentStart);\n+    out.print(' ');\n+    for (int i = 0; i < comment.length(); i++) {\n+      char c = comment.charAt(i);\n+      switch (c) {\n+        case '\\r' :\n+          if (i + 1 < comment.length() && comment.charAt(i + 1) == '\\n') {\n+            i++;\n+          }\n+          // break intentionally excluded.\n+        case '\\n' :\n+          out.println();\n+          out.print(commentStart);\n+          out.print(' ');\n+          break;\n+        default :\n+          out.print(c);\n+          break;\n+      }\n+    }\n+    out.println();\n+    out.flush();\n+    newLine = true;\n+  }\n+\n+\n+  /**\n+   * Print the string as the next value on the line. The value\n+   * will be quoted if needed.\n+   *\n+   * @param value value to be outputted.\n+   */\n+  public void print(String value) {\n+    boolean quote = false;\n+    if (value.length() > 0) {\n+      char c = value.charAt(0);\n+      if (newLine\n+        && (c < '0'\n+          || (c > '9' && c < 'A')\n+          || (c > 'Z' && c < 'a')\n+          || (c > 'z'))) {\n+        quote = true;\n+      }\n+      if (c == ' ' || c == '\\f' || c == '\\t') {\n+        quote = true;\n+      }\n+      for (int i = 0; i < value.length(); i++) {\n+        c = value.charAt(i);\n+        if (c == '\"' || c == separatorChar || c == '\\n' || c == '\\r') {\n+          quote = true;\n+        }\n+      }\n+      if (c == ' ' || c == '\\f' || c == '\\t') {\n+        quote = true;\n+      }\n+    } else if (newLine) {\n+      // always quote an empty token that is the first\n+      // on the line, as it may be the only thing on the\n+      // line. If it were not quoted in that case,\n+      // an empty line has no tokens.\n+      quote = true;\n+    }\n+    if (newLine) {\n+      newLine = false;\n+    } else {\n+      out.print(separatorChar);\n+    }\n+    if (quote) {\n+      out.print(escapeAndQuote(value));\n+    } else {\n+      out.print(value);\n+    }\n+    out.flush();\n+  }\n+\n+\n+  /**\n+   * Converts an array of string values into a single CSV line. All\n+   * <code>null</code> values are converted to the string <code>\"null\"</code>,\n+   * all strings equal to <code>\"null\"</code> will additionally get quotes\n+   * around.\n+   *\n+   * @param values the value array\n+   * @return the CSV string, will be an empty string if the length of the\n+   * value array is 0\n+   */\n+  public static String printLine(String[] values) {\n+\n+    // set up a CSVPrinter\n+    StringWriter csvWriter = new StringWriter();\n+    CSVPrinter csvPrinter = new CSVPrinter(csvWriter);\n+\n+    // check for null values an \"null\" as strings and convert them\n+    // into the strings \"null\" and \"\\\"null\\\"\"\n+    for (int i = 0; i < values.length; i++) {\n+      if (values[i] == null) {\n+        values[i] = \"null\";\n+      } else if (values[i].equals(\"null\")) {\n+        values[i] = \"\\\"null\\\"\";\n+      }\n+    }\n+\n+    // convert to CSV\n+    csvPrinter.println(values);\n+\n+    // as the resulting string has \\r\\n at the end, we will trim that away\n+    return csvWriter.toString().trim();\n+  }\n+\n+\n+  /**\n+   * Enclose the value in quotes and escape the quote\n+   * and comma characters that are inside.\n+   *\n+   * @param value needs to be escaped and quoted\n+   * @return the value, escaped and quoted\n+   */\n+  private static String escapeAndQuote(String value) {\n+    // the initial count is for the preceding and trailing quotes\n+    int count = 2;\n+    for (int i = 0; i < value.length(); i++) {\n+      switch (value.charAt(i)) {\n+        case '\\\"' :\n+        case '\\n' :\n+        case '\\r' :\n+        case '\\\\' :\n+          count++;\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+    StringBuffer sb = new StringBuffer(value.length() + count);\n+    sb.append('\"');\n+    for (int i = 0; i < value.length(); i++) {\n+      char c = value.charAt(i);\n+      switch (c) {\n+        case '\\\"' :\n+          sb.append(\"\\\\\\\"\");\n+          break;\n+        case '\\n' :\n+          sb.append(\"\\\\n\");\n+          break;\n+        case '\\r' :\n+          sb.append(\"\\\\r\");\n+          break;\n+        case '\\\\' :\n+          sb.append(\"\\\\\\\\\");\n+          break;\n+        default :\n+          sb.append(c);\n+      }\n+    }\n+    sb.append('\"');\n+    return sb.toString();\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/ch/netcetera/wake/core/format/csv/ExtendedBufferedReader.java\n+/*\n+* playground\n+*\n+* Copyright (C) 2004 by Netcetera AG.\n+* All rights reserved.\n+*\n+* The copyright to the computer program(s) herein is the property of\n+* Netcetera AG, Switzerland. The program(s) may be used and/or copied\n+* only with the written permission of Netcetera AG or in accordance\n+* with the terms and conditions stipulated in the agreement/contract\n+* under which the program(s) have been supplied.\n+*\n+* @(#) $Id: ExtendedBufferedReader.java,v 1.3 2004/09/30 13:37:10 hagger Exp $\n+*/\n+package ch.netcetera.wake.core.format.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+/**\n+ * ExtendedBufferedReader\n+ *\n+ * A special reader decorater which supports more\n+ * sophisticated access to the underlying reader object.\n+ * \n+ * In especialy the reader supports a look-ahead option,\n+ * which allows you to see the next char returned by\n+ * next().\n+ * Furthermore the skip-method supports skipping until\n+ * (but excluding) a given char. Similar functionality\n+ * is supported by the reader as well.\n+ * \n+ */\n+public class ExtendedBufferedReader extends BufferedReader  {\n+\n+  \n+  /** the end of stream symbol */\n+  public static final int END_OF_STREAM = -1;\n+  /** undefined state for the lookahead char */\n+  public static final int UNDEFINED = -2;\n+  \n+  /** the lookahead chars */\n+  private int lookaheadChar = UNDEFINED;\n+  /** the last char returned */\n+  private int lastChar = UNDEFINED;\n+  /** the line counter */\n+  private int lineCounter = 0;\n+  /**\n+   * Created extended buffered reader using default buffer-size\n+   *\n+   */\n+  public ExtendedBufferedReader(Reader r) {\n+    super(r);\n+    /* note uh: do not fetch the first char here,\n+     *          because this might block the method!\n+     */\n+  }\n+    \n+  /**\n+   * Create extended buffered reader using the given buffer-size\n+   */\n+  public ExtendedBufferedReader(Reader r, int bufSize) {\n+    super(r, bufSize);\n+    /* note uh: do not fetch the first char here,\n+     *          because this might block the method!\n+     */\n+  }\n+  \n+  /**\n+   * Reads the next char from the input stream.\n+   * @return the next char or END_OF_STREAM if end of stream has been reached.\n+   */\n+  public int read() throws IOException {\n+    // initalize the lookahead\n+    if (lookaheadChar == UNDEFINED) {\n+      lookaheadChar = super.read();\n+    }\n+    lastChar = lookaheadChar;\n+    lookaheadChar = super.read();\n+    if (lastChar == '\\n') {\n+      lineCounter++;\n+    } \n+    return lastChar;\n+  }\n+  \n+  /**\n+   * Returns the last read character again.\n+   * \n+   * @return the last read char or UNDEFINED\n+   */\n+  public int readAgain() {\n+    return lastChar;  \n+  }\n+  \n+  /**\n+   * Non-blocking reading of len chars into buffer buf starting\n+   * at bufferposition off.\n+   * \n+   * performs an iteratative read on the underlying stream\n+   * as long as the following conditions hold:\n+   *   - less than len chars have been read\n+   *   - end of stream has not been reached\n+   *   - next read is not blocking\n+   * \n+   * @return nof chars actually read or END_OF_STREAM\n+   */\n+  public int read(char[] buf, int off, int len) throws IOException {\n+    // do not claim if len == 0\n+    if (len == 0) {\n+      return 0;\n+    } \n+    \n+    // init lookahead, but do not block !!\n+    if (lookaheadChar == UNDEFINED) {\n+        if (ready()) {\n+         lookaheadChar = super.read();\n+        } else {\n+          return -1;\n+        }\n+    }\n+    // 'first read of underlying stream'\n+    if (lookaheadChar == -1) {\n+      return -1;\n+    }\n+    // continue until the lookaheadChar would block\n+    int cOff = off;\n+    while (len > 0 && ready()) {\n+      if (lookaheadChar == -1) {\n+        // eof stream reached, do not continue\n+        return cOff - off;\n+      } else {\n+        buf[cOff++] = (char) lookaheadChar;\n+        if (lookaheadChar == '\\n') {\n+          lineCounter++;\n+        } \n+        lastChar = lookaheadChar;\n+        lookaheadChar = super.read();\n+        len--;\n+      }\n+    }\n+    return cOff - off;\n+  }\n+ \n+ /**\n+  * Reads all characters up to (but not including) the given character.\n+  * \n+  * @param c the character to read up to\n+  * @return the string up to the character <code>c</code>\n+  * @throws IOException\n+  */\n+ public String readUntil(char c) throws IOException {\n+   if (lookaheadChar == UNDEFINED) {\n+     lookaheadChar = super.read();\n+   }\n+   StringBuffer ret = new StringBuffer(\"\");\n+   while (lookaheadChar != c && lookaheadChar != END_OF_STREAM) {\n+     ret.append((char) lookaheadChar);\n+     if (lookaheadChar == '\\n') {\n+       lineCounter++;\n+     } \n+     lastChar = lookaheadChar;\n+     lookaheadChar = super.read();\n+   }\n+   return ret.toString();    \n+ }\n+ \n+ /**\n+  * @return A String containing the contents of the line, not \n+  *         including any line-termination characters, or null \n+  *         if the end of the stream has been reached\n+  */\n+  public String readLine() throws IOException {\n+    \n+    if (lookaheadChar == UNDEFINED) {\n+      lookaheadChar = super.read(); \n+    }\n+    \n+    StringBuffer ret = new StringBuffer(\"\");\n+    \n+    // return null if end of stream has been reached\n+    if (lookaheadChar == END_OF_STREAM) {\n+      return null;\n+    }\n+    // do we have a line termination already\n+    char laChar = (char) lookaheadChar;\n+    if (laChar == '\\n' || laChar == '\\r') {\n+      lastChar = lookaheadChar;\n+      lookaheadChar = super.read();\n+      // ignore '\\r\\n' as well\n+      if ((char) lookaheadChar == '\\n') {\n+        lastChar = lookaheadChar;\n+        lookaheadChar = super.read();\n+      }\n+      lineCounter++;\n+      return ret.toString();\n+    }\n+    \n+    // create the rest-of-line return and update the lookahead\n+    ret.append(String.valueOf(laChar));\n+    String restOfLine = super.readLine();\n+    lastChar = lookaheadChar;\n+    lookaheadChar = super.read();\n+    if (restOfLine != null) {\n+      ret.append(restOfLine);\n+    }\n+    lineCounter++;\n+    return ret.toString();\n+  }\n+  \n+  /**\n+   * Skips char in the stream\n+   * \n+   * ATTENTION: invalidates the line-counter !!!!!\n+   * \n+   * @return nof skiped chars\n+   */\n+  public long skip(long n) throws IllegalArgumentException, IOException  {\n+    \n+    if (lookaheadChar == UNDEFINED) {\n+      lookaheadChar = super.read();   \n+    }\n+    \n+    // illegal argument\n+    if (n < 0) {\n+      throw new IllegalArgumentException(\"negative argument not supported\");  \n+    }\n+    \n+    // no skipping\n+    if (n == 0 || lookaheadChar == END_OF_STREAM) {\n+      return 0;\n+    } \n+    \n+    // skip and reread the lookahead-char\n+    long skiped = 0;\n+    if (n > 1) {\n+      skiped = super.skip(n - 1);\n+    }\n+    lookaheadChar = super.read();\n+    // fixme uh: we should check the skiped sequence for line-terminations...\n+    lineCounter = Integer.MIN_VALUE;\n+    return skiped + 1;\n+  }\n+  \n+  /**\n+   * Skips all chars in the input until (but excluding) the given char\n+   * \n+   * @param c\n+   * @return\n+   * @throws IllegalArgumentException\n+   * @throws IOException\n+   */\n+  public long skipUntil(char c) throws IllegalArgumentException, IOException {\n+    if (lookaheadChar == UNDEFINED) {\n+      lookaheadChar = super.read();   \n+    }\n+    long counter = 0;\n+    while (lookaheadChar != c && lookaheadChar != END_OF_STREAM) {\n+      if (lookaheadChar == '\\n') {\n+        lineCounter++;\n+      } \n+      lookaheadChar = super.read();\n+      counter++;\n+    }\n+    return counter;\n+  }\n+  \n+  /**\n+   * Returns the next char in the stream without consuming it.\n+   * \n+   * Remember the next char read by read(..) will always be\n+   * identical to lookAhead().\n+   * \n+   * @return the next char (without consuming it) or END_OF_STREAM\n+   */\n+  public int lookAhead() throws IOException {\n+    if (lookaheadChar == UNDEFINED) {\n+      lookaheadChar = super.read();\n+    }\n+    return lookaheadChar;\n+  }\n+  \n+  \n+  /**\n+   * Returns the nof line read\n+   * ATTENTION: the skip-method does invalidate the line-number counter\n+   * \n+   * @return the current-line-number (or -1)\n+   */ \n+  public int getLineNumber() {\n+    if (lineCounter > -1) {\n+      return lineCounter;\n+    } else {\n+      return -1;\n+    }\n+  }\n+  public boolean markSupported() {\n+    /* note uh: marking is not supported, cause we cannot\n+     *          see into the future...\n+     */\n+    return false;\n+  }\n+  \n+}\n--- /dev/null\n+++ b/src/test/ch/netcetera/wake/core/format/FormatTests.java\n+/*\n+ * Copyright (C) 2004 by Netcetera AG.\n+ * All rights reserved.\n+ *\n+ * The copyright to the computer program(s) herein is the property of\n+ * Netcetera AG, Switzerland.  The program(s) may be used and/or copied\n+ * only with the written permission of Netcetera AG or in accordance\n+ * with the terms and conditions stipulated in the agreement/contract\n+ * under which the program(s) have been supplied.\n+ *\n+ * @(#) $Id: FormatTests.java,v 1.3 2004/08/10 12:38:45 rgrunder Exp $\n+ */\n+package ch.netcetera.wake.core.format;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import ch.netcetera.wake.core.format.csv.CSVParserTest;\n+import ch.netcetera.wake.core.format.csv.CSVPrinterTest;\n+import ch.netcetera.wake.core.format.csv.ExtendedBufferedReaderTest;\n+\n+\n+public final class FormatTests {\n+\n+  protected FormatTests() {\n+    // empty\n+  }\n+\n+  public static void main(String[] args) {\n+    junit.textui.TestRunner.run(suite());\n+  }\n+\n+  public static Test suite() {\n+    TestSuite suite = new TestSuite(\"wake.core.format tests\");\n+    suite.addTest(ExtendedBufferedReaderTest.suite());\n+    suite.addTest(CSVParserTest.suite());\n+    suite.addTest(CSVPrinterTest.suite());\n+    return suite;\n+  }\n+}\n--- /dev/null\n+++ b/src/test/ch/netcetera/wake/core/format/csv/CSVParserTest.java\n+/*\n+* The copyright to the computer program(s) herein is the property of\n+* Netcetera AG, Switzerland. The program(s) may be used and/or copied\n+* only with the written permission of Netcetera AG or in accordance\n+* with the terms and conditions stipulated in the agreement/contract\n+* under which the program(s) have been supplied.\n+*\n+* @(#) $Id: CSVParserTest.java,v 1.5 2004/05/18 09:41:26 uhardegg Exp $\n+*/\n+package ch.netcetera.wake.core.format.csv;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * CSVParserTest\n+ *\n+ * The test are organized in three different sections:\n+ * The 'setter/getter' section, the lexer section and finally the parser \n+ * section. In case a test fails, you should follow a top-down approach for \n+ * fixing a potential bug (its likely that the parser itself fails if the lexer\n+ * has problems...).\n+ */\n+public class CSVParserTest extends TestCase {\n+  \n+  /**\n+   * TestCSVParser\n+   */\n+  class TestCSVParser extends CSVParser {\n+    TestCSVParser(Reader in) {\n+      super(in);\n+    }\n+    public String testNextToken() throws IOException {\n+      Token t = super.nextToken();\n+      String tmp = Integer.toString(t.type) + \";\" + t.content + \";\";\n+      System.out.println(\"token=\" + tmp);\n+      return tmp;\n+    }\n+  }\n+  \n+  /**\n+   * Constructor for CSVParserTest.\n+   * @param arg0\n+   */\n+  public CSVParserTest(String arg0) {\n+    super(arg0);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(CSVParserTest.class);\n+  }\n+\n+\n+  // ======================================================\n+  //   getters / setters\n+  // ======================================================\n+  public void testGetSetCommentStart() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    parser.setCommentStart('#');\n+    assertEquals(parser.getCommentStart(), '#');\n+    parser.setCommentStart('!');\n+    assertEquals(parser.getCommentStart(), '!');\n+  }\n+\n+  public void testGetSetEncapsulator() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    parser.setEncapsulator('\"');\n+    assertEquals(parser.getEncapsulator(), '\"');\n+    parser.setEncapsulator('\\'');\n+    assertEquals(parser.getEncapsulator(), '\\'');\n+  }\n+\n+  public void testGetSetDelimiter() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    parser.setDelimiter(';');\n+    assertEquals(parser.getDelimiter(), ';');\n+    parser.setDelimiter(',');\n+    assertEquals(parser.getDelimiter(), ',');\n+    parser.setDelimiter('\\t');\n+    assertEquals(parser.getDelimiter(), '\\t');\n+  }\n+\n+  public void testSetCSVStrategy() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    // default settings\n+    assertEquals(parser.getCommentStart(), '\\0');\n+    assertEquals(parser.getEncapsulator(), '\"');\n+    assertEquals(parser.getDelimiter(), ',');\n+    // explicit csv settings\n+    parser.setCSVStrategy();\n+    assertEquals(parser.getCommentStart(), '\\0');\n+    assertEquals(parser.getEncapsulator(), '\"');\n+    assertEquals(parser.getDelimiter(), ',');\n+  }\n+  \n+  \n+  \n+  // ======================================================\n+  //   lexer tests\n+  // ======================================================\n+  \n+  // single line (without comment)\n+  public void testNextToken1() throws IOException {\n+    String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setCSVStrategy();\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    assertEquals(CSVParser.TT_TOKEN + \";abc;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";def;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";hijk;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";lmnop;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";qrst;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";uv;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";wxy;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";z;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());  \n+  }\n+  \n+  // multiline including comments (and empty lines)\n+  public void testNextToken2() throws IOException {\n+    /*   file:   1,2,3,\n+     *           a,b,c\n+     *\n+     *           # this is a comment \n+     *           d,e,\n+     * \n+     */\n+    String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setIgnoreEmptyLines(false);\n+    parser.setCSVStrategy();\n+    parser.setCommentStart('#');\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";2;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";3;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";b x;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";c;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";d;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";e;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());    \n+    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());    \n+    \n+  }\n+ \n+  // simple token with escaping\n+  public void testNextToken3() throws IOException {\n+    /* file: a,\\,,b\n+     *       \\,,\n+     */\n+    String code = \"a,\\\\,,b\\n\\\\,,\";\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setCSVStrategy();\n+    parser.setCommentStart('#');\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";,;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";,;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+  }\n+  \n+  // encapsulator tokenizer (sinle line)\n+  public void testNextToken4() throws IOException {\n+    /* file:  a,\"foo\",b\n+     *        a,   \" foo\",b\n+     *        a,\"foo \"   ,b\n+     *        a,  \" foo \" ,b\n+     */ \n+     String code = \n+      \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n+     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+     parser.setCSVStrategy();\n+     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \";foo;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \"; foo;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \";foo ;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_TOKEN + \"; foo ;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());    \n+  }\n+  \n+  // encapsulator tokenizer (multi line, delimiter in string)\n+  public void testNextToken5() throws IOException {   \n+    String code = \n+      \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\",\\\"\\\\\\\"\\\",\\\"\\\"\\\"\\\"\";\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setCSVStrategy();\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+    assertEquals(\n+      CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\", \n+      parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";\\n\\t \\n;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";\\\";\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";\\\";\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+    \n+  }\n+  \n+  // change delimiters, comment, encapsulater\n+  public void testNextToken6() throws IOException {\n+    /* file: a;'b and \\' more\n+     *       '\n+     *       !comment;;;;\n+     *       ;;\n+     */\n+    String code = \"a;'b and \\\\' more\\n'\\n!comment;;;;\\n;;\";\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setDelimiter(';');\n+    parser.setEncapsulator('\\'');\n+    parser.setCommentStart('!');\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+    assertEquals(\n+      CSVParser.TT_EORECORD + \";b and ' more\\n;\", \n+      parser.testNextToken());\n+  }\n+  \n+  \n+  // ======================================================\n+  //   parser tests\n+  // ======================================================\n+  \n+  String code = \n+    \"a,b,c,d\\n\"\n+    + \" a , b , 1 2 \\n\"\n+    + \"\\\"foo baar\\\", b,\\n\"\n+    + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+  String[][] res = { \n+    {\"a\", \"b\", \"c\", \"d\"},\n+    {\"a\", \"b\", \"1 2\"}, \n+    {\"foo baar\", \"b\", \"\"}, \n+    {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"},\n+    {\"\"}\n+  };\n+  public void testGetLine() throws IOException {\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String[] tmp = null;\n+    for (int i = 0; i < res.length; i++) {\n+      tmp = parser.getLine();\n+      assertTrue(Arrays.equals(res[i], tmp));\n+    }\n+    tmp = parser.getLine();\n+    assertTrue(tmp == null);\n+  }\n+  \n+  public void testNextValue() throws IOException {\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String tmp = null;\n+    for (int i = 0; i < res.length; i++) {\n+      for (int j = 0; j < res[i].length; j++) {\n+        tmp = parser.nextValue();\n+        assertEquals(res[i][j], tmp);\n+      }\n+    }\n+    tmp = parser.nextValue();\n+    assertTrue(tmp == null);    \n+  }\n+  \n+  public void testGetAllValues() throws IOException {\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String[][] tmp = parser.getAllValues();\n+    assertEquals(res.length, tmp.length);\n+    assertTrue(tmp.length > 0);\n+    for (int i = 0; i < res.length; i++) {\n+      assertTrue(Arrays.equals(res[i], tmp[i])); \n+    }\n+  }\n+  \n+  public void testExcelStrategyTest() throws IOException {\n+    String code = \n+      \"value1;value2;value3;value4\\r\\na;b;c;d\\r\\n  x;;;\"\n+      + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\";\\\"  \\\"\\\"world\\\"\\\"\\\";\\\"abc\\ndef\\\";\\r\\n\";\n+    String[][] res = {\n+      {\"value1\", \"value2\", \"value3\", \"value4\"},\n+      {\"a\", \"b\", \"c\", \"d\"},\n+      {\"  x\", \"\", \"\", \"\"},\n+      {\"\"},\n+      {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"},\n+      {\"\"}\n+    };\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setExcelStrategy();\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String[][] tmp = parser.getAllValues();\n+    assertEquals(res.length, tmp.length);\n+    assertTrue(tmp.length > 0);\n+    for (int i = 0; i < res.length; i++) {\n+      assertTrue(Arrays.equals(res[i], tmp[i])); \n+    }\n+  }\n+  \n+  public void testExcelStrategyTest2() throws Exception {\n+    String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+    String[][] res = {\n+      {\"foo\", \"baar\"},\n+      {\"\"},\n+      {\"hello\", \"\"},\n+      {\"\"},\n+      {\"world\", \"\"},\n+      {\"\"} \n+    };\n+    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    parser.setExcelStrategy();\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String[][] tmp = parser.getAllValues();\n+    assertEquals(res.length, tmp.length);\n+    assertTrue(tmp.length > 0);\n+    for (int i = 0; i < res.length; i++) {\n+      for (int j = 0; j < tmp[i].length; j++) {\n+        System.out.println(\"'\" + tmp[i][j] + \"'\");\n+      }\n+      assertTrue(Arrays.equals(res[i], tmp[i])); \n+    }\n+    //assertTrue(false);\n+  }\n+  \n+  // ======================================================\n+  //   static parser tests\n+  // ======================================================\n+  public void testParse1() throws IOException {\n+      String[][] data = CSVParser.parse(\"abc\\ndef\");\n+      assertEquals(2, data.length);\n+      assertEquals(1, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\", data[1][0]);\n+    }\n+\n+    public void testParse2() throws IOException {\n+      String[][] data = CSVParser.parse(\"abc,def,\\\"ghi,jkl\\\"\\ndef\");\n+      assertEquals(2, data.length);\n+      assertEquals(3, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\", data[0][1]);\n+      assertEquals(\"ghi,jkl\", data[0][2]);\n+      assertEquals(\"def\", data[1][0]);\n+    }\n+\n+    public void testParse3() throws IOException {\n+      String[][] data = CSVParser.parse(\"abc,\\\"def\\nghi\\\"\\njkl\");\n+      assertEquals(2, data.length);\n+      assertEquals(2, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\\nghi\", data[0][1]);\n+      assertEquals(\"jkl\", data[1][0]);\n+    }\n+\n+    public void testParse4() throws IOException {\n+      String[][] data = CSVParser.parse(\"abc,\\\"def\\\\\\\\nghi\\\"\\njkl\");\n+      assertEquals(2, data.length);\n+      assertEquals(2, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\\\\nghi\", data[0][1]);\n+      assertEquals(\"jkl\", data[1][0]);\n+    }\n+\n+    public void testParse5() throws IOException {\n+      String[][] data = CSVParser.parse(\"abc,def\\\\nghi\\njkl\");\n+      assertEquals(2, data.length);\n+      assertEquals(2, data[0].length);\n+      assertEquals(1, data[1].length);\n+      assertEquals(\"abc\", data[0][0]);\n+      assertEquals(\"def\\\\nghi\", data[0][1]);\n+      assertEquals(\"jkl\", data[1][0]);\n+    }\n+    \n+    public void testParse6() throws IOException {\n+      String[][] data = CSVParser.parse(\"\");\n+      assertEquals(1, data.length);\n+      assertEquals(1, data[0].length);\n+      assertEquals(\"\", data[0][0]);  \n+    }\n+    \n+    public void testParse7() throws IOException {\n+      boolean io = false;\n+      try {\n+        CSVParser.parse(null);\n+      } catch (IllegalArgumentException e) {\n+        io = true;\n+      }\n+      assertTrue(io);\n+    }\n+    \n+    public void testParseLine1() throws IOException {\n+      String[] data = CSVParser.parseLine(\"abc,def,ghi\");\n+      assertEquals(3, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def\", data[1]);\n+      assertEquals(\"ghi\", data[2]);\n+    }\n+\n+    public void testParseLine2() throws IOException {\n+      String[] data = CSVParser.parseLine(\"abc,def,ghi\\n\");\n+      assertEquals(3, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def\", data[1]);\n+      assertEquals(\"ghi\", data[2]);\n+    }\n+\n+    public void testParseLine3() throws IOException {\n+      String[] data = CSVParser.parseLine(\"abc,\\\"def,ghi\\\"\");\n+      assertEquals(2, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def,ghi\", data[1]);\n+    }\n+\n+    public void testParseLine4() throws IOException {\n+      String[] data = CSVParser.parseLine(\"abc,\\\"def\\nghi\\\"\");\n+      assertEquals(2, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"def\\nghi\", data[1]);\n+    }\n+    \n+    public void testParseLine5() throws IOException {\n+      String[] data = CSVParser.parseLine(\"\");\n+      assertEquals(0, data.length);\n+      // assertEquals(\"\", data[0]);\n+    }\n+    \n+    public void testParseLine6() throws IOException {\n+      boolean io = false;\n+      try {\n+        CSVParser.parseLine(null);\n+      } catch (IllegalArgumentException e) {\n+        io = true;\n+      }\n+      assertTrue(io);\n+    }\n+    \n+    public void testParseLine7() throws IOException {\n+      String[] res = CSVParser.parseLine(\"\");\n+      assertNotNull(res);\n+      assertEquals(0, res.length);  \n+    }\n+      \n+    public void testUnicodeEscape() throws IOException {\n+      String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n+      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      parser.setUnicodeEscapeInterpretation(true);\n+      String[] data = parser.getLine();\n+      assertEquals(2, data.length);\n+      assertEquals(\"abc\", data[0]);\n+      assertEquals(\"public\", data[1]);\n+    }\n+    \n+    public void testCarriageReturnLineFeedEndings() throws IOException {\n+     String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+     String[][] data = parser.getAllValues();\n+     assertEquals(4, data.length);\n+    }\n+    \n+    public void testIgnoreEmptyLines() throws IOException {\n+      String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+      //String code = \"world\\r\\n\\n\";\n+      //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      String[][] data = parser.getAllValues();\n+//      for (int i = 0; i < data.length; i++) {\n+//        if (i > 0) {\n+//          System.out.print('\\n');\n+//        }\n+//        for (int j = 0; j < data[i].length; j++) {\n+//          System.out.print(\"(\" + j + \")'\" + data[i][j] + \"'\");\n+//        }\n+//      }\n+//      System.out.println(\"----------\");\n+      assertEquals(3, data.length);\n+    }\n+    \n+    public void testLineTokenConsistency() throws IOException {\n+      String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      String[][] data = parser.getAllValues();\n+      parser = new TestCSVParser(new StringReader(code));\n+      TestCSVParser parser1 = new TestCSVParser(new StringReader(code));\n+      for (int i = 0; i < data.length; i++) {\n+        assertTrue(Arrays.equals(parser1.getLine(), data[i]));\n+        for (int j = 0; j < data[i].length; j++) {\n+          assertEquals(parser.nextValue(), data[i][j]);\n+        }\n+      }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/ch/netcetera/wake/core/format/csv/CSVPrinterTest.java\n+/*\n+* The copyright to the computer program(s) herein is the property of\n+* Netcetera AG, Switzerland. The program(s) may be used and/or copied\n+* only with the written permission of Netcetera AG or in accordance\n+* with the terms and conditions stipulated in the agreement/contract\n+* under which the program(s) have been supplied.\n+*\n+* @(#) $Id: CSVPrinterTest.java,v 1.1 2004/08/10 12:38:45 rgrunder Exp $\n+*/\n+package ch.netcetera.wake.core.format.csv;\n+\n+import java.io.StringWriter;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * CSVPrinterTest\n+ */\n+public class CSVPrinterTest extends TestCase {\n+  \n+  String lineSeparator = null;\n+  \n+  /**\n+   * Constructor for CSVPrinterTest.\n+   */\n+  public CSVPrinterTest(String name) {\n+    super(name);\n+    this.lineSeparator = System.getProperty(\"line.separator\");\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(CSVPrinterTest.class);\n+  }\n+\n+  public void testPrinter1() {\n+    StringWriter sw = new StringWriter();\n+    CSVPrinter printer = new CSVPrinter(sw);\n+    String[] line1 = {\"a\", \"b\"};\n+    printer.println(line1);\n+    assertEquals(\"a,b\" + lineSeparator, sw.toString());\n+  }\n+\n+  public void testPrinter2() {\n+    StringWriter sw = new StringWriter();\n+    CSVPrinter printer = new CSVPrinter(sw);\n+    String[] line1 = {\"a,b\", \"b\"};\n+    printer.println(line1);\n+    assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n+  }\n+\n+  public void testPrinter3() {\n+    StringWriter sw = new StringWriter();\n+    CSVPrinter printer = new CSVPrinter(sw);\n+    String[] line1 = {\"a, b\", \"b \"};\n+    printer.println(line1);\n+    assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + lineSeparator, sw.toString());\n+  }\n+\n+  public void testExcelPrinter1() {\n+    StringWriter sw = new StringWriter();\n+    CSVPrinter printer = new CSVPrinter(sw);\n+    printer.setSeparatorChar(';');\n+    String[] line1 = {\"a\", \"b\"};\n+    printer.println(line1);\n+    assertEquals(\"a;b\" + lineSeparator, sw.toString());\n+  }\n+\n+  public void testExcelPrinter2() {\n+    StringWriter sw = new StringWriter();\n+    CSVPrinter printer = new CSVPrinter(sw);\n+    printer.setSeparatorChar(';');\n+    String[] line1 = {\"a;b\", \"b\"};\n+    printer.println(line1);\n+    assertEquals(\"\\\"a;b\\\";b\" + lineSeparator, sw.toString());\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/ch/netcetera/wake/core/format/csv/ExtendedBufferedReaderTest.java\n+/*\n+ * Copyright (C) 2004 by Netcetera AG.\n+ * All rights reserved.\n+ *\n+ * The copyright to the computer program(s) herein is the property of\n+ * Netcetera AG, Switzerland. The program(s) may be used and/or copied\n+ * only with the written permission of Netcetera AG or in accordance\n+ * with the terms and conditions stipulated in the agreement/contract\n+ * under which the program(s) have been supplied.\n+ *\n+ * @(#) $Id: ExtendedBufferedReaderTest.java,v 1.2 2004/10/20 11:14:11 rgrunder Exp $\n+ */\n+package ch.netcetera.wake.core.format.csv;\n+\n+import java.io.StringReader;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * ExtendedBufferedReaderTest\n+ *\n+ */\n+public class ExtendedBufferedReaderTest extends TestCase {\n+\n+  private StringBuffer buf = null;\n+  private ExtendedBufferedReader br = null;\n+  \n+  /**\n+   * Constructor for ExtendedBufferedReaderTest.\n+   * @param arg0\n+   */\n+  public ExtendedBufferedReaderTest(String arg0) {\n+    super(arg0);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ExtendedBufferedReaderTest.class);\n+  }\n+  \n+  // ======================================================\n+  //   the test cases\n+  // ======================================================\n+ \n+  public void testConstructors() {\n+    br = new ExtendedBufferedReader(new StringReader(\"\"));\n+    br = new ExtendedBufferedReader(new StringReader(\"\"), 10); \n+  }\n+  \n+  public void testReadLookahead1() throws Exception {\n+   \n+    assertEquals(ExtendedBufferedReader.END_OF_STREAM, getEBR(\"\").read());\n+    br = getEBR(\"1\\n2\\r3\\n\");\n+    assertEquals('1', br.lookAhead());\n+    assertEquals(ExtendedBufferedReader.UNDEFINED, br.readAgain());\n+    assertEquals('1', br.read());\n+    assertEquals('1', br.readAgain());\n+\n+    assertEquals(0, br.getLineNumber());\n+    assertEquals('\\n', br.lookAhead());\n+    assertEquals(0, br.getLineNumber());\n+    assertEquals('1', br.readAgain());    \n+    assertEquals('\\n', br.read());\n+    assertEquals(1, br.getLineNumber());\n+    assertEquals('\\n', br.readAgain());\n+    assertEquals(1, br.getLineNumber());\n+    \n+    assertEquals('2', br.lookAhead());\n+    assertEquals(1, br.getLineNumber());\n+    assertEquals('\\n', br.readAgain());\n+    assertEquals(1, br.getLineNumber());\n+    assertEquals('2', br.read());\n+    assertEquals('2', br.readAgain());\n+    \n+    assertEquals('\\r', br.lookAhead());\n+    assertEquals('2', br.readAgain());\n+    assertEquals('\\r', br.read());\n+    assertEquals('\\r', br.readAgain());\n+    \n+    assertEquals('3', br.lookAhead());\n+    assertEquals('\\r', br.readAgain());\n+    assertEquals('3', br.read());\n+    assertEquals('3', br.readAgain());\n+    \n+    assertEquals('\\n', br.lookAhead());\n+    assertEquals(1, br.getLineNumber());\n+    assertEquals('3', br.readAgain());\n+    assertEquals('\\n', br.read());\n+    assertEquals(2, br.getLineNumber());\n+    assertEquals('\\n', br.readAgain());\n+    assertEquals(2, br.getLineNumber());\n+    \n+    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n+    assertEquals('\\n', br.readAgain());\n+    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n+    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());\n+    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n+    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n+ \n+  }\n+  \n+\n+  public void testReadLookahead2() throws Exception {\n+    char[] ref = new char[5];\n+    char[] res = new char[5];  \n+    \n+    br = getEBR(\"\");\n+    assertEquals(0, br.read(res, 0, 0));\n+    assertTrue(Arrays.equals(res, ref)); \n+    \n+    br = getEBR(\"abcdefg\");\n+    ref[0] = 'a';\n+    ref[1] = 'b';\n+    ref[2] = 'c';\n+    assertEquals(3, br.read(res, 0, 3));\n+    assertTrue(Arrays.equals(res, ref));\n+    assertEquals('c', br.readAgain());\n+    \n+    assertEquals('d', br.lookAhead());\n+    ref[4] = 'd';\n+    assertEquals(1, br.read(res, 4, 1));\n+    assertTrue(Arrays.equals(res, ref));\n+    assertEquals('d', br.readAgain());\n+ \n+  }\n+  \n+  public void testMarkSupported() {\n+    assertFalse(getEBR(\"foo\").markSupported());\n+  }\n+  \n+  public void testReadLine() throws Exception {\n+    br = getEBR(\"\");\n+    assertTrue(br.readLine() == null);\n+    \n+    br = getEBR(\"\\n\");\n+    assertTrue(br.readLine().equals(\"\"));\n+    assertTrue(br.readLine() == null);\n+    \n+    br = getEBR(\"foo\\n\\nhello\");\n+    assertEquals(0, br.getLineNumber());\n+    assertTrue(br.readLine().equals(\"foo\"));\n+    assertEquals(1, br.getLineNumber());\n+    assertTrue(br.readLine().equals(\"\"));\n+    assertEquals(2, br.getLineNumber());\n+    assertTrue(br.readLine().equals(\"hello\"));\n+    assertEquals(3, br.getLineNumber());\n+    assertTrue(br.readLine() == null);\n+    assertEquals(3, br.getLineNumber());\n+    \n+    br = getEBR(\"foo\\n\\nhello\");\n+    assertEquals('f', br.read());\n+    assertEquals('o', br.lookAhead());\n+    assertTrue(br.readLine().equals(\"oo\"));\n+    assertEquals(1, br.getLineNumber());\n+    assertEquals('\\n', br.lookAhead());\n+    assertTrue(br.readLine().equals(\"\"));\n+    assertEquals(2, br.getLineNumber());\n+    assertEquals('h', br.lookAhead());\n+    assertTrue(br.readLine().equals(\"hello\"));\n+    assertTrue(br.readLine() == null);\n+    assertEquals(3, br.getLineNumber());\n+    \n+ \n+    br = getEBR(\"foo\\rbaar\\r\\nfoo\");\n+    assertTrue(br.readLine().equals(\"foo\"));\n+    assertEquals('b', br.lookAhead());\n+    assertTrue(br.readLine().equals(\"baar\"));\n+    assertEquals('f', br.lookAhead());\n+    assertTrue(br.readLine().equals(\"foo\"));\n+    assertTrue(br.readLine() == null);\n+  }\n+  \n+  public void testSkip0() throws Exception {\n+    \n+    br = getEBR(\"\");\n+    assertEquals(0, br.skip(0));\n+    assertEquals(0, br.skip(1));\n+    \n+    br = getEBR(\"\");\n+    assertEquals(0, br.skip(1));\n+    \n+    br = getEBR(\"abcdefg\");\n+    assertEquals(0, br.skip(0));\n+    assertEquals('a', br.lookAhead());\n+    assertEquals(0, br.skip(0));\n+    assertEquals('a', br.lookAhead());\n+    assertEquals(1, br.skip(1));\n+    assertEquals('b', br.lookAhead());\n+    assertEquals('b', br.read());\n+    assertEquals(3, br.skip(3));\n+    assertEquals('f', br.lookAhead());\n+    assertEquals(2, br.skip(5));\n+    assertTrue(br.readLine() == null);\n+    \n+    br = getEBR(\"12345\");\n+    assertEquals(5, br.skip(5));\n+    assertTrue (br.lookAhead() == ExtendedBufferedReader.END_OF_STREAM);\n+  }\n+  \n+  public void testSkipUntil() throws Exception {   \n+    br = getEBR(\"\");\n+    assertEquals(0, br.skipUntil(';'));\n+    br = getEBR(\"ABCDEF,GHL,,MN\");\n+    assertEquals(6, br.skipUntil(','));\n+    assertEquals(0, br.skipUntil(','));\n+    br.skip(1);\n+    assertEquals(3, br.skipUntil(','));\n+    br.skip(1);\n+    assertEquals(0, br.skipUntil(','));\n+    br.skip(1);\n+    assertEquals(2, br.skipUntil(','));\n+  }\n+  \n+  public void testReadUntil() throws Exception {\n+    br = getEBR(\"\");\n+    assertTrue(br.readUntil(';').equals(\"\"));\n+    br = getEBR(\"ABCDEF;GHL;;MN\");\n+    assertTrue(br.readUntil(';').equals(\"ABCDEF\"));\n+    assertTrue(br.readUntil(';').length() == 0);\n+    br.skip(1);\n+    assertTrue(br.readUntil(';').equals(\"GHL\"));\n+    br.skip(1);\n+    assertTrue(br.readUntil(';').equals(\"\"));\n+    br.skip(1);\n+    assertTrue(br.readUntil(',').equals(\"MN\"));\n+  }\n+  \n+  private ExtendedBufferedReader getEBR(String s) {\n+    return new ExtendedBufferedReader(new StringReader(s));\n+  }\n+}", "timestamp": 1134798087, "metainfo": ""}