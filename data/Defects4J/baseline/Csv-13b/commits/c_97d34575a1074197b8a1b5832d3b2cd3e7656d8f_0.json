{"sha": "97d34575a1074197b8a1b5832d3b2cd3e7656d8f", "log": "Revert back to NOT skipping a record when withHeader is called with a non-empty array. Add skipHeaderRecord setting to CSVFormat and use when headers are initialized.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n public class CSVFormat implements Serializable {\n \n     private static final long serialVersionUID = 1L;\n+    \n     /**\n      * Returns true if the given character is a line break character.\n      *\n     private final String recordSeparator; // for outputs\n     private final String nullString;\n     private final String[] header;\n+    private final boolean skipHeaderRecord;\n \n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n      * <li>withIgnoreEmptyLines(true)</li>\n      * </ul>\n      */\n-    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null);\n+    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null, false);\n \n     /**\n      * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n     public static CSVFormat newFormat(final char delimiter) {\n-        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null);\n+        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n     }\n \n     /**\n      *            the line separator to use for output\n      * @param header\n      *            the header\n+     * @param skipHeaderRecord TODO\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n     // package protected to give access without needing a synthetic accessor\n             final Quote quotePolicy, final Character commentStart,\n             final Character escape, final boolean ignoreSurroundingSpaces,\n             final boolean ignoreEmptyLines, final String recordSeparator,\n-            final String nullString, final String[] header) {\n+            final String nullString, final String[] header, boolean skipHeaderRecord) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         this.recordSeparator = recordSeparator;\n         this.nullString = nullString;\n         this.header = header == null ? null : header.clone();\n+        this.skipHeaderRecord = skipHeaderRecord;\n     }\n \n     CSVFormat(final CSVFormat format) {\n         this(format.getDelimiter(), format.getQuoteChar(), format.getQuotePolicy(), format.getCommentStart(),\n                 format.getEscape(), format.getIgnoreSurroundingSpaces(), format.getIgnoreEmptyLines(),\n-                format.getRecordSeparator(), format.getNullString(), format.getHeader());\n+                format.getRecordSeparator(), format.getNullString(), format.getHeader(), format.getSkipHeaderRecord());\n     }\n \n     @Override\n      */\n     public String getRecordSeparator() {\n         return recordSeparator;\n+    }\n+\n+    /**\n+     * Returns whether to skip the header record.\n+     *\n+     * @return whether to skip the header record.\n+     */\n+    public boolean getSkipHeaderRecord() {\n+        return skipHeaderRecord;\n     }\n \n     @Override\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n      * Sets the header of the format. The header can either be parsed automatically from the input file with:\n      * \n      * <pre>\n-     * CSVFormat format = aformat.withHeader();\n-     * </pre>\n+     * CSVFormat format = aformat.withHeader();</pre>\n      * \n      * or specified manually with:\n      * \n      * <pre>\n-     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n-     * </pre>\n-     * \n-     * When this option is is set to any non-null value, the first record is the first <em>data</em> record, not the\n-     * header record.\n+     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n      * \n      * @param header\n      *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n      * \n      * @return A new CSVFormat that is equal to this but with the specified header\n+     * @see #withSkipHeaderRecord(boolean)\n      */\n     public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n      */\n     public CSVFormat withNullString(final String nullString) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n      */\n     public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n \n     /**\n      */\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+    }\n+\n+    /**\n+     * Sets whether to skip the header record.\n+     *\n+     * @param skipHeaderRecord\n+     *            whether to skip the header record.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n+     * @see #withHeader(String...)\n+     */\n+    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n         Map<String, Integer> hdrMap = null;\n         String[] formatHeader = this.format.getHeader();\n         if (formatHeader != null) {\n-            final CSVRecord record = this.nextRecord();\n             hdrMap = new LinkedHashMap<String, Integer>();\n \n             String[] header = null;\n             if (formatHeader.length == 0) {\n                 // read the header from the first line of the file\n+                final CSVRecord record = this.nextRecord();\n                 if (record != null) {\n                     header = record.values();\n                 }\n             } else {\n+                if (this.format.getSkipHeaderRecord()) {\n+                    this.nextRecord();\n+                }\n                 header = formatHeader;\n             }\n \n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     @Test\n     public void testSkipSetHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord(true)\n+                .parse(in).iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"a\"));\n         assertEquals(\"2\", record.get(\"b\"));\n \n         final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n \n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n             final CSVRecord record = records.next();\n             assertTrue(record.isMapped(\"A\"));\n     @Test\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord(true)\n+                .parse(in).iterator();\n         CSVRecord record;\n \n         // 1st record\n         final Iterator<CSVRecord> records = parser.iterator();\n \n         // Parse to make sure getHeaderMap did not have a side-effect.\n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n             final CSVRecord record = records.next();\n             assertEquals(record.get(0), record.get(\"A\"));", "timestamp": 1375285197, "metainfo": ""}