{"sha": "770628d292666a4b99949e97b75f485e3e240e0d", "log": "Add org.apache.commons.csv.CSVParser.CSVParser(Reader, CSVFormat, long, long) and remove new setters.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n \n+    /**\n+     * The next record number to assign.\n+     */\n     private long recordNumber;\n     \n     /**\n-     * Lexer offset if the parser does not start parsing at the beginning of the source. Usually used in combination\n+     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n      * with {@link #setNextRecordNumber(long)}\n      */\n-    private long characterOffset;\n+    private final long characterOffset;\n \n     private final Token reusableToken = new Token();\n \n      *             If there is a problem reading the header or skipping the first record\n      */\n     public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n+        this(reader, format, 0, 1);\n+    }\n+\n+    /**\n+     * Customized CSV parser using the given {@link CSVFormat}\n+     *\n+     * <p>\n+     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n+     * unless you close the {@code reader}.\n+     * </p>\n+     *\n+     * @param reader\n+     *            a Reader containing CSV-formatted input. Must not be null.\n+     * @param format\n+     *            the CSVFormat used for CSV parsing. Must not be null.\n+     * @param characterOffset\n+     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n+     * @param recordNumber\n+     *            The next record number to assign\n+     * @throws IllegalArgumentException\n+     *             If the parameters of the format are inconsistent or if either reader or format are null.\n+     * @throws IOException\n+     *             If there is a problem reading the header or skipping the first record\n+     * @since 1.1\n+     */\n+    public CSVParser(final Reader reader, final CSVFormat format, long characterOffset, long recordNumber)\n+            throws IOException {\n         Assertions.notNull(reader, \"reader\");\n         Assertions.notNull(format, \"format\");\n \n         this.format = format;\n         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n         this.headerMap = this.initializeHeader();\n+        this.characterOffset = characterOffset;\n+        this.recordNumber = recordNumber - 1;\n     }\n \n     private void addRecordValue() {\n     }\n \n     /**\n-     * Sets the record number to be assigned to the next record read.\n-     * <p>\n-     * Use this if the reader is not positioned at the first record when you create the parser. For example, the first\n-     * record read might be the 51st record in the source file.\n-     * </p>\n-     * <p>\n-     * If you want the records to also have the correct character position referring to the underlying source, call\n-     * {@link #setNextCharacterPosition(long)}.\n-     * </p>\n-     * \n-     * @param nextRecordNumber\n-     *            the next record number\n-     * @since 1.1\n-     */\n-    public void setNextRecordNumber(long nextRecordNumber) {\n-        this.recordNumber = nextRecordNumber - 1;\n-    }\n-    \n-    /**\n-     * Sets the current position in the source stream regardless of where the parser and lexer start reading.\n-     * <p>\n-     * For example: We open a file and seek to position 5434 in order to start reading at record 42. In order to have\n-     * the parser assign the correct characterPosition to records, we call this method.\n-     * </p>\n-     * <p>\n-     * If you want the records to also have the correct record numbers, call {@link #setNextRecordNumber(long)}\n-     * </p>\n-     * \n-     * @param position\n-     *            the new character position\n-     * @since 1.1\n-     */\n-    public void setNextCharacterPosition(long position) {\n-        this.characterOffset = position - lexer.getCharacterPosition();\n-    }\n-    \n-    /**\n      * Returns the current record number in the input stream.\n      *\n      * <p>\n      * the line number.\n      * </p>\n      *\n-     * @return current line number\n+     * @return current record number\n      */\n     public long getRecordNumber() {\n         return this.recordNumber;\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n import java.io.Flushable;\n import java.io.IOException;\n import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n import java.sql.SQLException;\n \n /**\n      *             if a database access error occurs\n      */\n     public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n-        final int columnCount = resultSet.getMetaData().getColumnCount();\n+        ResultSetMetaData metaData = resultSet.getMetaData();\n+        final int columnCount = metaData.getColumnCount();\n+        boolean printHeader = false;\n+        if (printHeader) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                print(metaData.getColumnLabel(i));\n+            }\n+            println();\n+        }\n         while (resultSet.next()) {\n             for (int i = 1; i <= columnCount; i++) {\n                 print(resultSet.getString(i));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         parser.close();\n \n         // now try to read starting at record 3\n-        parser = CSVParser.parse(code.substring((int) positionRecord3), format);\n-        parser.setNextRecordNumber(3);\n-        parser.setNextCharacterPosition(positionRecord3);\n+        parser = new CSVParser(new StringReader(code.substring((int) positionRecord3)), format, positionRecord3, 3);\n \n         assertNotNull(record = parser.nextRecord());\n         assertEquals(3, record.getRecordNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n import java.util.List;\n import java.util.Random;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n         final Connection connection = DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n         try {\n             final Statement stmt = connection.createStatement();\n-            stmt.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n-            stmt.execute(\"insert into TEST values(1, 'r1')\");\n-            stmt.execute(\"insert into TEST values(2, 'r2')\");\n+            setUpTable(stmt);\n             final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n             printer.printRecords(stmt.executeQuery(\"select ID, NAME from TEST\"));\n             assertEquals(\"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n+            printer.close();\n+        } finally {\n+            connection.close();\n+        }\n+    }\n+\n+    private void setUpTable(final Statement stmt) throws SQLException {\n+        stmt.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n+        stmt.execute(\"insert into TEST values(1, 'r1')\");\n+        stmt.execute(\"insert into TEST values(2, 'r2')\");\n+    }\n+\n+    @Test\n+    @Ignore\n+    public void testJdbcPrinterWithHeaders() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        Class.forName(\"org.h2.Driver\");\n+        final Connection connection = DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n+        try {\n+            final Statement stmt = connection.createStatement();\n+            setUpTable(stmt);\n+            final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+            printer.printRecords(stmt.executeQuery(\"select ID, NAME from TEST\"));\n+            assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n             printer.close();\n         } finally {\n             connection.close();", "timestamp": 1414589584, "metainfo": ""}