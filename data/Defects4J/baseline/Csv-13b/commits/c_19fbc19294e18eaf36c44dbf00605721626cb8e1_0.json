{"sha": "19fbc19294e18eaf36c44dbf00605721626cb8e1", "log": "Added a JMH benchmark to compare the most commons CSV parsers  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/CSVBenchmark.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.generationjava.io.CsvReader;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.supercsv.io.CsvListReader;\n+import org.supercsv.prefs.CsvPreference;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Fork(value = 1, jvmArgs = \"-server\")\n+@Threads(1)\n+@Warmup(iterations = 10)\n+@Measurement(iterations = 10)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+public class CSVBenchmark {\n+\n+    private BufferedReader getReader() throws IOException {\n+        return new BufferedReader(new FileReader(\"worldcitiespop.txt\"));\n+    }\n+\n+    @Benchmark\n+    public int baseline(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        int count = 0;\n+        String line;\n+        while ((line = in.readLine()) != null) {\n+            count++;\n+        }\n+        \n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+\n+    @Benchmark\n+    public int parseCommonsCSV(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        \n+        CSVFormat format = CSVFormat.DEFAULT.withHeader();\n+\n+        int count = 0;\n+        for (CSVRecord record : format.parse(in)) {\n+            count++;\n+        }\n+\n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+\n+    @Benchmark\n+    public int parseGenJavaCSV(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        \n+        CsvReader reader = new CsvReader(in);\n+        reader.setFieldDelimiter(',');\n+\n+        int count = 0;\n+        String[] record = null;\n+        while ((record = reader.readLine()) != null) {\n+            count++;\n+        }\n+\n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+\n+    @Benchmark\n+    public int parseJavaCSV(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        \n+        com.csvreader.CsvReader reader = new com.csvreader.CsvReader(in, ',');\n+        reader.setRecordDelimiter('\\n');\n+\n+        int count = 0;\n+        while (reader.readRecord()) {\n+            count++;\n+        }\n+\n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+\n+    @Benchmark\n+    public int parseOpenCSV(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        \n+        com.opencsv.CSVReader reader = new com.opencsv.CSVReader(in, ',');\n+\n+        int count = 0;\n+        while (reader.readNext() != null) {\n+            count++;\n+        }\n+\n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+\n+    @Benchmark\n+    public int parseSkifeCSV(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        \n+        org.skife.csv.CSVReader reader = new org.skife.csv.SimpleReader();\n+        reader.setSeperator(',');\n+        \n+        CountingReaderCallback callback = new CountingReaderCallback();\n+        reader.parse(in, callback);\n+\n+        bh.consume(callback);\n+        in.close();\n+        return callback.count;\n+    }\n+\n+    private static class CountingReaderCallback implements org.skife.csv.ReaderCallback {\n+        public int count = 0;\n+\n+        @Override\n+        public void onRow(String[] fields) {\n+            count++;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int parseSuperCSV(Blackhole bh) throws Exception {\n+        BufferedReader in = getReader();\n+        \n+        CsvListReader reader = new CsvListReader(in, CsvPreference.STANDARD_PREFERENCE);\n+\n+        int count = 0;\n+        List<String> record = null;\n+        while ((record = reader.read()) != null) {\n+            count++;\n+        }\n+\n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+}", "timestamp": 1423439247, "metainfo": ""}