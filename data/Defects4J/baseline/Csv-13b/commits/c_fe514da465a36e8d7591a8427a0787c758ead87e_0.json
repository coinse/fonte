{"sha": "fe514da465a36e8d7591a8427a0787c758ead87e", "log": "[CSV-129] Add CSVFormat#with 0-arg methods matching boolean arg methods  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);\n+    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n \n     /**\n      * Tab-delimited format.\n     public static final CSVFormat TDF =\n             DEFAULT\n             .withDelimiter(TAB)\n-            .withIgnoreSurroundingSpaces(true);\n+            .withIgnoreSurroundingSpaces();\n \n     /**\n      * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     }\n \n     /**\n+     * Sets the missing column names behavior of the format to {@code true}\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n+     * @see #withAllowMissingColumnNames(boolean)\n+     * @since 1.1\n+     */\n+    public CSVFormat withAllowMissingColumnNames() {\n+        return this.withAllowMissingColumnNames(true);\n+    }\n+\n+    /**\n      * Sets the missing column names behavior of the format.\n      *\n      * @param allowMissingColumnNames\n     }\n \n     /**\n+     * Sets the empty line skipping behavior of the format to {@code true}.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n+     * @since {@link #withIgnoreEmptyLines(boolean)}\n+     * @since 1.1\n+     */\n+    public CSVFormat withIgnoreEmptyLines() {\n+        return this.withIgnoreEmptyLines(true);\n+    }\n+\n+    /**\n      * Sets the empty line skipping behavior of the format.\n      *\n      * @param ignoreEmptyLines\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n+    }\n+\n+    /**\n+     * Sets the trimming behavior of the format to {@code true}.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n+     * @see #withIgnoreSurroundingSpaces(boolean)\n+     * @since 1.1\n+     */\n+    public CSVFormat withIgnoreSurroundingSpaces() {\n+        return this.withIgnoreSurroundingSpaces(true);\n     }\n \n     /**\n     }\n \n     /**\n-     * Sets whether to skip the header record.\n+     * Sets skipping the header record to {@code true}.\n      *\n      * @param skipHeaderRecord\n      *            whether to skip the header record.\n      *\n      * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n+     * @see #withSkipHeaderRecord(boolean)\n+     * @see #withHeader(String...)\n+     * @since 1.1\n+     */\n+    public CSVFormat withSkipHeaderRecord() {\n+        return this.withSkipHeaderRecord(true);\n+    }\n+\n+    /**\n+     * Sets whether to skip the header record.\n+     *\n+     * @param skipHeaderRecord\n+     *            whether to skip the header record.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n      * @see #withHeader(String...)\n      */\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n                 .withCommentMarker('#')\n                 .withEscape('+')\n                 .withHeader(\"One\", \"Two\", \"Three\")\n-                .withIgnoreEmptyLines(true)\n-                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces()\n                 .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withCommentMarker('#')\n                 .withEscape('+')\n-                .withIgnoreEmptyLines(true)\n-                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces()\n                 .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withCommentMarker('#')\n                 .withEscape('+')\n-                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreSurroundingSpaces()\n                 .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withRecordSeparator(CR)\n                 .withCommentMarker('#')\n                 .withEscape('+')\n-                .withIgnoreEmptyLines(true)\n-                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces()\n                 .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withRecordSeparator(CR)\n                 .withCommentMarker('#')\n                 .withEscape('+')\n-                .withIgnoreEmptyLines(true)\n-                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces()\n                 .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL)\n                 .withNullString(\"null\");\n                 .withRecordSeparator(CR)\n                 .withCommentMarker('#')\n                 .withEscape('+')\n-                .withIgnoreEmptyLines(true)\n-                .withIgnoreSurroundingSpaces(true)\n+                .withIgnoreEmptyLines()\n+                .withIgnoreSurroundingSpaces()\n                 .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL)\n                 .withNullString(\"null\")\n-                .withSkipHeaderRecord(true);\n+                .withSkipHeaderRecord();\n         final CSVFormat left = right\n                 .withSkipHeaderRecord(false);\n \n \n     @Test\n     public void testNullRecordSeparatorCsv106() {\n-        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\", \"H2\");\n+        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord().withHeader(\"H1\", \"H2\");\n         final String formatStr = format.format(\"A\", \"B\");\n         assertNotNull(formatStr);\n         assertFalse(formatStr.endsWith(\"null\"));\n     @Test\n     public void testWithIgnoreEmptyLines() throws Exception {\n         assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n-        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines(true).getIgnoreEmptyLines());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines().getIgnoreEmptyLines());\n     }\n \n     @Test\n     public void testWithIgnoreSurround() throws Exception {\n         assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n-        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true).getIgnoreSurroundingSpaces());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces().getIgnoreSurroundingSpaces());\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n                 { \"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \" }, { \"9\", \"   \\n   \" }, };\n \n         final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/')\n-                .withIgnoreEmptyLines(true);\n+                .withIgnoreEmptyLines();\n \n         final CSVParser parser = CSVParser.parse(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         };\n \n         final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/')\n-                .withIgnoreEmptyLines(true);\n+                .withIgnoreEmptyLines();\n \n         final CSVParser parser = CSVParser.parse(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         }\n     }\n \n+//    @Test\n+//    public void testStartWithEmptyLinesThenHeaders() throws Exception {\n+//        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+//        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+//                { \"\" } };\n+//        for (final String code : codes) {\n+//            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+//            final List<CSVRecord> records = parser.getRecords();\n+//            assertEquals(res.length, records.size());\n+//            assertTrue(records.size() > 0);\n+//            for (int i = 0; i < res.length; i++) {\n+//                assertArrayEquals(res[i], records.get(i).values());\n+//            }\n+//            parser.close();\n+//        }\n+//    }\n+\n     @Test\n     public void testEndOfFileBehaviorCSV() throws Exception {\n         final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n         for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.nextRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n     @Test\n     public void testHeadersMissing() throws Exception {\n         final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n-        CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames(true).parse(in).iterator();\n+        CSVFormat.DEFAULT.withHeader().withAllowMissingColumnNames().parse(in).iterator();\n     }\n \n     @Test\n     public void testHeaderMissingWithNull() throws Exception {\n         final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n-        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames(true).parse(in).iterator();\n+        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withAllowMissingColumnNames().parse(in).iterator();\n     }\n \n     @Test\n     @Test\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord(true)\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord()\n                 .parse(in).iterator();\n         CSVRecord record;\n \n     @Test\n     public void testSkipSetHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord(true)\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord()\n                 .parse(in).iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"a\"));\n--- a/src/test/java/org/apache/commons/csv/LexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/LexerTest.java\n     @Test\n     public void testSurroundingSpacesAreDeleted() throws IOException {\n         final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n     @Test\n     public void testSurroundingTabsAreDeleted() throws IOException {\n         final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n                 \"\\n\"+\n                 \"\\n\"+\n                 \"\\n\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines(true);\n+        final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines();\n         final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n         *        a,  \" foo \" ,b\n         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));", "timestamp": 1409185682, "metainfo": ""}