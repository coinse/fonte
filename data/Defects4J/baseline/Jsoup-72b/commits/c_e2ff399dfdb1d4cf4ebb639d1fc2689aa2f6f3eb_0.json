{"sha": "e2ff399dfdb1d4cf4ebb639d1fc2689aa2f6f3eb", "log": "Updated from Java 5 to Java 7", "commit": "\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n         Map<String, String> cookies;\n \n         private Base() {\n-            headers = new LinkedHashMap<String, String>();\n-            cookies = new LinkedHashMap<String, String>();\n+            headers = new LinkedHashMap<>();\n+            cookies = new LinkedHashMap<>();\n         }\n \n         public URL url() {\n             timeoutMilliseconds = 30000; // 30 seconds\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n-            data = new ArrayList<Connection.KeyVal>();\n+            data = new ArrayList<>();\n             method = Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n             headers.put(USER_AGENT, DEFAULT_UA);\n                     sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                     // Create an ssl socket factory with our all-trusting manager\n                     sslSocketFactory = sslContext.getSocketFactory();\n-                } catch (NoSuchAlgorithmException e) {\n-                    throw new IOException(\"Can't create unsecure trust manager\");\n-                } catch (KeyManagementException e) {\n+                } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                     throw new IOException(\"Can't create unsecure trust manager\");\n                 }\n             }\n \n         private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n             // the default sun impl of conn.getHeaderFields() returns header values out of order\n-            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n+            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n             int i = 0;\n             while (true) {\n                 final String key = conn.getHeaderFieldKey(i);\n                 if (headers.containsKey(key))\n                     headers.get(key).add(val);\n                 else {\n-                    final ArrayList<String> vals = new ArrayList<String>();\n+                    final ArrayList<String> vals = new ArrayList<>();\n                     vals.add(val);\n                     headers.put(key, vals);\n                 }\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n         private static final String xmlnsPrefix = \"xmlns:\";\n \n         private final Document doc;\n-        private final HashMap<String, String> namespaces = new HashMap<String, String>(); // prefix => urn\n+        private final HashMap<String, String> namespaces = new HashMap<>(); // prefix => urn\n         private Element dest;\n \n         public W3CBuilder(Document doc) {\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n     public void put(Attribute attribute) {\n         Validate.notNull(attribute);\n         if (attributes == null)\n-             attributes = new LinkedHashMap<String, Attribute>(2);\n+             attributes = new LinkedHashMap<>(2);\n         attributes.put(attribute.getKey(), attribute);\n     }\n \n         if (incoming.size() == 0)\n             return;\n         if (attributes == null)\n-            attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n+            attributes = new LinkedHashMap<>(incoming.size());\n         attributes.putAll(incoming.attributes);\n     }\n \n         if (attributes == null)\n             return Collections.emptyList();\n \n-        List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n+        List<Attribute> list = new ArrayList<>(attributes.size());\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             list.add(entry.getValue());\n         }\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n         }\n-        clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size());\n+        clone.attributes = new LinkedHashMap<>(attributes.size());\n         for (Attribute attribute: this)\n             clone.attributes.put(attribute.getKey(), attribute.clone());\n         return clone;\n \n         private Dataset() {\n             if (attributes == null)\n-                attributes = new LinkedHashMap<String, Attribute>(2);\n+                attributes = new LinkedHashMap<>(2);\n         }\n \n         @Override\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n     // does not recurse.\n     private void normaliseTextNodes(Element element) {\n-        List<Node> toMove = new ArrayList<Node>();\n+        List<Node> toMove = new ArrayList<>();\n         for (Node node: element.childNodes) {\n             if (node instanceof TextNode) {\n                 TextNode tn = (TextNode) node;\n         Elements elements = this.getElementsByTag(tag);\n         Element master = elements.first(); // will always be available as created above if not existent\n         if (elements.size() > 1) { // dupes, move contents to master\n-            List<Node> toMove = new ArrayList<Node>();\n+            List<Node> toMove = new ArrayList<>();\n             for (int i = 1; i < elements.size(); i++) {\n                 Node dupe = elements.get(i);\n                 for (Node node : dupe.childNodes)\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n         List<Element> children;\n         if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n             final int size = childNodes.size();\n-            children = new ArrayList<Element>(size);\n+            children = new ArrayList<>(size);\n+            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n             for (int i = 0; i < size; i++) {\n                 final Node node = childNodes.get(i);\n                 if (node instanceof Element)\n                     children.add((Element) node);\n             }\n-            shadowChildrenRef = new WeakReference<List<Element>>(children);\n+            shadowChildrenRef = new WeakReference<>(children);\n         }\n         return children;\n     }\n      * </ul>\n      */\n     public List<TextNode> textNodes() {\n-        List<TextNode> textNodes = new ArrayList<TextNode>();\n+        List<TextNode> textNodes = new ArrayList<>();\n         for (Node node : childNodes) {\n             if (node instanceof TextNode)\n                 textNodes.add((TextNode) node);\n      * @see #data()\n      */\n     public List<DataNode> dataNodes() {\n-        List<DataNode> dataNodes = new ArrayList<DataNode>();\n+        List<DataNode> dataNodes = new ArrayList<>();\n         for (Node node : childNodes) {\n             if (node instanceof DataNode)\n                 dataNodes.add((DataNode) node);\n         if (index < 0) index += currentSize +1; // roll around\n         Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n \n-        ArrayList<Node> nodes = new ArrayList<Node>(children);\n+        ArrayList<Node> nodes = new ArrayList<>(children);\n         Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n         addChildren(index, nodeArray);\n         return this;\n      */\n     public Set<String> classNames() {\n     \tString[] names = classSplit.split(className());\n-    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n+    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n     \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n \n         return classNames;\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n         }\n     }\n \n-    private static final HashMap<String, String> multipoints = new HashMap<String, String>(); // name -> multiple character references\n+    private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\n \n     private Entities() {\n     }\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n      * @return a list of key vals\n      */\n     public List<Connection.KeyVal> formData() {\n-        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n+        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n \n         // iterate the form control elements and accumulate their values\n         for (Element el: elements) {\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n      * @return a deep copy of this node's children\n      */\n     public List<Node> childNodesCopy() {\n-        List<Node> children = new ArrayList<Node>(childNodes.size());\n+        List<Node> children = new ArrayList<>(childNodes.size());\n         for (Node node : childNodes) {\n             children.add(node.clone());\n         }\n \n         // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n         if (wrapChildren.size() > 0) {\n+            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n             for (int i = 0; i < wrapChildren.size(); i++) {\n                 Node remainder = wrapChildren.get(i);\n                 remainder.parentNode.removeChild(remainder);\n             return Collections.emptyList();\n \n         List<Node> nodes = parentNode.childNodes;\n-        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n+        List<Node> siblings = new ArrayList<>(nodes.size() - 1);\n         for (Node node: nodes)\n             if (node != this)\n                 siblings.add(node);\n         Node thisClone = doClone(null); // splits for orphan\n \n         // Queue up nodes that need their children cloned (BFS).\n-        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n+        LinkedList<Node> nodesToProcess = new LinkedList<>();\n         nodesToProcess.add(thisClone);\n \n         while (!nodesToProcess.isEmpty()) {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n  */\n public class HtmlTreeBuilder extends TreeBuilder {\n     // tag searches\n-    public static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n+    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n     private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n     private static final String[] TagSearchButton = new String[]{\"button\"};\n     private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n         headElement = null;\n         formElement = null;\n         contextElement = null;\n-        formattingElements = new ArrayList<Element>();\n-        pendingTableCharacters = new ArrayList<String>();\n+        formattingElements = new ArrayList<>();\n+        pendingTableCharacters = new ArrayList<>();\n         emptyEnd = new Token.EndTag();\n         framesetOk = true;\n         fosterInserts = false;\n     }\n \n     void newPendingTableCharacters() {\n-        pendingTableCharacters = new ArrayList<String>();\n+        pendingTableCharacters = new ArrayList<>();\n     }\n \n     List<String> getPendingTableCharacters() {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 }\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n+                    // todo - refactor to a switch statement\n                     String name = startTag.normalName();\n                     if (name.equals(\"a\")) {\n                         if (tb.getActiveFormattingElement(\"a\") != null) {\n                     break;\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.normalName();\n-                    if (name.equals(\"html\"))\n-                        return tb.process(t, InBody);\n-                    else if (name.equals(\"col\"))\n-                        tb.insertEmpty(startTag);\n-                    else\n-                        return anythingElse(t, tb);\n+                    switch (startTag.normalName()) {\n+                        case \"html\":\n+                            return tb.process(t, InBody);\n+                        case \"col\":\n+                            tb.insertEmpty(startTag);\n+                            break;\n+                        default:\n+                            return anythingElse(t, tb);\n+                    }\n                     break;\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.normalName();\n-                    if (name.equals(\"colgroup\")) {\n+                    if (endTag.normalName.equals(\"colgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"html\")) { // frag case\n                             tb.error(this);\n                             return false;\n                 case EndTag:\n                     Token.EndTag end = t.asEndTag();\n                     name = end.normalName();\n-                    if (name.equals(\"optgroup\")) {\n-                        if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n-                            tb.processEndTag(\"option\");\n-                        if (tb.currentElement().nodeName().equals(\"optgroup\"))\n-                            tb.pop();\n-                        else\n-                            tb.error(this);\n-                    } else if (name.equals(\"option\")) {\n-                        if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.pop();\n-                        else\n-                            tb.error(this);\n-                    } else if (name.equals(\"select\")) {\n-                        if (!tb.inSelectScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.popStackToClose(name);\n-                            tb.resetInsertionMode();\n-                        }\n-                    } else\n-                        return anythingElse(t, tb);\n+                    switch (name) {\n+                        case \"optgroup\":\n+                            if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n+                                tb.processEndTag(\"option\");\n+                            if (tb.currentElement().nodeName().equals(\"optgroup\"))\n+                                tb.pop();\n+                            else\n+                                tb.error(this);\n+                            break;\n+                        case \"option\":\n+                            if (tb.currentElement().nodeName().equals(\"option\"))\n+                                tb.pop();\n+                            else\n+                                tb.error(this);\n+                            break;\n+                        case \"select\":\n+                            if (!tb.inSelectScope(name)) {\n+                                tb.error(this);\n+                                return false;\n+                            } else {\n+                                tb.popStackToClose(name);\n+                                tb.resetInsertionMode();\n+                            }\n+                            break;\n+                        default:\n+                            return anythingElse(t, tb);\n+                    }\n                     break;\n                 case EOF:\n                     if (!tb.currentElement().nodeName().equals(\"html\"))\n                 return false;\n             } else if (t.isStartTag()) {\n                 Token.StartTag start = t.asStartTag();\n-                String name = start.normalName();\n-                if (name.equals(\"html\")) {\n-                    return tb.process(start, InBody);\n-                } else if (name.equals(\"frameset\")) {\n-                    tb.insert(start);\n-                } else if (name.equals(\"frame\")) {\n-                    tb.insertEmpty(start);\n-                } else if (name.equals(\"noframes\")) {\n-                    return tb.process(start, InHead);\n-                } else {\n-                    tb.error(this);\n-                    return false;\n+                switch (start.normalName()) {\n+                    case \"html\":\n+                        return tb.process(start, InBody);\n+                    case \"frameset\":\n+                        tb.insert(start);\n+                        break;\n+                    case \"frame\":\n+                        tb.insertEmpty(start);\n+                        break;\n+                    case \"noframes\":\n+                        return tb.process(start, InHead);\n+                    default:\n+                        tb.error(this);\n+                        return false;\n                 }\n             } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                 if (tb.currentElement().nodeName().equals(\"html\")) { // frag\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Tag {\n-    private static final Map<String, Tag> tags = new HashMap<String, Tag>(); // map of known tags\n+    private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags\n \n     private String tagName;\n     private boolean isBlock = true; // block or inline\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n         this.errors = errors;\n         currentToken = null;\n         tokeniser = new Tokeniser(reader, errors);\n-        stack = new ArrayList<Element>(32);\n+        stack = new ArrayList<>(32);\n         this.baseUri = baseUri;\n     }\n \n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n      @see #relaxed()\n      */\n     public Whitelist() {\n-        tagNames = new HashSet<TagName>();\n-        attributes = new HashMap<TagName, Set<AttributeKey>>();\n-        enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>();\n-        protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>();\n+        tagNames = new HashSet<>();\n+        attributes = new HashMap<>();\n+        enforcedAttributes = new HashMap<>();\n+        protocols = new HashMap<>();\n         preserveRelativeLinks = false;\n     }\n \n         TagName tagName = TagName.valueOf(tag);\n         if (!tagNames.contains(tagName))\n             tagNames.add(tagName);\n-        Set<AttributeKey> attributeSet = new HashSet<AttributeKey>();\n+        Set<AttributeKey> attributeSet = new HashSet<>();\n         for (String key : attributes) {\n             Validate.notEmpty(key);\n             attributeSet.add(AttributeKey.valueOf(key));\n         Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n \n         TagName tagName = TagName.valueOf(tag);\n-        Set<AttributeKey> attributeSet = new HashSet<AttributeKey>();\n+        Set<AttributeKey> attributeSet = new HashSet<>();\n         for (String key : attributes) {\n             Validate.notEmpty(key);\n             attributeSet.add(AttributeKey.valueOf(key));\n         if (enforcedAttributes.containsKey(tagName)) {\n             enforcedAttributes.get(tagName).put(attrKey, attrVal);\n         } else {\n-            Map<AttributeKey, AttributeValue> attrMap = new HashMap<AttributeKey, AttributeValue>();\n+            Map<AttributeKey, AttributeValue> attrMap = new HashMap<>();\n             attrMap.put(attrKey, attrVal);\n             enforcedAttributes.put(tagName, attrMap);\n         }\n         if (this.protocols.containsKey(tagName)) {\n             attrMap = this.protocols.get(tagName);\n         } else {\n-            attrMap = new HashMap<AttributeKey, Set<Protocol>>();\n+            attrMap = new HashMap<>();\n             this.protocols.put(tagName, attrMap);\n         }\n         if (attrMap.containsKey(attrKey)) {\n             protSet = attrMap.get(attrKey);\n         } else {\n-            protSet = new HashSet<Protocol>();\n+            protSet = new HashSet<>();\n             attrMap.put(attrKey, protSet);\n         }\n         for (String protocol : protocols) {\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n \n     CombiningEvaluator() {\n         super();\n-        evaluators = new ArrayList<Evaluator>();\n+        evaluators = new ArrayList<>();\n     }\n \n     CombiningEvaluator(Collection<Evaluator> evaluators) {\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n      * @return a list of each element's attribute value for the attribute\n      */\n     public List<String> eachAttr(String attributeKey) {\n-        List<String> attrs = new ArrayList<String>(size());\n+        List<String> attrs = new ArrayList<>(size());\n         for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 attrs.add(element.attr(attributeKey));\n      * @see #text()\n      */\n     public List<String> eachText() {\n-        ArrayList<String> texts = new ArrayList<String>(size());\n+        ArrayList<String> texts = new ArrayList<>(size());\n         for (Element el: this) {\n             if (el.hasText())\n                 texts.add(el.text());\n      * @return all of the parents and ancestor elements of the matched elements\n      */\n     public Elements parents() {\n-        HashSet<Element> combo = new LinkedHashSet<Element>();\n+        HashSet<Element> combo = new LinkedHashSet<>();\n         for (Element e: this) {\n             combo.addAll(e.parents());\n         }\n      * no forms.\n      */\n     public List<FormElement> forms() {\n-        ArrayList<FormElement> forms = new ArrayList<FormElement>();\n+        ArrayList<FormElement> forms = new ArrayList<>();\n         for (Element el: this)\n             if (el instanceof FormElement)\n                 forms.add((FormElement) el);\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n \n     private TokenQueue tq;\n     private String query;\n-    private List<Evaluator> evals = new ArrayList<Evaluator>();\n+    private List<Evaluator> evals = new ArrayList<>();\n \n     /**\n      * Create a new QueryParser.\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n         Validate.notEmpty(query);\n         Validate.notNull(roots);\n         Evaluator evaluator = QueryParser.parse(query);\n-        ArrayList<Element> elements = new ArrayList<Element>();\n-        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<Element, Boolean>();\n+        ArrayList<Element> elements = new ArrayList<>();\n+        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<>();\n         // dedupe elements by identity, not equality\n \n         for (Element root : roots) {", "timestamp": 1497738988, "metainfo": ""}