{"sha": "ea00e065f6245a94f87becf7d6ea80c46bc21ef1", "log": "Added support for multiple headers", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n import java.net.Proxy;\n import java.net.URL;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Map;\n \n /**\n         T method(Method method);\n \n         /**\n-         * Get the value of a header. This is a simplified header model, where a header may only have one value.\n+         * Get the value of a header. If there is more than one header with the same name, returns the first header.\n          * <p>\n          * Header names are case insensitive.\n          * </p>\n         String header(String name);\n \n         /**\n-         * Set a header. This method will overwrite any existing header with the same case insensitive name.\n+         * Get the values of a header.\n+         * @param name header name, case insensitive.\n+         * @return a list of values for this header, or an empty list if not set.\n+         */\n+        List<String> headers(String name);\n+\n+        /**\n+         * Set a header. This method will overwrite any existing header with the same case insensitive name. (If there\n+         * is more than one value for this header, this method will update the first matching header.\n          * @param name Name of header\n          * @param value Value of header\n          * @return this, for chaining\n+         * @see #addHeader(String, String)\n          */\n         T header(String name, String value);\n+\n+        /**\n+         * Add a header. The header will be added regardless of whether a header with the same name already exists.\n+         * @param name Name of new header\n+         * @param value Value of new header\n+         * @return this, for chaining\n+         */\n+        T addHeader(String name, String value);\n \n         /**\n          * Check if a header is present\n         boolean hasHeaderWithValue(String name, String value);\n \n         /**\n-         * Remove a header by name\n+         * Remove headers by name. If there is more than one header with this name, they will all be removed.\n          * @param name name of header to remove (case insensitive)\n          * @return this, for chaining\n          */\n         T removeHeader(String name);\n \n         /**\n-         * Retrieve all of the request/response headers as a map\n+         * Retrieve all of the request/response header names and corresponding values as a map. For headers with multiple\n+         * values, only the first header is returned.\n          * @return headers\n+         * @see #multiHeaders()\n+\n          */\n         Map<String, String> headers();\n+\n+        /**\n+         * Retreive all of the headers, keyed by the header name, and with a list of values per header.\n+         * @return a list of multiple values per header.\n+         */\n+        Map<String, List<String>> multiHeaders();\n \n         /**\n          * Get a cookie value by name from this request/response.\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.security.cert.X509Certificate;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n     private static abstract class Base<T extends Connection.Base> implements Connection.Base<T> {\n         URL url;\n         Method method;\n-        Map<String, String> headers;\n+        Map<String, List<String>> headers;\n         Map<String, String> cookies;\n \n         private Base() {\n \n         public String header(String name) {\n             Validate.notNull(name, \"Header name must not be null\");\n-            String val = getHeaderCaseInsensitive(name);\n+            List<String> vals = getHeadersCaseInsensitive(name);\n+            String val = null;\n+            if (vals.size() > 0)\n+                val = vals.get(0);\n+\n             if (val != null) {\n                 // headers should be ISO8859 - but values are often actually UTF-8. Test if it looks like UTF8 and convert if so\n                 val = fixHeaderEncoding(val);\n             }\n             return val;\n+        }\n+\n+        @Override\n+        public T addHeader(String name, String value) {\n+            Validate.notEmpty(name);\n+            Validate.notNull(value);\n+\n+            List<String> values = headers(name);\n+            if (values.isEmpty()) {\n+                values = new ArrayList<>();\n+                headers.put(name, values);\n+            }\n+            values.add(value);\n+\n+            return (T) this;\n+        }\n+\n+        @Override\n+        public List<String> headers(String name) {\n+            Validate.notEmpty(name);\n+            return getHeadersCaseInsensitive(name);\n         }\n \n         private static String fixHeaderEncoding(String val) {\n             Validate.notEmpty(name, \"Header name must not be empty\");\n             Validate.notNull(value, \"Header value must not be null\");\n             removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n-            headers.put(name, value);\n+            addHeader(name, value);\n             return (T) this;\n         }\n \n         public boolean hasHeader(String name) {\n             Validate.notEmpty(name, \"Header name must not be empty\");\n-            return getHeaderCaseInsensitive(name) != null;\n+            return getHeadersCaseInsensitive(name).size() != 0;\n         }\n \n         /**\n          * Test if the request has a header with this value (case insensitive).\n          */\n         public boolean hasHeaderWithValue(String name, String value) {\n-            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n+            Validate.notEmpty(name);\n+            Validate.notEmpty(value);\n+            List<String> values = headers(name);\n+            for (String candidate : values) {\n+                if (value.equalsIgnoreCase(candidate))\n+                    return true;\n+            }\n+            return false;\n         }\n \n         public T removeHeader(String name) {\n             Validate.notEmpty(name, \"Header name must not be empty\");\n-            Map.Entry<String, String> entry = scanHeaders(name); // remove is case insensitive too\n+            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case insensitive too\n             if (entry != null)\n                 headers.remove(entry.getKey()); // ensures correct case\n             return (T) this;\n         }\n \n         public Map<String, String> headers() {\n+            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n+            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n+                String header = entry.getKey();\n+                List<String> values = entry.getValue();\n+                if (values.size() > 0)\n+                    map.put(header, values.get(0));\n+            }\n+            return map;\n+        }\n+\n+        @Override\n+        public Map<String, List<String>> multiHeaders() {\n             return headers;\n         }\n \n-        private String getHeaderCaseInsensitive(String name) {\n-            Validate.notNull(name, \"Header name must not be null\");\n-            // quick evals for common case of title case, lower case, then scan for mixed\n-            String value = headers.get(name);\n-            if (value == null)\n-                value = headers.get(lowerCase(name));\n-            if (value == null) {\n-                Map.Entry<String, String> entry = scanHeaders(name);\n-                if (entry != null)\n-                    value = entry.getValue();\n-            }\n-            return value;\n-        }\n-\n-        private Map.Entry<String, String> scanHeaders(String name) {\n+        private List<String> getHeadersCaseInsensitive(String name) {\n+            Validate.notNull(name);\n+\n+            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n+                if (name.equalsIgnoreCase(entry.getKey()))\n+                    return entry.getValue();\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+        private Map.Entry<String, List<String>> scanHeaders(String name) {\n             String lc = lowerCase(name);\n-            for (Map.Entry<String, String> entry : headers.entrySet()) {\n+            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                 if (lowerCase(entry.getKey()).equals(lc))\n                     return entry;\n             }\n         private boolean validateTSLCertificates = true;\n         private String postDataCharset = DataUtil.defaultCharset;\n \n-        private Request() {\n+        Request() {\n             timeoutMilliseconds = 30000; // 30 seconds\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n             data = new ArrayList<>();\n             method = Method.GET;\n-            headers.put(\"Accept-Encoding\", \"gzip\");\n-            headers.put(USER_AGENT, DEFAULT_UA);\n+            addHeader(\"Accept-Encoding\", \"gzip\");\n+            addHeader(USER_AGENT, DEFAULT_UA);\n             parser = Parser.htmlParser();\n         }\n \n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n         HttpConnection.Response res = new HttpConnection.Response();\n         res.processResponseHeaders(headers);\n         assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\"));\n+    }\n+\n+    @Test public void multipleHeaders() {\n+        Connection.Request req = new HttpConnection.Request();\n+        req.addHeader(\"Accept\", \"Something\");\n+        req.addHeader(\"Accept\", \"Everything\");\n+        req.addHeader(\"Foo\", \"Bar\");\n+\n+        assertTrue(req.hasHeader(\"Accept\"));\n+        assertTrue(req.hasHeader(\"ACCEpt\"));\n+        assertEquals(\"Something\", req.header(\"accept\"));\n+        assertTrue(req.hasHeader(\"fOO\"));\n+        assertEquals(\"Bar\", req.header(\"foo\"));\n+\n+        List<String> accept = req.headers(\"accept\");\n+        assertEquals(2, accept.size());\n+        assertEquals(\"Something\", accept.get(0));\n+        assertEquals(\"Everything\", accept.get(1));\n+\n+        Map<String, List<String>> headers = req.multiHeaders();\n+        assertEquals(accept, headers.get(\"Accept\"));\n+        assertEquals(\"Bar\", headers.get(\"Foo\").get(0));\n+\n+        assertTrue(req.hasHeader(\"Accept\"));\n+        assertTrue(req.hasHeaderWithValue(\"accept\", \"Something\"));\n+        assertTrue(req.hasHeaderWithValue(\"accept\", \"Everything\"));\n+        assertFalse(req.hasHeaderWithValue(\"accept\", \"Something for nothing\"));\n+\n+        req.removeHeader(\"accept\");\n+        headers = req.multiHeaders();\n+        assertEquals(\"Bar\", headers.get(\"Foo\").get(0));\n+        assertFalse(req.hasHeader(\"Accept\"));\n+        assertTrue(headers.get(\"Accept\") == null);\n     }\n \n     @Test public void ignoresEmptySetCookies() {", "timestamp": 1507522876, "metainfo": ""}