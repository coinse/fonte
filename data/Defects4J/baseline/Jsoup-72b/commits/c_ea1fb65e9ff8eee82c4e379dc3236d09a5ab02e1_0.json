{"sha": "ea1fb65e9ff8eee82c4e379dc3236d09a5ab02e1", "log": "Refactored Attributes to be an array pair vs LinkedHashSet  Also a couple perf (cpu / garbage) tweaks", "commit": "\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n  * A minimal String utility class. Designed for internal jsoup use only.\n  */\n public final class StringUtil {\n-    // memoised padding up to 10\n-    private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\n+    // memoised padding up to 21\n+    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n+        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n+        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n \n     /**\n      * Join a collection of strings by a separator\n \n         if (width < padding.length)\n             return padding[width];\n-\n         char[] out = new char[width];\n         for (int i = 0; i < width; i++)\n             out[i] = ' ';\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n import java.util.Map;\n \n /**\n- A single key + value attribute. Keys are trimmed and normalised to lower-case.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ A single key + value attribute. (Only used for presentation.)\n+ */\n public class Attribute implements Map.Entry<String, String>, Cloneable  {\n     private static final String[] booleanAttributes = {\n             \"allowfullscreen\", \"async\", \"autofocus\", \"checked\", \"compact\", \"declare\", \"default\", \"defer\", \"disabled\",\n     };\n \n     private String key;\n-    private String value;\n+    private String val;\n+    Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface\n \n     /**\n      * Create a new attribute from unencoded (raw) key and value.\n      * @see #createFromEncoded\n      */\n     public Attribute(String key, String value) {\n+        this(key, value, null);\n+    }\n+\n+    /**\n+     * Create a new attribute from unencoded (raw) key and value.\n+     * @param key attribute key; case is preserved.\n+     * @param val attribute value\n+     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n+     * @see #createFromEncoded*/\n+    public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n-        Validate.notNull(value);\n         this.key = key.trim();\n         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n-        this.value = value;\n+        this.val = val;\n+        this.parent = parent;\n     }\n \n     /**\n      */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key.trim();\n+        key = key.trim();\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.keys[i] = key;\n+        }\n+        this.key = key;\n     }\n \n     /**\n      @return the attribute value\n      */\n     public String getValue() {\n-        return value;\n+        return val;\n     }\n \n     /**\n      Set the attribute value.\n-     @param value the new attribute value; must not be null\n-     */\n-    public String setValue(String value) {\n-        Validate.notNull(value);\n-        String old = this.value;\n-        this.value = value;\n-        return old;\n+     @param val the new attribute value; must not be null\n+     */\n+    public String setValue(String val) {\n+        String oldVal = parent.get(this.key);\n+        if (parent != null) {\n+            int i = parent.indexOfKey(this.key);\n+            if (i != Attributes.NotFound)\n+                parent.vals[i] = val;\n+        }\n+        this.val = val;\n+        return oldVal;\n     }\n \n     /**\n         }\n         return accum.toString();\n     }\n+\n+    protected static void html(String key, String val, Appendable accum, Document.OutputSettings out) throws IOException {\n+        accum.append(key);\n+        if (!shouldCollapseAttribute(key, val, out)) {\n+            accum.append(\"=\\\"\");\n+            Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);\n+            accum.append('\"');\n+        }\n+    }\n     \n     protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n-        accum.append(key);\n-        if (!shouldCollapseAttribute(out)) {\n-            accum.append(\"=\\\"\");\n-            Entities.escape(accum, value, out, true, false, false);\n-            accum.append('\"');\n-        }\n+        html(key, val, accum, out);\n     }\n \n     /**\n      */\n     public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\n         String value = Entities.unescape(encodedValue, true);\n-        return new Attribute(unencodedKey, value);\n+        return new Attribute(unencodedKey, value, null); // parent will get set when Put\n     }\n \n     protected boolean isDataAttribute() {\n+        return isDataAttribute(key);\n+    }\n+\n+    protected static boolean isDataAttribute(String key) {\n         return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();\n     }\n \n      * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n-        return (\"\".equals(value) || value.equalsIgnoreCase(key))\n-                && out.syntax() == Document.OutputSettings.Syntax.html\n-                && isBooleanAttribute();\n-    }\n-\n+        return shouldCollapseAttribute(key, val, out);\n+    }\n+\n+    protected static boolean shouldCollapseAttribute(String key, String val, Document.OutputSettings out) {\n+        // todo: optimize\n+        return (val == null || \"\".equals(val) || val.equalsIgnoreCase(key))\n+            && out.syntax() == Document.OutputSettings.Syntax.html\n+            && isBooleanAttribute(key);\n+    }\n+\n+    /**\n+     * @deprecated\n+     */\n     protected boolean isBooleanAttribute() {\n+        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;\n+    }\n+\n+    /**\n+     * Checks if this attribute name is defined as a boolean attribute in HTML5\n+     */\n+    protected static boolean isBooleanAttribute(final String key) {\n         return Arrays.binarySearch(booleanAttributes, key) >= 0;\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n+    public boolean equals(Object o) { // note parent not considered\n         if (this == o) return true;\n-        if (!(o instanceof Attribute)) return false;\n-\n+        if (o == null || getClass() != o.getClass()) return false;\n         Attribute attribute = (Attribute) o;\n-\n         if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n-        return !(value != null ? !value.equals(attribute.value) : attribute.value != null);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n+        return val != null ? val.equals(attribute.val) : attribute.val == null;\n+    }\n+\n+    @Override\n+    public int hashCode() { // note parent not considered\n         int result = key != null ? key.hashCode() : 0;\n-        result = 31 * result + (value != null ? value.hashCode() : 0);\n+        result = 31 * result + (val != null ? val.hashCode() : 0);\n         return result;\n     }\n \n     @Override\n     public Attribute clone() {\n         try {\n-            return (Attribute) super.clone(); // only fields are immutable strings key and value, so no more deep copy required\n+            return (Attribute) super.clone();\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n         }\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n import java.util.AbstractMap;\n import java.util.AbstractSet;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Iterator;\n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  * The attributes of an Element.\n  * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n  * </p>\n  * <p>\n- * Attribute name and value comparisons are  <b>case sensitive</b>. By default for HTML, attribute names are\n+ * Attribute name and value comparisons are  generally <b>case sensitive</b>. By default for HTML, attribute names are\n  * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n  * name.\n  * </p>\n  */\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n-\n-    private LinkedHashMap<String, Attribute> attributes = null;\n-    // linked hash map to preserve insertion order.\n-    // null be default as so many elements have no attributes -- saves a good chunk of memory\n+    private static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n+\n+    // manages the key/val arrays\n+    private static final int GrowthFactor = 2;\n+    private static final String[] Empty = {};\n+    static final int NotFound = -1;\n+    private static final String EmptyString = \"\";\n+\n+    private int size = 0; // number of slots used (not capacity, which is keys.length\n+    String[] keys = Empty;\n+    String[] vals = Empty;\n+\n+    // check there's room for more\n+    private void checkCapacity(int minNewSize) {\n+        Validate.isTrue(minNewSize >= size);\n+        int curSize = keys.length;\n+        if (curSize >= minNewSize)\n+            return;\n+\n+        int newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n+        if (minNewSize > newSize)\n+            newSize = minNewSize;\n+\n+        keys = Arrays.copyOf(keys, newSize);\n+        vals = Arrays.copyOf(vals, newSize);\n+    }\n+\n+    int indexOfKey(String key) {\n+        Validate.notNull(key);\n+        for (int i = 0; i < size; i++) {\n+            if (key.equals(keys[i]))\n+                return i;\n+        }\n+        return NotFound;\n+    }\n+\n+    private int indexOfKeyIgnoreCase(String key) {\n+        Validate.notNull(key);\n+        for (int i = 0; i < size; i++) {\n+            if (key.equalsIgnoreCase(keys[i]))\n+                return i;\n+        }\n+        return NotFound;\n+    }\n+\n+    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n+    static final String checkNotNull(String val) {\n+        return val == null ? EmptyString : val;\n+    }\n \n     /**\n      Get an attribute value by key.\n      @param key the (case-sensitive) attribute key\n-     @return the attribute value if set; or empty string if not set.\n+     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n      @see #hasKey(String)\n      */\n     public String get(String key) {\n-        Validate.notEmpty(key);\n-\n-        if (attributes == null)\n-            return \"\";\n-\n-        Attribute attr = attributes.get(key);\n-        return attr != null ? attr.getValue() : \"\";\n+        int i = indexOfKey(key);\n+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n     }\n \n     /**\n      * Get an attribute's value by case-insensitive key\n      * @param key the attribute name\n-     * @return the first matching attribute value if set; or empty string if not set.\n+     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n      */\n     public String getIgnoreCase(String key) {\n-        Attribute attr = getAttributeIgnoreCase(key);\n-        return attr != null ? attr.getValue() : \"\";\n-    }\n-\n-    private Attribute getAttributeIgnoreCase(String key) {\n-        Validate.notEmpty(key);\n-        if (attributes == null)\n-            return null;\n-\n-        Attribute attr = attributes.get(key);\n-        if (attr != null)\n-            return attr;\n-\n-        for (String attrKey : attributes.keySet()) {\n-            if (attrKey.equalsIgnoreCase(key))\n-                return attributes.get(attrKey);\n-        }\n-        return null;\n+        int i = indexOfKeyIgnoreCase(key);\n+        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n+    }\n+\n+    // adds without checking if this key exists\n+    private void add(String key, String value) {\n+        checkCapacity(size + 1);\n+        keys[size] = key;\n+        vals[size] = value;\n+        size++;\n     }\n \n     /**\n      * Set a new attribute, or replace an existing one by key.\n-     * @param key attribute key\n+     * @param key case sensitive attribute key\n      * @param value attribute value\n      * @return these attributes, for chaining\n      */\n     public Attributes put(String key, String value) {\n-        Attribute attr = new Attribute(key, value);\n-        put(attr);\n+        int i = indexOfKey(key);\n+        if (i != NotFound)\n+            vals[i] = value;\n+        else\n+            add(key, value);\n         return this;\n     }\n \n     void putIgnoreCase(String key, String value) {\n-        Attribute oldAttr = getAttributeIgnoreCase(key);\n-        if (oldAttr != null && !oldAttr.getKey().equals(key)) {\n-            attributes.remove(oldAttr.getKey());\n-        }\n-\n-        put(key, value);\n+        int i = indexOfKeyIgnoreCase(key);\n+        if (i != NotFound) {\n+            vals[i] = value;\n+            if (!keys[i].equals(key)) // case changed, update\n+                keys[i] = key;\n+        }\n+        else\n+            add(key, value);\n     }\n \n     /**\n      * Set a new boolean attribute, remove attribute if value is false.\n-     * @param key attribute key\n+     * @param key case <b>insensitive</b> attribute key\n      * @param value attribute value\n      * @return these attributes, for chaining\n      */\n     public Attributes put(String key, boolean value) {\n         if (value)\n-            put(new BooleanAttribute(key));\n+            putIgnoreCase(key, null);\n         else\n             remove(key);\n         return this;\n \n     /**\n      Set a new attribute, or replace an existing one by key.\n-     @param attribute attribute\n+     @param attribute attribute with case sensitive key\n      @return these attributes, for chaining\n      */\n     public Attributes put(Attribute attribute) {\n         Validate.notNull(attribute);\n-        if (attributes == null)\n-             attributes = new LinkedHashMap<>(2);\n-        attributes.put(attribute.getKey(), attribute);\n+        put(attribute.getKey(), attribute.getValue());\n+        attribute.parent = this;\n         return this;\n+    }\n+\n+    // removes and shifts up\n+    private void remove(int index) {\n+        Validate.isFalse(index >= size);\n+        int shifted = size - index - 1;\n+        if (shifted > 0) {\n+            System.arraycopy(keys, index + 1, keys, index, shifted);\n+            System.arraycopy(vals, index + 1, vals, index, shifted);\n+        }\n+        size--;\n+        keys[size] = null; // release hold\n+        vals[size] = null;\n     }\n \n     /**\n      @param key attribute key to remove\n      */\n     public void remove(String key) {\n-        Validate.notEmpty(key);\n-        if (attributes == null)\n-            return;\n-        attributes.remove(key);\n+        int i = indexOfKey(key);\n+        if (i != NotFound)\n+            remove(i);\n     }\n \n     /**\n      @param key attribute key to remove\n      */\n     public void removeIgnoreCase(String key) {\n-        Validate.notEmpty(key);\n-        if (attributes == null)\n-            return;\n-        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n-            String attrKey = it.next();\n-            if (attrKey.equalsIgnoreCase(key))\n-                it.remove();\n-        }\n+        int i = indexOfKeyIgnoreCase(key);\n+        if (i != NotFound)\n+            remove(i);\n     }\n \n     /**\n      @return true if key exists, false otherwise\n      */\n     public boolean hasKey(String key) {\n-        return attributes != null && attributes.containsKey(key);\n+        return indexOfKey(key) != NotFound;\n     }\n \n     /**\n      @return true if key exists, false otherwise\n      */\n     public boolean hasKeyIgnoreCase(String key) {\n-        if (attributes == null)\n-            return false;\n-        for (String attrKey : attributes.keySet()) {\n-            if (attrKey.equalsIgnoreCase(key))\n-                return true;\n-        }\n-        return false;\n+        return indexOfKeyIgnoreCase(key) != NotFound;\n     }\n \n     /**\n      @return size\n      */\n     public int size() {\n-        if (attributes == null)\n-            return 0;\n-        return attributes.size();\n+        return size;\n     }\n \n     /**\n     public void addAll(Attributes incoming) {\n         if (incoming.size() == 0)\n             return;\n-        if (attributes == null)\n-            attributes = new LinkedHashMap<>(incoming.size());\n-        attributes.putAll(incoming.attributes);\n+        checkCapacity(size + incoming.size);\n+\n+        for (Attribute attr : incoming) {\n+            // todo - should this be case insensitive?\n+            put(attr);\n+        }\n+\n     }\n \n     public Iterator<Attribute> iterator() {\n-        if (attributes == null || attributes.isEmpty()) {\n-            return Collections.<Attribute>emptyList().iterator();\n-        }\n-\n-        return attributes.values().iterator();\n-    }\n-\n-    /**\n-     Get the attributes as a List, for iteration. Do not modify the keys of the attributes via this view, as changes\n-     to keys will not be recognised in the containing set.\n-     @return an view of the attributes as a List.\n+        return new Iterator<Attribute>() {\n+            int i = 0;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return i < size;\n+            }\n+\n+            @Override\n+            public Attribute next() {\n+                final Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\n+                i++;\n+                return attr;\n+            }\n+\n+            @Override\n+            public void remove() {\n+                Attributes.this.remove(--i); // next() advanced, so rewind\n+            }\n+        };\n+    }\n+\n+    /**\n+     Get the attributes as a List, for iteration.\n+     @return an view of the attributes as an unmodifialbe List.\n      */\n     public List<Attribute> asList() {\n-        if (attributes == null)\n-            return Collections.emptyList();\n-\n-        List<Attribute> list = new ArrayList<>(attributes.size());\n-        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n-            list.add(entry.getValue());\n+        ArrayList<Attribute> list = new ArrayList<>(size);\n+        for (int i = 0; i < size; i++) {\n+            Attribute attr = vals[i] == null ?\n+                new BooleanAttribute(keys[i]) : // deprecated class, but maybe someone still wants it\n+                new Attribute(keys[i], vals[i], Attributes.this);\n+            list.add(attr);\n         }\n         return Collections.unmodifiableList(list);\n     }\n      * @return map of custom data attributes.\n      */\n     public Map<String, String> dataset() {\n-        return new Dataset();\n+        return new Dataset(this);\n     }\n \n     /**\n         return accum.toString();\n     }\n \n-    void html(Appendable accum, Document.OutputSettings out) throws IOException {\n-        if (attributes == null)\n-            return;\n-\n-        for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n-            Attribute attribute = entry.getValue();\n-            accum.append(\" \");\n-            attribute.html(accum, out);\n+    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n+        final int sz = size;\n+        for (int i = 0; i < sz; i++) {\n+            // inlined from Attribute.html()\n+            final String key = keys[i];\n+            final String val = vals[i];\n+            accum.append(' ').append(key);\n+\n+            // collapse checked=null, checked=\"\", checked=checked; write out others\n+            if (!(out.syntax() == Document.OutputSettings.Syntax.html\n+                && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n+\n+                accum.append(\"=\\\"\");\n+                Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n+                accum.append('\"');\n+            }\n         }\n     }\n \n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n-        if (!(o instanceof Attributes)) return false;\n+        if (o == null || getClass() != o.getClass()) return false;\n \n         Attributes that = (Attributes) o;\n \n-        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n+        if (size != that.size) return false;\n+        if (!Arrays.equals(keys, that.keys)) return false;\n+        return Arrays.equals(vals, that.vals);\n     }\n \n     /**\n      */\n     @Override\n     public int hashCode() {\n-        return attributes != null ? attributes.hashCode() : 0;\n+        int result = size;\n+        result = 31 * result + Arrays.hashCode(keys);\n+        result = 31 * result + Arrays.hashCode(vals);\n+        return result;\n     }\n \n     @Override\n     public Attributes clone() {\n-        if (attributes == null)\n-            return new Attributes();\n-\n         Attributes clone;\n         try {\n             clone = (Attributes) super.clone();\n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n         }\n-        clone.attributes = new LinkedHashMap<>(attributes.size());\n-        for (Attribute attribute: this)\n-            clone.attributes.put(attribute.getKey(), attribute.clone());\n+        clone.size = size;\n+        keys = Arrays.copyOf(keys, size);\n+        vals = Arrays.copyOf(vals, size);\n         return clone;\n     }\n \n-    private class Dataset extends AbstractMap<String, String> {\n-\n-        private Dataset() {\n-            if (attributes == null)\n-                attributes = new LinkedHashMap<>(2);\n+    /**\n+     * Internal method. Lowercases all keys.\n+     */\n+    public void normalize() {\n+        for (int i = 0; i < size; i++) {\n+            keys[i] = lowerCase(keys[i]);\n+        }\n+    }\n+\n+    private static class Dataset extends AbstractMap<String, String> {\n+        private final Attributes attributes;\n+\n+        private Dataset(Attributes attributes) {\n+            this.attributes = attributes;\n         }\n \n         @Override\n         @Override\n         public String put(String key, String value) {\n             String dataKey = dataKey(key);\n-            String oldValue = hasKey(dataKey) ? attributes.get(dataKey).getValue() : null;\n-            Attribute attr = new Attribute(dataKey, value);\n-            attributes.put(dataKey, attr);\n+            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n+            attributes.put(dataKey, value);\n             return oldValue;\n         }\n \n                 return new DatasetIterator();\n             }\n \n-           @Override\n+            @Override\n             public int size() {\n                 int count = 0;\n                 Iterator iter = new DatasetIterator();\n         }\n \n         private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n-            private Iterator<Attribute> attrIter = attributes.values().iterator();\n+            private Iterator<Attribute> attrIter = attributes.iterator();\n             private Attribute attr;\n             public boolean hasNext() {\n                 while (attrIter.hasNext()) {\n--- a/src/main/java/org/jsoup/nodes/BooleanAttribute.java\n+++ b/src/main/java/org/jsoup/nodes/BooleanAttribute.java\n \n /**\n  * A boolean attribute that is written out without any value.\n+ * @deprecated just use null values (vs empty string) for booleans.\n  */\n public class BooleanAttribute extends Attribute {\n     /**\n      * @param key attribute key\n      */\n     public BooleanAttribute(String key) {\n-        super(key, \"\");\n+        super(key, null);\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\n         private Charset charset;\n-        // enables the doc to be shared in multiple threads, without creating new encoders on every traverse\n-        private final ThreadLocal<CharsetEncoder> encoder = new ThreadLocal<CharsetEncoder>() {\n-            @Override\n-            protected CharsetEncoder initialValue() {\n-                return charset.newEncoder();\n-            }\n-        };\n+        CharsetEncoder encoder; // initialized by start of OuterHtmlVisitor and cleared at end\n+        Entities.CoreCharset coreCharset; // fast encoders for ascii and utf8\n+\n         private boolean prettyPrint = true;\n         private boolean outline = false;\n         private int indentAmount = 1;\n          */\n         public OutputSettings charset(Charset charset) {\n             this.charset = charset;\n-            encoder.remove();\n             return this;\n         }\n \n             return this;\n         }\n \n-        CharsetEncoder encoder() {\n-            CharsetEncoder ce = encoder.get();\n-            // check that the charset wasn't changed since accessed in this thread\n-            // (this is probably overkill for something we're not advertising as threadsafe)\n-            if (!ce.charset().equals(charset)) {\n-                encoder.remove();\n-                ce = encoder.get(); // retrips initialValue()\n-            }\n-            return ce;\n+        CharsetEncoder prepareEncoder() {\n+            encoder = charset.newEncoder(); // created at start of OuterHtmlVisitor so each pass has own encoder, so OutputSettings can be shared among threads\n+            coreCharset = Entities.CoreCharset.byName(encoder.charset().name());\n+            return encoder;\n         }\n \n         /**\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n \n import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document.OutputSettings.Syntax;\n \n import java.io.IOException;\n      * @param systemId the doctype's system ID\n      */\n     public DocumentType(String name, String publicId, String systemId) {\n+        Validate.notNull(name);\n+        Validate.notNull(publicId);\n+        Validate.notNull(systemId);\n         attr(NAME, name);\n         attr(PUBLIC_ID, publicId);\n         if (has(PUBLIC_ID)) {\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n                     if (accum.length() > 0 &&\n                         (element.isBlock() || element.tag.getName().equals(\"br\")) &&\n                         !TextNode.lastCharIsWhitespace(accum))\n-                        accum.append(\" \");\n+                        accum.append(' ');\n                 }\n             }\n \n         return this;\n     }\n \n-    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n         if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n             if (accum instanceof StringBuilder) {\n                 if (((StringBuilder) accum).length() > 0)\n                 indent(accum, depth, out);\n             }\n         }\n-        accum\n-                .append(\"<\")\n-                .append(tagName());\n-        if (hasAttributes())\n-            attributes.html(accum, out);\n+        accum.append('<').append(tagName());\n+        if (attributes != null) attributes.html(accum, out);\n \n         // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n         if (childNodes.isEmpty() && tag.isSelfClosing()) {\n                 accum.append(\" />\"); // <img> in html, <img /> in xml\n         }\n         else\n-            accum.append(\">\");\n+            accum.append('>');\n     }\n \n \tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n                     tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n             )))\n                 indent(accum, depth, out);\n-            accum.append(\"</\").append(tagName()).append(\">\");\n+            accum.append(\"</\").append(tagName()).append('>');\n         }\n     }\n \n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n         boolean lastWasWhite = false;\n         boolean reachedNonWhite = false;\n         final EscapeMode escapeMode = out.escapeMode();\n-        final CharsetEncoder encoder = out.encoder();\n-        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n+        final CharsetEncoder encoder = out.encoder != null ? out.encoder : out.prepareEncoder();\n+        final CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\n         final int length = string.length();\n \n         int codePoint;\n         }\n     }\n \n-    private enum CoreCharset {\n+    enum CoreCharset {\n         ascii, utf, fallback;\n \n-        private static CoreCharset byName(String name) {\n+        static CoreCharset byName(final String name) {\n             if (name.equals(\"US-ASCII\"))\n                 return ascii;\n             if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n-\n-import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n         String val = attributes().getIgnoreCase(attributeKey);\n         if (val.length() > 0)\n             return val;\n-        else if (lowerCase(attributeKey).startsWith(\"abs:\"))\n+        else if (attributeKey.startsWith(\"abs:\"))\n             return absUrl(attributeKey.substring(\"abs:\".length()));\n         else return \"\";\n     }\n      @param accum accumulator to place HTML into\n      @throws IOException if appending to the given accumulator fails.\n      */\n-    abstract void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n-\n-    abstract void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n+    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;\n+\n+    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;\n \n     /**\n      * Write this node and its children to the given {@link Appendable}.\n     }\n \n     protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n-        accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n+        accum.append('\\n').append(StringUtil.padding(depth * out.indentAmount()));\n     }\n \n     /**\n         OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n             this.accum = accum;\n             this.out = out;\n+            out.prepareEncoder();\n         }\n \n         public void head(Node node, int depth) {\n--- a/src/main/java/org/jsoup/parser/ParseSettings.java\n+++ b/src/main/java/org/jsoup/parser/ParseSettings.java\n package org.jsoup.parser;\n \n-import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n \n import static org.jsoup.internal.Normalizer.lowerCase;\n \n     Attributes normalizeAttributes(Attributes attributes) {\n         if (!preserveAttributeCase) {\n-            for (Attribute attr : attributes) {\n-                attr.setKey(lowerCase(attr.getKey()));\n-            }\n+            attributes.normalize();\n         }\n         return attributes;\n     }\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n-import org.jsoup.nodes.BooleanAttribute;\n \n import static org.jsoup.internal.Normalizer.lowerCase;\n \n                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                 pendingAttributeName = pendingAttributeName.trim();\n                 if (pendingAttributeName.length() > 0) {\n-                    Attribute attribute;\n+                    String value;\n                     if (hasPendingAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName,\n-                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\n                     else if (hasEmptyAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName, \"\");\n+                        value = \"\";\n                     else\n-                        attribute = new BooleanAttribute(pendingAttributeName);\n-                    attributes.put(attribute);\n+                        value = null;\n+                    attributes.put(pendingAttributeName, value);\n                 }\n             }\n             pendingAttributeName = null;\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n         assertEquals(\" \", StringUtil.padding(1));\n         assertEquals(\"  \", StringUtil.padding(2));\n         assertEquals(\"               \", StringUtil.padding(15));\n+        assertEquals(\"                                             \", StringUtil.padding(45));\n+    }\n+\n+    @Test public void paddingInACan() {\n+        String[] padding = StringUtil.padding;\n+        assertEquals(21, padding.length);\n+        for (int i = 0; i < padding.length; i++) {\n+            assertEquals(i, padding[i].length());\n+        }\n     }\n \n     @Test public void isBlank() {\n--- a/src/test/java/org/jsoup/nodes/AttributesTest.java\n+++ b/src/test/java/org/jsoup/nodes/AttributesTest.java\n import org.junit.Test;\n \n import java.util.Iterator;\n+import java.util.Map;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n         assertTrue(a.hasKeyIgnoreCase(\"tot\"));\n         assertEquals(\"There\", a.getIgnoreCase(\"hEllo\"));\n \n-        assertEquals(1, a.dataset().size());\n-        assertEquals(\"Jsoup\", a.dataset().get(\"name\"));\n+        Map<String, String> dataset = a.dataset();\n+        assertEquals(1, dataset.size());\n+        assertEquals(\"Jsoup\", dataset.get(\"name\"));\n         assertEquals(\"\", a.get(\"tot\"));\n         assertEquals(\"a&p\", a.get(\"Tot\"));\n         assertEquals(\"a&p\", a.getIgnoreCase(\"tot\"));\n         a.put(\"Tot\", \"a&p\");\n         a.put(\"Hello\", \"There\");\n         a.put(\"data-name\", \"Jsoup\");\n+        assertTrue(a.hasKey(\"Tot\"));\n \n         Iterator<Attribute> iterator = a.iterator();\n-        iterator.next();\n+        Attribute attr = iterator.next();\n+        assertEquals(\"Tot\", attr.getKey());\n         iterator.remove();\n         assertEquals(2, a.size());\n+        attr = iterator.next();\n+        assertEquals(\"Hello\", attr.getKey());\n+        assertEquals(\"There\", attr.getValue());\n+\n+        // make sure that's flowing to the underlying attributes object\n+        assertEquals(2, a.size());\n+        assertEquals(\"There\", a.get(\"Hello\"));\n+        assertFalse(a.hasKey(\"Tot\"));\n+    }\n+\n+    @Test\n+    public void testIteratorUpdateable() {\n+        Attributes a = new Attributes();\n+        a.put(\"Tot\", \"a&p\");\n+        a.put(\"Hello\", \"There\");\n+\n+        assertFalse(a.hasKey(\"Foo\"));\n+        Iterator<Attribute> iterator = a.iterator();\n+        Attribute attr = iterator.next();\n+        attr.setKey(\"Foo\");\n+        attr = iterator.next();\n+        attr.setKey(\"Bar\");\n+        attr.setValue(\"Qux\");\n+\n+        assertEquals(\"a&p\", a.get(\"Foo\"));\n+        assertEquals(\"Qux\", a.get(\"Bar\"));\n+        assertFalse(a.hasKey(\"Tot\"));\n+        assertFalse(a.hasKey(\"Hello\"));\n+    }\n+\n+    @Test public void testIteratorHasNext() {\n+        Attributes a = new Attributes();\n+        a.put(\"Tot\", \"1\");\n+        a.put(\"Hello\", \"2\");\n+        a.put(\"data-name\", \"3\");\n+\n+        int seen = 0;\n+        for (Attribute attribute : a) {\n+            seen++;\n+            assertEquals(String.valueOf(seen), attribute.getValue());\n+        }\n+        assertEquals(3, seen);\n     }\n \n     @Test", "timestamp": 1499199031, "metainfo": ""}