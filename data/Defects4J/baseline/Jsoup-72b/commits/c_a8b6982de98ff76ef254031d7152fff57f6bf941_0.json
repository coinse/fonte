{"sha": "a8b6982de98ff76ef254031d7152fff57f6bf941", "log": "Merge pull request #666 from hatsuyuki15/master  307 redirect should preserve request method & data", "commit": "\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n     private static final String CONTENT_TYPE = \"Content-Type\";\n     private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n     private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n+    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n \n     public static Connection connect(String url) {\n         Connection con = new HttpConnection();\n \n                 // redirect if there's a location header (from 3xx, or 201 etc)\n                 if (res.hasHeader(LOCATION) && req.followRedirects()) {\n-                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n-                    req.data().clear();\n+                    if (status != HTTP_TEMP_REDIR) {\n+                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n+                        req.data().clear();\n+                    }\n \n                     String location = res.header(LOCATION);\n                     if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.Proxy;\n import java.net.URL;\n import java.util.Collection;\n import java.util.Map;\n      * @return this Connection, for chaining\n      */\n     Connection url(String url);\n+\n+    /**\n+     * Set the proxy to use for this request. Set to <code>null</code> to disable.\n+     * @param proxy proxy to use\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(Proxy proxy);\n+\n+    /**\n+     * Set the HTTP proxy to use for this request.\n+     * @param proxy proxy to use\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(String host, int port);\n \n     /**\n      * Set the request user-agent header.\n      * Represents a HTTP request.\n      */\n     interface Request extends Base<Request> {\n-\n+        /**\n+         * Get the proxy used for this request.\n+         * @return the proxy; <code>null</code> if not enabled.\n+         */\n+        Proxy proxy();\n+\n+        /**\n+         * Update the proxy for this request.\n+         * @param proxy the proxy ot use; <code>null</code> to disable.\n+         * @return this Request, for chaining\n+         */\n+        Request proxy(Proxy proxy);\n+\n+        /**\n+         * Set the HTTP proxy to use for this request.\n+         * @param proxy proxy to use\n+         * @return this Connection, for chaining\n+         */\n+        Request proxy(String host, int port);\n \n         /**\n          * Get the request timeout, in milliseconds.\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n package org.jsoup.helper;\n \n-import org.jsoup.Connection;\n-import org.jsoup.HttpStatusException;\n-import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.*;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n import javax.net.ssl.*;\n import java.io.*;\n-import java.net.HttpURLConnection;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLEncoder;\n+import java.net.*;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n         return this;\n     }\n \n+    public Connection proxy(Proxy proxy) {\n+        req.proxy(proxy);\n+        return this;\n+    }\n+\n+    public Connection proxy(String host, int port) {\n+        req.proxy(host, port);\n+        return this;\n+    }\n+\n     public Connection userAgent(String userAgent) {\n         Validate.notNull(userAgent, \"User agent must not be null\");\n         req.header(\"User-Agent\", userAgent);\n     }\n \n     public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n+        private Proxy proxy; // nullable\n         private int timeoutMilliseconds;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n             method = Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n             parser = Parser.htmlParser();\n+        }\n+\n+        public Proxy proxy() {\n+            return proxy;\n+        }\n+\n+        public Request proxy(Proxy proxy) {\n+            this.proxy = proxy;\n+            return this;\n+        }\n+\n+        public Request proxy(String host, int port) {\n+            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n+            return this;\n         }\n \n         public int timeout() {\n                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                 if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                     InputStream bodyStream = null;\n-                    InputStream dataStream = null;\n                     try {\n-                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n-                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n-                                new BufferedInputStream(dataStream);\n+                        bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                        if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n+                            bodyStream = new GZIPInputStream(bodyStream);\n \n                         res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                     } finally {\n                         if (bodyStream != null) bodyStream.close();\n-                        if (dataStream != null) dataStream.close();\n                     }\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n \n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n-            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+            final HttpURLConnection conn = (HttpURLConnection) (\n+                req.proxy() == null ?\n+                req.url().openConnection() :\n+                req.url().openConnection(req.proxy())\n+            );\n \n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n     String consumeToAny(final char... chars) {\n         final int start = pos;\n         final int remaining = length;\n+        final char[] val = input;\n \n         OUTER: while (pos < remaining) {\n             for (char c : chars) {\n-                if (input[pos] == c)\n+                if (val[pos] == c)\n                     break OUTER;\n             }\n             pos++;\n             cached = new String(val, start, count);\n             cache[index] = cached;\n         } else { // hashcode hit, check equality\n-            if (rangeEquals(start, count, cached)) {\n-                // hit\n+            if (rangeEquals(start, count, cached)) { // hit\n                 return cached;\n             } else { // hashcode conflict\n                 cached = new String(val, start, count);\n+                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n             }\n         }\n         return cached;\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         protected String tagName;\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n         private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n+        private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n         private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\n         private boolean hasPendingAttributeValue = false;\n         boolean selfClosing = false;\n             tagName = null;\n             pendingAttributeName = null;\n             reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n             hasEmptyAttributeValue = false;\n             hasPendingAttributeValue = false;\n             selfClosing = false;\n             if (pendingAttributeName != null) {\n                 Attribute attribute;\n                 if (hasPendingAttributeValue)\n-                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\n+                    attribute = new Attribute(pendingAttributeName,\n+                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                 else if (hasEmptyAttributeValue)\n                     attribute = new Attribute(pendingAttributeName, \"\");\n                 else\n             hasEmptyAttributeValue = false;\n             hasPendingAttributeValue = false;\n             reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n         }\n \n         final void finaliseTag() {\n \n         final void appendAttributeValue(String append) {\n             ensureAttributeValue();\n-            pendingAttributeValue.append(append);\n+            if (pendingAttributeValue.length() == 0) {\n+                pendingAttributeValueS = append;\n+            } else {\n+                pendingAttributeValue.append(append);\n+            }\n         }\n \n         final void appendAttributeValue(char append) {\n \n         private void ensureAttributeValue() {\n             hasPendingAttributeValue = true;\n+            // if on second hit, we'll need to move to the builder\n+            if (pendingAttributeValueS != null) {\n+                pendingAttributeValue.append(pendingAttributeValueS);\n+                pendingAttributeValueS = null;\n+            }\n         }\n     }\n \n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n+            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n             else\n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n+            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n             else\n     },\n     AttributeValue_unquoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n+            String value = r.consumeToAnySorted(attributeValueUnquoted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n     private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n     private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n     private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+    private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'};\n \n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n         Arrays.sort(attributeSingleValueCharsSorted);\n         Arrays.sort(attributeDoubleValueCharsSorted);\n         Arrays.sort(attributeNameCharsSorted);\n+        Arrays.sort(attributeValueUnquoted);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n             Validate.notEmpty(value);\n \n             this.key = key.trim().toLowerCase();\n-            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n+            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")\n+                    || value.startsWith(\"'\") && value.endsWith(\"'\")) {\n                 value = value.substring(1, value.length()-1);\n             }\n             this.value = value.trim().toLowerCase();\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n+import java.net.*;\n import java.util.Map;\n \n import static org.hamcrest.core.Is.is;\n         Document doc = response.parse();\n         assertEquals(\"\", doc.text());\n     }\n+\n+\n+    /*\n+     Proxy tests. Assumes local proxy running on 8888, without system propery set (so that specifying it is required).\n+     */\n+\n+    @Test\n+    public void fetchViaHttpProxy() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(\"localhost\", 8888));\n+        Document doc = Jsoup.connect(url).proxy(proxy).get();\n+        assertTrue(doc.title().contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void fetchViaHttpProxySetByArgument() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Document doc = Jsoup.connect(url).proxy(\"localhost\", 8888).get();\n+        assertTrue(doc.title().contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void invalidProxyFails() throws IOException {\n+        boolean caught = false;\n+        String url = \"http://jsoup.org\";\n+        try {\n+            Document doc = Jsoup.connect(url).proxy(\"localhost\", 8889).get();\n+        } catch (IOException e) {\n+            caught = e instanceof ConnectException;\n+        }\n+        assertTrue(caught);\n+    }\n+\n+    @Test\n+    public void proxyGetAndSet() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(\"localhost\", 8889)); // invalid\n+        final Connection con = Jsoup.connect(url).proxy(proxy);\n+\n+        assert con.request().proxy() == proxy;\n+        con.request().proxy(null); // disable\n+        Document doc = con.get();\n+        assertTrue(doc.title().contains(\"jsoup\")); // would fail if actually went via proxy\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         Document doc = Jsoup.parse(body);\n         assertEquals(1, doc.body().children().size());\n     }\n+\n+    @Test public void testUsingSingleQuotesInQueries() {\n+        String body = \"<body> <div class='main'>hello</div></body>\";\n+        Document doc = Jsoup.parse(body);\n+        Elements main = doc.select(\"div[class='main']\");\n+        assertEquals(\"hello\", main.text());\n+    }\n }", "timestamp": 1459728377, "metainfo": ""}