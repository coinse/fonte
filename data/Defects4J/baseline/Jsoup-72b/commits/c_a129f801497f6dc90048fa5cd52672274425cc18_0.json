{"sha": "a129f801497f6dc90048fa5cd52672274425cc18", "log": "Simplified and corrected ConstrainableInputStream impl", "commit": "\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n import org.jsoup.select.Elements;\n \n import java.io.BufferedReader;\n-import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n     static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n         if (input == null) // empty body\n             return new Document(baseUri);\n-\n-        if (!(input instanceof ConstrainableInputStream))\n-            input = new ConstrainableInputStream(input, bufferSize, 0);\n+        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n \n         Document doc = null;\n         boolean fullyRead = false;\n      */\n     public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n         Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n-        final boolean capped = maxSize > 0;\n-        final byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n-        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n-\n-        int read;\n-        int remaining = maxSize;\n-\n-        while (true) {\n-            read = inStream.read(buffer);\n-            if (read == -1) break;\n-            if (capped) { // todo - why not using ConstrainedInputStream?\n-                if (read >= remaining) {\n-                    outStream.write(buffer, 0, remaining);\n-                    break;\n-                }\n-                remaining -= read;\n-            }\n-            outStream.write(buffer, 0, read);\n-        }\n-        return ByteBuffer.wrap(outStream.toByteArray());\n+        final ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\n+        return input.readToByteBuffer(maxSize);\n     }\n \n     static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n                     res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                     if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n                         res.bodyStream = new GZIPInputStream(res.bodyStream);\n-                    res.bodyStream = new ConstrainableInputStream(res.bodyStream, DataUtil.bufferSize, req.maxBodySize());\n+                    res.bodyStream = ConstrainableInputStream.wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize());\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n                 }\n             Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n             Validate.isFalse(inputStreamRead, \"Request has already been read\");\n             inputStreamRead = true;\n-            return new ConstrainableInputStream(bodyStream, DataUtil.bufferSize, req.maxBodySize());\n+            return ConstrainableInputStream.wrap(bodyStream, DataUtil.bufferSize, req.maxBodySize());\n         }\n \n         // set up connection defaults, and details from request\n--- a/src/main/java/org/jsoup/internal/ConstrainableInputStream.java\n+++ b/src/main/java/org/jsoup/internal/ConstrainableInputStream.java\n import org.jsoup.helper.Validate;\n \n import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.nio.ByteBuffer;\n \n /**\n  * A jsoup internal class (so don't use it as there is no contract API) that enables constraints on an Input Stream,\n  * namely a maximum read size, and the ability to Thread.interrupt() the read.\n  */\n public final class ConstrainableInputStream extends BufferedInputStream {\n+    private static final int DefaultSize = 1024 * 32;\n+\n     private final boolean capped;\n+    private final int maxSize;\n     private int remaining;\n \n-    public ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {\n+    private ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {\n         super(in, bufferSize);\n         Validate.isTrue(maxSize >= 0);\n+        this.maxSize = maxSize;\n         remaining = maxSize;\n         capped = maxSize != 0;\n     }\n \n+    /**\n+     * If this InputStream is not already a ConstrainableInputStream, let it be one.\n+     * @param in the input stream to (maybe) wrap\n+     * @param bufferSize the buffer size to use when reading\n+     * @param maxSize the maximum size to allow to be read. 0 == infinite.\n+     * @return a constrainable input stream\n+     */\n+    public static ConstrainableInputStream wrap(InputStream in, int bufferSize, int maxSize) {\n+        return in instanceof ConstrainableInputStream\n+            ? (ConstrainableInputStream) in\n+            : new ConstrainableInputStream(in, bufferSize, maxSize);\n+    }\n+\n     @Override\n     public int read(byte[] b, int off, int len) throws IOException {\n-        if (Thread.interrupted() || remaining < 0)\n+        if (Thread.interrupted() || capped && remaining <= 0)\n             return -1;\n \n+        if (capped && len > remaining)\n+            len = remaining; // don't read more than desired, even if available\n+\n         final int read = super.read(b, off, len);\n-        if (capped) {\n-            remaining -= read;\n-        }\n+        remaining -= read;\n+\n         return read;\n     }\n+\n+    /**\n+     * Reads this inputstream to a ByteBuffer. The supplied max may be less than the inputstream's max, to support\n+     * reading just the first bytes.\n+     */\n+    public ByteBuffer readToByteBuffer(int max) throws IOException {\n+        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n+        final boolean localCapped = max > 0; // still possibly capped in total stream\n+        final int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\n+        final byte[] readBuffer = new byte[bufferSize];\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n+\n+        int read;\n+        int remaining = max;\n+\n+        while (true) {\n+            read = read(readBuffer);\n+            if (read == -1) break;\n+            if (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\n+                if (read >= remaining) {\n+                    outStream.write(readBuffer, 0, remaining);\n+                    break;\n+                }\n+                remaining -= read;\n+            }\n+            outStream.write(readBuffer, 0, read);\n+        }\n+        return ByteBuffer.wrap(outStream.toByteArray());\n+    }\n+\n+    @Override\n+    public void reset() throws IOException {\n+        super.reset();\n+        remaining = maxSize - markpos;\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n \n         int actualDocText = 269541;\n         assertEquals(actualDocText, defaultRes.parse().text().length());\n-        assertEquals(47200, smallRes.parse().text().length());\n+        assertEquals(49165, smallRes.parse().text().length());\n         assertEquals(196577, mediumRes.parse().text().length());\n         assertEquals(actualDocText, largeRes.parse().text().length());\n         assertEquals(actualDocText, unlimitedRes.parse().text().length());\n--- /dev/null\n+++ b/src/test/java/org/jsoup/internal/ConstrainableInputStreamTest.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.Jsoup;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@Ignore\n+public class ConstrainableInputStreamTest {\n+    // todo - move these all to local jetty, don't ignore\n+\n+    @Test\n+    public void remainingAfterFirstRead() throws IOException {\n+        int bufferSize = 5 * 1024;\n+        int capSize = 100 * 1024;\n+\n+        String url = \"http://direct.infohound.net/tools/large.html\"; // 280 K\n+        BufferedInputStream inputStream = Jsoup.connect(url).maxBodySize(capSize)\n+            .execute().bodyStream();\n+\n+        assertTrue(inputStream instanceof ConstrainableInputStream);\n+        ConstrainableInputStream stream = (ConstrainableInputStream) inputStream;\n+\n+        // simulates parse which does a limited read first\n+        stream.mark(bufferSize);\n+        ByteBuffer firstBytes = stream.readToByteBuffer(bufferSize);\n+\n+        byte[] array = firstBytes.array();\n+        String firstText = new String(array, \"UTF-8\");\n+        assertTrue(firstText.startsWith(\"<html><head><title>Large\"));\n+        assertEquals(bufferSize, array.length);\n+\n+        boolean fullyRead = stream.read() == -1;\n+        assertFalse(fullyRead);\n+\n+        // reset and read again\n+        stream.reset();\n+        ByteBuffer fullRead = stream.readToByteBuffer(0);\n+        byte[] fullArray = fullRead.array();\n+        assertEquals(capSize, fullArray.length);\n+        String fullText = new String(fullArray, \"UTF-8\");\n+        assertTrue(fullText.startsWith(firstText));\n+    }\n+\n+    @Test\n+    public void noLimitAfterFirstRead() throws IOException {\n+        int bufferSize = 5 * 1024;\n+\n+        String url = \"http://direct.infohound.net/tools/large.html\"; // 280 K\n+        BufferedInputStream inputStream = Jsoup.connect(url).execute().bodyStream();\n+\n+        assertTrue(inputStream instanceof ConstrainableInputStream);\n+        ConstrainableInputStream stream = (ConstrainableInputStream) inputStream;\n+\n+        // simulates parse which does a limited read first\n+        stream.mark(bufferSize);\n+        ByteBuffer firstBytes = stream.readToByteBuffer(bufferSize);\n+        byte[] array = firstBytes.array();\n+        String firstText = new String(array, \"UTF-8\");\n+        assertTrue(firstText.startsWith(\"<html><head><title>Large\"));\n+        assertEquals(bufferSize, array.length);\n+\n+        // reset and read fully\n+        stream.reset();\n+        ByteBuffer fullRead = stream.readToByteBuffer(0);\n+        byte[] fullArray = fullRead.array();\n+        assertEquals(280735, fullArray.length);\n+        String fullText = new String(fullArray, \"UTF-8\");\n+        assertTrue(fullText.startsWith(firstText));\n+\n+    }\n+}", "timestamp": 1508005575, "metainfo": ""}