{"sha": "ad23b481e4c40fcc73c1fa59513b5a7ab0e271d6", "log": "Add new NodeFilter interface to NodeTraversor", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/NodeFilter.java\n+package org.jsoup.select;\n+\n+import org.jsoup.nodes.Node;\n+\n+/**\n+ * Node filter interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.\n+ * <p>\n+ * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first\n+ * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to\n+ * create a start tag for a node, and tail to create the end tag.\n+ * </p>\n+ * <p>\n+ * For every node, the filter has to decide whether to\n+ * <ul>\n+ * <li>continue ({@link FilterResult#CONTINUE}),</li>\n+ * <li>skip all children ({@link FilterResult#SKIP_CHILDREN}),</li>\n+ * <li>skip node entirely ({@link FilterResult#SKIP_ENTIRELY}),</li>\n+ * <li>remove the subtree ({@link FilterResult#REMOVE}),</li>\n+ * <li>interrupt the iteration and return ({@link FilterResult#STOP}).</li>\n+ * </ul>\n+ * The difference between {@link FilterResult#SKIP_CHILDREN} and {@link FilterResult#SKIP_ENTIRELY} is that the first\n+ * will invoke {@link NodeFilter#tail(Node, int)} on the node, while the latter will not.\n+ * Within {@link NodeFilter#tail(Node, int)}, both are equivalent to {@link FilterResult#CONTINUE}.\n+ * </p>\n+ */\n+public interface NodeFilter {\n+    /**\n+     * Filter decision.\n+     */\n+    public enum FilterResult {\n+        /** Continue processing the tree */\n+        CONTINUE,\n+        /** Skip the child nodes, but do call {@link NodeFilter#tail(Node, int)} next. */\n+        SKIP_CHILDREN,\n+        /** Skip the subtree, and do not call {@link NodeFilter#tail(Node, int)}. */\n+        SKIP_ENTIRELY,\n+        /** Remove the node and its children */\n+        REMOVE,\n+        /** Stop processing */\n+        STOP\n+    }\n+\n+    /**\n+     * Callback for when a node is first visited.\n+     * @param node the node being visited.\n+     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n+     * @return Filter decision\n+     */\n+    FilterResult head(Node node, int depth);\n+\n+    /**\n+     * Callback for when a node is last visited, after all of its descendants have been visited.\n+     * @param node the node being visited.\n+     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node of that will have depth 1.\n+     * @return Filter decision\n+     */\n+    FilterResult tail(Node node, int depth);\n+}\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n package org.jsoup.select;\n \n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n+import org.jsoup.select.NodeFilter.FilterResult;\n \n /**\n  * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.\n         for (Element el : elements)\n             traverse(visitor, el);\n     }\n+\n+    /**\n+     * Start a depth-first filtering of the root and all of its descendants.\n+     * @param filter Node visitor.\n+     * @param root the root node point to traverse.\n+     * @return The filter result of the root node, or {@link FilterResult#STOP}.\n+     */\n+    public static FilterResult filter(NodeFilter filter, Node root) {\n+        Node node = root;\n+        int depth = 0;\n+\n+        while (node != null) {\n+            FilterResult result = filter.head(node, depth);\n+            if (result == FilterResult.STOP)\n+                return result;\n+            // Descend into child nodes:\n+            if (result == FilterResult.CONTINUE && node.childNodeSize() > 0) {\n+                node = node.childNode(0);\n+                ++depth;\n+                continue;\n+            }\n+            // No siblings, move upwards:\n+            while (node.nextSibling() == null && depth > 0) {\n+                // 'tail' current node:\n+                if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n+                    result = filter.tail(node, depth);\n+                    if (result == FilterResult.STOP)\n+                        return result;\n+                }\n+                Node prev = node; // In case we need to remove it below.\n+                node = node.parentNode();\n+                depth--;\n+                if (result == FilterResult.REMOVE)\n+                    prev.remove(); // Remove AFTER finding parent.\n+                result = FilterResult.CONTINUE; // Parent was not pruned.\n+            }\n+            // 'tail' current node, then proceed with siblings:\n+            if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n+                result = filter.tail(node, depth);\n+                if (result == FilterResult.STOP)\n+                    return result;\n+            }\n+            if (node == root)\n+                return result;\n+            Node prev = node; // In case we need to remove it below.\n+            node = node.nextSibling();\n+            if (result == FilterResult.REMOVE)\n+                prev.remove(); // Remove AFTER finding sibling.\n+        }\n+        // root == null?\n+        return FilterResult.CONTINUE;\n+    }\n+\n+    /**\n+     * Start a depth-first filtering of all elements.\n+     * @param filter Node filter.\n+     * @param elements Elements to filter.\n+     */\n+    public static void filter(NodeFilter filter, Elements elements) {\n+        Validate.notNull(filter);\n+        Validate.notNull(elements);\n+        for (Element el : elements)\n+            if (filter(filter, el) == FilterResult.STOP)\n+                break;\n+    }\n }", "timestamp": 1507503484, "metainfo": ""}