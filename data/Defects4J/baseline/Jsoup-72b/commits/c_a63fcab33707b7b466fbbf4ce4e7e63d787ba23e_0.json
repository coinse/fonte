{"sha": "a63fcab33707b7b466fbbf4ce4e7e63d787ba23e", "log": "Implemented a proper total duration timeout", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     Connection userAgent(String userAgent);\n \n     /**\n-     * Set the request timeouts (connect and read). If a timeout occurs, an IOException will be thrown. The default\n-     * timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n-     * <p>Note that a read timeout is not the same as a maximum timeout. As long as the connection is sending bytes at\n-     * least every <i>timeout</i> seconds (e.g. in the case of an infinite stream of data, or a slow large download), the\n-     * read timeout will not fire. This can be mitigated by using a maximum download size (see {@link #maxBodySize(int)}),\n-     * or interrupting the connecting thread after a max timeout.</p>\n+     * Set the total request timeout duration. If a timeout occurs, an {@link java.net.SocketTimeoutException} will be thrown.\n+     * <p>The default timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n+     * <p>Note that this timeout specifies the combined maximum duration of the connection time and the time to read\n+     * the full response.\n      * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n      * @return this Connection, for chaining\n+     * @see #maxBodySize(int)\n      */\n     Connection timeout(int millis);\n \n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n     private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n     private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n     private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n+    private static final int ReadTimeoutMillis = 800; // max time between reads - only throws if exceeds total request timeout\n \n     public static Connection connect(String url) {\n         Connection con = new HttpConnection();\n             else if (methodHasBody)\n                 mimeBoundary = setOutputContentType(req);\n \n+            long startTime = System.nanoTime();\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n                     res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                     if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n                         res.bodyStream = new GZIPInputStream(res.bodyStream);\n-                    res.bodyStream = ConstrainableInputStream.wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize());\n+                    res.bodyStream = ConstrainableInputStream\n+                        .wrap(res.bodyStream, DataUtil.bufferSize, req.maxBodySize())\n+                        .timeout(startTime, req.timeout())\n+                    ;\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n                 }\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n             conn.setConnectTimeout(req.timeout());\n-            conn.setReadTimeout(req.timeout());\n+            conn.setReadTimeout(ReadTimeoutMillis);\n \n             if (conn instanceof HttpsURLConnection) {\n                 if (!req.validateTLSCertificates()) {\n--- a/src/main/java/org/jsoup/internal/ConstrainableInputStream.java\n+++ b/src/main/java/org/jsoup/internal/ConstrainableInputStream.java\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.SocketTimeoutException;\n import java.nio.ByteBuffer;\n \n /**\n \n     private final boolean capped;\n     private final int maxSize;\n+    private long startTime;\n+    private long timeout = -1; // optional max time of request\n     private int remaining;\n     private boolean interrupted;\n \n         this.maxSize = maxSize;\n         remaining = maxSize;\n         capped = maxSize != 0;\n+        startTime = System.nanoTime();\n     }\n \n     /**\n         if (interrupted || capped && remaining <= 0)\n             return -1;\n         if (Thread.interrupted()) {\n-            // tracks if this read was interrupted, because parse() may call twice (and we still want the thread interupt to clear)\n+            // interrupted latches, because parse() may call twice (and we still want the thread interupt to clear)\n             interrupted = true;\n             return -1;\n         }\n+        if (expired())\n+            throw new SocketTimeoutException(\"Read timeout\");\n \n         if (capped && len > remaining)\n             len = remaining; // don't read more than desired, even if available\n \n-        final int read = super.read(b, off, len);\n-        remaining -= read;\n-\n-        return read;\n+        try {\n+            final int read = super.read(b, off, len);\n+            remaining -= read;\n+            return read;\n+        } catch (SocketTimeoutException e) {\n+            return 0;\n+        }\n     }\n \n     /**\n         super.reset();\n         remaining = maxSize - markpos;\n     }\n+\n+    public ConstrainableInputStream timeout(long startTimeNanos, long timeoutMillis) {\n+        this.startTime = startTimeNanos;\n+        this.timeout = timeoutMillis * 1000000;\n+        return this;\n+    }\n+\n+    private boolean expired() {\n+        if (timeout == -1)\n+            return false;\n+\n+        final long now = System.nanoTime();\n+        final long dur = now - startTime;\n+        return (dur > timeout);\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/ConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/ConnectTest.java\n \n import java.io.IOException;\n import java.net.MalformedURLException;\n+import java.net.SocketTimeoutException;\n import java.net.URL;\n \n import static org.jsoup.integration.UrlConnectTest.browserUa;\n \n         assertTrue(body[0].length() == 0); // doesn't ready a failed doc\n     }\n+\n+    @Ignore\n+    @Test public void totalTimeout() throws IOException {\n+        int timeout = 3 * 1000;\n+        long start = System.currentTimeMillis();\n+        boolean threw = false;\n+        try {\n+            Jsoup.connect(SlowRider.Url).timeout(timeout).get();\n+        } catch (SocketTimeoutException e) {\n+            long end = System.currentTimeMillis();\n+            long took = end - start;\n+            assertTrue((\"Time taken was \" + took), took > timeout);\n+            assertTrue((\"Time taken was \" + took), took < timeout * 1.2);\n+            threw = true;\n+        }\n+\n+        assertTrue(threw);\n+    }\n+\n+    @Ignore\n+    @Test public void slowReadOk() throws IOException {\n+        // make sure that a slow read that is under the request timeout is still OK\n+        Document doc = Jsoup.connect(SlowRider.Url)\n+            .data(SlowRider.MaxTimeParam, \"2000\") // the reqest completes in 2 seconds\n+            .get();\n+\n+        Element h1 = doc.selectFirst(\"h1\");\n+        assertEquals(\"outatime\", h1.text());\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/servlets/SlowRider.java\n+++ b/src/test/java/org/jsoup/integration/servlets/SlowRider.java\n public class SlowRider extends BaseServlet {\n     public static final String Url = TestServer.map(SlowRider.class);\n     private static final int SleepTime = 1000;\n+    public static String MaxTimeParam = \"maxTime\";\n+\n \n     @Override\n     protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {\n         res.setStatus(HttpServletResponse.SC_OK);\n         PrintWriter w = res.getWriter();\n \n+        int maxTime = -1;\n+        String maxTimeP = req.getParameter(MaxTimeParam);\n+        if (maxTimeP != null) {\n+            maxTime = Integer.valueOf(maxTimeP);\n+        }\n+\n+        long startTime = System.currentTimeMillis();\n         while (true) {\n             w.println(\"<p>Are you still there?\");\n             boolean err = w.checkError(); // flush and check still ok\n             } catch (InterruptedException e) {\n                 break;\n             }\n+\n+            if (maxTime > 0 && System.currentTimeMillis() > startTime + maxTime) {\n+                w.println(\"<h1>outatime</h1>\");\n+                break;\n+            }\n         }\n     }\n ", "timestamp": 1508044321, "metainfo": ""}