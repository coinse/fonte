{"sha": "1d7e6fa1c5fb974bdae7abeabbb1e5a48dc00967", "log": ":matchText  Fixes #550", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/PseudoTextElement.java\n+package org.jsoup.nodes;\n+\n+import org.jsoup.parser.Tag;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with\n+ * the {@link org.jsoup.select.Selector} {@code :matchText} syntax.\n+ */\n+public class PseudoTextElement extends Element {\n+\n+    public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) {\n+        super(tag, baseUri, attributes);\n+    }\n+\n+    @Override\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+    }\n+\n+    @Override\n+    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+    }\n+}\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n import org.jsoup.nodes.DocumentType;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.PseudoTextElement;\n+import org.jsoup.nodes.TextNode;\n import org.jsoup.nodes.XmlDeclaration;\n \n import java.util.List;\n             return String.format(\":matchesOwn(%s)\", pattern);\n         }\n     }\n+\n+    public static final class MatchText extends Evaluator {\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            if (element instanceof PseudoTextElement)\n+                return true;\n+\n+            List<TextNode> textNodes = element.textNodes();\n+            for (TextNode textNode : textNodes) {\n+                PseudoTextElement pel = new PseudoTextElement(\n+                    org.jsoup.parser.Tag.valueOf(element.tagName()), element.baseUri(), element.attributes());\n+                textNode.replaceWith(pel);\n+                pel.appendChild(textNode);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \":matchText\";\n+        }\n+    }\n }\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n package org.jsoup.select;\n+\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.parser.TokenQueue;\n \n import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-\n-import org.jsoup.helper.StringUtil;\n-import org.jsoup.helper.Validate;\n-import org.jsoup.parser.TokenQueue;\n \n import static org.jsoup.internal.Normalizer.normalize;\n \n         \tevals.add(new Evaluator.IsEmpty());\n         else if (tq.matchChomp(\":root\"))\n         \tevals.add(new Evaluator.IsRoot());\n+        else if (tq.matchChomp(\":matchText\"))\n+            evals.add(new Evaluator.MatchText());\n \t\telse // unhandled\n             throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n \n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsData(<em>data</em>)</code></td><td>elements that contains the specified <em>data</em>. The contents of {@code script} and {@code style} elements, and {@code comment} nodes (etc) are considered data nodes, not text nodes. The search is case insensitive. The data may appear in the found element, or any of its descendants.</td><td><code>script:contains(jsoup)</code> finds script elements containing the data \"jsoup\".</td></tr>\n  * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n+ * <tr><td><code>:matchText</code></td><td>treats text nodes as elements, and so allows you to match against and select text nodes.<p><b>Note</b> that using this selector will modify the DOM, so you may want to {@code clone} your document before using.</td><td>{@code p:matchText:firstChild} with input {@code <p>One<br />Two</p>} will return one {@link org.jsoup.nodes.PseudoTextElement} with text \"{@code One}\".</td></tr>\n  * <tr><td colspan=\"3\"><h3>Structural pseudo selectors</h3></td></tr>\n  * <tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>\n  * <tr><td><code>:nth-child(<em>a</em>n+<em>b</em>)</code></td><td><p>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <code>n</code>, and has a parent element. For values of <code>a</code> and <code>b</code> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <code>a</code> and <code>b</code> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         Document doc = Jsoup.parse(html);\n         assertEquals(\"One\", doc.selectFirst(\"p, div\").text());\n     }\n+\n+    @Test public void textAsElements() {\n+        String html = \"<p>One<br>Two</p>\";\n+        Document doc = Jsoup.parse(html);\n+        String origHtml = doc.html();\n+\n+        Elements one = doc.select(\"p:matchText:first-child\");\n+        assertEquals(\"One\", one.first().text());\n+\n+        Elements two = doc.select(\"p:matchText:last-child\");\n+        assertEquals(\"Two\", two.first().text());\n+\n+        assertEquals(origHtml, doc.html());\n+\n+        assertEquals(\"Two\", doc.select(\"p:matchText + br + *\").text());\n+    }\n+\n+    @Test public void splitOnBr() {\n+        String html = \"<div><p>One<br>Two<br>Three</p></div>\";\n+        Document doc = Jsoup.parse(html);\n+\n+        Elements els = doc.select(\"p:matchText\");\n+        assertEquals(3, els.size());\n+        assertEquals(\"One\", els.get(0).text());\n+        assertEquals(\"Two\", els.get(1).text());\n+        assertEquals(\"Three\", els.get(2).toString());\n+    }\n }", "timestamp": 1510540700, "metainfo": ""}