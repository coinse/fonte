{"sha": "f71712ba5d28df09c9a5b6e3c8a37f05f5e3372d", "log": "Project :: Slimfast  Refactored node hierarchy so that leaf nodes (text, comments, scripts, etc) use 24 bytes vs 40 bytes each.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n     }\n \n     /**\n-     Set a new attribute, or replace an existing one by key.\n-     @param key attribute key\n-     @param value attribute value\n-     */\n-    public void put(String key, String value) {\n+     * Set a new attribute, or replace an existing one by key.\n+     * @param key attribute key\n+     * @param value attribute value\n+     * @return these attributes, for chaining\n+     */\n+    public Attributes put(String key, String value) {\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n+        return this;\n     }\n \n     void putIgnoreCase(String key, String value) {\n     }\n \n     /**\n-    Set a new boolean attribute, remove attribute if value is false.\n-    @param key attribute key\n-    @param value attribute value\n-    */\n-    public void put(String key, boolean value) {\n+     * Set a new boolean attribute, remove attribute if value is false.\n+     * @param key attribute key\n+     * @param value attribute value\n+     * @return these attributes, for chaining\n+     */\n+    public Attributes put(String key, boolean value) {\n         if (value)\n             put(new BooleanAttribute(key));\n         else\n             remove(key);\n+        return this;\n     }\n \n     /**\n      Set a new attribute, or replace an existing one by key.\n      @param attribute attribute\n-     */\n-    public void put(Attribute attribute) {\n+     @return these attributes, for chaining\n+     */\n+    public Attributes put(Attribute attribute) {\n         Validate.notNull(attribute);\n         if (attributes == null)\n              attributes = new LinkedHashMap<>(2);\n         attributes.put(attribute.getKey(), attribute);\n+        return this;\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n  A comment node.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class Comment extends Node {\n+public class Comment extends LeafNode {\n     private static final String COMMENT_KEY = \"comment\";\n \n     /**\n      Create a new comment node.\n      @param data The contents of the comment\n-     @param baseUri base URI\n+     */\n+    public Comment(String data) {\n+        value = data;\n+    }\n+\n+    /**\n+     Create a new comment node.\n+     @param data The contents of the comment\n+     @param baseUri base URI not used. This is a leaf node.\n+     @deprecated\n      */\n     public Comment(String data, String baseUri) {\n-        super(baseUri);\n-        attributes.put(COMMENT_KEY, data);\n+        this(data);\n     }\n \n     public String nodeName() {\n      @return comment content\n      */\n     public String getData() {\n-        return attributes.get(COMMENT_KEY);\n+        return coreValue();\n     }\n \n \tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n  A data node, for contents of style, script tags etc, where contents should not show in text().\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class DataNode extends Node{\n-    private static final String DATA_KEY = \"data\";\n+public class DataNode extends LeafNode {\n \n     /**\n      Create a new DataNode.\n      @param data data contents\n-     @param baseUri base URI\n+     */\n+    public DataNode(String data) {\n+        value = data;\n+    }\n+\n+    /**\n+     Create a new DataNode.\n+     @param data data contents\n+     @param baseUri Unused, Leaf Nodes do not hold base URis\n+     @deprecated\n      */\n     public DataNode(String data, String baseUri) {\n-        super(baseUri);\n-        attributes.put(DATA_KEY, data);\n+        this(data);\n     }\n \n     public String nodeName() {\n      @return data\n      */\n     public String getWholeData() {\n-        return attributes.get(DATA_KEY);\n+        return coreValue();\n     }\n \n     /**\n      * @return this node, for chaining\n      */\n     public DataNode setWholeData(String data) {\n-        attributes.put(DATA_KEY, data);\n+        coreValue(data);\n         return this;\n     }\n \n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n         for (int i = toMove.size()-1; i >= 0; i--) {\n             Node node = toMove.get(i);\n             element.removeChild(node);\n-            body().prependChild(new TextNode(\" \", \"\"));\n+            body().prependChild(new TextNode(\" \"));\n             body().prependChild(node);\n         }\n     }\n             List<Node> toMove = new ArrayList<>();\n             for (int i = 1; i < elements.size(); i++) {\n                 Node dupe = elements.get(i);\n-                toMove.addAll(dupe.childNodes);\n+                toMove.addAll(dupe.ensureChildNodes());\n                 dupe.remove();\n             }\n \n         if (node.nodeName().equals(tag))\n             return (Element) node;\n         else {\n-            for (Node child: node.childNodes) {\n-                Element found = findFirstElementByTagName(tag, child);\n+            int size = node.childNodeSize();\n+            for (int i = 0; i < size; i++) {\n+                Element found = findFirstElementByTagName(tag, node.childNode(i));\n                 if (found != null)\n                     return found;\n             }\n                             decl.attr(\"version\", \"1.0\");\n                         }\n                     } else {\n-                        decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                        decl = new XmlDeclaration(\"xml\", false);\n                         decl.attr(\"version\", \"1.0\");\n                         decl.attr(\"encoding\", charset().displayName());\n \n                         prependChild(decl);\n                     }\n                 } else {\n-                    XmlDeclaration decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                    XmlDeclaration decl = new XmlDeclaration(\"xml\", false);\n                     decl.attr(\"version\", \"1.0\");\n                     decl.attr(\"encoding\", charset().displayName());\n \n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n \n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.nodes.Document.OutputSettings.Syntax;\n+\n import java.io.IOException;\n-\n-import org.jsoup.helper.StringUtil;\n-import org.jsoup.nodes.Document.OutputSettings.*;\n \n /**\n  * A {@code <!DOCTYPE>} node.\n  */\n-public class DocumentType extends Node {\n+public class DocumentType extends LeafNode {\n+    // todo needs a bit of a chunky cleanup. this level of detail isn't needed\n     public static final String PUBLIC_KEY = \"PUBLIC\";\n     public static final String SYSTEM_KEY = \"SYSTEM\";\n     private static final String NAME = \"name\";\n      * @param name the doctype's name\n      * @param publicId the doctype's public ID\n      * @param systemId the doctype's system ID\n-     * @param baseUri the doctype's base URI\n      */\n-    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n-        super(baseUri);\n-\n+    public DocumentType(String name, String publicId, String systemId) {\n         attr(NAME, name);\n         attr(PUBLIC_ID, publicId);\n         if (has(PUBLIC_ID)) {\n      * @param name the doctype's name\n      * @param publicId the doctype's public ID\n      * @param systemId the doctype's system ID\n-     * @param baseUri the doctype's base URI\n+     * @param baseUri unused\n+     * @deprecated\n+     */\n+    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n+        attr(NAME, name);\n+        attr(PUBLIC_ID, publicId);\n+        if (has(PUBLIC_ID)) {\n+            attr(PUB_SYS_KEY, PUBLIC_KEY);\n+        }\n+        attr(SYSTEM_ID, systemId);\n+    }\n+\n+    /**\n+     * Create a new doctype element.\n+     * @param name the doctype's name\n+     * @param publicId the doctype's public ID\n+     * @param systemId the doctype's system ID\n+     * @param baseUri unused\n+     * @deprecated\n      */\n     public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n-        super(baseUri);\n-\n         attr(NAME, name);\n         if (pubSysKey != null) {\n             attr(PUB_SYS_KEY, pubSysKey);\n         }\n         attr(PUBLIC_ID, publicId);\n         attr(SYSTEM_ID, systemId);\n+    }\n+    public void setPubSysKey(String value) {\n+        if (value != null)\n+            attr(PUB_SYS_KEY, value);\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n package org.jsoup.nodes;\n \n+import org.jsoup.helper.ChangeNotifyingArrayList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Element extends Node {\n+    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n+    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n     private Tag tag;\n     private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\n-\n-    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n+    List<Node> childNodes;\n+    private Attributes attributes;\n+    private String baseUri;\n \n     /**\n      * Create a new, standalone element.\n      * @see #appendElement(String)\n      */\n     public Element(Tag tag, String baseUri, Attributes attributes) {\n-        super(baseUri, attributes);\n-        \n-        Validate.notNull(tag);    \n+        Validate.notNull(tag);\n+        Validate.notNull(baseUri);\n+        childNodes = EMPTY_NODES;\n+        this.baseUri = baseUri;\n+        this.attributes = attributes;\n         this.tag = tag;\n     }\n     \n      * @see Tag#valueOf(String, ParseSettings)\n      */\n     public Element(Tag tag, String baseUri) {\n-        this(tag, baseUri, new Attributes());\n+        this(tag, baseUri, null);\n+    }\n+\n+    protected List<Node> ensureChildNodes() {\n+        if (childNodes == EMPTY_NODES) {\n+            childNodes = new NodeList(4);\n+        }\n+        return childNodes;\n+    }\n+\n+    @Override\n+    protected boolean hasAttributes() {\n+        return attributes != null;\n+    }\n+\n+    @Override\n+    public Attributes attributes() {\n+        if (!hasAttributes())\n+            attributes = new Attributes();\n+        return attributes;\n+    }\n+\n+    @Override\n+    public String baseUri() {\n+        return baseUri;\n+    }\n+\n+    @Override\n+    protected void doSetBaseUri(String baseUri) {\n+        this.baseUri = baseUri;\n+    }\n+\n+    @Override\n+    public int childNodeSize() {\n+        return childNodes.size();\n     }\n \n     @Override\n      * @return The id attribute, if present, or an empty string if not.\n      */\n     public String id() {\n-        return attributes.getIgnoreCase(\"id\");\n+        return attributes().getIgnoreCase(\"id\");\n     }\n \n     /**\n      * @return this element\n      */\n     public Element attr(String attributeKey, boolean attributeValue) {\n-        attributes.put(attributeKey, attributeValue);\n+        attributes().put(attributeKey, attributeValue);\n         return this;\n     }\n \n      * @return a map of {@code key=value} custom data attributes.\n      */\n     public Map<String, String> dataset() {\n-        return attributes.dataset();\n+        return attributes().dataset();\n     }\n \n     @Override\n      */\n     public Element appendText(String text) {\n         Validate.notNull(text);\n-        TextNode node = new TextNode(text, baseUri());\n+        TextNode node = new TextNode(text);\n         appendChild(node);\n         return this;\n     }\n      */\n     public Element prependText(String text) {\n         Validate.notNull(text);\n-        TextNode node = new TextNode(text, baseUri());\n+        TextNode node = new TextNode(text);\n         prependChild(node);\n         return this;\n     }\n         Validate.notNull(text);\n \n         empty();\n-        TextNode textNode = new TextNode(text, baseUri);\n+        TextNode textNode = new TextNode(text);\n         appendChild(textNode);\n \n         return this;\n      */\n     public Element classNames(Set<String> classNames) {\n         Validate.notNull(classNames);\n-        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n+        attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n         return this;\n     }\n \n      */\n     // performance sensitive\n     public boolean hasClass(String className) {\n-        final String classAttr = attributes.getIgnoreCase(\"class\");\n+        final String classAttr = attributes().getIgnoreCase(\"class\");\n         final int len = classAttr.length();\n         final int wantLen = className.length();\n \n         accum\n                 .append(\"<\")\n                 .append(tagName());\n-        attributes.html(accum, out);\n+        if (hasAttributes())\n+            attributes.html(accum, out);\n \n         // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n         if (childNodes.isEmpty() && tag.isSelfClosing()) {\n     public Element clone() {\n         return (Element) super.clone();\n     }\n+\n+    @Override\n+    protected Element doClone(Node parent) {\n+        Element clone = (Element) super.doClone(parent);\n+        clone.attributes = attributes != null ? attributes.clone() : null;\n+        clone.baseUri = baseUri;\n+        clone.childNodes = new NodeList(childNodes.size());\n+\n+        clone.childNodes.addAll(childNodes);\n+\n+        return clone;\n+    }\n+\n+    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n+        NodeList(int initialCapacity) {\n+            super(initialCapacity);\n+        }\n+\n+        public void onContentsChanged() {\n+            nodelistChanged();\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/LeafNode.java\n+package org.jsoup.nodes;\n+\n+import org.jsoup.helper.Validate;\n+\n+import java.util.List;\n+\n+abstract class LeafNode extends Node {\n+    Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)\n+\n+    protected final boolean hasAttributes() {\n+        return value instanceof Attributes;\n+    }\n+\n+    @Override\n+    public final Attributes attributes() {\n+        ensureAttributes();\n+        return (Attributes) value;\n+    }\n+\n+    private void ensureAttributes() {\n+        if (!hasAttributes()) {\n+            Object coreValue = value;\n+            Attributes attributes = new Attributes();\n+            value = attributes;\n+            if (coreValue != null)\n+                attributes.put(nodeName(), (String) coreValue);\n+        }\n+    }\n+\n+    String coreValue() {\n+        return attr(nodeName());\n+    }\n+\n+    void coreValue(String value) {\n+        attr(nodeName(), value);\n+    }\n+\n+    @Override\n+    public String attr(String key) {\n+        Validate.notNull(key);\n+        if (!hasAttributes()) {\n+            return key.equals(nodeName()) ? (String) value : EmptyString;\n+        }\n+        return super.attr(key);\n+    }\n+\n+    @Override\n+    public Node attr(String key, String value) {\n+        if (!hasAttributes() && key.equals(nodeName())) {\n+            this.value = value;\n+        } else {\n+            ensureAttributes();\n+            super.attr(key, value);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean hasAttr(String key) {\n+        ensureAttributes();\n+        return super.hasAttr(key);\n+    }\n+\n+    @Override\n+    public Node removeAttr(String key) {\n+        ensureAttributes();\n+        return super.removeAttr(key);\n+    }\n+\n+    @Override\n+    public String absUrl(String key) {\n+        ensureAttributes();\n+        return super.absUrl(key);\n+    }\n+\n+    @Override\n+    public String baseUri() {\n+        return hasParent() ? parent().baseUri() : \"\";\n+    }\n+\n+    @Override\n+    protected void doSetBaseUri(String baseUri) {\n+        // noop\n+    }\n+\n+    @Override\n+    public int childNodeSize() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected List<Node> ensureChildNodes() {\n+        throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.ChangeNotifyingArrayList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public abstract class Node implements Cloneable {\n-    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n+    static final String EmptyString = \"\";\n     Node parentNode;\n-    List<Node> childNodes;\n-    Attributes attributes;\n-    String baseUri;\n     int siblingIndex;\n \n     /**\n-     Create a new Node.\n-     @param baseUri base URI\n-     @param attributes attributes (not null, but may be empty)\n-     */\n-    protected Node(String baseUri, Attributes attributes) {\n-        Validate.notNull(baseUri);\n-        Validate.notNull(attributes);\n-        \n-        childNodes = EMPTY_NODES;\n-        this.baseUri = baseUri.trim();\n-        this.attributes = attributes;\n-    }\n-\n-    protected Node(String baseUri) {\n-        this(baseUri, new Attributes());\n-    }\n-\n-    /**\n      * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n      */\n     protected Node() {\n-        childNodes = EMPTY_NODES;\n-        attributes = null;\n     }\n \n     /**\n      @return node name\n      */\n     public abstract String nodeName();\n+\n+    /**\n+     * Check if this Node has an actual Attributes object.\n+     */\n+    protected abstract boolean hasAttributes();\n+\n+    public boolean hasParent() {\n+        return parentNode != null;\n+    }\n \n     /**\n      * Get an attribute's value by its key. <b>Case insensitive</b>\n      * </p>\n      * E.g.:\n      * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n-     * \n+     *\n      * @param attributeKey The attribute key.\n      * @return The attribute, or empty string if not present (to avoid nulls).\n      * @see #attributes()\n      */\n     public String attr(String attributeKey) {\n         Validate.notNull(attributeKey);\n-\n-        String val = attributes.getIgnoreCase(attributeKey);\n+        if (!hasAttributes())\n+            return EmptyString;\n+\n+        String val = attributes().getIgnoreCase(attributeKey);\n         if (val.length() > 0)\n             return val;\n         else if (lowerCase(attributeKey).startsWith(\"abs:\"))\n      * Get all of the element's attributes.\n      * @return attributes (which implements iterable, in same order as presented in original HTML).\n      */\n-    public Attributes attributes() {\n-        return attributes;\n-    }\n+    public abstract Attributes attributes();\n \n     /**\n      * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is\n      * @return this (for chaining)\n      */\n     public Node attr(String attributeKey, String attributeValue) {\n-        attributes.putIgnoreCase(attributeKey, attributeValue);\n+        attributes().putIgnoreCase(attributeKey, attributeValue);\n         return this;\n     }\n \n \n         if (attributeKey.startsWith(\"abs:\")) {\n             String key = attributeKey.substring(\"abs:\".length());\n-            if (attributes.hasKeyIgnoreCase(key) && !absUrl(key).equals(\"\"))\n+            if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).equals(\"\"))\n                 return true;\n         }\n-        return attributes.hasKeyIgnoreCase(attributeKey);\n+        return attributes().hasKeyIgnoreCase(attributeKey);\n     }\n \n     /**\n      */\n     public Node removeAttr(String attributeKey) {\n         Validate.notNull(attributeKey);\n-        attributes.removeIgnoreCase(attributeKey);\n+        attributes().removeIgnoreCase(attributeKey);\n         return this;\n     }\n \n      * @return this, for chaining\n      */\n     public Node clearAttributes() {\n-        Iterator<Attribute> it = attributes.iterator();\n+        Iterator<Attribute> it = attributes().iterator();\n         while (it.hasNext()) {\n             it.next();\n             it.remove();\n      Get the base URI of this node.\n      @return base URI\n      */\n-    public String baseUri() {\n-        return baseUri;\n-    }\n+    public abstract String baseUri();\n+\n+    /**\n+     * Set the baseUri for just this node (not its descendants), if this Node tracks base URIs.\n+     * @param baseUri\n+     */\n+    protected abstract void doSetBaseUri(String baseUri);\n \n     /**\n      Update the base URI of this node and all of its descendants.\n \n         traverse(new NodeVisitor() {\n             public void head(Node node, int depth) {\n-                node.baseUri = baseUri;\n+                node.doSetBaseUri(baseUri);\n             }\n \n             public void tail(Node node, int depth) {\n      * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n      * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n      * </p>\n-     * \n+     *\n      * @param attributeKey The attribute key\n      * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n      * could not be made successfully into a URL.\n         if (!hasAttr(attributeKey)) {\n             return \"\"; // nothing to make absolute with\n         } else {\n-            return StringUtil.resolve(baseUri, attr(attributeKey));\n-        }\n-    }\n+            return StringUtil.resolve(baseUri(), attr(attributeKey));\n+        }\n+    }\n+\n+    protected abstract List<Node> ensureChildNodes();\n \n     /**\n      Get a child node by its 0-based index.\n      @return the child node at this index. Throws a {@code IndexOutOfBoundsException} if the index is out of bounds.\n      */\n     public Node childNode(int index) {\n-        return childNodes.get(index);\n+        return ensureChildNodes().get(index);\n     }\n \n     /**\n      @return list of children. If no children, returns an empty list.\n      */\n     public List<Node> childNodes() {\n-        return Collections.unmodifiableList(childNodes);\n+        return Collections.unmodifiableList(ensureChildNodes());\n     }\n \n     /**\n      * @return a deep copy of this node's children\n      */\n     public List<Node> childNodesCopy() {\n-        List<Node> children = new ArrayList<>(childNodes.size());\n-        for (Node node : childNodes) {\n+        final List<Node> nodes = ensureChildNodes();\n+        final ArrayList<Node> children = new ArrayList<>(nodes.size());\n+        for (Node node : nodes) {\n             children.add(node.clone());\n         }\n         return children;\n      * Get the number of child nodes that this node holds.\n      * @return the number of child nodes that this node holds.\n      */\n-    public final int childNodeSize() {\n-        return childNodes.size();\n-    }\n-    \n+    public abstract int childNodeSize();\n+\n     protected Node[] childNodesAsArray() {\n-        return childNodes.toArray(new Node[childNodeSize()]);\n+        return ensureChildNodes().toArray(new Node[childNodeSize()]);\n     }\n \n     /**\n             node = node.parentNode;\n         return node;\n     }\n-    \n-    /**\n-     * Gets the Document associated with this Node. \n+\n+    /**\n+     * Gets the Document associated with this Node.\n      * @return the Document associated with this Node, or null if there is no such Document.\n      */\n     public Document ownerDocument() {\n         Node root = root();\n         return (root instanceof Document) ? (Document) root : null;\n     }\n-    \n+\n     /**\n      * Remove (delete) this node from the DOM tree. If this node has children, they are also removed.\n      */\n         Validate.notNull(html);\n         Validate.notNull(parentNode);\n \n-        Element context = parent() instanceof Element ? (Element) parent() : null;        \n+        Element context = parent() instanceof Element ? (Element) parent() : null;\n         List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n         parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n     }\n      * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n      * <p>{@code <div>One Two <b>Three</b></div>}</p>\n      * and the {@code \"Two \"} {@link TextNode} being returned.\n-     * \n+     *\n      * @return the first child of this node, after the node has been unwrapped. Null if the node had no children.\n      * @see #remove()\n      * @see #wrap(String)\n      */\n     public Node unwrap() {\n         Validate.notNull(parentNode);\n-\n+        final List<Node> childNodes = ensureChildNodes();\n         Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n         parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n         this.remove();\n     void nodelistChanged() {\n         // Element overrides this to clear its shadow children elements\n     }\n-    \n+\n     /**\n      * Replace this node in the DOM with the supplied node.\n      * @param in the node that will will replace the existing node.\n         Validate.notNull(in);\n         if (in.parentNode != null)\n             in.parentNode.removeChild(in);\n-        \n+\n         final int index = out.siblingIndex;\n-        childNodes.set(index, in);\n+        ensureChildNodes().set(index, in);\n         in.parentNode = this;\n         in.setSiblingIndex(index);\n         out.parentNode = null;\n     protected void removeChild(Node out) {\n         Validate.isTrue(out.parentNode == this);\n         final int index = out.siblingIndex;\n-        childNodes.remove(index);\n+        ensureChildNodes().remove(index);\n         reindexChildren(index);\n         out.parentNode = null;\n     }\n \n     protected void addChildren(Node... children) {\n         //most used. short circuit addChildren(int), which hits reindex children and array copy\n+        final List<Node> nodes = ensureChildNodes();\n+\n         for (Node child: children) {\n             reparentChild(child);\n-            ensureChildNodes();\n-            childNodes.add(child);\n-            child.setSiblingIndex(childNodes.size()-1);\n+            nodes.add(child);\n+            child.setSiblingIndex(nodes.size()-1);\n         }\n     }\n \n     protected void addChildren(int index, Node... children) {\n         Validate.noNullElements(children);\n-        ensureChildNodes();\n+        final List<Node> nodes = ensureChildNodes();\n+\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n-            childNodes.add(index, in);\n+            nodes.add(index, in);\n             reindexChildren(index);\n         }\n     }\n-\n-    protected void ensureChildNodes() {\n-        if (childNodes == EMPTY_NODES) {\n-            childNodes = new NodeList(4);\n-        }\n-    }\n-\n+    \n     protected void reparentChild(Node child) {\n         if (child.parentNode != null)\n             child.parentNode.removeChild(child);\n         child.setParentNode(this);\n     }\n-    \n+\n     private void reindexChildren(int start) {\n+        final List<Node> childNodes = ensureChildNodes();\n+\n         for (int i = start; i < childNodes.size(); i++) {\n             childNodes.get(i).setSiblingIndex(i);\n         }\n     }\n-    \n+\n     /**\n      Retrieves this node's sibling nodes. Similar to {@link #childNodes()  node.parent.childNodes()}, but does not\n      include this node (a node is not a sibling of itself).\n         if (parentNode == null)\n             return Collections.emptyList();\n \n-        List<Node> nodes = parentNode.childNodes;\n+        List<Node> nodes = parentNode.ensureChildNodes();\n         List<Node> siblings = new ArrayList<>(nodes.size() - 1);\n         for (Node node: nodes)\n             if (node != this)\n     public Node nextSibling() {\n         if (parentNode == null)\n             return null; // root\n-        \n-        final List<Node> siblings = parentNode.childNodes;\n+\n+        final List<Node> siblings = parentNode.ensureChildNodes();\n         final int index = siblingIndex+1;\n         if (siblings.size() > index)\n             return siblings.get(index);\n             return null; // root\n \n         if (siblingIndex > 0)\n-            return parentNode.childNodes.get(siblingIndex-1);\n+            return parentNode.ensureChildNodes().get(siblingIndex-1);\n         else\n             return null;\n     }\n     public int siblingIndex() {\n         return siblingIndex;\n     }\n-    \n+\n     protected void setSiblingIndex(int siblingIndex) {\n         this.siblingIndex = siblingIndex;\n     }\n         outerHtml(appendable);\n         return appendable;\n     }\n-    \n+\n \tpublic String toString() {\n         return outerHtml();\n     }\n         Node thisClone = doClone(null); // splits for orphan\n \n         // Queue up nodes that need their children cloned (BFS).\n-        LinkedList<Node> nodesToProcess = new LinkedList<>();\n+        final LinkedList<Node> nodesToProcess = new LinkedList<>();\n         nodesToProcess.add(thisClone);\n \n         while (!nodesToProcess.isEmpty()) {\n             Node currParent = nodesToProcess.remove();\n \n-            for (int i = 0; i < currParent.childNodes.size(); i++) {\n-                Node childClone = currParent.childNodes.get(i).doClone(currParent);\n-                currParent.childNodes.set(i, childClone);\n+            final int size = currParent.childNodeSize();\n+            for (int i = 0; i < size; i++) {\n+                final List<Node> childNodes = currParent.ensureChildNodes();\n+                Node childClone = childNodes.get(i).doClone(currParent);\n+                childNodes.set(i, childClone);\n                 nodesToProcess.add(childClone);\n             }\n         }\n \n         clone.parentNode = parent; // can be null, to create an orphan split\n         clone.siblingIndex = parent == null ? 0 : siblingIndex;\n-        clone.attributes = attributes != null ? attributes.clone() : null;\n-        clone.baseUri = baseUri;\n-        clone.childNodes = new NodeList(childNodes.size());\n-\n-        clone.childNodes.addAll(childNodes);\n \n         return clone;\n     }\n             }\n         }\n     }\n-\n-    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n-        NodeList(int initialCapacity) {\n-            super(initialCapacity);\n-        }\n-\n-        public void onContentsChanged() {\n-            nodelistChanged();\n-        }\n-    }\n }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n package org.jsoup.nodes;\n-\n-import java.io.IOException;\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+\n+import java.io.IOException;\n \n /**\n  A text node.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class TextNode extends Node {\n-    /*\n-    TextNode is a node, and so by default comes with attributes and children. The attributes are seldom used, but use\n-    memory, and the child nodes are never used. So we don't have them, and override accessors to attributes to create\n-    them as needed on the fly.\n-     */\n-    private static final String TEXT_KEY = \"text\";\n-    String text;\n+public class TextNode extends LeafNode {\n \n     /**\n      Create a new TextNode representing the supplied (unencoded) text).\n \n      @param text raw text\n-     @param baseUri base uri\n+     @see #createFromEncoded(String)\n+     */\n+    public TextNode(String text) {\n+        value = text;\n+    }\n+\n+    /**\n+     Create a new TextNode representing the supplied (unencoded) text).\n+\n+     @param text raw text\n+     @param baseUri base uri - ignored for this node type\n      @see #createFromEncoded(String, String)\n+     @deprecated use {@link TextNode(String)}\n      */\n     public TextNode(String text, String baseUri) {\n-        this.baseUri = baseUri;\n-        this.text = text;\n+        this(text);\n     }\n \n \tpublic String nodeName() {\n      * @return this, for chaining\n      */\n     public TextNode text(String text) {\n-        this.text = text;\n-        if (attributes != null)\n-            attributes.put(TEXT_KEY, text);\n+        coreValue(text);\n         return this;\n     }\n \n      @return text\n      */\n     public String getWholeText() {\n-        return attributes == null ? text : attributes.get(TEXT_KEY);\n+        return coreValue();\n     }\n \n     /**\n      @return true if this document is empty or only whitespace, false if it contains any text content.\n      */\n     public boolean isBlank() {\n-        return StringUtil.isBlank(getWholeText());\n+        return StringUtil.isBlank(coreValue());\n     }\n \n     /**\n      * @return the newly created text node containing the text after the offset.\n      */\n     public TextNode splitText(int offset) {\n+        final String text = coreValue();\n         Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n         Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\n \n-        String head = getWholeText().substring(0, offset);\n-        String tail = getWholeText().substring(offset);\n+        String head = text.substring(0, offset);\n+        String tail = text.substring(offset);\n         text(head);\n         TextNode tailNode = new TextNode(tail, this.baseUri());\n         if (parent() != null)\n \n         boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n                 && !Element.preserveWhitespace(parent());\n-        Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);\n+        Entities.escape(accum, coreValue(), out, false, normaliseWhite, false);\n     }\n \n \tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n      * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n      * @param baseUri Base uri\n      * @return TextNode containing unencoded data (e.g. &lt;)\n+     * @deprecated use {@link TextNode#createFromEncoded(String)} instead, as LeafNodes don't carry base URIs.\n      */\n     public static TextNode createFromEncoded(String encodedText, String baseUri) {\n         String text = Entities.unescape(encodedText);\n-        return new TextNode(text, baseUri);\n+        return new TextNode(text);\n+    }\n+\n+    /**\n+     * Create a new TextNode from HTML encoded (aka escaped) data.\n+     * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n+     * @return TextNode containing unencoded data (e.g. &lt;)\n+     */\n+    public static TextNode createFromEncoded(String encodedText) {\n+        String text = Entities.unescape(encodedText);\n+        return new TextNode(text);\n     }\n \n     static String normaliseWhitespace(String text) {\n         return sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';\n     }\n \n-    // attribute fiddling. create on first access.\n-    private void ensureAttributes() {\n-        if (attributes == null) {\n-            attributes = new Attributes();\n-            attributes.put(TEXT_KEY, text);\n-        }\n-    }\n \n-    @Override\n-    public String attr(String attributeKey) {\n-        ensureAttributes();\n-        return super.attr(attributeKey);\n-    }\n-\n-    @Override\n-    public Attributes attributes() {\n-        ensureAttributes();\n-        return super.attributes();\n-    }\n-\n-    @Override\n-    public Node attr(String attributeKey, String attributeValue) {\n-        ensureAttributes();\n-        return super.attr(attributeKey, attributeValue);\n-    }\n-\n-    @Override\n-    public boolean hasAttr(String attributeKey) {\n-        ensureAttributes();\n-        return super.hasAttr(attributeKey);\n-    }\n-\n-    @Override\n-    public Node removeAttr(String attributeKey) {\n-        ensureAttributes();\n-        return super.removeAttr(attributeKey);\n-    }\n-\n-    @Override\n-    public String absUrl(String attributeKey) {\n-        ensureAttributes();\n-        return super.absUrl(attributeKey);\n-    }\n }\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n \n /**\n- An XML Declaration.\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n-public class XmlDeclaration extends Node {\n-    private final String name;\n+ * An XML Declaration.\n+ */\n+public class XmlDeclaration extends LeafNode {\n+    // todo this impl isn't really right, the data shouldn't be attributes, just a run of text after the name\n     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n \n     /**\n-     Create a new XML declaration\n-     @param name of declaration\n-     @param baseUri base uri\n-     @param isProcessingInstruction is processing instruction\n+     * Create a new XML declaration\n+     * @param name of declaration\n+     * @param isProcessingInstruction is processing instruction\n+     */\n+    public XmlDeclaration(String name, boolean isProcessingInstruction) {\n+        Validate.notNull(name);\n+        value = name;\n+        this.isProcessingInstruction = isProcessingInstruction;\n+    }\n+\n+    /**\n+     * Create a new XML declaration\n+     * @param name of declaration\n+     * @param baseUri Leaf Nodes don't have base URIs; they inherit from their Element\n+     * @param isProcessingInstruction is processing instruction\n+     * @see XmlDeclaration#XmlDeclaration(String, boolean)\n+     * @deprecated\n      */\n     public XmlDeclaration(String name, String baseUri, boolean isProcessingInstruction) {\n-        super(baseUri);\n-        Validate.notNull(name);\n-        this.name = name;\n-        this.isProcessingInstruction = isProcessingInstruction;\n+        this(name, isProcessingInstruction);\n     }\n \n     public String nodeName() {\n         return \"#declaration\";\n     }\n \n-\n     /**\n      * Get the name of this declaration.\n      * @return name of this declaration.\n      */\n     public String name() {\n-        return name;\n+        return coreValue();\n     }\n \n     /**\n-     Get the unencoded XML declaration.\n-     @return XML declaration\n+     * Get the unencoded XML declaration.\n+     * @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        return attributes.html().trim(); // attr html starts with a \" \"\n+        StringBuilder sb = new StringBuilder();\n+        try {\n+            getWholeDeclaration(sb, new Document.OutputSettings());\n+        } catch (IOException e) {\n+            throw new SerializationException(e);\n+        }\n+        return sb.toString().trim();\n     }\n \n-\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+    private void getWholeDeclaration(Appendable accum, Document.OutputSettings out) throws IOException {\n+        for (Attribute attribute : attributes()) {\n+            if (!attribute.getKey().equals(nodeName())) { // skips coreValue (name)\n+                accum.append(' ');\n+                attribute.html(accum, out);\n+            }\n+        }\n+    }\n+\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum\n             .append(\"<\")\n             .append(isProcessingInstruction ? \"!\" : \"?\")\n-            .append(name);\n-        attributes.html(accum, out);\n+            .append(coreValue());\n+        getWholeDeclaration(accum, out);\n         accum\n             .append(isProcessingInstruction ? \"!\" : \"?\")\n             .append(\">\");\n     }\n \n-\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n+    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n+    }\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n     }\n \n     void insert(Token.Comment commentToken) {\n-        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        Comment comment = new Comment(commentToken.getData());\n         insertNode(comment);\n     }\n \n         // characters in script and style go in as datanodes, not text nodes\n         String tagName = currentElement().tagName();\n         if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n-            node = new DataNode(characterToken.getData(), baseUri);\n+            node = new DataNode(characterToken.getData());\n         else\n-            node = new TextNode(characterToken.getData(), baseUri);\n+            node = new TextNode(characterToken.getData());\n         currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n     }\n \n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 // todo: quirk state check on doctype ids\n                 Token.Doctype d = t.asDoctype();\n                 DocumentType doctype = new DocumentType(\n-                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n+                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n+                doctype.setPubSysKey(d.getPubSysKey());\n                 tb.getDocument().appendChild(doctype);\n                 if (d.isForceQuirks())\n                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n     }\n \n     void insert(Token.Comment commentToken) {\n-        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        Comment comment = new Comment(commentToken.getData());\n         Node insert = comment;\n         if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n             // so we do a bit of a hack and parse the data as an element to pull the attributes out\n             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                 Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                 Element el = doc.child(0);\n-                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\"));\n+                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                 insert.attributes().addAll(el.attributes());\n             }\n         }\n     }\n \n     void insert(Token.Character characterToken) {\n-        Node node = new TextNode(characterToken.getData(), baseUri);\n+        Node node = new TextNode(characterToken.getData());\n         insertNode(node);\n     }\n \n     void insert(Token.Doctype d) {\n-        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n+        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n+        doctypeNode.setPubSysKey(d.getPubSysKey());\n         insertNode(doctypeNode);\n     }\n \n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n                 }\n             } else if (source instanceof TextNode) {\n                 TextNode sourceText = (TextNode) source;\n-                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n+                TextNode destText = new TextNode(sourceText.getWholeText());\n                 destination.appendChild(destText);\n             } else if (source instanceof DataNode && whitelist.isSafeTag(source.parent().nodeName())) {\n               DataNode sourceData = (DataNode) source;\n-              DataNode destData = new DataNode(sourceData.getWholeData(), source.baseUri());\n+              DataNode destData = new DataNode(sourceData.getWholeData());\n               destination.appendChild(destData);\n             } else { // else, we don't care about comments, xml proc instructions, etc\n                 numDiscarded++;\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n         doc.outputSettings().syntax(Syntax.xml);\n         \n         if( addDecl == true ) {\n-            XmlDeclaration decl = new XmlDeclaration(\"xml\", \"\", false);\n+            XmlDeclaration decl = new XmlDeclaration(\"xml\", false);\n             decl.attr(\"version\", version);\n             decl.attr(\"encoding\", charset);\n             doc.prependChild(decl);\n--- a/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n public class DocumentTypeTest {\n     @Test\n     public void constructorValidationOkWithBlankName() {\n-        DocumentType fail = new DocumentType(\"\",\"\", \"\", \"\");\n+        DocumentType fail = new DocumentType(\"\",\"\", \"\");\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void constructorValidationThrowsExceptionOnNulls() {\n-        DocumentType fail = new DocumentType(\"html\", null, null, \"\");\n+        DocumentType fail = new DocumentType(\"html\", null, null);\n     }\n \n     @Test\n     public void constructorValidationOkWithBlankPublicAndSystemIds() {\n-        DocumentType fail = new DocumentType(\"html\",\"\", \"\",\"\");\n+        DocumentType fail = new DocumentType(\"html\",\"\", \"\");\n     }\n \n     @Test public void outerHtmlGeneration() {\n-        DocumentType html5 = new DocumentType(\"html\", \"\", \"\", \"\");\n+        DocumentType html5 = new DocumentType(\"html\", \"\", \"\");\n         assertEquals(\"<!doctype html>\", html5.outerHtml());\n \n-        DocumentType publicDocType = new DocumentType(\"html\", \"-//IETF//DTD HTML//\", \"\", \"\");\n+        DocumentType publicDocType = new DocumentType(\"html\", \"-//IETF//DTD HTML//\", \"\");\n         assertEquals(\"<!DOCTYPE html PUBLIC \\\"-//IETF//DTD HTML//\\\">\", publicDocType.outerHtml());\n \n-        DocumentType systemDocType = new DocumentType(\"html\", \"\", \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\", \"\");\n+        DocumentType systemDocType = new DocumentType(\"html\", \"\", \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\");\n         assertEquals(\"<!DOCTYPE html \\\"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\\\">\", systemDocType.outerHtml());\n \n-        DocumentType combo = new DocumentType(\"notHtml\", \"--public\", \"--system\", \"\");\n+        DocumentType combo = new DocumentType(\"notHtml\", \"--public\", \"--system\");\n         assertEquals(\"<!DOCTYPE notHtml PUBLIC \\\"--public\\\" \\\"--system\\\">\", combo.outerHtml());\n     }\n \n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         List<Node> els = new ArrayList<Node>();\n         Element el1 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span1\");\n         Element el2 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span2\");\n-        TextNode tn1 = new TextNode(\"Text4\", \"\");\n+        TextNode tn1 = new TextNode(\"Text4\");\n         els.add(el1);\n         els.add(el2);\n         els.add(tn1);\n--- a/src/test/java/org/jsoup/nodes/TextNodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/TextNodeTest.java\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TextNodeTest {\n     @Test public void testBlank() {\n-        TextNode one = new TextNode(\"\", \"\");\n-        TextNode two = new TextNode(\"     \", \"\");\n-        TextNode three = new TextNode(\"  \\n\\n   \", \"\");\n-        TextNode four = new TextNode(\"Hello\", \"\");\n-        TextNode five = new TextNode(\"  \\nHello \", \"\");\n+        TextNode one = new TextNode(\"\");\n+        TextNode two = new TextNode(\"     \");\n+        TextNode three = new TextNode(\"  \\n\\n   \");\n+        TextNode four = new TextNode(\"Hello\");\n+        TextNode five = new TextNode(\"  \\nHello \");\n \n         assertTrue(one.isBlank());\n         assertTrue(two.isBlank());\n         tn.text(\" POW!\");\n         assertEquals(\"One <span>two &amp;</span> POW!\", TextUtil.stripNewlines(p.html()));\n \n-        tn.attr(\"text\", \"kablam &\");\n+        tn.attr(tn.nodeName(), \"kablam &\");\n         assertEquals(\"kablam &\", tn.text());\n         assertEquals(\"One <span>two &amp;</span>kablam &amp;\", TextUtil.stripNewlines(p.html()));\n     }", "timestamp": 1498978766, "metainfo": ""}