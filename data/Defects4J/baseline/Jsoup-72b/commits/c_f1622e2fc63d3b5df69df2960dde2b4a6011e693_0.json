{"sha": "f1622e2fc63d3b5df69df2960dde2b4a6011e693", "log": "Merge branch 'master' of https://github.com/pafgoncalves/jsoup into pafgoncalves-master  Updating patch", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.Proxy;\n import java.net.URL;\n import java.util.Collection;\n import java.util.Map;\n      */\n     Connection url(String url);\n \n+    /**\n+     * Set the request proxy to use.\n+     * @param proxy proxy to use\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(Proxy proxy);\n+    \n     /**\n      * Set the request user-agent header.\n      * @param userAgent user-agent to use\n \n \n         /**\n+         * Get the Proxy for this request\n+         * @return the Proxy.\n+         */\n+        Proxy proxy();\n+\n+        /**\n+         * Update the Proxy for this request.\n+         * @param the Proxy\n+         * @return this Request, for chaining\n+         */\n+        Request proxy(Proxy proxy);\n+\n+        /**\n          * Get the request timeout, in milliseconds.\n          * @return the timeout in milliseconds.\n          */\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.Proxy;\n import java.net.URL;\n \n /**\n     }\n \n     /**\n+     * Creates a new {@link Connection} to a URL using a Proxy. Use to fetch and parse a HTML page.\n+     * \n+     * @param url URL to connect to. The protocol must be {@code http} or {@code https}.\n+     * @param proxy Proxy to use.\n+     * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n+     */\n+    public static Connection connect(String url, Proxy proxy) {\n+        return HttpConnection.connect(url).proxy(proxy);\n+    }\n+    \n+    /**\n      Parse the contents of a file as HTML.\n \n      @param in          file to load HTML from\n     public static Document parse(URL url, int timeoutMillis) throws IOException {\n         Connection con = HttpConnection.connect(url);\n         con.timeout(timeoutMillis);\n+        return con.get();\n+    }\n+\n+    /**\n+     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n+     <p>\n+     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n+\n+     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n+     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n+     @param proxy Proxy to use.\n+     @return The parsed HTML.\n+\n+     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n+     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n+     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n+     @throws java.net.SocketTimeoutException if the connection times out\n+     @throws IOException if a connection or read error occurs\n+\n+     @see #connect(String)\n+     */\n+    public static Document parse(URL url, int timeoutMillis, Proxy proxy) throws IOException {\n+        Connection con = HttpConnection.connect(url);\n+        con.timeout(timeoutMillis);\n+        con.proxy(proxy);\n         return con.get();\n     }\n \n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.io.*;\n import java.net.HttpURLConnection;\n import java.net.MalformedURLException;\n+import java.net.Proxy;\n import java.net.URL;\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n         return this;\n     }\n \n+    public Connection proxy(Proxy proxy) {\n+        req.proxy(proxy);\n+        return this;\n+    }\n+\n     public Connection userAgent(String userAgent) {\n         Validate.notNull(userAgent, \"User agent must not be null\");\n         req.header(\"User-Agent\", userAgent);\n     }\n \n     public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n+        private Proxy proxy;\n         private int timeoutMilliseconds;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n             parser = Parser.htmlParser();\n         }\n \n+        public Proxy proxy() {\n+            return proxy;\n+        }\n+\n+        public Request proxy(Proxy proxy) {\n+            this.proxy = proxy;\n+            return this;\n+        }\n+        \n         public int timeout() {\n             return timeoutMilliseconds;\n         }\n \n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n-            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection(\n+                    req.proxy()==null?Proxy.NO_PROXY:req.proxy()\n+            \t);\n \n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n package org.jsoup;\n \n import org.jsoup.nodes.Document;\n+import org.jsoup.parser.HtmlTreeBuilder;\n import org.jsoup.parser.Parser;\n \n import java.io.IOException;\n      * GET and POST http methods.\n      */\n     enum Method {\n-        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true);\n+        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true), HEAD(false), OPTIONS(false), TRACE(false);\n \n         private final boolean hasBody;\n \n     Connection cookies(Map<String, String> cookies);\n \n     /**\n-     * Provide an alternate parser to use when parsing the response to a Document.\n+     * Provide an alternate parser to use when parsing the response to a Document. If not set, defaults to the HTML\n+     * parser, unless the response content-type is XML, in which case the XML parser is used.\n      * @param parser alternate parser\n      * @return this Connection, for chaining\n      */\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n+        private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n         private boolean validateTSLCertificates = true;\n         private String postDataCharset = DataUtil.defaultCharset;\n \n \n         public Request parser(Parser parser) {\n             this.parser = parser;\n+            parserDefined = true;\n             return this;\n         }\n \n         private Connection.Request req;\n \n         /*\n-         * For example {@code application/atom+xml;charset=utf-8}.\n-         * Stepping through it: start with {@code \"application/\"}, follow with word\n-         * characters up to a {@code \"+xml\"}, and then maybe more ({@code .*}).\n+         * Matches XML content types (like text/xml, application/xhtml+xml;charset=UTF8, etc)\n          */\n-        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"application/\\\\w+\\\\+xml.*\");\n+        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(application|text)/\\\\w*\\\\+?xml.*\");\n \n         Response() {\n             super();\n                     String location = res.header(LOCATION);\n                     if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                         location = location.substring(6);\n-                    req.url(new URL(req.url(), encodeUrl(location)));\n+                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n \n                     for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                         req.cookie(cookie.getKey(), cookie.getValue());\n                 if (contentType != null\n                         && !req.ignoreContentType()\n                         && !contentType.startsWith(\"text/\")\n-                        && !contentType.startsWith(\"application/xml\")\n                         && !xmlContentTypeRxp.matcher(contentType).matches()\n                         )\n                     throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                             contentType, req.url().toString());\n \n+                // switch to the XML parser if content type is xml and not parser not explicitly set\n+                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n+                    // only flip it if a HttpConnection.Request (i.e. don't presume other impls want it):\n+                    if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) {\n+                        req.parser(Parser.xmlParser());\n+                    }\n+                }\n+\n                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                 if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                     InputStream bodyStream = null;\n-                    InputStream dataStream = null;\n                     try {\n-                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n-                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n-                                new BufferedInputStream(dataStream);\n+                        bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                        if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n+                            bodyStream = new GZIPInputStream(bodyStream);\n \n                         res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                     } finally {\n                         if (bodyStream != null) bodyStream.close();\n-                        if (dataStream != null) dataStream.close();\n                     }\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n             statusMessage = conn.getResponseMessage();\n             contentType = conn.getContentType();\n \n-            Map<String, List<String>> resHeaders = conn.getHeaderFields();\n+            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n             processResponseHeaders(resHeaders);\n \n             // if from a redirect, map previous response cookies into this response\n                         cookie(prevCookie.getKey(), prevCookie.getValue());\n                 }\n             }\n+        }\n+\n+        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n+            // the default sun impl of conn.getHeaderFields() returns header values out of order\n+            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n+            int i = 0;\n+            while (true) {\n+                final String key = conn.getHeaderFieldKey(i);\n+                final String val = conn.getHeaderField(i);\n+                if (key == null && val == null)\n+                    break;\n+                i++;\n+                if (key == null || val == null)\n+                    continue; // skip http1.1 line\n+\n+                if (headers.containsKey(key))\n+                    headers.get(key).add(val);\n+                else {\n+                    final ArrayList<String> vals = new ArrayList<String>();\n+                    vals.add(val);\n+                    headers.put(key, vals);\n+                }\n+            }\n+            return headers;\n         }\n \n         void processResponseHeaders(Map<String, List<String>> resHeaders) {\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n-                } else { // only take the first instance of each header\n-                    if (!values.isEmpty())\n+                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n+                    if (values.size() == 1)\n                         header(name, values.get(0));\n+                    else if (values.size() > 1) {\n+                        StringBuilder accum = new StringBuilder();\n+                        for (int i = 0; i < values.size(); i++) {\n+                            final String val = values.get(i);\n+                            if (i != 0)\n+                                accum.append(\", \");\n+                            accum.append(val);\n+                        }\n+                        header(name, accum.toString());\n+                    }\n                 }\n             }\n         }\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n package org.jsoup.helper;\n \n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n \n         }\n         return false;\n     }\n+\n+    public static boolean inSorted(String needle, String[] haystack) {\n+        return Arrays.binarySearch(haystack, needle) >= 0;\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param base the existing absolulte base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return the resolved absolute URL\n+     * @throws MalformedURLException if an error occurred generating the URL\n+     */\n+    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n+        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n+        if (relUrl.startsWith(\"?\"))\n+            relUrl = base.getPath() + relUrl;\n+        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n+        if (relUrl.indexOf('.') == 0 && base.getFile().indexOf('/') != 0) {\n+            base = new URL(base.getProtocol(), base.getHost(), base.getPort(), \"/\" + base.getFile());\n+        }\n+        return new URL(base, relUrl);\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param baseUrl the existing absolute base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return an absolute URL if one was able to be generated, or the empty string if not\n+     */\n+    public static String resolve(final String baseUrl, final String relUrl) {\n+        URL base;\n+        try {\n+            try {\n+                base = new URL(baseUrl);\n+            } catch (MalformedURLException e) {\n+                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n+                URL abs = new URL(relUrl);\n+                return abs.toExternalForm();\n+            }\n+            return resolve(base, relUrl).toExternalForm();\n+        } catch (MalformedURLException e) {\n+            return \"\";\n+        }\n+\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n         return (\"\".equals(value) || value.equalsIgnoreCase(key))\n                 && out.syntax() == Document.OutputSettings.Syntax.html\n-                && Arrays.binarySearch(booleanAttributes, key) >= 0;\n+                && isBooleanAttribute();\n+    }\n+\n+    protected boolean isBooleanAttribute() {\n+        return Arrays.binarySearch(booleanAttributes, key) >= 0;\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n     }\n+    \n+    /**\n+    Set a new boolean attribute, remove attribute if value is false.\n+    @param key attribute key\n+    @param value attribute value\n+    */\n+    public void put(String key, boolean value) {\n+        if (value)\n+            put(new BooleanAttribute(key));\n+        else\n+            remove(key);\n+    }\n \n     /**\n      Set a new attribute, or replace an existing one by key.\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/BooleanAttribute.java\n+package org.jsoup.nodes;\n+\n+/**\n+ * A boolean attribute that is written out without any value.\n+ */\n+public class BooleanAttribute extends Attribute {\n+    /**\n+     * Create a new boolean attribute from unencoded (raw) key.\n+     * @param key attribute key\n+     */\n+    public BooleanAttribute(String key) {\n+        super(key, \"\");\n+    }\n+\n+    @Override\n+    protected boolean isBooleanAttribute() {\n+        return true;\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n      */\n     public Element attr(String attributeKey, String attributeValue) {\n         super.attr(attributeKey, attributeValue);\n+        return this;\n+    }\n+    \n+    /**\n+     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n+     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n+     * with the same key if it exists.\n+     * \n+     * @param attributeKey the attribute key\n+     * @param attributeValue the attribute value\n+     * \n+     * @return this element\n+     */\n+    public Element attr(String attributeKey, boolean attributeValue) {\n+        attributes.put(attributeKey, attributeValue);\n         return this;\n     }\n \n \n         // was - Node#addChildren(child). short-circuits an array create and a loop.\n         reparentChild(child);\n+        ensureChildNodes();\n         childNodes.add(child);\n         child.setSiblingIndex(childNodes.size() - 1);\n         return this;\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+                            accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n-                        if (!inAttribute)\n+                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n+                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public abstract class Node implements Cloneable {\n+    private static final List<Node> EMPTY_NODES = Collections.emptyList();\n     Node parentNode;\n     List<Node> childNodes;\n     Attributes attributes;\n         Validate.notNull(baseUri);\n         Validate.notNull(attributes);\n         \n-        childNodes = new ArrayList<Node>(4);\n+        childNodes = EMPTY_NODES;\n         this.baseUri = baseUri.trim();\n         this.attributes = attributes;\n     }\n      * Default constructor. Doesn't setup base uri, children, or attributes; use with caution.\n      */\n     protected Node() {\n-        childNodes = Collections.emptyList();\n+        childNodes = EMPTY_NODES;\n         attributes = null;\n     }\n \n     public String absUrl(String attributeKey) {\n         Validate.notEmpty(attributeKey);\n \n-        String relUrl = attr(attributeKey);\n         if (!hasAttr(attributeKey)) {\n             return \"\"; // nothing to make absolute with\n         } else {\n-            URL base;\n-            try {\n-                try {\n-                    base = new URL(baseUri);\n-                } catch (MalformedURLException e) {\n-                    // the base is unsuitable, but the attribute may be abs on its own, so try that\n-                    URL abs = new URL(relUrl);\n-                    return abs.toExternalForm();\n-                }\n-                // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n-                if (relUrl.startsWith(\"?\"))\n-                    relUrl = base.getPath() + relUrl;\n-                URL abs = new URL(base, relUrl);\n-                return abs.toExternalForm();\n-            } catch (MalformedURLException e) {\n-                return \"\";\n-            }\n+            return StringUtil.resolve(baseUri, attr(attributeKey));\n         }\n     }\n \n         //most used. short circuit addChildren(int), which hits reindex children and array copy\n         for (Node child: children) {\n             reparentChild(child);\n+            ensureChildNodes();\n             childNodes.add(child);\n             child.setSiblingIndex(childNodes.size()-1);\n         }\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n+            ensureChildNodes();\n             childNodes.add(index, in);\n         }\n         reindexChildren(index);\n+    }\n+\n+    protected void ensureChildNodes() {\n+        if (childNodes == EMPTY_NODES) {\n+            childNodes = new ArrayList<Node>(4);\n+        }\n     }\n \n     protected void reparentChild(Node child) {\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n     String consumeToAny(final char... chars) {\n         final int start = pos;\n         final int remaining = length;\n+        final char[] val = input;\n \n         OUTER: while (pos < remaining) {\n             for (char c : chars) {\n-                if (input[pos] == c)\n+                if (val[pos] == c)\n                     break OUTER;\n             }\n             pos++;\n             cached = new String(val, start, count);\n             cache[index] = cached;\n         } else { // hashcode hit, check equality\n-            if (rangeEquals(start, count, cached)) {\n-                // hit\n+            if (rangeEquals(start, count, cached)) { // hit\n                 return cached;\n             } else { // hashcode conflict\n                 cached = new String(val, start, count);\n+                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n             }\n         }\n         return cached;\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n /**\n  * HTML Tree Builder; creates a DOM from Tokens.\n  */\n-class HtmlTreeBuilder extends TreeBuilder {\n+public class HtmlTreeBuilder extends TreeBuilder {\n     // tag searches\n     private static final String[] TagsScriptStyle = new String[]{\"script\", \"style\"};\n     public static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n                     String name = startTag.name();\n-                    if (name.equals(\"html\")) {\n+                    if (name.equals(\"a\")) {\n+                        if (tb.getActiveFormattingElement(\"a\") != null) {\n+                            tb.error(this);\n+                            tb.processEndTag(\"a\");\n+\n+                            // still on stack?\n+                            Element remainingA = tb.getFromStack(\"a\");\n+                            if (remainingA != null) {\n+                                tb.removeFromActiveFormattingElements(remainingA);\n+                                tb.removeFromStack(remainingA);\n+                            }\n+                        }\n+                        tb.reconstructFormattingElements();\n+                        Element a = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(a);\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insertEmpty(startTag);\n+                        tb.framesetOk(false);\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.processEndTag(\"p\");\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"span\")) {\n+                        // same as final else, but short circuits lots of checks\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"li\")) {\n+                        tb.framesetOk(false);\n+                        ArrayList<Element> stack = tb.getStack();\n+                        for (int i = stack.size() - 1; i > 0; i--) {\n+                            Element el = stack.get(i);\n+                            if (el.nodeName().equals(\"li\")) {\n+                                tb.processEndTag(\"li\");\n+                                break;\n+                            }\n+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n+                                break;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.processEndTag(\"p\");\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"html\")) {\n                         tb.error(this);\n                         // merge attributes onto real html\n                         Element html = tb.getStack().get(0);\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                             tb.insert(startTag);\n                             tb.transition(InFrameset);\n                         }\n-                    } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n+                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                         if (tb.inButtonScope(\"p\")) {\n                             tb.processEndTag(\"p\");\n                         }\n+                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n+                            tb.error(this);\n+                            tb.pop();\n+                        }\n                         tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.Headings)) {\n-                        if (tb.inButtonScope(\"p\")) {\n-                            tb.processEndTag(\"p\");\n-                        }\n-                        if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n-                            tb.error(this);\n-                            tb.pop();\n-                        }\n-                        tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                         if (tb.inButtonScope(\"p\")) {\n                             tb.processEndTag(\"p\");\n                         }\n                             tb.processEndTag(\"p\");\n                         }\n                         tb.insertForm(startTag, true);\n-                    } else if (name.equals(\"li\")) {\n+                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                         tb.framesetOk(false);\n                         ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n-                            if (el.nodeName().equals(\"li\")) {\n-                                tb.processEndTag(\"li\");\n-                                break;\n-                            }\n-                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n-                                break;\n-                        }\n-                        if (tb.inButtonScope(\"p\")) {\n-                            tb.processEndTag(\"p\");\n-                        }\n-                        tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.DdDt)) {\n-                        tb.framesetOk(false);\n-                        ArrayList<Element> stack = tb.getStack();\n-                        for (int i = stack.size() - 1; i > 0; i--) {\n-                            Element el = stack.get(i);\n-                            if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n+                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                 tb.processEndTag(el.nodeName());\n                                 break;\n                             }\n-                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n+                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n                             tb.insert(startTag);\n                             tb.framesetOk(false);\n                         }\n-                    } else if (name.equals(\"a\")) {\n-                        if (tb.getActiveFormattingElement(\"a\") != null) {\n-                            tb.error(this);\n-                            tb.processEndTag(\"a\");\n-\n-                            // still on stack?\n-                            Element remainingA = tb.getFromStack(\"a\");\n-                            if (remainingA != null) {\n-                                tb.removeFromActiveFormattingElements(remainingA);\n-                                tb.removeFromStack(remainingA);\n-                            }\n-                        }\n-                        tb.reconstructFormattingElements();\n-                        Element a = tb.insert(startTag);\n-                        tb.pushActiveFormattingElements(a);\n-                    } else if (StringUtil.in(name, Constants.Formatters)) {\n+                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                         tb.reconstructFormattingElements();\n                         Element el = tb.insert(startTag);\n                         tb.pushActiveFormattingElements(el);\n                         }\n                         Element el = tb.insert(startTag);\n                         tb.pushActiveFormattingElements(el);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n                         tb.insertMarkerToFormattingElements();\n                         tb.insert(startTag);\n                         tb.framesetOk(false);\n                         tb.transition(InTable);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n-                        tb.reconstructFormattingElements();\n-                        tb.insertEmpty(startTag);\n-                        tb.framesetOk(false);\n                     } else if (name.equals(\"input\")) {\n                         tb.reconstructFormattingElements();\n                         Element el = tb.insertEmpty(startTag);\n                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                             tb.framesetOk(false);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                         tb.insertEmpty(startTag);\n                     } else if (name.equals(\"hr\")) {\n                         if (tb.inButtonScope(\"p\")) {\n                         // input\n                         Attributes inputAttribs = new Attributes();\n                         for (Attribute attr : startTag.attributes) {\n-                            if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n+                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                 inputAttribs.put(attr);\n                         }\n                         inputAttribs.put(\"name\", \"isindex\");\n                             tb.transition(InSelectInTable);\n                         else\n                             tb.transition(InSelect);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n                             tb.processEndTag(\"option\");\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n-                    } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                         if (tb.inScope(\"ruby\")) {\n                             tb.generateImpliedEndTags();\n                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                         tb.insert(startTag);\n                         tb.tokeniser.acknowledgeSelfClosingFlag();\n-                    } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                         tb.error(this);\n                         return false;\n                     } else {\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n                     name = endTag.name();\n-                    if (name.equals(\"body\")) {\n-                        if (!tb.inScope(\"body\")) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n-                            tb.transition(AfterBody);\n-                        }\n-                    } else if (name.equals(\"html\")) {\n-                        boolean notIgnored = tb.processEndTag(\"body\");\n-                        if (notIgnored)\n-                            return tb.process(endTag);\n-                    } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n-                        if (!tb.inScope(name)) {\n-                            // nothing to close\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (name.equals(\"form\")) {\n-                        Element currentForm = tb.getFormElement();\n-                        tb.setFormElement(null);\n-                        if (currentForm == null || !tb.inScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags();\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            // remove currentForm from stack. will shift anything under up.\n-                            tb.removeFromStack(currentForm);\n-                        }\n-                    } else if (name.equals(\"p\")) {\n-                        if (!tb.inButtonScope(name)) {\n-                            tb.error(this);\n-                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n-                            return tb.process(endTag);\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (name.equals(\"li\")) {\n-                        if (!tb.inListItemScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (StringUtil.in(name, Constants.DdDt)) {\n-                        if (!tb.inScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(name);\n-                        }\n-                    } else if (StringUtil.in(name, Constants.Headings)) {\n-                        if (!tb.inScope(Constants.Headings)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.generateImpliedEndTags(name);\n-                            if (!tb.currentElement().nodeName().equals(name))\n-                                tb.error(this);\n-                            tb.popStackToClose(Constants.Headings);\n-                        }\n-                    } else if (name.equals(\"sarcasm\")) {\n-                        // *sigh*\n-                        return anyOtherEndTag(t, tb);\n-                    } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n+                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                         // Adoption Agency Algorithm.\n                         for (int i = 0; i < 8; i++) {\n                             Element formatEl = tb.getActiveFormattingElement(name);\n                                 lastNode = node;\n                             }\n \n-                            if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n+                            if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                 if (lastNode.parent() != null)\n                                     lastNode.remove();\n                                 tb.insertInFosterParent(lastNode);\n                             tb.removeFromStack(formatEl);\n                             tb.insertOnStackAfter(furthestBlock, adopter);\n                         }\n-                    } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n+                        if (!tb.inScope(name)) {\n+                            // nothing to close\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"span\")) {\n+                        // same as final fall through, but saves short circuit\n+                        return anyOtherEndTag(t, tb);\n+                    } else if (name.equals(\"li\")) {\n+                        if (!tb.inListItemScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"body\")) {\n+                        if (!tb.inScope(\"body\")) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n+                            tb.transition(AfterBody);\n+                        }\n+                    } else if (name.equals(\"html\")) {\n+                        boolean notIgnored = tb.processEndTag(\"body\");\n+                        if (notIgnored)\n+                            return tb.process(endTag);\n+                    } else if (name.equals(\"form\")) {\n+                        Element currentForm = tb.getFormElement();\n+                        tb.setFormElement(null);\n+                        if (currentForm == null || !tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            // remove currentForm from stack. will shift anything under up.\n+                            tb.removeFromStack(currentForm);\n+                        }\n+                    } else if (name.equals(\"p\")) {\n+                        if (!tb.inButtonScope(name)) {\n+                            tb.error(this);\n+                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n+                            return tb.process(endTag);\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n+                        if (!tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n+                        if (!tb.inScope(Constants.Headings)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(Constants.Headings);\n+                        }\n+                    } else if (name.equals(\"sarcasm\")) {\n+                        // *sigh*\n+                        return anyOtherEndTag(t, tb);\n+                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                         if (!tb.inScope(\"name\")) {\n                             if (!tb.inScope(name)) {\n                                 tb.error(this);\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.BooleanAttribute;\n \n /**\n  * Parse tokens for the Tokeniser.\n         protected String tagName;\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n         private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n+        private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n+        private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\n         private boolean hasPendingAttributeValue = false;\n         boolean selfClosing = false;\n         Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n             tagName = null;\n             pendingAttributeName = null;\n             reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n+            hasEmptyAttributeValue = false;\n             hasPendingAttributeValue = false;\n             selfClosing = false;\n             attributes = null;\n \n             if (pendingAttributeName != null) {\n                 Attribute attribute;\n-                if (!hasPendingAttributeValue)\n+                if (hasPendingAttributeValue)\n+                    attribute = new Attribute(pendingAttributeName,\n+                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                else if (hasEmptyAttributeValue)\n                     attribute = new Attribute(pendingAttributeName, \"\");\n                 else\n-                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\n+                    attribute = new BooleanAttribute(pendingAttributeName);\n                 attributes.put(attribute);\n             }\n             pendingAttributeName = null;\n+            hasEmptyAttributeValue = false;\n+            hasPendingAttributeValue = false;\n             reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n         }\n \n         final void finaliseTag() {\n \n         final void appendAttributeValue(String append) {\n             ensureAttributeValue();\n-            pendingAttributeValue.append(append);\n+            if (pendingAttributeValue.length() == 0) {\n+                pendingAttributeValueS = append;\n+            } else {\n+                pendingAttributeValue.append(append);\n+            }\n         }\n \n         final void appendAttributeValue(char append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n+        \n+        final void setEmptyAttributeValue() {\n+            hasEmptyAttributeValue = true;\n+        }\n \n         private void ensureAttributeValue() {\n             hasPendingAttributeValue = true;\n+            // if on second hit, we'll need to move to the builder\n+            if (pendingAttributeValueS != null) {\n+                pendingAttributeValue.append(pendingAttributeValueS);\n+                pendingAttributeValueS = null;\n+            }\n         }\n     }\n \n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n                     break;\n                 case eof:\n                     t.eofError(this);\n+                    t.emitTagPending();\n                     t.transition(Data);\n                     break;\n                 case '>':\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n+            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n+            else\n+                t.tagPending.setEmptyAttributeValue();\n \n             char c = r.consume();\n             switch (c) {\n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n+            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n+            else\n+                t.tagPending.setEmptyAttributeValue();\n \n             char c = r.consume();\n             switch (c) {\n     },\n     AttributeValue_unquoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n+            String value = r.consumeToAnySorted(attributeValueUnquoted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n     private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n     private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n     private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+    private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'};\n \n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n         Arrays.sort(attributeSingleValueCharsSorted);\n         Arrays.sort(attributeDoubleValueCharsSorted);\n         Arrays.sort(attributeNameCharsSorted);\n+        Arrays.sort(attributeValueUnquoted);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n     protected abstract boolean process(Token token);\n \n     protected boolean processStartTag(String name) {\n+        if (currentToken == start) { // don't recycle an in-use token\n+            return process(new Token.StartTag().name(name));\n+        }\n         return process(start.reset().name(name));\n     }\n \n     public boolean processStartTag(String name, Attributes attrs) {\n+        if (currentToken == start) { // don't recycle an in-use token\n+            return process(new Token.StartTag().nameAttr(name, attrs));\n+        }\n         start.reset();\n         start.nameAttr(name, attrs);\n         return process(start);\n     }\n \n     protected boolean processEndTag(String name) {\n+        if (currentToken == end) { // don't recycle an in-use token\n+            return process(new Token.EndTag().name(name));\n+        }\n         return process(end.reset().name(name));\n     }\n \n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Element;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.LinkedHashSet;\n+import java.util.IdentityHashMap;\n \n /**\n  * CSS-like element selector, that finds elements matching a query.\n         Validate.notEmpty(query);\n         Validate.notNull(roots);\n         Evaluator evaluator = QueryParser.parse(query);\n-        LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n+        ArrayList<Element> elements = new ArrayList<Element>();\n+        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<Element, Boolean>();\n+        // dedupe elements by identity, not equality\n \n         for (Element root : roots) {\n-            elements.addAll(select(evaluator, root));\n+            final Elements found = select(evaluator, root);\n+            for (Element el : found) {\n+                if (!seenElements.containsKey(el)) {\n+                    elements.add(el);\n+                    seenElements.put(el, Boolean.TRUE);\n+                }\n+            }\n         }\n         return new Elements(elements);\n     }\n--- a/src/main/java/org/jsoup/select/StructuralEvaluator.java\n+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java\n                 return false;\n \n             Element parent = element.parent();\n-            while (parent != root) {\n+            while (true) {\n                 if (evaluator.matches(root, parent))\n                     return true;\n+                if (parent == root)\n+                    break;\n                 parent = parent.parent();\n             }\n             return false;\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n         res.header(\"accept-encoding\", \"deflate\");\n         assertEquals(\"deflate\", res.header(\"Accept-Encoding\"));\n         assertEquals(\"deflate\", res.header(\"accept-Encoding\"));\n+    }\n+\n+    @Test public void sameHeadersCombineWithComma() {\n+        Map<String, List<String>> headers = new HashMap<String, List<String>>();\n+        List<String> values = new ArrayList<String>();\n+        values.add(\"no-cache\");\n+        values.add(\"no-store\");\n+        headers.put(\"Cache-Control\", values);\n+        HttpConnection.Response res = new HttpConnection.Response();\n+        res.processResponseHeaders(headers);\n+        assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\"));\n     }\n \n     @Test public void ignoresEmptySetCookies() {\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n \n import java.util.Arrays;\n \n+import static org.jsoup.helper.StringUtil.*;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n     }\n \n     @Test public void normaliseWhiteSpace() {\n-        assertEquals(\" \", StringUtil.normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n-        assertEquals(\" hello there \", StringUtil.normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n-        assertEquals(\"hello\", StringUtil.normaliseWhitespace(\"hello\"));\n-        assertEquals(\"hello there\", StringUtil.normaliseWhitespace(\"hello\\nthere\"));\n+        assertEquals(\" \", normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n+        assertEquals(\" hello there \", normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n+        assertEquals(\"hello\", normaliseWhitespace(\"hello\"));\n+        assertEquals(\"hello there\", normaliseWhitespace(\"hello\\nthere\"));\n     }\n \n     @Test public void normaliseWhiteSpaceHandlesHighSurrogates() {\n         String test71540chars = \"\\ud869\\udeb2\\u304b\\u309a  1\";\n         String test71540charsExpectedSingleWhitespace = \"\\ud869\\udeb2\\u304b\\u309a 1\";\n \n-        assertEquals(test71540charsExpectedSingleWhitespace, StringUtil.normaliseWhitespace(test71540chars));\n+        assertEquals(test71540charsExpectedSingleWhitespace, normaliseWhitespace(test71540chars));\n         String extractedText = Jsoup.parse(test71540chars).text();\n         assertEquals(test71540charsExpectedSingleWhitespace, extractedText);\n     }\n+\n+    @Test public void resolvesRelativeUrls() {\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com?one\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three#four\", resolve(\"http://example.com\", \"./one/two?three#four\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"http://example.com/\", \"https://example.com/one\"));\n+        assertEquals(\"http://example.com/one/two.html\", resolve(\"http://example.com/two/\", \"../one/two.html\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"https://example.com/\", \"//example2.com/one\"));\n+        assertEquals(\"https://example.com:8080/one\", resolve(\"https://example.com:8080\", \"./one\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"http://example.com/\", \"https://example2.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"wrong\", \"https://example.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"https://example.com/one\", \"\"));\n+        assertEquals(\"\", resolve(\"wrong\", \"also wrong\"));\n+        assertEquals(\"ftp://example.com/one\", resolve(\"ftp://example.com/two/\", \"../one\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"./two.c\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"two.c\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.HttpStatusException;\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.W3CDom;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.FormElement;\n+import org.jsoup.parser.HtmlTreeBuilder;\n+import org.jsoup.parser.Parser;\n+import org.jsoup.parser.XmlTreeBuilder;\n import org.junit.Ignore;\n import org.junit.Test;\n \n \n     @Test\n     public void followsRelativeRedirect() throws IOException {\n-        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel.pl\"); // to ./ - /tools/\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel.pl\"); // to /tidy/\n         Document doc = con.post();\n         assertTrue(doc.title().contains(\"HTML Tidy Online\"));\n+    }\n+\n+    @Test\n+    public void followsRelativeDotRedirect() throws IOException {\n+        // redirects to \"./ok.html\", should resolve to http://direct.infohound.net/tools/ok.html\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel-dot.pl\"); // to ./ok.html\n+        Document doc = con.post();\n+        assertTrue(doc.title().contains(\"OK\"));\n+        assertEquals(doc.location(), \"http://direct.infohound.net/tools/ok.html\");\n+    }\n+\n+    @Test\n+    public void followsRelativeDotRedirect2() throws IOException {\n+        //redirects to \"esportspenedes.cat/./ep/index.php\", should resolve to \"esportspenedes.cat/ep/index.php\"\n+        Connection con = Jsoup.connect(\"http://esportspenedes.cat\")  // note lack of trailing / - server should redir to / first, then to ./ep/...; but doesn't'\n+                .timeout(10000);\n+        Document doc = con.post();\n+        assertEquals(doc.location(), \"http://esportspenedes.cat/ep/index.php\");\n     }\n \n     @Test\n         Connection.Response res = con.execute();\n         assertEquals(\"asdfg123\", res.cookie(\"token\")); // confirms that cookies set on 1st hit are presented in final result\n         Document doc = res.parse();\n-        assertEquals(\"uid=jhy; token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc)); // confirms that redirected hit saw cookie\n+        assertEquals(\"token=asdfg123; uid=jhy\", ihVal(\"HTTP_COOKIE\", doc)); // confirms that redirected hit saw cookie\n     }\n \n     @Test\n \n         // send those cookies into the echo URL by map:\n         Document doc = Jsoup.connect(echoURL).cookies(cookies).get();\n-        assertEquals(\"uid=jhy; token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc));\n+        assertEquals(\"token=asdfg123; uid=jhy\", ihVal(\"HTTP_COOKIE\", doc));\n     }\n \n     @Test\n         assertTrue(html.contains(\"jsoup\"));\n     }\n \n+    @Test\n+    public void fetchHandlesXml() throws IOException {\n+        // should auto-detect xml and use XML parser, unless explicitly requested the html parser\n+        String xmlUrl = \"http://direct.infohound.net/tools/parse-xml.xml\";\n+        Connection con = Jsoup.connect(xmlUrl);\n+        Document doc = con.get();\n+        Connection.Request req = con.request();\n+        assertTrue(req.parser().getTreeBuilder() instanceof XmlTreeBuilder);\n+        assertEquals(\"<xml> <link> one </link> <table> Two </table> </xml>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test\n+    public void fetchHandlesXmlAsHtmlWhenParserSet() throws IOException {\n+        // should auto-detect xml and use XML parser, unless explicitly requested the html parser\n+        String xmlUrl = \"http://direct.infohound.net/tools/parse-xml.xml\";\n+        Connection con = Jsoup.connect(xmlUrl).parser(Parser.htmlParser());\n+        Document doc = con.get();\n+        Connection.Request req = con.request();\n+        assertTrue(req.parser().getTreeBuilder() instanceof HtmlTreeBuilder);\n+        assertEquals(\"<html> <head></head> <body> <xml> <link>one <table> Two </table> </xml> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test\n+    public void combinesSameHeadersWithComma() throws IOException {\n+        // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n+        String url = \"http://direct.infohound.net/tools/q.pl\";\n+        Connection con = Jsoup.connect(url);\n+        con.get();\n+\n+        assertEquals(\"text/html\", con.response().header(\"Content-Type\"));\n+        assertEquals(\"no-cache, no-store\", con.response().header(\"Cache-Control\"));\n+    }\n+\n+    @Test\n+    public void sendHeadRequest() throws IOException {\n+        String url = \"http://direct.infohound.net/tools/parse-xml.xml\";\n+        Connection con = Jsoup.connect(url).method(Connection.Method.HEAD);\n+        final Connection.Response response = con.execute();\n+        assertEquals(\"text/xml\", response.header(\"Content-Type\"));\n+        assertEquals(\"\", response.body()); // head ought to have no body\n+        Document doc = response.parse();\n+        assertEquals(\"\", doc.text());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n package org.jsoup.nodes;\n \n+import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.nio.charset.Charset;\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n         \n         return doc;\n     }\n+\n+    @Test\n+    public void testShiftJisRoundtrip() throws Exception {\n+        String input =\n+                \"<html>\"\n+                        +   \"<head>\"\n+                        +     \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=Shift_JIS\\\" />\"\n+                        +   \"</head>\"\n+                        +   \"<body>\"\n+                        +     \"before&nbsp;after\"\n+                        +   \"</body>\"\n+                        + \"</html>\";\n+        InputStream is = new ByteArrayInputStream(input.getBytes(Charset.forName(\"ASCII\")));\n+\n+        Document doc = Jsoup.parse(is, null, \"http://example.com\");\n+        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);\n+\n+        String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());\n+\n+        assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\"));\n+        assertTrue(\"Should have contained a '&#xa0;' or a '&nbsp;'.\",\n+                output.contains(\"&#xa0;\") || output.contains(\"&nbsp;\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n             assertEquals(i, ps.get(i).siblingIndex);\n         }\n     }\n+    \n+    @Test public void testAddBooleanAttribute() {\n+        Element div = new Element(Tag.valueOf(\"div\"), \"\");\n+        \n+        div.attr(\"true\", true);\n+        \n+        div.attr(\"false\", \"value\");\n+        div.attr(\"false\", false);\n+        \n+        assertTrue(div.hasAttr(\"true\"));\n+        assertEquals(\"\", div.attr(\"true\"));\n+        \n+        List<Attribute> attributes = div.attributes().asList();\n+        assertEquals(\"There should be one attribute\", 1, attributes.size());\n+\t\tassertTrue(\"Attribute should be boolean\", attributes.get(0) instanceof BooleanAttribute);\n+        \n+        assertFalse(div.hasAttr(\"false\"));\n+ \n+        assertEquals(\"<div true></div>\", div.outerHtml());\n+    }    \n \n     @Test public void testAppendRowToTable() {\n         Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n         assertFalse(e0.hashCode() == (e6).hashCode());\n         assertFalse(e0.hashCode() == (e7).hashCode());\n     }\n+\n+    @Test public void testRelativeUrls() {\n+        String html = \"<body><a href='./one.html'>One</a> <a href='two.html'>two</a> <a href='../three.html'>Three</a> <a href='//example2.com/four/'>Four</a> <a href='https://example2.com/five/'>Five</a>\";\n+        Document doc = Jsoup.parse(html, \"http://example.com/bar/\");\n+        Elements els = doc.select(\"a\");\n+\n+        assertEquals(\"http://example.com/bar/one.html\", els.get(0).absUrl(\"href\"));\n+        assertEquals(\"http://example.com/bar/two.html\", els.get(1).absUrl(\"href\"));\n+        assertEquals(\"http://example.com/three.html\", els.get(2).absUrl(\"href\"));\n+        assertEquals(\"http://example2.com/four/\", els.get(3).absUrl(\"href\"));\n+        assertEquals(\"https://example2.com/five/\", els.get(4).absUrl(\"href\"));\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n         String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n         String escapedAsciiFull = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(extended));\n         String escapedAsciiXhtml = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(xhtml));\n-        String escapedUtfFull = Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(base));\n+        String escapedUtfFull = Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(extended));\n         String escapedUtfMin = Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(xhtml));\n \n         assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; &#x3c0; &#x65b0; there &frac34; &copy; &raquo;\", escapedAscii);\n         String string = \"http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2\";\n         assertEquals(string, Entities.unescape(string));\n     }\n+\n+    @Test public void escapesGtInXmlAttributesButNotInHtml() {\n+        // https://github.com/jhy/jsoup/issues/528 - < is OK in HTML attribute values, but not in XML\n+\n+\n+        String docHtml = \"<a title='<p>One</p>'>One</a>\";\n+        Document doc = Jsoup.parse(docHtml);\n+        Element element = doc.select(\"a\").first();\n+\n+        doc.outputSettings().escapeMode(base);\n+        assertEquals(\"<a title=\\\"<p>One</p>\\\">One</a>\", element.outerHtml());\n+\n+        doc.outputSettings().escapeMode(xhtml);\n+        assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/FormElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/FormElementTest.java\n         assertEquals(\"on\", data.get(0).value());\n         assertEquals(\"foo\", data.get(0).key());\n     }\n+\n+    @Test public void adoptedFormsRetainInputs() {\n+        // test for https://github.com/jhy/jsoup/issues/249\n+        String html = \"<html>\\n\" +\n+                \"<body>  \\n\" +\n+                \"  <table>\\n\" +\n+                \"      <form action=\\\"/hello.php\\\" method=\\\"post\\\">\\n\" +\n+                \"      <tr><td>User:</td><td> <input type=\\\"text\\\" name=\\\"user\\\" /></td></tr>\\n\" +\n+                \"      <tr><td>Password:</td><td> <input type=\\\"password\\\" name=\\\"pass\\\" /></td></tr>\\n\" +\n+                \"      <tr><td><input type=\\\"submit\\\" name=\\\"login\\\" value=\\\"login\\\" /></td></tr>\\n\" +\n+                \"   </form>\\n\" +\n+                \"  </table>\\n\" +\n+                \"</body>\\n\" +\n+                \"</html>\";\n+        Document doc = Jsoup.parse(html);\n+        FormElement form = (FormElement) doc.select(\"form\").first();\n+        List<Connection.KeyVal> data = form.formData();\n+        assertEquals(3, data.size());\n+        assertEquals(\"user\", data.get(0).key());\n+        assertEquals(\"pass\", data.get(1).key());\n+        assertEquals(\"login\", data.get(2).key());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n \n         Element a2 = doc.select(\"a\").get(1);\n         assertEquals(\"http://jsoup.org/path/bar.html?foo\", a2.absUrl(\"href\"));\n+    }\n+\n+    @Test public void absHandlesDotFromIndex() {\n+        Document doc = Jsoup.parse(\"<a href='./one/two.html'>One</a>\", \"http://example.com\");\n+        Element a1 = doc.select(\"a\").first();\n+        assertEquals(\"http://example.com/one/two.html\", a1.absUrl(\"href\"));\n     }\n     \n     @Test public void testRemove() {\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n package org.jsoup.parser;\n \n+import java.util.List;\n+\n import org.jsoup.Jsoup;\n+import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.BooleanAttribute;\n import org.jsoup.nodes.Element;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n         Elements els = Jsoup.parse(html).select(\"a\");\n         assertEquals(\"&wr_id=123&mid-size=true&ok=&wr\", els.first().attr(\"href\"));\n     }\n+    \n+    @Test public void parsesBooleanAttributes() {\n+        String html = \"<a normal=\\\"123\\\" boolean empty=\\\"\\\"></a>\";\n+        Element el = Jsoup.parse(html).select(\"a\").first();\n+        \n+        assertEquals(\"123\", el.attr(\"normal\"));\n+        assertEquals(\"\", el.attr(\"boolean\"));\n+        assertEquals(\"\", el.attr(\"empty\"));\n+        \n+        List<Attribute> attributes = el.attributes().asList();\n+        assertEquals(\"There should be 3 attribute present\", 3, attributes.size());\n+        \n+        // Assuming the list order always follows the parsed html\n+\t\tassertFalse(\"'normal' attribute should not be boolean\", attributes.get(0) instanceof BooleanAttribute);        \n+\t\tassertTrue(\"'boolean' attribute should be boolean\", attributes.get(1) instanceof BooleanAttribute);        \n+\t\tassertFalse(\"'empty' attribute should not be boolean\", attributes.get(2) instanceof BooleanAttribute);        \n+        \n+        assertEquals(html, el.outerHtml());\n+    }\n+    \n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.integration.ParseTest;\n import org.jsoup.nodes.*;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n+import java.io.File;\n+import java.io.IOException;\n import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n         String html = \"<p =a>One<a <p>Something</p>Else\";\n         // this gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n         Document doc = Jsoup.parse(html);\n-        assertEquals(\"<p =a=\\\"\\\">One<a <p=\\\"\\\">Something</a></p>\\n\" +\n-                \"<a <p=\\\"\\\">Else</a>\", doc.body().html());\n+        assertEquals(\"<p =a>One<a <p>Something</a></p>\\n\" +\n+                \"<a <p>Else</a>\", doc.body().html());\n \n         doc = Jsoup.parse(\"<p .....>\");\n-        assertEquals(\"<p .....=\\\"\\\"></p>\", doc.body().html());\n+        assertEquals(\"<p .....></p>\", doc.body().html());\n     }\n \n     @Test public void parsesComments() {\n         assertEquals(50000, doc.body().childNodeSize());\n         assertTrue(System.currentTimeMillis() - start < 1000);\n     }\n+\n+    @Test\n+    public void testInvalidTableContents() throws IOException {\n+        File in = ParseTest.getFile(\"/htmltests/table-invalid-elements.html\");\n+        Document doc = Jsoup.parse(in, \"UTF-8\");\n+        doc.outputSettings().prettyPrint(true);\n+        String rendered = doc.toString();\n+        int endOfEmail = rendered.indexOf(\"Comment\");\n+        int guarantee = rendered.indexOf(\"Why am I here?\");\n+        assertTrue(\"Comment not found\", endOfEmail > -1);\n+        assertTrue(\"Search text not found\", guarantee > -1);\n+        assertTrue(\"Search text did not come after comment\", guarantee > endOfEmail);\n+    }\n+\n+    @Test public void testNormalisesIsIndex() {\n+        Document doc = Jsoup.parse(\"<body><isindex action='/submit'></body>\");\n+        String html = doc.outerHtml();\n+        assertEquals(\"<form action=\\\"/submit\\\"> <hr> <label>This is a searchable index. Enter search keywords: <input name=\\\"isindex\\\"></label> <hr> </form>\",\n+                StringUtil.normaliseWhitespace(doc.body().html()));\n+    }\n+\n+    @Test public void testReinsertionModeForThCelss() {\n+        String body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";\n+        Document doc = Jsoup.parse(body);\n+        assertEquals(1, doc.body().children().size());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import java.util.List;\n \n import static org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.*;\n \n /**\n  * Tests XmlTreeBuilder.\n \n         // parse with both xml and html parser, ensure different\n         Document xmlDoc = Jsoup.connect(xmlUrl).parser(Parser.xmlParser()).get();\n-        Document htmlDoc = Jsoup.connect(xmlUrl).get();\n+        Document htmlDoc = Jsoup.connect(xmlUrl).parser(Parser.htmlParser()).get();\n+        Document autoXmlDoc = Jsoup.connect(xmlUrl).get(); // check connection auto detects xml, uses xml parser\n \n         assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n                 TextUtil.stripNewlines(xmlDoc.html()));\n-        assertNotSame(htmlDoc, xmlDoc);\n+        assertFalse(htmlDoc.equals(xmlDoc));\n+        assertEquals(xmlDoc, autoXmlDoc);\n         assertEquals(1, htmlDoc.select(\"head\").size()); // html parser normalises\n         assertEquals(0, xmlDoc.select(\"head\").size()); // xml parser does not\n+        assertEquals(0, autoXmlDoc.select(\"head\").size()); // xml parser does not\n     }\n \n     @Test\n         Document doc = Jsoup.parse(\"x\", \"\", Parser.xmlParser());\n         assertEquals(Syntax.xml, doc.outputSettings().syntax());\n     }\n+\n+    @Test\n+    public void testDoesHandleEOFInTag() {\n+        String html = \"<img src=asdf onerror=\\\"alert(1)\\\" x=\";\n+        Document xmlDoc = Jsoup.parse(html, \"\", Parser.xmlParser());\n+        assertEquals(\"<img src=\\\"asdf\\\" onerror=\\\"alert(1)\\\" x=\\\"\\\" />\", xmlDoc.html());\n+    }\n }\n--- a/src/test/java/org/jsoup/select/ElementsTest.java\n+++ b/src/test/java/org/jsoup/select/ElementsTest.java\n         assertEquals(\"<a>One</a> Two Three <i>Four</i> Fix <i>Six</i>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n+    @Test public void unwrapKeepsSpace() {\n+        String h = \"<p>One <span>two</span> <span>three</span> four</p>\";\n+        Document doc = Jsoup.parse(h);\n+        doc.select(\"span\").unwrap();\n+        assertEquals(\"<p>One two three four</p>\", doc.body().html());\n+    }\n+\n     @Test public void empty() {\n         Document doc = Jsoup.parse(\"<div><p>Hello <b>there</b></p> <p>now!</p></div>\");\n         doc.outputSettings().prettyPrint(false);\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n     @Test public void descendant() {\n         String h = \"<div class=head><p class=first>Hello</p><p>There</p></div><p>None</p>\";\n         Document doc = Jsoup.parse(h);\n-        Elements els = doc.select(\".head p\");\n+        Element root = doc.getElementsByClass(\"head\").first();\n+        \n+        Elements els = root.select(\".head p\");\n         assertEquals(2, els.size());\n         assertEquals(\"Hello\", els.get(0).text());\n         assertEquals(\"There\", els.get(1).text());\n \n-        Elements p = doc.select(\"p.first\");\n+        Elements p = root.select(\"p.first\");\n         assertEquals(1, p.size());\n         assertEquals(\"Hello\", p.get(0).text());\n \n-        Elements empty = doc.select(\"p .first\"); // self, not descend, should not match\n+        Elements empty = root.select(\"p .first\"); // self, not descend, should not match\n         assertEquals(0, empty.size());\n+        \n+        Elements aboveRoot = root.select(\"body div.head\");\n+        assertEquals(0, aboveRoot.size());\n     }\n \n     @Test public void and() {\n \n     @Test public void deeperDescendant() {\n         String h = \"<div class=head><p><span class=first>Hello</div><div class=head><p class=first><span>Another</span><p>Again</div>\";\n-        Elements els = Jsoup.parse(h).select(\"div p .first\");\n+        Document doc = Jsoup.parse(h);\n+        Element root = doc.getElementsByClass(\"head\").first();\n+\n+        Elements els = root.select(\"div p .first\");\n         assertEquals(1, els.size());\n         assertEquals(\"Hello\", els.first().text());\n         assertEquals(\"span\", els.first().tagName());\n+\n+        Elements aboveRoot = root.select(\"body p .first\");\n+        assertEquals(0, aboveRoot.size());\n     }\n \n     @Test public void parentChildElement() {\n         found = doc.select(\"div[class=\\\"value\\\\ \\\"]\");\n         assertEquals(0, found.size());\n     }\n-    \n+\n+    @Test public void selectSameElements() {\n+        final String html = \"<div>one</div><div>one</div>\";\n+\n+        Document doc = Jsoup.parse(html);\n+        Elements els = doc.select(\"div\");\n+        assertEquals(2, els.size());\n+\n+        Elements subSelect = els.select(\":contains(one)\");\n+        assertEquals(2, subSelect.size());\n+    }\n }", "timestamp": 1459721067, "metainfo": ""}