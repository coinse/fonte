{"sha": "48f31787f88cfe851aeaf796c6f2809dce380f37", "log": "Merge branch 'master' of https://github.com/sedran/jsoup into sedran-master", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n         child.setSiblingIndex(childNodes.size() - 1);\n         return this;\n     }\n+\n+    /**\n+\t * Add this node as a child node to the given parent\n+\t * \n+\t * @param parent node in which this node will be appended\n+\t * @return this element, so that you can continue modifying the element\n+\t */\n+\tpublic Element appendTo(Node parent) {\n+\t\tValidate.notNull(parent);\n+\t\tif (this.parentNode != null) {\n+\t\t\tthis.parentNode.removeChild(this);\n+\t\t}\n+\n+\t\tparent.ensureChildNodes();\n+\t\tparent.childNodes.add(this);\n+\t\tsetSiblingIndex(parent.childNodes.size() - 1);\n+\t\tsetParentNode(parent);\n+\t\treturn this;\n+\t}\n \n     /**\n      * Add a node to the start of this element's children.\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n-import java.util.*;\n-\n-import static org.junit.Assert.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n /**\n  * Tests for Element (DOM stuff mostly).\n         assertEquals(p1, p9);\n         assertEquals(p1, p10);\n     }\n+\n+\t@Test\n+\tpublic void testAppendTo() {\n+\t\tString parentHtml = \"<div class='a'></div>\";\n+\t\tString childHtml = \"<div class='b'></div>\";\n+\n+\t\tElement parentElement = Jsoup.parse(parentHtml).getElementsByClass(\"a\").first();\n+\t\tElement childElement = Jsoup.parse(childHtml).getElementsByClass(\"b\").first();\n+\n+\t\tchildElement.attr(\"class\", \"test-class\").appendTo(parentElement).attr(\"id\", \"testId\");\n+\t\tassertEquals(\"test-class\", childElement.attr(\"class\"));\n+\t\tassertEquals(\"testId\", childElement.attr(\"id\"));\n+\t\tassertThat(parentElement.attr(\"id\"), not(equalTo(\"testId\")));\n+\t\tassertThat(parentElement.attr(\"class\"), not(equalTo(\"test-class\")));\n+\t\tassertSame(childElement, parentElement.children().first());\n+\t\tassertSame(parentElement, childElement.parent());\n+\t}\n }\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n package org.jsoup;\n \n import org.jsoup.nodes.Document;\n-import org.jsoup.parser.HtmlTreeBuilder;\n import org.jsoup.parser.Parser;\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.Proxy;\n import java.net.URL;\n import java.util.Collection;\n import java.util.Map;\n     Connection url(String url);\n \n     /**\n+     * Set the proxy to use for this request. Set to <code>null</code> to disable.\n+     * @param proxy proxy to use\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(Proxy proxy);\n+\n+    /**\n+     * Set the HTTP proxy to use for this request.\n+     * @param host the proxy hostname\n+     * @param port the proxy port\n+     * @return this Connection, for chaining\n+     */\n+    Connection proxy(String host, int port);\n+\n+    /**\n      * Set the request user-agent header.\n      * @param userAgent user-agent to use\n      * @return this Connection, for chaining\n+     * @see org.jsoup.helper.HttpConnection#DEFAULT_UA\n      */\n     Connection userAgent(String userAgent);\n \n     /**\n      * Set the request timeouts (connect and read). If a timeout occurs, an IOException will be thrown. The default\n-     * timeout is 3 seconds (3000 millis). A timeout of zero is treated as an infinite timeout.\n+     * timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n+     * <p>Note that a read timeout is not the same as a maximum timeout. As long as the connection is sending bytes at\n+     * least every <i>timeout</i> seconds (e.g. in the case of an infinite stream of data, or a slow large download), the\n+     * read timeout will not fire. This can be mitigated by using a maximum download size (see {@link #maxBodySize(int)}),\n+     * or interrupting the connecting thread after a max timeout.</p>\n      * @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n      * @return this Connection, for chaining\n      */\n     Connection ignoreContentType(boolean ignoreContentType);\n \n     /**\n-     * Disable/enable TSL certificates validation for HTTPS requests.\n+     * Disable/enable TLS certificates validation for HTTPS requests.\n      * <p>\n      * By default this is <b>true</b>; all\n      * connections over HTTPS perform normal validation of certificates, and will abort requests if the provided\n      * <p>\n      * <b>Be careful</b> and understand why you need to disable these validations.\n      * </p>\n-     * @param value if should validate TSL (SSL) certificates. <b>true</b> by default.\n+     * @param value if should validate TLS (SSL) certificates. <b>true</b> by default.\n      * @return this Connection, for chaining\n      */\n     Connection validateTLSCertificates(boolean value);\n     Connection data(String key, String value);\n \n     /**\n-     * Add an input stream as a request data paramater. For GETs, has no effect, but for POSTS this will upload the\n+     * Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n      * input stream.\n      * @param key data key (form item name)\n      * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n     Connection data(String... keyvals);\n \n     /**\n+     * Get the data KeyVal for this key, if any\n+     * @param key the data key\n+     * @return null if not set\n+     */\n+    KeyVal data(String key);\n+\n+    /**\n+     * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n+     * encoded form key/value pairs. E.g.:\n+     * <code><pre>Jsoup.connect(url)\n+     * .requestBody(json)\n+     * .header(\"Content-Type\", \"application/json\")\n+     * .post();</pre></code>\n+     * If any data key/vals are supplied, they will be sent as URL query params.\n+     * @return this Request, for chaining\n+     */\n+    Connection requestBody(String body);\n+\n+    /**\n      * Set a request header.\n      * @param name header name\n      * @param value header value\n      * @see org.jsoup.Connection.Request#headers()\n      */\n     Connection header(String name, String value);\n+\n+    /**\n+     * Adds each of the supplied headers to the request.\n+     * @param headers map of headers name {@literal ->} value pairs\n+     * @return this Connection, for chaining\n+     * @see org.jsoup.Connection.Request#headers()\n+     */\n+    Connection headers(Map<String,String> headers);\n \n     /**\n      * Set a cookie to be sent in the request.\n      * Represents a HTTP request.\n      */\n     interface Request extends Base<Request> {\n-\n+        /**\n+         * Get the proxy used for this request.\n+         * @return the proxy; <code>null</code> if not enabled.\n+         */\n+        Proxy proxy();\n+\n+        /**\n+         * Update the proxy for this request.\n+         * @param proxy the proxy ot use; <code>null</code> to disable.\n+         * @return this Request, for chaining\n+         */\n+        Request proxy(Proxy proxy);\n+\n+        /**\n+         * Set the HTTP proxy to use for this request.\n+         * @param host the proxy hostname\n+         * @param port the proxy port\n+         * @return this Connection, for chaining\n+         */\n+        Request proxy(String host, int port);\n \n         /**\n          * Get the request timeout, in milliseconds.\n         Collection<KeyVal> data();\n \n         /**\n+         * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n+         * encoded form key/value pairs. E.g.:\n+         * <code><pre>Jsoup.connect(url)\n+         * .requestBody(json)\n+         * .header(\"Content-Type\", \"application/json\")\n+         * .post();</pre></code>\n+         * If any data key/vals are supplied, they will be sent as URL query params.\n+         * @return this Request, for chaining\n+         */\n+        Request requestBody(String body);\n+\n+        /**\n+         * Get the current request body.\n+         * @return null if not set.\n+         */\n+        String requestBody();\n+\n+        /**\n          * Specify the parser to use when parsing the document.\n          * @param parser parser to use.\n          * @return this Request, for chaining\n         String statusMessage();\n \n         /**\n-         * Get the character set name of the response.\n+         * Get the character set name of the response, derived from the content-type header.\n          * @return character set name\n          */\n         String charset();\n+\n+        /**\n+         * Set / override the response character set. When the document body is parsed it will be with this charset.\n+         * @param charset to decode body as\n+         * @return this Response, for chaining\n+         */\n+        Response charset(String charset);\n \n         /**\n          * Get the response content type (e.g. \"text/html\");\n         String contentType();\n \n         /**\n-         * Parse the body of the response as a Document.\n+         * Read and parse the body of the response as a Document. If you intend to parse the same response multiple\n+         * times, you should {@link #bufferUp()} first.\n          * @return a parsed Document\n          * @throws IOException on error\n          */\n          * @return body bytes\n          */\n         byte[] bodyAsBytes();\n+\n+        /**\n+         * Read the body of the response into a local buffer, so that {@link #parse()} may be called repeatedly on the\n+         * same connection response (otherwise, once the response is read, its InputStream will have been drained and\n+         * may not be re-read). Calling {@link #body() } or {@link #bodyAsBytes()} has the same effect. If the requ\n+         * @return this response, for chaining\n+         */\n+        Response bufferUp();\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n \n     /**\n      * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of\n-     * permitted\n-     * tags and attributes.\n+     * permitted tags and attributes.\n+     * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an\n+     * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add\n+     * structural tags (<code>html, head, body</code> etc) to the whitelist.\n      *\n      * @param bodyHtml input untrusted HTML (body fragment)\n      * @param baseUri URL to resolve relative URLs against\n     }\n \n     /**\n-     Test if the input HTML has only tags and attributes allowed by the Whitelist. Useful for form validation. The input HTML should\n-     still be run through the cleaner to set up enforced attributes, and to tidy the output.\n+     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n+     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n+     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n      @param bodyHtml HTML to test\n      @param whitelist whitelist to test against\n      @return true if no tags or attributes were removed; false otherwise\n      @see #clean(String, org.jsoup.safety.Whitelist) \n      */\n     public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n-        Document dirty = parseBodyFragment(bodyHtml, \"\");\n-        Cleaner cleaner = new Cleaner(whitelist);\n-        return cleaner.isValid(dirty);\n+        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n     }\n     \n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/SerializationException.java\n+package org.jsoup;\n+\n+/**\n+ * A SerializationException is raised whenever serialization of a DOM element fails. This exception usually wraps an\n+ * {@link java.io.IOException} that may be thrown due to an inaccessible output stream.\n+ */\n+public final class SerializationException extends RuntimeException {\n+\t/**\n+\t * Creates and initializes a new serialization exception with no error message and cause.\n+\t */\n+\tpublic SerializationException() {\n+\t\tsuper();\n+\t}\n+\n+\t/**\n+\t * Creates and initializes a new serialization exception with the given error message and no cause.\n+\t * \n+\t * @param message\n+\t *            the error message of the new serialization exception (may be <code>null</code>).\n+\t */\n+\tpublic SerializationException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\t/**\n+\t * Creates and initializes a new serialization exception with the specified cause and an error message of\n+     * <code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of\n+     * <code>cause</code>).\n+\t * \n+\t * @param cause\n+\t *            the cause of the new serialization exception (may be <code>null</code>).\n+\t */\n+\tpublic SerializationException(Throwable cause) {\n+\t\tsuper(cause);\n+\t}\n+\n+\t/**\n+\t * Creates and initializes a new serialization exception with the given error message and cause.\n+\t * \n+\t * @param message\n+\t *            the error message of the new serialization exception.\n+\t * @param cause\n+\t *            the cause of the new serialization exception.\n+\t */\n+\tpublic SerializationException(String message, Throwable cause) {\n+\t\tsuper(message, cause);\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/UncheckedIOException.java\n+package org.jsoup;\n+\n+import java.io.IOException;\n+\n+public class UncheckedIOException extends Error {\n+    public UncheckedIOException(IOException cause) {\n+        super(cause);\n+    }\n+\n+    public IOException ioException() {\n+        return (IOException) getCause();\n+    }\n+}\n--- a/src/main/java/org/jsoup/examples/package-info.java\n+++ b/src/main/java/org/jsoup/examples/package-info.java\n /**\n- Contains example programs and use of jsoup. See the <a href=\"http://jsoup.org/cookbook/\">jsoup cookbook</a>.\n+ Contains example programs and use of jsoup. See the <a href=\"https://jsoup.org/cookbook/\">jsoup cookbook</a>.\n  */\n package org.jsoup.examples;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/helper/ChangeNotifyingArrayList.java\n+package org.jsoup.helper;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+/**\n+ * Implementation of ArrayList that watches out for changes to the contents.\n+ */\n+public abstract class ChangeNotifyingArrayList<E> extends ArrayList<E> {\n+    public ChangeNotifyingArrayList(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    public abstract void onContentsChanged();\n+\n+    @Override\n+    public E set(int index, E element) {\n+        onContentsChanged();\n+        return super.set(index, element);\n+    }\n+\n+    @Override\n+    public boolean add(E e) {\n+        onContentsChanged();\n+        return super.add(e);\n+    }\n+\n+    @Override\n+    public void add(int index, E element) {\n+        onContentsChanged();\n+        super.add(index, element);\n+    }\n+\n+    @Override\n+    public E remove(int index) {\n+        onContentsChanged();\n+        return super.remove(index);\n+    }\n+\n+    @Override\n+    public boolean remove(Object o) {\n+        onContentsChanged();\n+        return super.remove(o);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        onContentsChanged();\n+        super.clear();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> c) {\n+        onContentsChanged();\n+        return super.addAll(c);\n+    }\n+\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> c) {\n+        onContentsChanged();\n+        return super.addAll(index, c);\n+    }\n+\n+    @Override\n+    protected void removeRange(int fromIndex, int toIndex) {\n+        onContentsChanged();\n+        super.removeRange(fromIndex, toIndex);\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        onContentsChanged();\n+        return super.removeAll(c);\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        onContentsChanged();\n+        return super.retainAll(c);\n+    }\n+\n+}\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n package org.jsoup.helper;\n \n+import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.XmlDeclaration;\n import org.jsoup.parser.Parser;\n-\n-import java.io.*;\n+import org.jsoup.select.Elements;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Locale;\n import java.util.Random;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n-import java.util.Locale;\n \n /**\n  * Internal static utilities for handling data.\n  *\n  */\n public final class DataUtil {\n-    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n+    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n-    private static final int bufferSize = 0x20000; // ~130K.\n-    private static final int UNICODE_BOM = 0xFEFF;\n+    private static final int firstReadBufferSize = 1024 * 5;\n+    static final int bufferSize = 1024 * 32;\n     private static final char[] mimeBoundaryChars =\n             \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n     static final int boundaryLength = 32;\n      * @throws IOException on IO error\n      */\n     public static Document load(File in, String charsetName, String baseUri) throws IOException {\n-        ByteBuffer byteData = readFileToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n     }\n \n     /**\n      * @throws IOException on IO error\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n-        ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n     }\n \n     /**\n      * @throws IOException on IO error\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n-        ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, parser);\n+        return parseInputStream(in, charsetName, baseUri, parser);\n     }\n \n     /**\n         }\n     }\n \n-    // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n-    // todo - this is getting gnarly. needs a rewrite.\n-    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n-        String docData;\n+    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n+        if (input == null) // empty body\n+            return new Document(baseUri);\n+\n+        if (!(input instanceof ConstrainableInputStream))\n+            input = new ConstrainableInputStream(input, bufferSize, 0);\n+\n         Document doc = null;\n-        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n+        boolean fullyRead = false;\n+\n+        // read the start of the stream and look for a BOM or meta charset\n+        input.mark(firstReadBufferSize);\n+        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed\n+        fullyRead = input.read() == -1;\n+        input.reset();\n+\n+        // look for BOM - overrides any other header or input\n+        BomCharset bomCharset = detectCharsetFromBom(firstBytes, charsetName);\n+        if (bomCharset != null) {\n+            charsetName = bomCharset.charset;\n+            input.skip(bomCharset.offset);\n+        }\n+\n+        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n+            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n+            doc = parser.parseInput(docData, baseUri);\n+\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n-            doc = parser.parseInput(docData, baseUri);\n-            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n-            if (meta != null) { // if not found, will keep utf-8 as best attempt\n-                String foundCharset = null;\n-                if (meta.hasAttr(\"http-equiv\")) {\n+            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n+            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n+            for (Element meta : metaElements) {\n+                if (meta.hasAttr(\"http-equiv\"))\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                }\n-                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                    try {\n-                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                            foundCharset = meta.attr(\"charset\");\n-                        }\n-                    } catch (IllegalCharsetNameException e) {\n-                        foundCharset = null;\n-                    }\n-                }\n-\n-                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n-                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-                    charsetName = foundCharset;\n-                    byteData.rewind();\n-                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n-                    doc = null;\n-                }\n+                if (foundCharset == null && meta.hasAttr(\"charset\"))\n+                    foundCharset = meta.attr(\"charset\");\n+                if (foundCharset != null)\n+                    break;\n+            }\n+\n+            // look for <?xml encoding='ISO-8859-1'?>\n+            if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n+                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n+                if (prolog.name().equals(\"xml\"))\n+                    foundCharset = prolog.attr(\"encoding\");\n+            }\n+            foundCharset = validateCharset(foundCharset);\n+            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n+                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n+                charsetName = foundCharset;\n+                doc = null;\n+            } else if (!fullyRead) {\n+                doc = null;\n             }\n         } else { // specified by content type header (or by user on file load)\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n-            docData = Charset.forName(charsetName).decode(byteData).toString();\n-        }\n-        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n-        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n-            byteData.rewind();\n-            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n-            docData = docData.substring(1);\n-            charsetName = defaultCharset;\n-            doc = null;\n         }\n         if (doc == null) {\n-            doc = parser.parseInput(docData, baseUri);\n+            if (charsetName == null)\n+                charsetName = defaultCharset;\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+            doc = parser.parseInput(reader, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }\n+        input.close();\n         return doc;\n     }\n \n     /**\n-     * Read the input stream into a byte buffer.\n+     * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this\n+     * method is executing on. The data read until being interrupted will be available.\n      * @param inStream the input stream to read from\n      * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n      * @return the filled byte buffer\n      * @throws IOException if an exception occurs whilst reading from the input stream.\n      */\n-    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n+    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n         Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n         final boolean capped = maxSize > 0;\n-        byte[] buffer = new byte[bufferSize];\n-        ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n+        final byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n+\n         int read;\n         int remaining = maxSize;\n \n             read = inStream.read(buffer);\n             if (read == -1) break;\n             if (capped) {\n-                if (read > remaining) {\n+                if (read >= remaining) {\n                     outStream.write(buffer, 0, remaining);\n                     break;\n                 }\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.replace(\"charset=\", \"\");\n-            if (charset.length() == 0) return null;\n-            try {\n-                if (Charset.isSupported(charset)) return charset;\n-                charset = charset.toUpperCase(Locale.ENGLISH);\n-                if (Charset.isSupported(charset)) return charset;\n-            } catch (IllegalCharsetNameException e) {\n-                // if our advanced charset matching fails.... we just take the default\n-                return null;\n-            }\n+            return validateCharset(charset);\n+        }\n+        return null;\n+    }\n+\n+    private static String validateCharset(String cs) {\n+        if (cs == null || cs.length() == 0) return null;\n+        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n+        try {\n+            if (Charset.isSupported(cs)) return cs;\n+            cs = cs.toUpperCase(Locale.ENGLISH);\n+            if (Charset.isSupported(cs)) return cs;\n+        } catch (IllegalCharsetNameException e) {\n+            // if our this charset matching fails.... we just take the default\n         }\n         return null;\n     }\n         }\n         return mime.toString();\n     }\n+\n+    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData, final String charsetName) {\n+        byteData.mark();\n+        byte[] bom = new byte[4];\n+        if (byteData.remaining() >= bom.length) {\n+            byteData.get(bom);\n+            byteData.rewind();\n+        }\n+        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n+            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n+            return new BomCharset(\"UTF-32\", 0); // and I hope it's on your system\n+        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n+            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n+            return new BomCharset(\"UTF-16\", 0); // in all Javas\n+        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n+            return new BomCharset(\"UTF-8\", 3); // in all Javas\n+            // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n+        }\n+        return null;\n+    }\n+\n+    private static class BomCharset {\n+        private final String charset;\n+        private final int offset;\n+\n+        public BomCharset(String charset, int offset) {\n+            this.charset = charset;\n+            this.offset = offset;\n+        }\n+    }\n }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n \n import org.jsoup.Connection;\n import org.jsoup.HttpStatusException;\n+import org.jsoup.UncheckedIOException;\n import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n-import javax.net.ssl.*;\n-import java.io.*;\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UnsupportedEncodingException;\n import java.net.HttpURLConnection;\n+import java.net.InetSocketAddress;\n import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URI;\n import java.net.URL;\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.security.KeyManagementException;\n import java.security.NoSuchAlgorithmException;\n import java.security.cert.X509Certificate;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n+\n+import static org.jsoup.Connection.Method.HEAD;\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  * Implementation of {@link Connection}.\n  * @see org.jsoup.Jsoup#connect(String)\n  */\n public class HttpConnection implements Connection {\n-    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n+    public static final String CONTENT_ENCODING = \"Content-Encoding\";\n+    /**\n+     * Many users would get caught by not setting a user-agent and therefore getting different responses on their desktop\n+     * vs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.\n+     */\n+    public static final String DEFAULT_UA =\n+        \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\";\n+    private static final String USER_AGENT = \"User-Agent\";\n     private static final String CONTENT_TYPE = \"Content-Type\";\n     private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n     private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n+    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n \n     public static Connection connect(String url) {\n         Connection con = new HttpConnection();\n         return con;\n     }\n \n+    /**\n+     * Encodes the input URL into a safe ASCII URL string\n+     * @param url unescaped URL\n+     * @return escaped URL\n+     */\n \tprivate static String encodeUrl(String url) {\n-\t\tif(url == null)\n-\t\t\treturn null;\n-    \treturn url.replaceAll(\" \", \"%20\");\n+        try {\n+            URL u = new URL(url);\n+            return encodeUrl(u).toExternalForm();\n+        } catch (Exception e) {\n+            return url;\n+        }\n \t}\n+\n+    static URL encodeUrl(URL u) {\n+        try {\n+            //  odd way to encode urls, but it works!\n+            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)\n+            urlS = urlS.replaceAll(\" \", \"%20\");\n+            final URI uri = new URI(urlS);\n+            return new URL(uri.toASCIIString());\n+        } catch (Exception e) {\n+            return u;\n+        }\n+    }\n \n     private static String encodeMimeName(String val) {\n         if (val == null)\n         return this;\n     }\n \n+    public Connection proxy(Proxy proxy) {\n+        req.proxy(proxy);\n+        return this;\n+    }\n+\n+    public Connection proxy(String host, int port) {\n+        req.proxy(host, port);\n+        return this;\n+    }\n+\n     public Connection userAgent(String userAgent) {\n         Validate.notNull(userAgent, \"User agent must not be null\");\n-        req.header(\"User-Agent\", userAgent);\n+        req.header(USER_AGENT, userAgent);\n         return this;\n     }\n \n         return this;\n     }\n \n+    public Connection.KeyVal data(String key) {\n+        Validate.notEmpty(key, \"Data key must not be empty\");\n+        for (Connection.KeyVal keyVal : request().data()) {\n+            if (keyVal.key().equals(key))\n+                return keyVal;\n+        }\n+        return null;\n+    }\n+\n+    public Connection requestBody(String body) {\n+        req.requestBody(body);\n+        return this;\n+    }\n+\n     public Connection header(String name, String value) {\n         req.header(name, value);\n+        return this;\n+    }\n+\n+    public Connection headers(Map<String,String> headers) {\n+        Validate.notNull(headers, \"Header map must not be null\");\n+        for (Map.Entry<String,String> entry : headers.entrySet()) {\n+            req.header(entry.getKey(),entry.getValue());\n+        }\n         return this;\n     }\n \n         Map<String, String> cookies;\n \n         private Base() {\n-            headers = new LinkedHashMap<String, String>();\n-            cookies = new LinkedHashMap<String, String>();\n+            headers = new LinkedHashMap<>();\n+            cookies = new LinkedHashMap<>();\n         }\n \n         public URL url() {\n \n         public String header(String name) {\n             Validate.notNull(name, \"Header name must not be null\");\n-            return getHeaderCaseInsensitive(name);\n+            String val = getHeaderCaseInsensitive(name);\n+            if (val != null) {\n+                // headers should be ISO8859 - but values are often actually UTF-8. Test if it looks like UTF8 and convert if so\n+                val = fixHeaderEncoding(val);\n+            }\n+            return val;\n+        }\n+\n+        private static String fixHeaderEncoding(String val) {\n+            try {\n+                byte[] bytes = val.getBytes(\"ISO-8859-1\");\n+                if (!looksLikeUtf8(bytes))\n+                    return val;\n+                return new String(bytes, \"UTF-8\");\n+            } catch (UnsupportedEncodingException e) {\n+                // shouldn't happen as these both always exist\n+                return val;\n+            }\n+        }\n+\n+        private static boolean looksLikeUtf8(byte[] input) {\n+            int i = 0;\n+            // BOM:\n+            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n+                && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n+                i = 3;\n+            }\n+\n+            int end;\n+            for (int j = input.length; i < j; ++i) {\n+                int o = input[i];\n+                if ((o & 0x80) == 0) {\n+                    continue; // ASCII\n+                }\n+\n+                // UTF-8 leading:\n+                if ((o & 0xE0) == 0xC0) {\n+                    end = i + 1;\n+                } else if ((o & 0xF0) == 0xE0) {\n+                    end = i + 2;\n+                } else if ((o & 0xF8) == 0xF0) {\n+                    end = i + 3;\n+                } else {\n+                    return false;\n+                }\n+\n+                while (i < end) {\n+                    i++;\n+                    o = input[i];\n+                    if ((o & 0xC0) != 0x80) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n         }\n \n         public T header(String name, String value) {\n             // quick evals for common case of title case, lower case, then scan for mixed\n             String value = headers.get(name);\n             if (value == null)\n-                value = headers.get(name.toLowerCase());\n+                value = headers.get(lowerCase(name));\n             if (value == null) {\n                 Map.Entry<String, String> entry = scanHeaders(name);\n                 if (entry != null)\n         }\n \n         private Map.Entry<String, String> scanHeaders(String name) {\n-            String lc = name.toLowerCase();\n+            String lc = lowerCase(name);\n             for (Map.Entry<String, String> entry : headers.entrySet()) {\n-                if (entry.getKey().toLowerCase().equals(lc))\n+                if (lowerCase(entry.getKey()).equals(lc))\n                     return entry;\n             }\n             return null;\n     }\n \n     public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n+        private Proxy proxy; // nullable\n         private int timeoutMilliseconds;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n         private Collection<Connection.KeyVal> data;\n+        private String body = null;\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n         private String postDataCharset = DataUtil.defaultCharset;\n \n         private Request() {\n-            timeoutMilliseconds = 3000;\n+            timeoutMilliseconds = 30000; // 30 seconds\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n-            data = new ArrayList<Connection.KeyVal>();\n+            data = new ArrayList<>();\n             method = Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n+            headers.put(USER_AGENT, DEFAULT_UA);\n             parser = Parser.htmlParser();\n+        }\n+\n+        public Proxy proxy() {\n+            return proxy;\n+        }\n+\n+        public Request proxy(Proxy proxy) {\n+            this.proxy = proxy;\n+            return this;\n+        }\n+\n+        public Request proxy(String host, int port) {\n+            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n+            return this;\n         }\n \n         public int timeout() {\n \n         public Collection<Connection.KeyVal> data() {\n             return data;\n+        }\n+\n+        public Connection.Request requestBody(String body) {\n+            this.body = body;\n+            return this;\n+        }\n+\n+        public String requestBody() {\n+            return body;\n         }\n \n         public Request parser(Parser parser) {\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n+        private InputStream bodyStream;\n         private String charset;\n         private String contentType;\n         private boolean executed = false;\n+        private boolean inputStreamRead = false;\n         private int numRedirects = 0;\n         private Connection.Request req;\n \n             String protocol = req.url().getProtocol();\n             if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                 throw new MalformedURLException(\"Only http & https protocols supported\");\n+            final boolean methodHasBody = req.method().hasBody();\n+            final boolean hasRequestBody = req.requestBody() != null;\n+            if (!methodHasBody)\n+                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n \n             // set up the request for execution\n             String mimeBoundary = null;\n-            if (!req.method().hasBody() && req.data().size() > 0) {\n-                serialiseRequestUrl(req); // appends query string\n-            } else if (req.method().hasBody()) {\n+            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n+                serialiseRequestUrl(req);\n+            else if (methodHasBody)\n                 mimeBoundary = setOutputContentType(req);\n-            }\n+\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n \n                 // redirect if there's a location header (from 3xx, or 201 etc)\n                 if (res.hasHeader(LOCATION) && req.followRedirects()) {\n-                    req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n-                    req.data().clear();\n+                    if (status != HTTP_TEMP_REDIR) {\n+                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n+                        req.data().clear();\n+                        req.requestBody(null);\n+                        req.removeHeader(CONTENT_TYPE);\n+                    }\n \n                     String location = res.header(LOCATION);\n                     if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                         location = location.substring(6);\n-                    req.url(StringUtil.resolve(req.url(), encodeUrl(location)));\n+                    URL redir = StringUtil.resolve(req.url(), location);\n+                    req.url(encodeUrl(redir));\n \n                     for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { // add response cookies to request (for e.g. login posts)\n                         req.cookie(cookie.getKey(), cookie.getValue());\n                 }\n \n                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n-                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n-                    InputStream bodyStream = null;\n-                    InputStream dataStream = null;\n-                    try {\n-                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n-                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n-                                new BufferedInputStream(dataStream);\n-\n-                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n-                    } finally {\n-                        if (bodyStream != null) bodyStream.close();\n-                        if (dataStream != null) dataStream.close();\n-                    }\n+                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n+                    res.bodyStream = null;\n+                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n+                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n+                    res.bodyStream = new ConstrainableInputStream(res.bodyStream, DataUtil.bufferSize, req.maxBodySize());\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n                 }\n-            } finally {\n+            } catch (IOException e){\n                 // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                 // connection errors will not be released quickly enough and can cause a too many open files error.\n                 conn.disconnect();\n+                throw e;\n             }\n \n             res.executed = true;\n             return charset;\n         }\n \n+        public Response charset(String charset) {\n+            this.charset = charset;\n+            return this;\n+        }\n+\n         public String contentType() {\n             return contentType;\n         }\n \n         public Document parse() throws IOException {\n             Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n-            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n-            byteData.rewind();\n+            if (byteData != null) { // bytes have been read in to the buffer, parse that\n+                bodyStream = new ByteArrayInputStream(byteData.array());\n+                inputStreamRead = false; // ok to reparse if in bytes\n+            }\n+            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n+            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n+            // todo - disconnect here?\n+            inputStreamRead = true;\n             return doc;\n         }\n \n+        private void prepareByteData() {\n+            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            if (byteData == null) {\n+                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n+                try {\n+                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        }\n+\n         public String body() {\n-            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            prepareByteData();\n             // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n             String body;\n             if (charset == null)\n         }\n \n         public byte[] bodyAsBytes() {\n-            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            prepareByteData();\n             return byteData.array();\n+        }\n+\n+        @Override\n+        public Connection.Response bufferUp() {\n+            prepareByteData();\n+            return this;\n         }\n \n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n-            HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+            final HttpURLConnection conn = (HttpURLConnection) (\n+                req.proxy() == null ?\n+                req.url().openConnection() :\n+                req.url().openConnection(req.proxy())\n+            );\n \n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n                     sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n                     // Create an ssl socket factory with our all-trusting manager\n                     sslSocketFactory = sslContext.getSocketFactory();\n-                } catch (NoSuchAlgorithmException e) {\n-                    throw new IOException(\"Can't create unsecure trust manager\");\n-                } catch (KeyManagementException e) {\n+                } catch (NoSuchAlgorithmException | KeyManagementException e) {\n                     throw new IOException(\"Can't create unsecure trust manager\");\n                 }\n             }\n \n         private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n             // the default sun impl of conn.getHeaderFields() returns header values out of order\n-            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>();\n+            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n             int i = 0;\n             while (true) {\n                 final String key = conn.getHeaderFieldKey(i);\n                 if (headers.containsKey(key))\n                     headers.get(key).add(val);\n                 else {\n-                    final ArrayList<String> vals = new ArrayList<String>();\n+                    final ArrayList<String> vals = new ArrayList<>();\n                     vals.add(val);\n                     headers.put(key, vals);\n                 }\n         }\n \n         private static String setOutputContentType(final Connection.Request req) {\n-            // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n-            boolean needsMulti = false;\n-            for (Connection.KeyVal keyVal : req.data()) {\n-                if (keyVal.hasInputStream()) {\n-                    needsMulti = true;\n-                    break;\n-                }\n-            }\n             String bound = null;\n-            if (needsMulti) {\n+            if (req.hasHeader(CONTENT_TYPE)) {\n+                // no-op; don't add content type as already set (e.g. for requestBody())\n+                // todo - if content type already set, we could add charset or boundary if those aren't included\n+            }\n+            else if (needsMultipart(req)) {\n                 bound = DataUtil.mimeBoundary();\n                 req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n             } else {\n \n         private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n             final Collection<Connection.KeyVal> data = req.data();\n-            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n+            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n \n             if (bound != null) {\n                 // boundary will be set if we're in multipart mode\n                 w.write(\"--\");\n                 w.write(bound);\n                 w.write(\"--\");\n-            } else {\n+            } else if (req.requestBody() != null) {\n+                // data will be in query string, we're sending a plaintext body\n+                w.write(req.requestBody());\n+            }\n+            else {\n                 // regular form data (application/x-www-form-urlencoded)\n                 boolean first = true;\n                 for (Connection.KeyVal keyVal : data) {\n                 first = false;\n             }\n             for (Connection.KeyVal keyVal : req.data()) {\n+                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                 if (!first)\n                     url.append('&');\n                 else\n         }\n     }\n \n+    private static boolean needsMultipart(Connection.Request req) {\n+        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n+        boolean needsMulti = false;\n+        for (Connection.KeyVal keyVal : req.data()) {\n+            if (keyVal.hasInputStream()) {\n+                needsMulti = true;\n+                break;\n+            }\n+        }\n+        return needsMulti;\n+    }\n+\n     public static class KeyVal implements Connection.KeyVal {\n         private String key;\n         private String value;\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n     private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\n \n     /**\n-     * Join a collection of strings by a seperator\n+     * Join a collection of strings by a separator\n      * @param strings collection of string objects\n      * @param sep string to place between strings\n      * @return joined string\n     }\n \n     /**\n-     * Join a collection of strings by a seperator\n+     * Join a collection of strings by a separator\n      * @param strings iterator of string objects\n      * @param sep string to place between strings\n      * @return joined string\n     }\n \n     /**\n-     * Tests if a string is blank: null, emtpy, or only whitespace (\" \", \\r\\n, \\t, etc)\n+     * Tests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n      * @param string string to test\n      * @return if string is blank\n      */\n     /**\n      * Tests if a string is numeric, i.e. contains only digit characters\n      * @param string string to test\n-     * @return true if only digit chars, false if empty or null or contains non-digit chrs\n+     * @return true if only digit chars, false if empty or null or contains non-digit chars\n      */\n     public static boolean isNumeric(String string) {\n         if (string == null || string.length() == 0)\n \n     /**\n      * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n-     * @param base the existing absolulte base URL\n+     * @param base the existing absolute base URL\n      * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n      * @return the resolved absolute URL\n      * @throws MalformedURLException if an error occurred generating the URL\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n package org.jsoup.helper;\n \n import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n import org.w3c.dom.Comment;\n import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.parsers.ParserConfigurationException;\n import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n import javax.xml.transform.TransformerFactory;\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n import java.io.StringWriter;\n-import javax.xml.transform.TransformerException;\n+import java.util.HashMap;\n \n /**\n  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n  * for integration with toolsets that use the W3C DOM.\n- * <p>\n- * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.\n- * </p>\n  */\n public class W3CDom {\n     protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n         Validate.notNull(in);\n         DocumentBuilder builder;\n         try {\n+        \t//set the factory to be namespace-aware\n+        \tfactory.setNamespaceAware(true);\n             builder = factory.newDocumentBuilder();\n             Document out = builder.newDocument();\n             convert(in, out);\n     /**\n      * Implements the conversion by walking the input.\n      */\n-    protected class W3CBuilder implements NodeVisitor {\n+    protected static class W3CBuilder implements NodeVisitor {\n+        private static final String xmlnsKey = \"xmlns\";\n+        private static final String xmlnsPrefix = \"xmlns:\";\n+\n         private final Document doc;\n+        private final HashMap<String, String> namespaces = new HashMap<>(); // prefix => urn\n         private Element dest;\n \n         public W3CBuilder(Document doc) {\n         public void head(org.jsoup.nodes.Node source, int depth) {\n             if (source instanceof org.jsoup.nodes.Element) {\n                 org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n-                Element el = doc.createElement(sourceEl.tagName());\n+\n+                String prefix = updateNamespaces(sourceEl);\n+                String namespace = namespaces.get(prefix);\n+\n+                Element el = doc.createElementNS(namespace, sourceEl.tagName());\n                 copyAttributes(sourceEl, el);\n                 if (dest == null) { // sets up the root\n                     doc.appendChild(el);\n \n         private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n             for (Attribute attribute : source.attributes()) {\n-                el.setAttribute(attribute.getKey(), attribute.getValue());\n+                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n+                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n+                if (key.matches(\"[a-zA-Z_:][-a-zA-Z0-9_:.]*\"))\n+                    el.setAttribute(key, attribute.getValue());\n             }\n         }\n+\n+        /**\n+         * Finds any namespaces defined in this element. Returns any tag prefix.\n+         */\n+        private String updateNamespaces(org.jsoup.nodes.Element el) {\n+            // scan the element for namespace declarations\n+            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n+            Attributes attributes = el.attributes();\n+            for (Attribute attr : attributes) {\n+                String key = attr.getKey();\n+                String prefix;\n+                if (key.equals(xmlnsKey)) {\n+                    prefix = \"\";\n+                } else if (key.startsWith(xmlnsPrefix)) {\n+                    prefix = key.substring(xmlnsPrefix.length());\n+                } else {\n+                    continue;\n+                }\n+                namespaces.put(prefix, attr.getValue());\n+            }\n+\n+            // get the element prefix if any\n+            int pos = el.tagName().indexOf(\":\");\n+            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n+        }\n+\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/ConstrainableInputStream.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.helper.Validate;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * A jsoup internal class (so don't use it as there is no contract API) that enables constraints on an Input Stream,\n+ * namely a maximum read size, and the ability to Thread.interrupt() the read.\n+ */\n+public final class ConstrainableInputStream extends BufferedInputStream {\n+    private final boolean capped;\n+    private int remaining;\n+\n+    public ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {\n+        super(in, bufferSize);\n+        Validate.isTrue(maxSize >= 0);\n+        remaining = maxSize;\n+        capped = maxSize != 0;\n+    }\n+\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (Thread.interrupted() || remaining < 0)\n+            return -1;\n+\n+        final int read = super.read(b, off, len);\n+        if (capped) {\n+            remaining -= read;\n+        }\n+        return read;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/Normalizer.java\n+package org.jsoup.internal;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Util methods for normalizing strings. Jsoup internal use only, please don't depend on this API.\n+ */\n+public final class Normalizer {\n+\n+    public static String lowerCase(final String input) {\n+        return input.toLowerCase(Locale.ENGLISH);\n+    }\n+\n+    public static String normalize(final String input) {\n+        return lowerCase(input).trim();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/package-info.java\n+/**\n+ * Util methods used by Jsoup. Please don't depend on the APIs implemented here as the contents may change without\n+ * notice.\n+ */\n+package org.jsoup.internal;\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.Validate;\n \n+import java.io.IOException;\n import java.util.Arrays;\n import java.util.Map;\n \n \n     /**\n      * Create a new attribute from unencoded (raw) key and value.\n-     * @param key attribute key\n+     * @param key attribute key; case is preserved.\n      * @param value attribute value\n      * @see #createFromEncoded\n      */\n     public Attribute(String key, String value) {\n-        Validate.notEmpty(key);\n+        Validate.notNull(key);\n         Validate.notNull(value);\n-        this.key = key.trim().toLowerCase();\n+        this.key = key.trim();\n+        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n         this.value = value;\n     }\n \n     }\n \n     /**\n-     Set the attribute key. Gets normalised as per the constructor method.\n+     Set the attribute key; case is preserved.\n      @param key the new key; must not be null\n      */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key.trim().toLowerCase();\n+        this.key = key.trim();\n     }\n \n     /**\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n-        html(accum, (new Document(\"\")).outputSettings());\n+        \n+        try {\n+        \thtml(accum, (new Document(\"\")).outputSettings());\n+        } catch(IOException exception) {\n+        \tthrow new SerializationException(exception);\n+        }\n         return accum.toString();\n     }\n     \n-    protected void html(StringBuilder accum, Document.OutputSettings out) {\n+    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         accum.append(key);\n         if (!shouldCollapseAttribute(out)) {\n             accum.append(\"=\\\"\");\n     /**\n      * Collapsible if it's a boolean attribute and value is empty or same as name\n      * \n-     * @param out Outputsettings\n+     * @param out output settings\n      * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.Validate;\n \n-import java.util.*;\n+import java.io.IOException;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n /**\n  * The attributes of an Element.\n  * <p>\n- * Attributes are treated as a map: there can be only one value associated with an attribute key.\n+ * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n  * </p>\n  * <p>\n- * Attribute key and value comparisons are done case insensitively, and keys are normalised to\n- * lower-case.\n+ * Attribute name and value comparisons are  <b>case sensitive</b>. By default for HTML, attribute names are\n+ * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n+ * name.\n  * </p>\n- * \n+ *\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n-    \n+\n     private LinkedHashMap<String, Attribute> attributes = null;\n     // linked hash map to preserve insertion order.\n     // null be default as so many elements have no attributes -- saves a good chunk of memory\n \n     /**\n      Get an attribute value by key.\n-     @param key the attribute key\n+     @param key the (case-sensitive) attribute key\n      @return the attribute value if set; or empty string if not set.\n      @see #hasKey(String)\n      */\n         if (attributes == null)\n             return \"\";\n \n-        Attribute attr = attributes.get(key.toLowerCase());\n+        Attribute attr = attributes.get(key);\n         return attr != null ? attr.getValue() : \"\";\n+    }\n+\n+    /**\n+     * Get an attribute's value by case-insensitive key\n+     * @param key the attribute name\n+     * @return the first matching attribute value if set; or empty string if not set.\n+     */\n+    public String getIgnoreCase(String key) {\n+        Attribute attr = getAttributeIgnoreCase(key);\n+        return attr != null ? attr.getValue() : \"\";\n+    }\n+\n+    private Attribute getAttributeIgnoreCase(String key) {\n+        Validate.notEmpty(key);\n+        if (attributes == null)\n+            return null;\n+\n+        Attribute attr = attributes.get(key);\n+        if (attr != null)\n+            return attr;\n+\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                return attributes.get(attrKey);\n+        }\n+        return null;\n     }\n \n     /**\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n     }\n-    \n+\n+    void putIgnoreCase(String key, String value) {\n+        Attribute oldAttr = getAttributeIgnoreCase(key);\n+        if (oldAttr != null && !oldAttr.getKey().equals(key)) {\n+            attributes.remove(oldAttr.getKey());\n+        }\n+\n+        put(key, value);\n+    }\n+\n     /**\n     Set a new boolean attribute, remove attribute if value is false.\n     @param key attribute key\n     public void put(Attribute attribute) {\n         Validate.notNull(attribute);\n         if (attributes == null)\n-             attributes = new LinkedHashMap<String, Attribute>(2);\n+             attributes = new LinkedHashMap<>(2);\n         attributes.put(attribute.getKey(), attribute);\n     }\n \n     /**\n-     Remove an attribute by key.\n+     Remove an attribute by key. <b>Case sensitive.</b>\n      @param key attribute key to remove\n      */\n     public void remove(String key) {\n         Validate.notEmpty(key);\n         if (attributes == null)\n             return;\n-        attributes.remove(key.toLowerCase());\n+        attributes.remove(key);\n+    }\n+\n+    /**\n+     Remove an attribute by key. <b>Case insensitive.</b>\n+     @param key attribute key to remove\n+     */\n+    public void removeIgnoreCase(String key) {\n+        Validate.notEmpty(key);\n+        if (attributes == null)\n+            return;\n+        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n+            String attrKey = it.next();\n+            if (attrKey.equalsIgnoreCase(key))\n+                it.remove();\n+        }\n+    }\n+\n+    /**\n+     Tests if these attributes contain an attribute with this key.\n+     @param key case-sensitive key to check for\n+     @return true if key exists, false otherwise\n+     */\n+    public boolean hasKey(String key) {\n+        return attributes != null && attributes.containsKey(key);\n     }\n \n     /**\n      @param key key to check for\n      @return true if key exists, false otherwise\n      */\n-    public boolean hasKey(String key) {\n-        return attributes != null && attributes.containsKey(key.toLowerCase());\n+    public boolean hasKeyIgnoreCase(String key) {\n+        if (attributes == null)\n+            return false;\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                return true;\n+        }\n+        return false;\n     }\n \n     /**\n         if (incoming.size() == 0)\n             return;\n         if (attributes == null)\n-            attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n+            attributes = new LinkedHashMap<>(incoming.size());\n         attributes.putAll(incoming.attributes);\n     }\n-    \n+\n     public Iterator<Attribute> iterator() {\n-        return asList().iterator();\n+        if (attributes == null || attributes.isEmpty()) {\n+            return Collections.<Attribute>emptyList().iterator();\n+        }\n+\n+        return attributes.values().iterator();\n     }\n \n     /**\n         if (attributes == null)\n             return Collections.emptyList();\n \n-        List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n+        List<Attribute> list = new ArrayList<>(attributes.size());\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             list.add(entry.getValue());\n         }\n     /**\n      Get the HTML representation of these attributes.\n      @return HTML\n+     @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n-        html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+        try {\n+            html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+        } catch (IOException e) { // ought never happen\n+            throw new SerializationException(e);\n+        }\n         return accum.toString();\n     }\n-    \n-    void html(StringBuilder accum, Document.OutputSettings out) {\n+\n+    void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         if (attributes == null)\n             return;\n-        \n+\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             Attribute attribute = entry.getValue();\n             accum.append(\" \");\n             attribute.html(accum, out);\n         }\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return html();\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         if (!(o instanceof Attributes)) return false;\n-        \n+\n         Attributes that = (Attributes) o;\n-        \n+\n         return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n     }\n \n         } catch (CloneNotSupportedException e) {\n             throw new RuntimeException(e);\n         }\n-        clone.attributes = new LinkedHashMap<String, Attribute>(attributes.size());\n+        clone.attributes = new LinkedHashMap<>(attributes.size());\n         for (Attribute attribute: this)\n             clone.attributes.put(attribute.getKey(), attribute.clone());\n         return clone;\n \n         private Dataset() {\n             if (attributes == null)\n-                attributes = new LinkedHashMap<String, Attribute>(2);\n+                attributes = new LinkedHashMap<>(2);\n         }\n \n         @Override\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n /**\n  A comment node.\n         return attributes.get(COMMENT_KEY);\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (out.prettyPrint())\n             indent(accum, depth, out);\n         accum\n                 .append(\"-->\");\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n /**\n  A data node, for contents of style, script tags etc, where contents should not show in text().\n         return this;\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum.append(getWholeData()); // data is not escaped in return from data nodes, so \" in script, style is plain\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n \n      @see #createShell\n      */\n     public Document(String baseUri) {\n-        super(Tag.valueOf(\"#root\"), baseUri);\n+        super(Tag.valueOf(\"#root\", ParseSettings.htmlDefault), baseUri);\n         this.location = baseUri;\n     }\n \n      @param baseUri baseUri of document\n      @return document with html, head, and body elements.\n      */\n-    static public Document createShell(String baseUri) {\n+    public static Document createShell(String baseUri) {\n         Validate.notNull(baseUri);\n \n         Document doc = new Document(baseUri);\n      @return new element\n      */\n     public Element createElement(String tagName) {\n-        return new Element(Tag.valueOf(tagName), this.baseUri());\n+        return new Element(Tag.valueOf(tagName, ParseSettings.preserveCase), this.baseUri());\n     }\n \n     /**\n \n     // does not recurse.\n     private void normaliseTextNodes(Element element) {\n-        List<Node> toMove = new ArrayList<Node>();\n+        List<Node> toMove = new ArrayList<>();\n         for (Node node: element.childNodes) {\n             if (node instanceof TextNode) {\n                 TextNode tn = (TextNode) node;\n         Elements elements = this.getElementsByTag(tag);\n         Element master = elements.first(); // will always be available as created above if not existent\n         if (elements.size() > 1) { // dupes, move contents to master\n-            List<Node> toMove = new ArrayList<Node>();\n+            List<Node> toMove = new ArrayList<>();\n             for (int i = 1; i < elements.size(); i++) {\n                 Node dupe = elements.get(i);\n-                for (Node node : dupe.childNodes)\n-                    toMove.add(node);\n+                toMove.addAll(dupe.childNodes);\n                 dupe.remove();\n             }\n \n      * <tt>true</tt>, otherwise this method does nothing.\n      * \n      * <ul>\n-     * <li>An exsiting element gets updated with the current charset</li>\n+     * <li>An existing element gets updated with the current charset</li>\n      * <li>If there's no element yet it will be inserted</li>\n      * <li>Obsolete elements are removed</li>\n      * </ul>\n                 if (node instanceof XmlDeclaration) {\n                     XmlDeclaration decl = (XmlDeclaration) node;\n \n-                    if (decl.attr(XmlDeclaration.DECL_KEY).equals(\"xml\")) {\n+                    if (decl.name().equals(\"xml\")) {\n                         decl.attr(\"encoding\", charset().displayName());\n \n                         final String version = decl.attr(\"version\");\n \n                     prependChild(decl);\n                 }\n-            } else {\n-                // Unsupported syntax - nothing to do yet\n             }\n         }\n     }\n \n         private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\n         private Charset charset = Charset.forName(\"UTF-8\");\n-        private CharsetEncoder charsetEncoder = charset.newEncoder();\n         private boolean prettyPrint = true;\n         private boolean outline = false;\n         private int indentAmount = 1;\n          */\n         public OutputSettings charset(Charset charset) {\n             this.charset = charset;\n-            charsetEncoder = charset.newEncoder();\n             return this;\n         }\n \n         }\n \n         CharsetEncoder encoder() {\n-            return charsetEncoder;\n+            return charset.newEncoder();\n         }\n \n         /**\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document.OutputSettings.*;\n  * A {@code <!DOCTYPE>} node.\n  */\n public class DocumentType extends Node {\n+    public static final String PUBLIC_KEY = \"PUBLIC\";\n+    public static final String SYSTEM_KEY = \"SYSTEM\";\n     private static final String NAME = \"name\";\n+    private static final String PUB_SYS_KEY = \"pubSysKey\"; // PUBLIC or SYSTEM\n     private static final String PUBLIC_ID = \"publicId\";\n     private static final String SYSTEM_ID = \"systemId\";\n     // todo: quirk mode from publicId and systemId\n \n         attr(NAME, name);\n         attr(PUBLIC_ID, publicId);\n+        if (has(PUBLIC_ID)) {\n+            attr(PUB_SYS_KEY, PUBLIC_KEY);\n+        }\n+        attr(SYSTEM_ID, systemId);\n+    }\n+\n+    /**\n+     * Create a new doctype element.\n+     * @param name the doctype's name\n+     * @param publicId the doctype's public ID\n+     * @param systemId the doctype's system ID\n+     * @param baseUri the doctype's base URI\n+     */\n+    public DocumentType(String name, String pubSysKey, String publicId, String systemId, String baseUri) {\n+        super(baseUri);\n+\n+        attr(NAME, name);\n+        if (pubSysKey != null) {\n+            attr(PUB_SYS_KEY, pubSysKey);\n+        }\n+        attr(PUBLIC_ID, publicId);\n         attr(SYSTEM_ID, systemId);\n     }\n \n     }\n \n     @Override\n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n             // looks like a html5 doctype, go lowercase for aesthetics\n             accum.append(\"<!doctype\");\n         }\n         if (has(NAME))\n             accum.append(\" \").append(attr(NAME));\n+        if (has(PUB_SYS_KEY))\n+            accum.append(\" \").append(attr(PUB_SYS_KEY));\n         if (has(PUBLIC_ID))\n-            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n+            accum.append(\" \\\"\").append(attr(PUBLIC_ID)).append('\"');\n         if (has(SYSTEM_ID))\n             accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n         accum.append('>');\n     }\n \n     @Override\n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n     }\n \n     private boolean has(final String attribute) {\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.*;\n-\n-import java.util.*;\n+import org.jsoup.select.Collector;\n+import org.jsoup.select.Elements;\n+import org.jsoup.select.Evaluator;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n+import org.jsoup.select.QueryParser;\n+import org.jsoup.select.Selector;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n+\n+import static org.jsoup.internal.Normalizer.normalize;\n \n /**\n  * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and\n  */\n public class Element extends Node {\n     private Tag tag;\n+    private WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\n \n     private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n+\n+    /**\n+     * Create a new, standalone element.\n+     * @param tag tag name\n+     */\n+    public Element(String tag) {\n+        this(Tag.valueOf(tag), \"\", new Attributes());\n+    }\n \n     /**\n      * Create a new, standalone Element. (Standalone in that is has no parent.)\n      * @param tag element tag\n      * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n      *            string, but not null.\n-     * @see Tag#valueOf(String)\n+     * @see Tag#valueOf(String, ParseSettings)\n      */\n     public Element(Tag tag, String baseUri) {\n         this(tag, baseUri, new Attributes());\n      */\n     public Element tagName(String tagName) {\n         Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n-        tag = Tag.valueOf(tagName);\n+        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case\n         return this;\n     }\n \n      * @return The id attribute, if present, or an empty string if not.\n      */\n     public String id() {\n-        return attributes.get(\"id\");\n+        return attributes.getIgnoreCase(\"id\");\n     }\n \n     /**\n      * @see #childNode(int)\n      */\n     public Element child(int index) {\n-        return children().get(index);\n+        return childElementsList().get(index);\n     }\n \n     /**\n      * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n      * </p>\n-     * @return child elements. If this element has no children, returns an\n-     * empty list.\n+     * @return child elements. If this element has no children, returns an empty list.\n      * @see #childNodes()\n      */\n     public Elements children() {\n-        // create on the fly rather than maintaining two lists. if gets slow, memoize, and mark dirty on change\n-        List<Element> elements = new ArrayList<Element>(childNodes.size());\n-        for (Node node : childNodes) {\n-            if (node instanceof Element)\n-                elements.add((Element) node);\n-        }\n-        return new Elements(elements);\n+        return new Elements(childElementsList());\n+    }\n+\n+    /**\n+     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n+     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n+     * @return a list of child elements\n+     */\n+    private List<Element> childElementsList() {\n+        List<Element> children;\n+        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n+            final int size = childNodes.size();\n+            children = new ArrayList<>(size);\n+            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n+            for (int i = 0; i < size; i++) {\n+                final Node node = childNodes.get(i);\n+                if (node instanceof Element)\n+                    children.add((Element) node);\n+            }\n+            shadowChildrenRef = new WeakReference<>(children);\n+        }\n+        return children;\n+    }\n+\n+    /**\n+     * Clears the cached shadow child elements.\n+     */\n+    @Override\n+    void nodelistChanged() {\n+        super.nodelistChanged();\n+        shadowChildrenRef = null;\n     }\n \n     /**\n      * </ul>\n      */\n     public List<TextNode> textNodes() {\n-        List<TextNode> textNodes = new ArrayList<TextNode>();\n+        List<TextNode> textNodes = new ArrayList<>();\n         for (Node node : childNodes) {\n             if (node instanceof TextNode)\n                 textNodes.add((TextNode) node);\n      * @see #data()\n      */\n     public List<DataNode> dataNodes() {\n-        List<DataNode> dataNodes = new ArrayList<DataNode>();\n+        List<DataNode> dataNodes = new ArrayList<>();\n         for (Node node : childNodes) {\n             if (node instanceof DataNode)\n                 dataNodes.add((DataNode) node);\n      */\n     public Elements select(String cssQuery) {\n         return Selector.select(cssQuery, this);\n+    }\n+\n+    /**\n+     * Check if this element matches the given {@link Selector} CSS query.\n+     * @param cssQuery a {@link Selector} CSS query\n+     * @return if this element matches the query\n+     */\n+    public boolean is(String cssQuery) {\n+        return is(QueryParser.parse(cssQuery));\n+    }\n+\n+    /**\n+     * Check if this element matches the given evaluator.\n+     * @param evaluator an element evaluator\n+     * @return if this element matches\n+     */\n+    public boolean is(Evaluator evaluator) {\n+        return evaluator.matches((Element)this.root(), this);\n     }\n     \n     /**\n         if (index < 0) index += currentSize +1; // roll around\n         Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n \n-        ArrayList<Node> nodes = new ArrayList<Node>(children);\n+        ArrayList<Node> nodes = new ArrayList<>(children);\n         Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n         addChildren(index, nodeArray);\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n+     *\n+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n+     * end\n+     * @param children child nodes to insert\n+     * @return this element, for chaining.\n+     */\n+    public Element insertChildren(int index, Node... children) {\n+        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n+        int currentSize = childNodeSize();\n+        if (index < 0) index += currentSize +1; // roll around\n+        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n+\n+        addChildren(index, children);\n         return this;\n     }\n     \n      * @return this element\n      */\n     public Element appendText(String text) {\n+        Validate.notNull(text);\n         TextNode node = new TextNode(text, baseUri());\n         appendChild(node);\n         return this;\n      * @return this element\n      */\n     public Element prependText(String text) {\n+        Validate.notNull(text);\n         TextNode node = new TextNode(text, baseUri());\n         prependChild(node);\n         return this;\n         if (id().length() > 0)\n             return \"#\" + id();\n \n-        StringBuilder selector = new StringBuilder(tagName());\n+        // Translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n+        String tagName = tagName().replace(':', '|');\n+        StringBuilder selector = new StringBuilder(tagName);\n         String classes = StringUtil.join(classNames(), \".\");\n         if (classes.length() > 0)\n             selector.append('.').append(classes);\n         if (parentNode == null)\n             return new Elements(0);\n \n-        List<Element> elements = parent().children();\n+        List<Element> elements = parent().childElementsList();\n         Elements siblings = new Elements(elements.size() - 1);\n         for (Element el: elements)\n             if (el != this)\n      */\n     public Element nextElementSibling() {\n         if (parentNode == null) return null;\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\n         if (siblings.size() > index+1)\n      */\n     public Element previousElementSibling() {\n         if (parentNode == null) return null;\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         Integer index = indexInList(this, siblings);\n         Validate.notNull(index);\n         if (index > 0)\n      */\n     public Element firstElementSibling() {\n         // todo: should firstSibling() exclude this?\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         return siblings.size() > 1 ? siblings.get(0) : null;\n     }\n     \n      * sibling, returns 0.\n      * @return position in element sibling list\n      */\n-    public Integer elementSiblingIndex() {\n+    public int elementSiblingIndex() {\n        if (parent() == null) return 0;\n-       return indexInList(this, parent().children()); \n+       return indexInList(this, parent().childElementsList());\n     }\n \n     /**\n      * @return the last sibling that is an element (aka the parent's last element child) \n      */\n     public Element lastElementSibling() {\n-        List<Element> siblings = parent().children();\n+        List<Element> siblings = parent().childElementsList();\n         return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n     }\n-    \n-    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n-        Validate.notNull(search);\n-        Validate.notNull(elements);\n-\n+\n+    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n         for (int i = 0; i < elements.size(); i++) {\n-            E element = elements.get(i);\n-            if (element == search)\n+            if (elements.get(i) == search)\n                 return i;\n         }\n-        return null;\n+        return 0;\n     }\n \n     // DOM type methods\n      */\n     public Elements getElementsByTag(String tagName) {\n         Validate.notEmpty(tagName);\n-        tagName = tagName.toLowerCase().trim();\n+        tagName = normalize(tagName);\n \n         return Collector.collect(new Evaluator.Tag(tagName), this);\n     }\n      */\n     public Elements getElementsByAttribute(String key) {\n         Validate.notEmpty(key);\n-        key = key.trim().toLowerCase();\n+        key = key.trim();\n \n         return Collector.collect(new Evaluator.Attribute(key), this);\n     }\n      */\n     public Elements getElementsByAttributeStarting(String keyPrefix) {\n         Validate.notEmpty(keyPrefix);\n-        keyPrefix = keyPrefix.trim().toLowerCase();\n+        keyPrefix = keyPrefix.trim();\n \n         return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n     }\n     }\n \n     /**\n-     * Get the combined data of this element. Data is e.g. the inside of a {@code script} tag.\n+     * Get the combined data of this element. Data is e.g. the inside of a {@code script} tag. Note that data is NOT the\n+     * text of the element. Use {@link #text()} to get the text that would be visible to a user, and {@link #data()}\n+     * for the contents of scripts, comments, CSS styles, etc.\n+     *\n      * @return the data, or empty string if none\n      *\n      * @see #dataNodes()\n             if (childNode instanceof DataNode) {\n                 DataNode data = (DataNode) childNode;\n                 sb.append(data.getWholeData());\n+            } else if (childNode instanceof Comment) {\n+                Comment comment = (Comment) childNode;\n+                sb.append(comment.getData());\n             } else if (childNode instanceof Element) {\n                 Element element = (Element) childNode;\n                 String elementData = element.data();\n      */\n     public Set<String> classNames() {\n     \tString[] names = classSplit.split(className());\n-    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n+    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n     \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n \n         return classNames;\n      * @param className name of class to check for\n      * @return true if it does, false if not\n      */\n-    /*\n-    Used by common .class selector, so perf tweaked to reduce object creation vs hitting classnames().\n-\n-    Wiki: 71, 13 (5.4x)\n-    CNN: 227, 91 (2.5x)\n-    Alterslash: 59, 4 (14.8x)\n-    Jsoup: 14, 1 (14x)\n-    */\n+    // performance sensitive\n     public boolean hasClass(String className) {\n-        String classAttr = attributes.get(\"class\");\n-        if (classAttr.equals(\"\") || classAttr.length() < className.length())\n+        final String classAttr = attributes.getIgnoreCase(\"class\");\n+        final int len = classAttr.length();\n+        final int wantLen = className.length();\n+\n+        if (len == 0 || len < wantLen) {\n             return false;\n-\n-        final String[] classes = classSplit.split(classAttr);\n-        for (String name : classes) {\n-            if (className.equalsIgnoreCase(name))\n-                return true;\n+        }\n+\n+        // if both lengths are equal, only need compare the className with the attribute\n+        if (len == wantLen) {\n+            return className.equalsIgnoreCase(classAttr);\n+        }\n+\n+        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n+        boolean inClass = false;\n+        int start = 0;\n+        for (int i = 0; i < len; i++) {\n+            if (Character.isWhitespace(classAttr.charAt(i))) {\n+                if (inClass) {\n+                    // white space ends a class name, compare it with the requested one, ignore case\n+                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n+                        return true;\n+                    }\n+                    inClass = false;\n+                }\n+            } else {\n+                if (!inClass) {\n+                    // we're in a class name : keep the start of the substring\n+                    inClass = true;\n+                    start = i;\n+                }\n+            }\n+        }\n+\n+        // check the last entry\n+        if (inClass && len - start == wantLen) {\n+            return classAttr.regionMatches(true, start, className, 0, wantLen);\n         }\n \n         return false;\n         return this;\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )\n-            indent(accum, depth, out);\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+        if (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\n+            if (accum instanceof StringBuilder) {\n+                if (((StringBuilder) accum).length() > 0)\n+                    indent(accum, depth, out);\n+            } else {\n+                indent(accum, depth, out);\n+            }\n+        }\n         accum\n                 .append(\"<\")\n                 .append(tagName());\n             accum.append(\">\");\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n             if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                     tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n     }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public <T extends Appendable> T html(T appendable) {\n+        for (Node node : childNodes)\n+            node.outerHtml(appendable);\n+\n+        return appendable;\n+    }\n     \n     /**\n      * Set this element's inner HTML. Clears the existing HTML first.\n         return this;\n     }\n \n-    public String toString() {\n+\tpublic String toString() {\n         return outerHtml();\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n-\n-        Element element = (Element) o;\n-\n-        return tag.equals(element.tag);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = super.hashCode();\n-        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n-        return result;\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.parser.CharacterReader;\n import org.jsoup.parser.Parser;\n \n+import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n import java.nio.charset.CharsetEncoder;\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+\n+import static org.jsoup.nodes.Entities.EscapeMode.base;\n+import static org.jsoup.nodes.Entities.EscapeMode.extended;\n \n /**\n  * HTML entities, and escape routines.\n  * named character references</a>.\n  */\n public class Entities {\n+    private static final int empty = -1;\n+    private static final String emptyName = \"\";\n+    static final int codepointRadix = 36;\n+    private static final Charset ASCII = Charset.forName(\"ascii\");\n+\n     public enum EscapeMode {\n-        /** Restricted entities suitable for XHTML output: lt, gt, amp, and quot only. */\n-        xhtml(xhtmlByVal),\n-        /** Default HTML output entities. */\n-        base(baseByVal),\n-        /** Complete HTML entities. */\n-        extended(fullByVal);\n-\n-        private Map<Character, String> map;\n-\n-        EscapeMode(Map<Character, String> map) {\n-            this.map = map;\n-        }\n-\n-        public Map<Character, String> getMap() {\n-            return map;\n-        }\n-    }\n-\n-    private static final Map<String, Character> full;\n-    private static final Map<Character, String> xhtmlByVal;\n-    private static final Map<String, Character> base;\n-    private static final Map<Character, String> baseByVal;\n-    private static final Map<Character, String> fullByVal;\n-\n-    private Entities() {}\n+        /**\n+         * Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n+         */\n+        xhtml(\"entities-xhtml.properties\", 4),\n+        /**\n+         * Default HTML output entities.\n+         */\n+        base(\"entities-base.properties\", 106),\n+        /**\n+         * Complete HTML entities.\n+         */\n+        extended(\"entities-full.properties\", 2125);\n+\n+        // table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\n+        private String[] nameKeys;\n+        private int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n+\n+        // table of codepoints to named entities.\n+        private int[] codeKeys; // we don' support multicodepoints to single named value currently\n+        private String[] nameVals;\n+\n+        EscapeMode(String file, int size) {\n+            load(this, file, size);\n+        }\n+\n+        int codepointForName(final String name) {\n+            int index = Arrays.binarySearch(nameKeys, name);\n+            return index >= 0 ? codeVals[index] : empty;\n+        }\n+\n+        String nameForCodepoint(final int codepoint) {\n+            final int index = Arrays.binarySearch(codeKeys, codepoint);\n+            if (index >= 0) {\n+                // the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n+                // (and binary search for same item with multi results is undefined\n+                return (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\n+                    nameVals[index + 1] : nameVals[index];\n+            }\n+            return emptyName;\n+        }\n+\n+        private int size() {\n+            return nameKeys.length;\n+        }\n+    }\n+\n+    private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\n+\n+    private Entities() {\n+    }\n \n     /**\n      * Check if the input is a known named entity\n+     *\n      * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity\n      */\n-    public static boolean isNamedEntity(String name) {\n-        return full.containsKey(name);\n+    public static boolean isNamedEntity(final String name) {\n+        return extended.codepointForName(name) != empty;\n     }\n \n     /**\n      * Check if the input is a known named entity in the base entity set.\n+     *\n      * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity in the base set\n      * @see #isNamedEntity(String)\n      */\n-    public static boolean isBaseNamedEntity(String name) {\n-        return base.containsKey(name);\n+    public static boolean isBaseNamedEntity(final String name) {\n+        return base.codepointForName(name) != empty;\n     }\n \n     /**\n      * Get the Character value of the named entity\n+     *\n      * @param name named entity (e.g. \"lt\" or \"amp\")\n      * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n+     * @deprecated does not support characters outside the BMP or multiple character names\n      */\n     public static Character getCharacterByName(String name) {\n-        return full.get(name);\n-    }\n-    \n+        return (char) extended.codepointForName(name);\n+    }\n+\n+    /**\n+     * Get the character(s) represented by the named entity\n+     *\n+     * @param name entity (e.g. \"lt\" or \"amp\")\n+     * @return the string value of the character(s) represented by this entity, or \"\" if not defined\n+     */\n+    public static String getByName(String name) {\n+        String val = multipoints.get(name);\n+        if (val != null)\n+            return val;\n+        int codepoint = extended.codepointForName(name);\n+        if (codepoint != empty)\n+            return new String(new int[]{codepoint}, 0, 1);\n+        return emptyName;\n+    }\n+\n+    public static int codepointsForName(final String name, final int[] codepoints) {\n+        String val = multipoints.get(name);\n+        if (val != null) {\n+            codepoints[0] = val.codePointAt(0);\n+            codepoints[1] = val.codePointAt(1);\n+            return 2;\n+        }\n+        int codepoint = extended.codepointForName(name);\n+        if (codepoint != empty) {\n+            codepoints[0] = codepoint;\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n     static String escape(String string, Document.OutputSettings out) {\n         StringBuilder accum = new StringBuilder(string.length() * 2);\n-        escape(accum, string, out, false, false, false);\n+        try {\n+            escape(accum, string, out, false, false, false);\n+        } catch (IOException e) {\n+            throw new SerializationException(e); // doesn't happen\n+        }\n         return accum.toString();\n     }\n \n     // this method is ugly, and does a lot. but other breakups cause rescanning and stringbuilder generations\n-    static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n-                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n+    static void escape(Appendable accum, String string, Document.OutputSettings out,\n+                       boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n \n         boolean lastWasWhite = false;\n         boolean reachedNonWhite = false;\n         final EscapeMode escapeMode = out.escapeMode();\n         final CharsetEncoder encoder = out.encoder();\n         final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n-        final Map<Character, String> map = escapeMode.getMap();\n         final int length = string.length();\n \n         int codePoint;\n                     default:\n                         if (canEncode(coreCharset, c, encoder))\n                             accum.append(c);\n-                        else if (map.containsKey(c))\n-                            accum.append('&').append(map.get(c)).append(';');\n-                        else\n-                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+                        else\n+                            appendEncoded(accum, escapeMode, codePoint);\n                 }\n             } else {\n                 final String c = new String(Character.toChars(codePoint));\n                 if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                     accum.append(c);\n                 else\n-                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n-            }\n-        }\n+                    appendEncoded(accum, escapeMode, codePoint);\n+            }\n+        }\n+    }\n+\n+    private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint) throws IOException {\n+        final String name = escapeMode.nameForCodepoint(codePoint);\n+        if (name != emptyName) // ok for identity check\n+            accum.append('&').append(name).append(';');\n+        else\n+            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n     }\n \n     static String unescape(String string) {\n \n     /**\n      * Unescape the input string.\n+     *\n      * @param string to un-HTML-escape\n      * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n      * @return unescaped string\n      * Alterslash: 3013, 28\n      * Jsoup: 167, 2\n      */\n-\n     private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n         // todo add more charset tests if impacted by Android's bad perf in canEncode\n         switch (charset) {\n         }\n     }\n \n-\n-    // xhtml has restricted entities\n-    private static final Object[][] xhtmlArray = {\n-            {\"quot\", 0x00022},\n-            {\"amp\", 0x00026},\n-            {\"lt\", 0x0003C},\n-            {\"gt\", 0x0003E}\n-    };\n-\n-    static {\n-        xhtmlByVal = new HashMap<Character, String>();\n-        base = loadEntities(\"entities-base.properties\");  // most common / default\n-        baseByVal = toCharacterKey(base);\n-        full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n-        fullByVal = toCharacterKey(full);\n-\n-        for (Object[] entity : xhtmlArray) {\n-            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n-            xhtmlByVal.put(c, ((String) entity[0]));\n-        }\n-    }\n-\n-    private static Map<String, Character> loadEntities(String filename) {\n-        Properties properties = new Properties();\n-        Map<String, Character> entities = new HashMap<String, Character>();\n-        try {\n-            InputStream in = Entities.class.getResourceAsStream(filename);\n-            properties.load(in);\n-            in.close();\n-        } catch (IOException e) {\n-            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n-        }\n-\n-        for (Map.Entry entry: properties.entrySet()) {\n-            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n-            String name = (String) entry.getKey();\n-            entities.put(name, val);\n-        }\n-        return entities;\n-    }\n-\n-    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n-        Map<Character, String> outMap = new HashMap<Character, String>();\n-        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n-            Character character = entry.getValue();\n-            String name = entry.getKey();\n-\n-            if (outMap.containsKey(character)) {\n-                // dupe, prefer the lower case version\n-                if (name.toLowerCase().equals(name))\n-                    outMap.put(character, name);\n+    private static final char[] codeDelims = {',', ';'};\n+\n+    private static void load(EscapeMode e, String file, int size) {\n+        e.nameKeys = new String[size];\n+        e.codeVals = new int[size];\n+        e.codeKeys = new int[size];\n+        e.nameVals = new String[size];\n+\n+        InputStream stream = Entities.class.getResourceAsStream(file);\n+        if (stream == null)\n+            throw new IllegalStateException(\"Could not read resource \" + file + \". Make sure you copy resources for \" + Entities.class.getCanonicalName());\n+\n+        int i = 0;\n+        BufferedReader input = new BufferedReader(new InputStreamReader(stream, ASCII));\n+        CharacterReader reader = new CharacterReader(input);\n+\n+        while (!reader.isEmpty()) {\n+            // NotNestedLessLess=10913,824;1887\n+\n+            final String name = reader.consumeTo('=');\n+            reader.advance();\n+            final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n+            final char codeDelim = reader.current();\n+            reader.advance();\n+            final int cp2;\n+            if (codeDelim == ',') {\n+                cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n+                reader.advance();\n             } else {\n-                outMap.put(character, name);\n-            }\n-        }\n-        return outMap;\n+                cp2 = empty;\n+            }\n+            String indexS = reader.consumeTo('\\n');\n+            // default git checkout on windows will add a \\r there, so remove\n+            if (indexS.charAt(indexS.length() - 1) == '\\r') {\n+                indexS = indexS.substring(0, indexS.length() - 1);\n+            }\n+            final int index = Integer.parseInt(indexS, codepointRadix);\n+            reader.advance();\n+\n+            e.nameKeys[i] = name;\n+            e.codeVals[i] = cp1;\n+            e.codeKeys[index] = cp1;\n+            e.nameVals[index] = name;\n+\n+            if (cp2 != empty) {\n+                multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n+            }\n+            i++;\n+        }\n+        Validate.isTrue(i == size, \"Unexpected count of entities loaded for \" + file);\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n      * @return a list of key vals\n      */\n     public List<Connection.KeyVal> formData() {\n-        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n+        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n \n         // iterate the form control elements and accumulate their values\n         for (Element el: elements) {\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n+import org.jsoup.SerializationException;\n+import org.jsoup.helper.ChangeNotifyingArrayList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.Parser;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n-import java.net.MalformedURLException;\n-import java.net.URL;\n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n     public abstract String nodeName();\n \n     /**\n-     * Get an attribute's value by its key.\n+     * Get an attribute's value by its key. <b>Case insensitive</b>\n      * <p>\n      * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n      * which is a shortcut to the {@link #absUrl} method.\n     public String attr(String attributeKey) {\n         Validate.notNull(attributeKey);\n \n-        if (attributes.hasKey(attributeKey))\n-            return attributes.get(attributeKey);\n-        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n+        String val = attributes.getIgnoreCase(attributeKey);\n+        if (val.length() > 0)\n+            return val;\n+        else if (lowerCase(attributeKey).startsWith(\"abs:\"))\n             return absUrl(attributeKey.substring(\"abs:\".length()));\n         else return \"\";\n     }\n     }\n \n     /**\n-     * Set an attribute (key=value). If the attribute already exists, it is replaced.\n+     * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is\n+     * <b>case insensitive</b>.\n      * @param attributeKey The attribute key.\n      * @param attributeValue The attribute value.\n      * @return this (for chaining)\n      */\n     public Node attr(String attributeKey, String attributeValue) {\n-        attributes.put(attributeKey, attributeValue);\n-        return this;\n-    }\n-\n-    /**\n-     * Test if this element has an attribute.\n+        attributes.putIgnoreCase(attributeKey, attributeValue);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if this element has an attribute. <b>Case insensitive</b>\n      * @param attributeKey The attribute key to check.\n      * @return true if the attribute exists, false if not.\n      */\n \n         if (attributeKey.startsWith(\"abs:\")) {\n             String key = attributeKey.substring(\"abs:\".length());\n-            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n+            if (attributes.hasKeyIgnoreCase(key) && !absUrl(key).equals(\"\"))\n                 return true;\n         }\n-        return attributes.hasKey(attributeKey);\n+        return attributes.hasKeyIgnoreCase(attributeKey);\n     }\n \n     /**\n      */\n     public Node removeAttr(String attributeKey) {\n         Validate.notNull(attributeKey);\n-        attributes.remove(attributeKey);\n+        attributes.removeIgnoreCase(attributeKey);\n+        return this;\n+    }\n+\n+    /**\n+     * Clear (remove) all of the attributes in this node.\n+     * @return this, for chaining\n+     */\n+    public Node clearAttributes() {\n+        Iterator<Attribute> it = attributes.iterator();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n         return this;\n     }\n \n      * @return a deep copy of this node's children\n      */\n     public List<Node> childNodesCopy() {\n-        List<Node> children = new ArrayList<Node>(childNodes.size());\n+        List<Node> children = new ArrayList<>(childNodes.size());\n         for (Node node : childNodes) {\n             children.add(node.clone());\n         }\n     }\n \n     /**\n-     Gets this node's parent node. Node overridable by extending classes, so useful if you really just need the Node type.\n+     Gets this node's parent node. Not overridable by extending classes, so useful if you really just need the Node type.\n      @return parent node; or null if no parent.\n      */\n     public final Node parentNode() {\n         return parentNode;\n     }\n+\n+    /**\n+     * Get this node's root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.\n+     * @return topmost ancestor.\n+     */\n+    public Node root() {\n+        Node node = this;\n+        while (node.parentNode != null)\n+            node = node.parentNode;\n+        return node;\n+    }\n     \n     /**\n      * Gets the Document associated with this Node. \n      * @return the Document associated with this Node, or null if there is no such Document.\n      */\n     public Document ownerDocument() {\n-        if (this instanceof Document)\n-            return (Document) this;\n-        else if (parentNode == null)\n-            return null;\n-        else\n-            return parentNode.ownerDocument();\n+        Node root = root();\n+        return (root instanceof Document) ? (Document) root : null;\n     }\n     \n     /**\n \n         // remainder (unbalanced wrap, like <div></div><p></p> -- The <p> is remainder\n         if (wrapChildren.size() > 0) {\n+            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n             for (int i = 0; i < wrapChildren.size(); i++) {\n                 Node remainder = wrapChildren.get(i);\n                 remainder.parentNode.removeChild(remainder);\n         else\n             return el;\n     }\n+\n+    void nodelistChanged() {\n+        // Element overrides this to clear its shadow children elements\n+    }\n     \n     /**\n      * Replace this node in the DOM with the supplied node.\n     }\n \n     protected void setParentNode(Node parentNode) {\n+        Validate.notNull(parentNode);\n         if (this.parentNode != null)\n             this.parentNode.removeChild(this);\n         this.parentNode = parentNode;\n \n     protected void addChildren(int index, Node... children) {\n         Validate.noNullElements(children);\n+        ensureChildNodes();\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n-            ensureChildNodes();\n             childNodes.add(index, in);\n-        }\n-        reindexChildren(index);\n+            reindexChildren(index);\n+        }\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n-            childNodes = new ArrayList<Node>(4);\n+            childNodes = new NodeList(4);\n         }\n     }\n \n             return Collections.emptyList();\n \n         List<Node> nodes = parentNode.childNodes;\n-        List<Node> siblings = new ArrayList<Node>(nodes.size() - 1);\n+        List<Node> siblings = new ArrayList<>(nodes.size() - 1);\n         for (Node node: nodes)\n             if (node != this)\n                 siblings.add(node);\n         return accum.toString();\n     }\n \n-    protected void outerHtml(StringBuilder accum) {\n+    protected void outerHtml(Appendable accum) {\n         new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n     Document.OutputSettings getOutputSettings() {\n-        return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings();\n+        Document owner = ownerDocument();\n+        return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n     }\n \n     /**\n      Get the outer HTML of this node.\n      @param accum accumulator to place HTML into\n-     */\n-    abstract void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out);\n-\n-    abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n-\n-    @Override\n-    public String toString() {\n+     @throws IOException if appending to the given accumulator fails.\n+     */\n+    abstract void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n+\n+    abstract void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException;\n+\n+    /**\n+     * Write this node and its children to the given {@link Appendable}.\n+     *\n+     * @param appendable the {@link Appendable} to write to.\n+     * @return the supplied {@link Appendable}, for chaining.\n+     */\n+    public <T extends Appendable> T html(T appendable) {\n+        outerHtml(appendable);\n+        return appendable;\n+    }\n+    \n+\tpublic String toString() {\n         return outerHtml();\n     }\n \n-    protected void indent(StringBuilder accum, int depth, Document.OutputSettings out) {\n+    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n     }\n \n     /**\n-     * Check if this node is equal to another node. A node is considered equal if its attributes and content equal the\n-     * other node; particularly its position in the tree does not influence its equality.\n+     * Check if this node is the same instance of another (object identity test).\n      * @param o other object to compare to\n      * @return true if the content of this node is the same as the other\n+     * @see Node#hasSameValue(Object) to compare nodes by their value\n      */\n     @Override\n     public boolean equals(Object o) {\n+        // implemented just so that javadoc is clear this is an identity test\n+        return this == o;\n+    }\n+\n+    /**\n+     * Check if this node is has the same content as another node. A node is considered the same if its name, attributes and content match the\n+     * other node; particularly its position in the tree does not influence its similarity.\n+     * @param o other object to compare to\n+     * @return true if the content of this node is the same as the other\n+     */\n+\n+    public boolean hasSameValue(Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n \n-        Node node = (Node) o;\n-\n-        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n-        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n-    }\n-\n-    /**\n-     * Calculates a hash code for this node, which includes iterating all its attributes, and recursing into any child\n-     * nodes. This means that a node's hashcode is based on it and its child content, and not its parent or place in the\n-     * tree. So two nodes with the same content, regardless of their position in the tree, will have the same hashcode.\n-     * @return the calculated hashcode\n-     * @see Node#equals(Object)\n-     */\n-    @Override\n-    public int hashCode() {\n-        int result = childNodes != null ? childNodes.hashCode() : 0;\n-        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n-        return result;\n+        return this.outerHtml().equals(((Node) o).outerHtml());\n     }\n \n     /**\n         Node thisClone = doClone(null); // splits for orphan\n \n         // Queue up nodes that need their children cloned (BFS).\n-        LinkedList<Node> nodesToProcess = new LinkedList<Node>();\n+        LinkedList<Node> nodesToProcess = new LinkedList<>();\n         nodesToProcess.add(thisClone);\n \n         while (!nodesToProcess.isEmpty()) {\n         clone.siblingIndex = parent == null ? 0 : siblingIndex;\n         clone.attributes = attributes != null ? attributes.clone() : null;\n         clone.baseUri = baseUri;\n-        clone.childNodes = new ArrayList<Node>(childNodes.size());\n-\n-        for (Node child: childNodes)\n-            clone.childNodes.add(child);\n+        clone.childNodes = new NodeList(childNodes.size());\n+\n+        clone.childNodes.addAll(childNodes);\n \n         return clone;\n     }\n \n     private static class OuterHtmlVisitor implements NodeVisitor {\n-        private StringBuilder accum;\n+        private Appendable accum;\n         private Document.OutputSettings out;\n \n-        OuterHtmlVisitor(StringBuilder accum, Document.OutputSettings out) {\n+        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n             this.accum = accum;\n             this.out = out;\n         }\n \n         public void head(Node node, int depth) {\n-            node.outerHtmlHead(accum, depth, out);\n+            try {\n+\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n+\t\t\t} catch (IOException exception) {\n+\t\t\t\tthrow new SerializationException(exception);\n+\t\t\t}\n         }\n \n         public void tail(Node node, int depth) {\n-            if (!node.nodeName().equals(\"#text\")) // saves a void hit.\n-                node.outerHtmlTail(accum, depth, out);\n+            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n+\t\t\t\ttry {\n+\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n+\t\t\t\t} catch (IOException exception) {\n+\t\t\t\t\tthrow new SerializationException(exception);\n+\t\t\t\t}\n+            }\n+        }\n+    }\n+\n+    private final class NodeList extends ChangeNotifyingArrayList<Node> {\n+        NodeList(int initialCapacity) {\n+            super(initialCapacity);\n+        }\n+\n+        public void onContentsChanged() {\n+            nodelistChanged();\n         }\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n package org.jsoup.nodes;\n+\n+import java.io.IOException;\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n         this.text = text;\n     }\n \n-    public String nodeName() {\n+\tpublic String nodeName() {\n         return \"#text\";\n     }\n     \n         return tailNode;\n     }\n \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n         if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n             indent(accum, depth, out);\n \n         Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n         ensureAttributes();\n         return super.absUrl(attributeKey);\n     }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n-\n-        TextNode textNode = (TextNode) o;\n-\n-        return !(text != null ? !text.equals(textNode.text) : textNode.text != null);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = super.hashCode();\n-        result = 31 * result + (text != null ? text.hashCode() : 0);\n-        return result;\n-    }\n }\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n package org.jsoup.nodes;\n+\n+import org.jsoup.helper.Validate;\n+\n+import java.io.IOException;\n \n /**\n  An XML Declaration.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class XmlDeclaration extends Node {\n-    static final String DECL_KEY = \"declaration\";\n+    private final String name;\n     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n \n     /**\n      Create a new XML declaration\n-     @param data data\n+     @param name of declaration\n      @param baseUri base uri\n      @param isProcessingInstruction is processing instruction\n      */\n-    public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) {\n+    public XmlDeclaration(String name, String baseUri, boolean isProcessingInstruction) {\n         super(baseUri);\n-        attributes.put(DECL_KEY, data);\n+        Validate.notNull(name);\n+        this.name = name;\n         this.isProcessingInstruction = isProcessingInstruction;\n     }\n \n         return \"#declaration\";\n     }\n \n+\n+    /**\n+     * Get the name of this declaration.\n+     * @return name of this declaration.\n+     */\n+    public String name() {\n+        return name;\n+    }\n+\n     /**\n      Get the unencoded XML declaration.\n      @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        final String decl = attributes.get(DECL_KEY);\n-        \n-        if(decl.equals(\"xml\") && attributes.size() > 1 ) {\n-            StringBuilder sb = new StringBuilder(decl);\n-            final String version = attributes.get(\"version\");\n-            \n-            if( version != null ) {\n-                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n-            }\n-            \n-            final String encoding = attributes.get(\"encoding\");\n-            \n-            if( encoding != null ) {\n-                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n-            }\n-            \n-            return sb.toString();\n-        }\n-        else {\n-            return attributes.get(DECL_KEY);\n-        }\n-    }\n-    \n-    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        accum\n-                .append(\"<\")\n-                .append(isProcessingInstruction ? \"!\" : \"?\")\n-                .append(getWholeDeclaration())\n-                .append(\">\");\n+        return attributes.html().trim(); // attr html starts with a \" \"\n     }\n \n-    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n+\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+        accum\n+            .append(\"<\")\n+            .append(isProcessingInstruction ? \"!\" : \"?\")\n+            .append(name);\n+        attributes.html(accum, out);\n+        accum\n+            .append(isProcessingInstruction ? \"!\" : \"?\")\n+            .append(\">\");\n+    }\n+\n+\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n \n     @Override\n     public String toString() {\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n package org.jsoup.parser;\n \n+import org.jsoup.UncheckedIOException;\n import org.jsoup.helper.Validate;\n \n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.Arrays;\n import java.util.Locale;\n \n /**\n- CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n+ CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n  */\n-final class CharacterReader {\n+public final class CharacterReader {\n     static final char EOF = (char) -1;\n-    private static final int maxCacheLen = 12;\n-\n-    private final char[] input;\n-    private final int length;\n-    private int pos = 0;\n-    private int mark = 0;\n+    private static final int maxStringCacheLen = 12;\n+    private static final int maxBufferLen = 1024 * 32;\n+    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n+\n+    private final char[] charBuf;\n+    private final Reader reader;\n+    private int bufLength;\n+    private int bufSplitPoint;\n+    private int bufPos;\n+    private int readerPos;\n+    private int bufMark;\n     private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n-    CharacterReader(String input) {\n+    public CharacterReader(Reader input, int sz) {\n         Validate.notNull(input);\n-        this.input = input.toCharArray();\n-        this.length = this.input.length;\n-    }\n-\n-    int pos() {\n-        return pos;\n-    }\n-\n-    boolean isEmpty() {\n-        return pos >= length;\n-    }\n-\n-    char current() {\n-        return pos >= length ? EOF : input[pos];\n+        Validate.isTrue(input.markSupported());\n+        reader = input;\n+        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n+        bufferUp();\n+    }\n+\n+    public CharacterReader(Reader input) {\n+        this(input, maxBufferLen);\n+    }\n+\n+    public CharacterReader(String input) {\n+        this(new StringReader(input), input.length());\n+    }\n+\n+    private void bufferUp() {\n+        if (bufPos < bufSplitPoint)\n+            return;\n+\n+        try {\n+            readerPos += bufPos;\n+            reader.skip(bufPos);\n+            reader.mark(maxBufferLen);\n+            bufLength = reader.read(charBuf);\n+            reader.reset();\n+            bufPos = 0;\n+            bufMark = 0;\n+            bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the current cursor position in the content.\n+     * @return current position\n+     */\n+    public int pos() {\n+        return readerPos + bufPos;\n+    }\n+\n+    /**\n+     * Tests if all the content has been read.\n+     * @return true if nothing left to read.\n+     */\n+    public boolean isEmpty() {\n+        return bufPos >= bufLength;\n+    }\n+\n+    /**\n+     * Get the char at the current position.\n+     * @return char\n+     */\n+    public char current() {\n+        bufferUp();\n+        return isEmpty() ? EOF : charBuf[bufPos];\n     }\n \n     char consume() {\n-        char val = pos >= length ? EOF : input[pos];\n-        pos++;\n+        bufferUp();\n+        char val = isEmpty() ? EOF : charBuf[bufPos];\n+        bufPos++;\n         return val;\n     }\n \n     void unconsume() {\n-        pos--;\n-    }\n-\n-    void advance() {\n-        pos++;\n+        bufPos--;\n+    }\n+\n+    /**\n+     * Moves the current position by one.\n+     */\n+    public void advance() {\n+        bufPos++;\n     }\n \n     void mark() {\n-        mark = pos;\n+        bufMark = bufPos;\n     }\n \n     void rewindToMark() {\n-        pos = mark;\n-    }\n-\n-    String consumeAsString() {\n-        return new String(input, pos++, 1);\n+        bufPos = bufMark;\n     }\n \n     /**\n      */\n     int nextIndexOf(char c) {\n         // doesn't handle scanning for surrogates\n-        for (int i = pos; i < length; i++) {\n-            if (c == input[i])\n-                return i - pos;\n+        bufferUp();\n+        for (int i = bufPos; i < bufLength; i++) {\n+            if (c == charBuf[i])\n+                return i - bufPos;\n         }\n         return -1;\n     }\n      * @return offset between current position and next instance of target. -1 if not found.\n      */\n     int nextIndexOf(CharSequence seq) {\n+        bufferUp();\n         // doesn't handle scanning for surrogates\n         char startChar = seq.charAt(0);\n-        for (int offset = pos; offset < length; offset++) {\n+        for (int offset = bufPos; offset < bufLength; offset++) {\n             // scan to first instance of startchar:\n-            if (startChar != input[offset])\n-                while(++offset < length && startChar != input[offset]) { /* empty */ }\n+            if (startChar != charBuf[offset])\n+                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length && last <= length) {\n-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n+            if (offset < bufLength && last <= bufLength) {\n+                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                 if (i == last) // found full sequence\n-                    return offset - pos;\n+                    return offset - bufPos;\n             }\n         }\n         return -1;\n     }\n \n-    String consumeTo(char c) {\n+    /**\n+     * Reads characters up to the specific char.\n+     * @param c the delimiter\n+     * @return the chars read\n+     */\n+    public String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = cacheString(pos, offset);\n-            pos += offset;\n+            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n+            bufPos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = cacheString(pos, offset);\n-            pos += offset;\n+            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n+            bufPos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n         }\n     }\n \n-    String consumeToAny(final char... chars) {\n-        final int start = pos;\n-        final int remaining = length;\n-\n-        OUTER: while (pos < remaining) {\n+    /**\n+     * Read characters until the first of any delimiters is found.\n+     * @param chars delimiters to scan for\n+     * @return characters read up to the matched delimiter.\n+     */\n+    public String consumeToAny(final char... chars) {\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        OUTER: while (bufPos < remaining) {\n             for (char c : chars) {\n-                if (input[pos] == c)\n+                if (val[bufPos] == c)\n                     break OUTER;\n             }\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeToAnySorted(final char... chars) {\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        while (pos < remaining) {\n-            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n-                break;\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        while (bufPos < remaining) {\n+            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n+                break;\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeData() {\n         // &, <, null\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        while (pos < remaining) {\n-            final char c = val[pos];\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        while (bufPos < remaining) {\n+            final char c = val[bufPos];\n             if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                 break;\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeTagName() {\n         // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        while (pos < remaining) {\n-            final char c = val[pos];\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        while (bufPos < remaining) {\n+            final char c = val[bufPos];\n             if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                 break;\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = cacheString(pos, length-pos);\n-        pos = length;\n+        bufferUp();\n+        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n+        bufPos = bufLength;\n         return data;\n     }\n \n     String consumeLetterSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n-                pos++;\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n+                bufPos++;\n             else\n                 break;\n         }\n \n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n-                pos++;\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n+                bufPos++;\n             else\n                 break;\n         }\n         while (!isEmpty()) {\n-            char c = input[pos];\n+            char c = charBuf[bufPos];\n             if (c >= '0' && c <= '9')\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n \n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeHexSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeDigitSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if (c >= '0' && c <= '9')\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     boolean matches(char c) {\n-        return !isEmpty() && input[pos] == c;\n+        return !isEmpty() && charBuf[bufPos] == c;\n \n     }\n \n     boolean matches(String seq) {\n+        bufferUp();\n         int scanLength = seq.length();\n-        if (scanLength > length - pos)\n+        if (scanLength > bufLength - bufPos)\n             return false;\n \n         for (int offset = 0; offset < scanLength; offset++)\n-            if (seq.charAt(offset) != input[pos+offset])\n+            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                 return false;\n         return true;\n     }\n \n     boolean matchesIgnoreCase(String seq) {\n+        bufferUp();\n         int scanLength = seq.length();\n-        if (scanLength > length - pos)\n+        if (scanLength > bufLength - bufPos)\n             return false;\n \n         for (int offset = 0; offset < scanLength; offset++) {\n             char upScan = Character.toUpperCase(seq.charAt(offset));\n-            char upTarget = Character.toUpperCase(input[pos + offset]);\n+            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n             if (upScan != upTarget)\n                 return false;\n         }\n         if (isEmpty())\n             return false;\n \n-        char c = input[pos];\n+        bufferUp();\n+        char c = charBuf[bufPos];\n         for (char seek : seq) {\n             if (seek == c)\n                 return true;\n     }\n \n     boolean matchesAnySorted(char[] seq) {\n-        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+        bufferUp();\n+        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n     }\n \n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n-        char c = input[pos];\n-        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n+        char c = charBuf[bufPos];\n+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n     }\n \n     boolean matchesDigit() {\n         if (isEmpty())\n             return false;\n-        char c = input[pos];\n+        char c = charBuf[bufPos];\n         return (c >= '0' && c <= '9');\n     }\n \n     boolean matchConsume(String seq) {\n+        bufferUp();\n         if (matches(seq)) {\n-            pos += seq.length();\n+            bufPos += seq.length();\n             return true;\n         } else {\n             return false;\n \n     boolean matchConsumeIgnoreCase(String seq) {\n         if (matchesIgnoreCase(seq)) {\n-            pos += seq.length();\n+            bufPos += seq.length();\n             return true;\n         } else {\n             return false;\n \n     @Override\n     public String toString() {\n-        return new String(input, pos, length - pos);\n+        return new String(charBuf, bufPos, bufLength - bufPos);\n     }\n \n     /**\n      * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n      * some more duplicates.\n      */\n-    private String cacheString(final int start, final int count) {\n-        final char[] val = input;\n-        final String[] cache = stringCache;\n-\n+    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n         // limit (no cache):\n-        if (count > maxCacheLen)\n-            return new String(val, start, count);\n+        if (count > maxStringCacheLen)\n+            return new String(charBuf, start, count);\n \n         // calculate hash:\n         int hash = 0;\n         int offset = start;\n         for (int i = 0; i < count; i++) {\n-            hash = 31 * hash + val[offset++];\n+            hash = 31 * hash + charBuf[offset++];\n         }\n \n         // get from cache\n-        final int index = hash & cache.length - 1;\n-        String cached = cache[index];\n+        final int index = hash & stringCache.length - 1;\n+        String cached = stringCache[index];\n \n         if (cached == null) { // miss, add\n-            cached = new String(val, start, count);\n-            cache[index] = cached;\n+            cached = new String(charBuf, start, count);\n+            stringCache[index] = cached;\n         } else { // hashcode hit, check equality\n-            if (rangeEquals(start, count, cached)) {\n-                // hit\n+            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                 return cached;\n             } else { // hashcode conflict\n-                cached = new String(val, start, count);\n+                cached = new String(charBuf, start, count);\n+                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n             }\n         }\n         return cached;\n     /**\n      * Check if the value of the provided range equals the string.\n      */\n-    boolean rangeEquals(final int start, int count, final String cached) {\n+    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n         if (count == cached.length()) {\n-            char one[] = input;\n             int i = start;\n             int j = 0;\n             while (count-- != 0) {\n-                if (one[i++] != cached.charAt(j++))\n+                if (charBuf[i++] != cached.charAt(j++))\n                     return false;\n             }\n             return true;\n         }\n         return false;\n     }\n+\n+    // just used for testing\n+    boolean rangeEquals(final int start, final int count, final String cached) {\n+        return rangeEquals(charBuf, start, count, cached);\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n+import org.jsoup.nodes.Comment;\n+import org.jsoup.nodes.DataNode;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.FormElement;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n import org.jsoup.select.Elements;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.List;\n \n  */\n public class HtmlTreeBuilder extends TreeBuilder {\n     // tag searches\n-    private static final String[] TagsScriptStyle = new String[]{\"script\", \"style\"};\n-    public static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n+    private static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"};\n     private static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n     private static final String[] TagSearchButton = new String[]{\"button\"};\n     private static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n     private HtmlTreeBuilderState state; // the current state\n     private HtmlTreeBuilderState originalState; // original / marked state\n \n-    private boolean baseUriSetFromDoc = false;\n+    private boolean baseUriSetFromDoc;\n     private Element headElement; // the current head element\n     private FormElement formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\n-    private List<String> pendingTableCharacters = new ArrayList<String>(); // chars in table to be shifted out\n-    private Token.EndTag emptyEnd = new Token.EndTag(); // reused empty end tag\n-\n-    private boolean framesetOk = true; // if ok to go into frameset\n-    private boolean fosterInserts = false; // if next inserts should be fostered\n-    private boolean fragmentParsing = false; // if parsing a fragment of html\n+    private ArrayList<Element> formattingElements; // active (open) formatting elements\n+    private List<String> pendingTableCharacters; // chars in table to be shifted out\n+    private Token.EndTag emptyEnd; // reused empty end tag\n+\n+    private boolean framesetOk; // if ok to go into frameset\n+    private boolean fosterInserts; // if next inserts should be fostered\n+    private boolean fragmentParsing; // if parsing a fragment of html\n \n     HtmlTreeBuilder() {}\n \n+    ParseSettings defaultSettings() {\n+        return ParseSettings.htmlDefault;\n+    }\n+\n     @Override\n-    Document parse(String input, String baseUri, ParseErrorList errors) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        super.initialiseParse(input, baseUri, errors, settings);\n+\n+        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n         state = HtmlTreeBuilderState.Initial;\n+        originalState = null;\n         baseUriSetFromDoc = false;\n-        return super.parse(input, baseUri, errors);\n-    }\n-\n-    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n+        headElement = null;\n+        formElement = null;\n+        contextElement = null;\n+        formattingElements = new ArrayList<>();\n+        pendingTableCharacters = new ArrayList<>();\n+        emptyEnd = new Token.EndTag();\n+        framesetOk = true;\n+        fosterInserts = false;\n+        fragmentParsing = false;\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         // context may be null\n         state = HtmlTreeBuilderState.Initial;\n-        initialiseParse(inputFragment, baseUri, errors);\n+        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\n             else\n                 tokeniser.transition(TokeniserState.Data); // default\n \n-            root = new Element(Tag.valueOf(\"html\"), baseUri);\n+            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n             doc.appendChild(root);\n             stack.add(root);\n             resetInsertionMode();\n         }\n \n         runParser();\n-        if (context != null && root != null)\n+        if (context != null)\n             return root.childNodes();\n         else\n             return doc.childNodes();\n             return el;\n         }\n         \n-        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n+        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n         insert(el);\n         return el;\n     }\n \n     Element insertStartTag(String startTagName) {\n-        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n+        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n         insert(el);\n         return el;\n     }\n     }\n \n     Element insertEmpty(Token.StartTag startTag) {\n-        Tag tag = Tag.valueOf(startTag.name());\n+        Tag tag = Tag.valueOf(startTag.name(), settings);\n         Element el = new Element(tag, baseUri, startTag.attributes);\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n             if (tag.isKnownTag()) {\n-                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n-            } else {\n-                // unknown tag, remember this is self closing for output\n+                if (!tag.isEmpty())\n+                    tokeniser.error(\"Tag cannot be self closing; not a void tag\");\n+            }\n+            else // unknown tag, remember this is self closing for output\n                 tag.setSelfClosing();\n-                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n-            }\n         }\n         return el;\n     }\n \n     FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n-        Tag tag = Tag.valueOf(startTag.name());\n+        Tag tag = Tag.valueOf(startTag.name(), settings);\n         FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n         setFormElement(el);\n         insertNode(el);\n     }\n \n     void newPendingTableCharacters() {\n-        pendingTableCharacters = new ArrayList<String>();\n+        pendingTableCharacters = new ArrayList<>();\n     }\n \n     List<String> getPendingTableCharacters() {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 // todo: parse error check on expected doctypes\n                 // todo: quirk state check on doctype ids\n                 Token.Doctype d = t.asDoctype();\n-                DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n+                DocumentType doctype = new DocumentType(\n+                    tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n                 tb.getDocument().appendChild(doctype);\n                 if (d.isForceQuirks())\n                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                 tb.insert(t.asComment());\n             } else if (isWhitespace(t)) {\n                 return true; // ignore whitespace\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 tb.insert(t.asStartTag());\n                 tb.transition(BeforeHead);\n-            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                 return anythingElse(t, tb);\n             } else if (t.isEndTag()) {\n                 tb.error(this);\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return InBody.process(t, tb); // does not transition\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                 Element head = tb.insert(t.asStartTag());\n                 tb.setHeadElement(head);\n                 tb.transition(InHead);\n-            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                 tb.processStartTag(\"head\");\n                 return tb.process(t);\n             } else if (t.isEndTag()) {\n                     return false;\n                 case StartTag:\n                     Token.StartTag start = t.asStartTag();\n-                    String name = start.name();\n+                    String name = start.normalName();\n                     if (name.equals(\"html\")) {\n                         return InBody.process(t, tb);\n                     } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                     break;\n                 case EndTag:\n                     Token.EndTag end = t.asEndTag();\n-                    name = end.name();\n+                    name = end.normalName();\n                     if (name.equals(\"head\")) {\n                         tb.pop();\n                         tb.transition(AfterHead);\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isDoctype()) {\n                 tb.error(this);\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return tb.process(t, InBody);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"noscript\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                 tb.pop();\n                 tb.transition(InHead);\n-            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                     \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                 return tb.process(t, InHead);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"br\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                 return anythingElse(t, tb);\n-            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"head\", \"noscript\")) || t.isEndTag()) {\n+            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                 tb.error(this);\n                 return false;\n             } else {\n                 tb.error(this);\n             } else if (t.isStartTag()) {\n                 Token.StartTag startTag = t.asStartTag();\n-                String name = startTag.name();\n+                String name = startTag.normalName();\n                 if (name.equals(\"html\")) {\n                     return tb.process(t, InBody);\n                 } else if (name.equals(\"body\")) {\n                     anythingElse(t, tb);\n                 }\n             } else if (t.isEndTag()) {\n-                if (StringUtil.in(t.asEndTag().name(), \"body\", \"html\")) {\n+                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                     anythingElse(t, tb);\n                 } else {\n                     tb.error(this);\n                 }\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.name();\n+                    // todo - refactor to a switch statement\n+                    String name = startTag.normalName();\n                     if (name.equals(\"a\")) {\n                         if (tb.getActiveFormattingElement(\"a\") != null) {\n                             tb.error(this);\n                         if (tb.getFormElement() != null)\n                             return false;\n \n-                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                         tb.processStartTag(\"form\");\n                         if (startTag.attributes.hasKey(\"action\")) {\n                             Element form = tb.getFormElement();\n                         tb.reconstructFormattingElements();\n                         // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                         tb.insert(startTag);\n-                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                     } else if (name.equals(\"svg\")) {\n                         tb.reconstructFormattingElements();\n                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                         tb.insert(startTag);\n-                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                     } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                         tb.error(this);\n                         return false;\n \n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.name();\n+                    name = endTag.normalName();\n                     if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                         // Adoption Agency Algorithm.\n                         for (int i = 0; i < 8; i++) {\n                                 } else if (node == formatEl)\n                                     break;\n \n-                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n+                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n+                                // case will follow the original node (so honours ParseSettings)\n                                 tb.replaceActiveFormattingElement(node, replacement);\n                                 tb.replaceOnStack(node, replacement);\n                                 node = replacement;\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().name();\n+            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);\n                 return false;\n             } else if (t.isStartTag()) {\n                 Token.StartTag startTag = t.asStartTag();\n-                String name = startTag.name();\n+                String name = startTag.normalName();\n                 if (name.equals(\"caption\")) {\n                     tb.clearStackToTableContext();\n                     tb.insertMarkerToFormattingElements();\n                 return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable\n             } else if (t.isEndTag()) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n \n                 if (name.equals(\"table\")) {\n                     if (!tb.inTableScope(name)) {\n     },\n     InCaption {\n         boolean process(Token t, HtmlTreeBuilder tb) {\n-            if (t.isEndTag() && t.asEndTag().name().equals(\"caption\")) {\n+            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n                 if (!tb.inTableScope(name)) {\n                     tb.error(this);\n                     return false;\n                     tb.transition(InTable);\n                 }\n             } else if ((\n-                    t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                             \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n-                            t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n+                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                     ) {\n                 tb.error(this);\n                 boolean processed = tb.processEndTag(\"caption\");\n                 if (processed)\n                     return tb.process(t);\n-            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                     \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                 tb.error(this);\n                 return false;\n                     break;\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.name();\n-                    if (name.equals(\"html\"))\n-                        return tb.process(t, InBody);\n-                    else if (name.equals(\"col\"))\n-                        tb.insertEmpty(startTag);\n-                    else\n-                        return anythingElse(t, tb);\n+                    switch (startTag.normalName()) {\n+                        case \"html\":\n+                            return tb.process(t, InBody);\n+                        case \"col\":\n+                            tb.insertEmpty(startTag);\n+                            break;\n+                        default:\n+                            return anythingElse(t, tb);\n+                    }\n                     break;\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.name();\n-                    if (name.equals(\"colgroup\")) {\n+                    if (endTag.normalName.equals(\"colgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"html\")) { // frag case\n                             tb.error(this);\n                             return false;\n             switch (t.type) {\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.name();\n+                    String name = startTag.normalName();\n                     if (name.equals(\"tr\")) {\n                         tb.clearStackToTableBodyContext();\n                         tb.insert(startTag);\n                     break;\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.name();\n+                    name = endTag.normalName();\n                     if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                         if (!tb.inTableScope(name)) {\n                             tb.error(this);\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isStartTag()) {\n                 Token.StartTag startTag = t.asStartTag();\n-                String name = startTag.name();\n+                String name = startTag.normalName();\n \n                 if (StringUtil.in(name, \"th\", \"td\")) {\n                     tb.clearStackToTableRowContext();\n                 }\n             } else if (t.isEndTag()) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n \n                 if (name.equals(\"tr\")) {\n                     if (!tb.inTableScope(name)) {\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isEndTag()) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n \n                 if (StringUtil.in(name, \"td\", \"th\")) {\n                     if (!tb.inTableScope(name)) {\n                     return anythingElse(t, tb);\n                 }\n             } else if (t.isStartTag() &&\n-                    StringUtil.in(t.asStartTag().name(),\n+                    StringUtil.in(t.asStartTag().normalName(),\n                             \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                 if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                     tb.error(this);\n                     return false;\n                 case StartTag:\n                     Token.StartTag start = t.asStartTag();\n-                    String name = start.name();\n+                    String name = start.normalName();\n                     if (name.equals(\"html\"))\n                         return tb.process(start, InBody);\n                     else if (name.equals(\"option\")) {\n-                        tb.processEndTag(\"option\");\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.processEndTag(\"option\");\n                         tb.insert(start);\n                     } else if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n                     break;\n                 case EndTag:\n                     Token.EndTag end = t.asEndTag();\n-                    name = end.name();\n-                    if (name.equals(\"optgroup\")) {\n-                        if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n-                            tb.processEndTag(\"option\");\n-                        if (tb.currentElement().nodeName().equals(\"optgroup\"))\n-                            tb.pop();\n-                        else\n-                            tb.error(this);\n-                    } else if (name.equals(\"option\")) {\n-                        if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.pop();\n-                        else\n-                            tb.error(this);\n-                    } else if (name.equals(\"select\")) {\n-                        if (!tb.inSelectScope(name)) {\n-                            tb.error(this);\n-                            return false;\n-                        } else {\n-                            tb.popStackToClose(name);\n-                            tb.resetInsertionMode();\n-                        }\n-                    } else\n-                        return anythingElse(t, tb);\n+                    name = end.normalName();\n+                    switch (name) {\n+                        case \"optgroup\":\n+                            if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n+                                tb.processEndTag(\"option\");\n+                            if (tb.currentElement().nodeName().equals(\"optgroup\"))\n+                                tb.pop();\n+                            else\n+                                tb.error(this);\n+                            break;\n+                        case \"option\":\n+                            if (tb.currentElement().nodeName().equals(\"option\"))\n+                                tb.pop();\n+                            else\n+                                tb.error(this);\n+                            break;\n+                        case \"select\":\n+                            if (!tb.inSelectScope(name)) {\n+                                tb.error(this);\n+                                return false;\n+                            } else {\n+                                tb.popStackToClose(name);\n+                                tb.resetInsertionMode();\n+                            }\n+                            break;\n+                        default:\n+                            return anythingElse(t, tb);\n+                    }\n                     break;\n                 case EOF:\n                     if (!tb.currentElement().nodeName().equals(\"html\"))\n     },\n     InSelectInTable {\n         boolean process(Token t, HtmlTreeBuilder tb) {\n-            if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n                 tb.processEndTag(\"select\");\n                 return tb.process(t);\n-            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n-                tb.error(this);\n-                if (tb.inTableScope(t.asEndTag().name())) {\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+                tb.error(this);\n+                if (tb.inTableScope(t.asEndTag().normalName())) {\n                     tb.processEndTag(\"select\");\n                     return (tb.process(t));\n                 } else\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return tb.process(t, InBody);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                 if (tb.isFragmentParsing()) {\n                     tb.error(this);\n                     return false;\n                 return false;\n             } else if (t.isStartTag()) {\n                 Token.StartTag start = t.asStartTag();\n-                String name = start.name();\n-                if (name.equals(\"html\")) {\n-                    return tb.process(start, InBody);\n-                } else if (name.equals(\"frameset\")) {\n-                    tb.insert(start);\n-                } else if (name.equals(\"frame\")) {\n-                    tb.insertEmpty(start);\n-                } else if (name.equals(\"noframes\")) {\n-                    return tb.process(start, InHead);\n-                } else {\n-                    tb.error(this);\n-                    return false;\n-                }\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"frameset\")) {\n+                switch (start.normalName()) {\n+                    case \"html\":\n+                        return tb.process(start, InBody);\n+                    case \"frameset\":\n+                        tb.insert(start);\n+                        break;\n+                    case \"frame\":\n+                        tb.insertEmpty(start);\n+                        break;\n+                    case \"noframes\":\n+                        return tb.process(start, InHead);\n+                    default:\n+                        tb.error(this);\n+                        return false;\n+                }\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                 if (tb.currentElement().nodeName().equals(\"html\")) { // frag\n                     tb.error(this);\n                     return false;\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return tb.process(t, InBody);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                 tb.transition(AfterAfterFrameset);\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"noframes\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                 return tb.process(t, InHead);\n             } else if (t.isEOF()) {\n                 // cool your heels, we're complete\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isComment()) {\n                 tb.insert(t.asComment());\n-            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                 return tb.process(t, InBody);\n             } else if (t.isEOF()) {\n                 // nice work chuck\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isComment()) {\n                 tb.insert(t.asComment());\n-            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                 return tb.process(t, InBody);\n             } else if (t.isEOF()) {\n                 // nice work chuck\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"noframes\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                 return tb.process(t, InHead);\n             } else {\n                 tb.error(this);\n     }\n \n     private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n-        tb.insert(startTag);\n         tb.tokeniser.transition(TokeniserState.Rcdata);\n         tb.markInsertionMode();\n         tb.transition(Text);\n+        tb.insert(startTag);\n     }\n \n     private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n-        tb.insert(startTag);\n         tb.tokeniser.transition(TokeniserState.Rawtext);\n         tb.markInsertionMode();\n         tb.transition(Text);\n+        tb.insert(startTag);\n     }\n \n     // lists of tags to search through. A little harder to read here, but causes less GC than dynamic varargs.\n--- a/src/main/java/org/jsoup/parser/ParseErrorList.java\n+++ b/src/main/java/org/jsoup/parser/ParseErrorList.java\n  * \n  * @author Jonathan Hedley\n  */\n-class ParseErrorList extends ArrayList<ParseError>{\n+public class ParseErrorList extends ArrayList<ParseError>{\n     private static final int INITIAL_CAPACITY = 16;\n     private final int maxSize;\n     \n         return maxSize;\n     }\n \n-    static ParseErrorList noTracking() {\n+    public static ParseErrorList noTracking() {\n         return new ParseErrorList(0, 0);\n     }\n     \n-    static ParseErrorList tracking(int maxSize) {\n+    public static ParseErrorList tracking(int maxSize) {\n         return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/ParseSettings.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n+\n+/**\n+ * Controls parser settings, to optionally preserve tag and/or attribute name case.\n+ */\n+public class ParseSettings {\n+    /**\n+     * HTML default settings: both tag and attribute names are lower-cased during parsing.\n+     */\n+    public static final ParseSettings htmlDefault;\n+    /**\n+     * Preserve both tag and attribute case.\n+     */\n+    public static final ParseSettings preserveCase;\n+\n+    static {\n+        htmlDefault = new ParseSettings(false, false);\n+        preserveCase = new ParseSettings(true, true);\n+    }\n+\n+    private final boolean preserveTagCase;\n+    private final boolean preserveAttributeCase;\n+\n+    /**\n+     * Define parse settings.\n+     * @param tag preserve tag case?\n+     * @param attribute preserve attribute name case?\n+     */\n+    public ParseSettings(boolean tag, boolean attribute) {\n+        preserveTagCase = tag;\n+        preserveAttributeCase = attribute;\n+    }\n+\n+    String normalizeTag(String name) {\n+        name = name.trim();\n+        if (!preserveTagCase)\n+            name = lowerCase(name);\n+        return name;\n+    }\n+\n+    String normalizeAttribute(String name) {\n+        name = name.trim();\n+        if (!preserveAttributeCase)\n+            name = lowerCase(name);\n+        return name;\n+    }\n+\n+    Attributes normalizeAttributes(Attributes attributes) {\n+        if (!preserveAttributeCase) {\n+            for (Attribute attr : attributes) {\n+                attr.setKey(lowerCase(attr.getKey()));\n+            }\n+        }\n+        return attributes;\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n \n /**\n     private TreeBuilder treeBuilder;\n     private int maxErrors = DEFAULT_MAX_ERRORS;\n     private ParseErrorList errors;\n+    private ParseSettings settings;\n \n     /**\n      * Create a new Parser, using the specified TreeBuilder\n      */\n     public Parser(TreeBuilder treeBuilder) {\n         this.treeBuilder = treeBuilder;\n+        settings = treeBuilder.defaultSettings();\n     }\n     \n     public Document parseInput(String html, String baseUri) {\n         errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        return treeBuilder.parse(html, baseUri, errors);\n+        return treeBuilder.parse(new StringReader(html), baseUri, errors, settings);\n+    }\n+\n+    public Document parseInput(Reader inputHtml, String baseUri) {\n+        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n+        return treeBuilder.parse(inputHtml, baseUri, errors, settings);\n     }\n \n     // gets & sets\n         return errors;\n     }\n \n+    public Parser settings(ParseSettings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    public ParseSettings settings() {\n+        return settings;\n+    }\n+\n     // static parse functions below\n     /**\n      * Parse HTML into a Document.\n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking());\n+        return treeBuilder.parse(new StringReader(html), baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking());\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+    }\n+\n+    /**\n+     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n+     *\n+     * @param fragmentHtml the fragment of HTML to parse\n+     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n+     * provides stack context (for implicit element creation).\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     * @param errorList list to add errors to\n+     *\n+     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n+     */\n+    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n+        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n     }\n \n     /**\n      */\n     public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n         XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking());\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Tag {\n-    private static final Map<String, Tag> tags = new HashMap<String, Tag>(); // map of known tags\n+    private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags\n \n     private String tagName;\n     private boolean isBlock = true; // block or inline\n     private boolean formatAsBlock = true; // should be formatted as a block\n-    private boolean canContainBlock = true; // Can this tag hold block level tags?\n     private boolean canContainInline = true; // only pcdata if not\n     private boolean empty = false; // can hold nothing; e.g. img\n     private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\n     private boolean formSubmit = false; // a control that can be submitted in a form: input etc\n \n     private Tag(String tagName) {\n-        this.tagName = tagName.toLowerCase();\n+        this.tagName = tagName;\n     }\n \n     /**\n      * </p>\n      * \n      * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n+     * @param settings used to control tag name sensitivity\n      * @return The tag, either defined or new generic.\n      */\n-    public static Tag valueOf(String tagName) {\n+    public static Tag valueOf(String tagName, ParseSettings settings) {\n         Validate.notNull(tagName);\n         Tag tag = tags.get(tagName);\n \n         if (tag == null) {\n-            tagName = tagName.trim().toLowerCase();\n+            tagName = settings.normalizeTag(tagName);\n             Validate.notEmpty(tagName);\n             tag = tags.get(tagName);\n \n                 // not defined: create default; go anywhere, do anything! (incl be inside a <p>)\n                 tag = new Tag(tagName);\n                 tag.isBlock = false;\n-                tag.canContainBlock = true;\n             }\n         }\n         return tag;\n+    }\n+\n+    /**\n+     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n+     * <p>\n+     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n+     * </p>\n+     *\n+     * @param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n+     * @return The tag, either defined or new generic.\n+     */\n+    public static Tag valueOf(String tagName) {\n+        return valueOf(tagName, ParseSettings.preserveCase);\n     }\n \n     /**\n      * Gets if this tag can contain block tags.\n      *\n      * @return if tag can contain block tags\n+     * @deprecated No longer used, and no different result than {{@link #isBlock()}}\n      */\n     public boolean canContainBlock() {\n-        return canContainBlock;\n+        return isBlock;\n     }\n \n     /**\n     /**\n      * Get if this tag should preserve whitespace within child text nodes.\n      *\n-     * @return if preserve whitepace\n+     * @return if preserve whitespace\n      */\n     public boolean preserveWhitespace() {\n         return preserveWhitespace;\n         Tag tag = (Tag) o;\n \n         if (!tagName.equals(tag.tagName)) return false;\n-        if (canContainBlock != tag.canContainBlock) return false;\n         if (canContainInline != tag.canContainInline) return false;\n         if (empty != tag.empty) return false;\n         if (formatAsBlock != tag.formatAsBlock) return false;\n         int result = tagName.hashCode();\n         result = 31 * result + (isBlock ? 1 : 0);\n         result = 31 * result + (formatAsBlock ? 1 : 0);\n-        result = 31 * result + (canContainBlock ? 1 : 0);\n         result = 31 * result + (canContainInline ? 1 : 0);\n         result = 31 * result + (empty ? 1 : 0);\n         result = 31 * result + (selfClosing ? 1 : 0);\n             \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n-            \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n+            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n             \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n             \"svg\", \"math\"\n     };\n             \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n             \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n             \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\",\n-            \"data\", \"bdi\"\n+            \"data\", \"bdi\", \"s\"\n     };\n     private static final String[] emptyTags = {\n             \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n         for (String tagName : inlineTags) {\n             Tag tag = new Tag(tagName);\n             tag.isBlock = false;\n-            tag.canContainBlock = false;\n             tag.formatAsBlock = false;\n             register(tag);\n         }\n         for (String tagName : emptyTags) {\n             Tag tag = tags.get(tagName);\n             Validate.notNull(tag);\n-            tag.canContainBlock = false;\n             tag.canContainInline = false;\n             tag.empty = true;\n         }\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.BooleanAttribute;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  * Parse tokens for the Tokeniser.\n \n     static final class Doctype extends Token {\n         final StringBuilder name = new StringBuilder();\n+        String pubSysKey = null;\n         final StringBuilder publicIdentifier = new StringBuilder();\n         final StringBuilder systemIdentifier = new StringBuilder();\n         boolean forceQuirks = false;\n         @Override\n         Token reset() {\n             reset(name);\n+            pubSysKey = null;\n             reset(publicIdentifier);\n             reset(systemIdentifier);\n             forceQuirks = false;\n             return name.toString();\n         }\n \n+        String getPubSysKey() {\n+            return pubSysKey;\n+        }\n+\n         String getPublicIdentifier() {\n             return publicIdentifier.toString();\n         }\n \n     static abstract class Tag extends Token {\n         protected String tagName;\n+        protected String normalName; // lc version of tag name, for case insensitive tree build\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n         private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n+        private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n         private boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\n         private boolean hasPendingAttributeValue = false;\n         boolean selfClosing = false;\n         @Override\n         Tag reset() {\n             tagName = null;\n+            normalName = null;\n             pendingAttributeName = null;\n             reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n             hasEmptyAttributeValue = false;\n             hasPendingAttributeValue = false;\n             selfClosing = false;\n                 attributes = new Attributes();\n \n             if (pendingAttributeName != null) {\n-                Attribute attribute;\n-                if (hasPendingAttributeValue)\n-                    attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\n-                else if (hasEmptyAttributeValue)\n-                    attribute = new Attribute(pendingAttributeName, \"\");\n-                else\n-                    attribute = new BooleanAttribute(pendingAttributeName);\n-                attributes.put(attribute);\n+                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n+                pendingAttributeName = pendingAttributeName.trim();\n+                if (pendingAttributeName.length() > 0) {\n+                    Attribute attribute;\n+                    if (hasPendingAttributeValue)\n+                        attribute = new Attribute(pendingAttributeName,\n+                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                    else if (hasEmptyAttributeValue)\n+                        attribute = new Attribute(pendingAttributeName, \"\");\n+                    else\n+                        attribute = new BooleanAttribute(pendingAttributeName);\n+                    attributes.put(attribute);\n+                }\n             }\n             pendingAttributeName = null;\n             hasEmptyAttributeValue = false;\n             hasPendingAttributeValue = false;\n             reset(pendingAttributeValue);\n+            pendingAttributeValueS = null;\n         }\n \n         final void finaliseTag() {\n             }\n         }\n \n-        final String name() {\n+        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n             Validate.isFalse(tagName == null || tagName.length() == 0);\n             return tagName;\n         }\n \n+        final String normalName() { // loses case, used in tree building for working out where in tree it should go\n+            return normalName;\n+        }\n+\n         final Tag name(String name) {\n             tagName = name;\n+            normalName = lowerCase(name);\n             return this;\n         }\n \n         // these appenders are rarely hit in not null state-- caused by null chars.\n         final void appendTagName(String append) {\n             tagName = tagName == null ? append : tagName.concat(append);\n+            normalName = lowerCase(tagName);\n         }\n \n         final void appendTagName(char append) {\n \n         final void appendAttributeValue(String append) {\n             ensureAttributeValue();\n-            pendingAttributeValue.append(append);\n+            if (pendingAttributeValue.length() == 0) {\n+                pendingAttributeValueS = append;\n+            } else {\n+                pendingAttributeValue.append(append);\n+            }\n         }\n \n         final void appendAttributeValue(char append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n+\n+        final void appendAttributeValue(int[] appendCodepoints) {\n+            ensureAttributeValue();\n+            for (int codepoint : appendCodepoints) {\n+                pendingAttributeValue.appendCodePoint(codepoint);\n+            }\n+        }\n         \n         final void setEmptyAttributeValue() {\n             hasEmptyAttributeValue = true;\n \n         private void ensureAttributeValue() {\n             hasPendingAttributeValue = true;\n+            // if on second hit, we'll need to move to the builder\n+            if (pendingAttributeValueS != null) {\n+                pendingAttributeValue.append(pendingAttributeValueS);\n+                pendingAttributeValueS = null;\n+            }\n         }\n     }\n \n         StartTag nameAttr(String name, Attributes attributes) {\n             this.tagName = name;\n             this.attributes = attributes;\n+            normalName = lowerCase(tagName);\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n \n     /**\n      * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n-     * and leave \" four\" on the queue. Unbalanced openers and closers can be escaped (with \\). Those escapes will be left\n+     * and leave \" four\" on the queue. Unbalanced openers and closers can be quoted (with ' or \") or escaped (with \\). Those escapes will be left\n      * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n      * contains text strings; use unescape for that.\n      * @param open opener\n         int end = -1;\n         int depth = 0;\n         char last = 0;\n+        boolean inQuote = false;\n \n         do {\n             if (isEmpty()) break;\n             Character c = consume();\n             if (last == 0 || last != ESC) {\n+                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n+                    inQuote = !inQuote;\n+                if (inQuote)\n+                    continue;\n                 if (c.equals(open)) {\n                     depth++;\n                     if (start == -1)\n                 end = pos; // don't include the outer match pair in the return\n             last = c;\n         } while (depth > 0);\n-        return (end >= 0) ? queue.substring(start, end) : \"\";\n+        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n+        if (depth > 0) {// ran out of queue before seeing enough )\n+            Validate.fail(\"Did not find balanced maker at \" + out);\n+        }\n+        return out;\n     }\n     \n     /**\n     }\n     \n     /**\n-     * Consume a CSS element selector (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).\n+     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).\n      * \n      * @return tag name\n      */\n     public String consumeElementSelector() {\n         int start = pos;\n-        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\n+        while (!isEmpty() && (matchesWord() || matchesAny(\"*|\",\"|\", \"_\", \"-\")))\n             pos++;\n         \n         return queue.substring(start, pos);\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         Arrays.sort(notCharRefCharsSorted);\n     }\n \n-    private CharacterReader reader; // html input\n-    private ParseErrorList errors; // errors found while tokenising\n+    private final CharacterReader reader; // html input\n+    private final ParseErrorList errors; // errors found while tokenising\n \n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n     Token.Comment commentPending = new Token.Comment(); // comment building up\n     private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n-    private boolean selfClosingFlagAcknowledged = true;\n \n     Tokeniser(CharacterReader reader, ParseErrorList errors) {\n         this.reader = reader;\n     }\n \n     Token read() {\n-        if (!selfClosingFlagAcknowledged) {\n-            error(\"Self closing flag not acknowledged\");\n-            selfClosingFlagAcknowledged = true;\n-        }\n-\n         while (!isEmitPending)\n             state.read(this, reader);\n \n         if (token.type == Token.TokenType.StartTag) {\n             Token.StartTag startTag = (Token.StartTag) token;\n             lastStartTag = startTag.tagName;\n-            if (startTag.selfClosing)\n-                selfClosingFlagAcknowledged = false;\n         } else if (token.type == Token.TokenType.EndTag) {\n             Token.EndTag endTag = (Token.EndTag) token;\n             if (endTag.attributes != null)\n         emit(String.valueOf(chars));\n     }\n \n+    void emit(int[] codepoints) {\n+        emit(new String(codepoints, 0, codepoints.length));\n+    }\n+\n     void emit(char c) {\n         emit(String.valueOf(c));\n     }\n         this.state = state;\n     }\n \n-    void acknowledgeSelfClosingFlag() {\n-        selfClosingFlagAcknowledged = true;\n-    }\n-\n-    final private char[] charRefHolder = new char[1]; // holder to not have to keep creating arrays\n-    char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+    final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays\n+    final private int[] multipointHolder = new int[2];\n+    int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n         if (reader.matchesAnySorted(notCharRefCharsSorted))\n             return null;\n \n-        final char[] charRef = charRefHolder;\n+        final int[] codeRef = codepointHolder;\n         reader.mark();\n         if (reader.matchConsume(\"#\")) { // numbered\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             try {\n                 int base = isHexMode ? 16 : 10;\n                 charval = Integer.valueOf(numRef, base);\n-            } catch (NumberFormatException e) {\n+            } catch (NumberFormatException ignored) {\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                charRef[0] = replacementChar;\n-                return charRef;\n+                codeRef[0] = replacementChar;\n+                return codeRef;\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n-                if (charval < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n-                    charRef[0] = (char) charval;\n-                    return charRef;\n-                } else\n-                return Character.toChars(charval);\n+                codeRef[0] = charval;\n+                return codeRef;\n             }\n         } else { // named\n             // get as many letters as possible, and look for matching entities.\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            charRef[0] = Entities.getCharacterByName(nameRef);\n-            return charRef;\n+            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n+            if (numChars == 1) {\n+                codeRef[0] = multipointHolder[0];\n+                return codeRef;\n+            } else if (numChars ==2) {\n+                return multipointHolder;\n+            } else {\n+                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n+                return multipointHolder;\n+            }\n         }\n     }\n \n     }\n \n     boolean isAppropriateEndTagToken() {\n-        return lastStartTag != null && tagPending.tagName.equals(lastStartTag);\n+        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n     }\n \n     String appropriateEndTagName() {\n             errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n     }\n \n-    private void error(String errorMsg) {\n+    void error(String errorMsg) {\n         if (errors.canAddError())\n             errors.add(new ParseError(reader.pos(), errorMsg));\n     }\n             builder.append(reader.consumeTo('&'));\n             if (reader.matches('&')) {\n                 reader.consume();\n-                char[] c = consumeCharacterReference(null, inAttribute);\n+                int[] c = consumeCharacterReference(null, inAttribute);\n                 if (c == null || c.length==0)\n                     builder.append('&');\n-                else\n-                    builder.append(c);\n+                else {\n+                    builder.appendCodePoint(c[0]);\n+                    if (c.length == 2)\n+                        builder.appendCodePoint(c[1]);\n+                }\n+\n             }\n         }\n         return builder.toString();\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n package org.jsoup.parser;\n+\n+import org.jsoup.nodes.DocumentType;\n \n import java.util.Arrays;\n \n     CharacterReferenceInData {\n         // from & in data\n         void read(Tokeniser t, CharacterReader r) {\n-            char[] c = t.consumeCharacterReference(null, false);\n-            if (c == null)\n-                t.emit('&');\n-            else\n-                t.emit(c);\n-            t.transition(Data);\n+            readCharRef(t, Data);\n         }\n     },\n     Rcdata {\n     },\n     CharacterReferenceInRcdata {\n         void read(Tokeniser t, CharacterReader r) {\n-            char[] c = t.consumeCharacterReference(null, false);\n-            if (c == null)\n-                t.emit('&');\n-            else\n-                t.emit(c);\n-            t.transition(Rcdata);\n+            readCharRef(t, Rcdata);\n         }\n     },\n     Rawtext {\n         void read(Tokeniser t, CharacterReader r) {\n-            switch (r.current()) {\n-                case '<':\n-                    t.advanceTransition(RawtextLessthanSign);\n-                    break;\n-                case nullChar:\n-                    t.error(this);\n-                    r.advance();\n-                    t.emit(replacementChar);\n-                    break;\n-                case eof:\n-                    t.emit(new Token.EOF());\n-                    break;\n-                default:\n-                    String data = r.consumeToAny('<', nullChar);\n-                    t.emit(data);\n-                    break;\n-            }\n+            readData(t, r, this, RawtextLessthanSign);\n         }\n     },\n     ScriptData {\n         void read(Tokeniser t, CharacterReader r) {\n-            switch (r.current()) {\n-                case '<':\n-                    t.advanceTransition(ScriptDataLessthanSign);\n-                    break;\n-                case nullChar:\n-                    t.error(this);\n-                    r.advance();\n-                    t.emit(replacementChar);\n-                    break;\n-                case eof:\n-                    t.emit(new Token.EOF());\n-                    break;\n-                default:\n-                    String data = r.consumeToAny('<', nullChar);\n-                    t.emit(data);\n-                    break;\n-            }\n+            readData(t, r, this, ScriptDataLessthanSign);\n         }\n     },\n     PLAINTEXT {\n         void read(Tokeniser t, CharacterReader r) {\n             // previous TagOpen state did NOT consume, will have a letter char in current\n             //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n-            String tagName = r.consumeTagName().toLowerCase();\n+            String tagName = r.consumeTagName();\n             t.tagPending.appendTagName(tagName);\n \n             switch (r.consume()) {\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 t.createTagPending(false);\n-                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n-                t.dataBuffer.append(Character.toLowerCase(r.current()));\n+                t.tagPending.appendTagName(r.current());\n+                t.dataBuffer.append(r.current());\n                 t.advanceTransition(RCDATAEndTagName);\n             } else {\n                 t.emit(\"</\");\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n-                t.tagPending.appendTagName(name.toLowerCase());\n+                t.tagPending.appendTagName(name);\n                 t.dataBuffer.append(name);\n                 return;\n             }\n     },\n     RawtextEndTagOpen {\n         void read(Tokeniser t, CharacterReader r) {\n-            if (r.matchesLetter()) {\n-                t.createTagPending(false);\n-                t.transition(RawtextEndTagName);\n-            } else {\n-                t.emit(\"</\");\n-                t.transition(Rawtext);\n-            }\n+            readEndTag(t, r, RawtextEndTagName, Rawtext);\n         }\n     },\n     RawtextEndTagName {\n     },\n     ScriptDataEndTagOpen {\n         void read(Tokeniser t, CharacterReader r) {\n-            if (r.matchesLetter()) {\n-                t.createTagPending(false);\n-                t.transition(ScriptDataEndTagName);\n-            } else {\n-                t.emit(\"</\");\n-                t.transition(ScriptData);\n-            }\n-\n+            readEndTag(t, r, ScriptDataEndTagName, ScriptData);\n         }\n     },\n     ScriptDataEndTagName {\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 t.createTempBuffer();\n-                t.dataBuffer.append(Character.toLowerCase(r.current()));\n+                t.dataBuffer.append(r.current());\n                 t.emit(\"<\" + r.current());\n                 t.advanceTransition(ScriptDataDoubleEscapeStart);\n             } else if (r.matches('/')) {\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 t.createTagPending(false);\n-                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n+                t.tagPending.appendTagName(r.current());\n                 t.dataBuffer.append(r.current());\n                 t.advanceTransition(ScriptDataEscapedEndTagName);\n             } else {\n         // from before attribute name\n         void read(Tokeniser t, CharacterReader r) {\n             String name = r.consumeToAnySorted(attributeNameCharsSorted);\n-            t.tagPending.appendAttributeName(name.toLowerCase());\n+            t.tagPending.appendAttributeName(name);\n \n             char c = r.consume();\n             switch (c) {\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n+            String value = r.consumeToAny(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n             else\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    int[] ref = t.consumeCharacterReference('\"', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n+            String value = r.consumeToAny(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n             else\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('\\'', true);\n+                    int[] ref = t.consumeCharacterReference('\\'', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n     },\n     AttributeValue_unquoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n+            String value = r.consumeToAnySorted(attributeValueUnquoted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n                     t.transition(BeforeAttributeName);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('>', true);\n+                    int[] ref = t.consumeCharacterReference('>', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n                     break;\n                 default:\n                     t.error(this);\n+                    r.unconsume();\n                     t.transition(BeforeAttributeName);\n             }\n         }\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n-                t.doctypePending.name.append(name.toLowerCase());\n+                t.doctypePending.name.append(name);\n                 return;\n             }\n             char c = r.consume();\n             else if (r.matches('>')) {\n                 t.emitDoctypePending();\n                 t.advanceTransition(Data);\n-            } else if (r.matchConsumeIgnoreCase(\"PUBLIC\")) {\n+            } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n+                t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY;\n                 t.transition(AfterDoctypePublicKeyword);\n-            } else if (r.matchConsumeIgnoreCase(\"SYSTEM\")) {\n+            } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n+                t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY;\n                 t.transition(AfterDoctypeSystemKeyword);\n             } else {\n                 t.error(this);\n     private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n     private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n     private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+    private static final char[] attributeValueUnquoted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`'};\n \n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n         Arrays.sort(attributeSingleValueCharsSorted);\n         Arrays.sort(attributeDoubleValueCharsSorted);\n         Arrays.sort(attributeNameCharsSorted);\n+        Arrays.sort(attributeValueUnquoted);\n     }\n \n     /**\n     private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n-            t.tagPending.appendTagName(name.toLowerCase());\n+            t.tagPending.appendTagName(name);\n             t.dataBuffer.append(name);\n             return;\n         }\n         }\n     }\n \n+    private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {\n+        switch (r.current()) {\n+            case '<':\n+                t.advanceTransition(advance);\n+                break;\n+            case nullChar:\n+                t.error(current);\n+                r.advance();\n+                t.emit(replacementChar);\n+                break;\n+            case eof:\n+                t.emit(new Token.EOF());\n+                break;\n+            default:\n+                String data = r.consumeToAny('<', nullChar); // todo - why hunt for null here? Just consumeTo'<'?\n+                t.emit(data);\n+                break;\n+        }\n+    }\n+\n+    private static void readCharRef(Tokeniser t, TokeniserState advance) {\n+        int[] c = t.consumeCharacterReference(null, false);\n+        if (c == null)\n+            t.emit('&');\n+        else\n+            t.emit(c);\n+        t.transition(advance);\n+    }\n+\n+    private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {\n+        if (r.matchesLetter()) {\n+            t.createTagPending(false);\n+            t.transition(a);\n+        } else {\n+            t.emit(\"</\");\n+            t.transition(b);\n+        }\n+    }\n+\n     private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n-            t.dataBuffer.append(name.toLowerCase());\n+            t.dataBuffer.append(name);\n             t.emit(name);\n             return;\n         }\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n+import java.io.Reader;\n import java.util.ArrayList;\n \n /**\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n+    protected ParseSettings settings;\n \n     private Token.StartTag start = new Token.StartTag(); // start tag to process\n     private Token.EndTag end  = new Token.EndTag();\n \n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n+    abstract ParseSettings defaultSettings();\n+\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         Validate.notNull(input, \"String input must not be null\");\n         Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n         doc = new Document(baseUri);\n+        this.settings = settings;\n         reader = new CharacterReader(input);\n         this.errors = errors;\n+        currentToken = null;\n         tokeniser = new Tokeniser(reader, errors);\n-        stack = new ArrayList<Element>(32);\n+        stack = new ArrayList<>(32);\n         this.baseUri = baseUri;\n     }\n \n-    Document parse(String input, String baseUri) {\n-        return parse(input, baseUri, ParseErrorList.noTracking());\n-    }\n-\n-    Document parse(String input, String baseUri, ParseErrorList errors) {\n-        initialiseParse(input, baseUri, errors);\n+    Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        initialiseParse(input, baseUri, errors, settings);\n         runParser();\n         return doc;\n     }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n package org.jsoup.parser;\n \n+import org.jsoup.Jsoup;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n  */\n public class XmlTreeBuilder extends TreeBuilder {\n+    ParseSettings defaultSettings() {\n+        return ParseSettings.preserveCase;\n+    }\n+\n+    Document parse(Reader input, String baseUri) {\n+        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n+    }\n+\n+    Document parse(String input, String baseUri) {\n+        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n+    }\n+\n     @Override\n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n-        super.initialiseParse(input, baseUri, errors);\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        super.initialiseParse(input, baseUri, errors, settings);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n         doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n     }\n     }\n \n     Element insert(Token.StartTag startTag) {\n-        Tag tag = Tag.valueOf(startTag.name());\n+        Tag tag = Tag.valueOf(startTag.name(), settings);\n         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n-        Element el = new Element(tag, baseUri, startTag.attributes);\n+        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n-            tokeniser.acknowledgeSelfClosingFlag();\n             if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n                 tag.setSelfClosing();\n         } else {\n         Comment comment = new Comment(commentToken.getData(), baseUri);\n         Node insert = comment;\n         if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n+            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n             String data = comment.getData();\n             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n-                String declaration = data.substring(1);\n-                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n+                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n+                Element el = doc.child(0);\n+                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\"));\n+                insert.attributes().addAll(el.attributes());\n             }\n         }\n         insertNode(insert);\n     }\n \n     void insert(Token.Doctype d) {\n-        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n+        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n         insertNode(doctypeNode);\n     }\n \n         }\n     }\n \n-    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n-        initialiseParse(inputFragment, baseUri, errors);\n+    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n         runParser();\n         return doc.childNodes();\n     }\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n package org.jsoup.safety;\n \n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.DataNode;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n+import org.jsoup.parser.ParseErrorList;\n+import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n+\n+import java.util.List;\n \n \n /**\n     }\n \n     /**\n-     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n-     in the input HTML are allowed by the whitelist.\n+     Determines if the input document <b>body</b>is valid, against the whitelist. It is considered valid if all the tags and attributes\n+     in the input HTML are allowed by the whitelist, and that there is no content in the <code>head</code>.\n      <p>\n-     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n+     This method can be used as a validator for user input. An invalid document will still be cleaned successfully\n      using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n      to ensure enforced attributes are set correctly, and that the output is tidied.\n      </p>\n \n         Document clean = Document.createShell(dirtyDocument.baseUri());\n         int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n-        return numDiscarded == 0;\n+        return numDiscarded == 0\n+            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n+    }\n+\n+    public boolean isValidBodyHtml(String bodyHtml) {\n+        Document clean = Document.createShell(\"\");\n+        Document dirty = Document.createShell(\"\");\n+        ParseErrorList errorList = ParseErrorList.tracking(1);\n+        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n+        dirty.body().insertChildren(0, nodes);\n+        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n+        return numDiscarded == 0 && errorList.size() == 0;\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n \n /**\n      @see #relaxed()\n      */\n     public Whitelist() {\n-        tagNames = new HashSet<TagName>();\n-        attributes = new HashMap<TagName, Set<AttributeKey>>();\n-        enforcedAttributes = new HashMap<TagName, Map<AttributeKey, AttributeValue>>();\n-        protocols = new HashMap<TagName, Map<AttributeKey, Set<Protocol>>>();\n+        tagNames = new HashSet<>();\n+        attributes = new HashMap<>();\n+        enforcedAttributes = new HashMap<>();\n+        protocols = new HashMap<>();\n         preserveRelativeLinks = false;\n     }\n \n      </p>\n \n      @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n-     @param keys List of valid attributes for the tag\n+     @param attributes List of valid attributes for the tag\n      @return this (for chaining)\n      */\n-    public Whitelist addAttributes(String tag, String... keys) {\n+    public Whitelist addAttributes(String tag, String... attributes) {\n         Validate.notEmpty(tag);\n-        Validate.notNull(keys);\n-        Validate.isTrue(keys.length > 0, \"No attributes supplied.\");\n+        Validate.notNull(attributes);\n+        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n \n         TagName tagName = TagName.valueOf(tag);\n         if (!tagNames.contains(tagName))\n             tagNames.add(tagName);\n-        Set<AttributeKey> attributeSet = new HashSet<AttributeKey>();\n-        for (String key : keys) {\n+        Set<AttributeKey> attributeSet = new HashSet<>();\n+        for (String key : attributes) {\n             Validate.notEmpty(key);\n             attributeSet.add(AttributeKey.valueOf(key));\n         }\n-        if (attributes.containsKey(tagName)) {\n-            Set<AttributeKey> currentSet = attributes.get(tagName);\n+        if (this.attributes.containsKey(tagName)) {\n+            Set<AttributeKey> currentSet = this.attributes.get(tagName);\n             currentSet.addAll(attributeSet);\n         } else {\n-            attributes.put(tagName, attributeSet);\n+            this.attributes.put(tagName, attributeSet);\n         }\n         return this;\n     }\n      </p>\n \n      @param tag  The tag the attributes are for.\n-     @param keys List of invalid attributes for the tag\n+     @param attributes List of invalid attributes for the tag\n      @return this (for chaining)\n      */\n-    public Whitelist removeAttributes(String tag, String... keys) {\n+    public Whitelist removeAttributes(String tag, String... attributes) {\n         Validate.notEmpty(tag);\n-        Validate.notNull(keys);\n-        Validate.isTrue(keys.length > 0, \"No attributes supplied.\");\n+        Validate.notNull(attributes);\n+        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n \n         TagName tagName = TagName.valueOf(tag);\n-        Set<AttributeKey> attributeSet = new HashSet<AttributeKey>();\n-        for (String key : keys) {\n+        Set<AttributeKey> attributeSet = new HashSet<>();\n+        for (String key : attributes) {\n             Validate.notEmpty(key);\n             attributeSet.add(AttributeKey.valueOf(key));\n         }\n-        if(tagNames.contains(tagName) && attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed\n-            Set<AttributeKey> currentSet = attributes.get(tagName);\n+        if(tagNames.contains(tagName) && this.attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed\n+            Set<AttributeKey> currentSet = this.attributes.get(tagName);\n             currentSet.removeAll(attributeSet);\n \n             if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n-                attributes.remove(tagName);\n+                this.attributes.remove(tagName);\n         }\n         if(tag.equals(\":all\")) // Attribute needs to be removed from all individually set tags\n-            for(TagName name: attributes.keySet()) {\n-                Set<AttributeKey> currentSet = attributes.get(name);\n+            for(TagName name: this.attributes.keySet()) {\n+                Set<AttributeKey> currentSet = this.attributes.get(name);\n                 currentSet.removeAll(attributeSet);\n \n                 if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n-                    attributes.remove(name);\n+                    this.attributes.remove(name);\n             }\n         return this;\n     }\n \n     /**\n      Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n-     already has the attribute set, it will be overridden.\n+     already has the attribute set, it will be overridden with this value.\n      <p>\n      E.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n      <code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n      </p>\n \n      @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n-     @param key   The attribute key\n+     @param attribute   The attribute name\n      @param value The enforced attribute value\n      @return this (for chaining)\n      */\n-    public Whitelist addEnforcedAttribute(String tag, String key, String value) {\n+    public Whitelist addEnforcedAttribute(String tag, String attribute, String value) {\n         Validate.notEmpty(tag);\n-        Validate.notEmpty(key);\n+        Validate.notEmpty(attribute);\n         Validate.notEmpty(value);\n \n         TagName tagName = TagName.valueOf(tag);\n         if (!tagNames.contains(tagName))\n             tagNames.add(tagName);\n-        AttributeKey attrKey = AttributeKey.valueOf(key);\n+        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n         AttributeValue attrVal = AttributeValue.valueOf(value);\n \n         if (enforcedAttributes.containsKey(tagName)) {\n             enforcedAttributes.get(tagName).put(attrKey, attrVal);\n         } else {\n-            Map<AttributeKey, AttributeValue> attrMap = new HashMap<AttributeKey, AttributeValue>();\n+            Map<AttributeKey, AttributeValue> attrMap = new HashMap<>();\n             attrMap.put(attrKey, attrVal);\n             enforcedAttributes.put(tagName, attrMap);\n         }\n      Remove a previously configured enforced attribute from a tag.\n \n      @param tag   The tag the enforced attribute is for.\n-     @param key   The attribute key\n+     @param attribute   The attribute name\n      @return this (for chaining)\n      */\n-    public Whitelist removeEnforcedAttribute(String tag, String key) {\n+    public Whitelist removeEnforcedAttribute(String tag, String attribute) {\n         Validate.notEmpty(tag);\n-        Validate.notEmpty(key);\n+        Validate.notEmpty(attribute);\n \n         TagName tagName = TagName.valueOf(tag);\n         if(tagNames.contains(tagName) && enforcedAttributes.containsKey(tagName)) {\n-            AttributeKey attrKey = AttributeKey.valueOf(key);\n+            AttributeKey attrKey = AttributeKey.valueOf(attribute);\n             Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.get(tagName);\n             attrMap.remove(attrKey);\n \n      </p>\n \n      @param tag       Tag the URL protocol is for\n-     @param key       Attribute key\n+     @param attribute       Attribute name\n      @param protocols List of valid protocols\n      @return this, for chaining\n      */\n-    public Whitelist addProtocols(String tag, String key, String... protocols) {\n+    public Whitelist addProtocols(String tag, String attribute, String... protocols) {\n         Validate.notEmpty(tag);\n-        Validate.notEmpty(key);\n+        Validate.notEmpty(attribute);\n         Validate.notNull(protocols);\n \n         TagName tagName = TagName.valueOf(tag);\n-        AttributeKey attrKey = AttributeKey.valueOf(key);\n+        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n         Map<AttributeKey, Set<Protocol>> attrMap;\n         Set<Protocol> protSet;\n \n         if (this.protocols.containsKey(tagName)) {\n             attrMap = this.protocols.get(tagName);\n         } else {\n-            attrMap = new HashMap<AttributeKey, Set<Protocol>>();\n+            attrMap = new HashMap<>();\n             this.protocols.put(tagName, attrMap);\n         }\n         if (attrMap.containsKey(attrKey)) {\n             protSet = attrMap.get(attrKey);\n         } else {\n-            protSet = new HashSet<Protocol>();\n+            protSet = new HashSet<>();\n             attrMap.put(attrKey, protSet);\n         }\n         for (String protocol : protocols) {\n     }\n \n     /**\n-     Remove allowed URL protocols for an element's URL attribute.\n+     Remove allowed URL protocols for an element's URL attribute. If you remove all protocols for an attribute, that\n+     attribute will allow any protocol.\n      <p>\n      E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n      </p>\n \n-     @param tag       Tag the URL protocol is for\n-     @param key       Attribute key\n-     @param protocols List of invalid protocols\n+     @param tag Tag the URL protocol is for\n+     @param attribute Attribute name\n+     @param removeProtocols List of invalid protocols\n      @return this, for chaining\n      */\n-    public Whitelist removeProtocols(String tag, String key, String... protocols) {\n+    public Whitelist removeProtocols(String tag, String attribute, String... removeProtocols) {\n         Validate.notEmpty(tag);\n-        Validate.notEmpty(key);\n-        Validate.notNull(protocols);\n+        Validate.notEmpty(attribute);\n+        Validate.notNull(removeProtocols);\n \n         TagName tagName = TagName.valueOf(tag);\n-        AttributeKey attrKey = AttributeKey.valueOf(key);\n-\n-        if(this.protocols.containsKey(tagName)) {\n-            Map<AttributeKey, Set<Protocol>> attrMap = this.protocols.get(tagName);\n-            if(attrMap.containsKey(attrKey)) {\n-                Set<Protocol> protSet = attrMap.get(attrKey);\n-                for (String protocol : protocols) {\n-                    Validate.notEmpty(protocol);\n-                    Protocol prot = Protocol.valueOf(protocol);\n-                    protSet.remove(prot);\n-                }\n-\n-                if(protSet.isEmpty()) { // Remove protocol set if empty\n-                    attrMap.remove(attrKey);\n-                    if(attrMap.isEmpty()) // Remove entry for tag if empty\n-                        this.protocols.remove(tagName);\n-                }\n-            }\n+        AttributeKey attr = AttributeKey.valueOf(attribute);\n+\n+        // make sure that what we're removing actually exists; otherwise can open the tag to any data and that can\n+        // be surprising\n+        Validate.isTrue(protocols.containsKey(tagName), \"Cannot remove a protocol that is not set.\");\n+        Map<AttributeKey, Set<Protocol>> tagProtocols = protocols.get(tagName);\n+        Validate.isTrue(tagProtocols.containsKey(attr), \"Cannot remove a protocol that is not set.\");\n+\n+        Set<Protocol> attrProtocols = tagProtocols.get(attr);\n+        for (String protocol : removeProtocols) {\n+            Validate.notEmpty(protocol);\n+            attrProtocols.remove(Protocol.valueOf(protocol));\n+        }\n+\n+        if (attrProtocols.isEmpty()) { // Remove protocol set if empty\n+            tagProtocols.remove(attr);\n+            if (tagProtocols.isEmpty()) // Remove entry for tag if empty\n+                protocols.remove(tagName);\n         }\n         return this;\n     }\n         TagName tag = TagName.valueOf(tagName);\n         AttributeKey key = AttributeKey.valueOf(attr.getKey());\n \n-        if (attributes.containsKey(tag)) {\n-            if (attributes.get(tag).contains(key)) {\n-                if (protocols.containsKey(tag)) {\n-                    Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n-                    // ok if not defined protocol; otherwise test\n-                    return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n-                } else { // attribute found, no protocols defined, so OK\n-                    return true;\n-                }\n+        Set<AttributeKey> okSet = attributes.get(tag);\n+        if (okSet != null && okSet.contains(key)) {\n+            if (protocols.containsKey(tag)) {\n+                Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n+                // ok if not defined protocol; otherwise test\n+                return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n+            } else { // attribute found, no protocols defined, so OK\n+                return true;\n+            }\n+        }\n+        // might be an enforced attribute?\n+        Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);\n+        if (enforcedSet != null) {\n+            Attributes expect = getEnforcedAttributes(tagName);\n+            String attrKey = attr.getKey();\n+            if (expect.hasKeyIgnoreCase(attrKey)) {\n+                return expect.getIgnoreCase(attrKey).equals(attr.getValue());\n             }\n         }\n         // no attributes defined for tag, try :all tag\n \n             prot += \":\";\n \n-            if (value.toLowerCase().startsWith(prot)) {\n+            if (lowerCase(value).startsWith(prot)) {\n                 return true;\n             }\n         }\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n \n     CombiningEvaluator() {\n         super();\n-        evaluators = new ArrayList<Evaluator>();\n+        evaluators = new ArrayList<>();\n     }\n \n     CombiningEvaluator(Collection<Evaluator> evaluators) {\n             updateNumEvaluators();\n         }\n \n+        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }\n+\n         Or() {\n             super();\n         }\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n     }\n \n     /**\n-     Checks if any of the matched elements have this attribute set.\n+     Checks if any of the matched elements have this attribute defined.\n      @param attributeKey attribute key\n      @return true if any of the elements have the attribute; false if none do.\n      */\n                 return true;\n         }\n         return false;\n+    }\n+\n+    /**\n+     * Get the attribute value for each of the matched elements. If an element does not have this attribute, no value is\n+     * included in the result set for that element.\n+     * @param attributeKey the attribute name to return values for. You can add the {@code abs:} prefix to the key to\n+     * get absolute URLs from relative URLs, e.g.: {@code doc.select(\"a\").eachAttr(\"abs:href\")} .\n+     * @return a list of each element's attribute value for the attribute\n+     */\n+    public List<String> eachAttr(String attributeKey) {\n+        List<String> attrs = new ArrayList<>(size());\n+        for (Element element : this) {\n+            if (element.hasAttr(attributeKey))\n+                attrs.add(element.attr(attributeKey));\n+        }\n+        return attrs;\n     }\n \n     /**\n      * children, as the Element.text() method returns the combined text of a parent and all its children.\n      * @return string of all text: unescaped and no HTML.\n      * @see Element#text()\n+     * @see #eachText()\n      */\n     public String text() {\n         StringBuilder sb = new StringBuilder();\n         return sb.toString();\n     }\n \n+    /**\n+     Test if any matched Element has any text content, that is not just whitespace.\n+     @return true if any element has non-blank text content.\n+     @see Element#hasText()\n+     */\n     public boolean hasText() {\n         for (Element element: this) {\n             if (element.hasText())\n                 return true;\n         }\n         return false;\n+    }\n+\n+    /**\n+     * Get the text content of each of the matched elements. If an element has no text, then it is not included in the\n+     * result.\n+     * @return A list of each matched element's text content.\n+     * @see Element#text()\n+     * @see Element#hasText()\n+     * @see #text()\n+     */\n+    public List<String> eachText() {\n+        ArrayList<String> texts = new ArrayList<>(size());\n+        for (Element el: this) {\n+            if (el.hasText())\n+                texts.add(el.text());\n+        }\n+        return texts;\n     }\n     \n     /**\n      * Remove elements from this list that match the {@link Selector} query.\n      * <p>\n      * E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>\n-     * <code>Elements divs = doc.select(\"div\").not(\"#logo\");</code><br>\n+     * <code>Elements divs = doc.select(\"div\").not(\".logo\");</code><br>\n      * Result: {@code divs: [<div>Two</div>]}\n      * <p>\n      * @param query the selector query whose results should be removed from these elements\n      * @return true if at least one element in the list matches the query.\n      */\n     public boolean is(String query) {\n-        Elements children = select(query);\n-        return !children.isEmpty();\n+        Evaluator eval = QueryParser.parse(query);\n+        for (Element e : this) {\n+            if (e.is(eval))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the immediate next element sibling of each element in this list.\n+     * @return next element siblings.\n+     */\n+    public Elements next() {\n+        return siblings(null, true, false);\n+    }\n+\n+    /**\n+     * Get the immediate next element sibling of each element in this list, filtered by the query.\n+     * @param query CSS query to match siblings against\n+     * @return next element siblings.\n+     */\n+    public Elements next(String query) {\n+        return siblings(query, true, false);\n+    }\n+\n+    /**\n+     * Get all of the following element siblings of each element in this list.\n+     * @return all following element siblings.\n+     */\n+    public Elements nextAll() {\n+        return siblings(null, true, true);\n+    }\n+\n+    /**\n+     * Get all of the following element siblings of each element in this list, filtered by the query.\n+     * @param query CSS query to match siblings against\n+     * @return all following element siblings.\n+     */\n+    public Elements nextAll(String query) {\n+        return siblings(query, true, true);\n+    }\n+\n+    /**\n+     * Get the immediate previous element sibling of each element in this list.\n+     * @return previous element siblings.\n+     */\n+    public Elements prev() {\n+        return siblings(null, false, false);\n+    }\n+\n+    /**\n+     * Get the immediate previous element sibling of each element in this list, filtered by the query.\n+     * @param query CSS query to match siblings against\n+     * @return previous element siblings.\n+     */\n+    public Elements prev(String query) {\n+        return siblings(query, false, false);\n+    }\n+\n+    /**\n+     * Get all of the previous element siblings of each element in this list.\n+     * @return all previous element siblings.\n+     */\n+    public Elements prevAll() {\n+        return siblings(null, false, true);\n+    }\n+\n+    /**\n+     * Get all of the previous element siblings of each element in this list, filtered by the query.\n+     * @param query CSS query to match siblings against\n+     * @return all previous element siblings.\n+     */\n+    public Elements prevAll(String query) {\n+        return siblings(query, false, true);\n+    }\n+\n+    private Elements siblings(String query, boolean next, boolean all) {\n+        Elements els = new Elements();\n+        Evaluator eval = query != null? QueryParser.parse(query) : null;\n+        for (Element e : this) {\n+            do {\n+                Element sib = next ? e.nextElementSibling() : e.previousElementSibling();\n+                if (sib == null) break;\n+                if (eval == null)\n+                    els.add(sib);\n+                else if (sib.is(eval))\n+                    els.add(sib);\n+                e = sib;\n+            } while (all);\n+        }\n+        return els;\n     }\n \n     /**\n      * @return all of the parents and ancestor elements of the matched elements\n      */\n     public Elements parents() {\n-        HashSet<Element> combo = new LinkedHashSet<Element>();\n+        HashSet<Element> combo = new LinkedHashSet<>();\n         for (Element e: this) {\n             combo.addAll(e.parents());\n         }\n      * no forms.\n      */\n     public List<FormElement> forms() {\n-        ArrayList<FormElement> forms = new ArrayList<FormElement>();\n+        ArrayList<FormElement> forms = new ArrayList<>();\n         for (Element el: this)\n             if (el instanceof FormElement)\n                 forms.add((FormElement) el);\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import static org.jsoup.internal.Normalizer.lowerCase;\n+import static org.jsoup.internal.Normalizer.normalize;\n+\n \n /**\n  * Evaluates that an element matches the selector.\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return (element.tagName().equals(tagName));\n+            return (element.tagName().equalsIgnoreCase(tagName));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s\", tagName);\n+        }\n+    }\n+\n+\n+    /**\n+     * Evaluator for tag name that ends with\n+     */\n+    public static final class TagEndsWith extends Evaluator {\n+        private String tagName;\n+\n+        public TagEndsWith(String tagName) {\n+            this.tagName = tagName;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (element.tagName().endsWith(tagName));\n         }\n \n         @Override\n         private String keyPrefix;\n \n         public AttributeStarting(String keyPrefix) {\n-            this.keyPrefix = keyPrefix;\n+            Validate.notEmpty(keyPrefix);\n+            this.keyPrefix = lowerCase(keyPrefix);\n         }\n \n         @Override\n         public boolean matches(Element root, Element element) {\n             List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n             for (org.jsoup.nodes.Attribute attribute : values) {\n-                if (attribute.getKey().startsWith(keyPrefix))\n+                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                     return true;\n             }\n             return false;\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && element.attr(key).toLowerCase().startsWith(value); // value is lower case already\n+            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n         }\n \n         @Override\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && element.attr(key).toLowerCase().endsWith(value); // value is lower case\n+            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n         }\n \n         @Override\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && element.attr(key).toLowerCase().contains(value); // value is lower case\n+            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n         }\n \n         @Override\n         Pattern pattern;\n \n         public AttributeWithValueMatching(String key, Pattern pattern) {\n-            this.key = key.trim().toLowerCase();\n+            this.key = normalize(key);\n             this.pattern = pattern;\n         }\n \n             Validate.notEmpty(key);\n             Validate.notEmpty(value);\n \n-            this.key = key.trim().toLowerCase();\n-            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n+            this.key = normalize(key);\n+            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")\n+                    || value.startsWith(\"'\") && value.endsWith(\"'\")) {\n                 value = value.substring(1, value.length()-1);\n             }\n-            this.value = value.trim().toLowerCase();\n+            this.value = normalize(value);\n         }\n     }\n \n \t\tprotected int calculatePosition(Element root, Element element) {\n \t\t\tint pos = 0;\n         \tElements family = element.parent().children();\n-        \tfor (int i = 0; i < family.size(); i++) {\n-        \t\tif (family.get(i).tag().equals(element.tag())) pos++;\n-        \t\tif (family.get(i) == element) break;\n-        \t}\n+            for (Element el : family) {\n+                if (el.tag().equals(element.tag())) pos++;\n+                if (el == element) break;\n+            }\n \t\t\treturn pos;\n \t\t}\n \n \t\t\t\n \t\t\tint pos = 0;\n         \tElements family = p.children();\n-        \tfor (int i = 0; i < family.size(); i++) {\n-        \t\tif (family.get(i).tag().equals(element.tag())) pos++;\n-        \t}\n+            for (Element el : family) {\n+                if (el.tag().equals(element.tag())) pos++;\n+            }\n         \treturn pos == 1;\n \t\t}\n     \t@Override\n \t\t@Override\n \t\tpublic boolean matches(Element root, Element element) {\n         \tList<Node> family = element.childNodes();\n-        \tfor (int i = 0; i < family.size(); i++) {\n-        \t\tNode n = family.get(i);\n-        \t\tif (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType)) return false; \n-        \t}\n+            for (Node n : family) {\n+                if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType)) return false;\n+            }\n         \treturn true;\n \t\t}\n     \t@Override\n         private String searchText;\n \n         public ContainsText(String searchText) {\n-            this.searchText = searchText.toLowerCase();\n-        }\n-\n-        @Override\n-        public boolean matches(Element root, Element element) {\n-            return (element.text().toLowerCase().contains(searchText));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\":contains(%s\", searchText);\n+            this.searchText = lowerCase(searchText);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return lowerCase(element.text()).contains(searchText);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":contains(%s)\", searchText);\n+        }\n+    }\n+\n+    /**\n+     * Evaluator for matching Element (and its descendants) data\n+     */\n+    public static final class ContainsData extends Evaluator {\n+        private String searchText;\n+\n+        public ContainsData(String searchText) {\n+            this.searchText = lowerCase(searchText);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return lowerCase(element.data()).contains(searchText);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":containsData(%s)\", searchText);\n         }\n     }\n \n         private String searchText;\n \n         public ContainsOwnText(String searchText) {\n-            this.searchText = searchText.toLowerCase();\n-        }\n-\n-        @Override\n-        public boolean matches(Element root, Element element) {\n-            return (element.ownText().toLowerCase().contains(searchText));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\":containsOwn(%s\", searchText);\n+            this.searchText = lowerCase(searchText);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return lowerCase(element.ownText()).contains(searchText);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\":containsOwn(%s)\", searchText);\n         }\n     }\n \n \n         @Override\n         public String toString() {\n-            return String.format(\":matches(%s\", pattern);\n+            return String.format(\":matches(%s)\", pattern);\n         }\n     }\n \n \n         @Override\n         public String toString() {\n-            return String.format(\":matchesOwn(%s\", pattern);\n+            return String.format(\":matchesOwn(%s)\", pattern);\n         }\n     }\n }\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.TokenQueue;\n \n+import static org.jsoup.internal.Normalizer.normalize;\n+\n /**\n  * Parses a CSS selector into an Evaluator tree.\n  */\n-class QueryParser {\n+public class QueryParser {\n     private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n     private static final String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"};\n \n     private TokenQueue tq;\n     private String query;\n-    private List<Evaluator> evals = new ArrayList<Evaluator>();\n+    private List<Evaluator> evals = new ArrayList<>();\n \n     /**\n      * Create a new QueryParser.\n      * @return Evaluator\n      */\n     public static Evaluator parse(String query) {\n-        QueryParser p = new QueryParser(query);\n-        return p.parse();\n+        try {\n+            QueryParser p = new QueryParser(query);\n+            return p.parse();\n+        } catch (IllegalArgumentException e) {\n+            throw new Selector.SelectorParseException(e.getMessage());\n+        }\n     }\n \n     /**\n             byId();\n         else if (tq.matchChomp(\".\"))\n             byClass();\n-        else if (tq.matchesWord())\n+        else if (tq.matchesWord() || tq.matches(\"*|\"))\n             byTag();\n         else if (tq.matches(\"[\"))\n             byAttribute();\n             contains(false);\n         else if (tq.matches(\":containsOwn(\"))\n             contains(true);\n+        else if (tq.matches(\":containsData(\"))\n+            containsData();\n         else if (tq.matches(\":matches(\"))\n             matches(false);\n         else if (tq.matches(\":matchesOwn(\"))\n     private void byClass() {\n         String className = tq.consumeCssIdentifier();\n         Validate.notEmpty(className);\n-        evals.add(new Evaluator.Class(className.trim().toLowerCase()));\n+        evals.add(new Evaluator.Class(className.trim()));\n     }\n \n     private void byTag() {\n         String tagName = tq.consumeElementSelector();\n+\n         Validate.notEmpty(tagName);\n \n-        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n-        if (tagName.contains(\"|\"))\n-            tagName = tagName.replace(\"|\", \":\");\n-\n-        evals.add(new Evaluator.Tag(tagName.trim().toLowerCase()));\n+        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n+        if (tagName.startsWith(\"*|\")) {\n+            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(normalize(tagName)), new Evaluator.TagEndsWith(normalize(tagName.replace(\"*|\", \":\")))));\n+        } else {\n+            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n+            if (tagName.contains(\"|\"))\n+                tagName = tagName.replace(\"|\", \":\");\n+\n+            evals.add(new Evaluator.Tag(tagName.trim()));\n+        }\n     }\n \n     private void byAttribute() {\n     }\n     \n     //pseudo selectors :first-child, :last-child, :nth-child, ...\n-    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n-    private static final Pattern NTH_B  = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\");\n+    private static final Pattern NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\");\n \n \tprivate void cssNthChild(boolean backwards, boolean ofType) {\n-\t\tString argS = tq.chompTo(\")\").trim().toLowerCase();\n+\t\tString argS = normalize(tq.chompTo(\")\"));\n \t\tMatcher mAB = NTH_AB.matcher(argS);\n \t\tMatcher mB = NTH_B.matcher(argS);\n \t\tfinal int a, b;\n             evals.add(new Evaluator.ContainsText(searchText));\n     }\n \n+    // pseudo selector :containsData(data)\n+    private void containsData() {\n+        tq.consume(\":containsData\");\n+        String searchText = TokenQueue.unescape(tq.chompBalanced('(', ')'));\n+        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n+        evals.add(new Evaluator.ContainsData(searchText));\n+    }\n+\n     // :matches(regex), matchesOwn(regex)\n     private void matches(boolean own) {\n         tq.consume(own ? \":matchesOwn\" : \":matches\");\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * \n  * <h2>Selector syntax</h2>\n  * <p>\n- * A selector is a chain of simple selectors, separated by combinators. Selectors are case insensitive (including against\n+ * A selector is a chain of simple selectors, separated by combinators. Selectors are <b>case insensitive</b> (including against\n  * elements, attributes, and attribute values).\n  * </p>\n  * <p>\n  * <tr><th align=\"left\">Pattern</th><th align=\"left\">Matches</th><th align=\"left\">Example</th></tr>\n  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n+ * <tr><td><code>*|E</code></td><td>elements of type E in any namespace <i>ns</i></td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  * <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  * <tr><td><code>:matchesOwn(<em>regex</em>)</code></td><td>elements whose own text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesOwn(\\\\d+)</code> finds table cells directly containing digits. <code>div:matchesOwn((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n+ * <tr><td><code>:containsData(<em>data</em>)</code></td><td>elements that contains the specified <em>data</em>. The contents of {@code script} and {@code style} elements, and {@code comment} nodes (etc) are considered data nodes, not text nodes. The search is case insensitive. The data may appear in the found element, or any of its descendants.</td><td><code>script:contains(jsoup)</code> finds script elements containing the data \"jsoup\".</td></tr>\n  * <tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n  * <tr><td colspan=\"3\"><h3>Structural pseudo selectors</h3></td></tr>\n  * <tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>\n         Validate.notEmpty(query);\n         Validate.notNull(roots);\n         Evaluator evaluator = QueryParser.parse(query);\n-        ArrayList<Element> elements = new ArrayList<Element>();\n-        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<Element, Boolean>();\n+        ArrayList<Element> elements = new ArrayList<>();\n+        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<>();\n         // dedupe elements by identity, not equality\n \n         for (Element root : roots) {\n--- /dev/null\n+++ b/src/test/java/org/jsoup/MultiLocaleRule.java\n+package org.jsoup;\n+\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.util.Locale;\n+\n+public class MultiLocaleRule implements TestRule {\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface MultiLocaleTest {\n+    }\n+\n+    public Statement apply(final Statement statement, final Description description) {\n+        return new Statement() {\n+            @Override\n+            public void evaluate() throws Throwable {\n+                MultiLocaleTest annotation = description.getAnnotation(MultiLocaleTest.class);\n+                if (annotation == null) {\n+                    statement.evaluate();\n+                    return;\n+                }\n+\n+                evaluateWithLocale(Locale.ENGLISH);\n+                evaluateWithLocale(new Locale(\"tr\"));\n+            }\n+\n+            private void evaluateWithLocale(Locale locale) throws Throwable {\n+                Locale oldLocale = Locale.getDefault();\n+                Locale.setDefault(locale);\n+                try {\n+                    statement.evaluate();\n+                } finally {\n+                    Locale.setDefault(oldLocale);\n+                }\n+            }\n+        };\n+    }\n+}\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n package org.jsoup.helper;\n \n-import java.io.UnsupportedEncodingException;\n+import org.jsoup.Jsoup;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.junit.Test;\n \n-import java.nio.ByteBuffer;\n-import java.nio.charset.Charset;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n \n-import static org.junit.Assert.*;\n+import static org.jsoup.integration.ParseTest.getFile;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n public class DataUtilTest {\n     @Test\n         assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html; charset='UTF-8'\"));\n     }\n \n-    @Test public void discardsSpuriousByteOrderMark() {\n+    private InputStream stream(String data) {\n+        return new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    private InputStream stream(String data, String charset) {\n+        try {\n+            return new ByteArrayInputStream(data.getBytes(charset));\n+        } catch (UnsupportedEncodingException e) {\n+            fail();\n+        }\n+        return null;\n+    }\n+\n+    @Test public void discardsSpuriousByteOrderMark() throws IOException {\n         String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n-        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n-        Document doc = DataUtil.parseByteData(buffer, \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n+        Document doc = DataUtil.parseInputStream(stream(html), \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n         assertEquals(\"One\", doc.head().text());\n     }\n \n-    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() {\n+    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() throws IOException {\n         String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n-        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n-        Document doc = DataUtil.parseByteData(buffer, null, \"http://foo.com/\", Parser.htmlParser());\n+        Document doc = DataUtil.parseInputStream(stream(html), null, \"http://foo.com/\", Parser.htmlParser());\n         assertEquals(\"One\", doc.head().text());\n         assertEquals(\"UTF-8\", doc.outputSettings().charset().displayName());\n     }\n     }\n     \n     @Test\n-    public void wrongMetaCharsetFallback() {\n-        try {\n-            final byte[] input = \"<html><head><meta charset=iso-8></head><body></body></html>\".getBytes(\"UTF-8\");\n-            final ByteBuffer inBuffer = ByteBuffer.wrap(input);\n-            \n-            Document doc = DataUtil.parseByteData(inBuffer, null, \"http://example.com\", Parser.htmlParser());\n-            \n-            final String expected = \"<html>\\n\" +\n-                                    \" <head>\\n\" +\n-                                    \"  <meta charset=\\\"iso-8\\\">\\n\" +\n-                                    \" </head>\\n\" +\n-                                    \" <body></body>\\n\" +\n-                                    \"</html>\";\n-            \n-            assertEquals(expected, doc.toString());\n-        } catch( UnsupportedEncodingException ex ) {\n-            fail(ex.getMessage());\n-        }\n+    public void wrongMetaCharsetFallback() throws IOException {\n+        String html = \"<html><head><meta charset=iso-8></head><body></body></html>\";\n+\n+        Document doc = DataUtil.parseInputStream(stream(html), null, \"http://example.com\", Parser.htmlParser());\n+\n+        final String expected = \"<html>\\n\" +\n+            \" <head>\\n\" +\n+            \"  <meta charset=\\\"iso-8\\\">\\n\" +\n+            \" </head>\\n\" +\n+            \" <body></body>\\n\" +\n+            \"</html>\";\n+\n+        assertEquals(expected, doc.toString());\n+    }\n+\n+    @Test\n+    public void secondMetaElementWithContentTypeContainsCharsetParameter() throws Exception {\n+        String html = \"<html><head>\" +\n+                \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html\\\">\" +\n+                \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=euc-kr\\\">\" +\n+                \"</head><body>\ud55c\uad6d\uc5b4</body></html>\";\n+\n+        Document doc = DataUtil.parseInputStream(stream(html, \"euc-kr\"), null, \"http://example.com\", Parser.htmlParser());\n+\n+        assertEquals(\"\ud55c\uad6d\uc5b4\", doc.body().text());\n+    }\n+\n+    @Test\n+    public void firstMetaElementWithCharsetShouldBeUsedForDecoding() throws Exception {\n+        String html = \"<html><head>\" +\n+                \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=iso-8859-1\\\">\" +\n+                \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-u\\\">\" +\n+                \"</head><body>\u00dcbergr\u00f6\u00dfentr\u00e4ger</body></html>\";\n+\n+        Document doc = DataUtil.parseInputStream(stream(html, \"iso-8859-1\"), null, \"http://example.com\", Parser.htmlParser());\n+\n+        assertEquals(\"\u00dcbergr\u00f6\u00dfentr\u00e4ger\", doc.body().text());\n+    }\n+\n+    @Test\n+    public void supportsBOMinFiles() throws IOException {\n+        // test files from http://www.i18nl10n.com/korean/utftest/\n+        File in = getFile(\"/bomtests/bom_utf16be.html\");\n+        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-16BE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+\n+        in = getFile(\"/bomtests/bom_utf16le.html\");\n+        doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-16LE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+\n+        in = getFile(\"/bomtests/bom_utf32be.html\");\n+        doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-32BE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n+\n+        in = getFile(\"/bomtests/bom_utf32le.html\");\n+        doc = Jsoup.parse(in, null, \"http://example.com\");\n+        assertTrue(doc.title().contains(\"UTF-32LE\"));\n+        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n     }\n }\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n package org.jsoup.helper;\n \n-import static org.junit.Assert.*;\n-\n+import org.jsoup.Connection;\n+import org.jsoup.MultiLocaleRule;\n+import org.jsoup.MultiLocaleRule.MultiLocaleTest;\n import org.jsoup.integration.ParseTest;\n+import org.junit.Rule;\n import org.junit.Test;\n-import org.jsoup.Connection;\n \n import java.io.IOException;\n-import java.util.*;\n+import java.net.MalformedURLException;\n import java.net.URL;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n public class HttpConnectionTest {\n     /* most actual network http connection tests are in integration */\n \n+    @Rule public MultiLocaleRule rule = new MultiLocaleRule();\n+\n     @Test(expected=IllegalArgumentException.class) public void throwsExceptionOnParseWithoutExecute() throws IOException {\n         Connection con = HttpConnection.connect(\"http://example.com\");\n         con.response().parse();\n         con.response().bodyAsBytes();\n     }\n \n-    @Test public void caseInsensitiveHeaders() {\n+    @Test @MultiLocaleTest public void caseInsensitiveHeaders() {\n         Connection.Response res = new HttpConnection.Response();\n         Map<String, String> headers = res.headers();\n         headers.put(\"Accept-Encoding\", \"gzip\");\n         assertTrue(res.hasHeader(\"Accept-Encoding\"));\n         assertTrue(res.hasHeader(\"accept-encoding\"));\n         assertTrue(res.hasHeader(\"accept-Encoding\"));\n+        assertTrue(res.hasHeader(\"ACCEPT-ENCODING\"));\n \n         assertEquals(\"gzip\", res.header(\"accept-Encoding\"));\n+        assertEquals(\"gzip\", res.header(\"ACCEPT-ENCODING\"));\n         assertEquals(\"text/html\", res.header(\"Content-Type\"));\n         assertEquals(\"http://example.com\", res.header(\"Referrer\"));\n \n         res.removeHeader(\"Content-Type\");\n         assertFalse(res.hasHeader(\"content-type\"));\n \n-        res.header(\"accept-encoding\", \"deflate\");\n+        res.removeHeader(\"ACCEPT-ENCODING\");\n+        assertFalse(res.hasHeader(\"Accept-Encoding\"));\n+\n+        res.header(\"ACCEPT-ENCODING\", \"deflate\");\n         assertEquals(\"deflate\", res.header(\"Accept-Encoding\"));\n         assertEquals(\"deflate\", res.header(\"accept-Encoding\"));\n+    }\n+\n+    @Test public void headers() {\n+        Connection con = HttpConnection.connect(\"http://example.com\");\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(\"content-type\", \"text/html\");\n+        headers.put(\"Connection\", \"keep-alive\");\n+        headers.put(\"Host\", \"http://example.com\");\n+        con.headers(headers);\n+        assertEquals(\"text/html\", con.request().header(\"content-type\"));\n+        assertEquals(\"keep-alive\", con.request().header(\"Connection\"));\n+        assertEquals(\"http://example.com\", con.request().header(\"Host\"));\n     }\n \n     @Test public void sameHeadersCombineWithComma() {\n \n     @Test public void userAgent() {\n         Connection con = HttpConnection.connect(\"http://example.com/\");\n+        assertEquals(HttpConnection.DEFAULT_UA, con.request().header(\"User-Agent\"));\n         con.userAgent(\"Mozilla\");\n         assertEquals(\"Mozilla\", con.request().header(\"User-Agent\"));\n     }\n \n     @Test public void timeout() {\n         Connection con = HttpConnection.connect(\"http://example.com/\");\n+        assertEquals(30 * 1000, con.request().timeout());\n         con.timeout(1000);\n         assertEquals(1000, con.request().timeout());\n     }\n         assertEquals(Connection.Method.POST, con.request().method());\n     }\n \n-    @Test(expected=IllegalArgumentException.class) public void throwsOnOdddData() {\n+    @Test(expected=IllegalArgumentException.class) public void throwsOnOddData() {\n         Connection con = HttpConnection.connect(\"http://example.com/\");\n         con.data(\"Name\", \"val\", \"what\");\n     }\n         assertEquals(\"two\", kv.value());\n         assertFalse(kv.hasInputStream());\n     }\n+\n+    @Test public void requestBody() {\n+        Connection con = HttpConnection.connect(\"http://example.com/\");\n+        con.requestBody(\"foo\");\n+        assertEquals(\"foo\", con.request().requestBody());\n+    }\n+\n+    @Test public void encodeUrl() throws MalformedURLException {\n+        URL url1 = new URL(\"http://test.com/?q=white space\");\n+        URL url2 = HttpConnection.encodeUrl(url1);\n+        assertEquals(\"http://test.com/?q=white%20space\", url2.toExternalForm());\n+    }\n }\n--- a/src/test/java/org/jsoup/helper/W3CDomTest.java\n+++ b/src/test/java/org/jsoup/helper/W3CDomTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.Element;\n import org.junit.Test;\n import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n \n import java.io.File;\n import java.io.IOException;\n \n import static org.jsoup.TextUtil.LE;\n-\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n \n         W3CDom w3c = new W3CDom();\n         Document wDoc = w3c.fromJsoup(doc);\n+        Node htmlEl = wDoc.getChildNodes().item(0);\n+        assertEquals(null, htmlEl.getNamespaceURI());\n+        assertEquals(\"html\", htmlEl.getLocalName());\n+        assertEquals(\"html\", htmlEl.getNodeName());\n+\n         String out = w3c.asString(wDoc);\n         assertTrue(out.contains(\"ipod\"));\n     }\n+\n+    @Test\n+    public void namespacePreservation() throws IOException {\n+        File in = ParseTest.getFile(\"/htmltests/namespaces.xhtml\");\n+        org.jsoup.nodes.Document jsoupDoc;\n+        jsoupDoc = Jsoup.parse(in, \"UTF-8\");\n+\n+        Document doc;\n+        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();\n+        doc = jDom.fromJsoup(jsoupDoc);\n+\n+        Node htmlEl = doc.getChildNodes().item(0);\n+        assertEquals(\"http://www.w3.org/1999/xhtml\", htmlEl.getNamespaceURI());\n+        assertEquals(\"html\", htmlEl.getLocalName());\n+        assertEquals(\"html\", htmlEl.getNodeName());\n+\n+        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);\n+        assertEquals(\"http://www.idpf.org/2007/ops\", epubTitle.getNamespaceURI());\n+        assertEquals(\"title\", epubTitle.getLocalName());\n+        assertEquals(\"epub:title\", epubTitle.getNodeName());\n+\n+        Node xSection = epubTitle.getNextSibling().getNextSibling();\n+        assertEquals(\"urn:test\", xSection.getNamespaceURI());\n+        assertEquals(\"section\", xSection.getLocalName());\n+        assertEquals(\"x:section\", xSection.getNodeName());\n+    }\n+\n+    @Test\n+    public void handlesInvalidAttributeNames() {\n+        String html = \"<html><head></head><body style=\\\"color: red\\\" \\\" name\\\"></body></html>\";\n+        org.jsoup.nodes.Document jsoupDoc;\n+        jsoupDoc = Jsoup.parse(html);\n+        Element body = jsoupDoc.select(\"body\").first();\n+        assertTrue(body.hasAttr(\"\\\"\")); // actually an attribute with key '\"'. Correct per HTML5 spec, but w3c xml dom doesn't dig it\n+        assertTrue(body.hasAttr(\"name\\\"\"));\n+\n+        Document w3Doc = new W3CDom().fromJsoup(jsoupDoc);\n+    }\n }\n \n--- a/src/test/java/org/jsoup/integration/ParseTest.java\n+++ b/src/test/java/org/jsoup/integration/ParseTest.java\n     public void testYahooArticle() throws IOException {\n         File in = getFile(\"/htmltests/yahoo-article-1.html\");\n         Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");\n-        Element p = doc.select(\"p:contains(Volt will be sold in the United States\").first();\n+        Element p = doc.select(\"p:contains(Volt will be sold in the United States)\").first();\n         assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n+    }\n+\n+    @Test\n+    public void testLowercaseUtf8Charset() throws IOException {\n+        File in = getFile(\"/htmltests/lowercase-charset-test.html\");\n+        Document doc = Jsoup.parse(in, null);\n+\n+        Element form = doc.select(\"#form\").first();\n+        assertEquals(2, form.children().size());\n+        assertEquals(\"UTF-8\", doc.outputSettings().charset().name());\n     }\n \n     public static File getFile(String resourceName) {\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n import java.net.MalformedURLException;\n+import java.net.Proxy;\n import java.net.URL;\n import java.util.Map;\n \n-import static org.hamcrest.core.Is.is;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests the URL connection. Not enabled by default, so tests don't require network connection.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n @Ignore // ignored by default so tests don't require network access. comment out to enable.\n+// todo: rebuild these into a local Jetty test server, so not reliant on the vagaries of the internet.\n public class UrlConnectTest {\n     private static final String WEBSITE_WITH_INVALID_CERTIFICATE = \"https://certs.cac.washington.edu/CAtest/\";\n     private static final String WEBSITE_WITH_SNI = \"https://jsoup.org/\";\n     private static String echoURL = \"http://direct.infohound.net/tools/q.pl\";\n+    public static String browserUa = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\";\n \n     @Test\n     public void fetchURl() throws IOException {\n-        String url = \"http://jsoup.org\"; // no trailing / to force redir\n+        String url = \"https://jsoup.org\"; // no trailing / to force redir\n         Document doc = Jsoup.parse(new URL(url), 10*1000);\n         assertTrue(doc.title().contains(\"jsoup\"));\n     }\n \n     @Test\n     public void ignoresContentTypeIfSoConfigured() throws IOException {\n-        Document doc = Jsoup.connect(\"http://jsoup.org/rez/osi_logo.png\").ignoreContentType(true).get();\n+        Document doc = Jsoup.connect(\"https://jsoup.org/rez/osi_logo.png\").ignoreContentType(true).get();\n         assertEquals(\"\", doc.title()); // this will cause an ugly parse tree\n     }\n \n         assertEquals(\"auth=token\", ihVal(\"HTTP_COOKIE\", doc));\n         assertEquals(\"\u5ea6\u4e00\u4e0b\", ihVal(\"\u767e\", doc));\n         assertEquals(\"Jsoup, Jonathan\", ihVal(\"uname\", doc));\n+    }\n+\n+    @Test\n+    public void sendsRequestBodyJsonWithData() throws IOException {\n+        final String body = \"{key:value}\";\n+        Document doc = Jsoup.connect(echoURL)\n+            .requestBody(body)\n+            .header(\"Content-Type\", \"application/json\")\n+            .userAgent(browserUa)\n+            .data(\"foo\", \"true\")\n+            .post();\n+        assertEquals(\"POST\", ihVal(\"REQUEST_METHOD\", doc));\n+        assertEquals(\"application/json\", ihVal(\"CONTENT_TYPE\", doc));\n+        assertEquals(\"foo=true\", ihVal(\"QUERY_STRING\", doc));\n+        assertEquals(body, doc.select(\"th:contains(POSTDATA) ~ td\").text());\n+    }\n+\n+    @Test\n+    public void sendsRequestBodyJsonWithoutData() throws IOException {\n+        final String body = \"{key:value}\";\n+        Document doc = Jsoup.connect(echoURL)\n+            .requestBody(body)\n+            .header(\"Content-Type\", \"application/json\")\n+            .userAgent(browserUa)\n+            .post();\n+        assertEquals(\"POST\", ihVal(\"REQUEST_METHOD\", doc));\n+        assertEquals(\"application/json\", ihVal(\"CONTENT_TYPE\", doc));\n+        assertEquals(body, doc.select(\"th:contains(POSTDATA) ~ td\").text());\n+    }\n+\n+    @Test\n+    public void sendsRequestBody() throws IOException {\n+        final String body = \"{key:value}\";\n+        Document doc = Jsoup.connect(echoURL)\n+            .requestBody(body)\n+            .header(\"Content-Type\", \"text/plain\")\n+            .userAgent(browserUa)\n+            .post();\n+        assertEquals(\"POST\", ihVal(\"REQUEST_METHOD\", doc));\n+        assertEquals(\"text/plain\", ihVal(\"CONTENT_TYPE\", doc));\n+        assertEquals(body, doc.select(\"th:contains(POSTDATA) ~ td\").text());\n+    }\n+\n+    @Test\n+    public void sendsRequestBodyWithUrlParams() throws IOException {\n+        final String body = \"{key:value}\";\n+        Document doc = Jsoup.connect(echoURL)\n+            .requestBody(body)\n+            .data(\"uname\", \"Jsoup\", \"uname\", \"Jonathan\", \"\u767e\", \"\u5ea6\u4e00\u4e0b\")\n+            .header(\"Content-Type\", \"text/plain\") // todo - if user sets content-type, we should append postcharset\n+            .userAgent(browserUa)\n+            .post();\n+        assertEquals(\"POST\", ihVal(\"REQUEST_METHOD\", doc));\n+        assertEquals(\"uname=Jsoup&uname=Jonathan&%E7%99%BE=%E5%BA%A6%E4%B8%80%E4%B8%8B\", ihVal(\"QUERY_STRING\", doc));\n+        assertEquals(body, ihVal(\"POSTDATA\", doc));\n     }\n \n     @Test\n         Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/307.pl\"); // http://jsoup.org\n         Document doc = con.get();\n         assertTrue(doc.title().contains(\"jsoup\"));\n-        assertEquals(\"http://jsoup.org\", con.response().url().toString());\n+        assertEquals(\"https://jsoup.org/\", con.response().url().toString());\n     }\n \n     @Test\n                 .data(\"Argument\", \"Riposte\")\n                 .method(Connection.Method.POST);\n         Connection.Response res = con.execute();\n-        assertEquals(\"http://jsoup.org\", res.url().toExternalForm());\n+        assertEquals(\"https://jsoup.org/\", res.url().toExternalForm());\n         assertEquals(Connection.Method.GET, res.method());\n     }\n \n     }\n \n     @Test\n-    public void ignores500NoWithContentExceptionIfSoConfigured() throws IOException {\n+    public void ignores500WithNoContentExceptionIfSoConfigured() throws IOException {\n         Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/500-no-content.pl\").ignoreHttpErrors(true);\n         Connection.Response res = con.execute();\n         Document doc = res.parse();\n     }\n \n     @Test\n-    public void ignores200NoWithContentExceptionIfSoConfigured() throws IOException {\n+    public void ignores200WithNoContentExceptionIfSoConfigured() throws IOException {\n         Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/200-no-content.pl\").ignoreHttpErrors(true);\n         Connection.Response res = con.execute();\n         Document doc = res.parse();\n         assertEquals(200, res.statusCode());\n         assertEquals(\"All Good\", res.statusMessage());\n+    }\n+\n+    @Test\n+    public void handles200WithNoContent() throws IOException {\n+        Connection con = Jsoup\n+            .connect(\"http://direct.infohound.net/tools/200-no-content.pl\")\n+            .userAgent(browserUa);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(200, res.statusCode());\n+\n+        con = Jsoup\n+            .connect(\"http://direct.infohound.net/tools/200-no-content.pl\")\n+            .parser(Parser.xmlParser())\n+            .userAgent(browserUa);\n+        res = con.execute();\n+        doc = res.parse();\n+        assertEquals(200, res.statusCode());\n     }\n \n     @Test\n         Connection.Response largeRes = Jsoup.connect(url).maxBodySize(300 * 1024).execute(); // does not crop\n         Connection.Response unlimitedRes = Jsoup.connect(url).maxBodySize(0).execute();\n \n-        int actualString = 280735;\n-        assertEquals(actualString, defaultRes.body().length());\n-        assertEquals(50 * 1024, smallRes.body().length());\n-        assertEquals(200 * 1024, mediumRes.body().length());\n-        assertEquals(actualString, largeRes.body().length());\n-        assertEquals(actualString, unlimitedRes.body().length());\n-\n         int actualDocText = 269541;\n         assertEquals(actualDocText, defaultRes.parse().text().length());\n-        assertEquals(49165, smallRes.parse().text().length());\n+        assertEquals(47200, smallRes.parse().text().length());\n         assertEquals(196577, mediumRes.parse().text().length());\n         assertEquals(actualDocText, largeRes.parse().text().length());\n         assertEquals(actualDocText, unlimitedRes.parse().text().length());\n     public void testSNIPass() throws Exception {\n         String url = WEBSITE_WITH_SNI;\n         Connection.Response defaultRes = Jsoup.connect(url).validateTLSCertificates(false).execute();\n-        assertThat(defaultRes.statusCode(), is(200));\n+        assertEquals(defaultRes.statusCode(), 200);\n     }\n \n     /**\n     public void testUnsafePass() throws Exception {\n         String url = WEBSITE_WITH_INVALID_CERTIFICATE;\n         Connection.Response defaultRes = Jsoup.connect(url).validateTLSCertificates(false).execute();\n-        assertThat(defaultRes.statusCode(), is(200));\n+        assertEquals(defaultRes.statusCode(), 200);\n     }\n \n     @Test\n \n         File uploadFile = ParseTest.getFile(\"/htmltests/google-ipod.html\");\n         FileInputStream stream = new FileInputStream(uploadFile);\n-\n-        // todo: need to add a better way to get an existing data field\n-        for (Connection.KeyVal keyVal : post.request().data()) {\n-            if (keyVal.key().equals(\"_file\")) {\n-                keyVal.value(\"check.html\");\n-                keyVal.inputStream(stream);\n-            }\n-        }\n+        \n+        Connection.KeyVal fileData = post.data(\"_file\");\n+        fileData.value(\"check.html\");\n+        fileData.inputStream(stream);\n \n         Connection.Response res;\n         try {\n     public void postJpeg() throws IOException {\n         File thumb = ParseTest.getFile(\"/htmltests/thumb.jpg\");\n         Document result = Jsoup\n-                .connect(\"http://regex.info/exif.cgi\")\n-                .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n-                .post();\n+            .connect(\"http://regex.info/exif.cgi\")\n+            .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n+            .userAgent(browserUa)\n+            .post();\n \n         assertEquals(\"Baseline DCT, Huffman coding\", result.select(\"td:contains(Process) + td\").text());\n+        assertEquals(\"1052 bytes 30 \u00d7 30\", result.select(\"td:contains(Size) + td\").text());\n     }\n \n     @Test\n     public void handles201Created() throws IOException {\n         Document doc = Jsoup.connect(\"http://direct.infohound.net/tools/201.pl\").get(); // 201, location=jsoup\n-        assertEquals(\"http://jsoup.org\", doc.location());\n+        assertEquals(\"https://jsoup.org/\", doc.location());\n     }\n \n     @Test\n     public void fetchToW3c() throws IOException {\n-        String url = \"http://jsoup.org\";\n+        String url = \"https://jsoup.org\";\n         Document doc = Jsoup.connect(url).get();\n \n         W3CDom dom = new W3CDom();\n         Document doc = response.parse();\n         assertEquals(\"\", doc.text());\n     }\n+\n+\n+    /*\n+     Proxy tests. Assumes local proxy running on 8888, without system propery set (so that specifying it is required).\n+     */\n+\n+    @Test\n+    public void fetchViaHttpProxy() throws IOException {\n+        String url = \"https://jsoup.org\";\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(\"localhost\", 8888));\n+        Document doc = Jsoup.connect(url).proxy(proxy).get();\n+        assertTrue(doc.title().contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void fetchViaHttpProxySetByArgument() throws IOException {\n+        String url = \"https://jsoup.org\";\n+        Document doc = Jsoup.connect(url).proxy(\"localhost\", 8888).get();\n+        assertTrue(doc.title().contains(\"jsoup\"));\n+    }\n+\n+    @Test\n+    public void invalidProxyFails() throws IOException {\n+        boolean caught = false;\n+        String url = \"https://jsoup.org\";\n+        try {\n+            Document doc = Jsoup.connect(url).proxy(\"localhost\", 8889).get();\n+        } catch (IOException e) {\n+            caught = e instanceof ConnectException;\n+        }\n+        assertTrue(caught);\n+    }\n+\n+    @Test\n+    public void proxyGetAndSet() throws IOException {\n+        String url = \"https://jsoup.org\";\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(\"localhost\", 8889)); // invalid\n+        final Connection con = Jsoup.connect(url).proxy(proxy);\n+\n+        assert con.request().proxy() == proxy;\n+        con.request().proxy(null); // disable\n+        Document doc = con.get();\n+        assertTrue(doc.title().contains(\"jsoup\")); // would fail if actually went via proxy\n+    }\n+\n+    @Test\n+    public void throwsIfRequestBodyForGet() throws IOException {\n+        boolean caught = false;\n+        String url = \"https://jsoup.org\";\n+        try {\n+            Document doc = Jsoup.connect(url).requestBody(\"fail\").get();\n+        } catch (IllegalArgumentException e) {\n+            caught = true;\n+        }\n+        assertTrue(caught);\n+    }\n+\n+    @Test\n+    public void canSpecifyResponseCharset() throws IOException {\n+        // both these docs have <80> in there as euro/control char depending on charset\n+        String noCharsetUrl = \"http://direct.infohound.net/tools/Windows-1252-nocharset.html\";\n+        String charsetUrl = \"http://direct.infohound.net/tools/Windows-1252-charset.html\";\n+\n+        // included in meta\n+        Connection.Response res1 = Jsoup.connect(charsetUrl).execute();\n+        assertEquals(null, res1.charset()); // not set in headers\n+        final Document doc1 = res1.parse();\n+        assertEquals(\"windows-1252\", doc1.charset().displayName()); // but determined at parse time\n+        assertEquals(\"Cost is \u20ac100\", doc1.select(\"p\").text());\n+        assertTrue(doc1.text().contains(\"\u20ac\"));\n+\n+        // no meta, no override\n+        Connection.Response res2 = Jsoup.connect(noCharsetUrl).execute();\n+        assertEquals(null, res2.charset()); // not set in headers\n+        final Document doc2 = res2.parse();\n+        assertEquals(\"UTF-8\", doc2.charset().displayName()); // so defaults to utf-8\n+        assertEquals(\"Cost is \ufffd100\", doc2.select(\"p\").text());\n+        assertTrue(doc2.text().contains(\"\ufffd\"));\n+\n+        // no meta, let's override\n+        Connection.Response res3 = Jsoup.connect(noCharsetUrl).execute();\n+        assertEquals(null, res3.charset()); // not set in headers\n+        res3.charset(\"windows-1252\");\n+        assertEquals(\"windows-1252\", res3.charset()); // read back\n+        final Document doc3 = res3.parse();\n+        assertEquals(\"windows-1252\", doc3.charset().displayName()); // from override\n+        assertEquals(\"Cost is \u20ac100\", doc3.select(\"p\").text());\n+        assertTrue(doc3.text().contains(\"\u20ac\"));\n+    }\n+\n+    @Test\n+    public void handlesUnescapedRedirects() throws IOException {\n+        // URL locations should be url safe (ascii) but are often not, so we should try to guess\n+        // in this case the location header is utf-8, but defined in spec as iso8859, so detect, convert, encode\n+        String url = \"http://direct.infohound.net/tools/302-utf.pl\";\n+        String urlEscaped = \"http://direct.infohound.net/tools/test%F0%9F%92%A9.html\";\n+\n+        Connection.Response res = Jsoup.connect(url).execute();\n+        Document doc = res.parse();\n+        assertEquals(doc.body().text(), \"\\uD83D\\uDCA9!\");\n+        assertEquals(doc.location(), urlEscaped);\n+\n+        Connection.Response res2 = Jsoup.connect(url).followRedirects(false).execute();\n+        assertEquals(\"/tools/test\\uD83D\\uDCA9.html\", res2.header(\"Location\"));\n+        // if we didn't notice it was utf8, would look like: Location: /tools/test\u00f0\u009f\u0092\u00a9.html\n+    }\n+\n+    @Test public void handlesEscapesInRedirecct() throws IOException {\n+        Document doc = Jsoup.connect(\"http://infohound.net/tools/302-escaped.pl\").get();\n+        assertEquals(\"http://infohound.net/tools/q.pl?q=one%20two\", doc.location());\n+\n+        doc = Jsoup.connect(\"http://infohound.net/tools/302-white.pl\").get();\n+        assertEquals(\"http://infohound.net/tools/q.pl?q=one%20two\", doc.location());\n+    }\n+\n+    @Test\n+    public void handlesUt8fInUrl() throws IOException {\n+        String url = \"http://direct.infohound.net/tools/test\\uD83D\\uDCA9.html\";\n+        String urlEscaped = \"http://direct.infohound.net/tools/test%F0%9F%92%A9.html\";\n+\n+        Connection.Response res = Jsoup.connect(url).execute();\n+        Document doc = res.parse();\n+        assertEquals(\"\\uD83D\\uDCA9!\", doc.body().text());\n+        assertEquals(urlEscaped, doc.location());\n+    }\n+\n+    @Test\n+    public void inWildUtfRedirect() throws IOException {\n+        Connection.Response res = Jsoup.connect(\"http://brabantn.ws/Q4F\").execute();\n+        Document doc = res.parse();\n+        assertEquals(\n+            \"http://www.omroepbrabant.nl/?news/2474781303/Gestrande+ree+in+Oss+niet+verdoofd,+maar+doodgeschoten+%E2%80%98Dit+kan+gewoon+niet,+bizar%E2%80%99+[VIDEO].aspx\",\n+            doc.location()\n+            );\n+    }\n+\n+    @Test\n+    public void inWildUtfRedirect2() throws IOException {\n+        Connection.Response res = Jsoup.connect(\"https://ssl.souq.com/sa-en/2724288604627/s\").execute();\n+        Document doc = res.parse();\n+        assertEquals(\n+            \"https://saudi.souq.com/sa-en/%D8%AE%D8%B2%D9%86%D8%A9-%D8%A2%D9%85%D9%86%D8%A9-3-%D8%B7%D8%A8%D9%82%D8%A7%D8%AA-%D8%A8%D9%86%D8%B8%D8%A7%D9%85-%D9%82%D9%81%D9%84-%D8%A5%D9%84%D9%83%D8%AA%D8%B1%D9%88%D9%86%D9%8A-bsd11523-6831477/i/?ctype=dsrch\",\n+            doc.location()\n+        );\n+    }\n+\n+    @Test public void canInterruptBodyStringRead() throws IOException, InterruptedException {\n+        // todo - implement in interruptable channels, so it's immediate\n+        final String[] body = new String[1];\n+        Thread runner = new Thread(new Runnable() {\n+            public void run() {\n+                try {\n+                    Connection.Response res = Jsoup.connect(\"http://jsscxml.org/serverload.stream\")\n+                        .timeout(15 * 1000)\n+                        .execute();\n+                    body[0] = res.body();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+            }\n+        });\n+\n+        runner.start();\n+        Thread.sleep(1000 * 7);\n+        runner.interrupt();\n+        assertTrue(runner.isInterrupted());\n+        runner.join();\n+\n+        assertTrue(body[0].length() > 0);\n+    }\n+\n+    @Test public void canInterruptDocumentRead() throws IOException, InterruptedException {\n+        // todo - implement in interruptable channels, so it's immediate\n+        final String[] body = new String[1];\n+        Thread runner = new Thread(new Runnable() {\n+            public void run() {\n+                try {\n+                    Connection.Response res = Jsoup.connect(\"http://jsscxml.org/serverload.stream\")\n+                        .timeout(15 * 1000)\n+                        .execute();\n+                    body[0] = res.parse().text();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+            }\n+        });\n+\n+        runner.start();\n+        Thread.sleep(1000 * 7);\n+        runner.interrupt();\n+        assertTrue(runner.isInterrupted());\n+        runner.join();\n+\n+        assertTrue(body[0].length() > 0);\n+    }\n+\n+    @Test public void handlesEscapedRedirectUrls() throws IOException {\n+        String url = \"http://www.altalex.com/documents/news/2016/12/06/questioni-civilistiche-conseguenti-alla-depenalizzazione\";\n+        // sends: Location:http://shop.wki.it/shared/sso/sso.aspx?sso=&url=http%3a%2f%2fwww.altalex.com%2fsession%2fset%2f%3freturnurl%3dhttp%253a%252f%252fwww.altalex.com%253a80%252fdocuments%252fnews%252f2016%252f12%252f06%252fquestioni-civilistiche-conseguenti-alla-depenalizzazione\n+        // then to: http://www.altalex.com/session/set/?returnurl=http%3a%2f%2fwww.altalex.com%3a80%2fdocuments%2fnews%2f2016%2f12%2f06%2fquestioni-civilistiche-conseguenti-alla-depenalizzazione&sso=RDRG6T684G4AK2E7U591UGR923\n+        // then : http://www.altalex.com:80/documents/news/2016/12/06/questioni-civilistiche-conseguenti-alla-depenalizzazione\n+\n+        // bug is that jsoup goes to\n+        // \tGET /shared/sso/sso.aspx?sso=&url=http%253a%252f%252fwww.altalex.com%252fsession%252fset%252f%253freturnurl%253dhttp%25253a%25252f%25252fwww.altalex.com%25253a80%25252fdocuments%25252fnews%25252f2016%25252f12%25252f06%25252fquestioni-civilistiche-conseguenti-alla-depenalizzazione HTTP/1.1\n+        // i.e. double escaped\n+\n+        Connection.Response res = Jsoup.connect(url)\n+                .proxy(\"localhost\", 8888)\n+                .execute();\n+        Document doc = res.parse();\n+        assertEquals(200, res.statusCode());\n+    }\n+\n+    @Test public void handlesUnicodeInQuery() throws IOException {\n+        Document doc = Jsoup.connect(\"https://www.google.pl/search?q=g\u0105ska\").get();\n+        assertEquals(\"g\u0105ska - Szukaj w Google\", doc.title());\n+\n+        doc = Jsoup.connect(\"http://mov-world.net/archiv/TV/A/%23No.Title/\").get();\n+        assertEquals(\"Index of /archiv/TV/A/%23No.Title\", doc.title());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) public void bodyAfterParseThrowsValidationError() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute();\n+        Document doc = res.parse();\n+        String body = res.body();\n+    }\n+\n+    @Test public void bodyAndBytesAvailableBeforeParse() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute();\n+        String body = res.body();\n+        assertTrue(body.contains(\"Environment\"));\n+        byte[] bytes = res.bodyAsBytes();\n+        assertTrue(bytes.length > 100);\n+\n+        Document doc = res.parse();\n+        assertTrue(doc.title().contains(\"Environment\"));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) public void parseParseThrowsValidates() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute();\n+        Document doc = res.parse();\n+        assertTrue(doc.title().contains(\"Environment\"));\n+        Document doc2 = res.parse(); // should blow up because the response input stream has been drained\n+    }\n+\n+    @Test public void multipleParsesOkAfterBufferUp() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute().bufferUp();\n+\n+        Document doc = res.parse();\n+        assertTrue(doc.title().contains(\"Environment\"));\n+\n+        Document doc2 = res.parse();\n+        assertTrue(doc2.title().contains(\"Environment\"));\n+    }\n+\n }\n--- a/src/test/java/org/jsoup/nodes/AttributesTest.java\n+++ b/src/test/java/org/jsoup/nodes/AttributesTest.java\n package org.jsoup.nodes;\n \n-import static org.junit.Assert.*;\n+import org.junit.Test;\n \n-import org.junit.Test;\n+import java.util.Iterator;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  * Tests for Attributes.\n  * @author Jonathan Hedley\n  */\n public class AttributesTest {\n-    @Test public void html() {\n+\n+    @Test\n+    public void html() {\n         Attributes a = new Attributes();\n         a.put(\"Tot\", \"a&p\");\n         a.put(\"Hello\", \"There\");\n         a.put(\"data-name\", \"Jsoup\");\n \n         assertEquals(3, a.size());\n-        assertTrue(a.hasKey(\"tot\"));\n+        assertTrue(a.hasKey(\"Tot\"));\n         assertTrue(a.hasKey(\"Hello\"));\n         assertTrue(a.hasKey(\"data-name\"));\n+        assertFalse(a.hasKey(\"tot\"));\n+        assertTrue(a.hasKeyIgnoreCase(\"tot\"));\n+        assertEquals(\"There\", a.getIgnoreCase(\"hEllo\"));\n+\n         assertEquals(1, a.dataset().size());\n         assertEquals(\"Jsoup\", a.dataset().get(\"name\"));\n-        assertEquals(\"a&p\", a.get(\"tot\"));\n+        assertEquals(\"\", a.get(\"tot\"));\n+        assertEquals(\"a&p\", a.get(\"Tot\"));\n+        assertEquals(\"a&p\", a.getIgnoreCase(\"tot\"));\n \n-        assertEquals(\" tot=\\\"a&amp;p\\\" hello=\\\"There\\\" data-name=\\\"Jsoup\\\"\", a.html());\n+        assertEquals(\" Tot=\\\"a&amp;p\\\" Hello=\\\"There\\\" data-name=\\\"Jsoup\\\"\", a.html());\n         assertEquals(a.html(), a.toString());\n     }\n \n+    @Test\n+    public void testIteratorRemovable() {\n+        Attributes a = new Attributes();\n+        a.put(\"Tot\", \"a&p\");\n+        a.put(\"Hello\", \"There\");\n+        a.put(\"data-name\", \"Jsoup\");\n+\n+        Iterator<Attribute> iterator = a.iterator();\n+        iterator.next();\n+        iterator.remove();\n+        assertEquals(2, a.size());\n+    }\n+\n+    @Test\n+    public void testIterator() {\n+        Attributes a = new Attributes();\n+        String[][] datas = {{\"Tot\", \"raul\"},\n+            {\"Hello\", \"pismuth\"},\n+            {\"data-name\", \"Jsoup\"}};\n+        for (String[] atts : datas) {\n+            a.put(atts[0], atts[1]);\n+        }\n+\n+        Iterator<Attribute> iterator = a.iterator();\n+        assertTrue(iterator.hasNext());\n+        int i = 0;\n+        for (Attribute attribute : a) {\n+            assertEquals(datas[i][0], attribute.getKey());\n+            assertEquals(datas[i][1], attribute.getValue());\n+            i++;\n+        }\n+        assertEquals(datas.length, i);\n+    }\n+\n+    @Test\n+    public void testIteratorEmpty() {\n+        Attributes a = new Attributes();\n+\n+        Iterator<Attribute> iterator = a.iterator();\n+        assertFalse(iterator.hasNext());\n+    }\n+\n+    @Test\n+    public void removeCaseSensitive() {\n+        Attributes a = new Attributes();\n+        a.put(\"Tot\", \"a&p\");\n+        a.put(\"tot\", \"one\");\n+        a.put(\"Hello\", \"There\");\n+        a.put(\"hello\", \"There\");\n+        a.put(\"data-name\", \"Jsoup\");\n+\n+        assertEquals(5, a.size());\n+        a.remove(\"Tot\");\n+        a.remove(\"Hello\");\n+        assertEquals(3, a.size());\n+        assertTrue(a.hasKey(\"tot\"));\n+        assertFalse(a.hasKey(\"Tot\"));\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/nodes/BuildEntities.java\n+package org.jsoup.nodes;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import org.jsoup.Connection;\n+import org.jsoup.Jsoup;\n+import org.jsoup.integration.UrlConnectTest;\n+import org.jsoup.nodes.Entities;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+\n+/**\n+ * Fetches HTML entity names from w3.org json, and outputs data files for optimized used in Entities.\n+ * I refuse to believe that entity names like \"NotNestedLessLess\" are valuable or useful for HTML authors. Implemented\n+ * only to be complete.\n+ */\n+class BuildEntities {\n+    private static final String projectDir = \"/Users/jhy/projects/jsoup\";\n+\n+    public static void main(String[] args) throws IOException {\n+        String url = \"https://www.w3.org/TR/2012/WD-html5-20121025/entities.json\";\n+        Connection.Response res = Jsoup.connect(url)\n+            .ignoreContentType(true)\n+            .userAgent(UrlConnectTest.browserUa)\n+            .execute();\n+\n+        Gson gson = new Gson();\n+        Map<String, CharacterRef> input = gson.fromJson(res.body(),\n+            new TypeToken<Map<String, CharacterRef>>() {\n+            }.getType());\n+\n+\n+        // build name sorted base and full character lists:\n+        ArrayList<CharacterRef> base = new ArrayList<CharacterRef>();\n+        ArrayList<CharacterRef> full = new ArrayList<CharacterRef>();\n+\n+        for (Map.Entry<String, CharacterRef> entry : input.entrySet()) {\n+            String name = entry.getKey().substring(1); // name is like &acute or &acute; , trim &\n+            CharacterRef ref = entry.getValue();\n+            if (name.endsWith(\";\")) {\n+                name = name.substring(0, name.length() - 1);\n+                full.add(ref);\n+            } else {\n+                base.add(ref);\n+            }\n+            ref.name = name;\n+        }\n+        Collections.sort(base, byName);\n+        Collections.sort(full, byName);\n+\n+        // now determine code point order\n+        ArrayList<CharacterRef> baseByCode = new ArrayList<CharacterRef>(base);\n+        ArrayList<CharacterRef> fullByCode = new ArrayList<CharacterRef>(full);\n+        Collections.sort(baseByCode, byCode);\n+        Collections.sort(fullByCode, byCode);\n+\n+        // and update their codepoint index. Don't\n+        ArrayList<CharacterRef>[] codelists = new ArrayList[]{baseByCode, fullByCode};\n+        for (ArrayList<CharacterRef> codelist : codelists) {\n+            for (int i = 0; i < codelist.size(); i++) {\n+                codelist.get(i).codeIndex = i;\n+            }\n+        }\n+\n+        // now write them\n+        persist(\"entities-full.properties\", full);\n+        persist(\"entities-base.properties\", base);\n+\n+        System.out.println(\"Full size: \" + full.size() + \", base size: \" + base.size());\n+    }\n+\n+    private static void persist(String name, ArrayList<CharacterRef> refs) throws IOException {\n+        String base = projectDir + \"/src/main/java/org/jsoup/nodes\";\n+        File file = new File(base, name);\n+        FileWriter writer = new FileWriter(file, false);\n+        for (CharacterRef ref : refs) {\n+            writer.append(ref.toString()).append(\"\\n\");\n+        }\n+        writer.close();\n+    }\n+\n+\n+    private static class CharacterRef {\n+        int[] codepoints;\n+        String name;\n+        int codeIndex;\n+\n+        @Override\n+        public String toString() {\n+            return name\n+                + \"=\"\n+                + d(codepoints[0])\n+                + (codepoints.length > 1 ? \",\" + d(codepoints[1]) : \"\")\n+                + \";\" + d(codeIndex);\n+        }\n+    }\n+\n+    private static String d(int d) {\n+        return Integer.toString(d, Entities.codepointRadix);\n+    }\n+\n+    private static class ByName implements Comparator<CharacterRef> {\n+        public int compare(CharacterRef o1, CharacterRef o2) {\n+            return o1.name.compareTo(o2.name);\n+        }\n+    }\n+\n+    private static class ByCode implements Comparator<CharacterRef> {\n+        public int compare(CharacterRef o1, CharacterRef o2) {\n+            int[] c1 = o1.codepoints;\n+            int[] c2 = o2.codepoints;\n+            int first = c1[0] - c2[0];\n+            if (first != 0)\n+                return first;\n+            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name\n+                int len = o2.name.length() - o1.name.length();\n+                if (len != 0)\n+                    return len;\n+                return o1.name.compareTo(o2.name);\n+            }\n+            if (c1.length == 2 && c2.length == 2)\n+                return c1[1] - c2[1];\n+            else\n+                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)\n+        }\n+    }\n+\n+    private static ByName byName = new ByName();\n+    private static ByCode byCode = new ByCode();\n+}\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n package org.jsoup.nodes;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.TextUtil;\n+import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.Document.OutputSettings;\n+import org.jsoup.nodes.Document.OutputSettings.Syntax;\n+import org.junit.Ignore;\n+import org.junit.Test;\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.StringWriter;\n import java.nio.charset.Charset;\n-import org.jsoup.Jsoup;\n-import org.jsoup.TextUtil;\n-import org.jsoup.integration.ParseTest;\n-import org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.*;\n-import org.junit.Ignore;\n-import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests for Document.\n         Document doc = Jsoup.parse(\"x\");\n         assertEquals(Syntax.html, doc.outputSettings().syntax());\n     }\n+    \n+    @Test public void testHtmlAppendable() {\n+    \tString htmlContent = \"<html><head><title>Hello</title></head><body><p>One</p><p>Two</p></body></html>\";\n+    \tDocument document = Jsoup.parse(htmlContent);\n+    \tOutputSettings outputSettings = new OutputSettings();\n+    \t\n+    \toutputSettings.prettyPrint(false);\n+    \tdocument.outputSettings(outputSettings);\n+    \tassertEquals(htmlContent, document.html(new StringWriter()).toString());\n+    }\n \n     // Ignored since this test can take awhile to run.\n     @Ignore\n         Document docB = Jsoup.parse(\"<div/>One\");\n         Document docC = Jsoup.parse(\"<div/>Two\");\n \n-        assertEquals(docA, docB);\n-        assertFalse(docA.equals(docC));\n-        assertEquals(docA.hashCode(), docB.hashCode());\n+        assertFalse(docA.equals(docB));\n+        assertTrue(docA.equals(docA));\n+        assertEquals(docA.hashCode(), docA.hashCode());\n         assertFalse(docA.hashCode() == docC.hashCode());\n+    }\n+\n+    @Test public void DocumentsWithSameContentAreVerifialbe() throws Exception {\n+        Document docA = Jsoup.parse(\"<div/>One\");\n+        Document docB = Jsoup.parse(\"<div/>One\");\n+        Document docC = Jsoup.parse(\"<div/>Two\");\n+\n+        assertTrue(docA.hasSameValue(docB));\n+        assertFalse(docA.hasSameValue(docC));\n     }\n     \n     @Test\n         doc.updateMetaCharsetElement(true);\n         doc.charset(Charset.forName(charsetUtf8));\n         \n-        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\"?>\\n\" +\n                                         \"<root>\\n\" +\n                                         \" node\\n\" +\n                                         \"</root>\";\n         doc.updateMetaCharsetElement(true);\n         doc.charset(Charset.forName(charsetIso8859));\n         \n-        final String xmlCharsetISO = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+        final String xmlCharsetISO = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetIso8859 + \"\\\"?>\\n\" +\n                                         \"<root>\\n\" +\n                                         \" node\\n\" +\n                                         \"</root>\";\n         doc.updateMetaCharsetElement(true);\n         doc.charset(Charset.forName(charsetUtf8));\n         \n-        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\"?>\\n\" +\n                                         \"<root>\\n\" +\n                                         \" node\\n\" +\n                                         \"</root>\";\n     public void testMetaCharsetUpdateXmlDisabledNoChanges() {\n         final Document doc = createXmlDocument(\"dontTouch\", \"dontTouch\", true);\n         \n-        final String xmlCharset = \"<?xml version=\\\"dontTouch\\\" encoding=\\\"dontTouch\\\">\\n\" +\n+        final String xmlCharset = \"<?xml version=\\\"dontTouch\\\" encoding=\\\"dontTouch\\\"?>\\n\" +\n                                     \"<root>\\n\" +\n                                     \" node\\n\" +\n                                     \"</root>\";\n--- a/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n package org.jsoup.nodes;\n \n+import org.jsoup.Jsoup;\n+import org.jsoup.parser.Parser;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n         DocumentType combo = new DocumentType(\"notHtml\", \"--public\", \"--system\", \"\");\n         assertEquals(\"<!DOCTYPE notHtml PUBLIC \\\"--public\\\" \\\"--system\\\">\", combo.outerHtml());\n     }\n+\n+    @Test public void testRoundTrip() {\n+        String base = \"<!DOCTYPE html>\";\n+        assertEquals(\"<!doctype html>\", htmlOutput(base));\n+        assertEquals(base, xmlOutput(base));\n+\n+        String publicDoc = \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\";\n+        assertEquals(publicDoc, htmlOutput(publicDoc));\n+        assertEquals(publicDoc, xmlOutput(publicDoc));\n+\n+        String systemDoc = \"<!DOCTYPE html SYSTEM \\\"exampledtdfile.dtd\\\">\";\n+        assertEquals(systemDoc, htmlOutput(systemDoc));\n+        assertEquals(systemDoc, xmlOutput(systemDoc));\n+\n+        String legacyDoc = \"<!DOCTYPE html SYSTEM \\\"about:legacy-compat\\\">\";\n+        assertEquals(legacyDoc, htmlOutput(legacyDoc));\n+        assertEquals(legacyDoc, xmlOutput(legacyDoc));\n+    }\n+\n+    private String htmlOutput(String in) {\n+        DocumentType type = (DocumentType) Jsoup.parse(in).childNode(0);\n+        return type.outerHtml();\n+    }\n+\n+    private String xmlOutput(String in) {\n+        return Jsoup.parse(in, \"\", Parser.xmlParser()).childNode(0).outerHtml();\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.hamcrest.CoreMatchers.not;\n-import static org.junit.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.Map;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n /**\n  * Tests for Element (DOM stuff mostly).\n         assertEquals(0, classes.size());\n         assertFalse(doc.hasClass(\"mellow\"));\n     }\n-\n+    \n+    @Test public void testHasClassDomMethods() {\n+        Tag tag = Tag.valueOf(\"a\");\n+        Attributes attribs = new Attributes();\n+        Element el = new Element(tag, \"\", attribs);\n+        \n+        attribs.put(\"class\", \"toto\");\n+        boolean hasClass = el.hasClass(\"toto\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \" toto\");\n+        hasClass = el.hasClass(\"toto\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \"toto \");\n+        hasClass = el.hasClass(\"toto\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \"\\ttoto \");\n+        hasClass = el.hasClass(\"toto\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \"  toto \");\n+        hasClass = el.hasClass(\"toto\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \"ab\");\n+        hasClass = el.hasClass(\"toto\");\n+        assertFalse(hasClass);\n+        \n+        attribs.put(\"class\", \"     \");\n+        hasClass = el.hasClass(\"toto\");\n+        assertFalse(hasClass);\n+        \n+        attribs.put(\"class\", \"tototo\");\n+        hasClass = el.hasClass(\"toto\");\n+        assertFalse(hasClass);\n+        \n+        attribs.put(\"class\", \"raulpismuth  \");\n+        hasClass = el.hasClass(\"raulpismuth\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \" abcd  raulpismuth efgh \");\n+        hasClass = el.hasClass(\"raulpismuth\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \" abcd efgh raulpismuth\");\n+        hasClass = el.hasClass(\"raulpismuth\");\n+        assertTrue(hasClass);\n+        \n+        attribs.put(\"class\", \" abcd efgh raulpismuth \");\n+        hasClass = el.hasClass(\"raulpismuth\");\n+        assertTrue(hasClass);\n+    }\n+\n+    \n     @Test public void testClassUpdates() {\n         Document doc = Jsoup.parse(\"<div class='mellow yellow'></div>\");\n         Element div = doc.select(\"div\").first();\n         Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n         Element div = doc.getElementById(\"1\");\n         div.appendElement(\"p\").text(\"there\");\n-        div.appendElement(\"P\").attr(\"class\", \"second\").text(\"now\");\n-        assertEquals(\"<html><head></head><body><div id=\\\"1\\\"><p>Hello</p><p>there</p><p class=\\\"second\\\">now</p></div></body></html>\",\n+        div.appendElement(\"P\").attr(\"CLASS\", \"second\").text(\"now\");\n+        // manually specifying tag and attributes should now preserve case, regardless of parse mode\n+        assertEquals(\"<html><head></head><body><div id=\\\"1\\\"><p>Hello</p><p>there</p><P CLASS=\\\"second\\\">now</P></div></body></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n \n         // check sibling index (with short circuit on reindexChildren):\n         div.prependText(\"there & now > \");\n         assertEquals(\"there & now > Hello\", div.text());\n         assertEquals(\"there &amp; now &gt; <p>Hello</p>\", TextUtil.stripNewlines(div.html()));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class) public void testThrowsOnAddNullText() {\n+        Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n+        Element div = doc.getElementById(\"1\");\n+        div.appendText(null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)  public void testThrowsOnPrependNullText() {\n+        Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n+        Element div = doc.getElementById(\"1\");\n+        div.prependText(null);\n     }\n     \n     @Test public void testAddNewHtml() {\n         }\n \n         try {\n-            div2.insertChildren(0, null);\n+            div2.insertChildren(0, (Collection<? extends Node>) null);\n             fail();\n         } catch (IllegalArgumentException e) {\n         }\n     }\n \n     @Test\n-    public void testHashAndEquals() {\n+    public void testHashAndEqualsAndValue() {\n+        // .equals and hashcode are identity. value is content.\n+\n         String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n                 \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n \n         Element e6 = els.get(6);\n         Element e7 = els.get(7);\n \n-        assertEquals(e0, e1);\n-        assertEquals(e0, e4);\n-        assertEquals(e0, e5);\n+        assertEquals(e0, e0);\n+        assertTrue(e0.hasSameValue(e1));\n+        assertTrue(e0.hasSameValue(e4));\n+        assertTrue(e0.hasSameValue(e5));\n         assertFalse(e0.equals(e2));\n-        assertFalse(e0.equals(e3));\n-        assertFalse(e0.equals(e6));\n-        assertFalse(e0.equals(e7));\n-\n-        assertEquals(e0.hashCode(), e1.hashCode());\n-        assertEquals(e0.hashCode(), e4.hashCode());\n-        assertEquals(e0.hashCode(), e5.hashCode());\n+        assertFalse(e0.hasSameValue(e2));\n+        assertFalse(e0.hasSameValue(e3));\n+        assertFalse(e0.hasSameValue(e6));\n+        assertFalse(e0.hasSameValue(e7));\n+\n+        assertEquals(e0.hashCode(), e0.hashCode());\n         assertFalse(e0.hashCode() == (e2.hashCode()));\n         assertFalse(e0.hashCode() == (e3).hashCode());\n         assertFalse(e0.hashCode() == (e6).hashCode());\n         assertEquals(\"http://example.com/three.html\", els.get(2).absUrl(\"href\"));\n         assertEquals(\"http://example2.com/four/\", els.get(3).absUrl(\"href\"));\n         assertEquals(\"https://example2.com/five/\", els.get(4).absUrl(\"href\"));\n+    }\n+\n+    @Test\n+    public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {\n+        Document doc = new Document(\"\");\n+        Element body = doc.appendElement(\"body\");\n+        body.appendElement(\"div1\");\n+        body.appendElement(\"div2\");\n+        final Element div3 = body.appendElement(\"div3\");\n+        div3.text(\"Check\");\n+        final Element div4 = body.appendElement(\"div4\");\n+\n+        ArrayList<Element> toMove = new ArrayList<Element>();\n+        toMove.add(div3);\n+        toMove.add(div4);\n+\n+        body.insertChildren(0, toMove);\n+\n+        String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n+        assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);\n+    }\n+\n+    @Test\n+    public void testHashcodeIsStableWithContentChanges() {\n+        Element root = new Element(Tag.valueOf(\"root\"), \"\");\n+\n+        HashSet<Element> set = new HashSet<Element>();\n+        // Add root node:\n+        set.add(root);\n+\n+        root.appendChild(new Element(Tag.valueOf(\"a\"), \"\"));\n+        assertTrue(set.contains(root));\n+    }\n+\n+    @Test\n+    public void testNamespacedElements() {\n+        // Namespaces with ns:tag in HTML must be translated to ns|tag in CSS.\n+        String html = \"<html><body><fb:comments /></body></html>\";\n+        Document doc = Jsoup.parse(html, \"http://example.com/bar/\");\n+        Elements els = doc.select(\"fb|comments\");\n+        assertEquals(1, els.size());\n+        assertEquals(\"html > body > fb|comments\", els.get(0).cssSelector());\n+    }\n+\n+    @Test\n+    public void testChainedRemoveAttributes() {\n+        String html = \"<a one two three four>Text</a>\";\n+        Document doc = Jsoup.parse(html);\n+        Element a = doc.select(\"a\").first();\n+        a\n+            .removeAttr(\"zero\")\n+            .removeAttr(\"one\")\n+            .removeAttr(\"two\")\n+            .removeAttr(\"three\")\n+            .removeAttr(\"four\")\n+            .removeAttr(\"five\");\n+        assertEquals(\"<a>Text</a>\", a.outerHtml());\n+    }\n+\n+    @Test\n+    public void testLoopedRemoveAttributes() {\n+        String html = \"<a one two three four>Text</a><p foo>Two</p>\";\n+        Document doc = Jsoup.parse(html);\n+        for (Element el : doc.getAllElements()) {\n+            el.clearAttributes();\n+        }\n+\n+        assertEquals(\"<a>Text</a>\\n<p>Two</p>\", doc.body().html());\n+    }\n+\n+    @Test\n+    public void testIs() {\n+        String html = \"<div><p>One <a class=big>Two</a> Three</p><p>Another</p>\";\n+        Document doc = Jsoup.parse(html);\n+        Element p = doc.select(\"p\").first();\n+\n+        assertTrue(p.is(\"p\"));\n+        assertFalse(p.is(\"div\"));\n+        assertTrue(p.is(\"p:has(a)\"));\n+        assertTrue(p.is(\"p:first-child\"));\n+        assertFalse(p.is(\"p:last-child\"));\n+        assertTrue(p.is(\"*\"));\n+        assertTrue(p.is(\"div p\"));\n+\n+        Element q = doc.select(\"p\").last();\n+        assertTrue(q.is(\"p\"));\n+        assertTrue(q.is(\"p ~ p\"));\n+        assertTrue(q.is(\"p + p\"));\n+        assertTrue(q.is(\"p:last-child\"));\n+        assertFalse(q.is(\"p a\"));\n+        assertFalse(q.is(\"a\"));\n+    }\n+\n+\n+    @Test public void elementByTagName() {\n+        Element a = new Element(\"P\");\n+        assertTrue(a.tagName().equals(\"P\"));\n+    }\n+\n+    @Test public void testChildrenElements() {\n+        String html = \"<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>\";\n+        Document doc = Jsoup.parse(html);\n+        Element div = doc.select(\"div\").first();\n+        Element p = doc.select(\"p\").first();\n+        Element span = doc.select(\"span\").first();\n+        Element foo = doc.select(\"foo\").first();\n+        Element img = doc.select(\"img\").first();\n+\n+        Elements docChildren = div.children();\n+        assertEquals(2, docChildren.size());\n+        assertEquals(\"<p><a>One</a></p>\", docChildren.get(0).outerHtml());\n+        assertEquals(\"<p><a>Two</a></p>\", docChildren.get(1).outerHtml());\n+        assertEquals(3, div.childNodes().size());\n+        assertEquals(\"Three\", div.childNodes().get(2).outerHtml());\n+\n+        assertEquals(1, p.children().size());\n+        assertEquals(\"One\", p.children().text());\n+\n+        assertEquals(0, span.children().size());\n+        assertEquals(1, span.childNodes().size());\n+        assertEquals(\"Four\", span.childNodes().get(0).outerHtml());\n+\n+        assertEquals(0, foo.children().size());\n+        assertEquals(0, foo.childNodes().size());\n+        assertEquals(0, img.children().size());\n+        assertEquals(0, img.childNodes().size());\n+    }\n+\n+    @Test public void testShadowElementsAreUpdated() {\n+        String html = \"<div><p><a>One</a></p><p><a>Two</a></p>Three</div><span>Four</span><foo></foo><img>\";\n+        Document doc = Jsoup.parse(html);\n+        Element div = doc.select(\"div\").first();\n+        Elements els = div.children();\n+        List<Node> nodes = div.childNodes();\n+\n+        assertEquals(2, els.size()); // the two Ps\n+        assertEquals(3, nodes.size()); // the \"Three\" textnode\n+\n+        Element p3 = new Element(\"p\").text(\"P3\");\n+        Element p4 = new Element(\"p\").text(\"P4\");\n+        div.insertChildren(1, p3);\n+        div.insertChildren(3, p4);\n+        Elements els2 = div.children();\n+\n+        // first els should not have changed\n+        assertEquals(2, els.size());\n+        assertEquals(4, els2.size());\n+\n+        assertEquals(\"<p><a>One</a></p>\\n\" +\n+            \"<p>P3</p>\\n\" +\n+            \"<p><a>Two</a></p>\\n\" +\n+            \"<p>P4</p>Three\", div.html());\n+        assertEquals(\"P3\", els2.get(1).text());\n+        assertEquals(\"P4\", els2.get(3).text());\n+\n+        p3.after(\"<span>Another</span\");\n+\n+        Elements els3 = div.children();\n+        assertEquals(5, els3.size());\n+        assertEquals(\"span\", els3.get(2).tagName());\n+        assertEquals(\"Another\", els3.get(2).text());\n+\n+        assertEquals(\"<p><a>One</a></p>\\n\" +\n+            \"<p>P3</p>\\n\" +\n+            \"<span>Another</span>\\n\" +\n+            \"<p><a>Two</a></p>\\n\" +\n+            \"<p>P4</p>Three\", div.html());\n+    }\n+\n+    @Test public void classNamesAndAttributeNameIsCaseInsensitive() {\n+        String html = \"<p Class='SomeText AnotherText'>One</p>\";\n+        Document doc = Jsoup.parse(html);\n+        Element p = doc.select(\"p\").first();\n+        assertEquals(\"SomeText AnotherText\", p.className());\n+        assertTrue(p.classNames().contains(\"SomeText\"));\n+        assertTrue(p.classNames().contains(\"AnotherText\"));\n+        assertTrue(p.hasClass(\"SomeText\"));\n+        assertTrue(p.hasClass(\"sometext\"));\n+        assertTrue(p.hasClass(\"AnotherText\"));\n+        assertTrue(p.hasClass(\"anothertext\"));\n+\n+        Element p1 = doc.select(\".SomeText\").first();\n+        Element p2 = doc.select(\".sometext\").first();\n+        Element p3 = doc.select(\"[class=SomeText AnotherText]\").first();\n+        Element p4 = doc.select(\"[Class=SomeText AnotherText]\").first();\n+        Element p5 = doc.select(\"[class=sometext anothertext]\").first();\n+        Element p6 = doc.select(\"[class=SomeText AnotherText]\").first();\n+        Element p7 = doc.select(\"[class^=sometext]\").first();\n+        Element p8 = doc.select(\"[class$=nothertext]\").first();\n+        Element p9 = doc.select(\"[class^=sometext]\").first();\n+        Element p10 = doc.select(\"[class$=AnotherText]\").first();\n+\n+        assertEquals(\"One\", p1.text());\n+        assertEquals(p1, p2);\n+        assertEquals(p1, p3);\n+        assertEquals(p1, p4);\n+        assertEquals(p1, p5);\n+        assertEquals(p1, p6);\n+        assertEquals(p1, p7);\n+        assertEquals(p1, p8);\n+        assertEquals(p1, p9);\n+        assertEquals(p1, p10);\n     }\n \n \t@Test\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import static org.jsoup.nodes.Document.OutputSettings;\n import static org.jsoup.nodes.Entities.EscapeMode.*;\n import static org.junit.Assert.*;\n-\n \n public class EntitiesTest {\n     @Test public void escape() {\n         assertEquals(text, Entities.unescape(escapedUtfMin));\n     }\n \n-    @Test public void escapeSupplementaryCharacter(){\n+    @Test public void escapedSupplemtary() {\n+        String text = \"\\uD835\\uDD59\";\n+        String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n+        assertEquals(\"&#x1d559;\", escapedAscii);\n+        String escapedAsciiFull = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(extended));\n+        assertEquals(\"&hopf;\", escapedAsciiFull);\n+        String escapedUtf= Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(extended));\n+        assertEquals(text, escapedUtf);\n+    }\n+\n+    @Test public void unescapeMultiChars() {\n+        String text = \"&NestedGreaterGreater; &nGg; &nGt; &nGtv; &Gt; &gg;\"; // gg is not combo, but 8811 could conflict with NestedGreaterGreater or others\n+        String un = \"\u226b \u22d9\u0338 \u226b\u20d2 \u226b\u0338 \u226b \u226b\";\n+        assertEquals(un, Entities.unescape(text));\n+        String escaped = Entities.escape(un, new OutputSettings().charset(\"ascii\").escapeMode(extended));\n+        assertEquals(\"&Gt; &Gg;&#x338; &Gt;&#x20d2; &Gt;&#x338; &Gt; &Gt;\", escaped);\n+        assertEquals(un, Entities.unescape(escaped));\n+    }\n+\n+    @Test public void xhtml() {\n+        String text = \"&amp; &gt; &lt; &quot;\";\n+        assertEquals(38, xhtml.codepointForName(\"amp\"));\n+        assertEquals(62, xhtml.codepointForName(\"gt\"));\n+        assertEquals(60, xhtml.codepointForName(\"lt\"));\n+        assertEquals(34, xhtml.codepointForName(\"quot\"));\n+\n+        assertEquals(\"amp\", xhtml.nameForCodepoint(38));\n+        assertEquals(\"gt\", xhtml.nameForCodepoint(62));\n+        assertEquals(\"lt\", xhtml.nameForCodepoint(60));\n+        assertEquals(\"quot\", xhtml.nameForCodepoint(34));\n+    }\n+\n+    @Test public void getByName() {\n+        assertEquals(\"\u226b\u20d2\", Entities.getByName(\"nGt\"));\n+        assertEquals(\"fj\", Entities.getByName(\"fjlig\"));\n+        assertEquals(\"\u226b\", Entities.getByName(\"gg\"));\n+        assertEquals(\"\u00a9\", Entities.getByName(\"copy\"));\n+    }\n+\n+    @Test public void escapeSupplementaryCharacter() {\n         String text = new String(Character.toChars(135361));\n         String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n         assertEquals(\"&#x210c1;\", escapedAscii);\n         assertEquals(text, escapedUtf);\n     }\n \n+    @Test public void notMissingMultis() {\n+        String text = \"&nparsl;\";\n+        String un = \"\\u2AFD\\u20E5\";\n+        assertEquals(un, Entities.unescape(text));\n+    }\n+\n+    @Test public void notMissingSupplementals() {\n+        String text = \"&npolint; &qfr;\";\n+        String un = \"\u2a14 \\uD835\\uDD2E\"; // \ud835\udd2e\n+        assertEquals(un, Entities.unescape(text));\n+    }\n+\n     @Test public void unescape() {\n-        String text = \"Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n-        assertEquals(\"Hello &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n+        String text = \"Hello &AElig; &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n+        assertEquals(\"Hello \u00c6 &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n \n         assertEquals(\"&0987654321; &unknown\", Entities.unescape(\"&0987654321; &unknown\"));\n     }\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n \n     @Test public void setBaseUriIsRecursive() {\n         Document doc = Jsoup.parse(\"<div><p></p></div>\");\n-        String baseUri = \"http://jsoup.org\";\n+        String baseUri = \"https://jsoup.org\";\n         doc.setBaseUri(baseUri);\n         \n         assertEquals(baseUri, doc.baseUri());\n     }\n \n     @Test public void handlesAbsPrefix() {\n-        Document doc = Jsoup.parse(\"<a href=/foo>Hello</a>\", \"http://jsoup.org/\");\n+        Document doc = Jsoup.parse(\"<a href=/foo>Hello</a>\", \"https://jsoup.org/\");\n         Element a = doc.select(\"a\").first();\n         assertEquals(\"/foo\", a.attr(\"href\"));\n-        assertEquals(\"http://jsoup.org/foo\", a.attr(\"abs:href\"));\n+        assertEquals(\"https://jsoup.org/foo\", a.attr(\"abs:href\"));\n         assertTrue(a.hasAttr(\"abs:href\"));\n     }\n \n     @Test public void handlesAbsOnImage() {\n-        Document doc = Jsoup.parse(\"<p><img src=\\\"/rez/osi_logo.png\\\" /></p>\", \"http://jsoup.org/\");\n+        Document doc = Jsoup.parse(\"<p><img src=\\\"/rez/osi_logo.png\\\" /></p>\", \"https://jsoup.org/\");\n         Element img = doc.select(\"img\").first();\n-        assertEquals(\"http://jsoup.org/rez/osi_logo.png\", img.attr(\"abs:src\"));\n+        assertEquals(\"https://jsoup.org/rez/osi_logo.png\", img.attr(\"abs:src\"));\n         assertEquals(img.absUrl(\"src\"), img.attr(\"abs:src\"));\n     }\n \n     @Test public void handlesAbsPrefixOnHasAttr() {\n         // 1: no abs url; 2: has abs url\n-        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>\");\n+        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='https://jsoup.org/'>Two</a>\");\n         Element one = doc.select(\"#1\").first();\n         Element two = doc.select(\"#2\").first();\n \n \n         assertTrue(two.hasAttr(\"abs:href\"));\n         assertTrue(two.hasAttr(\"href\"));\n-        assertEquals(\"http://jsoup.org/\", two.absUrl(\"href\"));\n+        assertEquals(\"https://jsoup.org/\", two.absUrl(\"href\"));\n     }\n \n     @Test public void literalAbsPrefix() {\n     Test for an issue with Java's abs URL handler.\n      */\n     @Test public void absHandlesRelativeQuery() {\n-        Document doc = Jsoup.parse(\"<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>\", \"http://jsoup.org/path/file?bar\");\n+        Document doc = Jsoup.parse(\"<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>\", \"https://jsoup.org/path/file?bar\");\n \n         Element a1 = doc.select(\"a\").first();\n-        assertEquals(\"http://jsoup.org/path/file?foo\", a1.absUrl(\"href\"));\n+        assertEquals(\"https://jsoup.org/path/file?foo\", a1.absUrl(\"href\"));\n \n         Element a2 = doc.select(\"a\").get(1);\n-        assertEquals(\"http://jsoup.org/path/bar.html?foo\", a2.absUrl(\"href\"));\n+        assertEquals(\"https://jsoup.org/path/bar.html?foo\", a2.absUrl(\"href\"));\n     }\n \n     @Test public void absHandlesDotFromIndex() {\n         assertTrue(p.ownerDocument() == doc);\n         assertTrue(doc.ownerDocument() == doc);\n         assertNull(doc.parent());\n+    }\n+\n+    @Test public void root() {\n+        Document doc = Jsoup.parse(\"<div><p>Hello\");\n+        Element p = doc.select(\"p\").first();\n+        Node root = p.root();\n+        assertTrue(doc == root);\n+        assertNull(root.parent());\n+        assertTrue(doc.root() == doc);\n+        assertTrue(doc.root() == doc.ownerDocument());\n+\n+        Element standAlone = new Element(Tag.valueOf(\"p\"), \"\");\n+        assertTrue(standAlone.parent() == null);\n+        assertTrue(standAlone.root() == standAlone);\n+        assertTrue(standAlone.ownerDocument() == null);\n     }\n \n     @Test public void before() {\n         assertTrue(el.text().equals(\"None\"));\n         assertTrue(elClone.text().equals(\"Text\"));\n     }\n+\n+    @Test public void changingAttributeValueShouldReplaceExistingAttributeCaseInsensitive() {\n+        Document document = Jsoup.parse(\"<INPUT id=\\\"foo\\\" NAME=\\\"foo\\\" VALUE=\\\"\\\">\");\n+        Element inputElement = document.select(\"#foo\").first();\n+\n+        inputElement.attr(\"value\",\"bar\");\n+\n+        assertEquals(singletonAttributes(\"value\", \"bar\"), getAttributesCaseInsensitive(inputElement, \"value\"));\n+    }\n+\n+    private Attributes getAttributesCaseInsensitive(Element element, String attributeName) {\n+        Attributes matches = new Attributes();\n+        for (Attribute attribute : element.attributes()) {\n+            if (attribute.getKey().equalsIgnoreCase(attributeName)) {\n+                matches.put(attribute);\n+            }\n+        }\n+        return matches;\n+    }\n+\n+    private Attributes singletonAttributes(String key, String value) {\n+        Attributes attributes = new Attributes();\n+        attributes.put(key, value);\n+        return attributes;\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.BooleanAttribute;\n+import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n         assertEquals(html, el.outerHtml());\n     }\n     \n+    @Test public void dropsSlashFromAttributeName() {\n+        String html = \"<img /onerror='doMyJob'/>\";\n+        Document doc = Jsoup.parse(html);\n+        assertTrue(\"SelfClosingStartTag ignores last character\", doc.select(\"img[onerror]\").size() != 0);\n+        assertEquals(\"<img onerror=\\\"doMyJob\\\">\", doc.body().html());\n+\n+        doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n+        assertEquals(\"<img onerror=\\\"doMyJob\\\" />\", doc.html());\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertFalse(r.matches(\"ne Two Three Four\"));\n         assertEquals(\"ne Two Three\", r.consumeToEnd());\n         assertFalse(r.matches(\"ne\"));\n+        assertTrue(r.isEmpty());\n     }\n \n     @Test\n         assertFalse(r.rangeEquals(18, 5, \"CHIKE\"));\n     }\n \n+    @Test\n+    public void empty() {\n+        CharacterReader r = new CharacterReader(\"One\");\n+        assertTrue(r.matchConsume(\"One\"));\n+        assertTrue(r.isEmpty());\n+\n+        r = new CharacterReader(\"Two\");\n+        String two = r.consumeToEnd();\n+        assertEquals(\"Two\", two);\n+    }\n+\n \n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.integration.ParseTest;\n-import org.jsoup.nodes.*;\n+import org.jsoup.nodes.Comment;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Entities;\n+import org.jsoup.nodes.FormElement;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n+import org.jsoup.safety.Whitelist;\n import org.jsoup.select.Elements;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.File;\n import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n /**\n         assertEquals(2, options.size());\n         assertEquals(\"One\", options.first().text());\n         assertEquals(\"TwoThree\", options.last().text());\n+    }\n+\n+    @Test public void testSelectWithOption() {\n+        Parser parser = Parser.htmlParser();\n+        parser.setTrackErrors(10);\n+        Document document = parser.parseInput(\"<select><option>Option 1</option></select>\", \"http://jsoup.org\");\n+        assertEquals(0, parser.getErrors().size());\n     }\n \n     @Test public void testSpaceAfterTag() {\n         assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img><img></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr> hr text <hr> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n+    @Test public void handlesKnownEmptyNoFrames() {\n+        String h = \"<html><head><noframes /><meta name=foo></head><body>One</body></html>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<html><head><noframes></noframes><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void handlesKnownEmptyStyle() {\n+        String h = \"<html><head><style /><meta name=foo></head><body>One</body></html>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<html><head><style></style><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void handlesKnownEmptyTitle() {\n+        String h = \"<html><head><title /><meta name=foo></head><body>One</body></html>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<html><head><title></title><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void handlesKnownEmptyIframe() {\n+        String h = \"<p>One</p><iframe id=1 /><p>Two\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<html><head></head><body><p>One</p><iframe id=\\\"1\\\"></iframe><p>Two</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n     @Test public void handlesSolidusAtAttributeEnd() {\n         // this test makes sure [<a href=/>link</a>] is parsed as [<a href=\"/\">link</a>], not [<a href=\"\" /><a>link</a>]\n         String h = \"<a href=/>link</a>\";\n         String h = \"<b>1<p>2</b>3</p>\";\n         Document doc = Jsoup.parse(h);\n         assertEquals(\"<b>1</b>\\n<p><b>2</b>3</p>\", doc.body().html());\n+    }\n+\n+    @Ignore // todo: test case for https://github.com/jhy/jsoup/issues/845. Doesn't work yet.\n+    @Test public void handlesMisnestedAInDivs() {\n+        String h = \"<a href='#1'><div><div><a href='#2'>child</a</div</div></a>\";\n+        String w = \"<a href=\\\"#1\\\"></a><div><a href=\\\"#1\\\"></a><div><a href=\\\"#1\\\"></a><a href=\\\"#2\\\">child</a></div></div>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\n+            StringUtil.normaliseWhitespace(w),\n+            StringUtil.normaliseWhitespace(doc.body().html()));\n     }\n \n     @Test public void handlesUnexpectedMarkupInTables() {\n         assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());\n         assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());\n         assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());\n-        assertEquals(\"50: Self closing flag not acknowledged\", errors.get(3).toString());\n+        assertEquals(\"50: Tag cannot be self closing; not a void tag\", errors.get(3).toString());\n         assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());\n     }\n \n         Document doc = Jsoup.parse(body);\n         assertEquals(1, doc.body().children().size());\n     }\n+\n+    @Test public void testUsingSingleQuotesInQueries() {\n+        String body = \"<body> <div class='main'>hello</div></body>\";\n+        Document doc = Jsoup.parse(body);\n+        Elements main = doc.select(\"div[class='main']\");\n+        assertEquals(\"hello\", main.text());\n+    }\n+\n+    @Test public void testSupportsNonAsciiTags() {\n+        String body = \"<\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>Yes</\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5><\u0440\u0443\u0441\u0441\u043a\u0438\u0439-\u0442\u044d\u0433>Correct</<\u0440\u0443\u0441\u0441\u043a\u0438\u0439-\u0442\u044d\u0433>\";\n+        Document doc = Jsoup.parse(body);\n+        Elements els = doc.select(\"\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5\");\n+        assertEquals(\"Yes\", els.text());\n+        els = doc.select(\"\u0440\u0443\u0441\u0441\u043a\u0438\u0439-\u0442\u044d\u0433\");\n+        assertEquals(\"Correct\", els.text());\n+    }\n+\n+    @Test public void testSupportsPartiallyNonAsciiTags() {\n+        String body = \"<div>Check</div\u00e1>\";\n+        Document doc = Jsoup.parse(body);\n+        Elements els = doc.select(\"div\");\n+        assertEquals(\"Check\", els.text());\n+    }\n+\n+    @Test public void testFragment() {\n+        // make sure when parsing a body fragment, a script tag at start goes into the body\n+        String html =\n+            \"<script type=\\\"text/javascript\\\">console.log('foo');</script>\\n\" +\n+                \"<div id=\\\"somecontent\\\">some content</div>\\n\" +\n+                \"<script type=\\\"text/javascript\\\">console.log('bar');</script>\";\n+\n+        Document body = Jsoup.parseBodyFragment(html);\n+        assertEquals(\"<script type=\\\"text/javascript\\\">console.log('foo');</script> \\n\" +\n+            \"<div id=\\\"somecontent\\\">\\n\" +\n+            \" some content\\n\" +\n+            \"</div> \\n\" +\n+            \"<script type=\\\"text/javascript\\\">console.log('bar');</script>\", body.body().html());\n+    }\n+\n+    @Test public void testHtmlLowerCase() {\n+        String html = \"<!doctype HTML><DIV ID=1>One</DIV>\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<!doctype html> <html> <head></head> <body> <div id=\\\"1\\\"> One </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void canPreserveTagCase() {\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(new ParseSettings(true, false));\n+        Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n+        assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <SPAN id=\\\"2\\\"></SPAN> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void canPreserveAttributeCase() {\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(new ParseSettings(false, true));\n+        Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n+        assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <span ID=\\\"2\\\"></span> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void canPreserveBothCase() {\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(new ParseSettings(true, true));\n+        Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n+        assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <SPAN ID=\\\"2\\\"></SPAN> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void handlesControlCodeInAttributeName() {\n+        Document doc = Jsoup.parse(\"<p><a \\06=foo>One</a><a/\\06=bar><a foo\\06=bar>Two</a></p>\");\n+        assertEquals(\"<p><a>One</a><a></a><a foo=\\\"bar\\\">Two</a></p>\", doc.body().html());\n+    }\n+\n+    @Test public void caseSensitiveParseTree() {\n+        String html = \"<r><X>A</X><y>B</y></r>\";\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(ParseSettings.preserveCase);\n+        Document doc = parser.parseInput(html, \"\");\n+        assertEquals(\"<r> <X> A </X> <y> B </y> </r>\", StringUtil.normaliseWhitespace(doc.body().html()));\n+    }\n+\n+    @Test public void selfClosingVoidIsNotAnError() {\n+        String html = \"<p>test<br/>test<br/></p>\";\n+        Parser parser = Parser.htmlParser().setTrackErrors(5);\n+        parser.parseInput(html, \"\");\n+        assertEquals(0, parser.getErrors().size());\n+\n+        assertTrue(Jsoup.isValid(html, Whitelist.basic()));\n+        String clean = Jsoup.clean(html, Whitelist.basic());\n+        assertEquals(\"<p>test<br>test<br></p>\", clean);\n+    }\n+\n+    @Test public void selfClosingOnNonvoidIsError() {\n+        String html = \"<p>test</p><div /><div>Two</div>\";\n+        Parser parser = Parser.htmlParser().setTrackErrors(5);\n+        parser.parseInput(html, \"\");\n+        assertEquals(1, parser.getErrors().size());\n+        assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString());\n+\n+        assertFalse(Jsoup.isValid(html, Whitelist.relaxed()));\n+        String clean = Jsoup.clean(html, Whitelist.relaxed());\n+        assertEquals(\"<p>test</p> <div></div> <div> Two </div>\", StringUtil.normaliseWhitespace(clean));\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/ParserSettingsTest.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.MultiLocaleRule;\n+import org.jsoup.MultiLocaleRule.MultiLocaleTest;\n+import org.jsoup.nodes.Attributes;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class ParserSettingsTest {\n+    @Rule public MultiLocaleRule rule = new MultiLocaleRule();\n+\n+    @Test @MultiLocaleTest public void caseSupport() {\n+        ParseSettings bothOn = new ParseSettings(true, true);\n+        ParseSettings bothOff = new ParseSettings(false, false);\n+        ParseSettings tagOn = new ParseSettings(true, false);\n+        ParseSettings attrOn = new ParseSettings(false, true);\n+\n+        assertEquals(\"IMG\", bothOn.normalizeTag(\"IMG\"));\n+        assertEquals(\"ID\", bothOn.normalizeAttribute(\"ID\"));\n+\n+        assertEquals(\"img\", bothOff.normalizeTag(\"IMG\"));\n+        assertEquals(\"id\", bothOff.normalizeAttribute(\"ID\"));\n+\n+        assertEquals(\"IMG\", tagOn.normalizeTag(\"IMG\"));\n+        assertEquals(\"id\", tagOn.normalizeAttribute(\"ID\"));\n+\n+        assertEquals(\"img\", attrOn.normalizeTag(\"IMG\"));\n+        assertEquals(\"ID\", attrOn.normalizeAttribute(\"ID\"));\n+    }\n+\n+    @Test @MultiLocaleTest public void attributeCaseNormalization() throws Exception {\n+        ParseSettings parseSettings = new ParseSettings(false, false);\n+\n+        String normalizedAttribute = parseSettings.normalizeAttribute(\"HIDDEN\");\n+\n+        assertEquals(\"hidden\", normalizedAttribute);\n+    }\n+\n+    @Test @MultiLocaleTest public void attributesCaseNormalization() throws Exception {\n+        ParseSettings parseSettings = new ParseSettings(false, false);\n+        Attributes attributes = new Attributes();\n+        attributes.put(\"ITEM\", \"1\");\n+\n+        Attributes normalizedAttributes = parseSettings.normalizeAttributes(attributes);\n+\n+        assertEquals(\"item\", normalizedAttributes.asList().get(0).getKey());\n+    }\n+}\n--- a/src/test/java/org/jsoup/parser/TagTest.java\n+++ b/src/test/java/org/jsoup/parser/TagTest.java\n package org.jsoup.parser;\n \n+import org.jsoup.MultiLocaleRule;\n+import org.jsoup.MultiLocaleRule.MultiLocaleTest;\n+import org.junit.Rule;\n import org.junit.Test;\n+\n import static org.junit.Assert.*;\n \n /**\n  Tag tests.\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TagTest {\n+    @Rule public MultiLocaleRule rule = new MultiLocaleRule();\n \n-    @Test public void isCaseInsensitive() {\n+    @Test public void isCaseSensitive() {\n         Tag p1 = Tag.valueOf(\"P\");\n         Tag p2 = Tag.valueOf(\"p\");\n-        assertEquals(p1, p2);\n+        assertFalse(p1.equals(p2));\n+    }\n+\n+    @Test @MultiLocaleTest public void canBeInsensitive() {\n+        Tag script1 = Tag.valueOf(\"script\", ParseSettings.htmlDefault);\n+        Tag script2 = Tag.valueOf(\"SCRIPT\", ParseSettings.htmlDefault);\n+        assertSame(script1, script2);\n     }\n \n     @Test public void trims() {\n     }\n \n     @Test public void defaultSemantics() {\n-        Tag foo = Tag.valueOf(\"foo\"); // not defined\n+        Tag foo = Tag.valueOf(\"FOO\"); // not defined\n         Tag foo2 = Tag.valueOf(\"FOO\");\n \n         assertEquals(foo, foo2);\n--- a/src/test/java/org/jsoup/parser/TokenQueueTest.java\n+++ b/src/test/java/org/jsoup/parser/TokenQueueTest.java\n     }\n \n     @Test public void chompBalancedMatchesAsMuchAsPossible() {\n-        TokenQueue tq = new TokenQueue(\"unbalanced(something(or another\");\n+        TokenQueue tq = new TokenQueue(\"unbalanced(something(or another)) else\");\n         tq.consumeTo(\"(\");\n         String match = tq.chompBalanced('(', ')');\n-        assertEquals(\"something(or another\", match);\n+        assertEquals(\"something(or another)\", match);\n     }\n     \n     @Test public void unescape() {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n+import org.jsoup.nodes.XmlDeclaration;\n import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URISyntaxException;\n+import java.nio.charset.Charset;\n import java.util.List;\n \n import static org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n \n /**\n  * Tests XmlTreeBuilder.\n \n     @Test\n     public void testCommentAndDocType() {\n-        String xml = \"<!DOCTYPE html><!-- a comment -->One <qux />Two\";\n+        String xml = \"<!DOCTYPE HTML><!-- a comment -->One <qux />Two\";\n         XmlTreeBuilder tb = new XmlTreeBuilder();\n         Document doc = tb.parse(xml, \"http://foo.com/\");\n-        assertEquals(\"<!DOCTYPE html><!-- a comment -->One <qux />Two\",\n+        assertEquals(\"<!DOCTYPE HTML><!-- a comment -->One <qux />Two\",\n                 TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void handlesXmlDeclarationAsDeclaration() {\n         String html = \"<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->\";\n         Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n-        assertEquals(\"<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->\",\n+        assertEquals(\"<?xml encoding=\\\"UTF-8\\\"?> <body> One </body> <!-- comment -->\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n         assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n         assertEquals(\"#comment\", doc.childNode(2).nodeName());\n         Document xmlDoc = Jsoup.parse(html, \"\", Parser.xmlParser());\n         assertEquals(\"<img src=\\\"asdf\\\" onerror=\\\"alert(1)\\\" x=\\\"\\\" />\", xmlDoc.html());\n     }\n+\n+    @Test\n+    public void testDetectCharsetEncodingDeclaration() throws IOException, URISyntaxException {\n+        File xmlFile = new File(XmlTreeBuilder.class.getResource(\"/htmltests/xml-charset.xml\").toURI());\n+        InputStream inStream = new FileInputStream(xmlFile);\n+        Document doc = Jsoup.parse(inStream, null, \"http://example.com/\", Parser.xmlParser());\n+        assertEquals(\"ISO-8859-1\", doc.charset().name());\n+        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?> <data>\u00e4\u00f6\u00e5\u00e9\u00fc</data>\",\n+            TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n+    public void testParseDeclarationAttributes() {\n+        String xml = \"<?xml version='1' encoding='UTF-8' something='else'?><val>One</val>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        XmlDeclaration decl = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(\"1\", decl.attr(\"version\"));\n+        assertEquals(\"UTF-8\", decl.attr(\"encoding\"));\n+        assertEquals(\"else\", decl.attr(\"something\"));\n+        assertEquals(\"version=\\\"1\\\" encoding=\\\"UTF-8\\\" something=\\\"else\\\"\", decl.getWholeDeclaration());\n+        assertEquals(\"<?xml version=\\\"1\\\" encoding=\\\"UTF-8\\\" something=\\\"else\\\"?>\", decl.outerHtml());\n+    }\n+\n+    @Test\n+    public void caseSensitiveDeclaration() {\n+        String xml = \"<?XML version='1' encoding='UTF-8' something='else'?>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        assertEquals(\"<?XML version=\\\"1\\\" encoding=\\\"UTF-8\\\" something=\\\"else\\\"?>\", doc.outerHtml());\n+    }\n+\n+    @Test\n+    public void testCreatesValidProlog() {\n+        Document document = Document.createShell(\"\");\n+        document.outputSettings().syntax(Syntax.xml);\n+        document.charset(Charset.forName(\"utf-8\"));\n+        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n+            \"<html>\\n\" +\n+            \" <head></head>\\n\" +\n+            \" <body></body>\\n\" +\n+            \"</html>\", document.outerHtml());\n+    }\n+\n+    @Test\n+    public void preservesCaseByDefault() {\n+        String xml = \"<TEST ID=1>Check</TEST>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        assertEquals(\"<TEST ID=\\\"1\\\">Check</TEST>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n+    public void canNormalizeCase() {\n+        String xml = \"<TEST ID=1>Check</TEST>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser().settings(ParseSettings.htmlDefault));\n+        assertEquals(\"<test id=\\\"1\\\">Check</test>\", TextUtil.stripNewlines(doc.html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n package org.jsoup.safety;\n \n+import org.jsoup.MultiLocaleRule;\n+import org.jsoup.MultiLocaleRule.MultiLocaleTest;\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Entities;\n+import org.junit.Rule;\n import org.junit.Test;\n+\n import static org.junit.Assert.*;\n \n /**\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class CleanerTest {\n+    @Rule public MultiLocaleRule rule = new MultiLocaleRule();\n+\n     @Test public void simpleBehaviourTest() {\n         String h = \"<div><p class=foo><a href='http://evil.com'>Hello <b id=bar>there</b>!</a></div>\";\n         String cleanHtml = Jsoup.clean(h, Whitelist.simpleText());\n         assertEquals(\"<p>Contact me <a rel=\\\"nofollow\\\">here</a></p>\",\n                 TextUtil.stripNewlines(cleanHtml));\n     }\n-    \n+\n+    @Test @MultiLocaleTest public void whitelistedProtocolShouldBeRetained() {\n+        Whitelist whitelist = Whitelist.none()\n+                .addTags(\"a\")\n+                .addAttributes(\"a\", \"href\")\n+                .addProtocols(\"a\", \"href\", \"something\");\n+\n+        String cleanHtml = Jsoup.clean(\"<a href=\\\"SOMETHING://x\\\"></a>\", whitelist);\n+\n+        assertEquals(\"<a href=\\\"SOMETHING://x\\\"></a>\", TextUtil.stripNewlines(cleanHtml));\n+    }\n+\n     @Test public void testDropComments() {\n         String h = \"<p>Hello<!-- no --></p>\";\n         String cleanHtml = Jsoup.clean(h, Whitelist.relaxed());\n         assertEquals(\"<img alt=\\\"\\\">\", cleanHtml);\n     }\n \n-    @Test public void testIsValid() {\n-        String ok = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\";\n+    @Test public void testIsValidBodyHtml() {\n+        String ok = \"<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>\";\n+        String ok1 = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\"; // missing enforced is OK because still needs run thru cleaner\n         String nok1 = \"<p><script></script>Not <b>OK</b></p>\";\n         String nok2 = \"<p align=right>Test Not <b>OK</b></p>\";\n         String nok3 = \"<!-- comment --><p>Not OK</p>\"; // comments and the like will be cleaned\n+        String nok4 = \"<html><head>Foo</head><body><b>OK</b></body></html>\"; // not body html\n+        String nok5 = \"<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>\";\n+        String nok6 = \"<p>Test <b><a href='http://example.com/'>OK</b></p>\"; // missing close tag\n+        String nok7 = \"</div>What\";\n         assertTrue(Jsoup.isValid(ok, Whitelist.basic()));\n+        assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(ok, Whitelist.none()));\n+        assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));\n+    }\n+\n+    @Test public void testIsValidDocument() {\n+        String ok = \"<html><head></head><body><p>Hello</p></body><html>\";\n+        String nok = \"<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>\";\n+\n+        Whitelist relaxed = Whitelist.relaxed();\n+        Cleaner cleaner = new Cleaner(relaxed);\n+        Document okDoc = Jsoup.parse(ok);\n+        assertTrue(cleaner.isValid(okDoc));\n+        assertFalse(cleaner.isValid(Jsoup.parse(nok)));\n+        assertFalse(new Cleaner(Whitelist.none()).isValid(okDoc));\n     }\n     \n     @Test public void resolvesRelativeLinks() {\n         String defaultOut = Jsoup.clean(html, \"http://foo.com/\", Whitelist.relaxed());\n         assertNotSame(defaultOut, customOut);\n \n-        assertEquals(\"<div><p>&bernou;</p></div>\", customOut);\n+        assertEquals(\"<div><p>&Bscr;</p></div>\", customOut); // entities now prefers shorted names if aliased\n         assertEquals(\"<div>\\n\" +\n             \" <p>\u212c</p>\\n\" +\n             \"</div>\", defaultOut);\n         whitelist.addTags( \"script\" );\n         assertTrue( Jsoup.isValid(\"Hello<script>alert('Doh')</script>World !\", whitelist ) );\n     }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void bailsIfRemovingProtocolThatsNotSet() {\n+        // a case that came up on the email list\n+        Whitelist w = Whitelist.none();\n+\n+        // note no add tag, and removing protocol without adding first\n+        w.addAttributes(\"a\", \"href\");\n+        w.removeProtocols(\"a\", \"href\", \"javascript\"); // with no protocols enforced, this was a noop. Now validates.\n+    }\n+\n+    @Test public void handlesControlCharactersAfterTagName() {\n+        String html = \"<a/\\06>\";\n+        String clean = Jsoup.clean(html, Whitelist.basic());\n+        assertEquals(\"<a rel=\\\"nofollow\\\"></a>\", clean);\n+    }\n }\n--- a/src/test/java/org/jsoup/select/ElementsTest.java\n+++ b/src/test/java/org/jsoup/select/ElementsTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.FormElement;\n import org.jsoup.nodes.Node;\n import org.junit.Test;\n \n import java.util.List;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests for ElementList.\n     }\n \n     @Test public void hasAbsAttr() {\n-        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>\");\n+        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='https://jsoup.org'>Two</a>\");\n         Elements one = doc.select(\"#1\");\n         Elements two = doc.select(\"#2\");\n         Elements both = doc.select(\"a\");\n     }\n \n     @Test public void absAttr() {\n-        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>\");\n+        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='https://jsoup.org'>Two</a>\");\n         Elements one = doc.select(\"#1\");\n         Elements two = doc.select(\"#2\");\n         Elements both = doc.select(\"a\");\n \n         assertEquals(\"\", one.attr(\"abs:href\"));\n-        assertEquals(\"http://jsoup.org\", two.attr(\"abs:href\"));\n-        assertEquals(\"http://jsoup.org\", both.attr(\"abs:href\"));\n+        assertEquals(\"https://jsoup.org\", two.attr(\"abs:href\"));\n+        assertEquals(\"https://jsoup.org\", both.attr(\"abs:href\"));\n     }\n \n     @Test public void classes() {\n \n         assertEquals(\"blue\", els.get(0).className());\n         assertEquals(\"red green blue mellow\", els.get(1).className());\n+    }\n+\n+    @Test public void hasClassCaseInsensitive() {\n+        Elements els = Jsoup.parse(\"<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE\").select(\"p\");\n+        Element one = els.get(0);\n+        Element two = els.get(1);\n+        Element thr = els.get(2);\n+\n+        assertTrue(one.hasClass(\"One\"));\n+        assertTrue(one.hasClass(\"ONE\"));\n+\n+        assertTrue(two.hasClass(\"TWO\"));\n+        assertTrue(two.hasClass(\"Two\"));\n+\n+        assertTrue(thr.hasClass(\"ThreE\"));\n+        assertTrue(thr.hasClass(\"three\"));\n     }\n     \n     @Test public void text() {\n         assertEquals(1, els.size());\n         assertEquals(\"Check\", els.text());\n     }\n+\n+    @Test public void siblings() {\n+        Document doc = Jsoup.parse(\"<div><p>1<p>2<p>3<p>4<p>5<p>6</div><div><p>7<p>8<p>9<p>10<p>11<p>12</div>\");\n+\n+        Elements els = doc.select(\"p:eq(3)\"); // gets p4 and p10\n+        assertEquals(2, els.size());\n+\n+        Elements next = els.next();\n+        assertEquals(2, next.size());\n+        assertEquals(\"5\", next.first().text());\n+        assertEquals(\"11\", next.last().text());\n+\n+        assertEquals(0, els.next(\"p:contains(6)\").size());\n+        final Elements nextF = els.next(\"p:contains(5)\");\n+        assertEquals(1, nextF.size());\n+        assertEquals(\"5\", nextF.first().text());\n+\n+        Elements nextA = els.nextAll();\n+        assertEquals(4, nextA.size());\n+        assertEquals(\"5\", nextA.first().text());\n+        assertEquals(\"12\", nextA.last().text());\n+\n+        Elements nextAF = els.nextAll(\"p:contains(6)\");\n+        assertEquals(1, nextAF.size());\n+        assertEquals(\"6\", nextAF.first().text());\n+\n+        Elements prev = els.prev();\n+        assertEquals(2, prev.size());\n+        assertEquals(\"3\", prev.first().text());\n+        assertEquals(\"9\", prev.last().text());\n+\n+        assertEquals(0, els.prev(\"p:contains(1)\").size());\n+        final Elements prevF = els.prev(\"p:contains(3)\");\n+        assertEquals(1, prevF.size());\n+        assertEquals(\"3\", prevF.first().text());\n+\n+        Elements prevA = els.prevAll();\n+        assertEquals(6, prevA.size());\n+        assertEquals(\"3\", prevA.first().text());\n+        assertEquals(\"7\", prevA.last().text());\n+\n+        Elements prevAF = els.prevAll(\"p:contains(1)\");\n+        assertEquals(1, prevAF.size());\n+        assertEquals(\"1\", prevAF.first().text());\n+    }\n+\n+    @Test public void eachText() {\n+        Document doc = Jsoup.parse(\"<div><p>1<p>2<p>3<p>4<p>5<p>6</div><div><p>7<p>8<p>9<p>10<p>11<p>12<p></p></div>\");\n+        List<String> divText = doc.select(\"div\").eachText();\n+        assertEquals(2, divText.size());\n+        assertEquals(\"1 2 3 4 5 6\", divText.get(0));\n+        assertEquals(\"7 8 9 10 11 12\", divText.get(1));\n+\n+        List<String> pText = doc.select(\"p\").eachText();\n+        Elements ps = doc.select(\"p\");\n+        assertEquals(13, ps.size());\n+        assertEquals(12, pText.size()); // not 13, as last doesn't have text\n+        assertEquals(\"1\", pText.get(0));\n+        assertEquals(\"2\", pText.get(1));\n+        assertEquals(\"5\", pText.get(4));\n+        assertEquals(\"7\", pText.get(6));\n+        assertEquals(\"12\", pText.get(11));\n+    }\n+\n+    @Test public void eachAttr() {\n+        Document doc = Jsoup.parse(\n+            \"<div><a href='/foo'>1</a><a href='http://example.com/bar'>2</a><a href=''>3</a><a>4</a>\",\n+            \"http://example.com\");\n+\n+        List<String> hrefAttrs = doc.select(\"a\").eachAttr(\"href\");\n+        assertEquals(3, hrefAttrs.size());\n+        assertEquals(\"/foo\", hrefAttrs.get(0));\n+        assertEquals(\"http://example.com/bar\", hrefAttrs.get(1));\n+        assertEquals(\"\", hrefAttrs.get(2));\n+        assertEquals(4, doc.select(\"a\").size());\n+\n+        List<String> absAttrs = doc.select(\"a\").eachAttr(\"abs:href\");\n+        assertEquals(3, absAttrs.size());\n+        assertEquals(3, absAttrs.size());\n+        assertEquals(\"http://example.com/foo\", absAttrs.get(0));\n+        assertEquals(\"http://example.com/bar\", absAttrs.get(1));\n+        assertEquals(\"http://example.com\", absAttrs.get(2));\n+    }\n }\n--- a/src/test/java/org/jsoup/select/QueryParserTest.java\n+++ b/src/test/java/org/jsoup/select/QueryParserTest.java\n         assertEquals(\"li :prevli :ImmediateParentol\", andRight.toString());\n         assertEquals(2, andLeft.evaluators.size());\n     }\n+\n+    @Test(expected = Selector.SelectorParseException.class) public void exceptionOnUncloseAttribute() {\n+        Evaluator parse = QueryParser.parse(\"section > a[href=\\\"]\");\n+    }\n+\n+    @Test(expected = Selector.SelectorParseException.class)  public void testParsesSingleQuoteInContains() {\n+        Evaluator parse = QueryParser.parse(\"p:contains(One \\\" One)\");\n+    }\n }\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n package org.jsoup.select;\n \n+import org.jsoup.MultiLocaleRule;\n+import org.jsoup.MultiLocaleRule.MultiLocaleTest;\n import org.jsoup.Jsoup;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n+import org.junit.Rule;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class SelectorTest {\n+    @Rule public MultiLocaleRule rule = new MultiLocaleRule();\n+\n     @Test public void testByTag() {\n-        Elements els = Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><div id=3>\").select(\"div\");\n+        // should be case insensitive\n+        Elements els = Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><DIV id=3>\").select(\"DIV\");\n         assertEquals(3, els.size());\n         assertEquals(\"1\", els.get(0).id());\n         assertEquals(\"2\", els.get(1).id());\n     }\n \n     @Test public void testByClass() {\n-        Elements els = Jsoup.parse(\"<p id=0 class='one two'><p id=1 class='one'><p id=2 class='two'>\").select(\"p.one\");\n+        Elements els = Jsoup.parse(\"<p id=0 class='ONE two'><p id=1 class='one'><p id=2 class='two'>\").select(\"P.One\");\n         assertEquals(2, els.size());\n         assertEquals(\"0\", els.get(0).id());\n         assertEquals(\"1\", els.get(1).id());\n         assertEquals(1, els2.size());\n     }\n \n-    @Test public void testByAttribute() {\n-        String h = \"<div Title=Foo /><div Title=Bar /><div Style=Qux /><div title=Bam /><div title=SLAM />\" +\n+    @Test public void testByClassCaseInsensitive() {\n+        String html = \"<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four\";\n+        Elements elsFromClass = Jsoup.parse(html).select(\"P.Foo\");\n+        Elements elsFromAttr = Jsoup.parse(html).select(\"p[class=foo]\");\n+\n+        assertEquals(elsFromAttr.size(), elsFromClass.size());\n+        assertEquals(3, elsFromClass.size());\n+        assertEquals(\"Two\", elsFromClass.get(1).text());\n+    }\n+\n+    @Test @MultiLocaleTest public void testByAttribute() {\n+        String h = \"<div Title=Foo /><div Title=Bar /><div Style=Qux /><div title=Balim /><div title=SLIM />\" +\n                 \"<div data-name='with spaces'/>\";\n         Document doc = Jsoup.parse(h);\n \n         Elements withTitle = doc.select(\"[title]\");\n         assertEquals(4, withTitle.size());\n \n-        Elements foo = doc.select(\"[title=foo]\");\n+        Elements foo = doc.select(\"[TITLE=foo]\");\n         assertEquals(1, foo.size());\n \n         Elements foo2 = doc.select(\"[title=\\\"foo\\\"]\");\n         Elements starts = doc.select(\"[title^=ba]\");\n         assertEquals(2, starts.size());\n         assertEquals(\"Bar\", starts.first().attr(\"title\"));\n-        assertEquals(\"Bam\", starts.last().attr(\"title\"));\n-\n-        Elements ends = doc.select(\"[title$=am]\");\n+        assertEquals(\"Balim\", starts.last().attr(\"title\"));\n+\n+        Elements ends = doc.select(\"[title$=im]\");\n         assertEquals(2, ends.size());\n-        assertEquals(\"Bam\", ends.first().attr(\"title\"));\n-        assertEquals(\"SLAM\", ends.last().attr(\"title\"));\n-\n-        Elements contains = doc.select(\"[title*=a]\");\n-        assertEquals(3, contains.size());\n-        assertEquals(\"Bar\", contains.first().attr(\"title\"));\n-        assertEquals(\"SLAM\", contains.last().attr(\"title\"));\n+        assertEquals(\"Balim\", ends.first().attr(\"title\"));\n+        assertEquals(\"SLIM\", ends.last().attr(\"title\"));\n+\n+        Elements contains = doc.select(\"[title*=i]\");\n+        assertEquals(2, contains.size());\n+        assertEquals(\"Balim\", contains.first().attr(\"title\"));\n+        assertEquals(\"SLIM\", contains.last().attr(\"title\"));\n     }\n \n     @Test public void testNamespacedTag() {\n         assertEquals(\"2\", byContains.last().id());\n     }\n \n-    @Test public void testByAttributeStarting() {\n-        Document doc = Jsoup.parse(\"<div id=1 data-name=jsoup>Hello</div><p data-val=5 id=2>There</p><p id=3>No</p>\");\n+    @Test public void testWildcardNamespacedTag() {\n+        Document doc = Jsoup.parse(\"<div><abc:def id=1>Hello</abc:def></div> <abc:def class=bold id=2>There</abc:def>\");\n+        Elements byTag = doc.select(\"*|def\");\n+        assertEquals(2, byTag.size());\n+        assertEquals(\"1\", byTag.first().id());\n+        assertEquals(\"2\", byTag.last().id());\n+\n+        Elements byAttr = doc.select(\".bold\");\n+        assertEquals(1, byAttr.size());\n+        assertEquals(\"2\", byAttr.last().id());\n+\n+        Elements byTagAttr = doc.select(\"*|def.bold\");\n+        assertEquals(1, byTagAttr.size());\n+        assertEquals(\"2\", byTagAttr.last().id());\n+\n+        Elements byContains = doc.select(\"*|def:contains(e)\");\n+        assertEquals(2, byContains.size());\n+        assertEquals(\"1\", byContains.first().id());\n+        assertEquals(\"2\", byContains.last().id());\n+    }\n+\n+    @Test @MultiLocaleTest public void testByAttributeStarting() {\n+        Document doc = Jsoup.parse(\"<div id=1 ATTRIBUTE data-name=jsoup>Hello</div><p data-val=5 id=2>There</p><p id=3>No</p>\");\n         Elements withData = doc.select(\"[^data-]\");\n         assertEquals(2, withData.size());\n         assertEquals(\"1\", withData.first().id());\n         withData = doc.select(\"p[^data-]\");\n         assertEquals(1, withData.size());\n         assertEquals(\"2\", withData.first().id());\n+\n+        assertEquals(1, doc.select(\"[^attrib]\").size());\n     }\n \n     @Test public void testByAttributeRegex() {\n     @Test public void descendant() {\n         String h = \"<div class=head><p class=first>Hello</p><p>There</p></div><p>None</p>\";\n         Document doc = Jsoup.parse(h);\n-        Element root = doc.getElementsByClass(\"head\").first();\n+        Element root = doc.getElementsByClass(\"HEAD\").first();\n         \n         Elements els = root.select(\".head p\");\n         assertEquals(2, els.size());\n         String h = \"<dIv tItle=bAr><div>\"; // mixed case so a simple toLowerCase() on value doesn't catch\n         Document doc = Jsoup.parse(h);\n \n-        assertEquals(2, doc.select(\"DIV\").size());\n-        assertEquals(1, doc.select(\"DIV[TITLE]\").size());\n-        assertEquals(1, doc.select(\"DIV[TITLE=BAR]\").size());\n-        assertEquals(0, doc.select(\"DIV[TITLE=BARBARELLA\").size());\n+        assertEquals(2, doc.select(\"DiV\").size());\n+        assertEquals(1, doc.select(\"DiV[TiTLE]\").size());\n+        assertEquals(1, doc.select(\"DiV[TiTLE=BAR]\").size());\n+        assertEquals(0, doc.select(\"DiV[TiTLE=BARBARELLA]\").size());\n     }\n \n     @Test public void adjacentSiblings() {\n         assertEquals(\"0\", divs1.get(0).id());\n         assertEquals(\"1\", divs1.get(1).id());\n \n-        Elements divs2 = doc.select(\"div:has([class]\");\n+        Elements divs2 = doc.select(\"div:has([class])\");\n         assertEquals(1, divs2.size());\n         assertEquals(\"1\", divs2.get(0).id());\n \n         assertEquals(\"Two\", divs.first().text());\n     }\n \n-    @Test public void testPseudoContains() {\n-        Document doc = Jsoup.parse(\"<div><p>The Rain.</p> <p class=light>The <i>rain</i>.</p> <p>Rain, the.</p></div>\");\n+    @Test @MultiLocaleTest public void testPseudoContains() {\n+        Document doc = Jsoup.parse(\"<div><p>The Rain.</p> <p class=light>The <i>RAIN</i>.</p> <p>Rain, the.</p></div>\");\n \n         Elements ps1 = doc.select(\"p:contains(Rain)\");\n         assertEquals(3, ps1.size());\n         Elements ps2 = doc.select(\"p:contains(the rain)\");\n         assertEquals(2, ps2.size());\n         assertEquals(\"The Rain.\", ps2.first().html());\n-        assertEquals(\"The <i>rain</i>.\", ps2.last().html());\n+        assertEquals(\"The <i>RAIN</i>.\", ps2.last().html());\n \n         Elements ps3 = doc.select(\"p:contains(the Rain):has(i)\");\n         assertEquals(1, ps3.size());\n \n         Elements ps5 = doc.select(\":contains(rain)\");\n         assertEquals(8, ps5.size()); // html, body, div,...\n+\n+        Elements ps6 = doc.select(\":contains(RAIN)\");\n+        assertEquals(8, ps6.size());\n     }\n \n     @Test public void testPsuedoContainsWithParentheses() {\n         assertEquals(\"2\", ps2.first().id());\n     }\n \n-    @Test public void containsOwn() {\n-        Document doc = Jsoup.parse(\"<p id=1>Hello <b>there</b> now</p>\");\n-        Elements ps = doc.select(\"p:containsOwn(Hello now)\");\n+    @Test @MultiLocaleTest public void containsOwn() {\n+        Document doc = Jsoup.parse(\"<p id=1>Hello <b>there</b> igor</p>\");\n+        Elements ps = doc.select(\"p:containsOwn(Hello IGOR)\");\n         assertEquals(1, ps.size());\n         assertEquals(\"1\", ps.first().id());\n \n         assertEquals(0, doc.select(\"p:containsOwn(there)\").size());\n+\n+        Document doc2 = Jsoup.parse(\"<p>Hello <b>there</b> IGOR</p>\");\n+        assertEquals(1, doc2.select(\"p:containsOwn(igor)\").size());\n+\n     }\n \n     @Test public void testMatches() {\n         Elements subSelect = els.select(\":contains(one)\");\n         assertEquals(2, subSelect.size());\n     }\n+\n+    @Test public void attributeWithBrackets() {\n+        String html = \"<div data='End]'>One</div> <div data='[Another)]]'>Two</div>\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"One\", doc.select(\"div[data='End]']\").first().text());\n+        assertEquals(\"Two\", doc.select(\"div[data='[Another)]]']\").first().text());\n+        assertEquals(\"One\", doc.select(\"div[data=\\\"End]\\\"]\").first().text());\n+        assertEquals(\"Two\", doc.select(\"div[data=\\\"[Another)]]\\\"]\").first().text());\n+    }\n+\n+    @Test @MultiLocaleTest public void containsData() {\n+        String html = \"<p>function</p><script>FUNCTION</script><style>item</style><span><!-- comments --></span>\";\n+        Document doc = Jsoup.parse(html);\n+        Element body = doc.body();\n+\n+        Elements dataEls1 = body.select(\":containsData(function)\");\n+        Elements dataEls2 = body.select(\"script:containsData(function)\");\n+        Elements dataEls3 = body.select(\"span:containsData(comments)\");\n+        Elements dataEls4 = body.select(\":containsData(o)\");\n+        Elements dataEls5 = body.select(\"style:containsData(ITEM)\");\n+\n+        assertEquals(2, dataEls1.size()); // body and script\n+        assertEquals(1, dataEls2.size());\n+        assertEquals(dataEls1.last(), dataEls2.first());\n+        assertEquals(\"<script>FUNCTION</script>\", dataEls2.outerHtml());\n+        assertEquals(1, dataEls3.size());\n+        assertEquals(\"span\", dataEls3.first().tagName());\n+        assertEquals(3, dataEls4.size());\n+        assertEquals(\"body\", dataEls4.first().tagName());\n+        assertEquals(\"script\", dataEls4.get(1).tagName());\n+        assertEquals(\"span\", dataEls4.get(2).tagName());\n+        assertEquals(1, dataEls5.size());\n+    }\n+\n+    @Test public void containsWithQuote() {\n+        String html = \"<p>One'One</p><p>One'Two</p>\";\n+        Document doc = Jsoup.parse(html);\n+        Elements els = doc.select(\"p:contains(One\\\\'One)\");\n+        assertEquals(1, els.size());\n+        assertEquals(\"One'One\", els.text());\n+    }\n }", "timestamp": 1498886352, "metainfo": ""}