{"sha": "9b2b8038b52be022e42c8c7fdf26e236888f94c5", "log": "checkstyle fixes   ", "commit": "\n--- a/src/java/org/apache/commons/cli/AlreadySelectedException.java\n+++ b/src/java/org/apache/commons/cli/AlreadySelectedException.java\n  * @author John Keyes ( john at integralsource.com )\n  * @see ParseException\n  */\n-public class AlreadySelectedException extends ParseException {\n+public class AlreadySelectedException\n+    extends ParseException {\n \n     /** \n      * <p>Construct a new <code>AlreadySelectedException</code> \n      *\n      * @param message the detail message\n      */\n-    public AlreadySelectedException( String message ) {\n-        super( message );\n+    public AlreadySelectedException(String message)\n+    {\n+        super(message);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/BasicParser.java\n+++ b/src/java/org/apache/commons/cli/BasicParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/BasicParser.java,v 1.3 2002/09/19 22:59:43 jkeyes Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/09/19 22:59:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/BasicParser.java,v 1.4 2002/12/09 23:47:24 jkeyes Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/12/09 23:47:24 $\n  *\n  * ====================================================================\n  *\n      * when an non option is found.\n      * @return The <code>arguments</code> String array.\n      */\n-    protected String[] flatten( Options options, \n-                                String[] arguments, \n-                                boolean stopAtNonOption )\n+    protected String[] flatten(Options options, String[] arguments, \n+                               boolean stopAtNonOption)\n     {\n         // just echo the arguments\n         return arguments;\n--- a/src/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/java/org/apache/commons/cli/CommandLine.java\n  */\n package org.apache.commons.cli;\n \n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.LinkedList;\n import java.util.Map;\n \n /** \n  * @author John Keyes (john at integralsource.com)\n  */\n public class CommandLine {\n-    \n+\n     /** the unrecognised options/arguments */\n-    private List args    = new LinkedList();\n+    private List args = new LinkedList();\n \n     /** the processed options */\n     private Map options = new HashMap();\n \n     /** the option name map */\n-    private Map names   = new HashMap();\n+    private Map names = new HashMap();\n \n     /** Map of unique options for ease to get complete list of options */\n     private Map hashcodeMap = new HashMap();\n     /**\n      * <p>Creates a command line.</p>\n      */\n-    CommandLine() {\n-    }\n-    \n+    CommandLine()\n+    {\n+    }\n+\n     /** \n      * <p>Query to see if an option has been set.</p>\n      *\n      * @param opt Short name of the option\n      * @return true if set, false if not\n      */\n-    public boolean hasOption(String opt) {\n-        return options.containsKey( opt );\n+    public boolean hasOption(String opt)\n+    {\n+        return options.containsKey(opt);\n     }\n \n     /** \n      * @param opt character name of the option\n      * @return true if set, false if not\n      */\n-    public boolean hasOption( char opt ) {\n-        return hasOption( String.valueOf( opt ) );\n+    public boolean hasOption(char opt)\n+    {\n+        return hasOption(String.valueOf(opt));\n     }\n \n     /**\n      * @param opt the name of the option\n      * @return the type of this <code>Option</code>\n      */\n-    public Object getOptionObject( String opt ) {\n-        String res = getOptionValue( opt );\n-        \n-        if( !options.containsKey( opt ) ) {\n+    public Object getOptionObject(String opt)\n+    {\n+        String res = getOptionValue(opt);\n+\n+        if (!options.containsKey(opt))\n+        {\n             return null;\n         }\n-        Object type = ((Option)options.get(opt)).getType();\n-        return res == null ? null : TypeHandler.createValue(res, type);\n+\n+        Object type = ((Option) options.get(opt)).getType();\n+\n+        return (res == null)        ? null : TypeHandler.createValue(res, type);\n     }\n \n     /**\n      * @param opt the name of the option\n      * @return the type of opt\n      */\n-    public Object getOptionObject( char opt ) {\n-        return getOptionObject( String.valueOf( opt ) );\n+    public Object getOptionObject(char opt)\n+    {\n+        return getOptionObject(String.valueOf(opt));\n     }\n \n     /** \n      * @return Value of the argument if option is set, and has an argument,\n      * otherwise null.\n      */\n-    public String getOptionValue( String opt ) {\n+    public String getOptionValue(String opt)\n+    {\n         String[] values = getOptionValues(opt);\n+\n         return (values == null) ? null : values[0];\n     }\n \n      * @return Value of the argument if option is set, and has an argument,\n      * otherwise null.\n      */\n-    public String getOptionValue( char opt ) {\n-        return getOptionValue( String.valueOf( opt ) );\n+    public String getOptionValue(char opt)\n+    {\n+        return getOptionValue(String.valueOf(opt));\n     }\n \n     /** \n      * @return Values of the argument if option is set, and has an argument,\n      * otherwise null.\n      */\n-    public String[] getOptionValues( String opt ) {\n+    public String[] getOptionValues(String opt)\n+    {\n         List values = new java.util.ArrayList();\n \n-        opt = Util.stripLeadingHyphens( opt );\n+        opt = Util.stripLeadingHyphens(opt);\n \n         String key = opt;\n-        if( names.containsKey( opt ) ) {\n-            key = (String)names.get( opt );\n-        }\n-\n-        if( options.containsKey( key ) ) {\n-            return ((Option)options.get(key)).getValues();\n-        }\n+\n+        if (names.containsKey(opt))\n+        {\n+            key = (String) names.get(opt);\n+        }\n+\n+        if (options.containsKey(key))\n+        {\n+            return ((Option) options.get(key)).getValues();\n+        }\n+\n         return null;\n     }\n \n      * @return Values of the argument if option is set, and has an argument,\n      * otherwise null.\n      */\n-    public String[] getOptionValues( char opt ) {\n-        return getOptionValues( String.valueOf( opt ) );\n-    }\n-    \n+    public String[] getOptionValues(char opt)\n+    {\n+        return getOptionValues(String.valueOf(opt));\n+    }\n+\n     /** \n      * <p>Retrieve the argument, if any, of an option.</p>\n      *\n      * @param opt name of the option\n-     * @param defaultValue is the default value to be returned if the option is not specified\n+     * @param defaultValue is the default value to be returned if the option \n+     * is not specified\n      * @return Value of the argument if option is set, and has an argument,\n      * otherwise <code>defaultValue</code>.\n      */\n-    public String getOptionValue( String opt, String defaultValue ) {\n-        String answer = getOptionValue( opt );\n-        return ( answer != null ) ? answer : defaultValue;\n-    }\n-    \n+    public String getOptionValue(String opt, String defaultValue)\n+    {\n+        String answer = getOptionValue(opt);\n+\n+        return (answer != null) ? answer : defaultValue;\n+    }\n+\n     /** \n      * <p>Retrieve the argument, if any, of an option.</p>\n      *\n      * @param opt character name of the option\n-     * @param defaultValue is the default value to be returned if the option is not specified\n+     * @param defaultValue is the default value to be returned if the option \n+     * is not specified\n      * @return Value of the argument if option is set, and has an argument,\n      * otherwise <code>defaultValue</code>.\n      */\n-    public String getOptionValue( char opt, String defaultValue ) {\n-        return getOptionValue( String.valueOf( opt ), defaultValue );\n+    public String getOptionValue(char opt, String defaultValue)\n+    {\n+        return getOptionValue(String.valueOf(opt), defaultValue);\n     }\n \n     /** \n      *\n      * @return remaining items passed in but not parsed as an array\n      */\n-    public String[] getArgs() {\n-        String[] answer = new String[ args.size() ];\n-        args.toArray( answer );\n+    public String[] getArgs()\n+    {\n+        String[] answer = new String[args.size()];\n+\n+        args.toArray(answer);\n+\n         return answer;\n     }\n-    \n+\n     /** \n      * <p>Retrieve any left-over non-recognized options and arguments</p>\n      *\n      * @return remaining items passed in but not parsed as a <code>List</code>.\n      */\n-    public List getArgList() {\n+    public List getArgList()\n+    {\n         return args;\n     }\n-    \n+\n     /** \n      * jkeyes\n      * - commented out until it is implemented properly\n      *\n      * @return Stringified form of this object\n      */\n+\n     /*\n     public String toString() {\n         StringBuffer buf = new StringBuffer();\n-        \n-        buf.append( \"[ CommandLine: [ options: \" );\n-        buf.append( options.toString() );\n-        buf.append( \" ] [ args: \");\n-        buf.append( args.toString() );\n-        buf.append( \" ] ]\" );\n-        \n+            \n+        buf.append(\"[ CommandLine: [ options: \");\n+        buf.append(options.toString());\n+        buf.append(\" ] [ args: \");\n+        buf.append(args.toString());\n+        buf.append(\" ] ]\");\n+            \n         return buf.toString();\n     }\n     */\n      *\n      * @param arg the unrecognised option/argument.\n      */\n-    void addArg(String arg) {\n-        args.add( arg );\n-    }\n-        \n+    void addArg(String arg)\n+    {\n+        args.add(arg);\n+    }\n+\n     /**\n      * <p>Add an option to the command line.  The values of \n      * the option are stored.</p>\n      *\n      * @param opt the processed option\n      */\n-    void addOption( Option opt ) {\n-        hashcodeMap.put( new Integer( opt.hashCode() ), opt );\n+    void addOption(Option opt)\n+    {\n+        hashcodeMap.put(new Integer(opt.hashCode()), opt);\n \n         String key = opt.getKey();\n-        if( key == null ) {\n+\n+        if (key == null)\n+        {\n             key = opt.getLongOpt();\n         }\n-        else {\n-            names.put( opt.getLongOpt(), key );\n-        }\n-\n-        options.put( key, opt );\n+        else\n+        {\n+            names.put(opt.getLongOpt(), key);\n+        }\n+\n+        options.put(key, opt);\n     }\n \n     /**\n      * @return an <code>Iterator</code> over the processed {@link Option} \n      * members of this {@link CommandLine}\n      */\n-    public Iterator iterator( ) {\n+    public Iterator iterator()\n+    {\n         return hashcodeMap.values().iterator();\n     }\n \n      *\n      * @return an array of the processed {@link Option}s.\n      */\n-    public Option[] getOptions( ) {\n+    public Option[] getOptions()\n+    {\n         Collection processed = options.values();\n \n+\n         // reinitialise array\n-        optionsArray = new Option[ processed.size() ];\n+        optionsArray = new Option[processed.size()];\n \n         // return the array\n-        return (Option[]) processed.toArray( optionsArray );\n-    }\n-\n-}\n+        return (Option[]) processed.toArray(optionsArray);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli/CommandLineParser.java\n+++ b/src/java/org/apache/commons/cli/CommandLineParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/CommandLineParser.java,v 1.5 2002/11/18 08:41:26 jkeyes Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/11/18 08:41:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/CommandLineParser.java,v 1.6 2002/12/09 23:47:24 jkeyes Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/12/09 23:47:24 $\n  *\n  * ====================================================================\n  *\n  * @author John Keyes (john at integralsource.com)\n  */\n public interface CommandLineParser {\n-    \n+\n     /**\n      * Parse the arguments according to the specified options.\n      *\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    public CommandLine parse( Options options, String[] arguments )\n-    throws ParseException;\n+    CommandLine parse(Options options, String[] arguments)\n+               throws ParseException;\n \n     /**\n      * Parse the arguments according to the specified options and\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    public CommandLine parse( Options options, String[] arguments, Properties props )\n-    throws ParseException;\n+    CommandLine parse(Options options, String[] arguments, \n+                      Properties properties)\n+               throws ParseException;\n \n     /**\n      * Parse the arguments according to the specified options.\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    public CommandLine parse( Options options, String[] arguments, boolean stopAtNonOption )\n-    throws ParseException;\n+    CommandLine parse(Options options, String[] arguments, \n+                      boolean stopAtNonOption)\n+               throws ParseException;\n \n     /**\n      * Parse the arguments according to the specified options and\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    public CommandLine parse( Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n-    throws ParseException;\n+    CommandLine parse(Options options, String[] arguments, \n+                      Properties properties, boolean stopAtNonOption)\n+               throws ParseException;\n }\n--- a/src/java/org/apache/commons/cli/GnuParser.java\n+++ b/src/java/org/apache/commons/cli/GnuParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.10 2002/09/19 22:59:43 jkeyes Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/09/19 22:59:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/GnuParser.java,v 1.11 2002/12/09 23:47:24 jkeyes Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/12/09 23:47:24 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.cli;\n \n-import java.util.Arrays;\n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n \n /**\n  * The class GnuParser provides an implementation of the \n  *\n  * @author John Keyes (john at integralsource.com)\n  * @see Parser\n- * @version $Revision: 1.10 $\n+ * @version $Revision: 1.11 $\n  */\n public class GnuParser extends Parser {\n \n      * <p>Resets the members to their original state i.e. remove\n      * all of <code>tokens</code> entries.\n      */\n-    private void init() {\n+    private void init()\n+    {\n         tokens.clear();\n     }\n \n      *  </li>\n      * </ol>\n      * </p>\n+     *\n+     * @param options The Options to parse the arguments by.\n+     * @param arguments The arguments that have to be flattened.\n+     * @param stopAtNonOption specifies whether to stop \n+     * flattening when a non option has been encountered\n+     * @return a String array of the flattened arguments\n      */\n-    protected String[] flatten( Options options, \n-                                String[] arguments, \n-                                boolean stopAtNonOption )\n+    protected String[] flatten(Options options, String[] arguments, \n+                               boolean stopAtNonOption)\n     {\n         init();\n+\n         boolean eatTheRest = false;\n         Option currentOption = null;\n \n-        for( int i = 0; i < arguments.length; i++ ) {\n-            if( \"--\".equals( arguments[i] ) ) {\n+        for (int i = 0; i < arguments.length; i++)\n+        {\n+            if (\"--\".equals(arguments[i]))\n+            {\n                 eatTheRest = true;\n-                tokens.add( \"--\" );\n-            }\n-            else if ( \"-\".equals( arguments[i] ) ) {\n-                tokens.add( \"-\" );\n-            }\n-            else if( arguments[i].startsWith( \"-\" ) ) {\n-                Option option = options.getOption( arguments[i] );\n+                tokens.add(\"--\");\n+            }\n+            else if (\"-\".equals(arguments[i]))\n+            {\n+                tokens.add(\"-\");\n+            }\n+            else if (arguments[i].startsWith(\"-\"))\n+            {\n+                Option option = options.getOption(arguments[i]);\n \n                 // this is not an Option\n-                if( option == null ) {\n+                if (option == null)\n+                {\n                     // handle special properties Option\n-                    Option specialOption = options.getOption( arguments[i].substring(0,2) );\n-                    if( specialOption != null ) {\n-                        tokens.add( arguments[i].substring(0,2) );\n-                        tokens.add( arguments[i].substring(2) );\n-                    }\n-                    else if( stopAtNonOption ) {\n+                    Option specialOption = \n+                            options.getOption(arguments[i].substring(0, 2));\n+\n+                    if (specialOption != null)\n+                    {\n+                        tokens.add(arguments[i].substring(0, 2));\n+                        tokens.add(arguments[i].substring(2));\n+                    }\n+                    else if (stopAtNonOption)\n+                    {\n                         eatTheRest = true;\n-                        tokens.add( arguments[i] );\n-                    }\n-                    else {\n-                        tokens.add( arguments[i] );\n+                        tokens.add(arguments[i]);\n+                    }\n+                    else\n+                    {\n+                        tokens.add(arguments[i]);\n                     }\n                 }\n-                else {\n+                else\n+                {\n                     currentOption = option;\n+\n                     // special option\n-                    Option specialOption = options.getOption( arguments[i].substring(0,2) );\n-                    if( specialOption != null && option == null ) {\n-                        tokens.add( arguments[i].substring(0,2) );\n-                        tokens.add( arguments[i].substring(2) );\n-                    }\n-                    else if( currentOption != null && currentOption.hasArg() ) {\n-                        if( currentOption.hasArg() ) {\n-                            tokens.add( arguments[i] );\n-                            currentOption= null;\n-                        }\n-                        else if ( currentOption.hasArgs() ) {\n-                            tokens.add( arguments[i] );\n-                        }\n-                        else if ( stopAtNonOption ) {\n+                    Option specialOption = \n+                            options.getOption(arguments[i].substring(0, 2));\n+\n+                    if ((specialOption != null) && (option == null))\n+                    {\n+                        tokens.add(arguments[i].substring(0, 2));\n+                        tokens.add(arguments[i].substring(2));\n+                    }\n+                    else if ((currentOption != null) && currentOption.hasArg())\n+                    {\n+                        if (currentOption.hasArg())\n+                        {\n+                            tokens.add(arguments[i]);\n+                            currentOption = null;\n+                        }\n+                        else if (currentOption.hasArgs())\n+                        {\n+                            tokens.add(arguments[i]);\n+                        }\n+                        else if (stopAtNonOption)\n+                        {\n                             eatTheRest = true;\n-                            tokens.add( \"--\" );\n-                            tokens.add( arguments[i] );\n-                        }\n-                        else {\n-                            tokens.add( arguments[i] );\n-                        }\n-                    } \n-                    else if (currentOption != null ) {\n-                        tokens.add( arguments[i] );\n-                    } \n-                    else if ( stopAtNonOption ) {\n+                            tokens.add(\"--\");\n+                            tokens.add(arguments[i]);\n+                        }\n+                        else\n+                        {\n+                            tokens.add(arguments[i]);\n+                        }\n+                    }\n+                    else if (currentOption != null)\n+                    {\n+                        tokens.add(arguments[i]);\n+                    }\n+                    else if (stopAtNonOption)\n+                    {\n                         eatTheRest = true;\n-                        tokens.add( \"--\" );\n-                        tokens.add( arguments[i] );\n-                    }\n-                    else {\n-                        tokens.add( arguments[i] );\n+                        tokens.add(\"--\");\n+                        tokens.add(arguments[i]);\n+                    }\n+                    else\n+                    {\n+                        tokens.add(arguments[i]);\n                     }\n                 }\n             }\n-            else {\n-                tokens.add( arguments[i] );\n-            }\n-\n-            if( eatTheRest ) {\n-                for( i++; i < arguments.length; i++ ) {\n-                    tokens.add( arguments[i] );\n+            else\n+            {\n+                tokens.add(arguments[i]);\n+            }\n+\n+            if (eatTheRest)\n+            {\n+                for (i++; i < arguments.length; i++)\n+                {\n+                    tokens.add(arguments[i]);\n                 }\n             }\n         }\n-        return (String[])tokens.toArray( new String[] {} );\n+\n+        return (String[]) tokens.toArray(new String[] {  });\n     }\n }\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n import java.io.PrintWriter;\n+\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n  * @author Slawek Zachcial\n  * @author John Keyes (john at integralsource.com)\n  **/\n-public class HelpFormatter\n-{\n-   // --------------------------------------------------------------- Constants\n-\n-   public static final int DEFAULT_WIDTH              = 74;\n-   public static final int DEFAULT_LEFT_PAD           = 1;\n-   public static final int DEFAULT_DESC_PAD           = 3;\n-   public static final String DEFAULT_SYNTAX_PREFIX   = \"usage: \";\n-   public static final String DEFAULT_OPT_PREFIX      = \"-\";\n-   public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n-   public static final String DEFAULT_ARG_NAME        = \"arg\";\n-\n-   // ------------------------------------------------------------------ Static\n-\n-   // -------------------------------------------------------------- Attributes\n-\n-   public int defaultWidth;\n-   public int defaultLeftPad;\n-   public int defaultDescPad;\n-   public String defaultSyntaxPrefix;\n-   public String defaultNewLine;\n-   public String defaultOptPrefix;\n-   public String defaultLongOptPrefix;\n-   public String defaultArgName;\n-\n-   // ------------------------------------------------------------ Constructors\n-   public HelpFormatter()\n-   {\n-      defaultWidth = DEFAULT_WIDTH;\n-      defaultLeftPad = DEFAULT_LEFT_PAD;\n-      defaultDescPad = DEFAULT_DESC_PAD;\n-      defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n-      defaultNewLine = System.getProperty(\"line.separator\");\n-      defaultOptPrefix = DEFAULT_OPT_PREFIX;\n-      defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n-      defaultArgName = DEFAULT_ARG_NAME;\n-   }\n-\n-   // ------------------------------------------------------------------ Public\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          Options options )\n-   {\n-       printHelp( defaultWidth, cmdLineSyntax, null, options, null, false );\n-   }\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          Options options,\n-                          boolean autoUsage )\n-   {\n-       printHelp( defaultWidth, cmdLineSyntax, null, options, null, autoUsage );\n-   }\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer )\n-   {\n-       printHelp( cmdLineSyntax, header, options, footer, false );\n-   }\n-\n-   public void printHelp( String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer,\n-                          boolean autoUsage )\n-   {\n-      printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage );\n-   }\n-   \n-   public void printHelp( int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer )\n-   {\n-       printHelp( width, cmdLineSyntax, header, options, footer, false );\n-   }\n-\n-   public void printHelp( int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          String footer,\n-                          boolean autoUsage )\n-   {\n-      PrintWriter pw = new PrintWriter(System.out);\n-      printHelp( pw, width, cmdLineSyntax, header,\n-                 options, defaultLeftPad, defaultDescPad, footer, autoUsage );\n-      pw.flush();\n-   }\n-   public void printHelp( PrintWriter pw,\n-                          int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          int leftPad,\n-                          int descPad,\n-                          String footer )\n-   throws IllegalArgumentException\n-   {\n-       printHelp( pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false );\n-   }\n-\n-   public void printHelp( PrintWriter pw,\n-                          int width,\n-                          String cmdLineSyntax,\n-                          String header,\n-                          Options options,\n-                          int leftPad,\n-                          int descPad,\n-                          String footer,\n-                          boolean autoUsage )\n-      throws IllegalArgumentException\n-   {\n-      if ( cmdLineSyntax == null || cmdLineSyntax.length() == 0 )\n-      {\n-         throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n-      }\n-\n-      if ( autoUsage ) {\n-          printUsage( pw, width, cmdLineSyntax, options );\n-      }\n-      else {\n-          printUsage( pw, width, cmdLineSyntax );\n-      }\n-\n-      if ( header != null && header.trim().length() > 0 )\n-      {\n-         printWrapped( pw, width, header );\n-      }\n-      printOptions( pw, width, options, leftPad, descPad );\n-      if ( footer != null && footer.trim().length() > 0 )\n-      {\n-         printWrapped( pw, width, footer );\n-      }\n-   }\n-\n-   /**\n-    * <p>Prints the usage statement for the specified application.</p>\n-    *\n-    * @param pw The PrintWriter to print the usage statement \n-    * @param width ??\n-    * @param appName The application name\n-    * @param options The command line Options\n-    * @see #appendOptionGroup(StringBuffer,OptionGroup)\n-    * @see #appendOption(StringBuffer,Option,boolean)\n-    *\n-    */\n-   public void printUsage( PrintWriter pw, int width, String app, Options options ) \n-   {\n-       // initialise the string buffer\n-       StringBuffer buff = new StringBuffer( defaultSyntaxPrefix ).append( app ).append( \" \" );\n-       \n-       // create a list for processed option groups\n-       final Collection processedGroups = new ArrayList();\n-\n-       // temp variable\n-       Option option;\n-       \n-       // iterate over the options\n-       for ( Iterator i = options.getOptions().iterator(); i.hasNext(); )\n-       {\n-           // get the next Option\n-           option = (Option) i.next();\n-\n-           // check if the option is part of an OptionGroup\n-           OptionGroup group = options.getOptionGroup( option );\n-\n-           // if the option is part of a group \n-           if( group != null) {\n-               // and if the group has not already been processed\n-               if( !processedGroups.contains(group) ) {\n-                   // add the group to the processed list\n-                   processedGroups.add( group );\n-                   // add the usage clause\n-                   appendOptionGroup( buff, group );\n-               }\n-               // otherwise the option was displayed in the group\n-               // previously so ignore it.\n-           }\n-           // if the Option is not part of an OptionGroup\n-           else {\n-               appendOption( buff, option, option.isRequired() );\n-           }\n-           \n-           if( i.hasNext() ){\n-               buff.append( \" \" );\n-           }\n-       }\n-\n-       // call printWrapped\n-       printWrapped( pw, width, buff.toString().indexOf(' ')+1,\n-                     buff.toString() );\n-   }\n-   \n-   /**\n-    * Appends the usage clause for an OptionGroup to a StringBuffer.  \n-    * The clause is wrapped in square brackets if the group is required.\n-    * The display of the options is handled by appendOption\n-    * @param buff the StringBuffer to append to\n-    * @param group the group to append\n-    * @see #appendOption(StringBuffer,Option,boolean)\n-    */\n-   private static void appendOptionGroup( final StringBuffer buff, final OptionGroup group )\n-   {\n-       if( !group.isRequired() ) {\n-           buff.append( \"[\" ); \n-       }\n-\n-       // for each option in the OptionGroup\n-       for( Iterator i = group.getOptions().iterator(); i.hasNext(); ) {\n-           // whether the option is required or not is handled at group level\n-           appendOption( buff, (Option)i.next(), true);\n-           if( i.hasNext() ) {\n-               buff.append( \" | \" );\n-           }\n-       }\n-       \n-       if( !group.isRequired() ) {\n-           buff.append( \"]\" ); \n-       }\n-   }\n-   \n-   /**\n-    * Appends the usage clause for an Option to a StringBuffer.  \n-    * The clause is wrapped in square brackets if the group is required.\n-    * The display of the options is handled by appendOption\n-    * @param buff the StringBuffer to append to\n-    * @param group the group to append\n-    * @see #appendOption(StringBuffer,Option,boolean)\n-    */\n-   private static void appendOption( final StringBuffer buff, final Option option, final boolean required)\n-   {\n-       if( !required ) {\n-           buff.append( \"[\" );\n-       }\n-\n-       if( option.getOpt() != null ) {\n-           buff.append( \"-\" ).append( option.getOpt() );\n-       }\n-       else {\n-           buff.append( \"--\" ).append( option.getLongOpt() );\n-       }\n-\n-       // if the Option has a value\n-       if( option.hasArg() && option.getArgName() != null ) {\n-           buff.append( \" <\" ).append( option.getArgName() ).append( \">\" );\n-       }\n-\n-       // if the Option is not a required option\n-       if( !required ) {\n-           buff.append( \"]\" );\n-       }\n-   }\n-       \n-\n-   public void printUsage( PrintWriter pw, int width, String cmdLineSyntax )\n-   {\n-      int argPos = cmdLineSyntax.indexOf(' ') + 1;\n-      printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos,\n-                   defaultSyntaxPrefix + cmdLineSyntax);\n-   }\n-\n-   public void printOptions( PrintWriter pw, int width, Options options, int leftPad, int descPad )\n-   {\n-      StringBuffer sb = new StringBuffer();\n-      renderOptions(sb, width, options, leftPad, descPad);\n-      pw.println(sb.toString());\n-   }\n-\n-   public void printWrapped( PrintWriter pw, int width, String text )\n-   {\n-      printWrapped(pw, width, 0, text);\n-   }\n-\n-   public void printWrapped( PrintWriter pw, int width, int nextLineTabStop, String text )\n-   {\n-      StringBuffer sb = new StringBuffer(text.length());\n-      renderWrappedText(sb, width, nextLineTabStop, text);\n-      pw.println(sb.toString());\n-   }\n-\n-   // --------------------------------------------------------------- Protected\n-\n-   protected StringBuffer renderOptions( StringBuffer sb,\n-                                         int width,\n-                                         Options options,\n-                                         int leftPad,\n-                                         int descPad )\n-   {\n-      final String lpad = createPadding(leftPad);\n-      final String dpad = createPadding(descPad);\n-\n-      //first create list containing only <lpad>-a,--aaa where -a is opt and --aaa is\n-      //long opt; in parallel look for the longest opt string\n-      //this list will be then used to sort options ascending\n-      int max = 0;\n-      StringBuffer optBuf;\n-      List prefixList = new ArrayList();\n-      Option option;\n-      List optList = options.helpOptions();\n-      Collections.sort( optList, new StringBufferComparator() );\n-      for ( Iterator i = optList.iterator(); i.hasNext(); )\n-      {\n-         option = (Option) i.next();\n-         optBuf = new StringBuffer(8);\n-\n-         if ( option.getOpt() == null )\n-         {\n-             optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n-         }\n-         else\n-         {\n-             optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n-             if ( option.hasLongOpt() )\n-             {\n-                optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n-             }\n-\n-         }\n-\n-         if( option.hasArg() ) {\n-             if( option.hasArgName() ) {\n-                 optBuf.append(\" <\").append( option.getArgName() ).append( \">\" );\n-             }\n-             else {\n-                 optBuf.append(' ');\n-             }\n-         }\n-\n-         prefixList.add(optBuf);\n-         max = optBuf.length() > max ? optBuf.length() : max;\n-      }\n-      int x = 0;\n-      for ( Iterator i = optList.iterator(); i.hasNext(); )\n-      {\n-         option = (Option) i.next();\n-         optBuf = new StringBuffer( prefixList.get( x++ ).toString() );\n-\n-         if ( optBuf.length() < max )\n-         {\n-             optBuf.append(createPadding(max - optBuf.length()));\n-         }\n-         optBuf.append( dpad );\n-         \n-         int nextLineTabStop = max + descPad;\n-\n-         if( option.getDescription() != null ) {\n-             optBuf.append( option.getDescription() );\n-         }\n-         renderWrappedText(sb, width, nextLineTabStop,\n-                           optBuf.toString());\n-         if ( i.hasNext() )\n-         {\n-             sb.append(defaultNewLine);\n-         }\n-      }\n-\n-      return sb;\n-   }\n-\n-   protected StringBuffer renderWrappedText( StringBuffer sb,\n-                                             int width,\n-                                             int nextLineTabStop,\n-                                             String text )\n-   {\n-      int pos = findWrapPos( text, width, 0);\n-      if ( pos == -1 )\n-      {\n-         sb.append(rtrim(text));\n-         return sb;\n-      }\n-      else\n-      {\n-         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n-      }\n-\n-      //all following lines must be padded with nextLineTabStop space characters\n-      final String padding = createPadding(nextLineTabStop);\n-\n-      while ( true )\n-      {\n-         text = padding + text.substring(pos).trim();\n-         pos = findWrapPos( text, width, nextLineTabStop );\n-         if ( pos == -1 )\n-         {\n-            sb.append(text);\n+public class HelpFormatter {\n+    // --------------------------------------------------------------- Constants\n+\n+    /** default number of characters per line */\n+    public static final int DEFAULT_WIDTH = 74;\n+\n+    /** default padding to the left of each line */\n+    public static final int DEFAULT_LEFT_PAD = 1;\n+\n+    /** ?? */\n+    public static final int DEFAULT_DESC_PAD = 3;\n+\n+    /** the string to display at the begining of the usage statement */\n+    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n+\n+    /** default prefix for shortOpts */\n+    public static final String DEFAULT_OPT_PREFIX = \"-\";\n+\n+    /** default prefix for long Option */\n+    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n+\n+    /** default name for an argument */\n+    public static final String DEFAULT_ARG_NAME = \"arg\";\n+\n+    // -------------------------------------------------------------- Attributes\n+\n+    /** number of characters per line */\n+    private int defaultWidth = DEFAULT_WIDTH;\n+\n+    /** amount of padding to the left of each line */\n+    private int defaultLeftPad = DEFAULT_LEFT_PAD;\n+\n+    /** ?? */\n+    private int defaultDescPad = DEFAULT_DESC_PAD;\n+\n+    /** the string to display at the begining of the usage statement */\n+    private String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n+\n+    /** the new line character/string ?? */\n+    private String defaultNewLine = System.getProperty(\"line.separator\");\n+\n+    /** the shortOpt prefix */\n+    private String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n+\n+    /** the long Opt prefix */\n+    private String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n+\n+    /** the name of the argument */\n+    private String defaultArgName = DEFAULT_ARG_NAME;\n+\n+    /**\n+     * Sets the 'width'.\n+     *\n+     * @param width the new value of 'width'\n+     */\n+    public void setWidth(int width)\n+    {\n+        this.defaultWidth = width;\n+    }\n+\n+    /**\n+     * Returns the 'width'.\n+     *\n+     * @return the 'width'\n+     */\n+    public int getWidth()\n+    {\n+        return this.defaultWidth;\n+    }\n+\n+    /**\n+     * Sets the 'leftPadding'.\n+     *\n+     * @param padding the new value of 'leftPadding'\n+     */\n+    public void setLeftPadding(int padding)\n+    {\n+        this.defaultLeftPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'leftPadding'.\n+     *\n+     * @return the 'leftPadding'\n+     */\n+    public int getLeftPadding()\n+    {\n+        return this.defaultLeftPad;\n+    }\n+\n+    /**\n+     * Sets the 'descPadding'.\n+     *\n+     * @param padding the new value of 'descPadding'\n+     */\n+    public void setDescPadding(int padding)\n+    {\n+        this.defaultDescPad = padding;\n+    }\n+\n+    /**\n+     * Returns the 'descPadding'.\n+     *\n+     * @return the 'descPadding'\n+     */\n+    public int getDescPadding()\n+    {\n+        return this.defaultDescPad;\n+    }\n+\n+    /**\n+     * Sets the 'syntaxPrefix'.\n+     *\n+     * @param prefix the new value of 'syntaxPrefix'\n+     */\n+    public void setSyntaxPrefix(String prefix)\n+    {\n+        this.defaultSyntaxPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'syntaxPrefix'.\n+     *\n+     * @return the 'syntaxPrefix'\n+     */\n+    public String getSyntaxPrefix()\n+    {\n+        return this.defaultSyntaxPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'newLine'.\n+     *\n+     * @param newline the new value of 'newLine'\n+     */\n+    public void setNewLine(String newline)\n+    {\n+        this.defaultNewLine = newline;\n+    }\n+\n+    /**\n+     * Returns the 'newLine'.\n+     *\n+     * @return the 'newLine'\n+     */\n+    public String getNewLine()\n+    {\n+        return this.defaultNewLine;\n+    }\n+\n+    /**\n+     * Sets the 'optPrefix'.\n+     *\n+     * @param prefix the new value of 'optPrefix'\n+     */\n+    public void setOptPrefix(String prefix)\n+    {\n+        this.defaultOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'optPrefix'.\n+     *\n+     * @return the 'optPrefix'\n+     */\n+    public String getOptPrefix()\n+    {\n+        return this.defaultOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'longOptPrefix'.\n+     *\n+     * @param prefix the new value of 'longOptPrefix'\n+     */\n+    public void setLongOptPrefix(String prefix)\n+    {\n+        this.defaultLongOptPrefix = prefix;\n+    }\n+\n+    /**\n+     * Returns the 'longOptPrefix'.\n+     *\n+     * @return the 'longOptPrefix'\n+     */\n+    public String getLongOptPrefix()\n+    {\n+        return this.defaultLongOptPrefix;\n+    }\n+\n+    /**\n+     * Sets the 'argName'.\n+     *\n+     * @param name the new value of 'argName'\n+     */\n+    public void setArgName(String name)\n+    {\n+        this.defaultArgName = name;\n+    }\n+\n+    /**\n+     * Returns the 'argName'.\n+     *\n+     * @return the 'argName'\n+     */\n+    public String getArgName()\n+    {\n+        return this.defaultArgName;\n+    }\n+\n+\n+    // ------------------------------------------------------------------ Public\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param options the Options instance\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, Options options, \n+                          boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, \n+                          String footer)\n+    {\n+        printHelp(cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(String cmdLineSyntax, String header, Options options, \n+                          String footer, boolean autoUsage)\n+    {\n+        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n+                  autoUsage);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header, \n+                          Options options, String footer)\n+    {\n+        printHelp(width, cmdLineSyntax, header, options, footer, false);\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(int width, String cmdLineSyntax, String header, \n+                          Options options, String footer, boolean autoUsage)\n+    {\n+        PrintWriter pw = new PrintWriter(System.out);\n+\n+        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n+                  defaultDescPad, footer, autoUsage);\n+        pw.flush();\n+    }\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n+                          String header, Options options, int leftPad, \n+                          int descPad, String footer)\n+    {\n+        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n+                  footer, false);\n+    }\n+\n+\n+    /**\n+     * <p>Print the help for <code>options</code> with the specified\n+     * command line syntax.</p>\n+     *\n+     * @param pw the writer to which the help will be written\n+     * @param width the number of characters to be displayed on each line\n+     * @param cmdLineSyntax the syntax for this application\n+     * @param header the banner to display at the begining of the help\n+     * @param options the Options instance\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     * @param footer the banner to display at the end of the help\n+     * @param autoUsage whether to print an automatically generated \n+     * usage statement\n+     */\n+    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n+                          String header, Options options, int leftPad, \n+                          int descPad, String footer, boolean autoUsage)\n+    {\n+        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n+        {\n+            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n+        }\n+\n+        if (autoUsage)\n+        {\n+            printUsage(pw, width, cmdLineSyntax, options);\n+        }\n+        else\n+        {\n+            printUsage(pw, width, cmdLineSyntax);\n+        }\n+\n+        if ((header != null) && (header.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, header);\n+        }\n+\n+        printOptions(pw, width, options, leftPad, descPad);\n+\n+        if ((footer != null) && (footer.trim().length() > 0))\n+        {\n+            printWrapped(pw, width, footer);\n+        }\n+    }\n+\n+    /**\n+     * <p>Prints the usage statement for the specified application.</p>\n+     *\n+     * @param pw The PrintWriter to print the usage statement \n+     * @param width The number of characters to display per line\n+     * @param app The application name\n+     * @param options The command line Options\n+     *\n+     */\n+    public void printUsage(PrintWriter pw, int width, String app, \n+                           Options options)\n+    {\n+        // initialise the string buffer\n+        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n+                                                                 .append(\" \");\n+\n+        // create a list for processed option groups\n+        final Collection processedGroups = new ArrayList();\n+\n+        // temp variable\n+        Option option;\n+\n+        // iterate over the options\n+        for (Iterator i = options.getOptions().iterator(); i.hasNext();)\n+        {\n+            // get the next Option\n+            option = (Option) i.next();\n+\n+            // check if the option is part of an OptionGroup\n+            OptionGroup group = options.getOptionGroup(option);\n+\n+            // if the option is part of a group \n+            if (group != null)\n+            {\n+                // and if the group has not already been processed\n+                if (!processedGroups.contains(group))\n+                {\n+                    // add the group to the processed list\n+                    processedGroups.add(group);\n+\n+\n+                    // add the usage clause\n+                    appendOptionGroup(buff, group);\n+                }\n+\n+                // otherwise the option was displayed in the group\n+                // previously so ignore it.\n+            }\n+\n+            // if the Option is not part of an OptionGroup\n+            else\n+            {\n+                appendOption(buff, option, option.isRequired());\n+            }\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" \");\n+            }\n+        }\n+\n+\n+        // call printWrapped\n+        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n+                     buff.toString());\n+    }\n+\n+    /**\n+     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n+     * The clause is wrapped in square brackets if the group is required.\n+     * The display of the options is handled by appendOption\n+     * @param buff the StringBuffer to append to\n+     * @param group the group to append\n+     * @see #appendOption(StringBuffer,Option,boolean)\n+     */\n+    private static void appendOptionGroup(final StringBuffer buff, \n+                                          final OptionGroup group)\n+    {\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        // for each option in the OptionGroup\n+        for (Iterator i = group.getOptions().iterator(); i.hasNext();)\n+        {\n+            // whether the option is required or not is handled at group level\n+            appendOption(buff, (Option) i.next(), true);\n+\n+            if (i.hasNext())\n+            {\n+                buff.append(\" | \");\n+            }\n+        }\n+\n+        if (!group.isRequired())\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * Appends the usage clause for an Option to a StringBuffer.  \n+     *\n+     * @param buff the StringBuffer to append to\n+     * @param option the Option to append\n+     * @param required whether the Option is required or not\n+     */\n+    private static void appendOption(final StringBuffer buff, \n+                                     final Option option, \n+                                     final boolean required)\n+    {\n+        if (!required)\n+        {\n+            buff.append(\"[\");\n+        }\n+\n+        if (option.getOpt() != null)\n+        {\n+            buff.append(\"-\").append(option.getOpt());\n+        }\n+        else\n+        {\n+            buff.append(\"--\").append(option.getLongOpt());\n+        }\n+\n+        // if the Option has a value\n+        if (option.hasArg() && (option.getArgName() != null))\n+        {\n+            buff.append(\" <\").append(option.getArgName()).append(\">\");\n+        }\n+\n+        // if the Option is not a required option\n+        if (!required)\n+        {\n+            buff.append(\"]\");\n+        }\n+    }\n+\n+    /**\n+     * <p>Print the cmdLineSyntax to the specified writer, using the\n+     * specified width.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters per line for the usage statement.\n+     * @param cmdLineSyntax The usage statement.\n+     */\n+    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n+    {\n+        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n+\n+        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n+                     defaultSyntaxPrefix + cmdLineSyntax);\n+    }\n+\n+    /**\n+     * <p>Print the help for the specified Options to the specified writer, \n+     * using the specified width, left padding and description padding.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     */\n+    public void printOptions(PrintWriter pw, int width, Options options, \n+                             int leftPad, int descPad)\n+    {\n+        StringBuffer sb = new StringBuffer();\n+\n+        renderOptions(sb, width, options, leftPad, descPad);\n+        pw.println(sb.toString());\n+    }\n+\n+    /**\n+     * <p>Print the specified text to the specified PrintWriter.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, String text)\n+    {\n+        printWrapped(pw, width, 0, text);\n+    }\n+\n+    /**\n+     * <p>Print the specified text to the specified PrintWriter.</p>\n+     *\n+     * @param pw The printWriter to write the help to\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be written to the PrintWriter\n+     */\n+    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n+                             String text)\n+    {\n+        StringBuffer sb = new StringBuffer(text.length());\n+\n+        renderWrappedText(sb, width, nextLineTabStop, text);\n+        pw.println(sb.toString());\n+    }\n+\n+    // --------------------------------------------------------------- Protected\n+\n+    /**\n+     * <p>Render the specified Options and return the rendered Options\n+     * in a StringBuffer.</p>\n+     *\n+     * @param sb The StringBuffer to place the rendered Options into.\n+     * @param width The number of characters to display per line\n+     * @param options The command line Options\n+     * @param leftPad the number of characters of padding to be prefixed\n+     * to each line\n+     * @param descPad the number of characters of padding to be prefixed\n+     * to each description line\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderOptions(StringBuffer sb, int width, \n+                                         Options options, int leftPad, \n+                                         int descPad)\n+    {\n+        final String lpad = createPadding(leftPad);\n+        final String dpad = createPadding(descPad);\n+\n+        // first create list containing only <lpad>-a,--aaa where \n+        // -a is opt and --aaa is long opt; in parallel look for \n+        // the longest opt string this list will be then used to \n+        // sort options ascending\n+        int max = 0;\n+        StringBuffer optBuf;\n+        List prefixList = new ArrayList();\n+        Option option;\n+        List optList = options.helpOptions();\n+\n+        Collections.sort(optList, new StringBufferComparator());\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            option = (Option) i.next();\n+            optBuf = new StringBuffer(8);\n+\n+            if (option.getOpt() == null)\n+            {\n+                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n+                      .append(option.getLongOpt());\n+            }\n+            else\n+            {\n+                optBuf.append(lpad).append(defaultOptPrefix)\n+                      .append(option.getOpt());\n+\n+                if (option.hasLongOpt())\n+                {\n+                    optBuf.append(',').append(defaultLongOptPrefix)\n+                          .append(option.getLongOpt());\n+                }\n+            }\n+\n+            if (option.hasArg())\n+            {\n+                if (option.hasArgName())\n+                {\n+                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n+                }\n+                else\n+                {\n+                    optBuf.append(' ');\n+                }\n+            }\n+\n+            prefixList.add(optBuf);\n+            max = (optBuf.length() > max)       ? optBuf.length() : max;\n+        }\n+\n+        int x = 0;\n+\n+        for (Iterator i = optList.iterator(); i.hasNext();)\n+        {\n+            option = (Option) i.next();\n+            optBuf = new StringBuffer(prefixList.get(x++).toString());\n+\n+            if (optBuf.length() < max)\n+            {\n+                optBuf.append(createPadding(max - optBuf.length()));\n+            }\n+\n+            optBuf.append(dpad);\n+\n+            int nextLineTabStop = max + descPad;\n+\n+            if (option.getDescription() != null)\n+            {\n+                optBuf.append(option.getDescription());\n+            }\n+\n+            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n+\n+            if (i.hasNext())\n+            {\n+                sb.append(defaultNewLine);\n+            }\n+        }\n+\n+        return sb;\n+    }\n+\n+    /**\n+     * <p>Render the specified text and return the rendered Options\n+     * in a StringBuffer.</p>\n+     *\n+     * @param sb The StringBuffer to place the rendered text into.\n+     * @param width The number of characters to display per line\n+     * @param nextLineTabStop The position on the next line for the first tab.\n+     * @param text The text to be rendered.\n+     *\n+     * @return the StringBuffer with the rendered Options contents.\n+     */\n+    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n+                                             int nextLineTabStop, String text)\n+    {\n+        int pos = findWrapPos(text, width, 0);\n+\n+        if (pos == -1)\n+        {\n+            sb.append(rtrim(text));\n+\n             return sb;\n-         }\n-\n-         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n-      }\n-\n-   }\n-\n-   /**\n-    * Finds the next text wrap position after <code>startPos</code> for the text\n-    * in <code>sb</code> with the column width <code>width</code>.\n-    * The wrap point is the last postion before startPos+width having a whitespace\n-    * character (space, \\n, \\r).\n-    *\n-    * @param sb text to be analyzed\n-    * @param width width of the wrapped text\n-    * @param startPos position from which to start the lookup whitespace character\n-    * @return postion on which the text must be wrapped or -1 if the wrap position is at the end\n-    *         of the text\n-    */\n-   protected int findWrapPos( String text, int width, int startPos )\n-   {\n-      int pos = -1;\n-      // the line ends before the max wrap pos or a new line char found\n-      if ( ((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)  ||\n-           ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width) )\n-      {\n-         return pos;\n-      }\n-      else if ( (startPos + width) >= text.length() )\n-      {\n-         return -1;\n-      }\n-\n-      //look for the last whitespace character before startPos+width\n-      pos = startPos + width;\n-      char c;\n-      while ( pos >= startPos && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r' )\n-      {\n-         --pos;\n-      }\n-      //if we found it - just return\n-      if ( pos > startPos )\n-      {\n-         return pos;\n-      }\n-      else\n-      {\n-         //must look for the first whitespace chearacter after startPos + width\n-         pos = startPos + width;\n-         while ( pos <= text.length() && (c = text.charAt(pos)) != ' ' && c != '\\n' && c != '\\r' )\n-         {\n-            ++pos;\n-         }\n-         return pos == text.length() ? -1 : pos;\n-      }\n-   }\n-\n-   protected String createPadding(int len)\n-   {\n-      StringBuffer sb = new StringBuffer(len);\n-      for ( int i = 0; i < len; ++i )\n-      {\n-         sb.append(' ');\n-      }\n-      return sb.toString();\n-   }\n-\n-   protected String rtrim( String s )\n-   {\n-      if ( s == null || s.length() == 0 )\n-      {\n-         return s;\n-      }\n-\n-      int pos = s.length();\n-      while ( pos >= 0 && Character.isWhitespace(s.charAt(pos-1)) )\n-      {\n-         --pos;\n-      }\n-      return s.substring(0, pos);\n-   }\n-\n-   // ------------------------------------------------------- Package protected\n-   \n-   // ----------------------------------------------------------------- Private\n-   \n-   // ----------------------------------------------------------- Inner classes\n-\n+        }\n+        else\n+        {\n+            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+        }\n+\n+        // all following lines must be padded with nextLineTabStop space \n+        // characters\n+        final String padding = createPadding(nextLineTabStop);\n+\n+        while (true)\n+        {\n+            text = padding + text.substring(pos).trim();\n+            pos = findWrapPos(text, width, nextLineTabStop);\n+\n+            if (pos == -1)\n+            {\n+                sb.append(text);\n+\n+                return sb;\n+            }\n+\n+            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next text wrap position after <code>startPos</code> for the \n+     * text in <code>text</code> with the column width <code>width</code>.\n+     * The wrap point is the last postion before startPos+width having a \n+     * whitespace character (space, \\n, \\r).\n+     *\n+     * @param text The text being searched for the wrap position\n+     * @param width width of the wrapped text\n+     * @param startPos position from which to start the lookup whitespace \n+     * character\n+     * @return postion on which the text must be wrapped or -1 if the wrap \n+     * position is at the end of the text\n+     */\n+    protected int findWrapPos(String text, int width, int startPos)\n+    {\n+        int pos = -1;\n+\n+        // the line ends before the max wrap pos or a new line char found\n+        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n+            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n+        {\n+            return pos;\n+        }\n+        else if ((startPos + width) >= text.length())\n+        {\n+            return -1;\n+        }\n+\n+\n+        // look for the last whitespace character before startPos+width\n+        pos = startPos + width;\n+\n+        char c;\n+\n+        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n+               && (c != '\\n') && (c != '\\r'))\n+        {\n+            --pos;\n+        }\n+\n+        // if we found it - just return\n+        if (pos > startPos)\n+        {\n+            return pos;\n+        }\n+        else\n+        {\n+            // must look for the first whitespace chearacter after startPos \n+            // + width\n+            pos = startPos + width;\n+\n+            while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n+                   && (c != '\\n') && (c != '\\r'))\n+            {\n+                ++pos;\n+            }\n+\n+            return (pos == text.length())        ? (-1) : pos;\n+        }\n+    }\n+\n+    /**\n+     * <p>Return a String of padding of length <code>len</code>.</p>\n+     *\n+     * @param len The length of the String of padding to create.\n+     *\n+     * @return The String of padding\n+     */\n+    protected String createPadding(int len)\n+    {\n+        StringBuffer sb = new StringBuffer(len);\n+\n+        for (int i = 0; i < len; ++i)\n+        {\n+            sb.append(' ');\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * <p>Remove the trailing whitespace from the specified String.</p>\n+     *\n+     * @param s The String to remove the trailing padding from.\n+     *\n+     * @return The String of without the trailing padding\n+     */\n+    protected String rtrim(String s)\n+    {\n+        if ((s == null) || (s.length() == 0))\n+        {\n+            return s;\n+        }\n+\n+        int pos = s.length();\n+\n+        while ((pos >= 0) && Character.isWhitespace(s.charAt(pos - 1)))\n+        {\n+            --pos;\n+        }\n+\n+        return s.substring(0, pos);\n+    }\n+\n+    // ------------------------------------------------------ Package protected\n+    // ---------------------------------------------------------------- Private\n+    // ---------------------------------------------------------- Inner classes\n+    /**\n+     * <p>This class implements the <code>Comparator</code> interface\n+     * for comparing StringBuffers.</p>\n+     */\n     private static class StringBufferComparator\n-    implements Comparator\n-    {\n-        public int compare( Object o1, Object o2 )\n+        implements Comparator {\n+\n+        /**\n+         * <p>Compares its two arguments for order. Returns a negative \n+         * integer, zero, or a positive integer as the first argument \n+         * is less than, equal to, or greater than the second.</p>\n+         *\n+         * @param o1 The first StringBuffer to be compared.\n+         * @param o2 The second StringBuffer to be compared.\n+         *\n+         * @return a negative integer, zero, or a positive integer as \n+         * the first argument is less than, equal to, or greater than the \n+         * second.\n+         */\n+        public int compare(Object o1, Object o2)\n         {\n             String str1 = stripPrefix(o1.toString());\n             String str2 = stripPrefix(o2.toString());\n+\n             return (str1.compareTo(str2));\n         }\n \n+        /**\n+         * <p>Removes any leading hyphens from <code>strOption</code>.</p>\n+         *         \n+         * @param strOption The String from which to strip the leading\n+         * hyphens.\n+         *\n+         * @return The String without any leading hyphens.\n+         */\n         private String stripPrefix(String strOption)\n         {\n             // Strip any leading '-' characters\n             int iStartIndex = strOption.lastIndexOf('-');\n+\n             if (iStartIndex == -1)\n             {\n-              iStartIndex = 0;\n-            }\n+                iStartIndex = 0;\n+            }\n+\n             return strOption.substring(iStartIndex);\n-\n-        }\n-    }\n-}\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/cli/MissingArgumentException.java\n+++ b/src/java/org/apache/commons/cli/MissingArgumentException.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n /** \n  * @author John Keyes (john at integralsource.com)\n  * @see ParseException\n  */\n-public class MissingArgumentException extends ParseException {\n-    \n+public class MissingArgumentException\n+    extends ParseException {\n+\n     /** \n      * <p>Construct a new <code>MissingArgumentException</code> \n      * with the specified detail message.</p>\n      *\n      * @param message the detail message\n      */\n-    public MissingArgumentException( String message ) {\n-        super( message );\n+    public MissingArgumentException(String message)\n+    {\n+        super(message);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/MissingOptionException.java\n+++ b/src/java/org/apache/commons/cli/MissingOptionException.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n /** \n  * @author John Keyes ( john at integralsource.com )\n  * @see ParseException\n  */\n-public class MissingOptionException extends ParseException {\n-    \n+public class MissingOptionException\n+    extends ParseException {\n+\n     /** \n      * <p>Construct a new <code>MissingSelectedException</code> \n      * with the specified detail message.</p>\n      *\n      * @param message the detail message\n      */\n-    public MissingOptionException( String message ) {\n-        super( message );\n+    public MissingOptionException(String message)\n+    {\n+        super(message);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/Option.java\n+++ b/src/java/org/apache/commons/cli/Option.java\n  */\n public class Option implements Cloneable {\n \n-    /** constant that specifies the number of argument values has not been specified */\n-    public final static int UNINITIALIZED = -1;\n-    \n+    /** constant that specifies the number of argument values has \n+        not been specified */\n+    public static final int UNINITIALIZED = -1;\n+\n     /** constant that specifies the number of argument values is infinite */\n-    public final static int UNLIMITED_VALUES = -2;\n-    \n+    public static final int UNLIMITED_VALUES = -2;\n+\n     /** opt the name of the option */\n     private String opt;\n \n      * numberOfArgs specifies the number of argument values this option \n      * can have \n      */\n-    private int numberOfArgs = UNINITIALIZED;   \n+    private int numberOfArgs = UNINITIALIZED;\n \n     /** the type of this Option */\n     private Object type;\n \n     /** the list of argument values **/\n     private ArrayList values = new ArrayList();\n-    \n+\n     /** the character that is the value separator */\n     private char valuesep;\n+\n+    /**\n+     * Creates an Option using the specified parameters.\n+     *\n+     * @param opt short representation of the option\n+     * @param description describes the function of the option\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, String description)\n+           throws IllegalArgumentException\n+    {\n+        this(opt, null, false, description);\n+    }\n \n     /**\n      * Creates an Option using the specified parameters.\n      * @param opt short representation of the option\n      * @param hasArg specifies whether the Option takes an argument or not\n      * @param description describes the function of the option\n-     */\n-    public Option( String opt, String description ) \n-    throws IllegalArgumentException\n-    {\n-        this( opt, null, false, description );\n-    }\n-\n-    /**\n-     * Creates an Option using the specified parameters.\n-     *\n-     * @param opt short representation of the option\n-     * @param hasArg specifies whether the Option takes an argument or not\n-     * @param description describes the function of the option\n-     */\n-    public Option( String opt, boolean hasArg, String description ) \n-    throws IllegalArgumentException\n-    {\n-        this( opt, null, hasArg, description );\n-    }\n-    \n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, boolean hasArg, String description)\n+           throws IllegalArgumentException\n+    {\n+        this(opt, null, hasArg, description);\n+    }\n+\n     /**\n      * <p>Creates an Option using the specified parameters.</p>\n      *\n      * @param longOpt the long representation of the option\n      * @param hasArg specifies whether the Option takes an argument or not\n      * @param description describes the function of the option\n-     */\n-    public Option( String opt, String longOpt, boolean hasArg, String description ) \n-    throws IllegalArgumentException\n+     *\n+     * @throws IllegalArgumentException if there are any non valid\n+     * Option characters in <code>opt</code>.\n+     */\n+    public Option(String opt, String longOpt, boolean hasArg, \n+                  String description)\n+           throws IllegalArgumentException\n     {\n         // ensure that the option is valid\n-        OptionValidator.validateOption( opt );\n-\n-        this.opt          = opt;\n-        this.longOpt      = longOpt;\n+        OptionValidator.validateOption(opt);\n+\n+        this.opt = opt;\n+        this.longOpt = longOpt;\n \n         // if hasArg is set then the number of arguments is 1\n-        if( hasArg ) {\n+        if (hasArg)\n+        {\n             this.numberOfArgs = 1;\n         }\n \n-        this.hasArg       = hasArg;\n-        this.description  = description;\n-    }\n-    \n+        this.hasArg = hasArg;\n+        this.description = description;\n+    }\n+\n     /**\n      * <p>Returns the id of this Option.  This is only set when the\n      * Option shortOpt is a single character.  This is used for switch\n      *\n      * @return the id of this Option\n      */\n-    public int getId( ) {\n-        return getKey().charAt( 0 );\n+    public int getId()\n+    {\n+        return getKey().charAt(0);\n     }\n \n     /**\n      * \n      * @return the 'unique' Option identifier\n      */\n-    String getKey() {\n+    String getKey()\n+    {\n         // if 'opt' is null, then it is a 'long' option\n-        if( opt == null ) {\n+        if (opt == null)\n+        {\n             return this.longOpt;\n         }\n+\n         return this.opt;\n     }\n \n      *\n      * @return The name of this option\n      */\n-    public String getOpt() {\n+    public String getOpt()\n+    {\n         return this.opt;\n     }\n \n      * \n      * @return The type of this option\n      */\n-    public Object getType() {\n+    public Object getType()\n+    {\n         return this.type;\n     }\n \n      *\n      * @param type the type of this Option\n      */\n-    public void setType( Object type ) {\n+    public void setType(Object type)\n+    {\n         this.type = type;\n     }\n-    \n+\n     /** \n      * <p>Retrieve the long name of this Option.</p>\n      *\n      * @return Long name of this option, or null, if there is no long name\n      */\n-    public String getLongOpt() {\n+    public String getLongOpt()\n+    {\n         return this.longOpt;\n     }\n \n      *\n      * @param longOpt the long name of this Option\n      */\n-    public void setLongOpt( String longOpt ) {\n+    public void setLongOpt(String longOpt)\n+    {\n         this.longOpt = longOpt;\n     }\n \n      * @param optionalArg specifies whether the Option can have\n      * an optional argument.\n      */\n-    public void setOptionalArg( boolean optionalArg ) {\n+    public void setOptionalArg(boolean optionalArg)\n+    {\n         this.optionalArg = optionalArg;\n     }\n \n     /**\n      * @return whether this Option can have an optional argument\n      */\n-    public boolean hasOptionalArg( ) {\n+    public boolean hasOptionalArg()\n+    {\n         return this.optionalArg;\n     }\n-    \n+\n     /** <p>Query to see if this Option has a long name</p>\n      *\n      * @return boolean flag indicating existence of a long name\n      */\n-    public boolean hasLongOpt() {\n-        return ( this.longOpt != null );\n-    }\n-    \n+    public boolean hasLongOpt()\n+    {\n+        return (this.longOpt != null);\n+    }\n+\n     /** <p>Query to see if this Option requires an argument</p>\n      *\n      * @return boolean flag indicating if an argument is required\n      */\n-    public boolean hasArg() {\n-        return this.numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n-    }\n-    \n+    public boolean hasArg()\n+    {\n+        return (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n+    }\n+\n     /** <p>Retrieve the self-documenting description of this Option</p>\n      *\n      * @return The string description of this option\n      */\n-    public String getDescription() {\n+    public String getDescription()\n+    {\n         return this.description;\n     }\n \n      *\n      * @return boolean flag indicating if an argument is required\n      */\n-    public boolean isRequired() {\n+    public boolean isRequired()\n+    {\n         return this.required;\n     }\n \n      *\n      * @param required specifies whether this Option is mandatory\n      */\n-    public void setRequired( boolean required ) {\n+    public void setRequired(boolean required)\n+    {\n         this.required = required;\n     }\n \n      *\n      * @param argName the display name for the argument value.\n      */\n-    public void setArgName( String argName ) {\n+    public void setArgName(String argName)\n+    {\n         this.argName = argName;\n     }\n \n      *\n      * @return the display name for the argument value.\n      */\n-    public String getArgName() {\n+    public String getArgName()\n+    {\n         return this.argName;\n     }\n \n      * @return if the display name for the argument value has been\n      * set.\n      */\n-    public boolean hasArgName() {\n-        return (this.argName != null && this.argName.length() > 0 );\n+    public boolean hasArgName()\n+    {\n+        return (this.argName != null && this.argName.length() > 0);\n     }\n \n     /** \n      *\n      * @return boolean flag indicating if multiple values are allowed\n      */\n-    public boolean hasArgs() {\n-        return this.numberOfArgs > 1 || this.numberOfArgs == UNLIMITED_VALUES;\n+    public boolean hasArgs()\n+    {\n+        return (this.numberOfArgs > 1) \n+                || (this.numberOfArgs == UNLIMITED_VALUES);\n     }\n \n     /** \n      *\n      * @param num the number of argument values\n      */\n-    public void setArgs( int num ) {\n+    public void setArgs(int num)\n+    {\n         this.numberOfArgs = num;\n     }\n \n      *\n      * @param sep The value separator.\n      */\n-    public void setValueSeparator( char sep ) {\n+    public void setValueSeparator(char sep)\n+    {\n         this.valuesep = sep;\n     }\n \n      *\n      * @return the value separator character.\n      */\n-    public char getValueSeparator() {\n+    public char getValueSeparator()\n+    {\n         return this.valuesep;\n     }\n \n     /**\n-     * ...\n-     */\n-    public boolean hasValueSeparator() {\n-        return ( this.valuesep > 0 );\n+     * <p>Return whether this Option has specified a value separator.</p>\n+     * \n+     * @return whether this Option has specified a value separator.</p>\n+     */\n+    public boolean hasValueSeparator()\n+    {\n+        return (this.valuesep > 0);\n     }\n \n     /** \n      *\n      * @return num the number of argument values\n      */\n-    public int getArgs( ) {\n+    public int getArgs()\n+    {\n         return this.numberOfArgs;\n     }\n \n      * \n      * @param value is a/the value of this Option\n      */\n-    void addValue( String value )\n-    {\n-        switch( numberOfArgs ) {\n-            case UNINITIALIZED:\n-                throw new RuntimeException( \"Cannot add value, no arguments allowed.\" );\n-            default:\n-                processValue( value );\n+    void addValue(String value)\n+    {\n+        switch (numberOfArgs)\n+        {\n+        case UNINITIALIZED:\n+            throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n+\n+        default:\n+            processValue(value);\n         }\n     }\n \n      * in the value, parsing is ceased and the remaining characters are\n      * added as a single token.</p>\n      *\n+     * @param value The String to be processed.\n+     *\n      * @since 1.0.1\n      */\n-    private void processValue( String value ) {\n-\n+    private void processValue(String value)\n+    {\n         // this Option has a separator character\n-        if( hasValueSeparator() ) {\n-\n+        if (hasValueSeparator())\n+        {\n             // get the separator character\n             char sep = getValueSeparator();\n \n             // store the index for the value separator\n-            int index = value.indexOf( sep );\n+            int index = value.indexOf(sep);\n \n             // while there are more value separators\n-            while( index != -1 ) {\n-\n+            while (index != -1)\n+            {\n                 // next value to be added \n-                if( values.size() == numberOfArgs-1 ) {\n+                if (values.size() == (numberOfArgs - 1))\n+                {\n                     break;\n-                } \n+                }\n+\n \n                 // store\n-                add( value.substring( 0, index ) );\n+                add(value.substring(0, index));\n+\n \n                 // parse\n-                value = value.substring( index+1 );\n+                value = value.substring(index + 1);\n+\n \n                 // get new index\n-                index = value.indexOf( sep );\n+                index = value.indexOf(sep);\n             }\n         }\n \n+\n         // store the actual value or the last value that has been parsed\n-        add( value );\n+        add(value);\n     }\n \n     /**\n      * add the value.  Otherwise, throw a runtime exception.\n      * </p>\n      *\n+     * @param value The value to be added to this Option\n+     *\n      * @since 1.0.1\n      */\n-    private void add( String value ) {\n-        if( numberOfArgs > 0 && values.size() > numberOfArgs-1 ) {\n-            throw new RuntimeException( \"Cannot add value, list full.\" );\n-        }\n+    private void add(String value)\n+    {\n+        if ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n+        {\n+            throw new RuntimeException(\"Cannot add value, list full.\");\n+        }\n+\n+\n         // store value\n-        this.values.add( value );\n-    }\n-\n-    /**\n+        this.values.add(value);\n+    }\n+\n+    /**\n+     * Returns the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n      * @return the value/first value of this Option or \n-     * <code>null</code> if there are no values.\n-     */\n-    public String getValue() {\n-        return this.values.size()==0 ? null : (String)this.values.get( 0 );\n-    }\n-\n-    /**\n+     * <code>null</code> if there is no value.\n+     */\n+    public String getValue()\n+    {\n+        return hasNoValues() ? null : (String) this.values.get(0);\n+    }\n+\n+    /**\n+     * Returns the specified value of this Option or \n+     * <code>null</code> if there is no value.\n+     *\n+     * @param index The index of the value to be returned.\n+     *\n      * @return the specified value of this Option or \n-     * <code>null</code> if there are no values.\n-     */\n-    public String getValue( int index ) \n-    throws IndexOutOfBoundsException\n-    {\n-        return ( this.values.size()==0 ) ? null : (String)this.values.get( index );\n-    }\n-\n-    /**\n+     * <code>null</code> if there is no value.\n+     *\n+     * @throws IndexOutOfBoundsException if index is less than 1\n+     * or greater than the number of the values for this Option.\n+     */\n+    public String getValue(int index)\n+        throws IndexOutOfBoundsException\n+    {\n+        return hasNoValues() ? null : (String) this.values.get(index);\n+    }\n+\n+    /**\n+     * Returns the value/first value of this Option or the \n+     * <code>defaultValue</code> if there is no value.\n+     *\n+     * @param defaultValue The value to be returned if ther\n+     * is no value.\n+     *\n      * @return the value/first value of this Option or the \n      * <code>defaultValue</code> if there are no values.\n      */\n-    public String getValue( String defaultValue ) {\n-        String value = getValue( );\n-        return ( value != null ) ? value : defaultValue;\n-    }\n-\n-    /**\n+    public String getValue(String defaultValue)\n+    {\n+        String value = getValue();\n+\n+        return (value != null) ? value : defaultValue;\n+    }\n+\n+    /**\n+     * Return the values of this Option as a String array \n+     * or null if there are no values\n+     *\n      * @return the values of this Option as a String array \n      * or null if there are no values\n      */\n-    public String[] getValues() {\n-        return this.values.size()==0 ? null : (String[])this.values.toArray(new String[]{});\n+    public String[] getValues()\n+    {\n+        return hasNoValues()\n+               ? null : (String[]) this.values.toArray(new String[] {  });\n     }\n \n     /**\n      * @return the values of this Option as a List\n      * or null if there are no values\n      */\n-    public java.util.List getValuesList() {\n+    public java.util.List getValuesList()\n+    {\n         return this.values;\n     }\n \n     /**\n      * @return a copy of this Option\n      */\n-    public Object clone() {\n-        Option option = new Option( getOpt(), getDescription() );\n-        option.setArgs( getArgs() );\n-        option.setOptionalArg( hasOptionalArg() );\n-        option.setRequired( isRequired() );\n-        option.setLongOpt( getLongOpt() );\n-        option.setType( getType() );\n-        option.setValueSeparator( getValueSeparator() );\n+    public Object clone()\n+    {\n+        Option option = new Option(getOpt(), getDescription());\n+\n+        option.setArgs(getArgs());\n+        option.setOptionalArg(hasOptionalArg());\n+        option.setRequired(isRequired());\n+        option.setLongOpt(getLongOpt());\n+        option.setType(getType());\n+        option.setValueSeparator(getValueSeparator());\n+\n         return option;\n     }\n \n      *\n      * @return Stringified form of this object\n      */\n-    public String toString() {\n+    public String toString()\n+    {\n         StringBuffer buf = new StringBuffer().append(\"[ option: \");\n-        \n-        buf.append( this.opt );\n-        \n-        if ( this.longOpt != null ) {\n-            buf.append(\" \")\n-            .append(this.longOpt);\n-        }\n-        \n+\n+        buf.append(this.opt);\n+\n+        if (this.longOpt != null)\n+        {\n+            buf.append(\" \").append(this.longOpt);\n+        }\n+\n         buf.append(\" \");\n-        \n-        if ( hasArg ) {\n-            buf.append( \"+ARG\" );\n-        }\n-        \n-        buf.append(\" :: \")\n-        .append( this.description );\n-        \n-        if ( this.type != null ) {\n-            buf.append(\" :: \")\n-            .append( this.type );\n+\n+        if (hasArg)\n+        {\n+            buf.append(\"+ARG\");\n+        }\n+\n+        buf.append(\" :: \").append(this.description);\n+\n+        if (this.type != null)\n+        {\n+            buf.append(\" :: \").append(this.type);\n         }\n \n         buf.append(\" ]\");\n+\n         return buf.toString();\n     }\n \n-}\n+    /**\n+     * Returns whether this Option has any values.\n+     *\n+     * @return whether this Option has any values.\n+     */\n+    private boolean hasNoValues()\n+    {\n+        return this.values.size() == 0;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli/OptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/OptionBuilder.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/OptionBuilder.java,v 1.14 2002/11/19 22:54:48 jkeyes Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/11/19 22:54:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/OptionBuilder.java,v 1.15 2002/12/09 23:47:24 jkeyes Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2002/12/09 23:47:24 $\n  *\n  * ====================================================================\n  *\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n /**\n  * <p>OptionBuilder allows the user to create Options using descriptive\n  * methods.</p>\n  * <p>Details on the Builder pattern can be found at \n- * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n- *\n- * @author John Keyes ( john at integralsource.com )\n+ * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n+ * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n+ *\n+ * @author John Keyes (john at integralsource.com)\n  * @since 1.0\n  */\n public class OptionBuilder {\n \n     /** long option */\n     private static String longopt;\n+\n     /** option description */\n     private static String description;\n+\n     /** argument name */\n     private static String argName;\n+\n     /** is required? */\n     private static boolean required;\n+\n     /** the number of arguments */\n     private static int numberOfArgs = Option.UNINITIALIZED;\n+\n     /** option type */\n     private static Object type;\n+\n     /** option can have an optional argument value */\n     private static boolean optionalArg;\n+\n     /** value separator for argument value */\n     private static char valuesep;\n \n     /** option builder instance */\n     private static OptionBuilder instance = new OptionBuilder();\n \n-    // private constructor\n-    private OptionBuilder() {\n+    /**\n+     * private constructor to prevent instances being created\n+     */\n+    private OptionBuilder()\n+    {\n     }\n \n     /**\n      * <p>Resets the member variables to their default values.</p>\n      */\n-    private static void reset() {\n+    private static void reset()\n+    {\n         description = null;\n         argName = \"arg\";\n         longopt = null;\n         required = false;\n         numberOfArgs = Option.UNINITIALIZED;\n \n+\n         // PMM 9/6/02 - these were missing\n         optionalArg = false;\n         valuesep = (char) 0;\n      * @param longopt the long option value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withLongOpt( String longopt ) {\n+    public static OptionBuilder withLongOpt(String longopt)\n+    {\n         instance.longopt = longopt;\n+\n         return instance;\n     }\n \n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArg( ) {\n+    public static OptionBuilder hasArg()\n+    {\n         instance.numberOfArgs = 1;\n+\n         return instance;\n     }\n \n      * @param hasArg if true then the Option has an argument value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArg( boolean hasArg ) {\n-        instance.numberOfArgs = ( hasArg == true ) ? 1 : Option.UNINITIALIZED;\n+    public static OptionBuilder hasArg(boolean hasArg)\n+    {\n+        instance.numberOfArgs = (hasArg == true) ? 1 : Option.UNINITIALIZED;\n+\n         return instance;\n     }\n \n      * @param name the name for the argument value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withArgName( String name ) {\n+    public static OptionBuilder withArgName(String name)\n+    {\n         instance.argName = name;\n+\n         return instance;\n     }\n \n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder isRequired( ) {\n+    public static OptionBuilder isRequired()\n+    {\n         instance.required = true;\n+\n         return instance;\n     }\n \n      *\n      * <b>Example:</b>\n      * <pre>\n-     * Option opt = OptionBuilder.withValueSeparator( ':' )\n-     *                           .create( 'D' );\n-     *\n-     * CommandLine line = parser.parse( args );\n-     * String propertyName = opt.getValue( 0 );\n-     * String propertyValue = opt.getValue( 1 );\n+     * Option opt = OptionBuilder.withValueSeparator(':')\n+     *                           .create('D');\n+     *\n+     * CommandLine line = parser.parse(args);\n+     * String propertyName = opt.getValue(0);\n+     * String propertyValue = opt.getValue(1);\n      * </pre>\n      *\n-     * @return the OptionBuilder instance\n-     */\n-    public static OptionBuilder withValueSeparator( char sep ) {\n+     * @param sep The value separator to be used for the argument values.\n+     *\n+     * @return the OptionBuilder instance\n+     */\n+    public static OptionBuilder withValueSeparator(char sep)\n+    {\n         instance.valuesep = sep;\n+\n         return instance;\n     }\n \n      *\n      * <b>Example:</b>\n      * <pre>\n-     * Option opt = OptionBuilder.withValueSeparator( )\n-     *                           .create( 'D' );\n-     *\n-     * CommandLine line = parser.parse( args );\n-     * String propertyName = opt.getValue( 0 );\n-     * String propertyValue = opt.getValue( 1 );\n+     * Option opt = OptionBuilder.withValueSeparator()\n+     *                           .create('D');\n+     *\n+     * CommandLine line = parser.parse(args);\n+     * String propertyName = opt.getValue(0);\n+     * String propertyValue = opt.getValue(1);\n      * </pre>\n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withValueSeparator( ) {\n+    public static OptionBuilder withValueSeparator()\n+    {\n         instance.valuesep = '=';\n+\n         return instance;\n     }\n \n      * @param required if true then the Option is required\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder isRequired( boolean required ) {\n+    public static OptionBuilder isRequired(boolean required)\n+    {\n         instance.required = required;\n+\n         return instance;\n     }\n \n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArgs( ) {\n+    public static OptionBuilder hasArgs()\n+    {\n         instance.numberOfArgs = Option.UNLIMITED_VALUES;\n+\n         return instance;\n     }\n \n      * @param num the number of args that the option can have\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasArgs( int num ) {\n+    public static OptionBuilder hasArgs(int num)\n+    {\n         instance.numberOfArgs = num;\n+\n         return instance;\n     }\n \n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasOptionalArg( ) {\n+    public static OptionBuilder hasOptionalArg()\n+    {\n         instance.numberOfArgs = 1;\n         instance.optionalArg = true;\n+\n         return instance;\n     }\n \n      *\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasOptionalArgs( ) {\n+    public static OptionBuilder hasOptionalArgs()\n+    {\n         instance.numberOfArgs = Option.UNLIMITED_VALUES;\n         instance.optionalArg = true;\n+\n         return instance;\n     }\n \n      * the next Option created can have.\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder hasOptionalArgs( int numArgs ) {\n+    public static OptionBuilder hasOptionalArgs(int numArgs)\n+    {\n         instance.numberOfArgs = numArgs;\n         instance.optionalArg = true;\n+\n         return instance;\n     }\n \n      * @param type the type of the Options argument value\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withType( Object type ) {\n+    public static OptionBuilder withType(Object type)\n+    {\n         instance.type = type;\n+\n         return instance;\n     }\n \n      * @param description a description of the Option's purpose\n      * @return the OptionBuilder instance\n      */\n-    public static OptionBuilder withDescription( String description ) {\n+    public static OptionBuilder withDescription(String description)\n+    {\n         instance.description = description;\n+\n         return instance;\n     }\n \n      * @throws IllegalArgumentException if <code>opt</code> is not\n      * a valid character.  See Option.\n      */\n-    public static Option create( char opt )\n-    throws IllegalArgumentException\n-    {\n-        return create( String.valueOf( opt ) );\n+    public static Option create(char opt)\n+                         throws IllegalArgumentException\n+    {\n+        return create(String.valueOf(opt));\n     }\n \n     /**\n      * @throws IllegalArgumentException if <code>longOpt</code> has\n      * not been set.  \n      */\n-    public static Option create() \n-    throws IllegalArgumentException\n-    {\n-        if( longopt == null ) {\n-            throw new IllegalArgumentException( \"must specify longopt\" );\n+    public static Option create()\n+                         throws IllegalArgumentException\n+    {\n+        if (longopt == null)\n+        {\n+            throw new IllegalArgumentException(\"must specify longopt\");\n         }\n \n-        return create( null );\n+        return create(null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if <code>opt</code> is not\n      * a valid character.  See Option.\n      */\n-    public static Option create( String opt ) \n-    throws IllegalArgumentException\n+    public static Option create(String opt)\n+                         throws IllegalArgumentException\n     {\n         // create the option\n-        Option option = new Option( opt, description );\n+        Option option = new Option(opt, description);\n+\n \n         // set the option properties\n-        option.setLongOpt( longopt );\n-        option.setRequired( required );\n-        option.setOptionalArg( optionalArg );\n-        option.setArgs( numberOfArgs );\n-        option.setType( type );\n-        option.setValueSeparator( valuesep );\n-        option.setArgName( argName );\n+        option.setLongOpt(longopt);\n+        option.setRequired(required);\n+        option.setOptionalArg(optionalArg);\n+        option.setArgs(numberOfArgs);\n+        option.setType(type);\n+        option.setValueSeparator(valuesep);\n+        option.setArgName(argName);\n+\n+\n         // reset the OptionBuilder properties\n         instance.reset();\n \n--- a/src/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/java/org/apache/commons/cli/OptionGroup.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n import java.util.Collection;\n      * @param opt the option to add to this group\n      * @return this option group with opt added\n      */\n-    public OptionGroup addOption(Option opt) {\n+    public OptionGroup addOption(Option opt)\n+    {\n         // key   - option name\n         // value - the option\n-        optionMap.put( opt.getKey(), opt );\n+        optionMap.put(opt.getKey(), opt);\n+\n         return this;\n     }\n \n      * @return the names of the options in this group as a \n      * <code>Collection</code>\n      */\n-    public Collection getNames() {\n+    public Collection getNames()\n+    {\n         // the key set is the collection of names\n         return optionMap.keySet();\n     }\n     /**\n      * @return the options in this group as a <code>Collection</code>\n      */\n-    public Collection getOptions() {\n+    public Collection getOptions()\n+    {\n         // the values are the collection of options\n         return optionMap.values();\n     }\n      * @throws AlreadySelectedException if an option from this group has \n      * already been selected.\n      */\n-    public void setSelected(Option opt) throws AlreadySelectedException {\n+    public void setSelected(Option opt)\n+                     throws AlreadySelectedException\n+    {\n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-\n-        if ( this.selected == null || this.selected.equals( opt.getOpt() ) ) {\n+        if ((this.selected == null) || this.selected.equals(opt.getOpt()))\n+        {\n             this.selected = opt.getOpt();\n         }\n-        else {\n-            throw new AlreadySelectedException( \"an option from this group has \" + \n-                                                \"already been selected: '\" + \n-                                                selected + \"'\");\n+        else\n+        {\n+            throw new AlreadySelectedException(\"an option from this group has \"\n+                                               + \"already been selected: '\"\n+                                               + selected + \"'\");\n         }\n     }\n \n     /**\n      * @return the selected option name\n      */\n-    public String getSelected() {\n+    public String getSelected()\n+    {\n         return selected;\n     }\n \n     /**\n      * @param required specifies if this group is required\n      */\n-    public void setRequired( boolean required ) {\n+    public void setRequired(boolean required)\n+    {\n         this.required = required;\n     }\n \n     /**\n      * Returns whether this option group is required.\n      *\n-     * @returns whether this option group is required\n-     */\n-    public boolean isRequired() {\n+     * @return whether this option group is required\n+     */\n+    public boolean isRequired()\n+    {\n         return this.required;\n     }\n \n      * <p>Returns the stringified version of this OptionGroup.</p>\n      * @return the stringified representation of this group\n      */\n-    public String toString() {\n+    public String toString()\n+    {\n         StringBuffer buff = new StringBuffer();\n \n         Iterator iter = getOptions().iterator();\n \n-        buff.append( \"[\" );\n-        while( iter.hasNext() ) {\n-            Option option = (Option)iter.next();\n-\n-            if( option.getOpt() != null ) {\n-                buff.append( \"-\" );\n-                buff.append( option.getOpt() );\n+        buff.append(\"[\");\n+\n+        while (iter.hasNext())\n+        {\n+            Option option = (Option) iter.next();\n+\n+            if (option.getOpt() != null)\n+            {\n+                buff.append(\"-\");\n+                buff.append(option.getOpt());\n             }\n-            else {\n-                buff.append( \"--\" );\n-                buff.append( option.getLongOpt() );\n+            else\n+            {\n+                buff.append(\"--\");\n+                buff.append(option.getLongOpt());\n             }\n-            buff.append( \" \" );\n-            buff.append( option.getDescription( ) );\n-\n-            if( iter.hasNext() ) {\n-                buff.append( \", \" );\n+\n+            buff.append(\" \");\n+            buff.append(option.getDescription());\n+\n+            if (iter.hasNext())\n+            {\n+                buff.append(\", \");\n             }\n         }\n-        buff.append( \"]\" );\n+\n+        buff.append(\"]\");\n \n         return buff.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/OptionValidator.java\n+++ b/src/java/org/apache/commons/cli/OptionValidator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/OptionValidator.java,v 1.1 2002/11/18 08:41:26 jkeyes Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/18 08:41:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/OptionValidator.java,v 1.2 2002/12/09 23:47:25 jkeyes Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/12/09 23:47:25 $\n  *\n  * ====================================================================\n  *\n      * @param opt The option string to validate\n      * @throws IllegalArgumentException if the Option is not valid.\n      */\n-    static void validateOption( String opt ) \n-    throws IllegalArgumentException\n+    static void validateOption(String opt)\n+                        throws IllegalArgumentException\n     {\n         // check that opt is not NULL\n-        if( opt == null ) {\n+        if (opt == null)\n+        {\n             return;\n         }\n+\n         // handle the single character opt\n-        else if( opt.length() == 1 ) {\n-            char ch = opt.charAt( 0 );\n-            if ( !isValidOpt( ch ) ) {\n-                throw new IllegalArgumentException( \"illegal option value '\" \n-                                                    + ch + \"'\" );\n+        else if (opt.length() == 1)\n+        {\n+            char ch = opt.charAt(0);\n+\n+            if (!isValidOpt(ch))\n+            {\n+                throw new IllegalArgumentException(\"illegal option value '\" + ch\n+                                                   + \"'\");\n             }\n         }\n+\n         // handle the multi character opt\n-        else {\n+        else\n+        {\n             char[] chars = opt.toCharArray();\n-            for( int i = 0; i < chars.length; i++ ) {\n-                if( !isValidChar( chars[i] ) ) {\n-                    throw new IllegalArgumentException( \"opt contains illegal character value '\" + chars[i] + \"'\" );\n+\n+            for (int i = 0; i < chars.length; i++)\n+            {\n+                if (!isValidChar(chars[i]))\n+                {\n+                    throw new IllegalArgumentException(\n+                            \"opt contains illegal character value '\" + chars[i]\n+                            + \"'\");\n                 }\n             }\n         }\n      * <p>Returns whether the specified character is a valid Option.</p>\n      *\n      * @param c the option to validate\n-     * @return true if <code>c</code> is a letter, ' ', '?' or '@', otherwise false.\n+     * @return true if <code>c</code> is a letter, ' ', '?' or '@', \n+     * otherwise false.\n      */\n-    private static boolean isValidOpt( char c ) {\n-        return ( isValidChar( c ) || c == ' ' || c == '?' || c == '@' );\n+    private static boolean isValidOpt(char c)\n+    {\n+        return (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n     }\n \n     /**\n      * @param c the character to validate\n      * @return true if <code>c</code> is a letter.\n      */\n-    private static boolean isValidChar( char c ) {\n-        return Character.isJavaIdentifierPart( c );\n+    private static boolean isValidChar(char c)\n+    {\n+        return Character.isJavaIdentifierPart(c);\n     }\n }\n--- a/src/java/org/apache/commons/cli/Options.java\n+++ b/src/java/org/apache/commons/cli/Options.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.*;\n \n /** <p>Main entry-point into the library.</p>\n  *\n public class Options {\n \n     /** a map of the options with the character key */\n-    private Map  shortOpts    = new HashMap();\n+    private Map shortOpts = new HashMap();\n \n     /** a map of the options with the long key */\n-    private Map  longOpts     = new HashMap();\n+    private Map longOpts = new HashMap();\n \n     /** a map of the required options */\n     private List requiredOpts = new ArrayList();\n-    \n+\n     /** a map of the option groups */\n-    private Map optionGroups  = new HashMap();\n+    private Map optionGroups = new HashMap();\n \n     /** <p>Construct a new Options descriptor</p>\n      */\n-    public Options() {        \n+    public Options()\n+    {\n     }\n \n     /**\n      * @param group the OptionGroup that is to be added\n      * @return the resulting Options instance\n      */\n-    public Options addOptionGroup( OptionGroup group ) {\n+    public Options addOptionGroup(OptionGroup group)\n+    {\n         Iterator options = group.getOptions().iterator();\n \n-        if( group.isRequired() ) {\n-            requiredOpts.add( group );\n-        }\n-\n-        while( options.hasNext() ) {\n-            Option option = (Option)options.next();\n+        if (group.isRequired())\n+        {\n+            requiredOpts.add(group);\n+        }\n+\n+        while (options.hasNext())\n+        {\n+            Option option = (Option) options.next();\n+\n+\n             // an Option cannot be required if it is in an\n             // OptionGroup, either the group is required or\n             // nothing is required\n-            option.setRequired( false );\n-            addOption( option );\n-\n-            optionGroups.put( option.getKey(), group );\n+            option.setRequired(false);\n+            addOption(option);\n+\n+            optionGroups.put(option.getKey(), group);\n         }\n \n         return this;\n      * @param description Self-documenting description\n      * @return the resulting Options instance\n      */\n-    public Options addOption(String opt, boolean hasArg, String description) {\n-        addOption( opt, null, hasArg, description );\n+    public Options addOption(String opt, boolean hasArg, String description)\n+    {\n+        addOption(opt, null, hasArg, description);\n+\n         return this;\n     }\n-    \n+\n     /** <p>Add an option that contains a short-name and a long-name</p>\n      * <p>It may be specified as requiring an argument.</p>\n      *\n      * @param description Self-documenting description\n      * @return the resulting Options instance\n      */\n-    public Options addOption(String opt, String longOpt, boolean hasArg, String description) {\n-        addOption( new Option( opt, longOpt, hasArg, description ) );        \n+    public Options addOption(String opt, String longOpt, boolean hasArg, \n+                             String description)\n+    {\n+        addOption(new Option(opt, longOpt, hasArg, description));\n+\n         return this;\n     }\n \n      * @param opt the option that is to be added \n      * @return the resulting Options instance\n      */\n-    public Options addOption(Option opt)  {\n+    public Options addOption(Option opt)\n+    {\n         String key = opt.getKey();\n-        \n-            // add it to the long option list\n-            if ( opt.hasLongOpt() ) {\n-                longOpts.put( opt.getLongOpt(), opt );\n-            }\n-        \n-            // if the option is required add it to the required list\n-            if ( opt.isRequired() && !requiredOpts.contains( key ) ) {\n-                requiredOpts.add( key );\n-            }\n-            shortOpts.put( key, opt );\n+\n+        // add it to the long option list\n+        if (opt.hasLongOpt())\n+        {\n+            longOpts.put(opt.getLongOpt(), opt);\n+        }\n+\n+        // if the option is required add it to the required list\n+        if (opt.isRequired() && !requiredOpts.contains(key))\n+        {\n+            requiredOpts.add(key);\n+        }\n+\n+        shortOpts.put(key, opt);\n \n         return this;\n     }\n-    \n+\n     /** <p>Retrieve a read-only list of options in this set</p>\n      *\n      * @return read-only Collection of {@link Option} objects in this descriptor\n      */\n-    public Collection getOptions() {\n-        return Collections.unmodifiableCollection( helpOptions() );\n+    public Collection getOptions()\n+    {\n+        return Collections.unmodifiableCollection(helpOptions());\n     }\n \n     /**\n      *\n      * @return the List of Options\n      */\n-    List helpOptions() {\n-        List opts = new ArrayList( shortOpts.values() );\n+    List helpOptions()\n+    {\n+        List opts = new ArrayList(shortOpts.values());\n \n         // now look through the long opts to see if there are any Long-opt\n         // only options\n         Iterator iter = longOpts.values().iterator();\n+\n         while (iter.hasNext())\n         {\n             Object item = iter.next();\n+\n             if (!opts.contains(item))\n             {\n                 opts.add(item);\n             }\n         }\n-        return new ArrayList( opts );\n+\n+        return new ArrayList(opts);\n     }\n \n     /** <p>Returns the required options as a \n      *\n      * @return Collection of required options\n      */\n-    public List getRequiredOptions() {\n+    public List getRequiredOptions()\n+    {\n         return requiredOpts;\n     }\n-    \n+\n     /** <p>Retrieve the named {@link Option}</p>\n      *\n      * @param opt short or long name of the {@link Option}\n      * @return the option represented by opt\n      */\n-    public Option getOption( String opt ) {\n-\n-        opt = Util.stripLeadingHyphens( opt );\n-\n-        if( shortOpts.containsKey( opt ) ) {\n-            return (Option) shortOpts.get( opt );\n-        }\n-        return (Option) longOpts.get( opt );\n+    public Option getOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        if (shortOpts.containsKey(opt))\n+        {\n+            return (Option) shortOpts.get(opt);\n+        }\n+\n+        return (Option) longOpts.get(opt);\n     }\n \n     /** \n      * @return true if the named {@link Option} is a member\n      * of this {@link Options}\n      */\n-    public boolean hasOption( String opt ) {\n-        opt = Util.stripLeadingHyphens( opt );\n-        return shortOpts.containsKey( opt ) || longOpts.containsKey( opt );\n+    public boolean hasOption(String opt)\n+    {\n+        opt = Util.stripLeadingHyphens(opt);\n+\n+        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n     }\n \n     /** <p>Returns the OptionGroup the <code>opt</code>\n      * @return the OptionGroup if <code>opt</code> is part\n      * of an OptionGroup, otherwise return null\n      */\n-    public OptionGroup getOptionGroup( Option opt ) {\n-        return (OptionGroup)optionGroups.get( opt.getKey() );\n-    }\n-    \n+    public OptionGroup getOptionGroup(Option opt)\n+    {\n+        return (OptionGroup) optionGroups.get(opt.getKey());\n+    }\n+\n     /** <p>Dump state, suitable for debugging.</p>\n      *\n      * @return Stringified form of this object\n      */\n-    public String toString() {\n+    public String toString()\n+    {\n         StringBuffer buf = new StringBuffer();\n-        \n+\n         buf.append(\"[ Options: [ short \");\n-        buf.append( shortOpts.toString() );\n-        buf.append( \" ] [ long \" );\n-        buf.append( longOpts );\n-        buf.append( \" ]\");\n-        \n+        buf.append(shortOpts.toString());\n+        buf.append(\" ] [ long \");\n+        buf.append(longOpts);\n+        buf.append(\" ]\");\n+\n         return buf.toString();\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/ParseException.java\n+++ b/src/java/org/apache/commons/cli/ParseException.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n /** \n  * @author bob mcwhirter (bob @ werken.com)\n  * @version $Revision: 1.2 $\n  */\n-public class ParseException extends Exception \n-{\n-    \n+public class ParseException extends Exception {\n+\n     /** \n      * <p>Construct a new <code>ParseException</code> \n      * with the specified detail message.</p>\n      *\n      * @param message the detail message\n      */\n-    public ParseException( String message ) {\n-        super( message );\n+    public ParseException(String message)\n+    {\n+        super(message);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Parser.java,v 1.10 2002/11/27 23:22:02 jkeyes Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/11/27 23:22:02 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Parser.java,v 1.11 2002/12/09 23:47:25 jkeyes Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/12/09 23:47:25 $\n  *\n  * ====================================================================\n  *\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n-import java.util.Map;\n import java.util.Properties;\n \n /**\n  *\n  * @author John Keyes (john at integralsource.com)\n  * @see Parser\n- * @version $Revision: 1.10 $\n+ * @version $Revision: 1.11 $\n  */\n public abstract class Parser implements CommandLineParser {\n \n     /** commandline instance */\n     private CommandLine cmd;\n+\n     /** current Options */\n     private Options options;\n+\n     /** list of required options strings */\n     private List requiredOptions;\n \n      * method.</p>\n      *\n      * @param opts The Options to parse the arguments by.\n-     * @param args The arguments that have to be flattened.\n+     * @param arguments The arguments that have to be flattened.\n      * @param stopAtNonOption specifies whether to stop \n      * flattening when a non option has been encountered\n      * @return a String array of the flattened arguments\n      */\n-    abstract protected String[] flatten( Options opts, \n-                                         String[] arguments, \n-                                         boolean stopAtNonOption );\n+    protected abstract String[] flatten(Options opts, String[] arguments, \n+                                        boolean stopAtNonOption);\n \n     /**\n      * <p>Parses the specified <code>arguments</code> \n      * @throws ParseException if an error occurs when parsing the\n      * arguments.\n      */\n-    public CommandLine parse( Options options, \n-                              String[] arguments ) \n-    throws ParseException \n-    {\n-        return parse( options, arguments, null, false );\n+    public CommandLine parse(Options options, String[] arguments)\n+                      throws ParseException\n+    {\n+        return parse(options, arguments, null, false);\n     }\n \n     /**\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    public CommandLine parse( Options options, \n-                              String[] arguments,\n-                              Properties properties ) \n-    throws ParseException \n-    {\n-        return parse( options, arguments, properties, false );\n+    public CommandLine parse(Options options, String[] arguments, \n+                             Properties properties)\n+        throws ParseException\n+    {\n+        return parse(options, arguments, properties, false);\n     }\n \n     /**\n      * @throws ParseException if an error occurs when parsing the\n      * arguments.\n      */\n-    public CommandLine parse( Options options, \n-                              String[] arguments,\n-                              boolean stopAtNonOption ) \n-    throws ParseException \n-    {\n-        return parse( options, arguments, null, stopAtNonOption );\n+    public CommandLine parse(Options options, String[] arguments, \n+                             boolean stopAtNonOption)\n+        throws ParseException\n+    {\n+        return parse(options, arguments, null, stopAtNonOption);\n     }\n \n     /**\n      * @param options the specified Options\n      * @param arguments the command line arguments\n      * @param properties command line option name-value pairs\n+     * @param stopAtNonOption stop parsing the arguments when the first\n+     * non option is encountered.\n+     *\n      * @return the list of atomic option and value tokens\n      *\n      * @throws ParseException if there are any problems encountered\n      * while parsing the command line tokens.\n      */\n-    public CommandLine parse( Options opts, \n-                              String[] arguments, \n-                              Properties properties,\n-                              boolean stopAtNonOption ) \n-    throws ParseException \n+    public CommandLine parse(Options options, String[] arguments, \n+                             Properties properties, boolean stopAtNonOption)\n+        throws ParseException\n     {\n         // initialise members\n-        options = opts;\n+        this.options = options;\n         requiredOptions = options.getRequiredOptions();\n         cmd = new CommandLine();\n \n         boolean eatTheRest = false;\n \n-        if( arguments == null ) {\n+        if (arguments == null)\n+        {\n             arguments = new String[0];\n         }\n \n-        List tokenList = Arrays.asList( flatten( opts, arguments, stopAtNonOption ) );\n+        List tokenList = Arrays.asList(flatten(this.options, \n+                                               arguments, \n+                                               stopAtNonOption));\n+\n         ListIterator iterator = tokenList.listIterator();\n \n         // process each flattened token\n-        while( iterator.hasNext() ) {\n-            String t = (String)iterator.next();\n+        while (iterator.hasNext())\n+        {\n+            String t = (String) iterator.next();\n \n             // the value is the double-dash\n-            if( \"--\".equals( t ) ) {\n+            if (\"--\".equals(t))\n+            {\n                 eatTheRest = true;\n             }\n+\n             // the value is a single dash\n-            else if( \"-\".equals( t ) ) {\n-                if( stopAtNonOption ) {\n+            else if (\"-\".equals(t))\n+            {\n+                if (stopAtNonOption)\n+                {\n                     eatTheRest = true;\n                 }\n-                else {\n-                    cmd.addArg(t );\n-                }\n-            }\n+                else\n+                {\n+                    cmd.addArg(t);\n+                }\n+            }\n+\n             // the value is an option\n-            else if( t.startsWith( \"-\" ) ) {\n-                if ( stopAtNonOption && !options.hasOption( t ) ) {\n+            else if (t.startsWith(\"-\"))\n+            {\n+                if (stopAtNonOption && !options.hasOption(t))\n+                {\n                     eatTheRest = true;\n-                    cmd.addArg( t );\n-                }\n-                else {\n-                    processOption( t, iterator );\n-                }\n-            }\n+                    cmd.addArg(t);\n+                }\n+                else\n+                {\n+                    processOption(t, iterator);\n+                }\n+            }\n+\n             // the value is an argument\n-            else {\n-                cmd.addArg( t );\n-                if( stopAtNonOption ) {\n+            else\n+            {\n+                cmd.addArg(t);\n+\n+                if (stopAtNonOption)\n+                {\n                     eatTheRest = true;\n                 }\n             }\n \n             // eat the remaining tokens\n-            if( eatTheRest ) {\n-                while( iterator.hasNext() ) {\n-                    String str = (String)iterator.next();\n+            if (eatTheRest)\n+            {\n+                while (iterator.hasNext())\n+                {\n+                    String str = (String) iterator.next();\n+\n                     // ensure only one double-dash is added\n-                    if( !\"--\".equals( str ) ) {\n-                        cmd.addArg( str );\n+                    if (!\"--\".equals(str))\n+                    {\n+                        cmd.addArg(str);\n                     }\n                 }\n             }\n         }\n-        processProperties( properties );\n+\n+        processProperties(properties);\n         checkRequiredOptions();\n+\n         return cmd;\n     }\n \n     /**\n-     * <p>Sets the values of Options using the values in <code>properties</code>.</p>\n-     */\n-    private void processProperties( Properties properties ) {\n-        if( properties == null ) {\n+     * <p>Sets the values of Options using the values in \n+     * <code>properties</code>.</p>\n+     *\n+     * @param properties The value properties to be processed.\n+     */\n+    private void processProperties(Properties properties)\n+    {\n+        if (properties == null)\n+        {\n             return;\n         }\n \n-        for( Enumeration e = properties.propertyNames(); e.hasMoreElements(); ) {\n+        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n+        {\n             String option = e.nextElement().toString();\n-            if( !cmd.hasOption( option ) ) {\n-                Option opt = options.getOption( option );\n+\n+            if (!cmd.hasOption(option))\n+            {\n+                Option opt = options.getOption(option);\n \n                 // get the value from the properties instance\n-                String value = properties.getProperty( option );\n-\n-                if( opt.hasArgs() ) {\n-                    if( opt.getValues() == null || opt.getValues().length == 0 ) {\n-                        try {\n-                            opt.addValue( value );\n+                String value = properties.getProperty(option);\n+\n+                if (opt.hasArgs())\n+                {\n+                    if ((opt.getValues() == null)\n+                        || (opt.getValues().length == 0))\n+                    {\n+                        try\n+                        {\n+                            opt.addValue(value);\n                         }\n-                        catch( RuntimeException exp ) {\n+                        catch (RuntimeException exp)\n+                        {\n                             // if we cannot add the value don't worry about it\n                         }\n                     }\n                 }\n-                else if ( ! ( \"yes\".equalsIgnoreCase( value ) ||\n-                              \"true\".equalsIgnoreCase( value ) ||\n-                              \"1\".equalsIgnoreCase( value) ) ) {\n+                else if (!(\"yes\".equalsIgnoreCase(value) \n+                           || \"true\".equalsIgnoreCase(value)\n+                           || \"1\".equalsIgnoreCase(value)))\n+                {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n                     break;\n                 }\n \n-                cmd.addOption( opt );\n+                cmd.addOption(opt);\n             }\n         }\n     }\n     /**\n      * <p>Throws a {@link MissingOptionException} if all of the\n      * required options are no present.</p>\n+     *\n+     * @throws MissingOptionException if any of the required Options\n+     * are not present.\n      */\n     private void checkRequiredOptions()\n-    throws MissingOptionException \n-    {\n-\n+        throws MissingOptionException\n+    {\n         // if there are required options that have not been\n         // processsed\n-        if( requiredOptions.size() > 0 ) {\n+        if (requiredOptions.size() > 0)\n+        {\n             Iterator iter = requiredOptions.iterator();\n             StringBuffer buff = new StringBuffer();\n \n             // loop through the required options\n-            while( iter.hasNext() ) {\n-                buff.append( iter.next() );\n-            }\n-\n-            throw new MissingOptionException( buff.toString() );\n-        }\n-    }\n-\n-    public void processArgs( Option opt, ListIterator iter ) \n-    throws ParseException\n+            while (iter.hasNext())\n+            {\n+                buff.append(iter.next());\n+            }\n+\n+            throw new MissingOptionException(buff.toString());\n+        }\n+    }\n+\n+    /**\n+     * <p>Process the argument values for the specified Option\n+     * <code>opt</code> using the values retrieved from the \n+     * specified iterator <code>iter</code>.\n+     *\n+     * @param opt The current Option\n+     * @param iter The iterator over the flattened command line\n+     * Options.\n+     *\n+     * @throws ParseException if an argument value is required\n+     * and it is has not been found.\n+     */\n+    public void processArgs(Option opt, ListIterator iter)\n+        throws ParseException\n     {\n         // loop until an option is found\n-        while( iter.hasNext() ) {\n-            String str = (String)iter.next();\n+        while (iter.hasNext())\n+        {\n+            String str = (String) iter.next();\n \n             // found an Option\n-            if( options.hasOption( str ) ) {\n+            if (options.hasOption(str))\n+            {\n                 iter.previous();\n+\n                 break;\n             }\n+\n             // found a value\n-            else {\n-                try {\n-                    opt.addValue( str ) ;\n-                }\n-                catch( RuntimeException exp ) {\n+            else\n+            {\n+                try\n+                {\n+                    opt.addValue(str);\n+                }\n+                catch (RuntimeException exp)\n+                {\n                     iter.previous();\n+\n                     break;\n                 }\n             }\n         }\n \n-        if( opt.getValues() == null && !opt.hasOptionalArg() ) {\n-            throw new MissingArgumentException( \"no argument for:\" + opt.getKey() );\n-        }\n-    }\n-\n-    private void processOption( String arg, ListIterator iter ) \n-    throws ParseException\n+        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n+        {\n+            throw new MissingArgumentException(\"no argument for:\"\n+                                               + opt.getKey());\n+        }\n+    }\n+\n+    /**\n+     * <p>Process the Option specified by <code>arg</code>\n+     * using the values retrieved from the specfied iterator\n+     * <code>iter</code>.\n+     *\n+     * @param arg The String value representing an Option\n+     * @param iter The iterator over the flattened command \n+     * line arguments.\n+     *\n+     * @throws ParseException if <code>arg</code> does not\n+     * represent an Option\n+     */\n+    private void processOption(String arg, ListIterator iter)\n+        throws ParseException\n     {\n         // get the option represented by arg\n         Option opt = null;\n \n-        boolean hasOption = options.hasOption( arg );\n+        boolean hasOption = options.hasOption(arg);\n \n         // if there is no option throw an UnrecognisedOptionException\n-        if( !hasOption ) {\n-            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg);\n-        }\n-        else {\n-            opt = (Option) options.getOption( arg );\n+        if (!hasOption)\n+        {\n+            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n+                                                  + arg);\n+        }\n+        else\n+        {\n+            opt = (Option) options.getOption(arg);\n         }\n \n         // if the option is a required option remove the option from\n         // the requiredOptions list\n-        if ( opt.isRequired() ) {\n-            requiredOptions.remove( opt.getKey() );\n+        if (opt.isRequired())\n+        {\n+            requiredOptions.remove(opt.getKey());\n         }\n \n         // if the option is in an OptionGroup make that option the selected\n         // option of the group\n-        if ( options.getOptionGroup( opt ) != null ) {\n-            OptionGroup group = ( OptionGroup ) options.getOptionGroup( opt );\n-            if( group.isRequired() ) {\n-                requiredOptions.remove( group );\n-            }\n-            group.setSelected( opt );\n+        if (options.getOptionGroup(opt) != null)\n+        {\n+            OptionGroup group = (OptionGroup) options.getOptionGroup(opt);\n+\n+            if (group.isRequired())\n+            {\n+                requiredOptions.remove(group);\n+            }\n+\n+            group.setSelected(opt);\n         }\n \n         // if the option takes an argument value\n-        if ( opt.hasArg() ) {\n-            processArgs( opt, iter );\n-        }\n+        if (opt.hasArg())\n+        {\n+            processArgs(opt, iter);\n+        }\n+\n \n         // set the option on the command line\n-        cmd.addOption( opt );\n+        cmd.addOption(opt);\n     }\n }\n--- a/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n+++ b/src/java/org/apache/commons/cli/PatternOptionBuilder.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n /** \n  * Allows Options to be created from a single String.\n  *\n+ * @todo These need to break out to OptionType and also \n+ * to be pluggable.\n  *\n  * @author Henri Yandell (bayard @ generationjava.com)\n  * @version $Revision: 1.2 $\n  */\n public class PatternOptionBuilder {\n \n-    /// TODO: These need to break out to OptionType and also to be pluggable.\n-\n     /** String class */\n-    public static final Class STRING_VALUE        = java.lang.String.class;\n+    public static final Class STRING_VALUE = java.lang.String.class;\n+\n     /** Object class */\n-    public static final Class OBJECT_VALUE        = java.lang.Object.class;\n+    public static final Class OBJECT_VALUE = java.lang.Object.class;\n+\n     /** Number class */\n-    public static final Class NUMBER_VALUE        = java.lang.Number.class;\n+    public static final Class NUMBER_VALUE = java.lang.Number.class;\n+\n     /** Date class */\n-    public static final Class DATE_VALUE          = java.util.Date.class;\n+    public static final Class DATE_VALUE = java.util.Date.class;\n+\n     /** Class class */\n-    public static final Class CLASS_VALUE         = java.lang.Class.class;\n-\n-/// can we do this one?? \n-// is meant to check that the file exists, else it errors.\n-// ie) it's for reading not writing.\n+    public static final Class CLASS_VALUE = java.lang.Class.class;\n+\n+    /// can we do this one?? \n+    // is meant to check that the file exists, else it errors.\n+    // ie) it's for reading not writing.\n+\n     /** FileInputStream class */\n-    public static final Class EXISTING_FILE_VALUE = java.io.FileInputStream.class;\n+    public static final Class EXISTING_FILE_VALUE = \n+            java.io.FileInputStream.class;\n+\n     /** File class */\n-    public static final Class FILE_VALUE          = java.io.File.class;\n+    public static final Class FILE_VALUE = java.io.File.class;\n+\n     /** File array class */\n-    public static final Class FILES_VALUE         = java.io.File[].class;\n+    public static final Class FILES_VALUE = java.io.File[].class;\n+\n     /** URL class */\n-    public static final Class URL_VALUE           = java.net.URL.class;\n+    public static final Class URL_VALUE = java.net.URL.class;\n \n     /**\n      * <p>Retrieve the class that <code>ch</code> represents.</p>\n      * @param ch the specified character\n      * @return The class that <code>ch</code> represents\n      */\n-    public static Object getValueClass(char ch) {\n-        if (ch == '@') {\n+    public static Object getValueClass(char ch)\n+    {\n+        if (ch == '@')\n+        {\n             return PatternOptionBuilder.OBJECT_VALUE;\n-        } else if (ch == ':') {\n+        }\n+        else if (ch == ':')\n+        {\n             return PatternOptionBuilder.STRING_VALUE;\n-        } else if (ch == '%') {\n+        }\n+        else if (ch == '%')\n+        {\n             return PatternOptionBuilder.NUMBER_VALUE;\n-        } else if (ch == '+') {\n+        }\n+        else if (ch == '+')\n+        {\n             return PatternOptionBuilder.CLASS_VALUE;\n-        } else if (ch == '#') {\n+        }\n+        else if (ch == '#')\n+        {\n             return PatternOptionBuilder.DATE_VALUE;\n-        } else if (ch == '<') {\n+        }\n+        else if (ch == '<')\n+        {\n             return PatternOptionBuilder.EXISTING_FILE_VALUE;\n-        } else if (ch == '>') {\n+        }\n+        else if (ch == '>')\n+        {\n             return PatternOptionBuilder.FILE_VALUE;\n-        } else if (ch == '*') {\n+        }\n+        else if (ch == '*')\n+        {\n             return PatternOptionBuilder.FILES_VALUE;\n-        } else if (ch == '/') {\n+        }\n+        else if (ch == '/')\n+        {\n             return PatternOptionBuilder.URL_VALUE;\n         }\n+\n         return null;\n     }\n- \n+\n     /**\n      * <p>Returns whether <code>ch</code> is a value code, i.e.\n      * whether it represents a class in a pattern.</p>\n      * @param ch the specified character\n      * @return true if <code>ch</code> is a value code, otherwise false.\n      */\n-    public static boolean isValueCode(char ch) {\n-        if( (ch != '@') &&\n-            (ch != ':') &&\n-            (ch != '%') &&\n-            (ch != '+') &&\n-            (ch != '#') &&\n-            (ch != '<') &&\n-            (ch != '>') &&\n-            (ch != '*') &&\n-            (ch != '/')\n-          )\n+    public static boolean isValueCode(char ch)\n+    {\n+        if ((ch != '@') && (ch != ':') && (ch != '%') && (ch != '+')\n+            && (ch != '#') && (ch != '<') && (ch != '>') && (ch != '*')\n+            && (ch != '/'))\n         {\n             return false;\n         }\n+\n         return true;\n-    }       \n- \n+    }\n+\n     /**\n      * <p>Returns the {@link Options} instance represented by \n      * <code>pattern</code>.</p>\n      * @param pattern the pattern string\n      * @return The {@link Options} instance\n      */\n-    public static Options parsePattern(String pattern) {\n+    public static Options parsePattern(String pattern)\n+    {\n         int sz = pattern.length();\n \n         char opt = ' ';\n         Object type = null;\n \n         Options options = new Options();\n-        \n-        for(int i=0; i<sz; i++) {\n+\n+        for (int i = 0; i < sz; i++)\n+        {\n             ch = pattern.charAt(i);\n \n             // a value code comes after an option and specifies \n             // details about it\n-            if(!isValueCode(ch)) {\n-                if(opt != ' ') {\n+            if (!isValueCode(ch))\n+            {\n+                if (opt != ' ')\n+                {\n                     // we have a previous one to deal with\n-                    options.addOption( OptionBuilder.hasArg( type != null )\n-                                                    .isRequired( required )\n-                                                    .withType( type )\n-                                                    .create( opt ) );\n+                    options.addOption(\n+                            OptionBuilder.hasArg(type != null)\n+                                         .isRequired(required).withType(type)\n+                                         .create(opt));\n                     required = false;\n                     type = null;\n                     opt = ' ';\n                 }\n+\n                 opt = ch;\n-            } else\n-            if(ch == '!') {\n+            }\n+            else if (ch == '!')\n+            {\n                 required = true;\n-            } else {\n+            }\n+            else\n+            {\n                 type = getValueClass(ch);\n             }\n         }\n \n-        if(opt != ' ') {\n+        if (opt != ' ')\n+        {\n             // we have a final one to deal with\n-            options.addOption( OptionBuilder.hasArg( type != null )\n-                                            .isRequired( required )\n-                                            .withType( type )\n-                                            .create( opt ) );\n+            options.addOption(\n+                    OptionBuilder.hasArg(type != null).isRequired(required)\n+                                 .withType(type).create(opt));\n         }\n \n         return options;\n     }\n-\n-}\n+}\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.11 2002/09/19 22:59:43 jkeyes Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/09/19 22:59:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/PosixParser.java,v 1.12 2002/12/09 23:47:25 jkeyes Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2002/12/09 23:47:25 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.cli;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Iterator;\n-import java.util.Map;\n \n /**\n  * The class PosixParser provides an implementation of the \n  *\n  * @author John Keyes (john at integralsource.com)\n  * @see Parser\n- * @version $Revision: 1.11 $\n+ * @version $Revision: 1.12 $\n  */\n public class PosixParser extends Parser {\n \n     /** holder for flattened tokens */\n     private ArrayList tokens = new ArrayList();\n+\n     /** specifies if bursting should continue */\n     private boolean eatTheRest;\n+\n     /** holder for the current option */\n     private Option currentOption;\n+\n     /** the command line Options */\n     private Options options;\n \n      * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n      * to false and set <code>currentOption</code> to null.</p>\n      */\n-    private void init() {\n+    private void init()\n+    {\n         eatTheRest = false;\n         tokens.clear();\n         currentOption = null;\n      *  characters in length and the first character is \"<b>-</b>\" then\n      *  we need to burst the entry to determine its constituents.  For more\n      *  information on the bursting algorithm see \n-     *  {@link PosixParser#burstToken( String, boolean) burstToken}.</li>\n+     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n      *  <li>if the current <code>arguments</code> entry is not handled \n      *  by any of the previous rules, then the entry is added to the list\n      *  of processed tokens.</li>\n      * when an non option is found.\n      * @return The flattened <code>arguments</code> String array.\n      */\n-    protected String[] flatten( Options options, \n-                                String[] arguments, \n-                                boolean stopAtNonOption )\n+    protected String[] flatten(Options options, String[] arguments, \n+                               boolean stopAtNonOption)\n     {\n         init();\n         this.options = options;\n \n         // an iterator for the command line tokens\n-        Iterator iter = Arrays.asList( arguments ).iterator();\n+        Iterator iter = Arrays.asList(arguments).iterator();\n         String token = null;\n-        \n+\n         // process each command line token\n-        while ( iter.hasNext() ) {\n-\n+        while (iter.hasNext())\n+        {\n             // get the next command line token\n             token = (String) iter.next();\n \n             // handle SPECIAL TOKEN\n-            if( token.startsWith( \"--\" ) ) {\n-                if( token.indexOf( '=' ) != -1 ) {\n-                    tokens.add( token.substring( 0, token.indexOf( '=' ) ) );\n-                    tokens.add( token.substring( token.indexOf( '=' ) + 1,\n-                                                 token.length() ) );\n-                }\n-                else {\n-                    tokens.add( token );\n-                }\t\n-            }\n+            if (token.startsWith(\"--\"))\n+            {\n+                if (token.indexOf('=') != -1)\n+                {\n+                    tokens.add(token.substring(0, token.indexOf('=')));\n+                    tokens.add(token.substring(token.indexOf('=') + 1, \n+                                               token.length()));\n+                }\n+                else\n+                {\n+                    tokens.add(token);\n+                }\n+            }\n+\n             // single hyphen\n-            else if( \"-\".equals( token ) ) {\n-                processSingleHyphen( token );\n-            }\n-            else if( token.startsWith( \"-\" ) ) {\n+            else if (\"-\".equals(token))\n+            {\n+                processSingleHyphen(token);\n+            }\n+            else if (token.startsWith(\"-\"))\n+            {\n                 int tokenLength = token.length();\n-                if( tokenLength == 2 ) {\n-                    processOptionToken( token, stopAtNonOption );\n-                }\n+\n+                if (tokenLength == 2)\n+                {\n+                    processOptionToken(token, stopAtNonOption);\n+                }\n+\n                 // requires bursting\n-                else {\n-                    burstToken( token, stopAtNonOption );\n-                }\n-            }\n-            else {\n-                if( stopAtNonOption ) {\n-                    process( token );\n-                }\n-                else {\n-                    tokens.add( token );\n-                }\n-            }\n-\n-            gobble( iter );\n-        }\n-\n-        return (String[])tokens.toArray( new String[] {} );\n+                else\n+                {\n+                    burstToken(token, stopAtNonOption);\n+                }\n+            }\n+            else\n+            {\n+                if (stopAtNonOption)\n+                {\n+                    process(token);\n+                }\n+                else\n+                {\n+                    tokens.add(token);\n+                }\n+            }\n+\n+            gobble(iter);\n+        }\n+\n+        return (String[]) tokens.toArray(new String[] {  });\n     }\n \n     /**\n      *\n      * @param iter An iterator over the remaining tokens\n      */\n-    private void gobble( Iterator iter ) {\n-        if( eatTheRest ) {\n-            while( iter.hasNext() ) {\n-                tokens.add( iter.next() );\n+    private void gobble(Iterator iter)\n+    {\n+        if (eatTheRest)\n+        {\n+            while (iter.hasNext())\n+            {\n+                tokens.add(iter.next());\n             }\n         }\n     }\n      *\n      * @param value The current token\n      */\n-    private void process( String value ) {\n-        if( currentOption != null && currentOption.hasArg() ) {\n-            if( currentOption.hasArg() ) {\n-                tokens.add( value );\n+    private void process(String value)\n+    {\n+        if ((currentOption != null) && currentOption.hasArg())\n+        {\n+            if (currentOption.hasArg())\n+            {\n+                tokens.add(value);\n                 currentOption = null;\n             }\n-            else if (currentOption.hasArgs() ) {\n-                tokens.add( value );\n-            }\n-        }\n-        else {\n+            else if (currentOption.hasArgs())\n+            {\n+                tokens.add(value);\n+            }\n+        }\n+        else\n+        {\n             eatTheRest = true;\n-            tokens.add( \"--\" );\n-            tokens.add( value );\n+            tokens.add(\"--\");\n+            tokens.add(value);\n         }\n     }\n \n      *\n      * @param hyphen The hyphen token\n      */\n-    private void processSingleHyphen( String hyphen ) {\n-        tokens.add( hyphen );\n+    private void processSingleHyphen(String hyphen)\n+    {\n+        tokens.add(hyphen);\n     }\n \n     /**\n      * @param stopAtNonOption Specifies whether flattening should halt\n      * at the first non option.\n      */\n-    private void processOptionToken( String token, boolean stopAtNonOption ) {\n-        if( this.options.hasOption( token ) ) {\n-            currentOption = this.options.getOption( token );\n-            tokens.add( token );\n-        }\n-        else if( stopAtNonOption ) {\n+    private void processOptionToken(String token, boolean stopAtNonOption)\n+    {\n+        if (this.options.hasOption(token))\n+        {\n+            currentOption = this.options.getOption(token);\n+            tokens.add(token);\n+        }\n+        else if (stopAtNonOption)\n+        {\n             eatTheRest = true;\n         }\n     }\n      * <p>Breaks <code>token</code> into its constituent parts\n      * using the following algorithm.\n      * <ul>\n-     *  <li>ignore the first character (\"<b>-</b>\" )</li>\n+     *  <li>ignore the first character (\"<b>-</b>\")</li>\n      *  <li>foreach remaining character check if an {@link Option}\n      *  exists with that id.</li>\n      *  <li>if an {@link Option} does exist then add that character\n      *  character prepended with \"<b>-</b>\".</li>\n      * </ul>\n      * </p>\n-     */\n-    protected void burstToken( String token, boolean stopAtNonOption ) {\n+     *\n+     * @param token The current token to be <b>burst</b>\n+     * @param stopAtNonOption Specifies whether to stop processing\n+     * at the first non-Option encountered.\n+     */\n+    protected void burstToken(String token, boolean stopAtNonOption)\n+    {\n         int tokenLength = token.length();\n \n-        for( int i = 1; i < tokenLength; i++) {\n-            String ch = String.valueOf( token.charAt( i ) );\n-            boolean hasOption = options.hasOption( ch );\n-\n-            if( hasOption ) {\n-                tokens.add( \"-\" + ch );\n-                currentOption = options.getOption( ch );\n-                if( currentOption.hasArg() && token.length()!=i+1 ) {\n-                    tokens.add( token.substring( i+1 ) );\n+        for (int i = 1; i < tokenLength; i++)\n+        {\n+            String ch = String.valueOf(token.charAt(i));\n+            boolean hasOption = options.hasOption(ch);\n+\n+            if (hasOption)\n+            {\n+                tokens.add(\"-\" + ch);\n+                currentOption = options.getOption(ch);\n+\n+                if (currentOption.hasArg() && (token.length() != (i + 1)))\n+                {\n+                    tokens.add(token.substring(i + 1));\n+\n                     break;\n                 }\n             }\n-            else if( stopAtNonOption ) {\n-                process( token.substring( i ) );\n-            }\n-            else {\n-                tokens.add( \"-\" + ch );\n+            else if (stopAtNonOption)\n+            {\n+                process(token.substring(i));\n+            }\n+            else\n+            {\n+                tokens.add(\"-\" + ch);\n             }\n         }\n     }\n--- a/src/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n import java.io.File;\n+\n+import java.net.MalformedURLException;\n import java.net.URL;\n-import java.net.MalformedURLException;\n+\n import java.util.Date;\n \n import org.apache.commons.lang.NumberUtils;\n   *\n   * @author Henri Yandell (bayard @ generationjava.com)\n   * @version $Revision: 1.2 $\n-  */    \n+  */\n public class TypeHandler {\n \n     /**\n      * @return The instance of <code>obj</code> initialised with\n      * the value of <code>str</code>.\n      */\n-    public static Object createValue(String str, Object obj) {\n-        return createValue(str, (Class)obj);\n+    public static Object createValue(String str, Object obj)\n+    {\n+        return createValue(str, (Class) obj);\n     }\n \n     /**\n      * @return The instance of <code>clazz</code> initialised with\n      * the value of <code>str</code>.\n      */\n-    public static Object createValue(String str, Class clazz) {\n-        if( PatternOptionBuilder.STRING_VALUE == clazz) {\n+    public static Object createValue(String str, Class clazz)\n+    {\n+        if (PatternOptionBuilder.STRING_VALUE == clazz)\n+        {\n             return str;\n-        } else\n-        if( PatternOptionBuilder.OBJECT_VALUE == clazz) {\n+        }\n+        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n+        {\n             return createObject(str);\n-        } else\n-        if( PatternOptionBuilder.NUMBER_VALUE == clazz) {\n+        }\n+        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n+        {\n             return createNumber(str);\n-        } else\n-        if( PatternOptionBuilder.DATE_VALUE   == clazz) {\n+        }\n+        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n+        {\n             return createDate(str);\n-        } else\n-        if( PatternOptionBuilder.CLASS_VALUE  == clazz) {\n+        }\n+        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n+        {\n             return createClass(str);\n-        } else\n-        if( PatternOptionBuilder.FILE_VALUE   == clazz) {\n+        }\n+        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n+        {\n             return createFile(str);\n-        } else\n-        if( PatternOptionBuilder.EXISTING_FILE_VALUE   == clazz) {\n+        }\n+        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n+        {\n             return createFile(str);\n-        } else\n-        if( PatternOptionBuilder.FILES_VALUE  == clazz) {\n+        }\n+        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n+        {\n             return createFiles(str);\n-        } else\n-        if( PatternOptionBuilder.URL_VALUE    == clazz) {\n+        }\n+        else if (PatternOptionBuilder.URL_VALUE == clazz)\n+        {\n             return createURL(str);\n-        } else {\n+        }\n+        else\n+        {\n             return null;\n         }\n     }\n       * <p>Create an Object from the classname and empty constructor.</p>\n       *\n       * @param str the argument value\n-      * @return the initialised object, or null if it couldn't create the Object.\n+      * @return the initialised object, or null if it couldn't create \n+      * the Object.\n       */\n-    public static Object createObject(String str) {\n+    public static Object createObject(String str)\n+    {\n         Class cl = null;\n-        try {\n+\n+        try\n+        {\n             cl = Class.forName(str);\n-        } catch (ClassNotFoundException cnfe) {\n-            System.err.println(\"Unable to find: \"+str);\n+        }\n+        catch (ClassNotFoundException cnfe)\n+        {\n+            System.err.println(\"Unable to find: \" + str);\n+\n             return null;\n         }\n \n         Object instance = null;\n \n-        try {\n+        try\n+        {\n             instance = cl.newInstance();\n-        } catch (InstantiationException cnfe) {\n-            System.err.println(\"InstantiationException; Unable to create: \"+str);\n-            return null;\n-        }\n-        catch (IllegalAccessException cnfe) {\n-            System.err.println(\"IllegalAccessException; Unable to create: \"+str);\n+        }\n+        catch (InstantiationException cnfe)\n+        {\n+            System.err.println(\"InstantiationException; Unable to create: \"\n+                               + str);\n+\n+            return null;\n+        }\n+        catch (IllegalAccessException cnfe)\n+        {\n+            System.err.println(\"IllegalAccessException; Unable to create: \"\n+                               + str);\n+\n             return null;\n         }\n \n      * @return the number represented by <code>str</code>, if <code>str</code>\n      * is not a number, null is returned.\n      */\n-    public static Number createNumber(String str) {\n+    public static Number createNumber(String str)\n+    {\n         // Needs to be able to create\n-        try {\n+        try\n+        {\n             // do searching for decimal point etc, but atm just make an Integer\n             return NumberUtils.createNumber(str);\n-        } catch (NumberFormatException nfe) {\n+        }\n+        catch (NumberFormatException nfe)\n+        {\n             System.err.println(nfe.getMessage());\n+\n             return null;\n         }\n     }\n      * @param str the class name\n      * @return The class if it is found, otherwise return null\n      */\n-    public static Class createClass(String str) {\n-        try {\n+    public static Class createClass(String str)\n+    {\n+        try\n+        {\n             return Class.forName(str);\n-        } catch (ClassNotFoundException cnfe) {\n-            System.err.println(\"Unable to find: \"+str);\n+        }\n+        catch (ClassNotFoundException cnfe)\n+        {\n+            System.err.println(\"Unable to find: \" + str);\n+\n             return null;\n         }\n     }\n      * @return The date if <code>str</code> is a valid date string,\n      * otherwise return null.\n      */\n-    public static Date createDate(String str) {\n+    public static Date createDate(String str)\n+    {\n         Date date = null;\n-        if(date == null) {\n-            System.err.println(\"Unable to parse: \"+str);\n-        }\n+\n+        if (date == null)\n+        {\n+            System.err.println(\"Unable to parse: \" + str);\n+        }\n+\n         return date;\n     }\n \n      * @return The URL is <code>str</code> is well-formed, otherwise\n      * return null.\n      */\n-    public static URL createURL(String str) {\n-        try {\n+    public static URL createURL(String str)\n+    {\n+        try\n+        {\n             return new URL(str);\n-        } catch (MalformedURLException mue) {\n-            System.err.println(\"Unable to parse: \"+str);\n+        }\n+        catch (MalformedURLException mue)\n+        {\n+            System.err.println(\"Unable to parse: \" + str);\n+\n             return null;\n         }\n     }\n      * @param str the File location\n      * @return The file represented by <code>str</code>.\n      */\n-    public static File createFile(String str) {\n+    public static File createFile(String str)\n+    {\n         return new File(str);\n     }\n \n      * @param str the paths to the files\n      * @return The File[] represented by <code>str</code>.\n      */\n-    public static File[] createFiles(String str) {\n-// to implement/port:\n-//        return FileW.findFiles(str);\n+    public static File[] createFiles(String str)\n+    {\n+        // to implement/port:\n+        //        return FileW.findFiles(str);\n         return null;\n     }\n-\n-}\n+}\n--- a/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n+++ b/src/java/org/apache/commons/cli/UnrecognizedOptionException.java\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.cli;\n \n /** \n  * @author bob mcwhiter (bob @ werken.com)\n  * @version $Revision: 1.2 $\n  */\n-public class UnrecognizedOptionException extends ParseException {\n-    \n+public class UnrecognizedOptionException\n+    extends ParseException {\n+\n     /** \n      * <p>Construct a new <code>UnrecognizedArgumentException</code> \n      * with the specified detail message.</p>\n      *\n      * @param message the detail message\n      */\n-    public UnrecognizedOptionException( String message ) {\n-        super( message );\n+    public UnrecognizedOptionException(String message)\n+    {\n+        super(message);\n     }\n-}\n+}\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Util.java,v 1.1 2002/11/18 08:41:26 jkeyes Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/18 08:41:26 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//cli/src/java/org/apache/commons/cli/Util.java,v 1.2 2002/12/09 23:47:25 jkeyes Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/12/09 23:47:25 $\n  *\n  * ====================================================================\n  *\n  */\n class Util {\n \n-    static String stripLeadingHyphens( String str ) {\n-        if( str.startsWith( \"--\" ) ) {\n-            return str.substring( 2, str.length() );\n+    /**\n+     * <p>Remove the hyphens from the begining of <code>str</code> and\n+     * return the new String.</p>\n+     *\n+     * @param str The string from which the hyphens should be removed.\n+     *\n+     * @return the hyphens from the begining of <code>str</code> and\n+     * return the new String.\n+     */\n+    static String stripLeadingHyphens(String str)\n+    {\n+        if (str.startsWith(\"--\"))\n+        {\n+            return str.substring(2, str.length());\n         }\n-        else if ( str.startsWith( \"-\" ) ) {\n-            return str.substring( 1, str.length() );\n+        else if (str.startsWith(\"-\"))\n+        {\n+            return str.substring(1, str.length());\n         }\n+\n         return str;\n     }\n-            }\n+}\n--- a/src/test/org/apache/commons/cli/TestHelpFormatter.java\n+++ b/src/test/org/apache/commons/cli/TestHelpFormatter.java\n       String text = \"This is a test.\";\n       String expected;\n \n-      expected = \"This is a\" + hf.defaultNewLine + \"test.\";\n+      expected = \"This is a\" + hf.getNewLine() + \"test.\";\n       hf.renderWrappedText(sb, 12, 0, text);\n       assertEquals(\"single line text\", expected, sb.toString());\n \n       sb.setLength(0);\n-      expected = \"This is a\" + hf.defaultNewLine + \"    test.\";\n+      expected = \"This is a\" + hf.getNewLine() + \"    test.\";\n       hf.renderWrappedText(sb, 12, 4, text);\n       assertEquals(\"single line padded text\", expected, sb.toString());\n \n       text =\n-         \"aaaa aaaa aaaa\" + hf.defaultNewLine +\n-         \"aaaaaa\" + hf.defaultNewLine +\n+         \"aaaa aaaa aaaa\" + hf.getNewLine() +\n+         \"aaaaaa\" + hf.getNewLine() +\n          \"aaaaa\";\n \n       expected = text;\n       assertEquals(\"multi line text\", expected, sb.toString());\n \n       expected =\n-         \"aaaa aaaa aaaa\" + hf.defaultNewLine +\n-         \"    aaaaaa\" + hf.defaultNewLine +\n+         \"aaaa aaaa aaaa\" + hf.getNewLine() +\n+         \"    aaaaaa\" + hf.getNewLine() +\n          \"    aaaaa\";\n       sb.setLength(0);\n       hf.renderWrappedText(sb, 16, 4, text);\n \n        int nextLineTabStop = leftPad+descPad+\"-a\".length();\n        expected =\n-           lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + hf.defaultNewLine +\n+           lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + hf.getNewLine() +\n            hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n        sb.setLength(0);\n        hf.renderOptions(sb, nextLineTabStop+17, options, leftPad, descPad);\n \n        nextLineTabStop = leftPad+descPad+\"-a,--aaa\".length();\n        expected =\n-           lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.defaultNewLine +\n+           lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.getNewLine() +\n            hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n            addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").\n            addOption(\"b\", false, \"feeee eeee eeee eeee\");\n        expected =\n-           lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.defaultNewLine +\n-           hf.createPadding(nextLineTabStop) + \"dddd dddd\" + hf.defaultNewLine +\n-           lpad + \"-b      \" + dpad + \"feeee eeee\" + hf.defaultNewLine +\n+           lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + hf.getNewLine() +\n+           hf.createPadding(nextLineTabStop) + \"dddd dddd\" + hf.getNewLine() +\n+           lpad + \"-b      \" + dpad + \"feeee eeee\" + hf.getNewLine() +\n            hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);", "timestamp": 1039477646, "metainfo": ""}