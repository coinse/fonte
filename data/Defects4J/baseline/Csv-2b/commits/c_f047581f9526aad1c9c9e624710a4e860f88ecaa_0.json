{"sha": "f047581f9526aad1c9c9e624710a4e860f88ecaa", "log": "Javadoc improvements, more unit tests, change of API to a chain style, some bugfixes  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n  * <p>Parsing of a csv-string having ';' as separator:</p>\n  * <pre>\n  *  String[][] data = \n- *         (new CSVParser(new StringReader(\"a;b\\nc;d\"),';')).getAllValues();\n+ *      (new CSVParser(new StringReader(\"a;b\\nc;d\"),';')).getAllValues();\n+ * </pre>\n+ * \n+ * <p>The API allows chained method calls, if you like this coding style:</p>\n+ * <pre>\n+ *  String[][] data = (new CSVParser(new StringReader(\"a;b\\nc;d\"),';'))\n+ *      .setExcelStrategy().setIgnoreEmptyLines(true).getAllValues();\n  * </pre>\n  * \n  * <p>\n  * for more details</p>\n  */\n public class CSVParser {\n-  \n+\n   /** length of the initial token (content-)buffer */\n   private static final int INITIAL_TOKEN_LENGTH = 50;\n   \n   // the token types\n+  /** Token has no valid content, i.e. is in its initilized state. */\n   protected static final int TT_INVALID = -1;\n+  /** Token with content, at beginning or in the middle of a line. */\n   protected static final int TT_TOKEN = 0;\n+  /** Token (which can have content) when end of file is reached. */\n   protected static final int TT_EOF = 1;\n+  /** Token with content when end of a line is reached. */\n   protected static final int TT_EORECORD = 2;\n    \n   // the csv definition\n    * It is used as contract between the lexer and the parser. \n    */\n   class Token {\n-    // token type see TT_xxx constants\n+    /** Token type, see TT_xxx constants. */\n     int type;\n-    // the content buffer\n+    /** The content buffer. */\n     StringBuffer content;\n-    // token ready flag: indicates a valid token (ready for the parser)\n+    /** Token ready flag: indicates a valid token with content (ready for the parser). */\n     boolean isReady;\n+    /** Initializes an empty token. */\n     Token() {\n       content = new StringBuffer(INITIAL_TOKEN_LENGTH);\n       type = TT_INVALID;\n   /**\n    * Parses the given String according to the default CSV strategy.\n    * \n+   * @param s CSV String to be parsed.\n    * @return parsed String matrix (which is never null)\n    * @throws IOException in case of error\n    * @see #setCSVStrategy()\n     if (s == null) {\n       throw new IllegalArgumentException(\"Null argument not allowed.\");\n     }\n-    return (new CSVParser(new StringReader(s))).getAllValues();\n+    String[][] result = (new CSVParser(new StringReader(s))).getAllValues();\n+    if (result == null) {\n+      // since CSVStrategy ignores empty lines an empty array is returned\n+      // (i.e. not \"result = new String[][] {{\"\"}};\")\n+      result = new String[0][0];\n+    }\n+    return result;\n   }\n   \n   /**\n    * Parsing empty string will be handled as valid records containing zero\n    * elements, so the following property holds: parseLine(\"\").length == 0.\n    * \n+   * @param s CSV String to be parsed.\n    * @return parsed String vector (which is never null)\n    * @throws IOException in case of error\n    * @see #setCSVStrategy()\n    * Customized csv parser.\n    * \n    * The parser parses according to the given CSV dialect settings.\n-   * Leading whitespaces are truncated whereas unicode escapes are\n-   * not interpreted.\n+   * Leading whitespaces are truncated, unicode escapes are\n+   * not interpreted and empty lines are ignored.\n    * \n    * @param input a Reader based on \"csv-formatted\" input\n    * @param delimiter a Char used for value separation\n    * the stream.\n    * \n    * @return matrix of records x values ('null' when end of file)\n+   * @throws IOException on parse error or input read-failure\n    */\n   public String[][] getAllValues() throws IOException {\n     Vector records = new Vector();\n    * and returns the next csv-value as string.\n    * \n    * @return next value in the input stream ('null' when end of file)\n-   * @throws IOException\n+   * @throws IOException on parse error or input read-failure\n    */\n   public String nextValue() throws IOException {\n     Token tkn = nextToken();\n         record.add(tkn.content.toString());\n         break;\n       case TT_EOF:\n-        ret = null;\n+        if (tkn.isReady) {\n+          record.add(tkn.content.toString());\n+        } else {\n+          ret = null;\n+        }\n         break;\n       case TT_INVALID:\n       default:\n    *            number does not correspond to the record-number\n    * \n    * @return  current line number\n-   * @throws IOException\n-   */\n-  public int getLineNumber() throws IOException {\n+   */\n+  public int getLineNumber() {\n     return in.getLineNumber();  \n   }\n   \n   // ======================================================\n  \n  /**\n-  * Returns the next token \n-  * \n-  * a token coresponds to a term, a record change\n-  * or and end-of-file indicator\n-  */\n+   * Returns the next token.\n+   * \n+   * A token corresponds to a term, a record change or an\n+   * end-of-file indicator.\n+   * \n+   * @return the next token found\n+   * @throws IOException on stream access error\n+   */\n   protected Token nextToken() throws IOException {\n     Token tkn = new Token();\n     StringBuffer wsBuf = new StringBuffer();\n-    // boolean skipEmptyLines = false;\n     \n     // get the last read char (required for empty line detection)\n     int lastChar = in.readAgain();\n     }\n \n     // did we reached eof during the last iteration already ? TT_EOF\n-    if (isEndOfFile(lastChar)) {\n+    if (isEndOfFile(lastChar) || (lastChar != delimiter && isEndOfFile(c))) {\n       tkn.type = TT_EOF;\n       return tkn;\n     } \n       } else if (isEndOfFile(c)) {\n         // end of file return TT_EOF()\n         tkn.content.append(\"\");\n-        tkn.type = TT_EORECORD;\n-        // tkn.type = TT_EOF;\n+        tkn.type = TT_EOF;\n         tkn.isReady = true;\n       } else {\n         // next token must be a simple token\n         tkn.isReady = true;\n       } else if (isEndOfFile(c)) {\n         // end of file\n-        // tkn.type = TT_EOF;\n-        tkn.type = TT_EORECORD;\n+        tkn.type = TT_EOF;\n         tkn.isReady = true;\n       } else if (c == delimiter) {\n         // end of token\n         tkn.type = TT_TOKEN;\n         tkn.isReady = true;\n-      } else if (c == '\\\\') {\n-        // handle escaped delimiters (remove escaping)\n-        if (in.lookAhead() == this.delimiter) {\n-          tkn.content.append((char) in.read());\n-        } else if (interpretUnicodeEscapes && in.lookAhead() == 'u') {\n-          // interpret unicode escaped chars (like \\u0070 -> p)\n-          tkn.content.append((char) unicodeEscapeLexer(c));\n-        } else {\n-          tkn.content.append((char) c);\n-        }\n+      } else if (c == '\\\\' && interpretUnicodeEscapes && in.lookAhead() == 'u') {\n+        // interpret unicode escaped chars (like \\u0070 -> p)\n+        tkn.content.append((char) unicodeEscapeLexer(c));\n       } else if (isWhitespace(c)) {\n         // gather whitespaces \n         // (as long as they are not at the beginning of a token)\n           c = in.read();\n           tkn.content.append((char) c);\n         } else if (c == '\\\\' && in.lookAhead() == '\\\\') {\n-          // doubled escape character -> add single escape char to stream\n+          // doubled escape char, it does not escape itself, only encapsulator \n+          // -> add both escape chars to stream\n+          tkn.content.append((char) c);\n           c = in.read();\n           tkn.content.append((char) c);\n         } else if (\n           && in.lookAhead() == 'u') {\n           // interpret unicode escaped chars (like \\u0070 -> p)\n           tkn.content.append((char) unicodeEscapeLexer(c));\n+        } else if (c == '\\\\') {\n+          // use a single escape character -> add it to stream\n+          tkn.content.append((char) c);\n         } else {\n-          // token finish mark reached: ignore ws till delimiter\n+          // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n           while (!tkn.isReady) {\n             int n = in.lookAhead();\n             if (n == delimiter) {\n               tkn.type = TT_TOKEN;\n               tkn.isReady = true;\n             } else if (isEndOfFile(n)) {\n-              // tkn.type = TT_EOF;\n-              tkn.type = TT_EORECORD;\n+              tkn.type = TT_EOF;\n               tkn.isReady = true;\n             } else if (isEndOfLine(n)) {\n               // ok eo token reached\n   \n   \n   /**\n-   * Decodes Unicode escapes \n+   * Decodes Unicode escapes.\n    * \n    * Interpretation of \"\\\\uXXXX\" escape sequences\n-   * where XXXX is a hex-number\n-   * @param c\n+   * where XXXX is a hex-number.\n+   * @param c current char which is discarded because it's the \"\\\\\" of \"\\\\uXXXX\"\n    * @return the decoded character\n    * @throws IOException on wrong unicode escape sequence or read error\n    */\n    * Sets the \"Default CSV\" settings.\n    * \n    * The default csv settings are relatively restrictive but implement\n-   * something like the \"least-common-basis\" of CSV.\n-   * \n-   * Values are separated by ',' (as the C in \"CSV\"). Complex values must\n-   * be surrounded by '\"'. Comments are not supported. Leading whitespaces\n-   * are ignored, unicode escapes are not interpreted and empty lines\n-   * are skiped.\n-   */\n-  public void setCSVStrategy() {\n+   * something like the \"least-common-basis\" of CSV:\n+   * <ul>\n+   * <li> Delimiter of values is comma ',' (as the C in \"CSV\") </li>\n+   * <li> Complex values encapsulated by '\"' </li>\n+   * <li> Comments are not supported </li>\n+   * <li> Leading whitespaces are ignored </li>\n+   * <li> Unicode escapes are not interpreted </li>\n+   * <li> empty lines are skiped </li>\n+   * </ul>\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setCSVStrategy() {\n     setStrategy(',', '\"', (char) 0, true, false, true);\n-  }\n-  \n-  /**\n-   * Sets the \"Excel CSV\" settings.\n-   * \n-   * There are companies out there which interpret \"C\" as an abbreviation for\n-   * \"Semicolon\". For these companies the following settings might be\n-   * appropriate: \n-   * <p>\n-   * Delimiter Semicolon ';', Complex-values surrounded by '\"', leading \n-   * whitespaces are not ignored and unicode escapes are not interpreted.\n-   */\n-  public void setExcelStrategy() {\n+    return this;\n+  }\n+  \n+  /**\n+   * Sets the \"Excel CSV\" settings. There are companies out there which\n+   * interpret \"C\" as an abbreviation for \"Semicolon\". For these companies the\n+   * following settings might be appropriate:\n+   * <ul>\n+   * <li> Delimiter of values is semicolon ';' </li>\n+   * <li> Complex values encapsulated by '\"' </li>\n+   * <li> Comments are not supported </li>\n+   * <li> Leading whitespaces are not ignored </li>\n+   * <li> Unicode escapes are not interpreted </li>\n+   * <li> empty lines are not skiped </li>\n+   * </ul>\n+   *\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setExcelStrategy() {\n     setStrategy(';', '\"', (char) 0, false, false, false);\n+    return this;\n   }\n   \n   /**\n    * @param interpretUnicodeEscapes TRUE when unicode escapes should be \n    *                                interpreted\n    * @param ignoreEmptyLines TRUE when the parser should skip emtpy lines\n-   */\n-  public void setStrategy(\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setStrategy(\n     char delimiter, \n     char encapsulator, \n     char commentStart, \n     this.setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);\n     this.setUnicodeEscapeInterpretation(interpretUnicodeEscapes);\n     this.setIgnoreEmptyLines(ignoreEmptyLines);\n-  }\n-  \n-  /**\n-   * Set the desired delimiter\n+    return this;\n+  }\n+  \n+  /**\n+   * Set the desired delimiter.\n    *\n    * @param c a Char used for value separation\n-   */\n-  public void setDelimiter(char c) {\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setDelimiter(char c) {\n     this.delimiter = c;\n+    return this;\n   }\n   \n   /**\n   }\n   \n   /**\n-   * Set the desired encapsulator\n+   * Set the desired encapsulator.\n    * \n    * @param c a Char used as value encapsulation marker\n-   */\n-  public void setEncapsulator(char c) {\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setEncapsulator(char c) {\n     this.encapsulator = c;\n+    return this;\n   }\n   \n   /**\n   }\n   \n   /**\n-   * Set the desired comment start character\n+   * Set the desired comment start character.\n    * \n    * @param c a Char used for comment identification\n-   */\n-  public void setCommentStart(char c) {\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setCommentStart(char c) {\n     this.commentStart = c;\n-  }\n-  \n-  /**\n-   * Gets the comment identifier\n+    return this;\n+  }\n+  \n+  /**\n+   * Gets the comment identifier.\n    * \n    * @return the comment identifier character\n    */\n   }\n   \n   /**\n-   * Enables unicode escape interpretation\n+   * Enables unicode escape interpretation.\n    * \n    * @param b TRUE when interpretation should be enabled\n-   */\n-  public void setUnicodeEscapeInterpretation(boolean b) {\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setUnicodeEscapeInterpretation(boolean b) {\n     this.interpretUnicodeEscapes = b;\n-  }\n-  \n-  /**\n-   * Shows wether unicode interpretation is enabled\n+    return this;\n+  }\n+  \n+  /**\n+   * Shows wether unicode interpretation is enabled.\n    * \n    * @return TRUE when unicode interpretation is enabled\n    */\n    * Sets the ignore-leading-whitespaces behaviour.\n    * \n    * Should the lexer ignore leading whitespaces when parsing non \n-   * encapsulated tokens\n+   * encapsulated tokens.\n    * \n    * @param b TRUE when leading whitespaces should be ignored\n-   */\n-  public void setIgnoreLeadingWhitespaces(boolean b) {\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setIgnoreLeadingWhitespaces(boolean b) {\n     this.ignoreLeadingWhitespaces = b;\n-  }\n-  \n-  /**\n-   * Shows wether unicode interpretation is enabled\n+    return this;\n+  }\n+  \n+  /**\n+   * Shows whether unicode interpretation is enabled.\n    * \n    * @return TRUE when unicode interpretation is enabled\n    */\n    * \n    * When set to 'true' empty lines in the input will be ignored.\n    * \n-   * @param b\n-   */\n-  public void setIgnoreEmptyLines(boolean b) {\n+   * @param b TRUE when empty lines in the input should be ignored\n+   * @return current instance of CSVParser to allow chained method calls\n+   */\n+  public CSVParser setIgnoreEmptyLines(boolean b) {\n     this.ignoreEmptyLines = b;  \n+    return this;\n+  }\n+  \n+  /**\n+   * Shows whether empty lines in the input are ignored.\n+   * \n+   * @return TRUE when empty lines in the input are ignored\n+   */\n+  public boolean getIgnoreEmptyLines() {\n+    return this.ignoreEmptyLines;\n   }\n   \n   // ======================================================\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n public class CSVParserTest extends TestCase {\n   \n   /**\n-   * TestCSVParser\n+   * TestCSVParser.\n    */\n   class TestCSVParser extends CSVParser {\n+    /**\n+     * Test parser to investigate the type of the internal Token.\n+     * @param in a Reader\n+     */\n     TestCSVParser(Reader in) {\n       super(in);\n     }\n+    /**\n+     * Calls super.nextToken() and prints out a String representation of token\n+     * type and content.\n+     * @return String representation of token type and content\n+     * @throws IOException like {@link CSVParser#nextToken()}\n+     */\n     public String testNextToken() throws IOException {\n       Token t = super.nextToken();\n       String tmp = Integer.toString(t.type) + \";\" + t.content + \";\";\n   }\n   \n   /**\n-   * Constructor for CSVParserTest.\n-   * @param arg0\n+   * Constructor for JUnit.\n+   * @param name Name to be used in JUnit Test Environment\n    */\n-  public CSVParserTest(String arg0) {\n-    super(arg0);\n-  }\n-\n+  public CSVParserTest(String name) {\n+    super(name);\n+  }\n+\n+  /**\n+   * Returns a Test suite for JUnit.\n+   * @return Test suite for JUnit\n+   */\n   public static Test suite() {\n     return new TestSuite(CSVParserTest.class);\n   }\n   public void testSetCSVStrategy() {\n     CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n     // default settings\n+    assertEquals(parser.getDelimiter(), ',');\n+    assertEquals(parser.getEncapsulator(), '\"');\n     assertEquals(parser.getCommentStart(), '\\0');\n-    assertEquals(parser.getEncapsulator(), '\"');\n-    assertEquals(parser.getDelimiter(), ',');\n+    assertEquals(true,  parser.getIgnoreLeadingWhitespaces());\n+    assertEquals(false, parser.getUnicodeEscapeInterpretation());\n+    assertEquals(true,  parser.getIgnoreEmptyLines());\n     // explicit csv settings\n     parser.setCSVStrategy();\n+    assertEquals(parser.getDelimiter(), ',');\n+    assertEquals(parser.getEncapsulator(), '\"');\n     assertEquals(parser.getCommentStart(), '\\0');\n+    assertEquals(true,  parser.getIgnoreLeadingWhitespaces());\n+    assertEquals(false, parser.getUnicodeEscapeInterpretation());\n+    assertEquals(true,  parser.getIgnoreEmptyLines());\n+  }\n+  \n+  public void testSetExcelStrategy() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    // explicit Excel settings\n+    parser.setExcelStrategy();\n+    assertEquals(parser.getDelimiter(), ';');\n     assertEquals(parser.getEncapsulator(), '\"');\n-    assertEquals(parser.getDelimiter(), ',');\n-  }\n-  \n+    assertEquals(parser.getCommentStart(), '\\0');\n+    assertEquals(false,  parser.getIgnoreLeadingWhitespaces());\n+    assertEquals(false, parser.getUnicodeEscapeInterpretation());\n+    assertEquals(false, parser.getIgnoreEmptyLines());\n+  }\n   \n   \n   // ======================================================\n   //   lexer tests\n   // ======================================================\n   \n-  // single line (without comment)\n+  // Single line (without comment)\n   public void testNextToken1() throws IOException {\n     String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n     assertEquals(CSVParser.TT_TOKEN + \";wxy;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";z;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());  \n   }\n   \n   // multiline including comments (and empty lines)\n   public void testNextToken2() throws IOException {\n     /*   file:   1,2,3,\n-     *           a,b,c\n+     *           a,b x,c\n      *\n      *           # this is a comment \n      *           d,e,\n     parser.setCommentStart('#');\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";,;\", parser.testNextToken());\n+    // an unquoted single backslash is not an escape char\n+    assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";,;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+    // an unquoted single backslash is not an escape char\n+    assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n   }\n   \n   public void testNextToken4() throws IOException {\n     /* file:  a,\"foo\",b\n      *        a,   \" foo\",b\n-     *        a,\"foo \"   ,b\n+     *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n      *        a,  \" foo \" ,b\n      */ \n      String code = \n      assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n      assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n      assertEquals(CSVParser.TT_TOKEN + \"; foo ;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());    \n+//     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+     assertEquals(CSVParser.TT_EOF + \";b;\", parser.testNextToken());    \n   }\n   \n   // encapsulator tokenizer (multi line, delimiter in string)\n   public void testNextToken5() throws IOException {   \n     String code = \n-      \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\",\\\"\\\\\\\"\\\",\\\"\\\"\\\"\\\"\";\n+      \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\",\\\"\\\\\\\"\\\"\"\n+      + \",\\\"\\\\,\\\"\" \n+      + \",\\\"\\\"\\\"\\\"\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n     parser.setCSVStrategy();\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-    assertEquals(\n-      CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\", \n-      parser.testNextToken());\n+    assertEquals(CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\",\n+        parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";\\n\\t \\n;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";\\\";\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";\\\";\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n-    \n+    // escape char in quoted input only escapes delimiter\n+    assertEquals(CSVParser.TT_TOKEN + \";\\\\,;\", parser.testNextToken());\n+    assertEquals(CSVParser.TT_EOF + \";\\\";\", parser.testNextToken());\n   }\n   \n   // change delimiters, comment, encapsulater\n     {\"a\", \"b\", \"c\", \"d\"},\n     {\"a\", \"b\", \"1 2\"}, \n     {\"foo baar\", \"b\", \"\"}, \n-    {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"},\n-    {\"\"}\n+    {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"}\n   };\n   public void testGetLine() throws IOException {\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    CSVParser parser = new CSVParser(new StringReader(code));\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String[] tmp = null;\n     for (int i = 0; i < res.length; i++) {\n   }\n   \n   public void testNextValue() throws IOException {\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    CSVParser parser = new CSVParser(new StringReader(code));\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String tmp = null;\n     for (int i = 0; i < res.length; i++) {\n   }\n   \n   public void testGetAllValues() throws IOException {\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    CSVParser parser = new CSVParser(new StringReader(code));\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String[][] tmp = parser.getAllValues();\n     assertEquals(res.length, tmp.length);\n     }\n   }\n   \n-  public void testExcelStrategyTest() throws IOException {\n+  public void testExcelStrategy1() throws IOException {\n     String code = \n       \"value1;value2;value3;value4\\r\\na;b;c;d\\r\\n  x;;;\"\n       + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\";\\\"  \\\"\\\"world\\\"\\\"\\\";\\\"abc\\ndef\\\";\\r\\n\";\n       {\"a\", \"b\", \"c\", \"d\"},\n       {\"  x\", \"\", \"\", \"\"},\n       {\"\"},\n-      {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"},\n-      {\"\"}\n+      {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n     };\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    CSVParser parser = new CSVParser(new StringReader(code));\n     parser.setExcelStrategy();\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String[][] tmp = parser.getAllValues();\n     }\n   }\n   \n-  public void testExcelStrategyTest2() throws Exception {\n+  public void testExcelStrategy2() throws Exception {\n     String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n     String[][] res = {\n       {\"foo\", \"baar\"},\n       {\"\"},\n       {\"hello\", \"\"},\n       {\"\"},\n-      {\"world\", \"\"},\n-      {\"\"} \n+      {\"world\", \"\"}\n     };\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+    CSVParser parser = new CSVParser(new StringReader(code));\n     parser.setExcelStrategy();\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String[][] tmp = parser.getAllValues();\n       }\n       assertTrue(Arrays.equals(res[i], tmp[i])); \n     }\n-    //assertTrue(false);\n+  }\n+  \n+  public void testEndOfFileBehaviourExcel() throws Exception {\n+    String[] codes = {\n+        \"hello;\\r\\n\\r\\nworld;\\r\\n\",\n+        \"hello;\\r\\n\\r\\nworld;\",\n+        \"hello;\\r\\n\\r\\nworld;\\\"\\\"\\r\\n\",\n+        \"hello;\\r\\n\\r\\nworld;\\\"\\\"\",\n+        \"hello;\\r\\n\\r\\nworld;\\n\",\n+        \"hello;\\r\\n\\r\\nworld;\",\n+        \"hello;\\r\\n\\r\\nworld;\\\"\\\"\\n\",\n+        \"hello;\\r\\n\\r\\nworld;\\\"\\\"\"\n+        };\n+    String[][] res = {\n+      {\"hello\", \"\"},\n+      {\"\"},  // ExcelStrategy does not ignore empty lines\n+      {\"world\", \"\"}\n+    };\n+    String code;\n+    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+      code = codes[codeIndex];\n+      CSVParser parser = new CSVParser(new StringReader(code));\n+      parser.setExcelStrategy();\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      String[][] tmp = parser.getAllValues();\n+      assertEquals(res.length, tmp.length);\n+      assertTrue(tmp.length > 0);\n+      for (int i = 0; i < res.length; i++) {\n+        for (int j = 0; j < tmp[i].length; j++) {\n+          System.out.println(\"'\" + tmp[i][j] + \"'\");\n+        }\n+        assertTrue(Arrays.equals(res[i], tmp[i]));\n+      }\n+    }\n+  }\n+  \n+  public void testEndOfFileBehaviorCSV() throws Exception {\n+    String[] codes = {\n+        \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n+        \"hello,\\r\\n\\r\\nworld,\",\n+        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+        \"hello,\\r\\n\\r\\nworld,\\n\",\n+        \"hello,\\r\\n\\r\\nworld,\",\n+        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n+        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n+        };\n+    String[][] res = {\n+      {\"hello\", \"\"},  // CSV Strategy ignores empty lines\n+      {\"world\", \"\"}\n+    };\n+    String code;\n+    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+      code = codes[codeIndex];\n+      CSVParser parser = new CSVParser(new StringReader(code));\n+      parser.setCSVStrategy();\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      String[][] tmp = parser.getAllValues();\n+      assertEquals(res.length, tmp.length);\n+      assertTrue(tmp.length > 0);\n+      for (int i = 0; i < res.length; i++) {\n+        for (int j = 0; j < tmp[i].length; j++) {\n+          System.out.println(\"'\" + tmp[i][j] + \"'\");\n+        }\n+        assertTrue(Arrays.equals(res[i], tmp[i]));\n+      }\n+    }\n+  }\n+  \n+  public void testEmptyLineBehaviourExcel() throws Exception {\n+    String[] codes = {\n+        \"hello;\\r\\n\\r\\n\\r\\n\",\n+        \"hello;\\n\\n\\n\",\n+        \"hello;\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+        \"hello;\\\"\\\"\\n\\n\\n\"\n+        };\n+    String[][] res = {\n+      {\"hello\", \"\"},\n+      {\"\"},  // ExcelStrategy does not ignore empty lines\n+      {\"\"}\n+    };\n+    String code;\n+    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+      code = codes[codeIndex];\n+      CSVParser parser = new CSVParser(new StringReader(code));\n+      parser.setExcelStrategy();\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      String[][] tmp = parser.getAllValues();\n+      assertEquals(res.length, tmp.length);\n+      assertTrue(tmp.length > 0);\n+      for (int i = 0; i < res.length; i++) {\n+        for (int j = 0; j < tmp[i].length; j++) {\n+          System.out.println(\"'\" + tmp[i][j] + \"'\");\n+        }\n+        assertTrue(Arrays.equals(res[i], tmp[i]));\n+      }\n+    }\n+  }\n+  \n+  public void testEmptyLineBehaviourCSV() throws Exception {\n+    String[] codes = {\n+        \"hello,\\r\\n\\r\\n\\r\\n\",\n+        \"hello,\\n\\n\\n\",\n+        \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+        \"hello,\\\"\\\"\\n\\n\\n\"\n+        };\n+    String[][] res = {\n+      {\"hello\", \"\"}  // CSV Strategy ignores empty lines\n+    };\n+    String code;\n+    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+      code = codes[codeIndex];\n+      CSVParser parser = new CSVParser(new StringReader(code));\n+      parser.setCSVStrategy();\n+      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+      String[][] tmp = parser.getAllValues();\n+      assertEquals(res.length, tmp.length);\n+      assertTrue(tmp.length > 0);\n+      for (int i = 0; i < res.length; i++) {\n+        for (int j = 0; j < tmp[i].length; j++) {\n+          System.out.println(\"'\" + tmp[i][j] + \"'\");\n+        }\n+        assertTrue(Arrays.equals(res[i], tmp[i]));\n+      }\n+    }\n+  }\n+  \n+  public void testBackslashEscaping() throws IOException {\n+    String code =\n+      \"one,two,three\\n\"\n+      + \"on\\\\\\\"e,two\\n\"\n+      + \"on\\\"e,two\\n\"\n+      + \"one,\\\"tw\\\\\\\"o\\\"\\n\"\n+      + \"one,\\\"t\\\\,wo\\\"\\n\"\n+      + \"one,two,\\\"th,ree\\\"\\n\"\n+      + \"\\\"a\\\\\\\\\\\"\\n\"\n+      + \"a\\\\,b\\n\"\n+      + \"\\\"a\\\\\\\\,b\\\"\";\n+    String[][] res = {\n+        { \"one\", \"two\", \"three\" },\n+        { \"on\\\\\\\"e\", \"two\" },\n+        { \"on\\\"e\", \"two\" },\n+        { \"one\", \"tw\\\"o\" },\n+        { \"one\", \"t\\\\,wo\" },  // backslash in quotes only escapes a delimiter (\",\")\n+        { \"one\", \"two\", \"th,ree\" },\n+        { \"a\\\\\\\\\" },     // backslash in quotes only escapes a delimiter (\",\")\n+        { \"a\\\\\", \"b\" },  // a backslash must be returnd \n+        { \"a\\\\\\\\,b\" }    // backslash in quotes only escapes a delimiter (\",\")\n+      };\n+    CSVParser parser = new CSVParser(new StringReader(code));\n+    System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n+    String[][] tmp = parser.getAllValues();\n+    assertEquals(res.length, tmp.length);\n+    assertTrue(tmp.length > 0);\n+    for (int i = 0; i < res.length; i++) {\n+      for (int j = 0; j < tmp[i].length; j++) {\n+        System.out.println(\"'\" + tmp[i][j] + \"'\");\n+      }\n+      assertTrue(Arrays.equals(res[i], tmp[i])); \n+    }\n   }\n   \n   // ======================================================\n       assertEquals(2, data[0].length);\n       assertEquals(1, data[1].length);\n       assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\\\\nghi\", data[0][1]);\n+      // an escape char in quotes only escapes a delimiter, not itself\n+      assertEquals(\"def\\\\\\\\nghi\", data[0][1]);\n       assertEquals(\"jkl\", data[1][0]);\n     }\n \n     \n     public void testParse6() throws IOException {\n       String[][] data = CSVParser.parse(\"\");\n-      assertEquals(1, data.length);\n-      assertEquals(1, data[0].length);\n-      assertEquals(\"\", data[0][0]);  \n+      // default strategy is CSV, which ignores empty lines\n+      assertEquals(0, data.length);\n     }\n     \n     public void testParse7() throws IOException {\n       \n     public void testUnicodeEscape() throws IOException {\n       String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n-      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+      CSVParser parser = new CSVParser(new StringReader(code));\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       parser.setUnicodeEscapeInterpretation(true);\n       String[] data = parser.getLine();\n     \n     public void testCarriageReturnLineFeedEndings() throws IOException {\n      String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n-     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+     CSVParser parser = new CSVParser(new StringReader(code));\n      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n      String[][] data = parser.getAllValues();\n      assertEquals(4, data.length);\n       String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n       //String code = \"world\\r\\n\\n\";\n       //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+      CSVParser parser = new CSVParser(new StringReader(code));\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       String[][] data = parser.getAllValues();\n //      for (int i = 0; i < data.length; i++) {\n     \n     public void testLineTokenConsistency() throws IOException {\n       String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n-      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+      CSVParser parser = new CSVParser(new StringReader(code));\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       String[][] data = parser.getAllValues();\n-      parser = new TestCSVParser(new StringReader(code));\n-      TestCSVParser parser1 = new TestCSVParser(new StringReader(code));\n+      parser = new CSVParser(new StringReader(code));\n+      CSVParser parser1 = new CSVParser(new StringReader(code));\n       for (int i = 0; i < data.length; i++) {\n         assertTrue(Arrays.equals(parser1.getLine(), data[i]));\n         for (int j = 0; j < data[i].length; j++) {", "timestamp": 1141621881, "metainfo": ""}