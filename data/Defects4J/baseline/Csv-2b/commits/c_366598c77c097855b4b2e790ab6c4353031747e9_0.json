{"sha": "366598c77c097855b4b2e790ab6c4353031747e9", "log": "Start with CSVWriter.. (it's kind of working already..)  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/csv/writer/CSVConfig.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv.writer;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * The CSVConfig is used to configure the CSV writer\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVConfig {\n+\n+    /** specifies if it is a fixed width csv file **/\n+    private boolean fixedWidth;\n+    /** list of fields **/\n+    private List fields;\n+\n+    /** Do no do any filling **/\n+    public static final int FILLNONE = 0;\n+    /** Fill content the the left. Mainly usable together with fixedWidth **/\n+    public static final int FILLLEFT = 1;\n+    /** Fill content to the right. Mainly usable together with fixedWidth **/\n+    public static final int FILLRIGHT = 2;\n+    \n+    /** The fill pattern */\n+    private int fill;\n+    /** The fill char. Defaults to a space */\n+    private char fillChar = ' ';\n+    /** The seperator character. Defaults to , */\n+    private char delimiter = ',';\n+    /** Should we ignore the delimiter. Defaults to false */\n+    private boolean ignoreDelimiter = false;\n+    /** the value delimiter. Defaults to \" */\n+    private char valueDelimiter = '\"';\n+    /** Should we ignore the value delimiter. Defaults to true */\n+    private boolean ignoreValueDelimiter = true;\n+    /** Specifies if we want to use a field header */\n+    private boolean fieldHeader = false;\n+    /** Specifies if the end of the line needs to be trimmed */\n+    private boolean endTrimmed = false;\n+    /**\n+     * \n+     */\n+    public CSVConfig() {\n+        super();\n+    }\n+    \n+    /**\n+     * @return if the CSV file is fixedWidth\n+     */\n+    public boolean isFixedWidth() {\n+        return fixedWidth;\n+    }\n+    \n+    /**\n+     * Specify if the CSV file is fixed width.\n+     * Defaults to false\n+     * @param fixedWidth the fixedwidth\n+     */\n+    public void setFixedWidth(boolean fixedWidth) {\n+        this.fixedWidth = fixedWidth;\n+    }\n+    \n+    public void addField(CSVField field) {\n+        if (fields == null) {\n+            fields = new ArrayList();\n+        }\n+        fields.add(field);\n+    }\n+    \n+    /**\n+     * Set the fields that should be used by the writer.\n+     * This will overwrite currently added fields completely!\n+     * @param csvFields the csvfields array. If null it will do nothing\n+     */\n+    public void setFields(CSVField[] csvFields) {\n+        if (csvFields == null) {\n+            return;\n+        }\n+        fields = new ArrayList(Arrays.asList(csvFields));\n+    }\n+    \n+    /**\n+     * Set the fields that should be used by the writer\n+     * @param csvField a collection with fields. If null it will do nothing\n+     */\n+    public void setFields(Collection csvField) {\n+        if (csvField == null) {\n+            return;\n+        }\n+        fields = new ArrayList(csvField);\n+    }\n+\n+    /**\n+     * @return an array with the known fields (even if no fields are specified)\n+     */\n+    public CSVField[] getFields() {\n+        CSVField[] csvFields = new CSVField[0];\n+        if (fields != null) {\n+            return (CSVField[]) fields.toArray(csvFields);\n+        }\n+        return csvFields;\n+    }\n+    \n+    public CSVField getField(String name) {\n+        if (fields == null || name == null) {\n+            return null;\n+        }\n+        for(int i = 0; i < fields.size(); i++) {\n+            CSVField field = (CSVField) fields.get(i);\n+            if (name.equals(field.getName())) {\n+                return field;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @return the fill pattern.\n+     */\n+    public int getFill() {\n+        return fill;\n+    }\n+\n+    /**\n+     * Set the fill pattern. Defaults to {@link #FILLNONE}\n+     * <br/>Other options are : {@link #FILLLEFT} and {@link #FILLRIGHT}\n+     * @param fill the fill pattern.\n+     */\n+    public void setFill(int fill) {\n+        this.fill = fill;\n+    }\n+\n+    /**\n+     * \n+     * @return the fillchar. Defaults to a space.\n+     */\n+    public char getFillChar() {\n+        return fillChar;\n+    }\n+\n+    /**\n+     * Set the fill char\n+     * @param fillChar the fill char\n+     */\n+    public void setFillChar(char fillChar) {\n+        this.fillChar = fillChar;\n+    }\n+\n+    /**\n+     * @return the delimeter used.\n+     */\n+    public char getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    /**\n+     * Set the delimiter to use\n+     * @param delimiter the delimiter character.\n+     */\n+    public void setDelimiter(char delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    /**\n+     * @return if the writer should ignore the delimiter character.\n+     */\n+    public boolean isDelimiterIgnored() {\n+        return ignoreDelimiter;\n+    }\n+\n+    /**\n+     * Specify if the writer should ignore the delimiter. \n+     * @param ignoreDelimiter defaults to false.\n+     */\n+    public void setIgnoreDelimiter(boolean ignoreDelimiter) {\n+        this.ignoreDelimiter = ignoreDelimiter;\n+    }\n+\n+    /**\n+     * @return the value delimeter used. Defaults to \"\n+     */\n+    public char getValueDelimiter() {\n+        return valueDelimiter;\n+    }\n+\n+    /**\n+     * Set the value delimiter to use\n+     * @param valueDelimiter the value delimiter character.\n+     */\n+    public void setValueDelimiter(char valueDelimiter) {\n+        this.valueDelimiter = valueDelimiter;\n+    }\n+\n+    /**\n+     * @return if the writer should ignore the value delimiter character.\n+     *         Defaults to true.\n+     */\n+    public boolean isValueDelimiterIgnored() {\n+        return ignoreValueDelimiter;\n+    }\n+\n+    /**\n+     * Specify if the writer should ignore the value delimiter. \n+     * @param ignoreValueDelimiter defaults to false.\n+     */\n+    public void setIgnoreValueDelimiter(boolean ignoreValueDelimiter) {\n+        this.ignoreValueDelimiter = ignoreValueDelimiter;\n+    }\n+\n+    /**\n+     * @return if a field header is used. Defaults to false\n+     */\n+    public boolean isFieldHeader() {\n+        return fieldHeader;\n+    }\n+    /**\n+     * Specify if you want to use a field header.\n+     * @param fieldHeader true or false.\n+     */\n+    public void setFieldHeader(boolean fieldHeader) {\n+        this.fieldHeader = fieldHeader;\n+    }\n+    \n+    /**\n+     * TODO..\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == null && !(obj instanceof CSVConfig)) {\n+            return false;\n+        }\n+        return super.equals(obj);\n+//        CSVConfig config = (CSVConfig) obj;\n+//        getFill() == config.getFill()\n+//        getFields().equals(config.getFields())\n+    }\n+\n+    /**\n+     * Creates a config based on a stream. It tries to guess<br/>\n+     * NOTE : The stream will be closed.\n+     * @param inputStream the inputstream. \n+     * @return the guessed config. \n+     */\n+    public static CSVConfig guessConfig(InputStream inputStream) {\n+        return null;\n+    }\n+\n+    /**\n+     * @return if the end of the line should be trimmed. Default is false.\n+     */\n+    public boolean isEndTrimmed() {\n+        return endTrimmed;\n+    }\n+\n+    /**\n+     * Specify if the end of the line needs to be trimmed. Defaults to false.\n+     * @param endTrimmed\n+     */\n+    public void setEndTrimmed(boolean endTrimmed) {\n+        this.endTrimmed = endTrimmed;\n+    }\n+\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv.writer;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+/**\n+ * Tries to guess a config based on an InputStream.\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVConfigGuesser {\n+\n+    /** The stream to read */\n+    private InputStream in;\n+    /** \n+     * if the file has a field header (need this info, to be able to guess better)\n+     * Defaults to false\n+     */\n+    private boolean hasFieldHeader = false;\n+    /** The found config */\n+    protected CSVConfig config;\n+    \n+    /**\n+     * \n+     */\n+    public CSVConfigGuesser() {\n+        this.config = new CSVConfig();\n+    }\n+    \n+    /**\n+     * @param in the inputstream to guess from\n+     */\n+    public CSVConfigGuesser(InputStream in) {\n+        this();\n+        setInputStream(in);\n+    }\n+    \n+    public void setInputStream(InputStream in) {\n+        this.in = in;\n+    }\n+    \n+    /**\n+     * Allow override.\n+     * @return the inputstream that was set.\n+     */\n+    protected InputStream getInputStream() {\n+        return in;\n+    }\n+    \n+    /**\n+     * Guess the config based on the first 10 (or less when less available) \n+     * records of a CSV file.\n+     * \n+     * @return the guessed config.\n+     */\n+    public CSVConfig guess() {\n+        try {\n+            // tralalal\n+            BufferedReader bIn = new BufferedReader(new InputStreamReader((getInputStream())));\n+            String[] lines = new String[10];\n+            String line = null;\n+            int counter = 0;\n+            while ( (line = bIn.readLine()) != null || counter > 10) {\n+                lines[counter] = line;\n+                counter++;\n+            }\n+            if (counter < 10) {\n+                // remove nulls from the array, so we can skip the null checking.\n+                String[] newLines = new String[counter];\n+                System.arraycopy(lines, 0, newLines, 0, counter);\n+                lines = newLines;\n+            }\n+            analyseLines(lines);\n+        } catch(Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            if (in != null) {\n+                try {\n+                    in.close();\n+                } catch(Exception e) {\n+                    // ignore exception.\n+                }\n+            }\n+        }\n+        CSVConfig conf = config;\n+        // cleanup the config.\n+        config = null;\n+        return conf;\n+    }\n+    \n+    protected void analyseLines(String[] lines) {\n+        guessFixedWidth(lines);\n+        guessFieldSeperator(lines);\n+    }\n+    \n+    /**\n+     * Guess if this file is fixedwidth.\n+     * Just basing the fact on all lines being of the same length\n+     * @param lines\n+     */\n+    protected void guessFixedWidth(String[] lines) {\n+        int lastLength = 0;\n+        // assume fixedlength.\n+        config.setFixedWidth(true);\n+        for (int i = 0; i < lines.length; i++) {\n+            if (i == 0) {\n+                lastLength = lines[i].length();\n+            } else {\n+                if (lastLength != lines[i].length()) {\n+                    config.setFixedWidth(false);\n+                }\n+            }\n+        }\n+    }\n+        \n+\n+    protected void guessFieldSeperator(String[] lines) {\n+        if (config.isFixedWidth()) {\n+            guessFixedWidthSeperator(lines);\n+            return;\n+        }\n+        for (int i = 0; i < lines.length; i++) {\n+        }\n+    }\n+    \n+    protected void guessFixedWidthSeperator(String[] lines) {\n+        // keep track of the fieldlength\n+        int previousMatch = -1;\n+        for (int i = 0; i < lines[0].length(); i++) {\n+            char last = ' ';\n+            boolean charMatches = true;\n+            for (int j = 0; j < lines.length; j++) {\n+                if (j == 0) {\n+                    last = lines[j].charAt(i);\n+                }\n+                if (last != lines[j].charAt(i)) {\n+                    charMatches = false;\n+                    break;\n+                } \n+            }\n+            if (charMatches) {\n+                if (previousMatch == -1) {\n+                    previousMatch = 0;\n+                }\n+                CSVField field = new CSVField();\n+                field.setName(\"field\"+config.getFields().length+1);\n+                field.setSize((i-previousMatch));\n+                config.addField(field);\n+            }\n+        }\n+    }\n+    /**\n+     * \n+     * @return if the field uses a field header. Defaults to false.\n+     */\n+    public boolean hasFieldHeader() {\n+        return hasFieldHeader;\n+    }\n+\n+    /**\n+     * Specify if the CSV file has a field header\n+     * @param hasFieldHeader true or false\n+     */\n+    public void setHasFieldHeader(boolean hasFieldHeader) {\n+        this.hasFieldHeader = hasFieldHeader;\n+    }\n+    \n+ \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/csv/writer/CSVField.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv.writer;\n+\n+\n+/**\n+ * \n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVField {\n+\n+    private String name;\n+    private int size;\n+    private int fill;\n+    private boolean overrideFill;\n+\n+    /**\n+     * \n+     */\n+    public CSVField() {\n+    }\n+\n+    /**\n+     * @param name the name of the field\n+     */\n+    public CSVField(String name) {\n+        setName(name);\n+    }\n+\n+    /**\n+     * @param name the name of the field\n+     * @param size the size of the field\n+     */\n+    public CSVField(String name, int size) {\n+        setName(name);\n+        setSize(size);\n+    }\n+\n+    /**\n+     * @return the name of the field\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    \n+    /**\n+     * Set the name of the field\n+     * @param name the name\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * \n+     * @return the size of the field\n+     */\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Set the size of the field.\n+     * The size will be ignored when fixedwidth is set to false in the CSVConfig\n+     * @param size the size of the field.\n+     */\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    /**\n+     * @return the fill pattern.\n+     */\n+    public int getFill() {\n+        return fill;\n+    }\n+\n+    /**\n+     * Sets overrideFill to true.\n+     * @param fill the file pattern\n+     */\n+    public void setFill(int fill) {\n+        overrideFill = true;\n+        this.fill = fill;\n+    }\n+    \n+    /**\n+     * Does this field override fill ?\n+     * \n+     * @return\n+     */\n+    public boolean overrideFill() {\n+        return overrideFill;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/csv/writer/CSVWriter.java\n+/*\n+ * Copyright 2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+\n+/**\n+ * CSVWriter\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVWriter {\n+\n+    /** The CSV config **/\n+    private CSVConfig config;\n+    /** The writer **/\n+    private Writer writer;\n+    /**\n+     * \n+     */\n+    public CSVWriter() {\n+    }\n+    \n+    public CSVWriter(CSVConfig config) {\n+        setConfig(config);\n+    }\n+\n+    public void writeRecord(Map map) {\n+        CSVField[] fields = config.getFields();\n+        try {\n+            StringBuffer sb = new StringBuffer();\n+            for (int i = 0; i < fields.length; i++) {\n+                String value = (String) map.get(fields[i].getName());\n+                value = writeValue(fields[i], value);\n+                sb.append(value);\n+                if (!config.isDelimiterIgnored() && fields.length != (i+1)) {\n+                    sb.append(config.getDelimiter());\n+                }\n+            }\n+            if (config.isEndTrimmed()) {\n+                for (int i = sb.length()-1; i >= 0; i--) {\n+                    System.out.println(\"i : \" + i);\n+                    if (Character.isWhitespace(sb.charAt(i))) {\n+                        sb.deleteCharAt(i);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+            sb.append(\"\\n\");\n+            String line = sb.toString();\n+            writer.write(line);\n+        } catch(Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    protected String writeValue(CSVField field, String value) throws Exception {\n+        if (config.isFixedWidth()) {\n+            if (value.length() < field.getSize()) {\n+                int fillPattern = config.getFill();\n+                if (field.overrideFill()) {\n+                    fillPattern = field.getFill();\n+                }\n+                StringBuffer sb = new StringBuffer();\n+                int fillSize = (field.getSize() - value.length());\n+                char[] fill = new char[fillSize];\n+                Arrays.fill(fill, config.getFillChar());\n+                if (fillPattern == CSVConfig.FILLLEFT) {\n+                    sb.append(fill);\n+                    sb.append(value);\n+                    value = sb.toString();\n+                } else {\n+                    // defaults to fillpattern FILLRIGHT when fixedwidth is used\n+                    sb.append(value);\n+                    sb.append(fill);\n+                    value = sb.toString();\n+                }\n+            } else if (value.length() > field.getSize()) {\n+                // value to big..\n+                value = value.substring(0, field.getSize());\n+            }\n+            if (!config.isValueDelimiterIgnored()) {\n+                // add the value delimiter..\n+                value = config.getValueDelimiter()+value+config.getValueDelimiter();\n+            }\n+        }\n+        return value;\n+    }\n+    /**\n+     * @return the CVSConfig or null if not present\n+     */\n+    public CSVConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Set the CSVConfig\n+     * @param config the CVSConfig\n+     */\n+    public void setConfig(CSVConfig config) {\n+        this.config = config;\n+    }\n+    \n+    /**\n+     * Set the writer to write the CSV file to.\n+     * @param writer the writer.\n+     */\n+    public void setWriter(Writer writer) {\n+        this.writer = writer;\n+    }\n+\n+}", "timestamp": 1138750608, "metainfo": ""}