{"sha": "ecea0c35993b2428e0a938933896329c413de40e", "log": "Rename \"encapsulator\" to \"quoteChar\" so we have quoteChar and quotePolicy. Encapsulator makes me want to ask \"encapsulate what\"? fieldEncapsulator would be better but so verbose, quoteChar feels more to the point to me and provides symmetry with quotePolicy.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     public static final CSVFormat DEFAULT =\n             PRISTINE\n             .withDelimiter(COMMA)\n-            .withEncapsulator(DOUBLE_QUOTE)\n+            .withQuoteChar(DOUBLE_QUOTE)\n             .withIgnoreEmptyLines(true)\n             .withLineSeparator(CRLF);\n \n     public static final CSVFormat RFC4180 =\n             PRISTINE\n             .withDelimiter(COMMA)\n-            .withEncapsulator(DOUBLE_QUOTE)\n+            .withQuoteChar(DOUBLE_QUOTE)\n             .withLineSeparator(CRLF);\n \n     /**\n     public static final CSVFormat EXCEL =\n             PRISTINE\n             .withDelimiter(COMMA)\n-            .withEncapsulator(DOUBLE_QUOTE)\n+            .withQuoteChar(DOUBLE_QUOTE)\n             .withLineSeparator(CRLF);\n \n     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n     public static final CSVFormat TDF =\n             PRISTINE\n             .withDelimiter(TAB)\n-            .withEncapsulator(DOUBLE_QUOTE)\n+            .withQuoteChar(DOUBLE_QUOTE)\n             .withIgnoreSurroundingSpaces(true)\n             .withIgnoreEmptyLines(true)\n             .withLineSeparator(CRLF);\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withEncapsulator(final char encapsulator) {\n-        return withEncapsulator(Character.valueOf(encapsulator));\n+    public CSVFormat withQuoteChar(final char quoteChar) {\n+        return withQuoteChar(Character.valueOf(quoteChar));\n     }\n \n     /**\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withEncapsulator(final Character encapsulator) {\n-        if (isLineBreak(encapsulator)) {\n+    public CSVFormat withQuoteChar(final Character quoteChar) {\n+        if (isLineBreak(quoteChar)) {\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, encapsulator, quotePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, lineSeparator, header);\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n-        CSVFormat fmt = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\"');\n+        CSVFormat fmt = CSVFormat.PRISTINE.withDelimiter(',').withQuoteChar('\"');\n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n         final CSVFormat format = new CSVFormat('!', '!', Quote.MINIMAL, '!', '!', true, true, CRLF, null);\n \n         format.withDelimiter('?');\n-        format.withEncapsulator('?');\n+        format.withQuoteChar('?');\n         format.withCommentStart('?');\n         format.withLineSeparator(\"?\");\n         format.withEscape('?');\n         final CSVFormat format = new CSVFormat('!', '!', null, '!', '!', true, true, CRLF, null);\n \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n-        assertEquals('?', format.withEncapsulator('?').getQuoteChar().charValue());\n+        assertEquals('?', format.withQuoteChar('?').getQuoteChar().charValue());\n         assertEquals('?', format.withCommentStart('?').getCommentStart().charValue());\n         assertEquals(\"?\", format.withLineSeparator(\"?\").getLineSeparator());\n         assertEquals('?', format.withEscape('?').getEscape().charValue());\n         }\n \n         try {\n-            format.withEncapsulator('\\n');\n+            format.withQuoteChar('\\n');\n             fail();\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n-            format.withEncapsulator('!').withCommentStart('!').validate();\n+            format.withQuoteChar('!').withCommentStart('!').validate();\n             fail();\n         } catch (final IllegalStateException e) {\n             // expected\n         }\n \n-        format.withEncapsulator(null).withCommentStart(null).validate();\n+        format.withQuoteChar(null).withCommentStart(null).validate();\n \n         try {\n             format.withEscape('!').withCommentStart('!').validate();\n \n \n         try {\n-            format.withEncapsulator('!').withDelimiter('!').validate();\n+            format.withQuoteChar('!').withDelimiter('!').validate();\n             fail();\n         } catch (final IllegalStateException e) {\n             // expected\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n         *       ;;\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withEncapsulator('\\'').withCommentStart('!');\n+        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withQuoteChar('\\'').withCommentStart('!');\n         final Lexer parser = getLexer(code, format);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         };\n \n \n-        final CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\\'').withEscape('/')\n+        final CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withQuoteChar('\\'').withEscape('/')\n                                .withIgnoreEmptyLines(true).withLineSeparator(CRLF);\n \n         final CSVParser parser = new CSVParser(code, format);", "timestamp": 1350190819, "metainfo": ""}