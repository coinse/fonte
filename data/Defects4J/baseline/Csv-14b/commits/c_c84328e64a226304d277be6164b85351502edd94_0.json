{"sha": "c84328e64a226304d277be6164b85351502edd94", "log": "Fix JavaDoc errors  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n /**\n  * Specifies the format of a CSV file and parses input.\n  *\n- * <h4>Using predefined formats</h4>\n+ * <h2>Using predefined formats</h2>\n  *\n  * <p>\n  * You can use one of the predefined formats:\n  *\n  * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n  *\n- * <h4>Defining formats</h4>\n+ * <h2>Defining formats</h2>\n  *\n  * <p>\n  * You can extend a format by calling the {@code with} methods. For example:\n  *   .withIgnoreSurroundingSpaces(true);\n  * </pre>\n  *\n- * <h4>Defining column names</h4>\n+ * <h2>Defining column names</h2>\n  *\n  * <p>\n  * To define the column names you want to use to access records, write:\n  * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n  * </p>\n  *\n- * <h4>Parsing</h4>\n+ * <h2>Parsing</h2>\n  *\n  * <p>\n  * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n  * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n  * </p>\n  *\n- * <h4>Referencing columns safely</h4>\n+ * <h2>Referencing columns safely</h2>\n  *\n  * <p>\n  * If your source contains a header record, you can simplify your code and safely reference columns,\n  * This makes your code impervious to changes in column order in the CSV file.\n  * </p>\n  *\n- * <h4>Notes</h4>\n+ * <h2>Notes</h2>\n  *\n  * <p>\n  * This class is immutable.\n     /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n      * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n-     * <p/>\n+     *\n+     * <p>\n      * For example for parsing or generating a CSV file on a French system the following format will be used:\n+     * </p>\n      *\n      * <pre>\n      * CSVFormat fmt = CSVFormat.newBuilder(EXCEL).withDelimiter(';');\n      * </pre>\n+     *\n+     * <p>\n      * Settings are:\n+     * </p>\n      * <ul>\n      * <li>withDelimiter(',')</li>\n      * <li>withQuoteChar('\"')</li>\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  *\n  * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n  *\n- * <h4>Creating instances</h4>\n+ * <h2>Creating instances</h2>\n+ * <p>\n  * There are several static factory methods that can be used to create instances for various types of resources:\n- * <p>\n+ * </p>\n  * <ul>\n  *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n  *     <li>{@link #parse(String, CSVFormat)}</li>\n  *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n  * </ul>\n- * </p>\n  * <p>\n  * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n  *\n  * }\n  * </pre>\n  *\n- * <h4>Parsing record wise</h4>\n+ * <h2>Parsing record wise</h2>\n  * <p>\n  * To parse a CSV input from a file, you write:\n  * </p>\n  * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n  * </p>\n  *\n- * <h4>Parsing into memory</h4>\n+ * <h2>Parsing into memory</h2>\n  * <p>\n  * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n  * </p>\n  * There are two constraints that have to be kept in mind:\n  * </p>\n  *\n- * <p>\n  * <ol>\n  *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n  *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n  *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n  *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n  * </ol>\n- * </p>\n- *\n- * <h4>Notes</h4>\n+ *\n+ * <h2>Notes</h2>\n  * <p>\n  * Internal parser state is completely covered by the format and the reader-state.\n  * </p>\n \n     /**\n      * Returns the current line number in the input stream.\n-     * <p/>\n-     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n+     *\n+     * <p>\n+     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the record number.\n+     * </p>\n      *\n      * @return current line number\n      */\n \n     /**\n      * Returns the current record number in the input stream.\n-     * <p/>\n-     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n+     *\n+     * <p>\n+     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.\n+     * </p>\n      *\n      * @return current line number\n      */\n     /**\n      * Parses the CSV input according to the given format and returns the content as a list of\n      * {@link CSVRecord CSVRecords}.\n-     * <p/>\n+     *\n+     * <p>\n      * The returned content starts at the current parse-position in the stream.\n+     * </p>\n      *\n      * @return list of {@link CSVRecord CSVRecords}, may be empty\n      * @throws IOException\n     /**\n      * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n      * CSVRecords}.\n-     * <p/>\n+     *\n+     * <p>\n      * The returned content starts at the current parse-position in the stream.\n-     * \n+     * </p>\n+     *\n      * @param records\n      *            The collection to add to.\n+     * @param <T> the type of collection used.\n      * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n      * @throws IOException\n      *             on parse error or input read-failure\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n     /**\n      * Creates a printer that will print values to the given stream following the CSVFormat.\n-     * <p/>\n+     * <p>\n      * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats\n      * (encapsulation and escaping with a different character) are not supported.\n+     * </p>\n      *\n      * @param out\n      *            stream to which to print. Must not be null.\n     }\n \n     /**\n-     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n-     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n-     * beginning of each new line in the comment.\n-     * <p/>\n+     * Prints a comment on a new line among the delimiter separated values.\n+     *\n+     * <p>\n+     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n+     * comments and a space will be inserted at the beginning of each new line in the comment.\n+     * </p>\n+     *\n      * If comments are disabled in the current CSV format this method does nothing.\n      *\n      * @param comment", "timestamp": 1399219736, "metainfo": ""}