{"sha": "61fdb7a03a22065de4c63525a4b836ba616aa1f1", "log": "Sort members.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  */\n public class CSVParser implements Iterable<CSVRecord>, Closeable {\n \n+    private final CSVFormat format;\n+    private final Map<String, Integer> headerMap;\n     private final Lexer lexer;\n-    private final Map<String, Integer> headerMap;\n-    private long recordNumber;\n-    private final CSVFormat format;\n-\n-    // the following objects are shared to reduce garbage\n-\n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n+\n+    // the following objects are shared to reduce garbage\n+\n+    private long recordNumber;\n     private final Token reusableToken = new Token();\n \n     /**\n         this(new StringReader(input), format);\n     }\n \n+    private void addRecordValue() {\n+        final String input = reusableToken.content.toString();\n+        final String nullString = this.format.getNullString();\n+        if (nullString == null) {\n+            record.add(input);\n+        } else {\n+            record.add(input.equalsIgnoreCase(nullString) ? null : input);\n+        }}\n+\n+    /**\n+     * Closes resources.\n+     * \n+\t * @throws IOException\n+\t *             If an I/O error occurs\n+     */\n+\tpublic void close() throws IOException {\n+\t\tif (lexer != null) {\n+\t\t\tlexer.close();\n+\t\t}\t\t\n+\t}\n+\n+    /**\n+     * Returns the current line number in the input stream.\n+     * <p/>\n+     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n+     *\n+     * @return current line number\n+     */\n+    public long getCurrentLineNumber() {\n+        return lexer.getCurrentLineNumber();\n+    }\n+\n     /**\n      * Returns a copy of the header map that iterates in column order.\n      * <p>\n     }\n \n     /**\n-     * Returns the current line number in the input stream.\n-     * <p/>\n-     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n-     *\n-     * @return current line number\n-     */\n-    public long getCurrentLineNumber() {\n-        return lexer.getCurrentLineNumber();\n-    }\n-\n-    /**\n      * Returns the current record number in the input stream.\n      * <p/>\n      * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     }\n \n     /**\n+     * Parses the CSV input according to the given format and returns the content as an array of {@link CSVRecord}\n+     * entries.\n+     * <p/>\n+     * The returned content starts at the current parse-position in the stream.\n+     *\n+     * @return list of {@link CSVRecord} entries, may be empty\n+     * @throws IOException\n+     *             on parse error or input read-failure\n+     */\n+    public List<CSVRecord> getRecords() throws IOException {\n+        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n+        CSVRecord rec;\n+        while ((rec = nextRecord()) != null) {\n+            records.add(rec);\n+        }\n+        return records;\n+    }\n+\n+    /**\n+     * Initializes the name to index mapping if the format defines a header.\n+     */\n+    private Map<String, Integer> initializeHeader() throws IOException {\n+        Map<String, Integer> hdrMap = null;\n+        if (format.getHeader() != null) {\n+            hdrMap = new LinkedHashMap<String, Integer>();\n+\n+            String[] header = null;\n+            if (format.getHeader().length == 0) {\n+                // read the header from the first line of the file\n+                final CSVRecord record = nextRecord();\n+                if (record != null) {\n+                    header = record.values();\n+                }\n+            } else {\n+                header = format.getHeader();\n+            }\n+\n+            // build the name to index mappings\n+            if (header != null) {\n+                for (int i = 0; i < header.length; i++) {\n+                    hdrMap.put(header[i], Integer.valueOf(i));\n+                }\n+            }\n+        }\n+        return hdrMap;\n+    }\n+\n+    public boolean isClosed() {\n+\t\treturn lexer.isClosed();\n+\t}\n+\n+    /**\n+     * Returns an iterator on the records. IOExceptions occurring during the iteration are wrapped in a\n+     * RuntimeException.\n+     */\n+    public Iterator<CSVRecord> iterator() {\n+        return new Iterator<CSVRecord>() {\n+            private CSVRecord current;\n+\n+            private CSVRecord getNextRecord() {\n+                try {\n+                    return nextRecord();\n+                } catch (final IOException e) {\n+                    // TODO: This is not great, throw an ISE instead?\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            public boolean hasNext() {\n+            \tif (isClosed()) {\n+            \t\treturn false;\n+            \t}\n+                if (current == null) {\n+                    current = getNextRecord();\n+                }\n+\n+                return current != null;\n+            }\n+\n+            public CSVRecord next() {\n+            \tif (isClosed()) {\n+            \t\treturn null;\n+            \t}\n+                CSVRecord next = current;\n+                current = null;\n+\n+                if (next == null) {\n+                    // hasNext() wasn't called before\n+                    next = getNextRecord();\n+                    if (next == null) {\n+                        throw new NoSuchElementException(\"No more CSV records available\");\n+                    }\n+                }\n+\n+                return next;\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+\t/**\n      * Parses the next record from the current point in the stream.\n      *\n      * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n         return result;\n     }\n \n-    private void addRecordValue() {\n-        final String input = reusableToken.content.toString();\n-        final String nullString = this.format.getNullString();\n-        if (nullString == null) {\n-            record.add(input);\n-        } else {\n-            record.add(input.equalsIgnoreCase(nullString) ? null : input);\n-        }}\n-\n-    /**\n-     * Closes resources.\n-     * \n-\t * @throws IOException\n-\t *             If an I/O error occurs\n-     */\n-\tpublic void close() throws IOException {\n-\t\tif (lexer != null) {\n-\t\t\tlexer.close();\n-\t\t}\t\t\n-\t}\n-\n-    /**\n-     * Parses the CSV input according to the given format and returns the content as an array of {@link CSVRecord}\n-     * entries.\n-     * <p/>\n-     * The returned content starts at the current parse-position in the stream.\n-     *\n-     * @return list of {@link CSVRecord} entries, may be empty\n-     * @throws IOException\n-     *             on parse error or input read-failure\n-     */\n-    public List<CSVRecord> getRecords() throws IOException {\n-        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n-        CSVRecord rec;\n-        while ((rec = nextRecord()) != null) {\n-            records.add(rec);\n-        }\n-        return records;\n-    }\n-\n-    /**\n-     * Initializes the name to index mapping if the format defines a header.\n-     */\n-    private Map<String, Integer> initializeHeader() throws IOException {\n-        Map<String, Integer> hdrMap = null;\n-        if (format.getHeader() != null) {\n-            hdrMap = new LinkedHashMap<String, Integer>();\n-\n-            String[] header = null;\n-            if (format.getHeader().length == 0) {\n-                // read the header from the first line of the file\n-                final CSVRecord record = nextRecord();\n-                if (record != null) {\n-                    header = record.values();\n-                }\n-            } else {\n-                header = format.getHeader();\n-            }\n-\n-            // build the name to index mappings\n-            if (header != null) {\n-                for (int i = 0; i < header.length; i++) {\n-                    hdrMap.put(header[i], Integer.valueOf(i));\n-                }\n-            }\n-        }\n-        return hdrMap;\n-    }\n-\n-    /**\n-     * Returns an iterator on the records. IOExceptions occurring during the iteration are wrapped in a\n-     * RuntimeException.\n-     */\n-    public Iterator<CSVRecord> iterator() {\n-        return new Iterator<CSVRecord>() {\n-            private CSVRecord current;\n-\n-            private CSVRecord getNextRecord() {\n-                try {\n-                    return nextRecord();\n-                } catch (final IOException e) {\n-                    // TODO: This is not great, throw an ISE instead?\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-\n-            public boolean hasNext() {\n-            \tif (isClosed()) {\n-            \t\treturn false;\n-            \t}\n-                if (current == null) {\n-                    current = getNextRecord();\n-                }\n-\n-                return current != null;\n-            }\n-\n-            public CSVRecord next() {\n-            \tif (isClosed()) {\n-            \t\treturn null;\n-            \t}\n-                CSVRecord next = current;\n-                current = null;\n-\n-                if (next == null) {\n-                    // hasNext() wasn't called before\n-                    next = getNextRecord();\n-                    if (next == null) {\n-                        throw new NoSuchElementException(\"No more CSV records available\");\n-                    }\n-                }\n-\n-                return next;\n-            }\n-\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-    }\n-\n-\tpublic boolean isClosed() {\n-\t\treturn lexer.isClosed();\n-\t}\n-\n }", "timestamp": 1375201603, "metainfo": ""}