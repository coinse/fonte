{"sha": "4a6af4590838e8804290464a8d88a837acb2fa08", "log": "[CSV-182] Allow some printing operations directly from CSVFormat. Adds APIs to CSVFormat so update version from 1.3.1-SNAPSHOT to 1.4-SNAPHOT a la semver. This commit refactors a small bit of guts code from CSVPrinter to CSVFormat.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n import static org.apache.commons.csv.Constants.BACKSLASH;\n import static org.apache.commons.csv.Constants.COMMA;\n+import static org.apache.commons.csv.Constants.COMMENT;\n import static org.apache.commons.csv.Constants.CR;\n import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\n import static org.apache.commons.csv.Constants.LF;\n import static org.apache.commons.csv.Constants.PIPE;\n+import static org.apache.commons.csv.Constants.SP;\n import static org.apache.commons.csv.Constants.TAB;\n \n import java.io.IOException;\n      *            TODO\n      * @param trim\n      *            TODO\n-     * @param trailingDelimiter TODO\n+     * @param trailingDelimiter\n+     *            TODO\n      * @throws IllegalArgumentException\n      *             if the delimiter is a line break character\n      */\n         return new CSVPrinter(out, this);\n     }\n \n+    /**\n+     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed. Useful when\n+     * one wants to avoid creating CSVPrinters.\n+     *\n+     * @param value\n+     *            value to be output.\n+     * @param out\n+     *            where to print the value\n+     * @param newRecord\n+     *            is this a new record\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.4\n+     */\n+    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n+        // null values are considered empty\n+        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n+        CharSequence charSequence;\n+        if (value == null) {\n+            charSequence = nullString == null ? Constants.EMPTY : nullString;\n+        } else {\n+            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n+        }\n+        charSequence = getTrim() ? trim(charSequence) : charSequence;\n+        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n+    }\n+\n+    private void print(final Object object, final CharSequence value, final int offset, final int len,\n+            final Appendable out, final boolean newRecord) throws IOException {\n+        if (!newRecord) {\n+            out.append(getDelimiter());\n+        }\n+        if (object == null) {\n+            out.append(value);\n+        } else if (isQuoteCharacterSet()) {\n+            // the original object is needed so can check for Number\n+            printAndQuote(object, value, offset, len, out, newRecord);\n+        } else if (isEscapeCharacterSet()) {\n+            printAndEscape(value, offset, len, out);\n+        } else {\n+            out.append(value, offset, offset + len);\n+        }\n+    }\n+\n+    /*\n+     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n+     */\n+    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n+            throws IOException {\n+        int start = offset;\n+        int pos = offset;\n+        final int end = offset + len;\n+\n+        final char delim = getDelimiter();\n+        final char escape = getEscapeCharacter().charValue();\n+\n+        while (pos < end) {\n+            char c = value.charAt(pos);\n+            if (c == CR || c == LF || c == delim || c == escape) {\n+                // write out segment up until this char\n+                if (pos > start) {\n+                    out.append(value, start, pos);\n+                }\n+                if (c == LF) {\n+                    c = 'n';\n+                } else if (c == CR) {\n+                    c = 'r';\n+                }\n+\n+                out.append(escape);\n+                out.append(c);\n+\n+                start = pos + 1; // start on the current char after this one\n+            }\n+\n+            pos++;\n+        }\n+\n+        // write last segment\n+        if (pos > start) {\n+            out.append(value, start, pos);\n+        }\n+    }\n+\n+    /*\n+     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n+     */\n+    // the original object is needed so can check for Number\n+    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n+            final Appendable out, final boolean newRecord) throws IOException {\n+        boolean quote = false;\n+        int start = offset;\n+        int pos = offset;\n+        final int end = offset + len;\n+\n+        final char delimChar = getDelimiter();\n+        final char quoteChar = getQuoteCharacter().charValue();\n+\n+        QuoteMode quoteModePolicy = getQuoteMode();\n+        if (quoteModePolicy == null) {\n+            quoteModePolicy = QuoteMode.MINIMAL;\n+        }\n+        switch (quoteModePolicy) {\n+        case ALL:\n+            quote = true;\n+            break;\n+        case NON_NUMERIC:\n+            quote = !(object instanceof Number);\n+            break;\n+        case NONE:\n+            // Use the existing escaping code\n+            printAndEscape(value, offset, len, out);\n+            return;\n+        case MINIMAL:\n+            if (len <= 0) {\n+                // always quote an empty token that is the first\n+                // on the line, as it may be the only thing on the\n+                // line. If it were not quoted in that case,\n+                // an empty line has no tokens.\n+                if (newRecord) {\n+                    quote = true;\n+                }\n+            } else {\n+                char c = value.charAt(pos);\n+\n+                // TODO where did this rule come from?\n+                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                    quote = true;\n+                } else if (c <= COMMENT) {\n+                    // Some other chars at the start of a value caused the parser to fail, so for now\n+                    // encapsulate if we start in anything less than '#'. We are being conservative\n+                    // by including the default comment char too.\n+                    quote = true;\n+                } else {\n+                    while (pos < end) {\n+                        c = value.charAt(pos);\n+                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n+                            quote = true;\n+                            break;\n+                        }\n+                        pos++;\n+                    }\n+\n+                    if (!quote) {\n+                        pos = end - 1;\n+                        c = value.charAt(pos);\n+                        // Some other chars at the end caused the parser to fail, so for now\n+                        // encapsulate if we end in anything less than ' '\n+                        if (c <= SP) {\n+                            quote = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (!quote) {\n+                // no encapsulation needed - write out the original value\n+                out.append(value, start, end);\n+                return;\n+            }\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n+        }\n+\n+        if (!quote) {\n+            // no encapsulation needed - write out the original value\n+            out.append(value, start, end);\n+            return;\n+        }\n+\n+        // we hit something that needed encapsulation\n+        out.append(quoteChar);\n+\n+        // Pick up where we left off: pos should be positioned on the first character that caused\n+        // the need for encapsulation.\n+        while (pos < end) {\n+            final char c = value.charAt(pos);\n+            if (c == quoteChar) {\n+                // write out the chunk up until this point\n+\n+                // add 1 to the length to write out the encapsulator also\n+                out.append(value, start, pos + 1);\n+                // put the next starting position on the encapsulator so we will\n+                // write it out again with the next string (effectively doubling it)\n+                start = pos;\n+            }\n+            pos++;\n+        }\n+\n+        // write the last segment\n+        out.append(value, start, pos);\n+        out.append(quoteChar);\n+    }\n+\n+    /**\n+     * Outputs the record separator.\n+     *\n+     * @param out\n+     *            where to write\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.4\n+     */\n+    public void println(final Appendable out) throws IOException {\n+        if (getTrailingDelimiter()) {\n+            out.append(getDelimiter());\n+        }\n+        if (recordSeparator != null) {\n+            out.append(recordSeparator);\n+        }\n+    }\n+\n+    /**\n+     * Prints the given values a single record of delimiter separated values followed by the record separator.\n+     *\n+     * <p>\n+     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n+     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n+     * </p>\n+     *\n+     * @param out where to write\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @since 1.4\n+     */\n+    public void printRecord(final Appendable out, final Object... values) throws IOException {\n+        for (int i = 0; i < values.length; i++) {\n+            print(values[i], out, i == 0);\n+        }\n+        println(out);\n+    }\n+\n     @Override\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n             strings[i] = value == null ? null : value.toString();\n         }\n         return strings;\n+    }\n+\n+    private CharSequence trim(final CharSequence charSequence) {\n+        if (charSequence instanceof String) {\n+            return ((String) charSequence).trim();\n+        }\n+        final int count = charSequence.length();\n+        int len = count;\n+        int pos = 0;\n+\n+        while ((pos < len) && (charSequence.charAt(pos) <= ' ')) {\n+            pos++;\n+        }\n+        while ((pos < len) && (charSequence.charAt(len - 1) <= ' ')) {\n+            len--;\n+        }\n+        return (pos > 0) || (len < count) ? charSequence.subSequence(pos, len) : charSequence;\n     }\n \n     /**\n      * <p>\n      * Calling this method is equivalent to calling:\n      * </p>\n+     *\n      * <pre>\n      * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n      * </pre>\n      * </p>\n      *\n      * @param headerEnum\n-     *              the enum defining the header, {@code null} if disabled, empty if parsed automatically, user\n-     *              specified otherwise.\n+     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n+     *            otherwise.\n      *\n      * @return A new CSVFormat that is equal to this but with the specified header\n      * @see #withHeader(String...)\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n package org.apache.commons.csv;\n \n-import static org.apache.commons.csv.Constants.COMMENT;\n import static org.apache.commons.csv.Constants.CR;\n import static org.apache.commons.csv.Constants.LF;\n import static org.apache.commons.csv.Constants.SP;\n      *             If an I/O error occurs\n      */\n     public void print(final Object value) throws IOException {\n-        // null values are considered empty\n-        // Only call CharSequence.toString() if you have to, helps GC-free use cases. \n-        CharSequence charSequence;\n-        if (value == null) {\n-            final String nullString = format.getNullString();\n-            charSequence = nullString == null ? Constants.EMPTY : nullString;\n-        } else {\n-            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n-        }\n-        charSequence = format.getTrim() ? trim(charSequence) : charSequence;\n-        this.print(value, charSequence, 0, charSequence.length());\n-    }\n-\n-    private CharSequence trim(final CharSequence charSequence) {\n-        if (charSequence instanceof String) {\n-            return ((String) charSequence).trim();\n-        }\n-        final int count = charSequence.length();\n-        int len = count;\n-        int pos = 0;\n-\n-        while ((pos < len) && (charSequence.charAt(pos) <= ' ')) {\n-            pos++;\n-        }\n-        while ((pos < len) && (charSequence.charAt(len - 1) <= ' ')) {\n-            len--;\n-        }\n-        return (pos > 0) || (len < count) ? charSequence.subSequence(pos, len) : charSequence;\n-    }\n-\n-    private void print(final Object object, final CharSequence value, final int offset, final int len)\n-            throws IOException {\n-        if (!newRecord) {\n-            out.append(format.getDelimiter());\n-        }\n-        if (object == null) {\n-            out.append(value);\n-        } else if (format.isQuoteCharacterSet()) {\n-            // the original object is needed so can check for Number\n-            printAndQuote(object, value, offset, len);\n-        } else if (format.isEscapeCharacterSet()) {\n-            printAndEscape(value, offset, len);\n-        } else {\n-            out.append(value, offset, offset + len);\n-        }\n+        format.print(value, out, newRecord);\n         newRecord = false;\n-    }\n-\n-    /*\n-     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n-     */\n-    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n-        int start = offset;\n-        int pos = offset;\n-        final int end = offset + len;\n-\n-        final char delim = format.getDelimiter();\n-        final char escape = format.getEscapeCharacter().charValue();\n-\n-        while (pos < end) {\n-            char c = value.charAt(pos);\n-            if (c == CR || c == LF || c == delim || c == escape) {\n-                // write out segment up until this char\n-                if (pos > start) {\n-                    out.append(value, start, pos);\n-                }\n-                if (c == LF) {\n-                    c = 'n';\n-                } else if (c == CR) {\n-                    c = 'r';\n-                }\n-\n-                out.append(escape);\n-                out.append(c);\n-\n-                start = pos + 1; // start on the current char after this one\n-            }\n-\n-            pos++;\n-        }\n-\n-        // write last segment\n-        if (pos > start) {\n-            out.append(value, start, pos);\n-        }\n-    }\n-\n-    /*\n-     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n-     */\n-    // the original object is needed so can check for Number\n-    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len)\n-            throws IOException {\n-        boolean quote = false;\n-        int start = offset;\n-        int pos = offset;\n-        final int end = offset + len;\n-\n-        final char delimChar = format.getDelimiter();\n-        final char quoteChar = format.getQuoteCharacter().charValue();\n-\n-        QuoteMode quoteModePolicy = format.getQuoteMode();\n-        if (quoteModePolicy == null) {\n-            quoteModePolicy = QuoteMode.MINIMAL;\n-        }\n-        switch (quoteModePolicy) {\n-        case ALL:\n-            quote = true;\n-            break;\n-        case NON_NUMERIC:\n-            quote = !(object instanceof Number);\n-            break;\n-        case NONE:\n-            // Use the existing escaping code\n-            printAndEscape(value, offset, len);\n-            return;\n-        case MINIMAL:\n-            if (len <= 0) {\n-                // always quote an empty token that is the first\n-                // on the line, as it may be the only thing on the\n-                // line. If it were not quoted in that case,\n-                // an empty line has no tokens.\n-                if (newRecord) {\n-                    quote = true;\n-                }\n-            } else {\n-                char c = value.charAt(pos);\n-\n-                // TODO where did this rule come from?\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n-                    // Some other chars at the start of a value caused the parser to fail, so for now\n-                    // encapsulate if we start in anything less than '#'. We are being conservative\n-                    // by including the default comment char too.\n-                    quote = true;\n-                } else {\n-                    while (pos < end) {\n-                        c = value.charAt(pos);\n-                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n-                            quote = true;\n-                            break;\n-                        }\n-                        pos++;\n-                    }\n-\n-                    if (!quote) {\n-                        pos = end - 1;\n-                        c = value.charAt(pos);\n-                        // Some other chars at the end caused the parser to fail, so for now\n-                        // encapsulate if we end in anything less than ' '\n-                        if (c <= SP) {\n-                            quote = true;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if (!quote) {\n-                // no encapsulation needed - write out the original value\n-                out.append(value, start, end);\n-                return;\n-            }\n-            break;\n-        default:\n-            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n-        }\n-\n-        if (!quote) {\n-            // no encapsulation needed - write out the original value\n-            out.append(value, start, end);\n-            return;\n-        }\n-\n-        // we hit something that needed encapsulation\n-        out.append(quoteChar);\n-\n-        // Pick up where we left off: pos should be positioned on the first character that caused\n-        // the need for encapsulation.\n-        while (pos < end) {\n-            final char c = value.charAt(pos);\n-            if (c == quoteChar) {\n-                // write out the chunk up until this point\n-\n-                // add 1 to the length to write out the encapsulator also\n-                out.append(value, start, pos + 1);\n-                // put the next starting position on the encapsulator so we will\n-                // write it out again with the next string (effectively doubling it)\n-                start = pos;\n-            }\n-            pos++;\n-        }\n-\n-        // write the last segment\n-        out.append(value, start, pos);\n-        out.append(quoteChar);\n     }\n \n     /**\n      *             If an I/O error occurs\n      */\n     public void println() throws IOException {\n-        if (format.getTrailingDelimiter()) {\n-            out.append(format.getDelimiter());\n-        }\n-        final String recordSeparator = format.getRecordSeparator();\n-        if (recordSeparator != null) {\n-            out.append(recordSeparator);\n-        }\n+        format.println(out);\n         newRecord = true;\n     }\n \n      *             If an I/O error occurs\n      */\n     public void printRecord(final Object... values) throws IOException {\n-        for (final Object value : values) {\n-            print(value);\n-        }\n-        println();\n+        format.printRecord(out, values);\n+        newRecord = true;\n     }\n \n     /**", "timestamp": 1463000988, "metainfo": ""}