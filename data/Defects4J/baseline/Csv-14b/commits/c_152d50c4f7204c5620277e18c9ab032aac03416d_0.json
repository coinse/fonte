{"sha": "152d50c4f7204c5620277e18c9ab032aac03416d", "log": "Remove type names from static factory APIs in org.apache.commons.csv.CSVParser.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public static CSVParser parseFile(File file, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n         return new CSVParser(new FileReader(file), format);\n     }\n \n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public static CSVParser parseResource(String resource, Charset charset, ClassLoader classLoader,\n+    public static CSVParser parse(String resource, Charset charset, ClassLoader classLoader,\n             final CSVFormat format) throws IOException {\n         final URL url = classLoader.getResource(resource);\n         if (url == null) {\n             throw new IllegalArgumentException(\"Resource cannot be found: \" + resource);\n         }\n-        return parseURL(url, charset, format);\n+        return parse(url, charset, format);\n     }\n \n     /**\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public static CSVParser parseResource(String resource, Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(String resource, Charset charset, final CSVFormat format) throws IOException {\n         final URL url = ClassLoader.getSystemResource(resource);\n         if (url == null) {\n             throw new IllegalArgumentException(\"System resource cannot be found: \" + resource);\n         }\n-        return parseURL(url, charset, format);\n+        return parse(url, charset, format);\n     }\n \n     /**\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public static CSVParser parseString(String string, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n         return new CSVParser(new StringReader(string), format);\n     }\n \n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public static CSVParser parseURL(URL url, Charset charset, final CSVFormat format) throws IOException {\n+    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n         return new CSVParser(new InputStreamReader(url.openStream(), \n                              charset == null ? Charset.forName(\"UTF-8\") : charset), format);\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n \n         // Now parse the file and compare against the expected results\n         // We use a buffered reader internally so no need to create one here.\n-        final CSVParser parser = CSVParser.parseFile(new File(BASE, split[0]), format);\n+        final CSVParser parser = CSVParser.parse(new File(BASE, split[0]), format);\n         for(final CSVRecord record : parser) {\n             String parsed = record.toString();\n             if (checkComments) {\n         assertEquals(testName + \" Expected format \", line, format.toString());\n \n         // Now parse the file and compare against the expected results\n-        final CSVParser parser = CSVParser.parseResource(\"CSVFileParser/\" + split[0], Charset.forName(\"UTF-8\"),\n+        final CSVParser parser = CSVParser.parse(\"CSVFileParser/\" + split[0], Charset.forName(\"UTF-8\"),\n                 this.getClass().getClassLoader(), format);\n         for (final CSVRecord record : parser) {\n             String parsed = record.toString();\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = CSVParser.parseString(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.nextRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = CSVParser.parseString(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n                 {\"\"},\n                 {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n         };\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n                 {\"\"},\n                 {\"world\", \"\"}\n         };\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         };\n \n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n                 {\"world\", \"\"}\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n                 {\"\"}\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parseString(code, CSVFormat.EXCEL);\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n                 {\"hello\", \"\"}  // CSV format ignores empty lines\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n \n     @Test\n     public void testEmptyFile() throws Exception {\n-        final CSVParser parser = CSVParser.parseString(\"\", CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n         assertNull(parser.nextRecord());\n     }\n \n     @Test\n     public void testCSV57() throws Exception {\n-        final CSVParser parser = CSVParser.parseString(\"\", CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n         final List<CSVRecord> list = parser.getRecords();\n         assertNotNull(list);\n         assertEquals(0, list.size());\n                 {\"a\\\\\", \"b\"},  // a backslash must be returnd\n                 {\"a\\\\\\\\,b\"}    // backslash in quotes only escapes a delimiter (\",\")\n         };\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'')\n                                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n-        final CSVParser parser = CSVParser.parseString(code, format);\n+        final CSVParser parser = CSVParser.parse(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         final CSVFormat format = CSVFormat.newFormat(',')\n                 .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n-        final CSVParser parser = CSVParser.parseString(code, format);\n+        final CSVParser parser = CSVParser.parse(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isCommentingEnabled());\n \n-        CSVParser parser = CSVParser.parseString(code, format);\n+        CSVParser parser = CSVParser.parse(code, format);\n         List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         };\n \n         format = CSVFormat.DEFAULT.withCommentStart('#');\n-        parser = CSVParser.parseString(code, format);\n+        parser = CSVParser.parse(code, format);\n         records = parser.getRecords();\n \n         Utils.compare(\"Failed to parse with comments\", res_comments, records);\n     @Test\n     public void testCarriageReturnLineFeedEndings() throws IOException {\n         final String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n     @Test\n     public void testCarriageReturnEndings() throws IOException {\n         final String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n     @Test\n     public void testLineFeedEndings() throws IOException {\n         final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n         final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n         //String code = \"world\\r\\n\\n\";\n         //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-        final CSVParser parser = CSVParser.parseString(code, CSVFormat.DEFAULT);\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(3, records.size());\n     }\n         final StringWriter out = new StringWriter();\n         final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n         final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n-        for (final CSVRecord record : CSVParser.parseString(input, CSVFormat.DEFAULT)) {\n+        for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) {\n             printer.printRecord(record);\n         }\n         assertEquals(input, out.toString());\n \n     @Test\n     public void testGetHeaderMap() throws Exception {\n-        final CSVParser parser = CSVParser.parseString(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n+        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n         final Map<String, Integer> headerMap = parser.getHeaderMap();\n         final Iterator<String> columnNames = headerMap.keySet().iterator();\n         // Headers are iterated in column order.\n \n     @Test\n     public void testGetRecordWithMultiiLineValues() throws Exception {\n-        final CSVParser parser = CSVParser.parseString(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n+        final CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n                 CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n     }\n \n     private void validateRecordNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parseString(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n     }\n \n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parseString(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         assertEquals(0, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n         assertEquals(1, parser.getCurrentLineNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n         final String result = sw.toString();\n         // System.out.println(\"### :\" + printable(result));\n \n-        final CSVParser parser = CSVParser.parseString(result, format);\n+        final CSVParser parser = CSVParser.parse(result, format);\n         final List<CSVRecord> parseResult = parser.getRecords();\n \n         Utils.compare(\"Printer output :\" + printable(result), lines, parseResult);\n--- a/src/test/java/org/apache/commons/csv/FercGovTest.java\n+++ b/src/test/java/org/apache/commons/csv/FercGovTest.java\n \n     @Test\n     public void testContractFile() throws IOException {\n-        final CSVParser parser = CSVParser.parseResource(\"ferc.gov/contract.txt\", US_ASCII,\n+        final CSVParser parser = CSVParser.parse(\"ferc.gov/contract.txt\", US_ASCII,\n                 CSVFormat.DEFAULT.withHeader());\n         try {\n             final List<CSVRecord> records = parser.getRecords();\n \n     @Test\n     public void testTransactionFile() throws IOException {\n-        final CSVParser parser = CSVParser.parseResource(\"ferc.gov/transaction.txt\", US_ASCII,\n+        final CSVParser parser = CSVParser.parse(\"ferc.gov/transaction.txt\", US_ASCII,\n                 CSVFormat.DEFAULT.withHeader());\n         try {\n             final List<CSVRecord> records = parser.getRecords();", "timestamp": 1375981863, "metainfo": ""}