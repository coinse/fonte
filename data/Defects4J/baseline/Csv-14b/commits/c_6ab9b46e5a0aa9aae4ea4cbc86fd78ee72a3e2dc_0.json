{"sha": "6ab9b46e5a0aa9aae4ea4cbc86fd78ee72a3e2dc", "log": "Use final keyword where possible.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      * @param header\n      *            the header\n      */\n-    CSVFormat(char delimiter, char encapsulator, char commentStart, char escape, boolean surroundingSpacesIgnored,\n-            boolean emptyLinesIgnored, String lineSeparator, String[] header) {\n+    CSVFormat(final char delimiter, final char encapsulator, final char commentStart, final char escape, final boolean surroundingSpacesIgnored,\n+            final boolean emptyLinesIgnored, final String lineSeparator, final String[] header) {\n         this.delimiter = delimiter;\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n      *\n      * @return true if <code>c</code> is a line break character\n      */\n-    private static boolean isLineBreak(char c) {\n+    private static boolean isLineBreak(final char c) {\n         return c == '\\n' || c == '\\r';\n     }\n \n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withDelimiter(char delimiter) {\n+    public CSVFormat withDelimiter(final char delimiter) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withEncapsulator(char encapsulator) {\n+    public CSVFormat withEncapsulator(final char encapsulator) {\n         if (isLineBreak(encapsulator)) {\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withCommentStart(char commentStart) {\n+    public CSVFormat withCommentStart(final char commentStart) {\n         if (isLineBreak(commentStart)) {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withEscape(char escape) {\n+    public CSVFormat withEscape(final char escape) {\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n      *            spaces as is.\n      * @return A copy of this format with the specified trimming behavior.\n      */\n-    public CSVFormat withIgnoreSurroundingSpaces(boolean ignoreSurroundingSpaces) {\n+    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, lineSeparator, header);\n     }\n      *            <tt>false</tt> to translate empty lines to empty records.\n      * @return A copy of this format with the specified empty line skipping behavior.\n      */\n-    public CSVFormat withIgnoreEmptyLines(boolean ignoreEmptyLines) {\n+    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, lineSeparator, header);\n     }\n      *\n      * @return A copy of this format using the specified output line separator\n      */\n-    public CSVFormat withLineSeparator(String lineSeparator) {\n+    public CSVFormat withLineSeparator(final String lineSeparator) {\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, lineSeparator, header);\n     }\n      *\n      * @return A copy of this format using the specified header\n      */\n-    public CSVFormat withHeader(String... header) {\n+    public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, encapsulator, commentStart, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, lineSeparator, header);\n     }\n      * @param in\n      *            the input stream\n      */\n-    public Iterable<CSVRecord> parse(Reader in) throws IOException {\n+    public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n         return new CSVParser(in, this);\n     }\n \n      * @param values\n      *            the values to format\n      */\n-    public String format(String... values) {\n-        StringWriter out = new StringWriter();\n+    public String format(final String... values) {\n+        final StringWriter out = new StringWriter();\n         try {\n             new CSVPrinter(out, this).println(values);\n             return out.toString().trim();\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             // should not happen\n             throw new IllegalStateException(e);\n         }\n \n     @Override\n     public String toString() {\n-        StringBuilder sb = new StringBuilder();\n+        final StringBuilder sb = new StringBuilder();\n         sb.append(\"Delimiter=<\").append(delimiter).append('>');\n         if (isEscaping()) {\n             sb.append(' ');\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n class CSVLexer extends Lexer {\n \n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n-    public CSVLexer(CSVFormat format, ExtendedBufferedReader in) {\n+    public CSVLexer(final CSVFormat format, final ExtendedBufferedReader in) {\n         super(format, in);\n     }\n \n      *             on stream access error\n      */\n     @Override\n-    Token nextToken(Token token) throws IOException {\n+    Token nextToken(final Token token) throws IOException {\n \n         // get the last read char (required for empty line detection)\n         int lastChar = in.readAgain();\n         }\n \n         if (isStartOfLine(lastChar) && isCommentStart(c)) {\n-            String comment = in.readLine().trim();\n+            final String comment = in.readLine().trim();\n             token.content.append(comment);\n             token.type = COMMENT;\n             return token;\n      * @throws IOException\n      *             on stream access error\n      */\n-    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n+    private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         // Faster to use while(true)+break than while(tkn.type == INVALID)\n         while (true) {\n             if (isEndOfLine(c)) {\n      * @throws IOException\n      *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n      */\n-    private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n+    private Token encapsulatedTokenLexer(final Token tkn) throws IOException {\n         // save current line number in case needed for IOE\n-        int startLineNumber = getLineNumber();\n+        final int startLineNumber = getLineNumber();\n         int c;\n         while (true) {\n             c = in.read();\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      * @throws IllegalArgumentException\n      *             thrown if the parameters of the format are inconsistent\n      */\n-    public CSVParser(Reader input) throws IOException {\n+    public CSVParser(final Reader input) throws IOException {\n         this(input, CSVFormat.DEFAULT);\n     }\n \n      * @throws IllegalArgumentException\n      *             thrown if the parameters of the format are inconsistent\n      */\n-    public CSVParser(Reader input, CSVFormat format) throws IOException {\n+    public CSVParser(final Reader input, final CSVFormat format) throws IOException {\n         format.validate();\n \n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n      * @throws IllegalArgumentException\n      *             thrown if the parameters of the format are inconsistent\n      */\n-    public CSVParser(String input, CSVFormat format) throws IOException {\n+    public CSVParser(final String input, final CSVFormat format) throws IOException {\n         this(new StringReader(input), format);\n     }\n \n      *             on parse error or input read-failure\n      */\n     public List<CSVRecord> getRecords() throws IOException {\n-        List<CSVRecord> records = new ArrayList<CSVRecord>();\n+        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n         CSVRecord rec;\n         while ((rec = getRecord()) != null) {\n             records.add(rec);\n     /**\n      * Initializes the name to index mapping if the format defines a header.\n      */\n-    private Map<String, Integer> initializeHeader(CSVFormat format) throws IOException {\n+    private Map<String, Integer> initializeHeader(final CSVFormat format) throws IOException {\n         Map<String, Integer> hdrMap = null;\n         if (format.getHeader() != null) {\n             hdrMap = new LinkedHashMap<String, Integer>();\n             String[] header = null;\n             if (format.getHeader().length == 0) {\n                 // read the header from the first line of the file\n-                CSVRecord rec = getRecord();\n+                final CSVRecord rec = getRecord();\n                 if (rec != null) {\n                     header = rec.values();\n                 }\n             private CSVRecord getNextRecord() {\n                 try {\n                     return getRecord();\n-                } catch (IOException e) {\n+                } catch (final IOException e) {\n                     throw new RuntimeException(e);\n                 }\n             }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n      * @throws IllegalArgumentException\n      *             thrown if the parameters of the format are inconsistent\n      */\n-    public CSVPrinter(Appendable out, CSVFormat format) {\n+    public CSVPrinter(final Appendable out, final CSVFormat format) {\n         this.out = out;\n         this.format = format == null ? CSVFormat.DEFAULT : format;\n         this.format.validate();\n      * @param values\n      *            values to be outputted.\n      */\n-    public void println(String... values) throws IOException {\n-        for (String value : values) {\n+    public void println(final String... values) throws IOException {\n+        for (final String value : values) {\n             print(value);\n         }\n         println();\n      * @param comment\n      *            the comment to output\n      */\n-    public void printComment(String comment) throws IOException {\n+    public void printComment(final String comment) throws IOException {\n         if (!format.isCommentingEnabled()) {\n             return;\n         }\n         out.append(format.getCommentStart());\n         out.append(' ');\n         for (int i = 0; i < comment.length(); i++) {\n-            char c = comment.charAt(i);\n+            final char c = comment.charAt(i);\n             switch (c) {\n             case '\\r':\n                 if (i + 1 < comment.length() && comment.charAt(i + 1) == '\\n') {\n         println();\n     }\n \n-    private void print(CharSequence value, int offset, int len) throws IOException {\n+    private void print(final CharSequence value, final int offset, final int len) throws IOException {\n         if (format.isEncapsulating()) {\n             printAndEncapsulate(value, offset, len);\n         } else if (format.isEscaping()) {\n         }\n     }\n \n-    void printAndEscape(CharSequence value, int offset, int len) throws IOException {\n+    void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n         int start = offset;\n         int pos = offset;\n-        int end = offset + len;\n+        final int end = offset + len;\n \n         printSep();\n \n-        char delim = format.getDelimiter();\n-        char escape = format.getEscape();\n+        final char delim = format.getDelimiter();\n+        final char escape = format.getEscape();\n \n         while (pos < end) {\n             char c = value.charAt(pos);\n         }\n     }\n \n-    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n-        boolean first = newLine; // is this the first value on this line?\n+    void printAndEncapsulate(final CharSequence value, final int offset, final int len) throws IOException {\n+        final boolean first = newLine; // is this the first value on this line?\n         boolean quote = false;\n         int start = offset;\n         int pos = offset;\n-        int end = offset + len;\n+        final int end = offset + len;\n \n         printSep();\n \n-        char delim = format.getDelimiter();\n-        char encapsulator = format.getEncapsulator();\n+        final char delim = format.getDelimiter();\n+        final char encapsulator = format.getEncapsulator();\n \n         if (len <= 0) {\n             // always quote an empty token that is the first\n         // Pick up where we left off: pos should be positioned on the first character that caused\n         // the need for encapsulation.\n         while (pos < end) {\n-            char c = value.charAt(pos);\n+            final char c = value.charAt(pos);\n             if (c == encapsulator) {\n                 // write out the chunk up until this point\n \n      * @param value\n      *            value to be outputted.\n      */\n-    public void print(String value, boolean checkForEscape) throws IOException {\n+    public void print(String value, final boolean checkForEscape) throws IOException {\n         if (value == null) {\n             // null values are considered empty\n             value = \"\";\n      * @param value\n      *            value to be outputted.\n      */\n-    public void print(String value) throws IOException {\n+    public void print(final String value) throws IOException {\n         print(value, true);\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n     /** The accumulated comments (if any) */\n     private final String comment;\n \n-    CSVRecord(String[] values, Map<String, Integer> mapping, String comment) {\n+    CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment) {\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n         this.comment = comment;\n      * @param i\n      *            the index of the column retrieved\n      */\n-    public String get(int i) {\n+    public String get(final int i) {\n         return values[i];\n     }\n \n      * @throws IllegalStateException\n      *             if no header mapping was provided\n      */\n-    public String get(String name) {\n+    public String get(final String name) {\n         if (mapping == null) {\n             throw new IllegalStateException(\"No header mapping was specified, the record values can't be accessed by name\");\n         }\n \n-        Integer index = mapping.get(name);\n+        final Integer index = mapping.get(name);\n \n         return index != null ? values[index.intValue()] : null;\n     }\n      *            the name of the column to be retrieved.\n      * @return whether a given columns is mapped.\n      */\n-    public boolean isMapped(String name) {\n+    public boolean isMapped(final String name) {\n         return mapping != null ? mapping.containsKey(name) : false;\n     }\n     \n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n     /**\n      * Created extended buffered reader using default buffer-size\n      */\n-    ExtendedBufferedReader(Reader r) {\n+    ExtendedBufferedReader(final Reader r) {\n         super(r);\n     }\n \n     @Override\n     public int read() throws IOException {\n-        int current = super.read();\n+        final int current = super.read();\n         if (current == CR || (current == LF && lastChar != CR)) {\n             lineCounter++;\n         }\n     }\n \n     @Override\n-    public int read(char[] buf, int offset, int length) throws IOException {\n+    public int read(final char[] buf, final int offset, final int length) throws IOException {\n         if (length == 0) {\n             return 0;\n         }\n \n-        int len = super.read(buf, offset, length);\n+        final int len = super.read(buf, offset, length);\n \n         if (len > 0) {\n \n             for (int i = offset; i < offset + len; i++) {\n-                char ch = buf[i];\n+                final char ch = buf[i];\n                 if (ch == LF) {\n                     if (CR != (i > 0 ? buf[i - 1] : lastChar)) {\n                         lineCounter++;\n      */\n     @Override\n     public String readLine() throws IOException {\n-        String line = super.readLine();\n+        final String line = super.readLine();\n \n         if (line != null) {\n             lastChar = LF; // needed for detecting start of line\n      */\n     int lookAhead() throws IOException {\n         super.mark(1);\n-        int c = super.read();\n+        final int c = super.read();\n         super.reset();\n \n         return c;\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     /** The input stream */\n     final ExtendedBufferedReader in;\n \n-    Lexer(CSVFormat format, ExtendedBufferedReader in) {\n+    Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n         this.format = format;\n         this.in = in;\n         this.isEncapsulating = format.isEncapsulating();\n     // TODO escape handling needs more work\n     int readEscape() throws IOException {\n         // assume c is the escape char (normally a backslash)\n-        int c = in.read();\n+        final int c = in.read();\n         switch (c) {\n         case 'r':\n             return '\\r';\n         }\n     }\n \n-    void trimTrailingSpaces(StringBuilder buffer) {\n+    void trimTrailingSpaces(final StringBuilder buffer) {\n         int length = buffer.length();\n         while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n             length = length - 1;\n     /**\n      * @return true if the given char is a whitespace character\n      */\n-    boolean isWhitespace(int c) {\n+    boolean isWhitespace(final int c) {\n         return c != format.getDelimiter() && Character.isWhitespace((char) c);\n     }\n \n      * @param c\n      * @return true if the character is at the start of a line.\n      */\n-    boolean isStartOfLine(int c) {\n+    boolean isStartOfLine(final int c) {\n         return c == '\\n' || c == '\\r' || c == ExtendedBufferedReader.UNDEFINED;\n     }\n \n     /**\n      * @return true if the given character indicates end of file\n      */\n-    boolean isEndOfFile(int c) {\n+    boolean isEndOfFile(final int c) {\n         return c == ExtendedBufferedReader.END_OF_STREAM;\n     }\n \n     abstract Token nextToken(Token reusableToken) throws IOException;\n \n-    boolean isDelimiter(int c) {\n+    boolean isDelimiter(final int c) {\n         return c == delimiter;\n     }\n \n-    boolean isEscape(int c) {\n+    boolean isEscape(final int c) {\n         return isEscaping && c == escape;\n     }\n \n-    boolean isEncapsulator(int c) {\n+    boolean isEncapsulator(final int c) {\n         return isEncapsulating && c == encapsulator;\n     }\n \n-    boolean isCommentStart(int c) {\n+    boolean isCommentStart(final int c) {\n         return isCommentEnabled && c == commmentStart;\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n     private final BufferedReader testData;\n     private final String testName;\n \n-    public CSVFileParserTest(File file) throws FileNotFoundException\n+    public CSVFileParserTest(final File file) throws FileNotFoundException\n     {\n        this.testName = file.getName();\n        this.testData = new BufferedReader(new FileReader(file));\n     @Parameters\n     public static Collection<Object[]> generateData()\n     {\n-        List<Object[]> list = new ArrayList<Object[]>();\n+        final List<Object[]> list = new ArrayList<Object[]>();\n \n         final FilenameFilter filenameFilter = new FilenameFilter() {\n-            public boolean accept(File dir, String name) {\n+            public boolean accept(final File dir, final String name) {\n                 return name.startsWith(\"test\") && name.endsWith(\".txt\");\n             }\n         };\n-        File[] files = BASE.listFiles(filenameFilter);\n-        for(File f : files){\n+        final File[] files = BASE.listFiles(filenameFilter);\n+        for(final File f : files){\n             list.add(new Object[]{f});\n         }\n         return list;\n     public void testCSVFile() throws Exception {\n         String line = readTestData();\n         assertNotNull(\"file must contain config line\", line);\n-        String[] split = line.split(\" \");\n+        final String[] split = line.split(\" \");\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n-        BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n+        final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n         CSVFormat fmt = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\"');\n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n-            String[] option_parts = option.split(\"=\",2);\n+            final String[] option_parts = option.split(\"=\",2);\n             if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])){\n                 fmt = fmt.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n         assertEquals(testName+\" Expected format \", line, fmt.toString());\n \n         // Now parse the file and compare against the expected results\n-        for(CSVRecord rec : fmt.parse(csvFile)) {\n+        for(final CSVRecord rec : fmt.parse(csvFile)) {\n             String parsed = rec.toString();\n             if (checkComments) {\n                 final String comment = rec.getComment().replace(\"\\n\", \"\\\\n\");\n                     parsed += \"#\" + comment;\n                 }\n             }\n-            int count = rec.size();\n+            final int count = rec.size();\n             assertEquals(testName, readTestData(), count+\":\"+parsed);\n         }\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test\n     public void testImmutalibity() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n+        final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n \n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n \n     @Test\n     public void testMutators() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n+        final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CSVFormat.CRLF, null);\n \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n \n     @Test\n     public void testFormat() {\n-        CSVFormat format = CSVFormat.DEFAULT;\n+        final CSVFormat format = CSVFormat.DEFAULT;\n \n         assertEquals(\"\", format.format());\n         assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n \n     @Test\n     public void testValidation() {\n-        CSVFormat format = CSVFormat.DEFAULT;\n+        final CSVFormat format = CSVFormat.DEFAULT;\n \n         try {\n             format.withDelimiter('\\n');\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withEscape('\\r');\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withEncapsulator('\\n');\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withCommentStart('\\r');\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withDelimiter('!').withEscape('!').validate();\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withDelimiter('!').withCommentStart('!').validate();\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withEncapsulator('!').withCommentStart('!').validate();\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withEscape('!').withCommentStart('!').validate();\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             format.withEncapsulator('!').withDelimiter('!').validate();\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n     @SuppressWarnings(\"boxing\") // no need to worry about boxing here\n     @Test\n     public void testSerialization() throws Exception {\n-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n \n-        ObjectOutputStream oos = new ObjectOutputStream(out);\n+        final ObjectOutputStream oos = new ObjectOutputStream(out);\n         oos.writeObject(CSVFormat.DEFAULT);\n         oos.flush();\n         oos.close();\n \n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n-        CSVFormat format = (CSVFormat) in.readObject();\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n+        final CSVFormat format = (CSVFormat) in.readObject();\n \n         assertNotNull(format);\n         assertEquals(\"delimiter\", CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter());\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n     private final StringBuilder wsBuf = new StringBuilder();\n \n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n-    public CSVLexer1(CSVFormat format, ExtendedBufferedReader in) {\n+    public CSVLexer1(final CSVFormat format, final ExtendedBufferedReader in) {\n         super(format, in);\n     }\n \n      * @return the filled token\n      * @throws IOException on stream access error\n      */\n-    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n+    private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         while (true) {\n             if (isEndOfLine(c)) {\n                 // end of record\n      * @return a valid token object\n      * @throws IOException on invalid state\n      */\n-    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {\n+    private Token encapsulatedTokenLexer(final Token tkn, int c) throws IOException {\n         // save current line\n-        int startLineNumber = getLineNumber();\n+        final int startLineNumber = getLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n         while (true) {\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n class CSVLexer1306663 extends Lexer {\n \n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n-    public CSVLexer1306663(CSVFormat format, ExtendedBufferedReader in) {\n+    public CSVLexer1306663(final CSVFormat format, final ExtendedBufferedReader in) {\n         super(format, in);\n     }\n \n      * @throws java.io.IOException on stream access error\n      */\n     @Override\n-    Token nextToken(Token tkn) throws IOException {\n+    Token nextToken(final Token tkn) throws IOException {\n \n         // get the last read char (required for empty line detection)\n         int lastChar = in.readAgain();\n      * @return the filled token\n      * @throws IOException on stream access error\n      */\n-    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n+    private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         // Faster to use while(true)+break than while(tkn.type == INVALID)\n         while (true) {\n             if (isEndOfLine(c)) {\n      * @return a valid token object\n      * @throws IOException on invalid state\n      */\n-    private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n+    private Token encapsulatedTokenLexer(final Token tkn) throws IOException {\n         // save current line\n-        int startLineNumber = getLineNumber();\n+        final int startLineNumber = getLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n         int c;\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n class CSVLexer1306667 extends Lexer {\n \n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n-    public CSVLexer1306667(CSVFormat format, ExtendedBufferedReader in) {\n+    public CSVLexer1306667(final CSVFormat format, final ExtendedBufferedReader in) {\n         super(format, in);\n     }\n \n      * @throws java.io.IOException on stream access error\n      */\n     @Override\n-    Token nextToken(Token tkn) throws IOException {\n+    Token nextToken(final Token tkn) throws IOException {\n \n         // get the last read char (required for empty line detection)\n         int lastChar = in.readAgain();\n      * @return the filled token\n      * @throws IOException on stream access error\n      */\n-    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n+    private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         // Faster to use while(true)+break than while(tkn.type == INVALID)\n         while (true) {\n             if (isEndOfLine(c)) {\n      * @return a valid token object\n      * @throws IOException on invalid state\n      */\n-    private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n+    private Token encapsulatedTokenLexer(final Token tkn) throws IOException {\n         // save current line\n-        int startLineNumber = getLineNumber();\n+        final int startLineNumber = getLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n         int c;\n--- a/src/test/java/org/apache/commons/csv/CSVLexer3.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer3.java\n     private final char escape;\n \n     // ctor needs to be public so can be called dynamically by PerformanceTest class\n-    public CSVLexer3(CSVFormat format, ExtendedBufferedReader in) {\n+    public CSVLexer3(final CSVFormat format, final ExtendedBufferedReader in) {\n         super(format, in);\n         this.escape = format.getEscape();\n     }\n         EOFCHAR\n     }\n \n-    private CharType classify(int intch) {\n+    private CharType classify(final int intch) {\n         if (isDelimiter(intch)) {\n             return CharType.DELIM;\n         }\n      * @throws java.io.IOException on stream access error\n      */\n     @Override\n-    Token nextToken(Token tkn) throws IOException {\n+    Token nextToken(final Token tkn) throws IOException {\n \n         State state = State.BEGIN;\n         int intch;\n         boolean trimTrailingSpaces = false;\n         while(tkn.type == INVALID) {\n             intch = in.read();\n-            CharType type = classify(intch);\n+            final CharType type = classify(intch);\n             switch(state) {\n                 case BEGIN:\n                     switch(type){\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n \n public class CSVLexerTest {\n \n-    private Lexer getLexer(String input, CSVFormat format) {\n+    private Lexer getLexer(final String input, final CSVFormat format) {\n         return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n     }\n \n-    private void assertTokenEquals(Token.Type expectedType, String expectedContent, Token token) {\n+    private void assertTokenEquals(final Token.Type expectedType, final String expectedContent, final Token token) {\n         assertEquals(\"Token type\", expectedType, token.type);\n         assertEquals(\"Token content\", expectedContent, token.content.toString());\n     }\n     // Single line (without comment)\n     @Test\n     public void testNextToken1() throws IOException {\n-        String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n                 \"\\n\"+\n                 \"\\n\"+\n                 \"# Final comment\\n\";       // 7\n-        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n         assertTrue(\"Should ignore empty lines\", format.getIgnoreEmptyLines());\n \n-        Lexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n \n         assertTokenEquals(TOKEN, \"1\", parser.nextToken(new Token()));\n                 \"\\n\"+                      // 6b\n                 \"\\n\"+                      // 6c\n                 \"# Final comment\\n\";       // 7\n-        CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n-        Lexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n \n         assertTokenEquals(TOKEN, \"1\", parser.nextToken(new Token()));\n         /* file: a,\\,,b\n         *       \\,,\n         */\n-        String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n-        CSVFormat format = CSVFormat.DEFAULT;\n+        final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n+        final CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isEscaping());\n-        Lexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         // an unquoted single backslash is not an escape char\n         /* file: a,\\,,b\n         *       \\,,\n         */\n-        String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n-        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\').withIgnoreEmptyLines(false);\n+        final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\').withIgnoreEmptyLines(false);\n         assertTrue(format.isEscaping());\n-        Lexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \",\", parser.nextToken(new Token()));\n     // simple token with escaping enabled\n     @Test\n     public void testNextToken3BadEscaping() throws IOException {\n-        String code = \"a,b,c\\\\\";\n-        CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n+        final String code = \"a,b,c\\\\\";\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n         assertTrue(format.isEscaping());\n-        Lexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"b\", parser.nextToken(new Token()));\n         try {\n-            Token tkn = parser.nextToken(new Token());\n+            final Token tkn = parser.nextToken(new Token());\n             fail(\"Expected IOE, found \"+tkn);\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n         }\n     }\n \n         *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n         *        a,  \" foo \" ,b\n         */\n-        String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n     // encapsulator tokenizer (multi line, delimiter in string)\n     @Test\n     public void testNextToken5() throws IOException {\n-        String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-        Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        final String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\\n\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n         *       !comment;;;;\n         *       ;;\n         */\n-        String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withEncapsulator('\\'').withCommentStart('!');\n-        Lexer parser = getLexer(code, format);\n+        final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n+        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withEncapsulator('\\'').withCommentStart('!');\n+        final Lexer parser = getLexer(code, format);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n     }\n     // From CSV-1\n     @Test\n     public void testDelimiterIsWhitespace() throws IOException {\n-        String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        Lexer parser = getLexer(code, CSVFormat.TDF);\n+        final String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n+        final Lexer parser = getLexer(code, CSVFormat.TDF);\n         assertTokenEquals(TOKEN, \"one\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"two\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n-        for (String[] re : RESULT) {\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.getRecord().values());\n         }\n \n \n     @Test\n     public void testGetRecords() throws IOException {\n-        CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n         for (int i = 0; i < RESULT.length; i++) {\n \n     @Test\n     public void testExcelFormat1() throws IOException {\n-        String code =\n+        final String code =\n                 \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n                         + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"value1\", \"value2\", \"value3\", \"value4\"},\n                 {\"a\", \"b\", \"c\", \"d\"},\n                 {\"  x\", \"\", \"\", \"\"},\n                 {\"\"},\n                 {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n         };\n-        CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n \n     @Test\n     public void testExcelFormat2() throws Exception {\n-        String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n-        String[][] res = {\n+        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n+        final String[][] res = {\n                 {\"foo\", \"baar\"},\n                 {\"\"},\n                 {\"hello\", \"\"},\n                 {\"\"},\n                 {\"world\", \"\"}\n         };\n-        CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n \n     @Test\n     public void testEndOfFileBehaviourExcel() throws Exception {\n-        String[] codes = {\n+        final String[] codes = {\n                 \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n                 \"hello,\\r\\n\\r\\nworld,\",\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n         };\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"hello\", \"\"},\n                 {\"\"},  // Excel format does not ignore empty lines\n                 {\"world\", \"\"}\n         };\n \n-        for (String code : codes) {\n-            CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-            List<CSVRecord> records = parser.getRecords();\n+        for (final String code : codes) {\n+            final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+            final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n \n     @Test\n     public void testEndOfFileBehaviorCSV() throws Exception {\n-        String[] codes = {\n+        final String[] codes = {\n                 \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n                 \"hello,\\r\\n\\r\\nworld,\",\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n                 \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n         };\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"hello\", \"\"},  // CSV format ignores empty lines\n                 {\"world\", \"\"}\n         };\n-        for (String code : codes) {\n-            CSVParser parser = new CSVParser(new StringReader(code));\n-            List<CSVRecord> records = parser.getRecords();\n+        for (final String code : codes) {\n+            final CSVParser parser = new CSVParser(new StringReader(code));\n+            final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n \n     @Test\n     public void testEmptyLineBehaviourExcel() throws Exception {\n-        String[] codes = {\n+        final String[] codes = {\n                 \"hello,\\r\\n\\r\\n\\r\\n\",\n                 \"hello,\\n\\n\\n\",\n                 \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n                 \"hello,\\\"\\\"\\n\\n\\n\"\n         };\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"hello\", \"\"},\n                 {\"\"},  // Excel format does not ignore empty lines\n                 {\"\"}\n         };\n-        for (String code : codes) {\n-            CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n-            List<CSVRecord> records = parser.getRecords();\n+        for (final String code : codes) {\n+            final CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);\n+            final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n \n     @Test\n     public void testEmptyLineBehaviourCSV() throws Exception {\n-        String[] codes = {\n+        final String[] codes = {\n                 \"hello,\\r\\n\\r\\n\\r\\n\",\n                 \"hello,\\n\\n\\n\",\n                 \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n                 \"hello,\\\"\\\"\\n\\n\\n\"\n         };\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"hello\", \"\"}  // CSV format ignores empty lines\n         };\n-        for (String code : codes) {\n-            CSVParser parser = new CSVParser(new StringReader(code));\n-            List<CSVRecord> records = parser.getRecords();\n+        for (final String code : codes) {\n+            final CSVParser parser = new CSVParser(new StringReader(code));\n+            final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n \n     @Test\n     public void testEmptyFile() throws Exception {\n-        CSVParser parser = new CSVParser(\"\", CSVFormat.DEFAULT);\n+        final CSVParser parser = new CSVParser(\"\", CSVFormat.DEFAULT);\n         assertNull(parser.getRecord());\n     }\n \n     @Test\n     public void testCSV57() throws Exception {\n-        CSVParser parser = new CSVParser(\"\", CSVFormat.DEFAULT);\n-        List<CSVRecord> l = parser.getRecords();\n+        final CSVParser parser = new CSVParser(\"\", CSVFormat.DEFAULT);\n+        final List<CSVRecord> l = parser.getRecords();\n         assertNotNull(l);\n         assertEquals(0, l.size());\n     }\n     @Test\n     @Ignore\n     public void testBackslashEscapingOld() throws IOException {\n-        String code =\n+        final String code =\n                 \"one,two,three\\n\"\n                         + \"on\\\\\\\"e,two\\n\"\n                         + \"on\\\"e,two\\n\"\n                         + \"\\\"a\\\\\\\\\\\"\\n\"\n                         + \"a\\\\,b\\n\"\n                         + \"\\\"a\\\\\\\\,b\\\"\";\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"one\", \"two\", \"three\"},\n                 {\"on\\\\\\\"e\", \"two\"},\n                 {\"on\\\"e\", \"two\"},\n                 {\"a\\\\\", \"b\"},  // a backslash must be returnd\n                 {\"a\\\\\\\\,b\"}    // backslash in quotes only escapes a delimiter (\",\")\n         };\n-        CSVParser parser = new CSVParser(new StringReader(code));\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n         // We will test with a forward slash as the escape char, and a single\n         // quote as the encapsulator.\n \n-        String code =\n+        final String code =\n                 \"one,two,three\\n\" // 0\n                         + \"'',''\\n\"       // 1) empty encapsulators\n                         + \"/',/'\\n\"       // 2) single encapsulators\n                         + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n                         + \"9,   /\\n   \\n\"  // escaped newline\n                         + \"\";\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"one\", \"two\", \"three\"}, // 0\n                 {\"\", \"\"},                // 1\n                 {\"'\", \"'\"},              // 2\n         };\n \n \n-        CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\\'').withEscape('/')\n+        final CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEncapsulator('\\'').withEscape('/')\n                                .withIgnoreEmptyLines(true).withLineSeparator(CSVFormat.CRLF);\n \n-        CSVParser parser = new CSVParser(code, format);\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(code, format);\n+        final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n         for (int i = 0; i < res.length; i++) {\n             assertArrayEquals(res[i], records.get(i).values());\n         // We will test with a forward slash as the escape char, and a single\n         // quote as the encapsulator.\n \n-        String code = \"\"\n+        final String code = \"\"\n                 + \" , , \\n\"           // 1)\n                 + \" \\t ,  , \\n\"       // 2)\n                 + \" // , /, , /,\\n\"   // 3)\n                 + \"\";\n-        String[][] res = {\n+        final String[][] res = {\n                 {\" \", \" \", \" \"},         // 1\n                 {\" \\t \", \"  \", \" \"},     // 2\n                 {\" / \", \" , \", \" ,\"},    // 3\n         };\n \n \n-        CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEscape('/')\n+        final CSVFormat format = CSVFormat.PRISTINE.withDelimiter(',').withEscape('/')\n                 .withIgnoreEmptyLines(true).withLineSeparator(CSVFormat.CRLF);\n \n-        CSVParser parser = new CSVParser(code, format);\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(code, format);\n+        final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n \n         Utils.compare(\"\", res, records);\n \n     @Test\n     public void testDefaultFormat() throws IOException {\n-        String code = \"\"\n+        final String code = \"\"\n                 + \"a,b#\\n\"           // 1)\n                 + \"\\\"\\n\\\",\\\" \\\",#\\n\"   // 2)\n                 + \"#,\\\"\\\"\\n\"         // 3)\n                 + \"# Final comment\\n\"// 4)\n                 ;\n-        String[][] res = {\n+        final String[][] res = {\n                 {\"a\", \"b#\"},\n                 {\"\\n\", \" \", \"#\"},\n                 {\"#\", \"\"},\n \n         Utils.compare(\"Failed to parse without comments\", res, records);\n \n-        String[][] res_comments = {\n+        final String[][] res_comments = {\n                 {\"a\", \"b#\"},\n                 {\"\\n\", \" \", \"#\"},\n         };\n \n     @Test\n     public void testCarriageReturnLineFeedEndings() throws IOException {\n-        String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n-        CSVParser parser = new CSVParser(new StringReader(code));\n-        List<CSVRecord> records = parser.getRecords();\n+        final String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n \n     @Test\n     public void testCarriageReturnEndings() throws IOException {\n-        String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n-        CSVParser parser = new CSVParser(new StringReader(code));\n-        List<CSVRecord> records = parser.getRecords();\n+        final String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n \n     @Test\n     public void testLineFeedEndings() throws IOException {\n-        String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n-        CSVParser parser = new CSVParser(new StringReader(code));\n-        List<CSVRecord> records = parser.getRecords();\n+        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n     }\n \n     @Test\n     public void testIgnoreEmptyLines() throws IOException {\n-        String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n         //String code = \"world\\r\\n\\n\";\n         //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-        CSVParser parser = new CSVParser(new StringReader(code));\n-        List<CSVRecord> records = parser.getRecords();\n+        final CSVParser parser = new CSVParser(new StringReader(code));\n+        final List<CSVRecord> records = parser.getRecords();\n         assertEquals(3, records.size());\n     }\n \n     @Test\n     public void testForEach() throws Exception {\n-        List<CSVRecord> records = new ArrayList<CSVRecord>();\n-\n-        Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        for (CSVRecord record : CSVFormat.DEFAULT.parse(in)) {\n+        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n+\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) {\n             records.add(record);\n         }\n \n \n     @Test\n     public void testIterator() throws Exception {\n-        Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n \n         assertTrue(iterator.hasNext());\n         try {\n             iterator.remove();\n             fail(\"expected UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException expected) {\n+        } catch (final UnsupportedOperationException expected) {\n         }\n         assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values());\n         assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values());\n         try {\n             iterator.next();\n             fail(\"NoSuchElementException expected\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testHeader() throws Exception {\n-        Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n-            CSVRecord record = records.next();\n+            final CSVRecord record = records.next();\n             assertEquals(record.get(0), record.get(\"a\"));\n             assertEquals(record.get(1), record.get(\"b\"));\n             assertEquals(record.get(2), record.get(\"c\"));\n \n     @Test\n     public void testHeaderComment() throws Exception {\n-        Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n-\n-        Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n-            CSVRecord record = records.next();\n+            final CSVRecord record = records.next();\n             assertEquals(record.get(0), record.get(\"a\"));\n             assertEquals(record.get(1), record.get(\"b\"));\n             assertEquals(record.get(2), record.get(\"c\"));\n \n     @Test\n     public void testProvidedHeader() throws Exception {\n-        Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n \n         for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n-            CSVRecord record = records.next();\n+            final CSVRecord record = records.next();\n             assertTrue(record.isMapped(\"A\"));\n             assertTrue(record.isMapped(\"B\"));\n             assertTrue(record.isMapped(\"C\"));\n         Assert.assertEquals(\"A\", columnNames.next());\n         Assert.assertEquals(\"B\", columnNames.next());\n         Assert.assertEquals(\"C\", columnNames.next());\n-        Iterator<CSVRecord> records = parser.iterator();\n+        final Iterator<CSVRecord> records = parser.iterator();\n         \n         // Parse to make sure getHeaderMap did not have a side-effect.\n         for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n-            CSVRecord record = records.next();\n+            final CSVRecord record = records.next();\n             assertEquals(record.get(0), record.get(\"A\"));\n             assertEquals(record.get(1), record.get(\"B\"));\n             assertEquals(record.get(2), record.get(\"C\"));\n \n     @Test\n     public void testGetLineNumberWithLF() throws Exception {\n-        CSVParser parser = new CSVParser(\"a\\nb\\nc\", CSVFormat.DEFAULT.withLineSeparator(\"\\n\"));\n+        final CSVParser parser = new CSVParser(\"a\\nb\\nc\", CSVFormat.DEFAULT.withLineSeparator(\"\\n\"));\n \n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n \n     @Test\n     public void testGetLineNumberWithCRLF() throws Exception {\n-        CSVParser parser = new CSVParser(\"a\\r\\nb\\r\\nc\", CSVFormat.DEFAULT.withLineSeparator(CSVFormat.CRLF));\n+        final CSVParser parser = new CSVParser(\"a\\r\\nb\\r\\nc\", CSVFormat.DEFAULT.withLineSeparator(CSVFormat.CRLF));\n \n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n \n     @Test\n     public void testGetLineNumberWithCR() throws Exception {\n-        CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n+        final CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n \n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.getRecord());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n \n     @Test\n     public void testPrinter1() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a\", \"b\");\n         assertEquals(\"a,b\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrinter2() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a,b\", \"b\");\n         assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrinter3() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a, b\", \"b \");\n         assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrinter4() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a\", \"b\\\"c\");\n         assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrinter5() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a\", \"b\\nc\");\n         assertEquals(\"a,\\\"b\\nc\\\"\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrinter6() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a\", \"b\\r\\nc\");\n         assertEquals(\"a,\\\"b\\r\\nc\\\"\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrinter7() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a\", \"b\\\\c\");\n         assertEquals(\"a,b\\\\c\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testExcelPrinter1() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n         printer.println(\"a\", \"b\");\n         assertEquals(\"a,b\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testExcelPrinter2() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n         printer.println(\"a,b\", \"b\");\n         assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testPrintNullValues() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.println(\"a\", null, \"b\");\n         assertEquals(\"a,,b\" + lineSeparator, sw.toString());\n     }\n \n     @Test\n     public void testDisabledComment() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n         printer.printComment(\"This is a comment\");\n \n         assertEquals(\"\", sw.toString());\n \n     @Test\n     public void testSingleLineComment() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n         printer.printComment(\"This is a comment\");\n \n         assertEquals(\"# This is a comment\" + lineSeparator, sw.toString());\n \n     @Test\n     public void testMultiLineComment() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n         printer.printComment(\"This is a comment\\non multiple lines\");\n \n         assertEquals(\"# This is a comment\" + lineSeparator + \"# on multiple lines\" + lineSeparator, sw.toString());\n \n     @Test\n     public void testRandom() throws Exception {\n-        int iter = 10000;\n+        final int iter = 10000;\n         doRandom(CSVFormat.DEFAULT, iter);\n         doRandom(CSVFormat.EXCEL, iter);\n         doRandom(CSVFormat.MYSQL, iter);\n     }\n \n-    public void doRandom(CSVFormat format, int iter) throws Exception {\n+    public void doRandom(final CSVFormat format, final int iter) throws Exception {\n         for (int i = 0; i < iter; i++) {\n             doOneRandom(format);\n         }\n     }\n \n-    public void doOneRandom(CSVFormat format) throws Exception {\n-        Random r = new Random();\n-\n-        int nLines = r.nextInt(4) + 1;\n-        int nCol = r.nextInt(3) + 1;\n+    public void doOneRandom(final CSVFormat format) throws Exception {\n+        final Random r = new Random();\n+\n+        final int nLines = r.nextInt(4) + 1;\n+        final int nCol = r.nextInt(3) + 1;\n         // nLines=1;nCol=2;\n-        String[][] lines = new String[nLines][];\n+        final String[][] lines = new String[nLines][];\n         for (int i = 0; i < nLines; i++) {\n-            String[] line = new String[nCol];\n+            final String[] line = new String[nCol];\n             lines[i] = line;\n             for (int j = 0; j < nCol; j++) {\n                 line[j] = randStr();\n             }\n         }\n \n-        StringWriter sw = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(sw, format);\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n \n         for (int i = 0; i < nLines; i++) {\n             // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n         }\n \n         printer.flush();\n-        String result = sw.toString();\n+        final String result = sw.toString();\n         // System.out.println(\"### :\" + printable(result));\n \n-        CSVParser parser = new CSVParser(result, format);\n-        List<CSVRecord> parseResult = parser.getRecords();\n+        final CSVParser parser = new CSVParser(result, format);\n+        final List<CSVRecord> parseResult = parser.getRecords();\n \n         Utils.compare(\"Printer output :\" + printable(result), lines, parseResult);\n     }\n \n-    public static String printable(String s) {\n-        StringBuilder sb = new StringBuilder();\n+    public static String printable(final String s) {\n+        final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < s.length(); i++) {\n-            char ch = s.charAt(i);\n+            final char ch = s.charAt(i);\n             if (ch <= ' ' || ch >= 128) {\n                 sb.append(\"(\").append((int) ch).append(\")\");\n             } else {\n     }\n \n     public String randStr() {\n-        Random r = new Random();\n-\n-        int sz = r.nextInt(20);\n+        final Random r = new Random();\n+\n+        final int sz = r.nextInt(20);\n         // sz = r.nextInt(3);\n-        char[] buf = new char[sz];\n+        final char[] buf = new char[sz];\n         for (int i = 0; i < sz; i++) {\n             // stick in special chars with greater frequency\n             char ch;\n-            int what = r.nextInt(20);\n+            final int what = r.nextInt(20);\n             switch (what) {\n                 case 0:\n                     ch = '\\r';\n--- a/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n \n     @Test\n     public void testEmptyInput() throws Exception {\n-        ExtendedBufferedReader br = getBufferedReader(\"\");\n+        final ExtendedBufferedReader br = getBufferedReader(\"\");\n         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());\n \n     @Test\n     public void testReadLookahead1() throws Exception {\n-        ExtendedBufferedReader br = getBufferedReader(\"1\\n2\\r3\\n\");\n+        final ExtendedBufferedReader br = getBufferedReader(\"1\\n2\\r3\\n\");\n         assertEquals('1', br.lookAhead());\n         assertEquals(ExtendedBufferedReader.UNDEFINED, br.readAgain());\n         assertEquals('1', br.read());\n \n     @Test\n     public void testReadLookahead2() throws Exception {\n-        char[] ref = new char[5];\n-        char[] res = new char[5];\n+        final char[] ref = new char[5];\n+        final char[] res = new char[5];\n \n-        ExtendedBufferedReader br = getBufferedReader(\"abcdefg\");\n+        final ExtendedBufferedReader br = getBufferedReader(\"abcdefg\");\n         ref[0] = 'a';\n         ref[1] = 'b';\n         ref[2] = 'c';\n      */\n     @Test\n     public void testReadChar() throws Exception {\n-        String LF=\"\\n\"; String CR=\"\\r\"; String CRLF=CR+LF; String LFCR=LF+CR;// easier to read the string below\n-        String test=\"a\" + LF + \"b\" + CR + \"c\" + LF + LF + \"d\" + CR + CR + \"e\" + LFCR + \"f \"+ CRLF;\n+        final String LF=\"\\n\"; final String CR=\"\\r\"; final String CRLF=CR+LF; final String LFCR=LF+CR;// easier to read the string below\n+        final String test=\"a\" + LF + \"b\" + CR + \"c\" + LF + LF + \"d\" + CR + CR + \"e\" + LFCR + \"f \"+ CRLF;\n         //                EOL        eol        EOL  EOL        eol  eol        EOL+CR        EOL\n         final int EOLeolct=9;\n         ExtendedBufferedReader br;\n \n         br = getBufferedReader(test);\n         assertEquals(0, br.getLineNumber());\n-        char[] buff = new char[10];\n+        final char[] buff = new char[10];\n         while(br.read(buff ,0, 3)!=-1) {}\n         assertEquals(EOLeolct, br.getLineNumber());\n     }\n \n-    private ExtendedBufferedReader getBufferedReader(String s) {\n+    private ExtendedBufferedReader getBufferedReader(final String s) {\n         return new ExtendedBufferedReader(new StringReader(s));\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n \n     private static final CSVFormat format = CSVFormat.EXCEL;\n \n-    public static void main(String [] args) throws Exception {\n+    public static void main(final String [] args) throws Exception {\n         final int argc = args.length;\n         String tests[];\n         if (argc > 0) {\n         } else {\n             tests=new String[]{\"file\", \"split\", \"extb\", \"exts\", \"csv\", \"lexreset\", \"lexnew\"};\n         }\n-        for(String p : PROPS) {\n+        for(final String p : PROPS) {\n             System.out.println(p+\"=\"+System.getProperty(p));\n         }\n         System.out.println(\"Max count: \"+max+\"\\n\");\n \n-        for(String test : tests) {\n+        for(final String test : tests) {\n             if (\"file\".equals(test)) {\n                 testReadBigFile(false);\n             } else if (\"split\".equals(test)) {\n     private static class Stats {\n         final int count;\n         final int fields;\n-        Stats(int c, int f) {\n+        Stats(final int c, final int f) {\n             count=c;\n             fields=f;\n         }\n     }\n \n     // Display end stats; store elapsed for average\n-    private static void show(String msg, Stats s, long start) {\n+    private static void show(final String msg, final Stats s, final long start) {\n         final long elapsed = System.currentTimeMillis() - start;\n         System.out.printf(\"%-20s: %5dms \" + s.count + \" lines \"+ s.fields + \" fields%n\",msg,elapsed);\n         elapsedTimes[num++]=elapsed;\n         num=0; // ready for next set\n     }\n \n-    private static void testReadBigFile(boolean split) throws Exception {\n-       for (int i = 0; i < max; i++) {\n-           BufferedReader in = getReader();\n-           long t0 = System.currentTimeMillis();\n-           Stats s = readAll(in, split);\n+    private static void testReadBigFile(final boolean split) throws Exception {\n+       for (int i = 0; i < max; i++) {\n+           final BufferedReader in = getReader();\n+           final long t0 = System.currentTimeMillis();\n+           final Stats s = readAll(in, split);\n            in.close();\n            show(split?\"file+split\":\"file\", s, t0);\n        }\n        show();\n    }\n \n-   private static Stats readAll(BufferedReader in, boolean split) throws IOException {\n+   private static Stats readAll(final BufferedReader in, final boolean split) throws IOException {\n        int count = 0;\n        int fields = 0;\n        String record;\n        return new Stats(count, fields);\n    }\n \n-   private static void testExtendedBuffer(boolean makeString) throws Exception {\n-       for (int i = 0; i < max; i++) {\n-           ExtendedBufferedReader in = new ExtendedBufferedReader(getReader());\n-           long t0 = System.currentTimeMillis();\n+   private static void testExtendedBuffer(final boolean makeString) throws Exception {\n+       for (int i = 0; i < max; i++) {\n+           final ExtendedBufferedReader in = new ExtendedBufferedReader(getReader());\n+           final long t0 = System.currentTimeMillis();\n            int read;\n            int fields = 0;\n            int lines = 0;\n    private static void testParseCommonsCSV() throws Exception {\n        for (int i = 0; i < max; i++) {\n            final BufferedReader reader = getReader();\n-           CSVParser parser = new CSVParser(reader, format);\n-           long t0 = System.currentTimeMillis();\n-           Stats s = iterate(parser);\n+           final CSVParser parser = new CSVParser(reader, format);\n+           final long t0 = System.currentTimeMillis();\n+           final Stats s = iterate(parser);\n            reader.close();\n            show(\"CSV\", s, t0);\n        }\n    }\n \n \n-   private static Constructor<Lexer> getLexerCtor(String clazz) throws Exception {\n+   private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\n        @SuppressWarnings(\"unchecked\")\n+    final\n        Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\"+clazz);\n-       Constructor<Lexer> ctor = lexer.getConstructor(new Class<?>[]{CSVFormat.class, ExtendedBufferedReader.class});\n+       final Constructor<Lexer> ctor = lexer.getConstructor(new Class<?>[]{CSVFormat.class, ExtendedBufferedReader.class});\n        return ctor;\n    }\n \n-   private static void testCSVLexer(final boolean newToken, String test) throws Exception {\n+   private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\n        Token token = new Token();\n        String dynamic = \"\";\n        for (int i = 0; i < max; i++) {\n            }\n            int count = 0;\n            int fields = 0;\n-           long t0 = System.currentTimeMillis();\n+           final long t0 = System.currentTimeMillis();\n            do {\n                if (newToken) {\n                    token = new Token();\n               }\n \n            } while (!token.type.equals(Token.Type.EOF));\n-           Stats s = new Stats(count, fields);\n+           final Stats s = new Stats(count, fields);\n            input.close();\n            show(lexer.getClass().getSimpleName()+dynamic+\" \"+(newToken ? \"new\" : \"reset\"), s, t0);\n        }\n        show();\n    }\n \n-   private static Stats iterate(Iterable<CSVRecord> it) {\n+   private static Stats iterate(final Iterable<CSVRecord> it) {\n        int count = 0;\n        int fields = 0;\n-       for (CSVRecord record : it) {\n+       for (final CSVRecord record : it) {\n            count++;\n            fields+=record.size();\n        }\n--- a/src/test/java/org/apache/commons/csv/Utils.java\n+++ b/src/test/java/org/apache/commons/csv/Utils.java\n      * @param expected the 2d array of expected results\n      * @param actual the 2d array of actual results\n      */\n-    public static void compare(String message, String[][] expected, String[][] actual) {\n+    public static void compare(final String message, final String[][] expected, final String[][] actual) {\n         Assert.assertEquals(message+\"  - outer array size\", expected.length, actual.length);\n         for(int i = 0; i < expected.length; i++) {\n             Assert.assertArrayEquals(message+\" (entry \"+i+\")\",expected[i], actual[i]);\n      * @param expected the 2d array of expected results\n      * @param actual the List of {@link CSVRecord} entries, each containing an array of values\n      */\n-    public static void compare(String message, String[][] expected, List<CSVRecord> actual) {\n+    public static void compare(final String message, final String[][] expected, final List<CSVRecord> actual) {\n         Assert.assertEquals(message+\"  - outer array size\", expected.length, actual.size());\n         for(int i = 0; i < expected.length; i++) {\n             Assert.assertArrayEquals(message+\" (entry \"+i+\")\",expected[i], actual.get(i).values());", "timestamp": 1349970464, "metainfo": ""}