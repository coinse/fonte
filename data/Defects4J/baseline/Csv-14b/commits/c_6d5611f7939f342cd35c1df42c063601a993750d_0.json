{"sha": "6d5611f7939f342cd35c1df42c063601a993750d", "log": "Use final.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      *             If there is a problem reading the header or skipping the first record\n      * @since 1.1\n      */\n-    public CSVParser(final Reader reader, final CSVFormat format, long characterOffset, long recordNumber)\n+    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n             throws IOException {\n         Assertions.notNull(reader, \"reader\");\n         Assertions.notNull(format, \"format\");\n      */\n     public List<CSVRecord> getRecords() throws IOException {\n         CSVRecord rec;\n-        List<CSVRecord> records = new ArrayList<CSVRecord>();\n+        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n         while ((rec = this.nextRecord()) != null) {\n             records.add(rec);\n         }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n         // It seems a pain to have to track whether the header has already been printed or not.\n         if (format.getHeaderComments() != null) {\n-            for (String line : format.getHeaderComments()) {\n+            for (final String line : format.getHeaderComments()) {\n                 if (line != null) {\n                     this.printComment(line);\n                 }\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n     private final String[] values;\n \n     CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber,\n-            long characterPosition) {\n+            final long characterPosition) {\n         this.recordNumber = recordNumber;\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n--- a/src/test/java/org/apache/commons/csv/CSVBenchmark.java\n+++ b/src/test/java/org/apache/commons/csv/CSVBenchmark.java\n      */\n     @Setup\n     public void init() throws IOException {\n-        File file = new File(\"src/test/resources/perf/worldcitiespop.txt.gz\");\n-        InputStream in = new GZIPInputStream(new FileInputStream(file));\n+        final File file = new File(\"src/test/resources/perf/worldcitiespop.txt.gz\");\n+        final InputStream in = new GZIPInputStream(new FileInputStream(file));\n         this.data = IOUtils.toString(in, \"ISO-8859-1\");\n         in.close();\n     }\n     }\n \n     @Benchmark\n-    public int read(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n+    public int read(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n         int count = 0;\n         String line;\n         while ((line = in.readLine()) != null) {\n     }\n \n     @Benchmark\n-    public int split(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n+    public int split(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n         int count = 0;\n         String line;\n         while ((line = in.readLine()) != null) {\n-            String[] values = StringUtils.split(line, ',');\n+            final String[] values = StringUtils.split(line, ',');\n             count += values.length;\n         }\n         \n     }\n \n     @Benchmark\n-    public int parseCommonsCSV(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n-        \n-        CSVFormat format = CSVFormat.DEFAULT.withHeader();\n-\n-        int count = 0;\n-        for (CSVRecord record : format.parse(in)) {\n-            count++;\n-        }\n-\n-        bh.consume(count);\n-        in.close();\n-        return count;\n-    }\n-\n-    @Benchmark\n-    public int parseGenJavaCSV(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n-        \n-        CsvReader reader = new CsvReader(in);\n+    public int parseCommonsCSV(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n+        \n+        final CSVFormat format = CSVFormat.DEFAULT.withHeader();\n+\n+        int count = 0;\n+        for (final CSVRecord record : format.parse(in)) {\n+            count++;\n+        }\n+\n+        bh.consume(count);\n+        in.close();\n+        return count;\n+    }\n+\n+    @Benchmark\n+    public int parseGenJavaCSV(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n+        \n+        final CsvReader reader = new CsvReader(in);\n         reader.setFieldDelimiter(',');\n \n         int count = 0;\n     }\n \n     @Benchmark\n-    public int parseJavaCSV(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n-        \n-        com.csvreader.CsvReader reader = new com.csvreader.CsvReader(in, ',');\n+    public int parseJavaCSV(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n+        \n+        final com.csvreader.CsvReader reader = new com.csvreader.CsvReader(in, ',');\n         reader.setRecordDelimiter('\\n');\n \n         int count = 0;\n     }\n \n     @Benchmark\n-    public int parseOpenCSV(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n-        \n-        com.opencsv.CSVReader reader = new com.opencsv.CSVReader(in, ',');\n+    public int parseOpenCSV(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n+        \n+        final com.opencsv.CSVReader reader = new com.opencsv.CSVReader(in, ',');\n \n         int count = 0;\n         while (reader.readNext() != null) {\n     }\n \n     @Benchmark\n-    public int parseSkifeCSV(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n-        \n-        org.skife.csv.CSVReader reader = new org.skife.csv.SimpleReader();\n+    public int parseSkifeCSV(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n+        \n+        final org.skife.csv.CSVReader reader = new org.skife.csv.SimpleReader();\n         reader.setSeperator(',');\n         \n-        CountingReaderCallback callback = new CountingReaderCallback();\n+        final CountingReaderCallback callback = new CountingReaderCallback();\n         reader.parse(in, callback);\n \n         bh.consume(callback);\n         public int count = 0;\n \n         @Override\n-        public void onRow(String[] fields) {\n-            count++;\n-        }\n-    }\n-\n-    @Benchmark\n-    public int parseSuperCSV(Blackhole bh) throws Exception {\n-        BufferedReader in = getReader();\n-        \n-        CsvListReader reader = new CsvListReader(in, CsvPreference.STANDARD_PREFERENCE);\n+        public void onRow(final String[] fields) {\n+            count++;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int parseSuperCSV(final Blackhole bh) throws Exception {\n+        final BufferedReader in = getReader();\n+        \n+        final CsvListReader reader = new CsvListReader(in, CsvPreference.STANDARD_PREFERENCE);\n \n         int count = 0;\n         List<String> record = null;\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n         final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());\n         try {\n-            for (CSVRecord record : parser.getRecords()) {\n+            for (final CSVRecord record : parser.getRecords()) {\n                 Assert.assertEquals(\"a\", record.get(\"A\"));\n                 Assert.assertEquals(\"b\", record.get(\"B\"));\n                 Assert.assertEquals(\"c\", record.get(\"C\"));\n     private void validateRecordPosition(final String lineSeparator) throws IOException {\n         final String nl = lineSeparator; // used as linebreak in values for better distinction\n \n-        String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n+        final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n         // to see if recordPosition correctly points to the enclosing quote\n                 \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\n                 // unicode test... not very relevant while operating on strings instead of bytes, but for\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n     }\n \n     private void setUpTable(final Connection connection) throws SQLException {\n-        Statement statement = connection.createStatement();\n+        final Statement statement = connection.createStatement();\n         try {\n             statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n             statement.execute(\"insert into TEST values(1, 'r1')\");", "timestamp": 1439240938, "metainfo": ""}