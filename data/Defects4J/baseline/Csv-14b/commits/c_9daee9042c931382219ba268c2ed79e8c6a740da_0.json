{"sha": "9daee9042c931382219ba268c2ed79e8c6a740da", "log": "Use try-with-resources.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      */\n     public String format(final Object... values) {\n         final StringWriter out = new StringWriter();\n-        try {\n-            new CSVPrinter(out, this).printRecord(values);\n+        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n+            csvPrinter.printRecord(values);\n             return out.toString().trim();\n         } catch (final IOException e) {\n             // should not happen because a StringWriter does not do IO.\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n \n         // Now parse the file and compare against the expected results\n         // We use a buffered reader internally so no need to create one here.\n-        final CSVParser parser = CSVParser.parse(new File(BASE, split[0]), Charset.defaultCharset(), format);\n-        for (final CSVRecord record : parser) {\n-            String parsed = Arrays.toString(record.values());\n-            if (checkComments) {\n-                final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n-                if (comment != null) {\n-                    parsed += \"#\" + comment;\n+        try (final CSVParser parser = CSVParser.parse(new File(BASE, split[0]), Charset.defaultCharset(), format)) {\n+            for (final CSVRecord record : parser) {\n+                String parsed = Arrays.toString(record.values());\n+                if (checkComments) {\n+                    final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n+                    if (comment != null) {\n+                        parsed += \"#\" + comment;\n+                    }\n                 }\n+                final int count = record.size();\n+                assertEquals(testName, readTestData(), count + \":\" + parsed);\n             }\n-            final int count = record.size();\n-            assertEquals(testName, readTestData(), count + \":\" + parsed);\n         }\n-        parser.close();\n     }\n \n     @Test\n \n         // Now parse the file and compare against the expected results\n         final URL resource = ClassLoader.getSystemResource(\"CSVFileParser/\" + split[0]);\n-        final CSVParser parser = CSVParser.parse(resource, Charset.forName(\"UTF-8\"), format);\n-        for (final CSVRecord record : parser) {\n-            String parsed = Arrays.toString(record.values());\n-            if (checkComments) {\n-                final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n-                if (comment != null) {\n-                    parsed += \"#\" + comment;\n+        try (final CSVParser parser = CSVParser.parse(resource, Charset.forName(\"UTF-8\"), format)) {\n+            for (final CSVRecord record : parser) {\n+                String parsed = Arrays.toString(record.values());\n+                if (checkComments) {\n+                    final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n+                    if (comment != null) {\n+                        parsed += \"#\" + comment;\n+                    }\n                 }\n+                final int count = record.size();\n+                assertEquals(testName, readTestData(), count + \":\" + parsed);\n             }\n-            final int count = record.size();\n-            assertEquals(testName, readTestData(), count + \":\" + parsed);\n         }\n-        parser.close();\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n     public void testSerialization() throws Exception {\n         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n \n-        final ObjectOutputStream oos = new ObjectOutputStream(out);\n-        oos.writeObject(CSVFormat.DEFAULT);\n-        oos.flush();\n-        oos.close();\n+        try (final ObjectOutputStream oos = new ObjectOutputStream(out)) {\n+            oos.writeObject(CSVFormat.DEFAULT);\n+            oos.flush();\n+        }\n \n         final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));\n         final CSVFormat format = (CSVFormat) in.readObject();\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n public class CSVParserTest {\n \n     private static final String CSV_INPUT = \"a,b,c,d\\n\" + \" a , b , 1 2 \\n\" + \"\\\"foo baar\\\", b,\\n\"\n-    // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+            // + \" \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n             + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"; // changed to use standard CSV escaping\n \n     private static final String CSV_INPUT_1 = \"a,b,c,d\";\n         // quote as the encapsulator.\n \n         final String code = \"one,two,three\\n\" // 0\n-                + \"'',''\\n\" // 1) empty encapsulators\n+        + \"'',''\\n\" // 1) empty encapsulators\n                 + \"/',/'\\n\" // 2) single encapsulators\n                 + \"'/'','/''\\n\" // 3) single encapsulators encapsulated via escape\n                 + \"'''',''''\\n\" // 4) single encapsulators encapsulated via doubling\n         final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/')\n                 .withIgnoreEmptyLines();\n \n-        final CSVParser parser = CSVParser.parse(code, format);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertTrue(records.size() > 0);\n-\n-        Utils.compare(\"Records do not match expected result\", res, records);\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertTrue(records.size() > 0);\n+\n+            Utils.compare(\"Records do not match expected result\", res, records);\n+        }\n     }\n \n     @Test\n         final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/')\n                 .withIgnoreEmptyLines();\n \n-        final CSVParser parser = CSVParser.parse(code, format);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertTrue(records.size() > 0);\n-\n-        Utils.compare(\"\", res, records);\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, format)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertTrue(records.size() > 0);\n+\n+            Utils.compare(\"\", res, records);\n+        }\n     }\n \n     @Test\n     @Ignore\n     public void testBackslashEscapingOld() throws IOException {\n-        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\"\n-                + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" + \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\n+        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\" +\n+                \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" + \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\n         final String[][] res = { { \"one\", \"two\", \"three\" }, { \"on\\\\\\\"e\", \"two\" }, { \"on\\\"e\", \"two\" },\n                 { \"one\", \"tw\\\"o\" }, { \"one\", \"t\\\\,wo\" }, // backslash in quotes only escapes a delimiter (\",\")\n                 { \"one\", \"two\", \"th,ree\" }, { \"a\\\\\\\\\" }, // backslash in quotes only escapes a delimiter (\",\")\n                 { \"a\\\\\", \"b\" }, // a backslash must be returnd\n                 { \"a\\\\\\\\,b\" } // backslash in quotes only escapes a delimiter (\",\")\n         };\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(res.length, records.size());\n-        assertTrue(records.size() > 0);\n-        for (int i = 0; i < res.length; i++) {\n-            assertArrayEquals(res[i], records.get(i).values());\n-        }\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n     }\n \n     @Test\n     @Ignore(\"CSV-107\")\n     public void testBOM() throws IOException {\n         final URL url = ClassLoader.getSystemClassLoader().getResource(\"CSVFileParser/bom.csv\");\n-        final CSVParser parser = CSVParser.parse(url, Charset.forName(\"UTF-8\"), CSVFormat.EXCEL.withHeader());\n-        try {\n+        try (final CSVParser parser = CSVParser.parse(url, Charset.forName(\"UTF-8\"), CSVFormat.EXCEL.withHeader())) {\n             for (final CSVRecord record : parser) {\n                 final String string = record.get(\"Date\");\n                 Assert.assertNotNull(string);\n                 // System.out.println(\"date: \" + record.get(\"Date\"));\n             }\n-        } finally {\n-            parser.close();\n         }\n     }\n \n     @Test\n     public void testBOMInputStream() throws IOException {\n         final URL url = ClassLoader.getSystemClassLoader().getResource(\"CSVFileParser/bom.csv\");\n-        final Reader reader = new InputStreamReader(new BOMInputStream(url.openStream()), \"UTF-8\");\n-        final CSVParser parser = new CSVParser(reader, CSVFormat.EXCEL.withHeader());\n-        try {\n+        try (final Reader reader = new InputStreamReader(new BOMInputStream(url.openStream()), \"UTF-8\");\n+                final CSVParser parser = new CSVParser(reader, CSVFormat.EXCEL.withHeader())) {\n             for (final CSVRecord record : parser) {\n                 final String string = record.get(\"Date\");\n                 Assert.assertNotNull(string);\n                 // System.out.println(\"date: \" + record.get(\"Date\"));\n             }\n-        } finally {\n-            parser.close();\n-            reader.close();\n         }\n     }\n \n     @Test\n     public void testCarriageReturnEndings() throws IOException {\n         final String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(4, records.size());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n     }\n \n     @Test\n     public void testCarriageReturnLineFeedEndings() throws IOException {\n         final String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(4, records.size());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n     }\n \n     @Test(expected = NoSuchElementException.class)\n     public void testClose() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n-        final CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in);\n-        final Iterator<CSVRecord> records = parser.iterator();\n-        assertTrue(records.hasNext());\n-        parser.close();\n+        final Iterator<CSVRecord> records;\n+        try (final CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in)) {\n+            records = parser.iterator();\n+            assertTrue(records.hasNext());\n+        }\n         assertFalse(records.hasNext());\n         records.next();\n     }\n \n     @Test\n     public void testCSV57() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n-        final List<CSVRecord> list = parser.getRecords();\n-        assertNotNull(list);\n-        assertEquals(0, list.size());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> list = parser.getRecords();\n+            assertNotNull(list);\n+            assertEquals(0, list.size());\n+        }\n     }\n \n     @Test\n                 + \"\\\"\\n\\\",\\\" \\\",#\\n\" // 2)\n                 + \"#,\\\"\\\"\\n\" // 3)\n                 + \"# Final comment\\n\"// 4)\n-        ;\n+                ;\n         final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\n \n         CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isCommentMarkerSet());\n-\n-        CSVParser parser = CSVParser.parse(code, format);\n-        List<CSVRecord> records = parser.getRecords();\n-        assertTrue(records.size() > 0);\n-\n-        Utils.compare(\"Failed to parse without comments\", res, records);\n-\n         final String[][] res_comments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, };\n \n-        format = CSVFormat.DEFAULT.withCommentMarker('#');\n-        parser.close();\n-        parser = CSVParser.parse(code, format);\n-        records = parser.getRecords();\n-\n-        Utils.compare(\"Failed to parse with comments\", res_comments, records);\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, format)) {\n+            List<CSVRecord> records = parser.getRecords();\n+            assertTrue(records.size() > 0);\n+\n+            Utils.compare(\"Failed to parse without comments\", res, records);\n+\n+            format = CSVFormat.DEFAULT.withCommentMarker('#');\n+        }\n+        try (final CSVParser parser = CSVParser.parse(code, format)) {\n+            List<CSVRecord> records = parser.getRecords();\n+\n+            Utils.compare(\"Failed to parse with comments\", res_comments, records);\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n \n     @Test\n     public void testEmptyFile() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n-        assertNull(parser.nextRecord());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT)) {\n+            assertNull(parser.nextRecord());\n+        }\n     }\n \n     @Test\n         final String[][] res = { { \"hello\", \"\" } // CSV format ignores empty lines\n         };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-            parser.close();\n+            try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertTrue(records.size() > 0);\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n         }\n     }\n \n         final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n                 { \"\" } };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-            parser.close();\n+            try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertTrue(records.size() > 0);\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n         }\n     }\n \n         final String[][] res = { { \"hello\", \"\" }, // CSV format ignores empty lines\n                 { \"world\", \"\" } };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-            parser.close();\n+            try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertTrue(records.size() > 0);\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n         }\n     }\n \n                 { \"world\", \"\" } };\n \n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+            try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertTrue(records.size() > 0);\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat1() throws IOException {\n+        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\" +\n+                \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n+        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" },\n+                { \"  x\", \"\", \"\", \"\" }, { \"\" }, { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(res.length, records.size());\n             assertTrue(records.size() > 0);\n             for (int i = 0; i < res.length; i++) {\n                 assertArrayEquals(res[i], records.get(i).values());\n             }\n-            parser.close();\n-        }\n-    }\n-\n-    @Test\n-    public void testExcelFormat1() throws IOException {\n-        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n-                + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n-        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" },\n-                { \"  x\", \"\", \"\", \"\" }, { \"\" }, { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(res.length, records.size());\n-        assertTrue(records.size() > 0);\n-        for (int i = 0; i < res.length; i++) {\n-            assertArrayEquals(res[i], records.get(i).values());\n-        }\n-        parser.close();\n+        }\n     }\n \n     @Test\n     public void testExcelFormat2() throws Exception {\n         final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n         final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(res.length, records.size());\n-        assertTrue(records.size() > 0);\n-        for (int i = 0; i < res.length; i++) {\n-            assertArrayEquals(res[i], records.get(i).values());\n-        }\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n     }\n \n     /**\n     @Test\n     public void testExcelHeaderCountLessThanData() throws Exception {\n         final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());\n-        try {\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader())) {\n             for (final CSVRecord record : parser.getRecords()) {\n                 Assert.assertEquals(\"a\", record.get(\"A\"));\n                 Assert.assertEquals(\"b\", record.get(\"B\"));\n                 Assert.assertEquals(\"c\", record.get(\"C\"));\n             }\n-        } finally {\n-            parser.close();\n         }\n     }\n \n     @Test\n     public void testForEach() throws Exception {\n         final List<CSVRecord> records = new ArrayList<>();\n-\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) {\n-            records.add(record);\n-        }\n-\n-        assertEquals(3, records.size());\n-        assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\n-        assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\n-        assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\n+        try (final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\")) {\n+            for (final CSVRecord record : CSVFormat.DEFAULT.parse(in)) {\n+                records.add(record);\n+            }\n+            assertEquals(3, records.size());\n+            assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\n+            assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\n+            assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\n+        }\n     }\n \n     @Test\n     public void testGetHeaderMap() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n-        final Map<String, Integer> headerMap = parser.getHeaderMap();\n-        final Iterator<String> columnNames = headerMap.keySet().iterator();\n-        // Headers are iterated in column order.\n-        Assert.assertEquals(\"A\", columnNames.next());\n-        Assert.assertEquals(\"B\", columnNames.next());\n-        Assert.assertEquals(\"C\", columnNames.next());\n-        final Iterator<CSVRecord> records = parser.iterator();\n-\n-        // Parse to make sure getHeaderMap did not have a side-effect.\n-        for (int i = 0; i < 3; i++) {\n-            assertTrue(records.hasNext());\n-            final CSVRecord record = records.next();\n-            assertEquals(record.get(0), record.get(\"A\"));\n-            assertEquals(record.get(1), record.get(\"B\"));\n-            assertEquals(record.get(2), record.get(\"C\"));\n-        }\n-\n-        assertFalse(records.hasNext());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\",\n+                CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final Map<String, Integer> headerMap = parser.getHeaderMap();\n+            final Iterator<String> columnNames = headerMap.keySet().iterator();\n+            // Headers are iterated in column order.\n+            Assert.assertEquals(\"A\", columnNames.next());\n+            Assert.assertEquals(\"B\", columnNames.next());\n+            Assert.assertEquals(\"C\", columnNames.next());\n+            final Iterator<CSVRecord> records = parser.iterator();\n+\n+            // Parse to make sure getHeaderMap did not have a side-effect.\n+            for (int i = 0; i < 3; i++) {\n+                assertTrue(records.hasNext());\n+                final CSVRecord record = records.next();\n+                assertEquals(record.get(0), record.get(\"A\"));\n+                assertEquals(record.get(1), record.get(\"B\"));\n+                assertEquals(record.get(2), record.get(\"C\"));\n+            }\n+\n+            assertFalse(records.hasNext());\n+        }\n     }\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n-        for (final String[] re : RESULT) {\n-            assertArrayEquals(re, parser.nextRecord().values());\n-        }\n-\n-        assertNull(parser.nextRecord());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            for (final String[] re : RESULT) {\n+                assertArrayEquals(re, parser.nextRecord().values());\n+            }\n+\n+            assertNull(parser.nextRecord());\n+        }\n     }\n \n     @Test\n \n     @Test\n     public void testGetOneLine() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT);\n-        final CSVRecord record = parser.getRecords().get(0);\n-        assertArrayEquals(RESULT[0], record.values());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(CSV_INPUT_1, CSVFormat.DEFAULT)) {\n+            final CSVRecord record = parser.getRecords().get(0);\n+            assertArrayEquals(RESULT[0], record.values());\n+        }\n     }\n \n     /**\n      */\n     @Test\n     public void testGetOneLineOneParser() throws IOException {\n-        final PipedWriter writer = new PipedWriter();\n-        final PipedReader reader = new PipedReader(writer);\n         final CSVFormat format = CSVFormat.DEFAULT;\n-        final CSVParser parser = new CSVParser(reader, format);\n-        try {\n+        try (final PipedWriter writer = new PipedWriter();\n+                final CSVParser parser = new CSVParser(new PipedReader(writer), format)) {\n             writer.append(CSV_INPUT_1);\n             writer.append(format.getRecordSeparator());\n             final CSVRecord record1 = parser.nextRecord();\n             writer.append(format.getRecordSeparator());\n             final CSVRecord record2 = parser.nextRecord();\n             assertArrayEquals(RESULT[1], record2.values());\n-        } finally {\n-            parser.close();\n         }\n     }\n \n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(RESULT.length, records.size());\n-        assertTrue(records.size() > 0);\n-        for (int i = 0; i < RESULT.length; i++) {\n-            assertArrayEquals(RESULT[i], records.get(i).values());\n-        }\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(CSV_INPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(RESULT.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < RESULT.length; i++) {\n+                assertArrayEquals(RESULT[i], records.get(i).values());\n+            }\n+        }\n     }\n \n     @Test\n     public void testGetRecordWithMultiLineValues() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF +\n-                \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\", CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n-        CSVRecord record;\n-        assertEquals(0, parser.getRecordNumber());\n-        assertEquals(0, parser.getCurrentLineNumber());\n-        assertNotNull(record = parser.nextRecord());\n-        assertEquals(3, parser.getCurrentLineNumber());\n-        assertEquals(1, record.getRecordNumber());\n-        assertEquals(1, parser.getRecordNumber());\n-        assertNotNull(record = parser.nextRecord());\n-        assertEquals(6, parser.getCurrentLineNumber());\n-        assertEquals(2, record.getRecordNumber());\n-        assertEquals(2, parser.getRecordNumber());\n-        assertNotNull(record = parser.nextRecord());\n-        assertEquals(8, parser.getCurrentLineNumber());\n-        assertEquals(3, record.getRecordNumber());\n-        assertEquals(3, parser.getRecordNumber());\n-        assertNull(record = parser.nextRecord());\n-        assertEquals(8, parser.getCurrentLineNumber());\n-        assertEquals(3, parser.getRecordNumber());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\n+                \"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n+                CSVFormat.DEFAULT.withRecordSeparator(CRLF))) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            assertEquals(0, parser.getCurrentLineNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, parser.getCurrentLineNumber());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(1, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(6, parser.getCurrentLineNumber());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(2, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(8, parser.getCurrentLineNumber());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+            assertNull(record = parser.nextRecord());\n+            assertEquals(8, parser.getCurrentLineNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+        }\n     }\n \n     @Test\n         final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n         // String code = \"world\\r\\n\\n\";\n         // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(3, records.size());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(3, records.size());\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testInvalidFormat() throws Exception {\n         final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n-        new CSVParser(null, invalidFormat).close();\n+        try (final CSVParser parser = new CSVParser(null, invalidFormat)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test\n     @Test\n     public void testLineFeedEndings() throws IOException {\n         final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(4, records.size());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+        }\n     }\n \n     @Test\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord()\n-                .parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord().parse(in)\n+                .iterator();\n         CSVRecord record;\n \n         // 1st record\n     @Test\n     // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n     public void testMultipleIterators() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"a,b,c\" + CR + \"d,e,f\", CSVFormat.DEFAULT);\n-\n-        final Iterator<CSVRecord> itr1 = parser.iterator();\n-        final Iterator<CSVRecord> itr2 = parser.iterator();\n-\n-        final CSVRecord first = itr1.next();\n-        assertEquals(\"a\", first.get(0));\n-        assertEquals(\"b\", first.get(1));\n-        assertEquals(\"c\", first.get(2));\n-\n-        final CSVRecord second = itr2.next();\n-        assertEquals(\"d\", second.get(0));\n-        assertEquals(\"e\", second.get(1));\n-        assertEquals(\"f\", second.get(2));\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"a,b,c\" + CR + \"d,e,f\", CSVFormat.DEFAULT)) {\n+            final Iterator<CSVRecord> itr1 = parser.iterator();\n+            final Iterator<CSVRecord> itr2 = parser.iterator();\n+\n+            final CSVRecord first = itr1.next();\n+            assertEquals(\"a\", first.get(0));\n+            assertEquals(\"b\", first.get(1));\n+            assertEquals(\"c\", first.get(2));\n+\n+            final CSVRecord second = itr2.next();\n+            assertEquals(\"d\", second.get(0));\n+            assertEquals(\"e\", second.get(1));\n+            assertEquals(\"f\", second.get(2));\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testNewCSVParserNullReaderFormat() throws Exception {\n-        new CSVParser(null, CSVFormat.DEFAULT).close();\n+        try (final CSVParser parser = new CSVParser(null, CSVFormat.DEFAULT)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testNewCSVParserReaderNullFormat() throws Exception {\n-        new CSVParser(new StringReader(\"\"), null).close();\n+        try (final CSVParser parser = new CSVParser(new StringReader(\"\"), null)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test\n     public void testNoHeaderMap() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n-        Assert.assertNull(parser.getHeaderMap());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT)) {\n+            Assert.assertNull(parser.getHeaderMap());\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testParserUrlNullCharsetFormat() throws Exception {\n-        final CSVParser parser = CSVParser.parse(new URL(\"http://commons.apache.org\"), null, CSVFormat.DEFAULT);\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(new URL(\"http://commons.apache.org\"), null, CSVFormat.DEFAULT)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testParseUrlCharsetNullFormat() throws Exception {\n-        final CSVParser parser = CSVParser.parse(new URL(\"http://commons.apache.org\"), Charset.defaultCharset(), null);\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(new URL(\"http://commons.apache.org\"), Charset.defaultCharset(), null)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test\n     @Test\n     public void testRoundtrip() throws Exception {\n         final StringWriter out = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n-        final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n-        for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) {\n-            printer.printRecord(record);\n-        }\n-        assertEquals(input, out.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT)) {\n+            final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n+            for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) {\n+                printer.printRecord(record);\n+            }\n+            assertEquals(input, out.toString());\n+        }\n     }\n \n     @Test\n         assertEquals(\"2\", record.get(\"b\"));\n         assertEquals(\"3\", record.get(\"c\"));\n     }\n-    \n+\n     @Test\n     public void testSkipHeaderOverrideDuplicateHeaders() throws Exception {\n         final Reader in = new StringReader(\"a,a,a\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord()\n-                .parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)\n+                .iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"X\"));\n         assertEquals(\"2\", record.get(\"Y\"));\n     @Test\n     public void testSkipSetAltHeaders() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord()\n-                .parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().parse(in)\n+                .iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"X\"));\n         assertEquals(\"2\", record.get(\"Y\"));\n     @Test\n     public void testSkipSetHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord()\n-                .parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord().parse(in)\n+                .iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"a\"));\n         assertEquals(\"2\", record.get(\"b\"));\n     @Test\n     @Ignore\n     public void testStartWithEmptyLinesThenHeaders() throws Exception {\n-        final String[] codes = {\"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\\"\\\"\\n\\n\\n\"};\n-        final String[][] res = {{\"hello\", \"\"}, {\"\"}, // Excel format does not ignore empty lines\n-                {\"\"}};\n+        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"\" } };\n         for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-            parser.close();\n+            try (final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL)) {\n+                final List<CSVRecord> records = parser.getRecords();\n+                assertEquals(res.length, records.size());\n+                assertTrue(records.size() > 0);\n+                for (int i = 0; i < res.length; i++) {\n+                    assertArrayEquals(res[i], records.get(i).values());\n+                }\n+            }\n         }\n     }\n \n     @Test\n     public void testTrailingDelimiter() throws Exception {\n         final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter()\n-                .parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord()\n+                .withTrailingDelimiter().parse(in).iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"X\"));\n         assertEquals(\"2\", record.get(\"Y\"));\n     @Test\n     public void testTrim() throws Exception {\n         final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim()\n-                .parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord()\n+                .withTrim().parse(in).iterator();\n         final CSVRecord record = records.next();\n         assertEquals(\"1\", record.get(\"X\"));\n         assertEquals(\"2\", record.get(\"Y\"));\n     }\n \n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n-                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n-        assertEquals(0, parser.getCurrentLineNumber());\n-        assertNotNull(parser.nextRecord());\n-        assertEquals(1, parser.getCurrentLineNumber());\n-        assertNotNull(parser.nextRecord());\n-        assertEquals(2, parser.getCurrentLineNumber());\n-        assertNotNull(parser.nextRecord());\n-        // Still 2 because the last line is does not have EOL chars\n-        assertEquals(2, parser.getCurrentLineNumber());\n-        assertNull(parser.nextRecord());\n-        // Still 2 because the last line is does not have EOL chars\n-        assertEquals(2, parser.getCurrentLineNumber());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n+                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n+            assertEquals(0, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            assertEquals(1, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            assertEquals(2, parser.getCurrentLineNumber());\n+            assertNotNull(parser.nextRecord());\n+            // Still 2 because the last line is does not have EOL chars\n+            assertEquals(2, parser.getCurrentLineNumber());\n+            assertNull(parser.nextRecord());\n+            // Still 2 because the last line is does not have EOL chars\n+            assertEquals(2, parser.getCurrentLineNumber());\n+        }\n     }\n \n     private void validateRecordNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n-                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n-        CSVRecord record;\n-        assertEquals(0, parser.getRecordNumber());\n-        assertNotNull(record = parser.nextRecord());\n-        assertEquals(1, record.getRecordNumber());\n-        assertEquals(1, parser.getRecordNumber());\n-        assertNotNull(record = parser.nextRecord());\n-        assertEquals(2, record.getRecordNumber());\n-        assertEquals(2, parser.getRecordNumber());\n-        assertNotNull(record = parser.nextRecord());\n-        assertEquals(3, record.getRecordNumber());\n-        assertEquals(3, parser.getRecordNumber());\n-        assertNull(record = parser.nextRecord());\n-        assertEquals(3, parser.getRecordNumber());\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n+                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator))) {\n+            CSVRecord record;\n+            assertEquals(0, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(1, record.getRecordNumber());\n+            assertEquals(1, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(2, record.getRecordNumber());\n+            assertEquals(2, parser.getRecordNumber());\n+            assertNotNull(record = parser.nextRecord());\n+            assertEquals(3, record.getRecordNumber());\n+            assertEquals(3, parser.getRecordNumber());\n+            assertNull(record = parser.nextRecord());\n+            assertEquals(3, parser.getRecordNumber());\n+        }\n     }\n \n     private void validateRecordPosition(final String lineSeparator) throws IOException {\n         final String nl = lineSeparator; // used as linebreak in values for better distinction\n \n         final String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n-        // to see if recordPosition correctly points to the enclosing quote\n+                // to see if recordPosition correctly points to the enclosing quote\n                 \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\n                 // unicode test... not very relevant while operating on strings instead of bytes, but for\n                 // completeness...\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n import java.util.Random;\n \n import org.apache.commons.lang3.ObjectUtils;\n+import org.junit.Assert;\n import org.junit.Ignore;\n import org.junit.Test;\n \n public class CSVPrinterTest {\n \n     private static final int ITERATIONS_FOR_RANDOM_TEST = 50000;\n-    \n+\n     private static String printable(final String s) {\n         final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < s.length(); i++) {\n         final String[][] lines = generateLines(nLines, nCol);\n \n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-\n-        for (int i = 0; i < nLines; i++) {\n-            // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n-            printer.printRecord((Object[]) lines[i]);\n-        }\n-\n-        printer.flush();\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+\n+            for (int i = 0; i < nLines; i++) {\n+                // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n+                printer.printRecord((Object[]) lines[i]);\n+            }\n+\n+            printer.flush();\n+        }\n         final String result = sw.toString();\n         // System.out.println(\"### :\" + printable(result));\n \n-        final CSVParser parser = CSVParser.parse(result, format);\n-        final List<CSVRecord> parseResult = parser.getRecords();\n-\n-        final String[][] expected = lines.clone();\n-        for (int i = 0; i < expected.length; i++) {\n-            expected[i] = expectNulls(expected[i], format);\n-        }\n-        Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n-        parser.close();\n+        try (final CSVParser parser = CSVParser.parse(result, format)) {\n+            final List<CSVRecord> parseResult = parser.getRecords();\n+\n+            final String[][] expected = lines.clone();\n+            for (int i = 0; i < expected.length; i++) {\n+                expected[i] = expectNulls(expected[i], format);\n+            }\n+            Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n+        }\n     }\n \n     private void doRandom(final CSVFormat format, final int iter) throws Exception {\n     }\n \n     private void setUpTable(final Connection connection) throws SQLException {\n-        final Statement statement = connection.createStatement();\n-        try {\n+        try (final Statement statement = connection.createStatement()) {\n             statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n             statement.execute(\"insert into TEST values(1, 'r1')\");\n             statement.execute(\"insert into TEST values(2, 'r2')\");\n-        } finally {\n-            statement.close();\n         }\n     }\n \n     @Test\n     public void testDelimeterQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"'a,b,c',xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a,b,c',xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testDelimeterQuoteNONE() throws IOException {\n         final StringWriter sw = new StringWriter();\n         final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testDelimiterEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null))) {\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testDelimiterPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"a,b,c,xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            printer.print(\"a,b,c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"a,b,c,xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testDisabledComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printComment(\"This is a comment\");\n-\n-        assertEquals(\"\", sw.toString());\n-        printer.close();\n-    }\n-    \n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printComment(\"This is a comment\");\n+            assertEquals(\"\", sw.toString());\n+        }\n+    }\n+\n     @Test\n     public void testEOLEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n-        printer.print(\"a\\rb\\nc\");\n-        printer.print(\"x\\fy\\bz\");\n-        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n-        printer.close();\n-    }\n-    \n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\fy\\bz\");\n+            assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n+        }\n+    }\n+\n     @Test\n     public void testEOLPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.print(\"a\\rb\\nc\");\n-        printer.print(\"x\\fy\\bz\");\n-        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n-        printer.close();\n-    }\n-    \n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\fy\\bz\");\n+            assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n+        }\n+    }\n+\n     @Test\n     public void testEOLQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"a\\rb\\nc\");\n-        printer.print(\"x\\by\\fz\");\n-        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n-        printer.close();\n-    }\n-    \n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"a\\rb\\nc\");\n+            printer.print(\"x\\by\\fz\");\n+            assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n+        }\n+    }\n+\n     @Test\n     public void testEscapeBackslash() throws IOException {\n         StringWriter sw = new StringWriter();\n         final char quoteChar = '\\'';\n         final String eol = \"\\r\\n\";\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"\\\\\");\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar))) {\n+            printer.print(\"\\\\\");\n+        }\n         assertEquals(\"'\\\\'\", sw.toString());\n \n         sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"\\\\\\r\");\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar))) {\n+            printer.print(\"\\\\\\r\");\n+        }\n         assertEquals(\"'\\\\\\r'\", sw.toString());\n \n         sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"X\\\\\\r\");\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar))) {\n+            printer.print(\"X\\\\\\r\");\n+        }\n         assertEquals(\"'X\\\\\\r'\", sw.toString());\n \n         sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.printRecord(new Object[] { \"\\\\\\r\" });\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar))) {\n+            printer.printRecord(new Object[] { \"\\\\\\r\" });\n+        }\n         assertEquals(\"'\\\\\\r'\" + eol, sw.toString());\n \n         sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"\\\\\\\\\");\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar))) {\n+            printer.print(\"\\\\\\\\\");\n+        }\n         assertEquals(\"'\\\\\\\\'\", sw.toString());\n \n     }\n     @Test\n     public void testExcelPrintAllArrayOfArrays() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n-        printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\n-        assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            printer.printRecords((Object[]) new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } });\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testExcelPrintAllArrayOfLists() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n-        printer.printRecords((Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\n-        assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            printer.printRecords(\n+                    (Object[]) new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") });\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testExcelPrintAllIterableOfArrays() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n-        printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\n-        assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            printer.printRecords(Arrays.asList(new String[][] { { \"r1c1\", \"r1c2\" }, { \"r2c1\", \"r2c2\" } }));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testExcelPrintAllIterableOfLists() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n-        printer.printRecords(\n-                Arrays.asList(new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") }));\n-        assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            printer.printRecords(\n+                    Arrays.asList(new List[] { Arrays.asList(\"r1c1\", \"r1c2\"), Arrays.asList(\"r2c1\", \"r2c2\") }));\n+            assertEquals(\"r1c1,r1c2\" + recordSeparator + \"r2c1,r2c2\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testExcelPrinter1() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n-        printer.printRecord(\"a\", \"b\");\n-        assertEquals(\"a,b\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testExcelPrinter2() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);\n-        printer.printRecord(\"a,b\", \"b\");\n-        assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL)) {\n+            printer.printRecord(\"a,b\", \"b\");\n+            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testHeader() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"));\n-        printer.printRecord(\"a\", \"b\", \"c\");\n-        printer.printRecord(\"x\", \"y\", \"z\");\n-        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw,\n+                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n     }\n \n     @Test\n         final StringWriter sw = new StringWriter();\n         final Date now = new Date();\n         final CSVFormat format = CSVFormat.EXCEL;\n-        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n-        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n-                sw.toString());\n-        csvPrinter.close();\n+        try (final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\n+            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n+                    sw.toString());\n+        }\n     }\n \n     @Test\n         final StringWriter sw = new StringWriter();\n         final Date now = new Date();\n         final CSVFormat format = CSVFormat.TDF;\n-        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n-        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n-                sw.toString());\n-        csvPrinter.close();\n+        try (final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format)) {\n+            assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n+                    sw.toString());\n+        }\n     }\n \n     @Test\n     public void testHeaderNotSet() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.printRecord(\"a\", \"b\", \"c\");\n-        printer.printRecord(\"x\", \"y\", \"z\");\n-        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testInvalidFormat() throws Exception {\n         final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n-        new CSVPrinter(new StringWriter(), invalidFormat).close();\n+        try (final CSVPrinter printer = new CSVPrinter(new StringWriter(), invalidFormat)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test\n     public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\n         final StringWriter sw = new StringWriter();\n-        final Connection connection = geH2Connection();\n-        try {\n+        try (final Connection connection = geH2Connection()) {\n             setUpTable(connection);\n-            final Statement stmt = connection.createStatement();\n-            final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-            printer.printRecords(stmt.executeQuery(\"select ID, NAME from TEST\"));\n-            assertEquals(\"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n-            printer.close();\n-        } finally {\n-            connection.close();\n-        }\n+            try (final Statement stmt = connection.createStatement();\n+                    final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+                printer.printRecords(stmt.executeQuery(\"select ID, NAME from TEST\"));\n+            }\n+        }\n+        assertEquals(\"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n     }\n \n     @Test\n     public void testJdbcPrinterWithResultSet() throws IOException, ClassNotFoundException, SQLException {\n         final StringWriter sw = new StringWriter();\n         Class.forName(\"org.h2.Driver\");\n-        final Connection connection = geH2Connection();\n-        try {\n+        try (final Connection connection = geH2Connection();) {\n             setUpTable(connection);\n-            @SuppressWarnings(\"resource\")\n-            // Closed when the connection is closed.\n-            final Statement stmt = connection.createStatement();\n-            @SuppressWarnings(\"resource\")\n-            // Closed when the connection is closed.\n-            final ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\");\n-            final CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw);\n-            printer.printRecords(resultSet);\n-            assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator,\n-                    sw.toString());\n-            printer.close();\n-        } finally {\n-            connection.close();\n-        }\n+            try (final Statement stmt = connection.createStatement();\n+                    final ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\");\n+                    final CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw)) {\n+                printer.printRecords(resultSet);\n+            }\n+        }\n+        assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n     }\n \n     @Test\n     public void testJdbcPrinterWithResultSetMetaData() throws IOException, ClassNotFoundException, SQLException {\n         final StringWriter sw = new StringWriter();\n         Class.forName(\"org.h2.Driver\");\n-        final Connection connection = geH2Connection();\n-        try {\n+        try (final Connection connection = geH2Connection()) {\n             setUpTable(connection);\n-            @SuppressWarnings(\"resource\")\n-            // Closed when the connection is closed.\n-            final Statement stmt = connection.createStatement();\n-            @SuppressWarnings(\"resource\")\n-            // Closed when the connection is closed.\n-            final ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\");\n-            final CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw);\n-            printer.printRecords(resultSet);\n-            assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator,\n-                    sw.toString());\n-            printer.close();\n-        } finally {\n-            connection.close();\n+            try (final Statement stmt = connection.createStatement();\n+                    final ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\");\n+                    final CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw)) {\n+                printer.printRecords(resultSet);\n+                assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator,\n+                        sw.toString());\n+            }\n         }\n     }\n \n     public void testJira135_part1() throws IOException {\n         final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n         final List<String> list = new LinkedList<>();\n-        list.add(\"\\\"\");\n-        printer.printRecord(list);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\"\");\n+            printer.printRecord(list);\n+        }\n         final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n         assertEquals(expected, sw.toString());\n         final String[] record0 = toFirstRecordValues(expected, format);\n     public void testJira135_part2() throws IOException {\n         final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n         final List<String> list = new LinkedList<>();\n-        list.add(\"\\n\");\n-        printer.printRecord(list);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\n\");\n+            printer.printRecord(list);\n+        }\n         final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n         assertEquals(expected, sw.toString());\n         final String[] record0 = toFirstRecordValues(expected, format);\n     public void testJira135_part3() throws IOException {\n         final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n         final List<String> list = new LinkedList<>();\n-        list.add(\"\\\\\");\n-        printer.printRecord(list);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\\\");\n+            printer.printRecord(list);\n+        }\n         final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n         assertEquals(expected, sw.toString());\n         final String[] record0 = toFirstRecordValues(expected, format);\n     public void testJira135All() throws IOException {\n         final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n         final List<String> list = new LinkedList<>();\n-        list.add(\"\\\"\");\n-        list.add(\"\\n\");\n-        list.add(\"\\\\\");\n-        printer.printRecord(list);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            list.add(\"\\\"\");\n+            list.add(\"\\n\");\n+            list.add(\"\\\\\");\n+            printer.printRecord(list);\n+        }\n         final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n         assertEquals(expected, sw.toString());\n         final String[] record0 = toFirstRecordValues(expected, format);\n     @Test\n     public void testMultiLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'));\n-        printer.printComment(\"This is a comment\\non multiple lines\");\n-\n-        assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            printer.printComment(\"This is a comment\\non multiple lines\");\n+\n+            assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator,\n+                    sw.toString());\n+        }\n     }\n \n     @Test\n         Object[] s = new String[] { \"NULL\", null };\n         CSVFormat format = CSVFormat.MYSQL.withQuote('\"').withNullString(\"NULL\").withQuoteMode(QuoteMode.NON_NUMERIC);\n         StringWriter writer = new StringWriter();\n-        CSVPrinter printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         String expected = \"\\\"NULL\\\"\\tNULL\\n\";\n         assertEquals(expected, writer.toString());\n         String[] record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\\\\N\", null };\n         format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\\\\\\\N\\t\\\\N\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\\\\N\", \"A\" };\n         format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\\\\\\\N\\tA\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\\n\", \"A\" };\n         format = CSVFormat.MYSQL.withNullString(\"\\\\N\");\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\\\n\\tA\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\", null };\n         format = CSVFormat.MYSQL.withNullString(\"NULL\");\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\tNULL\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\", null };\n         format = CSVFormat.MYSQL;\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\t\\\\N\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\\\\N\", \"\", \"\\u000e,\\\\\\r\" };\n         format = CSVFormat.MYSQL;\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\\\\\\\N\\t\\t\\u000e,\\\\\\\\\\\\r\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"NULL\", \"\\\\\\r\" };\n         format = CSVFormat.MYSQL;\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"NULL\\t\\\\\\\\\\\\r\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n         s = new String[] { \"\\\\\\r\" };\n         format = CSVFormat.MYSQL;\n         writer = new StringWriter();\n-        printer = new CSVPrinter(writer, format);\n-        printer.printRecord(s);\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(writer, format)) {\n+            printer.printRecord(s);\n+        }\n         expected = \"\\\\\\\\\\\\r\\n\";\n         assertEquals(expected, writer.toString());\n         record0 = toFirstRecordValues(expected, format);\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testNewCsvPrinterAppendableNullFormat() throws Exception {\n-        new CSVPrinter(new StringWriter(), null).close();\n+        try (final CSVPrinter printer = new CSVPrinter(new StringWriter(), null)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testNewCSVPrinterNullAppendableFormat() throws Exception {\n-        new CSVPrinter(null, CSVFormat.DEFAULT).close();\n+        try (final CSVPrinter printer = new CSVPrinter(null, CSVFormat.DEFAULT)) {\n+            Assert.fail(\"This test should have thrown an exception.\");\n+        }\n     }\n \n     @Test\n     public void testParseCustomNullValues() throws IOException {\n         final StringWriter sw = new StringWriter();\n         final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        printer.printRecord(\"a\", null, \"b\");\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, format)) {\n+            printer.printRecord(\"a\", null, \"b\");\n+        }\n         final String csvString = sw.toString();\n         assertEquals(\"a,NULL,b\" + recordSeparator, csvString);\n-        final Iterable<CSVRecord> iterable = format.parse(new StringReader(csvString));\n-        final Iterator<CSVRecord> iterator = iterable.iterator();\n-        final CSVRecord record = iterator.next();\n-        assertEquals(\"a\", record.get(0));\n-        assertEquals(null, record.get(1));\n-        assertEquals(\"b\", record.get(2));\n-        assertFalse(iterator.hasNext());\n-        ((CSVParser) iterable).close();\n+        try (final CSVParser iterable = format.parse(new StringReader(csvString))) {\n+            final Iterator<CSVRecord> iterator = iterable.iterator();\n+            final CSVRecord record = iterator.next();\n+            assertEquals(\"a\", record.get(0));\n+            assertEquals(null, record.get(1));\n+            assertEquals(\"b\", record.get(2));\n+            assertFalse(iterator.hasNext());\n+        }\n     }\n \n     @Test\n     public void testPlainEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n-        printer.print(\"abc\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"abc,xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'))) {\n+            printer.print(\"abc\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"abc,xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPlainPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.print(\"abc\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"abc,xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null))) {\n+            printer.print(\"abc\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"abc,xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPlainQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"abc\");\n-        assertEquals(\"abc\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"abc\");\n+            assertEquals(\"abc\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrint() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = CSVFormat.DEFAULT.print(sw);\n-        printer.printRecord(\"a\", \"b\\\\c\");\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = CSVFormat.DEFAULT.print(sw)) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrintCustomNullValues() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n-        printer.printRecord(\"a\", null, \"b\");\n-        assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"))) {\n+            printer.printRecord(\"a\", null, \"b\");\n+            assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter1() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\");\n-        assertEquals(\"a,b\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\");\n+            assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter2() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a,b\", \"b\");\n-        assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a,b\", \"b\");\n+            assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter3() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a, b\", \"b \");\n-        assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a, b\", \"b \");\n+            assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter4() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\\"c\");\n-        assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\\\"c\");\n+            assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter5() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\nc\");\n-        assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\\nc\");\n+            assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter6() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\r\\nc\");\n-        assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\\r\\nc\");\n+            assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrinter7() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\\\c\");\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", \"b\\\\c\");\n+            assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testPrintNullValues() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", null, \"b\");\n-        assertEquals(\"a,,b\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT)) {\n+            printer.printRecord(\"a\", null, \"b\");\n+            assertEquals(\"a,,b\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testQuoteAll() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL));\n-        printer.printRecord(\"a\", \"b\\nc\", \"d\");\n-        assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL))) {\n+            printer.printRecord(\"a\", \"b\\nc\", \"d\");\n+            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testQuoteNonNumeric() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC));\n-        printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n-        assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.NON_NUMERIC))) {\n+            printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n+            assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     @Test\n     public void testSingleLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'));\n-        printer.printComment(\"This is a comment\");\n-\n-        assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'))) {\n+            printer.printComment(\"This is a comment\");\n+            assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n+        }\n     }\n \n     @Test\n     public void testSingleQuoteQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"a'b'c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"'a''b''c',xyz\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''))) {\n+            printer.print(\"a'b'c\");\n+            printer.print(\"xyz\");\n+            assertEquals(\"'a''b''c',xyz\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testSkipHeaderRecordFalse() throws IOException {\n         // functionally identical to testHeader, used to test CSV-153\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw,\n-                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false));\n-        printer.printRecord(\"a\", \"b\", \"c\");\n-        printer.printRecord(\"x\", \"y\", \"z\");\n-        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw,\n+                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testSkipHeaderRecordTrue() throws IOException {\n         // functionally identical to testHeaderNotSet, used to test CSV-153\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw,\n-                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true));\n-        printer.printRecord(\"a\", \"b\", \"c\");\n-        printer.printRecord(\"x\", \"y\", \"z\");\n-        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw,\n+                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(true))) {\n+            printer.printRecord(\"a\", \"b\", \"c\");\n+            printer.printRecord(\"x\", \"y\", \"z\");\n+            assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testTrimOnOneColumn() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n-        printer.print(\" A \");\n-        assertEquals(\"A\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\n+            printer.print(\" A \");\n+            assertEquals(\"A\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testTrimOnTwoColumns() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n-        printer.print(\" A \");\n-        printer.print(\" B \");\n-        assertEquals(\"A,B\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim())) {\n+            printer.print(\" A \");\n+            printer.print(\" B \");\n+            assertEquals(\"A,B\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testTrailingDelimiterOnTwoColumns() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter());\n-        printer.printRecord(\"A\", \"B\");\n-        assertEquals(\"A,B,\\r\\n\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter())) {\n+            printer.printRecord(\"A\", \"B\");\n+            assertEquals(\"A,B,\\r\\n\", sw.toString());\n+        }\n     }\n \n     @Test\n     public void testTrimOffOneColumn() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false));\n-        printer.print(\" A \");\n-        assertEquals(\"\\\" A \\\"\", sw.toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false))) {\n+            printer.print(\" A \");\n+            assertEquals(\"\\\" A \\\"\", sw.toString());\n+        }\n     }\n \n     private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n--- a/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n     @Test\n     public void testRemoveAndAddColumns() throws IOException {\n         // do:\n-        final CSVPrinter printer = new CSVPrinter(new StringBuilder(), CSVFormat.DEFAULT);\n-        final Map<String, String> map = recordWithHeader.toMap();\n-        map.remove(\"OldColumn\");\n-        map.put(\"ZColumn\", \"NewValue\");\n-        // check:\n-        final ArrayList<String> list = new ArrayList<>(map.values());\n-        Collections.sort(list);\n-        printer.printRecord(list);\n-        Assert.assertEquals(\"A,B,C,NewValue\" + CSVFormat.DEFAULT.getRecordSeparator(), printer.getOut().toString());\n-        printer.close();\n+        try (final CSVPrinter printer = new CSVPrinter(new StringBuilder(), CSVFormat.DEFAULT)) {\n+            final Map<String, String> map = recordWithHeader.toMap();\n+            map.remove(\"OldColumn\");\n+            map.put(\"ZColumn\", \"NewValue\");\n+            // check:\n+            final ArrayList<String> list = new ArrayList<>(map.values());\n+            Collections.sort(list);\n+            printer.printRecord(list);\n+            Assert.assertEquals(\"A,B,C,NewValue\" + CSVFormat.DEFAULT.getRecordSeparator(), printer.getOut().toString());\n+        }\n     }\n \n     @Test\n \n     @Test\n     public void testToMapWithShortRecord() throws Exception {\n-       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n-       final CSVRecord shortRec = parser.iterator().next();\n-       shortRec.toMap();\n+        try (final CSVParser parser = CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"))) {\n+            final CSVRecord shortRec = parser.iterator().next();\n+            shortRec.toMap();\n+        }\n     }\n \n     @Test\n     public void testToMapWithNoHeader() throws Exception {\n-       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));\n-       final CSVRecord shortRec = parser.iterator().next();\n-       final Map<String, String> map = shortRec.toMap();\n-       assertNotNull(\"Map is not null.\", map);\n-       assertTrue(\"Map is empty.\", map.isEmpty());\n+        try (final CSVParser parser = CSVParser.parse(\"a,b\", CSVFormat.newFormat(','))) {\n+            final CSVRecord shortRec = parser.iterator().next();\n+            final Map<String, String> map = shortRec.toMap();\n+            assertNotNull(\"Map is not null.\", map);\n+            assertTrue(\"Map is empty.\", map.isEmpty());\n+        }\n     }\n \n     private void validateMap(final Map<String, String> map, final boolean allowsNulls) {\n--- a/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n \n     @Test\n     public void testEmptyInput() throws Exception {\n-        final ExtendedBufferedReader br = getBufferedReader(\"\");\n-        assertEquals(END_OF_STREAM, br.read());\n-        assertEquals(END_OF_STREAM, br.lookAhead());\n-        assertEquals(END_OF_STREAM, br.getLastChar());\n-        assertNull(br.readLine());\n-        assertEquals(0, br.read(new char[10], 0, 0));\n-        br.close();\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"\")) {\n+            assertEquals(END_OF_STREAM, br.read());\n+            assertEquals(END_OF_STREAM, br.lookAhead());\n+            assertEquals(END_OF_STREAM, br.getLastChar());\n+            assertNull(br.readLine());\n+            assertEquals(0, br.read(new char[10], 0, 0));\n+        }\n     }\n \n     @Test\n     public void testReadLookahead1() throws Exception {\n-        final ExtendedBufferedReader br = getBufferedReader(\"1\\n2\\r3\\n\");\n-        assertEquals(0, br.getCurrentLineNumber());\n-        assertEquals('1', br.lookAhead());\n-        assertEquals(UNDEFINED, br.getLastChar());\n-        assertEquals(0, br.getCurrentLineNumber());\n-        assertEquals('1', br.read()); // Start line 1\n-        assertEquals('1', br.getLastChar());\n-\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals('\\n', br.lookAhead());\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals('1', br.getLastChar());\n-        assertEquals('\\n', br.read());\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(1, br.getCurrentLineNumber());\n-\n-        assertEquals('2', br.lookAhead());\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals('2', br.read()); // Start line 2\n-        assertEquals(2, br.getCurrentLineNumber());\n-        assertEquals('2', br.getLastChar());\n-\n-        assertEquals('\\r', br.lookAhead());\n-        assertEquals(2, br.getCurrentLineNumber());\n-        assertEquals('2', br.getLastChar());\n-        assertEquals('\\r', br.read());\n-        assertEquals('\\r', br.getLastChar());\n-        assertEquals(2, br.getCurrentLineNumber());\n-\n-        assertEquals('3', br.lookAhead());\n-        assertEquals('\\r', br.getLastChar());\n-        assertEquals('3', br.read()); // Start line 3\n-        assertEquals('3', br.getLastChar());\n-        assertEquals(3, br.getCurrentLineNumber());\n-\n-        assertEquals('\\n', br.lookAhead());\n-        assertEquals(3, br.getCurrentLineNumber());\n-        assertEquals('3', br.getLastChar());\n-        assertEquals('\\n', br.read());\n-        assertEquals(3, br.getCurrentLineNumber());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(3, br.getCurrentLineNumber());\n-\n-        assertEquals(END_OF_STREAM, br.lookAhead());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(END_OF_STREAM, br.read());\n-        assertEquals(END_OF_STREAM, br.getLastChar());\n-        assertEquals(END_OF_STREAM, br.read());\n-        assertEquals(END_OF_STREAM, br.lookAhead());\n-        assertEquals(3, br.getCurrentLineNumber());\n-\n-        br.close();\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"1\\n2\\r3\\n\")) {\n+            assertEquals(0, br.getCurrentLineNumber());\n+            assertEquals('1', br.lookAhead());\n+            assertEquals(UNDEFINED, br.getLastChar());\n+            assertEquals(0, br.getCurrentLineNumber());\n+            assertEquals('1', br.read()); // Start line 1\n+            assertEquals('1', br.getLastChar());\n+\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals('\\n', br.lookAhead());\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals('1', br.getLastChar());\n+            assertEquals('\\n', br.read());\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals('\\n', br.getLastChar());\n+            assertEquals(1, br.getCurrentLineNumber());\n+\n+            assertEquals('2', br.lookAhead());\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals('\\n', br.getLastChar());\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals('2', br.read()); // Start line 2\n+            assertEquals(2, br.getCurrentLineNumber());\n+            assertEquals('2', br.getLastChar());\n+\n+            assertEquals('\\r', br.lookAhead());\n+            assertEquals(2, br.getCurrentLineNumber());\n+            assertEquals('2', br.getLastChar());\n+            assertEquals('\\r', br.read());\n+            assertEquals('\\r', br.getLastChar());\n+            assertEquals(2, br.getCurrentLineNumber());\n+\n+            assertEquals('3', br.lookAhead());\n+            assertEquals('\\r', br.getLastChar());\n+            assertEquals('3', br.read()); // Start line 3\n+            assertEquals('3', br.getLastChar());\n+            assertEquals(3, br.getCurrentLineNumber());\n+\n+            assertEquals('\\n', br.lookAhead());\n+            assertEquals(3, br.getCurrentLineNumber());\n+            assertEquals('3', br.getLastChar());\n+            assertEquals('\\n', br.read());\n+            assertEquals(3, br.getCurrentLineNumber());\n+            assertEquals('\\n', br.getLastChar());\n+            assertEquals(3, br.getCurrentLineNumber());\n+\n+            assertEquals(END_OF_STREAM, br.lookAhead());\n+            assertEquals('\\n', br.getLastChar());\n+            assertEquals(END_OF_STREAM, br.read());\n+            assertEquals(END_OF_STREAM, br.getLastChar());\n+            assertEquals(END_OF_STREAM, br.read());\n+            assertEquals(END_OF_STREAM, br.lookAhead());\n+            assertEquals(3, br.getCurrentLineNumber());\n+\n+        }\n     }\n \n     @Test\n         final char[] ref = new char[5];\n         final char[] res = new char[5];\n \n-        final ExtendedBufferedReader br = getBufferedReader(\"abcdefg\");\n-        ref[0] = 'a';\n-        ref[1] = 'b';\n-        ref[2] = 'c';\n-        assertEquals(3, br.read(res, 0, 3));\n-        assertArrayEquals(ref, res);\n-        assertEquals('c', br.getLastChar());\n-\n-        assertEquals('d', br.lookAhead());\n-        ref[4] = 'd';\n-        assertEquals(1, br.read(res, 4, 1));\n-        assertArrayEquals(ref, res);\n-        assertEquals('d', br.getLastChar());\n-        br.close();\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"abcdefg\")) {\n+            ref[0] = 'a';\n+            ref[1] = 'b';\n+            ref[2] = 'c';\n+            assertEquals(3, br.read(res, 0, 3));\n+            assertArrayEquals(ref, res);\n+            assertEquals('c', br.getLastChar());\n+\n+            assertEquals('d', br.lookAhead());\n+            ref[4] = 'd';\n+            assertEquals(1, br.read(res, 4, 1));\n+            assertArrayEquals(ref, res);\n+            assertEquals('d', br.getLastChar());\n+        }\n     }\n \n     @Test\n     public void testReadLine() throws Exception {\n-        ExtendedBufferedReader br = getBufferedReader(\"\");\n-        assertNull(br.readLine());\n-\n-        br.close();\n-        br = getBufferedReader(\"\\n\");\n-        assertEquals(\"\",br.readLine());\n-        assertNull(br.readLine());\n-\n-        br.close();\n-        br = getBufferedReader(\"foo\\n\\nhello\");\n-        assertEquals(0, br.getCurrentLineNumber());\n-        assertEquals(\"foo\",br.readLine());\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals(\"\",br.readLine());\n-        assertEquals(2, br.getCurrentLineNumber());\n-        assertEquals(\"hello\",br.readLine());\n-        assertEquals(3, br.getCurrentLineNumber());\n-        assertNull(br.readLine());\n-        assertEquals(3, br.getCurrentLineNumber());\n-\n-        br.close();\n-        br = getBufferedReader(\"foo\\n\\nhello\");\n-        assertEquals('f', br.read());\n-        assertEquals('o', br.lookAhead());\n-        assertEquals(\"oo\",br.readLine());\n-        assertEquals(1, br.getCurrentLineNumber());\n-        assertEquals('\\n', br.lookAhead());\n-        assertEquals(\"\",br.readLine());\n-        assertEquals(2, br.getCurrentLineNumber());\n-        assertEquals('h', br.lookAhead());\n-        assertEquals(\"hello\",br.readLine());\n-        assertNull(br.readLine());\n-        assertEquals(3, br.getCurrentLineNumber());\n-\n-\n-        br.close();\n-        br = getBufferedReader(\"foo\\rbaar\\r\\nfoo\");\n-        assertEquals(\"foo\",br.readLine());\n-        assertEquals('b', br.lookAhead());\n-        assertEquals(\"baar\",br.readLine());\n-        assertEquals('f', br.lookAhead());\n-        assertEquals(\"foo\",br.readLine());\n-        assertNull(br.readLine());\n-        br.close();\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"\")) {\n+            assertNull(br.readLine());\n+        }\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"\\n\")) {\n+            assertEquals(\"\", br.readLine());\n+            assertNull(br.readLine());\n+        }\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"foo\\n\\nhello\")) {\n+            assertEquals(0, br.getCurrentLineNumber());\n+            assertEquals(\"foo\", br.readLine());\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals(\"\", br.readLine());\n+            assertEquals(2, br.getCurrentLineNumber());\n+            assertEquals(\"hello\", br.readLine());\n+            assertEquals(3, br.getCurrentLineNumber());\n+            assertNull(br.readLine());\n+            assertEquals(3, br.getCurrentLineNumber());\n+        }\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"foo\\n\\nhello\")) {\n+            assertEquals('f', br.read());\n+            assertEquals('o', br.lookAhead());\n+            assertEquals(\"oo\", br.readLine());\n+            assertEquals(1, br.getCurrentLineNumber());\n+            assertEquals('\\n', br.lookAhead());\n+            assertEquals(\"\", br.readLine());\n+            assertEquals(2, br.getCurrentLineNumber());\n+            assertEquals('h', br.lookAhead());\n+            assertEquals(\"hello\", br.readLine());\n+            assertNull(br.readLine());\n+            assertEquals(3, br.getCurrentLineNumber());\n+        }\n+        try (final ExtendedBufferedReader br = createBufferedReader(\"foo\\rbaar\\r\\nfoo\")) {\n+            assertEquals(\"foo\", br.readLine());\n+            assertEquals('b', br.lookAhead());\n+            assertEquals(\"baar\", br.readLine());\n+            assertEquals('f', br.lookAhead());\n+            assertEquals(\"foo\", br.readLine());\n+            assertNull(br.readLine());\n+        }\n     }\n \n     /*\n-     * Test to illustrate  https://issues.apache.org/jira/browse/CSV-75\n+     * Test to illustrate https://issues.apache.org/jira/browse/CSV-75\n      *\n      */\n     @Test\n     public void testReadChar() throws Exception {\n-        final String LF=\"\\n\"; final String CR=\"\\r\"; final String CRLF=CR+LF; final String LFCR=LF+CR;// easier to read the string below\n-        final String test=\"a\" + LF + \"b\" + CR + \"c\" + LF + LF + \"d\" + CR + CR + \"e\" + LFCR + \"f \"+ CRLF;\n-        //                EOL        eol        EOL  EOL        eol  eol        EOL+CR        EOL\n+        final String LF = \"\\n\";\n+        final String CR = \"\\r\";\n+        final String CRLF = CR + LF;\n+        final String LFCR = LF + CR;// easier to read the string below\n+        final String test = \"a\" + LF + \"b\" + CR + \"c\" + LF + LF + \"d\" + CR + CR + \"e\" + LFCR + \"f \" + CRLF;\n+        // EOL eol EOL EOL eol eol EOL+CR EOL\n         final int EOLeolct = 9;\n-        ExtendedBufferedReader br;\n-\n-        br = getBufferedReader(test);\n-        assertEquals(0, br.getCurrentLineNumber());\n-        while (br.readLine() != null) {\n-            // consume all\n-        }\n-        assertEquals(EOLeolct, br.getCurrentLineNumber());\n-\n-        br.close();\n-        br = getBufferedReader(test);\n-        assertEquals(0, br.getCurrentLineNumber());\n-        while (br.read() != -1) {\n-            // consume all\n-        }\n-        assertEquals(EOLeolct, br.getCurrentLineNumber());\n-\n-        br.close();\n-        br = getBufferedReader(test);\n-        assertEquals(0, br.getCurrentLineNumber());\n-        final char[] buff = new char[10];\n-        while (br.read(buff, 0, 3) != -1) {\n-            // consume all\n-        }\n-        assertEquals(EOLeolct, br.getCurrentLineNumber());\n-        br.close();\n-    }\n-\n-    private ExtendedBufferedReader getBufferedReader(final String s) {\n+\n+        try (final ExtendedBufferedReader br = createBufferedReader(test)) {\n+            assertEquals(0, br.getCurrentLineNumber());\n+            while (br.readLine() != null) {\n+                // consume all\n+            }\n+            assertEquals(EOLeolct, br.getCurrentLineNumber());\n+        }\n+        try (final ExtendedBufferedReader br = createBufferedReader(test)) {\n+            assertEquals(0, br.getCurrentLineNumber());\n+            while (br.read() != -1) {\n+                // consume all\n+            }\n+            assertEquals(EOLeolct, br.getCurrentLineNumber());\n+        }\n+        try (final ExtendedBufferedReader br = createBufferedReader(test)) {\n+            assertEquals(0, br.getCurrentLineNumber());\n+            final char[] buff = new char[10];\n+            while (br.read(buff, 0, 3) != -1) {\n+                // consume all\n+            }\n+            assertEquals(EOLeolct, br.getCurrentLineNumber());\n+        }\n+    }\n+\n+    private ExtendedBufferedReader createBufferedReader(final String s) {\n         return new ExtendedBufferedReader(new StringReader(s));\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/LexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/LexerTest.java\n         formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n     }\n \n-    private Lexer getLexer(final String input, final CSVFormat format) {\n+    private Lexer createLexer(final String input, final CSVFormat format) {\n         return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n     }\n \n     @Test\n     public void testSurroundingSpacesAreDeleted() throws IOException {\n         final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingSpaces\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingSpaces\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        }\n     }\n \n     @Test\n     public void testSurroundingTabsAreDeleted() throws IOException {\n         final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingTabs\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"surroundingTabs\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        }\n     }\n \n     @Test\n     public void testIgnoreEmptyLines() throws IOException {\n-        final String code =\n-                \"first,line,\\n\"+\n-                \"\\n\"+\n-                \"\\n\"+\n-                \"second,line\\n\"+\n-                \"\\n\"+\n-                \"\\n\"+\n-                \"third line \\n\"+\n-                \"\\n\"+\n-                \"\\n\"+\n-                \"last, line \\n\"+\n-                \"\\n\"+\n-                \"\\n\"+\n-                \"\\n\";\n+        final String code = \"first,line,\\n\" + \"\\n\" + \"\\n\" + \"second,line\\n\" + \"\\n\" + \"\\n\" + \"third line \\n\" + \"\\n\" +\n+                \"\\n\" + \"last, line \\n\" + \"\\n\" + \"\\n\" + \"\\n\";\n         final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines();\n-        final Lexer parser = getLexer(code, format);\n-\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"second\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"line\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"third line \"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"last\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \" line \"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        try (final Lexer parser = createLexer(code, format)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"second\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"line\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"third line \"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"last\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \" line \"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        }\n     }\n \n     @Test\n     public void testComments() throws IOException {\n-        final String code =\n-                \"first,line,\\n\"+\n-                \"second,line,tokenWith#no-comment\\n\"+\n-                \"# comment line \\n\"+\n-                \"third,line,#no-comment\\n\"+\n-                \"# penultimate comment\\n\"+\n-                \"# Final comment\\n\";\n+        final String code = \"first,line,\\n\" + \"second,line,tokenWith#no-comment\\n\" + \"# comment line \\n\" +\n+                \"third,line,#no-comment\\n\" + \"# penultimate comment\\n\" + \"# Final comment\\n\";\n         final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#');\n-        final Lexer parser = getLexer(code, format);\n-\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"second\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"tokenWith#no-comment\"));\n-        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"comment line\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"third\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"#no-comment\"));\n-        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"penultimate comment\"));\n-        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"Final comment\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        try (final Lexer parser = createLexer(code, format)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"second\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"tokenWith#no-comment\"));\n+            assertThat(parser.nextToken(new Token()), matches(COMMENT, \"comment line\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"third\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"#no-comment\"));\n+            assertThat(parser.nextToken(new Token()), matches(COMMENT, \"penultimate comment\"));\n+            assertThat(parser.nextToken(new Token()), matches(COMMENT, \"Final comment\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        }\n     }\n \n     @Test\n     public void testCommentsAndEmptyLines() throws IOException {\n-        final String code =\n-                \"1,2,3,\\n\"+                // 1\n-                \"\\n\"+                      // 1b\n-                \"\\n\"+                      // 1c\n-                \"a,b x,c#no-comment\\n\"+    // 2\n-                \"#foo\\n\"+                  // 3\n-                \"\\n\"+                      // 4\n-                \"\\n\"+                      // 4b\n-                \"d,e,#no-comment\\n\"+       // 5\n-                \"\\n\"+                      // 5b\n-                \"\\n\"+                      // 5c\n-                \"# penultimate comment\\n\"+ // 6\n-                \"\\n\"+                      // 6b\n-                \"\\n\"+                      // 6c\n-                \"# Final comment\\n\";       // 7\n+        final String code = \"1,2,3,\\n\" + // 1\n+                \"\\n\" + // 1b\n+                \"\\n\" + // 1c\n+                \"a,b x,c#no-comment\\n\" + // 2\n+                \"#foo\\n\" + // 3\n+                \"\\n\" + // 4\n+                \"\\n\" + // 4b\n+                \"d,e,#no-comment\\n\" + // 5\n+                \"\\n\" + // 5b\n+                \"\\n\" + // 5c\n+                \"# penultimate comment\\n\" + // 6\n+                \"\\n\" + // 6b\n+                \"\\n\" + // 6c\n+                \"# Final comment\\n\"; // 7\n         final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#').withIgnoreEmptyLines(false);\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n-        final Lexer parser = getLexer(code, format);\n-\n-\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"1\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"2\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"3\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 1\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 1b\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 1c\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b x\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"c#no-comment\")); // 2\n-        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"foo\"));           // 3\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 4\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 4b\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"d\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"e\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"#no-comment\"));  // 5\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 5b\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 5c\n-        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"penultimate comment\"));              // 6\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 6b\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\"));             // 6c\n-        assertThat(parser.nextToken(new Token()), matches(COMMENT, \"Final comment\"));              // 7\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n-\n+        try (final Lexer parser = createLexer(code, format)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"1\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"2\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"3\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 1\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 1b\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 1c\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"b x\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"c#no-comment\")); // 2\n+            assertThat(parser.nextToken(new Token()), matches(COMMENT, \"foo\")); // 3\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 4\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 4b\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"d\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"e\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"#no-comment\")); // 5\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 5b\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 5c\n+            assertThat(parser.nextToken(new Token()), matches(COMMENT, \"penultimate comment\")); // 6\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 6b\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"\")); // 6c\n+            assertThat(parser.nextToken(new Token()), matches(COMMENT, \"Final comment\")); // 7\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        }\n     }\n \n     // simple token with escaping not enabled\n     @Test\n     public void testBackslashWithoutEscaping() throws IOException {\n-        /* file: a,\\,,b\n-        *       \\,,\n-        */\n+        /*\n+         * file: a,\\,,b \\,,\n+         */\n         final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n         final CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isEscapeCharacterSet());\n-        final Lexer parser = getLexer(code, format);\n-\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        // an unquoted single backslash is not an escape char\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\\\\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\\\\\"));\n-        // an unquoted single backslash is not an escape char\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\\\\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        try (final Lexer parser = createLexer(code, format)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            // an unquoted single backslash is not an escape char\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\\\\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\\\\\"));\n+            // an unquoted single backslash is not an escape char\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\\\\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\"));\n+        }\n     }\n \n     // simple token with escaping enabled\n     @Test\n     public void testBackslashWithEscaping() throws IOException {\n-        /* file: a,\\,,b\n-        *       \\,,\n-        */\n+        /*\n+         * file: a,\\,,b \\,,\n+         */\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n         final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n         assertTrue(format.isEscapeCharacterSet());\n-        final Lexer parser = getLexer(code, format);\n-\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\\\\\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\nc\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"d\\r\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"e\"));\n+        try (final Lexer parser = createLexer(code, format)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\\\\\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\\nc\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"d\\r\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"e\"));\n+        }\n     }\n \n     // encapsulator tokenizer (single line)\n     @Test\n     public void testNextToken4() throws IOException {\n-        /* file:  a,\"foo\",b\n-        *        a,   \" foo\",b\n-        *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n-        *        a,  \" foo \" ,b\n-        */\n+        /*\n+         * file: a,\"foo\",b a, \" foo\",b a,\"foo \" ,b // whitespace after closing encapsulator a, \" foo \" ,b\n+         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces());\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \" foo\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo \"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \" foo \"));\n-//      assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"b\"));\n+        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces())) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \" foo\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo \"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \" foo \"));\n+            // assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"b\"));\n+        }\n     }\n \n     // encapsulator tokenizer (multi line, delimiter in string)\n     @Test\n     public void testNextToken5() throws IOException {\n         final String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\\n\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"foo\\n  baar ,,,\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"\\n\\t \\n\"));\n-\n+        try (final Lexer parser = createLexer(code, CSVFormat.DEFAULT)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\\n\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"foo\\n  baar ,,,\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"\\n\\t \\n\"));\n+        }\n     }\n \n     // change delimiters, comment, encapsulater\n     @Test\n     public void testNextToken6() throws IOException {\n-        /* file: a;'b and \\' more\n-        *       '\n-        *       !comment;;;;\n-        *       ;;\n-        */\n+        /*\n+         * file: a;'b and \\' more ' !comment;;;; ;;\n+         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n         final CSVFormat format = CSVFormat.DEFAULT.withQuote('\\'').withCommentMarker('!').withDelimiter(';');\n-        final Lexer parser = getLexer(code, format);\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n-        assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));\n+        try (final Lexer parser = createLexer(code, format)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n+            assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));\n+        }\n     }\n \n     // From CSV-1\n     @Test\n     public void testDelimiterIsWhitespace() throws IOException {\n         final String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        final Lexer parser = getLexer(code, CSVFormat.TDF);\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"one\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"two\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"four\"));\n-        assertThat(parser.nextToken(new Token()), matches(TOKEN, \"five\"));\n-        assertThat(parser.nextToken(new Token()), matches(EOF, \"six\"));\n+        try (final Lexer parser = createLexer(code, CSVFormat.TDF)) {\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"one\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"two\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"four\"));\n+            assertThat(parser.nextToken(new Token()), matches(TOKEN, \"five\"));\n+            assertThat(parser.nextToken(new Token()), matches(EOF, \"six\"));\n+        }\n     }\n \n     @Test\n     public void testEscapedCR() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+        }\n     }\n \n     @Test\n     public void testCR() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n+        }\n     }\n \n     @Test\n     public void testEscapedLF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n+        }\n     }\n \n     @Test\n     public void testLF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n+        }\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>TAB to be unescaped?\n     public void testEscapedTab() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n+        }\n+\n     }\n \n     @Test\n     public void testTab() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"NotEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"NotEscaped\"));\n+        }\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>BACKSPACE to be unescaped?\n     public void testEscapedBackspace() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n+        }\n     }\n \n     @Test\n     public void testBackspace() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"NotEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"NotEscaped\"));\n+        }\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>FF to be unescaped?\n     public void testEscapedFF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n+        }\n     }\n \n     @Test\n     public void testFF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"NotEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"NotEscaped\"));\n+        }\n     }\n \n     @Test\n     public void testEscapedMySqlNullValue() throws Exception {\n         // MySQL uses \\N to symbolize null values. We have to restore this\n-        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\NEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n+        }\n     }\n \n     @Test\n     public void testEscapedCharacter() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\aEscaped\", formatWithEscaping)) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n+        }\n     }\n \n     @Test\n     public void testEscapedControlCharacter() throws Exception {\n         // we are explicitly using an escape different from \\ here\n-        final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'))) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+        }\n     }\n \n     @Test\n     public void testEscapedControlCharacter2() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n-        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+        try (final Lexer lexer = createLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'))) {\n+            assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n+        }\n     }\n \n     @Test(expected = IOException.class)\n     public void testEscapingAtEOF() throws Exception {\n         final String code = \"escaping at EOF is evil\\\\\";\n-        final Lexer lexer = getLexer(code, formatWithEscaping);\n-\n-        lexer.nextToken(new Token());\n+        try (final Lexer lexer = createLexer(code, formatWithEscaping)) {\n+            lexer.nextToken(new Token());\n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n import java.util.zip.GZIPInputStream;\n \n import org.apache.commons.io.IOUtils;\n             System.out.println(String.format(\"Found test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n         } else {\n             System.out.println(\"Decompressing test fixture \" + BIG_FILE + \"...\");\n-            final InputStream input = new GZIPInputStream(new FileInputStream(\"src/test/resources/perf/worldcitiespop.txt.gz\"));\n-            final OutputStream output = new FileOutputStream(BIG_FILE);\n-            IOUtils.copy(input, output);\n-            input.close();\n-            output.close();\n+            try (final InputStream input = new GZIPInputStream(\n+                    new FileInputStream(\"src/test/resources/perf/worldcitiespop.txt.gz\"));\n+                    final OutputStream output = new FileOutputStream(BIG_FILE)) {\n+                IOUtils.copy(input, output);\n+            }\n             System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n         }\n         final int argc = args.length;\n         }\n     }\n \n-    private static BufferedReader getReader() throws IOException {\n+    private static BufferedReader createReader() throws IOException {\n         return new BufferedReader(new FileReader(BIG_FILE));\n     }\n \n     }\n \n     private static void testReadBigFile(final boolean split) throws Exception {\n-       for (int i = 0; i < max; i++) {\n-           final BufferedReader in = getReader();\n-           final long t0 = System.currentTimeMillis();\n-           final Stats s = readAll(in, split);\n-           in.close();\n-           show(split?\"file+split\":\"file\", s, t0);\n-       }\n-       show();\n-   }\n+        for (int i = 0; i < max; i++) {\n+            final long startMillis;\n+            final Stats stats;\n+            try (final BufferedReader in = createReader()) {\n+                startMillis = System.currentTimeMillis();\n+                stats = readAll(in, split);\n+            }\n+            show(split ? \"file+split\" : \"file\", stats, startMillis);\n+        }\n+        show();\n+    }\n \n    private static Stats readAll(final BufferedReader in, final boolean split) throws IOException {\n        int count = 0;\n        return new Stats(count, fields);\n    }\n \n-   private static void testExtendedBuffer(final boolean makeString) throws Exception {\n-       for (int i = 0; i < max; i++) {\n-           final ExtendedBufferedReader in = new ExtendedBufferedReader(getReader());\n-           final long t0 = System.currentTimeMillis();\n-           int read;\n-           int fields = 0;\n-           int lines = 0;\n-           if (makeString) {\n-               StringBuilder sb = new StringBuilder();\n-               while((read=in.read()) != -1) {\n-                   sb.append((char)read);\n-                   if (read == ',') { // count delimiters\n-                       sb.toString();\n-                       sb = new StringBuilder();\n-                       fields++;\n-                   } else if (read == '\\n') {\n-                       sb.toString();\n-                       sb = new StringBuilder();\n-                       lines++;\n-                   }\n-               }\n-           } else {\n-               while((read=in.read()) != -1) {\n-                   if (read == ',') { // count delimiters\n-                       fields++;\n-                   } else if (read == '\\n') {\n-                       lines++;\n-                   }\n-               }\n-           }\n-           fields += lines; // EOL is a delimiter too\n-           in.close();\n-           show(\"Extended\"+(makeString?\" toString\":\"\"), new Stats(lines, fields), t0);\n-       }\n-       show();\n-   }\n-\n-   private static void testParseCommonsCSV() throws Exception {\n-       for (int i = 0; i < max; i++) {\n-           final BufferedReader reader = getReader();\n-           final CSVParser parser = new CSVParser(reader, format);\n-           final long t0 = System.currentTimeMillis();\n-           final Stats s = iterate(parser);\n-           reader.close();\n-           show(\"CSV\", s, t0);\n-           parser.close();\n-       }\n-       show();\n-   }\n+    private static void testExtendedBuffer(final boolean makeString) throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            int fields = 0;\n+            int lines = 0;\n+            final long startMillis;\n+            try (final ExtendedBufferedReader in = new ExtendedBufferedReader(createReader())) {\n+                startMillis = System.currentTimeMillis();\n+                int read;\n+                if (makeString) {\n+                    StringBuilder sb = new StringBuilder();\n+                    while ((read = in.read()) != -1) {\n+                        sb.append((char) read);\n+                        if (read == ',') { // count delimiters\n+                            sb.toString();\n+                            sb = new StringBuilder();\n+                            fields++;\n+                        } else if (read == '\\n') {\n+                            sb.toString();\n+                            sb = new StringBuilder();\n+                            lines++;\n+                        }\n+                    }\n+                } else {\n+                    while ((read = in.read()) != -1) {\n+                        if (read == ',') { // count delimiters\n+                            fields++;\n+                        } else if (read == '\\n') {\n+                            lines++;\n+                        }\n+                    }\n+                }\n+                fields += lines; // EOL is a delimiter too\n+            }\n+            show(\"Extended\" + (makeString ? \" toString\" : \"\"), new Stats(lines, fields), startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static void testParseCommonsCSV() throws Exception {\n+        for (int i = 0; i < max; i++) {\n+            final long startMillis;\n+            final Stats stats;\n+            try (final BufferedReader reader = createReader()) {\n+                try (final CSVParser parser = new CSVParser(reader, format)) {\n+                    startMillis = System.currentTimeMillis();\n+                    stats = iterate(parser);\n+                }\n+                show(\"CSV\", stats, startMillis);\n+            }\n+        }\n+        show();\n+    }\n \n \n    private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\n        return lexer.getConstructor(new Class<?>[]{CSVFormat.class, ExtendedBufferedReader.class});\n    }\n \n-   private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\n-       Token token = new Token();\n-       String dynamic = \"\";\n-       for (int i = 0; i < max; i++) {\n-           final ExtendedBufferedReader input = new ExtendedBufferedReader(getReader());\n-           Lexer lexer = null;\n-           if (test.startsWith(\"CSVLexer\")) {\n-               dynamic=\"!\";\n-               lexer = getLexerCtor(test).newInstance(new Object[]{format, input});\n-           } else {\n-               lexer = new Lexer(format, input);\n-           }\n-           int count = 0;\n-           int fields = 0;\n-           final long t0 = System.currentTimeMillis();\n-           do {\n-               if (newToken) {\n-                   token = new Token();\n-               } else {\n-                   token.reset();\n-               }\n-               lexer.nextToken(token);\n-               switch(token.type) {\n-               case EOF:\n-                   break;\n-               case EORECORD:\n-                   fields++;\n-                   count++;\n-                   break;\n-               case INVALID:\n-                   throw new IOException(\"invalid parse sequence <\"+token.content.toString()+\">\");\n-               case TOKEN:\n-                   fields++;\n-                   break;\n-                case COMMENT: // not really expecting these\n-                    break;\n-                default:\n-                    throw new IllegalStateException(\"Unexpected Token type: \" + token.type);\n-              }\n-\n-           } while (!token.type.equals(Token.Type.EOF));\n-           final Stats s = new Stats(count, fields);\n-           input.close();\n-           show(lexer.getClass().getSimpleName()+dynamic+\" \"+(newToken ? \"new\" : \"reset\"), s, t0);\n-       }\n-       show();\n-   }\n+    private static void testCSVLexer(final boolean newToken, final String test) throws Exception {\n+        Token token = new Token();\n+        String dynamic = \"\";\n+        for (int i = 0; i < max; i++) {\n+            final String simpleName;\n+            final Stats stats;\n+            final long startMillis;\n+            try (final ExtendedBufferedReader input = new ExtendedBufferedReader(createReader());\n+                    Lexer lexer = createTestCSVLexer(test, input)) {\n+                if (test.startsWith(\"CSVLexer\")) {\n+                    dynamic = \"!\";\n+                }\n+                simpleName = lexer.getClass().getSimpleName();\n+                int count = 0;\n+                int fields = 0;\n+                startMillis = System.currentTimeMillis();\n+                do {\n+                    if (newToken) {\n+                        token = new Token();\n+                    } else {\n+                        token.reset();\n+                    }\n+                    lexer.nextToken(token);\n+                    switch (token.type) {\n+                    case EOF:\n+                        break;\n+                    case EORECORD:\n+                        fields++;\n+                        count++;\n+                        break;\n+                    case INVALID:\n+                        throw new IOException(\"invalid parse sequence <\" + token.content.toString() + \">\");\n+                    case TOKEN:\n+                        fields++;\n+                        break;\n+                    case COMMENT: // not really expecting these\n+                        break;\n+                    default:\n+                        throw new IllegalStateException(\"Unexpected Token type: \" + token.type);\n+                    }\n+                } while (!token.type.equals(Token.Type.EOF));\n+                stats = new Stats(count, fields);\n+            }\n+            show(simpleName + dynamic + \" \" + (newToken ? \"new\" : \"reset\"), stats, startMillis);\n+        }\n+        show();\n+    }\n+\n+    private static Lexer createTestCSVLexer(final String test, final ExtendedBufferedReader input)\n+            throws InstantiationException, IllegalAccessException, InvocationTargetException, Exception {\n+        return test.startsWith(\"CSVLexer\") ? getLexerCtor(test)\n+                .newInstance(new Object[] { format, input }) : new Lexer(format, input);\n+    }\n \n    private static Stats iterate(final Iterable<CSVRecord> it) {\n        int count = 0;\n--- a/src/test/java/org/apache/commons/csv/bugs/JiraCsv164Test.java\n+++ b/src/test/java/org/apache/commons/csv/bugs/JiraCsv164Test.java\n     @Test\n     public void testJiraCsv154_withCommentMarker() throws IOException {\n         final String comment = \"This is a header comment\";\n-        final CSVFormat format = CSVFormat.EXCEL.withHeader(\"H1\", \"H2\").withCommentMarker('#').withHeaderComments(comment);\n+        final CSVFormat format = CSVFormat.EXCEL.withHeader(\"H1\", \"H2\").withCommentMarker('#')\n+                .withHeaderComments(comment);\n         final StringBuilder out = new StringBuilder();\n-        final CSVPrinter printer = format.print(out);\n-        printer.print(\"A\");\n-        printer.print(\"B\");\n-        printer.close();\n+        try (final CSVPrinter printer = format.print(out)) {\n+            printer.print(\"A\");\n+            printer.print(\"B\");\n+        }\n         final String s = out.toString();\n         assertTrue(s, s.contains(comment));\n     }\n     @Test\n     public void testJiraCsv154_withHeaderComments() throws IOException {\n         final String comment = \"This is a header comment\";\n-        final CSVFormat format = CSVFormat.EXCEL.withHeader(\"H1\", \"H2\").withHeaderComments(comment).withCommentMarker('#');\n+        final CSVFormat format = CSVFormat.EXCEL.withHeader(\"H1\", \"H2\").withHeaderComments(comment)\n+                .withCommentMarker('#');\n         final StringBuilder out = new StringBuilder();\n-        final CSVPrinter printer = format.print(out);\n-        printer.print(\"A\");\n-        printer.print(\"B\");\n-        printer.close();\n+        try (final CSVPrinter printer = format.print(out)) {\n+            printer.print(\"A\");\n+            printer.print(\"B\");\n+        }\n         final String s = out.toString();\n         assertTrue(s, s.contains(comment));\n     }\n--- a/src/test/java/org/apache/commons/csv/bugs/JiraCsv167Test.java\n+++ b/src/test/java/org/apache/commons/csv/bugs/JiraCsv167Test.java\n \n     @Test\n     public void parse() throws IOException {\n-        final BufferedReader br = new BufferedReader(getTestInput());\n-        String s = null;\n         int totcomment = 0;\n         int totrecs = 0;\n-        boolean lastWasComment = false;\n-        while((s=br.readLine()) != null) {\n-            if (s.startsWith(\"#\")) {\n-                if (!lastWasComment) { // comments are merged\n-                    totcomment++;\n+        try (final BufferedReader br = new BufferedReader(getTestInput())) {\n+            String s = null;\n+            boolean lastWasComment = false;\n+            while ((s = br.readLine()) != null) {\n+                if (s.startsWith(\"#\")) {\n+                    if (!lastWasComment) { // comments are merged\n+                        totcomment++;\n+                    }\n+                    lastWasComment = true;\n+                } else {\n+                    totrecs++;\n+                    lastWasComment = false;\n                 }\n-                lastWasComment = true;\n-            } else {\n-                totrecs++;\n-                lastWasComment = false;\n             }\n         }\n-        br.close();\n         CSVFormat format = CSVFormat.DEFAULT;\n         //\n         format = format.withAllowMissingColumnNames(false);\n         format = format.withRecordSeparator('\\n');\n         format = format.withSkipHeaderRecord(false);\n         //\n-        final CSVParser parser = format.parse(getTestInput());\n         int comments = 0;\n         int records = 0;\n-        for (final CSVRecord csvRecord : parser) {\n-            records++;\n-            if (csvRecord.hasComment()) {\n-                comments++;\n+        try (final CSVParser parser = format.parse(getTestInput())) {\n+            for (final CSVRecord csvRecord : parser) {\n+                records++;\n+                if (csvRecord.hasComment()) {\n+                    comments++;\n+                }\n             }\n         }\n         // Comment lines are concatenated, in this example 4 lines become 2 comments.\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n             return;\n         }\n         System.out.println(\"Decompressing test fixture \" + BIG_FILE + \"...\");\n-        final InputStream input = new GZIPInputStream(new FileInputStream(\"src/test/resources/perf/worldcitiespop.txt.gz\"));\n-        final OutputStream output = new FileOutputStream(BIG_FILE);\n-        IOUtils.copy(input, output);\n-        System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n-        input.close();\n-        output.close();\n+        try (final InputStream input = new GZIPInputStream(\n+                new FileInputStream(\"src/test/resources/perf/worldcitiespop.txt.gz\"));\n+                final OutputStream output = new FileOutputStream(BIG_FILE)) {\n+            IOUtils.copy(input, output);\n+            System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n+        }\n     }\n \n-    private BufferedReader getBufferedReader() throws IOException {\n+    private BufferedReader createBufferedReader() throws IOException {\n         return new BufferedReader(new FileReader(BIG_FILE));\n     }\n \n \n     public long testParseBigFile(final boolean traverseColumns) throws Exception {\n         final long startMillis = System.currentTimeMillis();\n-        final long count = this.parse(this.getBufferedReader(), traverseColumns);\n+        final long count = this.parse(this.createBufferedReader(), traverseColumns);\n         final long totalMillis = System.currentTimeMillis() - startMillis;\n         this.println(String.format(\"File parsed in %,d milliseconds with Commons CSV: %,d lines.\", totalMillis, count));\n         return totalMillis;\n     public void testReadBigFile() throws Exception {\n         long bestTime = Long.MAX_VALUE;\n         for (int i = 0; i < this.max; i++) {\n-            final BufferedReader in = this.getBufferedReader();\n-            final long startMillis = System.currentTimeMillis();\n-            long count = 0;\n-            try {\n+            final long startMillis;\n+            long count;\n+            try (final BufferedReader in = this.createBufferedReader()) {\n+                startMillis = System.currentTimeMillis();\n+                count = 0;\n                 count = this.readAll(in);\n-            } finally {\n-                in.close();\n             }\n             final long totalMillis = System.currentTimeMillis() - startMillis;\n             bestTime = Math.min(totalMillis, bestTime);", "timestamp": 1465801009, "metainfo": ""}