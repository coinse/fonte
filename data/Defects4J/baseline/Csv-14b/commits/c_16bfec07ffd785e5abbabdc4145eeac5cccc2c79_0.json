{"sha": "16bfec07ffd785e5abbabdc4145eeac5cccc2c79", "log": "Turned the token types into an Enum  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n import java.util.ArrayList;\n import java.util.List;\n \n+import static org.apache.commons.csv.CSVParser.Token.Type.*;\n \n /**\n  * Parses CSV files according to the specified configuration.\n     /** length of the initial token (content-)buffer */\n     private static final int INITIAL_TOKEN_LENGTH = 50;\n \n-    // the token types\n-    /** Token has no valid content, i.e. is in its initialized state. */\n-    static final int TT_INVALID = -1;\n-    \n-    /** Token with content, at beginning or in the middle of a line. */\n-    static final int TT_TOKEN = 0;\n-    \n-    /** Token (which can have content) when end of file is reached. */\n-    static final int TT_EOF = 1;\n-    \n-    /** Token with content when end of a line is reached. */\n-    static final int TT_EORECORD = 2;\n-\n     /** Immutable empty String array. */\n     private static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n      * It is used as contract between the lexer and the parser.\n      */\n     static class Token {\n-        /**\n-         * Token type, see TT_xxx constants.\n-         */\n-        int type = TT_INVALID;\n-        /**\n-         * The content buffer.\n-         */\n+\n+        enum Type {\n+            /** Token has no valid content, i.e. is in its initialized state. */\n+            INVALID,\n+            \n+            /** Token with content, at beginning or in the middle of a line. */\n+            TOKEN,\n+            \n+            /** Token (which can have content) when end of file is reached. */\n+            EOF,\n+            \n+            /** Token with content when end of a line is reached. */\n+            EORECORD\n+        }\n+        \n+        /** Token type */\n+        Type type = INVALID;\n+        \n+        /** The content buffer. */\n         CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);\n-        /**\n-         * Token ready flag: indicates a valid token with content (ready for the parser).\n-         */\n+        \n+        /** Token ready flag: indicates a valid token with content (ready for the parser). */\n         boolean isReady;\n \n         Token reset() {\n             content.clear();\n-            type = TT_INVALID;\n+            type = INVALID;\n             isReady = false;\n             return this;\n         }\n             reusableToken.reset();\n             nextToken(reusableToken);\n             switch (reusableToken.type) {\n-                case TT_TOKEN:\n+                case TOKEN:\n                     record.add(reusableToken.content.toString());\n                     break;\n-                case TT_EORECORD:\n+                case EORECORD:\n                     record.add(reusableToken.content.toString());\n                     break;\n-                case TT_EOF:\n+                case EOF:\n                     if (reusableToken.isReady) {\n                         record.add(reusableToken.content.toString());\n                     } else {\n                         ret = null;\n                     }\n                     break;\n-                case TT_INVALID:\n+                case INVALID:\n                 default:\n                     // error: throw IOException\n                     throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n                     // unreachable: break;\n             }\n-            if (reusableToken.type != TT_TOKEN) {\n+            if (reusableToken.type != TOKEN) {\n                 break;\n             }\n         }\n             c = in.readAgain();\n             // reached end of file without any content (empty line at the end)\n             if (isEndOfFile(c)) {\n-                tkn.type = TT_EOF;\n+                tkn.type = EOF;\n                 return tkn;\n             }\n         }\n \n-        // did we reach eof during the last iteration already ? TT_EOF\n+        // did we reach eof during the last iteration already ? EOF\n         if (isEndOfFile(lastChar) || (lastChar != format.getDelimiter() && isEndOfFile(c))) {\n-            tkn.type = TT_EOF;\n+            tkn.type = EOF;\n             return tkn;\n         }\n \n         //  important: make sure a new char gets consumed in each iteration\n-        while (!tkn.isReady && tkn.type != TT_EOF) {\n+        while (!tkn.isReady && tkn.type != EOF) {\n             // ignore whitespaces at beginning of a token\n             while (format.isLeadingSpacesIgnored() && isWhitespace(c) && !eol) {\n                 wsBuf.append((char) c);\n                 in.readLine();\n                 tkn = nextToken(tkn.reset());\n             } else if (c == format.getDelimiter()) {\n-                // empty token return TT_TOKEN(\"\")\n-                tkn.type = TT_TOKEN;\n+                // empty token return TOKEN(\"\")\n+                tkn.type = TOKEN;\n                 tkn.isReady = true;\n             } else if (eol) {\n-                // empty token return TT_EORECORD(\"\")\n+                // empty token return EORECORD(\"\")\n                 //noop: tkn.content.append(\"\");\n-                tkn.type = TT_EORECORD;\n+                tkn.type = EORECORD;\n                 tkn.isReady = true;\n             } else if (c == format.getEncapsulator()) {\n                 // consume encapsulated token\n                 encapsulatedTokenLexer(tkn, c);\n             } else if (isEndOfFile(c)) {\n-                // end of file return TT_EOF()\n+                // end of file return EOF()\n                 //noop: tkn.content.append(\"\");\n-                tkn.type = TT_EOF;\n+                tkn.type = EOF;\n                 tkn.isReady = true;\n             } else {\n                 // next token must be a simple token\n      * A simple token might contain escaped delimiters (as \\, or \\;). The\n      * token is finished when one of the following conditions become true:\n      * <ul>\n-     * <li>end of line has been reached (TT_EORECORD)</li>\n-     * <li>end of stream has been reached (TT_EOF)</li>\n-     * <li>an unescaped delimiter has been reached (TT_TOKEN)</li>\n+     * <li>end of line has been reached (EORECORD)</li>\n+     * <li>end of stream has been reached (EOF)</li>\n+     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n      * </ul>\n      *\n      * @param tkn the current token\n         for (; ;) {\n             if (isEndOfLine(c)) {\n                 // end of record\n-                tkn.type = TT_EORECORD;\n+                tkn.type = EORECORD;\n                 tkn.isReady = true;\n                 break;\n             } else if (isEndOfFile(c)) {\n                 // end of file\n-                tkn.type = TT_EOF;\n+                tkn.type = EOF;\n                 tkn.isReady = true;\n                 break;\n             } else if (c == format.getDelimiter()) {\n                 // end of token\n-                tkn.type = TT_TOKEN;\n+                tkn.type = TOKEN;\n                 tkn.isReady = true;\n                 break;\n             } else if (c == '\\\\' && format.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n                     for (; ;) {\n                         c = in.read();\n                         if (c == format.getDelimiter()) {\n-                            tkn.type = TT_TOKEN;\n+                            tkn.type = TOKEN;\n                             tkn.isReady = true;\n                             return tkn;\n                         } else if (isEndOfFile(c)) {\n-                            tkn.type = TT_EOF;\n+                            tkn.type = EOF;\n                             tkn.isReady = true;\n                             return tkn;\n                         } else if (isEndOfLine(c)) {\n                             // ok eo token reached\n-                            tkn.type = TT_EORECORD;\n+                            tkn.type = EORECORD;\n                             tkn.isReady = true;\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.apache.commons.csv;\n \n import java.io.IOException;\n import java.util.Arrays;\n \n import junit.framework.TestCase;\n+\n+import static org.apache.commons.csv.CSVParser.Token.Type.*;\n \n /**\n  * CSVParserTest\n          */\n         public String testNextToken() throws IOException {\n             Token t = super.nextToken();\n-            return Integer.toString(t.type) + \";\" + t.content + \";\";\n+            return t.type.name() + \";\" + t.content + \";\";\n         }\n     }\n \n     public void testNextToken1() throws IOException {\n         String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n         TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-        assertEquals(CSVParser.TT_TOKEN + \";abc;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";def;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";hijk;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";lmnop;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";qrst;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";uv;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";wxy;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";z;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";abc;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";def;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";hijk;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";lmnop;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";qrst;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";uv;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";wxy;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";z;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(EOF + \";;\", parser.testNextToken());\n     }\n \n     // multiline including comments (and empty lines)\n         TestCSVParser parser = new TestCSVParser(new StringReader(code), format);\n \n \n-        assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";2;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";3;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";b x;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";c;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";d;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";e;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";1;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";2;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";3;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";b x;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";c;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";d;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";e;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";;\", parser.testNextToken());\n+        assertEquals(EOF + \";;\", parser.testNextToken());\n+        assertEquals(EOF + \";;\", parser.testNextToken());\n \n     }\n \n         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n         TestCSVParser parser = new TestCSVParser(new StringReader(code), format);\n \n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n         // an unquoted single backslash is not an escape char\n-        assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";\\\\;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n         // an unquoted single backslash is not an escape char\n-        assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";\\\\;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(EOF + \";;\", parser.testNextToken());\n     }\n \n     // encapsulator tokenizer (sinle line)\n         String code =\n                 \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n         TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";foo;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \"; foo;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";foo ;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \"; foo ;\", parser.testNextToken());\n-//     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";b;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";foo;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \"; foo;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";foo ;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \"; foo ;\", parser.testNextToken());\n+//     assertEquals(EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(EOF + \";b;\", parser.testNextToken());\n     }\n \n     // encapsulator tokenizer (multi line, delimiter in string)\n         String code =\n                 \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n         TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\",\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";foo\\n;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(EORECORD + \";foo\\n  baar ,,,;\",\n                 parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";\\n\\t \\n;\", parser.testNextToken());\n+        assertEquals(EOF + \";\\n\\t \\n;\", parser.testNextToken());\n \n     }\n \n         */\n         String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n         TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVFormat(';', '\\'', '!'));\n-        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";a;\", parser.testNextToken());\n         assertEquals(\n-                CSVParser.TT_EORECORD + \";b and ' more\\n;\",\n+                EORECORD + \";b and ' more\\n;\",\n                 parser.testNextToken());\n     }\n \n \n     public void testGetLine() throws IOException {\n         CSVParser parser = new CSVParser(new StringReader(code));\n-        String[] tmp = null;\n-        for (int i = 0; i < res.length; i++) {\n-            tmp = parser.getLine();\n-            assertTrue(Arrays.equals(res[i], tmp));\n-        }\n-        tmp = parser.getLine();\n-        assertTrue(tmp == null);\n+        for (String[] re : res) {\n+            assertTrue(Arrays.equals(re, parser.getLine()));\n+        }\n+        \n+        assertTrue(parser.getLine() == null);\n     }\n \n     public void testGetAllValues() throws IOException {\n                 {\"\"},  // Excel format does not ignore empty lines\n                 {\"world\", \"\"}\n         };\n-        String code;\n-        for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n-            code = codes[codeIndex];\n+        \n+        for (String code : codes) {\n             CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.EXCEL);\n             String[][] tmp = parser.getAllValues();\n             assertEquals(res.length, tmp.length);\n     public void testDelimiterIsWhitespace() throws IOException {\n         String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n         TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVFormat.TDF);\n-        assertEquals(CSVParser.TT_TOKEN + \";one;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";two;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";four;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_TOKEN + \";five;\", parser.testNextToken());\n-        assertEquals(CSVParser.TT_EOF + \";six;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";one;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";two;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";four;\", parser.testNextToken());\n+        assertEquals(TOKEN + \";five;\", parser.testNextToken());\n+        assertEquals(EOF + \";six;\", parser.testNextToken());\n     }\n }", "timestamp": 1320858682, "metainfo": ""}