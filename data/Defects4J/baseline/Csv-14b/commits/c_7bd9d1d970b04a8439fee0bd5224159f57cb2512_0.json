{"sha": "7bd9d1d970b04a8439fee0bd5224159f57cb2512", "log": "Updated the Javadoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      */\n     public static final char DISABLED = '\\ufffe';\n \n-    /** Standard comma separated format as defined by RFC 4180. */\n+    /** Standard comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>. */\n     public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, false, true);\n \n     /** Excel file format (using a comma as the value delimiter). */\n \n \n     /**\n-     * Creates a CSVFormat with the default parameters.\n+     * Creates a CSV format with the default parameters.\n      */\n     public CSVFormat() {\n     }\n \n+    /**\n+     * Creates a customized CSV format.\n+     * \n+     * @param delimiter                 the char used for value separation\n+     * @param encapsulator              the char used as value encapsulation marker\n+     * @param commentStart              the char used for comment identification\n+     */\n     public CSVFormat(char delimiter, char encapsulator, char commentStart) {\n         this(delimiter, encapsulator, commentStart, DISABLED, true, true, false, true);\n     }\n \n     /**\n-     * Customized CSV format constructor.\n+     * Creates a customized CSV format.\n      *\n-     * @param delimiter                 a char used for value separation\n-     * @param encapsulator              a char used as value encapsulation marker\n-     * @param commentStart              a char used for comment identification\n-     * @param escape                    a char used to escape special characters in values\n-     * @param leadingSpacesIgnored      TRUE when leading whitespaces should be ignored\n-     * @param trailingSpacesIgnored     TRUE when trailing whitespaces should be ignored\n-     * @param unicodeEscapesInterpreted TRUE when unicode escapes should be interpreted\n-     * @param emptyLinesIgnored         TRUE when the parser should skip emtpy lines\n+     * @param delimiter                 the char used for value separation\n+     * @param encapsulator              the char used as value encapsulation marker\n+     * @param commentStart              the char used for comment identification\n+     * @param escape                    the char used to escape special characters in values\n+     * @param leadingSpacesIgnored      <tt>true</tt> when leading whitespaces should be ignored\n+     * @param trailingSpacesIgnored     <tt>true</tt> when trailing whitespaces should be ignored\n+     * @param unicodeEscapesInterpreted <tt>true</tt> when unicode escapes should be interpreted\n+     * @param emptyLinesIgnored         <tt>true</tt> when the parser should skip emtpy lines\n      */\n     public CSVFormat(\n             char delimiter,\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     /** Immutable empty String array. */\n     private static final String[] EMPTY_STRING_ARRAY = new String[0];\n \n-    // the input stream\n+    /** The input stream */\n     private final ExtendedBufferedReader in;\n \n     private final CSVFormat format;\n \n     // the following objects are shared to reduce garbage\n-    /**\n-     * A record buffer for getLine(). Grows as necessary and is reused.\n-     */\n+    \n+    /** A record buffer for getLine(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n     private final Token reusableToken = new Token();\n     private final CharBuffer wsBuf = new CharBuffer();\n     // ======================================================\n \n     /**\n-     * Parses the CSV according to the given format\n-     * and returns the content as an array of records\n-     * (whereas records are arrays of single values).\n-     * <p/>\n-     * The returned content starts at the current parse-position in\n-     * the stream.\n+     * Parses the CSV according to the given format and returns the content\n+     * as an array of records (whereas records are arrays of single values).\n+     * <p/>\n+     * The returned content starts at the current parse-position in the stream.\n      *\n      * @return matrix of records x values ('null' when end of file)\n      * @throws IOException on parse error or input read-failure\n     }\n \n     /**\n-     * Parses from the current point in the stream til\n-     * the end of the current line.\n-     *\n-     * @return array of values til end of line\n-     *         ('null' when end of file has been reached)\n+     * Parses from the current point in the stream til * the end of the current line.\n+     *\n+     * @return array of values til end of line ('null' when end of file has been reached)\n      * @throws IOException on parse error or input read-failure\n      */\n     String[] getLine() throws IOException {\n             }\n         }\n         if (!record.isEmpty()) {\n-            ret = (String[]) record.toArray(new String[record.size()]);\n+            ret = record.toArray(new String[record.size()]);\n         }\n         return ret;\n     }\n     /**\n      * Returns the next token.\n      * <p/>\n-     * A token corresponds to a term, a record change or an\n-     * end-of-file indicator.\n-     *\n-     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the\n-     *            Token.\n+     * A token corresponds to a term, a record change or an end-of-file indicator.\n+     *\n+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the Token.\n      * @return the next token found\n      * @throws IOException on stream access error\n      */\n      * A simple token might contain escaped delimiters (as \\, or \\;). The\n      * token is finished when one of the following conditions become true:\n      * <ul>\n-     * <li>end of line has been reached (EORECORD)</li>\n-     * <li>end of stream has been reached (EOF)</li>\n-     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n+     *   <li>end of line has been reached (EORECORD)</li>\n+     *   <li>end of stream has been reached (EOF)</li>\n+     *   <li>an unescaped delimiter has been reached (TOKEN)</li>\n      * </ul>\n      *\n      * @param tkn the current token\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\n-                                    \"(line \" + getLineNumber()\n-                                            + \") invalid char between encapsulated token end delimiter\"\n-                            );\n+                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n                         }\n                     }\n                 }\n             } else if (isEndOfFile(c)) {\n                 // error condition (end of file before end of token)\n-                throw new IOException(\n-                        \"(startline \" + startLineNumber + \")\"\n-                                + \"eof reached before encapsulated token finished\"\n-                );\n+                throw new IOException(\"(startline \" + startLineNumber + \") EOF reached before encapsulated token finished\");\n             } else {\n                 // consume character\n                 tkn.content.append((char) c);\n     /**\n      * Decodes Unicode escapes.\n      * <p/>\n-     * Interpretation of \"\\\\uXXXX\" escape sequences\n-     * where XXXX is a hex-number.\n+     * Interpretation of \"\\\\uXXXX\" escape sequences where XXXX is a hex-number.\n      *\n      * @param c current char which is discarded because it's the \"\\\\\" of \"\\\\uXXXX\"\n      * @return the decoded character\n         return out;\n     }\n \n-    // ======================================================\n-    //  strategies\n-    // ======================================================\n-\n     /**\n      * Obtain the specified CSV format.\n      *", "timestamp": 1330952899, "metainfo": ""}