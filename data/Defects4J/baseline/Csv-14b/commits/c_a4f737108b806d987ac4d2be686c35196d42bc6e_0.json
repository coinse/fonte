{"sha": "a4f737108b806d987ac4d2be686c35196d42bc6e", "log": "[CSV-130] CSVFormat#withHeader doesn't work well with #printComment, add withHeaderComments(String...)  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private final String recordSeparator; // for outputs\n     private final String nullString; // the string to be used for null values\n     private final String[] header; // array of header column names\n+    private final String[] headerComments; // array of header comment lines\n     private final boolean skipHeaderRecord;\n \n     /**\n      * </ul>\n      */\n     public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n-                                                            false, true, CRLF, null, null, false, false);\n+                                                            false, true, CRLF, null, null, null, false, false);\n \n     /**\n      * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n      * @see #TDF\n      */\n     public static CSVFormat newFormat(final char delimiter) {\n-        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n+        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false);\n     }\n \n     /**\n      *            the line separator to use for output\n      * @param nullString\n      *            the line separator to use for output\n+     * @param toHeaderComments TODO\n      * @param header\n      *            the header\n      * @param skipHeaderRecord TODO\n             final QuoteMode quoteMode, final Character commentStart,\n             final Character escape, final boolean ignoreSurroundingSpaces,\n             final boolean ignoreEmptyLines, final String recordSeparator,\n-            final String nullString, final String[] header, final boolean skipHeaderRecord,\n-            final boolean allowMissingColumnNames) {\n+            final String nullString, final Object[] headerComments, final String[] header,\n+            final boolean skipHeaderRecord, final boolean allowMissingColumnNames) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         this.ignoreEmptyLines = ignoreEmptyLines;\n         this.recordSeparator = recordSeparator;\n         this.nullString = nullString;\n+        this.headerComments = toStringArray(headerComments);\n         if (header == null) {\n             this.header = null;\n         } else {\n         validate();\n     }\n \n+    private String[] toStringArray(Object[] values) {\n+        if (values == null) {\n+            return null;\n+        }\n+        String[] strings = new String[values.length];\n+        for (int i = 0; i < values.length; i++) {\n+            Object value = values[i];\n+            strings[i] = value == null ? null : value.toString();\n+        }\n+        return strings;\n+    }\n+\n     @Override\n     public boolean equals(final Object obj) {\n         if (this == obj) {\n      */\n     public String[] getHeader() {\n         return header != null ? header.clone() : null;\n+    }\n+\n+    /**\n+     * Returns a copy of the header comment array.\n+     *\n+     * @return a copy of the header comment array; {@code null} if disabled.\n+     */\n+    public String[] getHeaderComments() {\n+        return headerComments != null ? headerComments.clone() : null;\n     }\n \n     /**\n             sb.append(\" SurroundingSpaces:ignored\");\n         }\n         sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n+        if (headerComments != null) {\n+            sb.append(' ');\n+            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n+        }\n         if (header != null) {\n             sb.append(' ');\n             sb.append(\"Header:\").append(Arrays.toString(header));\n             throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n+    }\n+\n+    /**\n+     * Sets the header comments of the format. The comments will be printed first, before the headers.\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeaderComments(\"Generated by Apache Commons CSV 1.1.\", new Date());</pre>\n+     *\n+     * @param header\n+     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified header\n+     * @see #withSkipHeaderRecord(boolean)\n+     * @since 1.1\n+     */\n+    public CSVFormat withHeaderComments(final Object... headerComments) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withNullString(final String nullString) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n-                allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n+                skipHeaderRecord, allowMissingColumnNames);\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n      * </p>\n      *\n      * @param out\n-     *        stream to which to print. Must not be null.\n+     *            stream to which to print. Must not be null.\n      * @param format\n-     *        the CSV format. Must not be null.\n-     * @throws IOException\n-     *         thrown if the optional header cannot be printed.\n+     *            the CSV format. Must not be null.\n+     * @throws IOException\n+     *             thrown if the optional header cannot be printed.\n      * @throws IllegalArgumentException\n-     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n+     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n      */\n     public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n         Assertions.notNull(out, \"out\");\n         this.format = format;\n         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n         // It seems a pain to have to track whether the header has already been printed or not.\n+        if (format.getHeaderComments() != null) {\n+            for (String line : format.getHeaderComments()) {\n+                if (line != null) {\n+                    this.printComment(line);\n+                }\n+            }\n+        }\n         if (format.getHeader() != null) {\n             this.printRecord((Object[]) format.getHeader());\n         }\n         this.print(value, strValue, 0, strValue.length());\n     }\n \n-    private void print(final Object object, final CharSequence value,\n-            final int offset, final int len) throws IOException {\n+    private void print(final Object object, final CharSequence value, final int offset, final int len)\n+            throws IOException {\n         if (!newRecord) {\n             out.append(format.getDelimiter());\n         }\n      * Note: must only be called if quoting is enabled, otherwise will generate NPE\n      */\n     // the original object is needed so can check for Number\n-    private void printAndQuote(final Object object, final CharSequence value,\n-            final int offset, final int len) throws IOException {\n+    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len)\n+            throws IOException {\n         boolean quote = false;\n         int start = offset;\n         int pos = offset;\n     /**\n      * Prints all the objects in the given collection handling nested collections/arrays as records.\n      *\n-     * <p>If the given collection only contains simple objects, this method will print a single record like\n+     * <p>\n+     * If the given collection only contains simple objects, this method will print a single record like\n      * {@link #printRecord(Iterable)}. If the given collections contains nested collections/arrays those nested elements\n-     * will each be printed as records using {@link #printRecord(Object...)}.</p>\n-     *\n-     * <p>Given the following data structure:</p>\n+     * will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     * \n      * <pre>\n      * <code>\n      * List&lt;String[]&gt; data = ...\n      * </code>\n      * </pre>\n      *\n-     * <p>Calling this method will print:</p>\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     * \n      * <pre>\n      * <code>\n      * A, B, C\n     /**\n      * Prints all the objects in the given array handling nested collections/arrays as records.\n      *\n-     * <p>If the given array only contains simple objects, this method will print a single record like\n+     * <p>\n+     * If the given array only contains simple objects, this method will print a single record like\n      * {@link #printRecord(Object...)}. If the given collections contains nested collections/arrays those nested\n-     * elements will each be printed as records using {@link #printRecord(Object...)}.</p>\n-     *\n-     * <p>Given the following data structure:</p>\n+     * elements will each be printed as records using {@link #printRecord(Object...)}.\n+     * </p>\n+     *\n+     * <p>\n+     * Given the following data structure:\n+     * </p>\n+     * \n      * <pre>\n      * <code>\n      * String[][] data = new String[3][]\n      * </code>\n      * </pre>\n      *\n-     * <p>Calling this method will print:</p>\n+     * <p>\n+     * Calling this method will print:\n+     * </p>\n+     * \n      * <pre>\n      * <code>\n      * A, B, C\n     /**\n      * Prints all the objects in the given JDBC result set.\n      *\n-     * @param resultSet result set\n-     *            the values to print.\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     * @throws SQLException if a database access error occurs\n+     * @param resultSet\n+     *            result set the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     * @throws SQLException\n+     *             if a database access error occurs\n      */\n     public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n         final int columnCount = resultSet.getMetaData().getColumnCount();\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n import java.sql.SQLException;\n import java.sql.Statement;\n import java.util.Arrays;\n+import java.util.Date;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Random;\n     }\n \n     @Test\n+    public void testHeaderCommentExcel() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        Date now = new Date();\n+        CSVFormat format = CSVFormat.EXCEL;\n+        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n+        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\n+        csvPrinter.close();\n+    }\n+\n+    @Test\n+    public void testHeaderCommentTdf() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        Date now = new Date();\n+        CSVFormat format = CSVFormat.TDF;\n+        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n+        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\n+        csvPrinter.close();\n+    }\n+\n+    private CSVPrinter printWithHeaderComments(final StringWriter sw, Date now, CSVFormat format)\n+            throws IOException {\n+        format = format.withCommentMarker('#').withHeader(\"Col1\", \"Col2\");\n+        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n+        final CSVPrinter csvPrinter = format.print(sw);\n+        csvPrinter.printRecord(\"A\", \"B\");\n+        csvPrinter.printRecord(\"C\", \"D\");\n+        csvPrinter.close();\n+        return csvPrinter;\n+    }\n+\n+    @Test\n     public void testEOLPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n         final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));", "timestamp": 1410353282, "metainfo": ""}