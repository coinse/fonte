{"sha": "a4c1a85d9db8ae782af49a26196d4e3ec4b68011", "log": "Sort members.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n         }\n     };\n     \n-    private static final long serialVersionUID = 1L;\n-\n-    private final char delimiter;\n-    private final Character quoteCharacter; // null if quoting is disabled\n-    private final QuoteMode quoteMode;\n-    private final Character commentMarker; // null if commenting is disabled\n-    private final Character escapeCharacter; // null if escaping is disabled\n-    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n-    private final boolean allowMissingColumnNames;\n-    private final boolean ignoreEmptyLines;\n-    private final String recordSeparator; // for outputs\n-    private final String nullString; // the string to be used for null values\n-    private final String[] header; // array of header column names\n-    private final String[] headerComments; // array of header comment lines\n-    private final boolean skipHeaderRecord;\n-    private final boolean ignoreHeaderCase; // should ignore header names case\n-\n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n      *\n             CRLF, null, null, null, false, false, false);\n \n     /**\n-     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n-     *\n-     * <p>\n-     * Settings are:\n-     * </p>\n-     * <ul>\n-     * <li>withDelimiter(',')</li>\n-     * <li>withQuote('\"')</li>\n-     * <li>withRecordSeparator(\"\\r\\n\")</li>\n-     * <li>withIgnoreEmptyLines(false)</li>\n-     * </ul>\n-     * @see Predefined#RFC4180\n-     */\n-    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n-\n-    /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n      * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n      *\n      * @see Predefined#Excel\n      */\n     public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n-\n-    /**\n-     * Tab-delimited format.\n-     *\n-     * <p>\n-     * Settings are:\n-     * </p>\n-     * <ul>\n-     * <li>withDelimiter('\\t')</li>\n-     * <li>withQuote('\"')</li>\n-     * <li>withRecordSeparator(\"\\r\\n\")</li>\n-     * <li>withIgnoreSurroundingSpaces(true)</li>\n-     * </ul>\n-     * @see Predefined#TDF\n-     */\n-    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n-\n     /**\n      * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n      *\n      */\n     public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n             .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n-\n+    /**\n+     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n+     *\n+     * <p>\n+     * Settings are:\n+     * </p>\n+     * <ul>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuote('\"')</li>\n+     * <li>withRecordSeparator(\"\\r\\n\")</li>\n+     * <li>withIgnoreEmptyLines(false)</li>\n+     * </ul>\n+     * @see Predefined#RFC4180\n+     */\n+    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n+    private static final long serialVersionUID = 1L;\n+    /**\n+     * Tab-delimited format.\n+     *\n+     * <p>\n+     * Settings are:\n+     * </p>\n+     * <ul>\n+     * <li>withDelimiter('\\t')</li>\n+     * <li>withQuote('\"')</li>\n+     * <li>withRecordSeparator(\"\\r\\n\")</li>\n+     * <li>withIgnoreSurroundingSpaces(true)</li>\n+     * </ul>\n+     * @see Predefined#TDF\n+     */\n+    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n     /**\n      * Returns true if the given character is a line break character.\n      *\n     private static boolean isLineBreak(final char c) {\n         return c == LF || c == CR;\n     }\n-\n     /**\n      * Returns true if the given character is a line break character.\n      *\n     private static boolean isLineBreak(final Character c) {\n         return c != null && isLineBreak(c.charValue());\n     }\n-\n     /**\n      * Creates a new CSV format with the specified delimiter.\n      *\n     public static CSVFormat newFormat(final char delimiter) {\n         return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n     }\n-\n     /**\n      * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n      * \n     public static CSVFormat valueOf(final String format) {\n         return CSVFormat.Predefined.valueOf(format).getFormat();\n     }\n+    private final boolean allowMissingColumnNames;\n+    private final Character commentMarker; // null if commenting is disabled\n+    private final char delimiter;\n+    private final Character escapeCharacter; // null if escaping is disabled\n+    private final String[] header; // array of header column names\n+\n+    private final String[] headerComments; // array of header comment lines\n+\n+    private final boolean ignoreEmptyLines;\n+\n+    private final boolean ignoreHeaderCase; // should ignore header names case\n+\n+    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n+\n+    private final String nullString; // the string to be used for null values\n+\n+    private final Character quoteCharacter; // null if quoting is disabled\n+\n+    private final QuoteMode quoteMode;\n+\n+    private final String recordSeparator; // for outputs\n+\n+    private final boolean skipHeaderRecord;\n \n     /**\n      * Creates a customized CSV format.\n         validate();\n     }\n \n-    private String[] toStringArray(final Object[] values) {\n-        if (values == null) {\n-            return null;\n-        }\n-        final String[] strings = new String[values.length];\n-        for (int i = 0; i < values.length; i++) {\n-            final Object value = values[i];\n-            strings[i] = value == null ? null : value.toString();\n-        }\n-        return strings;\n-    }\n-\n     @Override\n     public boolean equals(final Object obj) {\n         if (this == obj) {\n     }\n \n     /**\n+     * Specifies whether missing column names are allowed when parsing the header line.\n+     *\n+     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n+     *         {@link IllegalArgumentException}.\n+     */\n+    public boolean getAllowMissingColumnNames() {\n+        return allowMissingColumnNames;\n+    }\n+\n+    /**\n      * Returns the character marking the start of a line comment.\n      *\n      * @return the comment start marker, may be {@code null}\n     }\n \n     /**\n-     * Specifies whether missing column names are allowed when parsing the header line.\n-     *\n-     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n-     *         {@link IllegalArgumentException}.\n-     */\n-    public boolean getAllowMissingColumnNames() {\n-        return allowMissingColumnNames;\n-    }\n-\n-    /**\n      * Specifies whether empty lines between records are ignored when parsing input.\n      *\n      * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     }\n \n     /**\n+     * Specifies whether header names will be accessed ignoring case.\n+     *\n+     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n+     */\n+    public boolean getIgnoreHeaderCase() {\n+        return ignoreHeaderCase;\n+    }\n+\n+    /**\n      * Specifies whether spaces around values are ignored when parsing input.\n      *\n      * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n      */\n     public boolean getIgnoreSurroundingSpaces() {\n         return ignoreSurroundingSpaces;\n-    }\n-\n-    /**\n-     * Specifies whether header names will be accessed ignoring case.\n-     *\n-     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n-     */\n-    public boolean getIgnoreHeaderCase() {\n-        return ignoreHeaderCase;\n     }\n \n     /**\n         return sb.toString();\n     }\n \n+    private String[] toStringArray(final Object[] values) {\n+        if (values == null) {\n+            return null;\n+        }\n+        final String[] strings = new String[values.length];\n+        for (int i = 0; i < values.length; i++) {\n+            final Object value = values[i];\n+            strings[i] = value == null ? null : value.toString();\n+        }\n+        return strings;\n+    }\n+\n     /**\n      * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n      *\n     }\n \n     /**\n+     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n+     * @see #withAllowMissingColumnNames(boolean)\n+     * @since 1.1\n+     */\n+    public CSVFormat withAllowMissingColumnNames() {\n+        return this.withAllowMissingColumnNames(true);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n+     *\n+     * @param allowMissingColumnNames\n+     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n+     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n+     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n+     */\n+    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+    }\n+\n+    /**\n      * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n      *\n      * Note that the comment start character is only recognized at the start of a line.\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                 allowMissingColumnNames, ignoreHeaderCase);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with the header of the format set to the given values. \n-     * The header can either be parsed automatically from the input file with:\n-     *\n-     * <pre>\n-     * CSVFormat format = aformat.withHeader();\n-     * </pre>\n-     *\n-     * or specified manually with:\n-     *\n-     * <pre>\n-     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n-     * </pre>\n-     * <p>\n-     * The header is also used by the {@link CSVPrinter}..\n-     * </p>\n-     *\n-     * @param header\n-     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n-     *\n-     * @return A new CSVFormat that is equal to this but with the specified header\n-     * @see #withSkipHeaderRecord(boolean)\n-     */\n-    public CSVFormat withHeader(final String... header) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n     }\n \n     /**\n     }\n \n     /**\n+     * Returns a new {@code CSVFormat} with the header of the format set to the given values. \n+     * The header can either be parsed automatically from the input file with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader();\n+     * </pre>\n+     *\n+     * or specified manually with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n+     * </pre>\n+     * <p>\n+     * The header is also used by the {@link CSVPrinter}..\n+     * </p>\n+     *\n+     * @param header\n+     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified header\n+     * @see #withSkipHeaderRecord(boolean)\n+     */\n+    public CSVFormat withHeader(final String... header) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+    }\n+\n+    /**\n      * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. \n      * The comments will be printed first, before the headers. This setting is ignored by the parser.\n      *\n     }\n \n     /**\n-     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n-     *\n-     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n-     * @see #withAllowMissingColumnNames(boolean)\n-     * @since 1.1\n-     */\n-    public CSVFormat withAllowMissingColumnNames() {\n-        return this.withAllowMissingColumnNames(true);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n-     *\n-     * @param allowMissingColumnNames\n-     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n-     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n-     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n-     */\n-    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n-    }\n-\n-    /**\n      * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n      *\n      * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     }\n \n     /**\n+     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n+     *\n+     * @return A new CSVFormat that will ignore case header name.\n+     * @see #withIgnoreHeaderCase(boolean)\n+     * @since ?\n+     */\n+    public CSVFormat withIgnoreHeaderCase() {\n+        return this.withIgnoreHeaderCase(true);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n+     *\n+     * @param ignoreHeaderCase\n+     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the\n+     *            mapping as is.\n+     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n+     */\n+    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+    }\n+\n+    /**\n      * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n      *\n      * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n      * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n-     *\n-     * @return A new CSVFormat that will ignore case header name.\n-     * @see #withIgnoreHeaderCase(boolean)\n-     * @since ?\n-     */\n-    public CSVFormat withIgnoreHeaderCase() {\n-        return this.withIgnoreHeaderCase(true);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n-     *\n-     * @param ignoreHeaderCase\n-     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the\n-     *            mapping as is.\n-     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n-     */\n-    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                 skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);", "timestamp": 1460941323, "metainfo": ""}