{"sha": "69cdb8a227351341e9716b5329078eee6289a747", "log": "CSV-124 apply provided patch and update unit tests  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n         return putIn(new HashMap<String, String>(values.length));\n     }\n \n-    /**\n-     * Returns a string representation of the contents of this record. The result is constructed by passing the internal\n-     * values array to {@link Arrays#toString(Object[])}.\n+\n+    /**\n+     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n+     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n      *\n      * @return a String representation of this record.\n      */\n     @Override\n     public String toString() {\n-        return Arrays.toString(values);\n+        return \"CSVRecord [comment=\" + comment + \", mapping=\" + mapping +\n+                \", recordNumber=\" + recordNumber + \", values=\" +\n+                Arrays.toString(values) + \"]\";\n     }\n \n     String[] values() {\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n import java.net.URL;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n     private static final File BASE = new File(\"src/test/resources/CSVFileParser\");\n \n     private final BufferedReader testData;\n+\n     private final String testName;\n \n-    public CSVFileParserTest(final File file) throws FileNotFoundException\n-    {\n-       this.testName = file.getName();\n-       this.testData = new BufferedReader(new FileReader(file));\n+    public CSVFileParserTest(final File file) throws FileNotFoundException {\n+        this.testName = file.getName();\n+        this.testData = new BufferedReader(new FileReader(file));\n     }\n \n     private String readTestData() throws IOException {\n     }\n \n     @Parameters\n-    public static Collection<Object[]> generateData()\n-    {\n+    public static Collection<Object[]> generateData() {\n         final List<Object[]> list = new ArrayList<Object[]>();\n \n         final FilenameFilter filenameFilter = new FilenameFilter() {\n+\n+            @Override\n             public boolean accept(final File dir, final String name) {\n                 return name.startsWith(\"test\") && name.endsWith(\".txt\");\n             }\n         };\n         final File[] files = BASE.listFiles(filenameFilter);\n-        for(final File f : files){\n-            list.add(new Object[]{f});\n+        for (final File f : files) {\n+            list.add(new Object[] {\n+                f\n+            });\n         }\n         return list;\n     }\n         String line = readTestData();\n         assertNotNull(\"file must contain config line\", line);\n         final String[] split = line.split(\" \");\n-        assertTrue(testName+\" require 1 param\", split.length >= 1);\n-         // first line starts with csv data file name\n+        assertTrue(testName + \" require 1 param\", split.length >= 1);\n+        // first line starts with csv data file name\n         CSVFormat format = CSVFormat.newFormat(',').withQuote('\"');\n         boolean checkComments = false;\n-        for(int i=1; i < split.length; i++) {\n+        for (int i = 1; i < split.length; i++) {\n             final String option = split[i];\n-            final String[] option_parts = option.split(\"=\",2);\n-            if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])){\n+            final String[] option_parts = option.split(\"=\", 2);\n+            if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])) {\n                 format = format.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n                 format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n                 checkComments = true;\n             } else {\n-                fail(testName+\" unexpected option: \"+option);\n+                fail(testName + \" unexpected option: \" + option);\n             }\n         }\n         line = readTestData(); // get string version of format\n-        assertEquals(testName+\" Expected format \", line, format.toString());\n+        assertEquals(testName + \" Expected format \", line, format.toString());\n \n         // Now parse the file and compare against the expected results\n         // We use a buffered reader internally so no need to create one here.\n         final CSVParser parser = CSVParser.parse(new File(BASE, split[0]), Charset.defaultCharset(), format);\n-        for(final CSVRecord record : parser) {\n-            String parsed = record.toString();\n+        for (final CSVRecord record : parser) {\n+            String parsed = Arrays.toString(record.values());\n             if (checkComments) {\n                 final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n                 if (comment != null) {\n                 }\n             }\n             final int count = record.size();\n-            assertEquals(testName, readTestData(), count+\":\"+parsed);\n+            assertEquals(testName, readTestData(), count + \":\" + parsed);\n         }\n         parser.close();\n     }\n         final URL resource = ClassLoader.getSystemResource(\"CSVFileParser/\" + split[0]);\n         final CSVParser parser = CSVParser.parse(resource, Charset.forName(\"UTF-8\"), format);\n         for (final CSVRecord record : parser) {\n-            String parsed = record.toString();\n+            String parsed = Arrays.toString(record.values());\n             if (checkComments) {\n                 final String comment = record.getComment().replace(\"\\n\", \"\\\\n\");\n                 if (comment != null) {", "timestamp": 1410365145, "metainfo": ""}