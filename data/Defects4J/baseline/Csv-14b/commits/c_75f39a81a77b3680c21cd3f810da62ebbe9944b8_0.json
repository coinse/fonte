{"sha": "75f39a81a77b3680c21cd3f810da62ebbe9944b8", "log": "[CSV-99] Revert Builder implementation in CSVFormat.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n  */\n public class CSVFormat implements Serializable {\n \n-    /**\n-     * Builds CSVFormat objects.\n-     */\n-    public static class CSVFormatBuilder {\n-\n-        private char delimiter;\n-        private Character quoteChar;\n-        private Quote quotePolicy;\n-        private Character commentStart;\n-        private Character escape;\n-        private boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n-        private boolean ignoreEmptyLines;\n-        private String recordSeparator; // for outputs\n-        private String nullString;\n-        private String[] header;\n-\n-        /**\n-         * Creates a basic CSVFormatBuilder.\n-         *\n-         * @param delimiter\n-         *            the char used for value separation, must not be a line break character\n-         * @throws IllegalArgumentException if the delimiter is a line break character\n-         */\n-        // package protected to give access without needing a synthetic accessor\n-        CSVFormatBuilder(final char delimiter) {\n-            this(delimiter, null, null, null, null, false, false, null, null, null);\n-        }\n-\n-        /**\n-         * Creates a customized CSV format.\n-         *\n-         * @param delimiter\n-         *            the char used for value separation, must not be a line break character\n-         * @param quoteChar\n-         *            the char used as value encapsulation marker\n-         * @param quotePolicy\n-         *            the quote policy\n-         * @param commentStart\n-         *            the char used for comment identification\n-         * @param escape\n-         *            the char used to escape special characters in values\n-         * @param ignoreSurroundingSpaces\n-         *            <tt>true</tt> when whitespaces enclosing values should be ignored\n-         * @param ignoreEmptyLines\n-         *            <tt>true</tt> when the parser should skip empty lines\n-         * @param recordSeparator\n-         *            the record separator to use for output\n-         * @param nullString\n-         *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n-         * @param header\n-         *            the header\n-         * @throws IllegalArgumentException if the delimiter is a line break character\n-         */\n-        // package protected for use by test code\n-        CSVFormatBuilder(final char delimiter, final Character quoteChar,\n-                final Quote quotePolicy, final Character commentStart,\n-                final Character escape, final boolean ignoreSurroundingSpaces,\n-                final boolean ignoreEmptyLines, final String recordSeparator,\n-                String nullString, final String[] header) {\n-            if (isLineBreak(delimiter)) {\n-                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n-            }\n-            this.delimiter = delimiter;\n-            this.quoteChar = quoteChar;\n-            this.quotePolicy = quotePolicy;\n-            this.commentStart = commentStart;\n-            this.escape = escape;\n-            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n-            this.ignoreEmptyLines = ignoreEmptyLines;\n-            this.recordSeparator = recordSeparator;\n-            this.nullString = nullString;\n-            this.header = header;\n-        }\n-\n-        /**\n-         * Creates a CSVFormatBuilder, using the values of the given CSVFormat.\n-         *\n-         * @param format\n-         *            The format to use values from\n-         */\n-        @SuppressWarnings(\"synthetic-access\") // TODO fields could be made package-protected\n-        // package protected to give access without needing a synthetic accessor\n-        CSVFormatBuilder(final CSVFormat format) {\n-            this(format.delimiter, format.quoteChar, format.quotePolicy,\n-                    format.commentStart, format.escape,\n-                    format.ignoreSurroundingSpaces, format.ignoreEmptyLines,\n-                    format.recordSeparator, format.nullString, format.header);\n-        }\n-\n-        /**\n-         * Builds a new CSVFormat configured with the values from this builder.\n-         *\n-         * @return a new CSVFormat\n-         */\n-        public CSVFormat build() {\n-            validate();\n-            return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, \n-                                 header);\n-        }\n-\n-        /**\n-         * Parses the specified content. Short-hand for:\n-         * <pre>format.build().parse(in);</pre>\n-         *\n-         * @param in\n-         *            the input stream\n-         * @return a CSVRecord stream\n-         * @throws IOException\n-         *             If an I/O error occurs\n-         */\n-        public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n-            return this.build().parse(in);\n-        }\n-\n-        /**\n-         * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n-         *\n-         * @throws IllegalStateException\n-         */\n-        private void validate() throws IllegalStateException {\n-            if (quoteChar != null && delimiter == quoteChar.charValue()) {\n-                throw new IllegalStateException(\n-                        \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n-            }\n-\n-            if (escape != null && delimiter == escape.charValue()) {\n-                throw new IllegalStateException(\n-                        \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n-            }\n-\n-            if (commentStart != null && delimiter == commentStart.charValue()) {\n-                throw new IllegalStateException(\n-                        \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n-            }\n-\n-            if (quoteChar != null && quoteChar.equals(commentStart)) {\n-                throw new IllegalStateException(\n-                        \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n-            }\n-\n-            if (escape != null && escape.equals(commentStart)) {\n-                throw new IllegalStateException(\n-                        \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n-            }\n-\n-            if (escape == null && quotePolicy == Quote.NONE) {\n-                throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n-            }\n-        }\n-\n-        /**\n-         * Sets the comment start marker of the format to the specified character.\n-         *\n-         * Note that the comment introducer character is only recognised at the start of a line.\n-         *\n-         * @param commentStart\n-         *            the comment start marker\n-         * @return This builder with the specified character as the comment start marker\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withCommentStart(final char commentStart) {\n-            return withCommentStart(Character.valueOf(commentStart));\n-        }\n-\n-        /**\n-         * Sets the comment start marker of the format to the specified character.\n-         *\n-         * Note that the comment introducer character is only recognised at the start of a line.\n-         *\n-         * @param commentStart\n-         *            the comment start marker\n-         * @return This builder with the specified character as the comment start marker\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withCommentStart(final Character commentStart) {\n-            if (isLineBreak(commentStart)) {\n-                throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n-            }\n-            this.commentStart = commentStart;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the delimiter of the format to the specified character.\n-         *\n-         * @param delimiter\n-         *            the delimiter character\n-         * @return This builder with the specified character as delimiter\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withDelimiter(final char delimiter) {\n-            if (isLineBreak(delimiter)) {\n-                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n-            }\n-            this.delimiter = delimiter;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the escape character of the format to the specified character.\n-         *\n-         * @param escape\n-         *            the escape character\n-         * @return This builder with the specified character as the escape character\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withEscape(final char escape) {\n-            return withEscape(Character.valueOf(escape));\n-        }\n-\n-        /**\n-         * Sets the escape character of the format to the specified character.\n-         *\n-         * @param escape\n-         *            the escape character\n-         * @return This builder with the specified character as the escape character\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withEscape(final Character escape) {\n-            if (isLineBreak(escape)) {\n-                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n-            }\n-            this.escape = escape;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the header of the format. The header can either be parsed automatically from the\n-         * input file with:\n-         *\n-         * <pre>\n-         * CSVFormat format = aformat.withHeader();\n-         * </pre>\n-         *\n-         * or specified manually with:\n-         *\n-         * <pre>\n-         * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n-         * </pre>\n-         *\n-         * @param header\n-         *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n-         *\n-         * @return This builder with the specified header\n-         */\n-        public CSVFormatBuilder withHeader(final String... header) {\n-            this.header = header;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the empty line skipping behavior of the format.\n-         *\n-         * @param ignoreEmptyLines\n-         *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n-         *            <tt>false</tt> to translate empty lines to empty records.\n-         * @return This builder with the specified empty line skipping behavior.\n-         */\n-        public CSVFormatBuilder withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-            this.ignoreEmptyLines = ignoreEmptyLines;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the trimming behavior of the format.\n-         *\n-         * @param ignoreSurroundingSpaces\n-         *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n-         *            spaces as is.\n-         * @return This builder with the specified trimming behavior.\n-         */\n-        public CSVFormatBuilder withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n-            return this;\n-        }\n-\n-        /**\n-         * Performs conversions to and from null for strings on input and output.\n-         * <ul>\n-         * <li>\n-         * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n-         * records.</li>\n-         * <li>\n-         * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n-         * </ul>\n-         * \n-         * @param nullString\n-         *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n-         * \n-         * @return This builder with the the specified null conversion string.\n-         */\n-        public CSVFormatBuilder withNullString(final String nullString) {\n-            this.nullString = nullString;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the quoteChar of the format to the specified character.\n-         *\n-         * @param quoteChar\n-         *            the quoteChar character\n-         * @return This builder with the specified character as quoteChar\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withQuoteChar(final char quoteChar) {\n-            return withQuoteChar(Character.valueOf(quoteChar));\n-        }\n-\n-        /**\n-         * Sets the quoteChar of the format to the specified character.\n-         *\n-         * @param quoteChar\n-         *            the quoteChar character\n-         * @return This builder with the specified character as quoteChar\n-         * @throws IllegalArgumentException\n-         *             thrown if the specified character is a line break\n-         */\n-        public CSVFormatBuilder withQuoteChar(final Character quoteChar) {\n-            if (isLineBreak(quoteChar)) {\n-                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n-            }\n-            this.quoteChar = quoteChar;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the output quote policy of the format to the specified value.\n-         *\n-         * @param quotePolicy\n-         *            the quote policy to use for output.\n-         *\n-         * @return This builder with the specified quote policy\n-         */\n-        public CSVFormatBuilder withQuotePolicy(final Quote quotePolicy) {\n-            this.quotePolicy = quotePolicy;\n-            return this;\n-        }\n-\n-        /**\n-         * Sets the record separator of the format to the specified character.\n-         *\n-         * @param recordSeparator\n-         *            the record separator to use for output.\n-         *\n-         * @return This builder with the the specified output record separator\n-         */\n-        public CSVFormatBuilder withRecordSeparator(final char recordSeparator) {\n-            return withRecordSeparator(String.valueOf(recordSeparator));\n-        }\n-\n-        /**\n-         * Sets the record separator of the format to the specified String.\n-         *\n-         * @param recordSeparator\n-         *            the record separator to use for output.\n-         *\n-         * @return This builder with the the specified output record separator\n-         */\n-        public CSVFormatBuilder withRecordSeparator(final String recordSeparator) {\n-            this.recordSeparator = recordSeparator;\n-            return this;\n-        }\n-    }\n-\n     private static final long serialVersionUID = 1L;\n     /**\n      * Returns true if the given character is a line break character.\n     // package protected to give access without needing a synthetic accessor\n     static boolean isLineBreak(final Character c) {\n         return c != null && isLineBreak(c.charValue());\n-    }\n-    /**\n-     * Creates a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n-     * <ul>\n-     * <li>withDelimiter(',')</li>\n-     * <li>withQuoteChar('\"')</li>\n-     * <li>withEmptyLinesIgnored(true)</li>\n-     * <li>withRecordSeparator(CRLF)</li>\n-     * </ul>\n-     *\n-     * Shortcut for {@code CSVFormat.newBuilder(CSVFormat.DEFAULT)}\n-     *\n-     * @return a standard comma separated format builder, as for {@link #RFC4180} but allowing empty lines.\n-     */\n-    public static CSVFormatBuilder newBuilder() {\n-        return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null);\n     }\n     \n     private final char delimiter;\n     private final String[] header;\n \n     /**\n-     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n-     * <h3>RFC 4180:</h3>\n-     * <ul>\n-     * <li>withDelimiter(',')</li>\n-     * <li>withQuoteChar('\"')</li>\n-     * <li>withRecordSeparator(CRLF)</li>\n-     * </ul>\n-     */\n-    public static final CSVFormat RFC4180 =\n-            newBuilder()\n-            .withIgnoreEmptyLines(false)\n-            .build();\n-\n-    /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n      * <h3>RFC 4180:</h3>\n      * <ul>\n      * <li>withIgnoreEmptyLines(true)</li>\n      * </ul>\n      */\n-    public static final CSVFormat DEFAULT =\n-            newBuilder()\n-            .build();\n+    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF, null, null);\n+\n+    /**\n+     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n+     * <h3>RFC 4180:</h3>\n+     * <ul>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuoteChar('\"')</li>\n+     * <li>withRecordSeparator(CRLF)</li>\n+     * </ul>\n+     */\n+    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n \n     /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n      * </ul>\n      * Note: this is currently the same as RFC4180\n      */\n-    public static final CSVFormat EXCEL =\n-            newBuilder()\n-            .withIgnoreEmptyLines(false)\n-            .build();\n+    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n \n     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n     public static final CSVFormat TDF =\n-            newBuilder()\n+            DEFAULT\n             .withDelimiter(TAB)\n-            .withIgnoreSurroundingSpaces(true)\n-            .build();\n+            .withIgnoreSurroundingSpaces(true);\n \n     /**\n      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and <tt>LOAD DATA INFILE</tt> operations. This is\n      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL =\n-            newBuilder()\n+            DEFAULT\n             .withDelimiter(TAB)\n-            .withQuoteChar(null)\n             .withEscape(BACKSLASH)\n             .withIgnoreEmptyLines(false)\n-            .withRecordSeparator(LF)\n-            .build();\n+            .withQuoteChar(null)\n+            .withRecordSeparator(LF);\n \n     /**\n      * Returns true if the given character is a line break character.\n     }\n \n     /**\n-     * Creates a new CSV format builder.\n+     * Creates a new CSV format with the specified delimiter.\n      *\n      * @param delimiter\n      *            the char used for value separation, must not be a line break character\n-     * @return a new CSV format builder.\n+     * @return a new CSV format.\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n-    public static CSVFormatBuilder newBuilder(final char delimiter) {\n-        return new CSVFormatBuilder(delimiter);\n+    public static CSVFormat newFormat(final char delimiter) {\n+        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null);\n     }\n \n     /**\n      *\n      * @param format\n      *            The format to use values from\n-     * @return a new CSVFormatBuilder\n-     */\n-    public static CSVFormatBuilder newBuilder(final CSVFormat format) {\n-        return new CSVFormatBuilder(format);\n+     * @return a new CSVFormat\n+     */\n+    public static CSVFormat copy(final CSVFormat format) {\n+        return new CSVFormat(format);\n     }\n \n     /**\n         this.header = header == null ? null : header.clone();\n     }\n \n+    CSVFormat(final CSVFormat format) {\n+        this(format.getDelimiter(), format.getQuoteChar(), format.getQuotePolicy(), format.getCommentStart(),\n+                format.getEscape(), format.getIgnoreSurroundingSpaces(), format.getIgnoreEmptyLines(),\n+                format.getRecordSeparator(), format.getNullString(), format.getHeader());\n+    }\n+\n     @Override\n     public boolean equals(final Object obj) {\n         if (this == obj) {\n         return new CSVParser(in, this);\n     }\n \n-    /**\n-     * Creates a builder based on this format.\n-     *\n-     * @return a new builder\n-     */\n-    public CSVFormatBuilder toBuilder() {\n-        return new CSVFormatBuilder(this);\n-    }\n-\n     @Override\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         }\n         return sb.toString();\n     }\n+\n+    /**\n+     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n+     *\n+     * @throws IllegalStateException\n+     */\n+    void validate() throws IllegalStateException {\n+        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n+            throw new IllegalStateException(\n+                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n+        }\n+\n+        if (escape != null && delimiter == escape.charValue()) {\n+            throw new IllegalStateException(\n+                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n+        }\n+\n+        if (commentStart != null && delimiter == commentStart.charValue()) {\n+            throw new IllegalStateException(\n+                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n+        }\n+\n+        if (quoteChar != null && quoteChar.equals(commentStart)) {\n+            throw new IllegalStateException(\n+                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n+        }\n+\n+        if (escape != null && escape.equals(commentStart)) {\n+            throw new IllegalStateException(\n+                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n+        }\n+\n+        if (escape == null && quotePolicy == Quote.NONE) {\n+            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n+        }\n+    }\n+\n+    /**\n+     * Sets the comment start marker of the format to the specified character.\n+     *\n+     * Note that the comment start character is only recognised at the start of a line.\n+     *\n+     * @param commentStart\n+     *            the comment start marker\n+     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withCommentStart(final char commentStart) {\n+        return withCommentStart(Character.valueOf(commentStart));\n+    }\n+\n+    /**\n+     * Sets the comment start marker of the format to the specified character.\n+     *\n+     * Note that the comment start character is only recognised at the start of a line.\n+     *\n+     * @param commentStart\n+     *            the comment start marker\n+     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withCommentStart(final Character commentStart) {\n+        if (isLineBreak(commentStart)) {\n+            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n+        }\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the delimiter of the format to the specified character.\n+     *\n+     * @param delimiter\n+     *            the delimiter character\n+     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withDelimiter(final char delimiter) {\n+        if (isLineBreak(delimiter)) {\n+            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n+        }\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the escape character of the format to the specified character.\n+     *\n+     * @param escape\n+     *            the escape character\n+     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withEscape(final char escape) {\n+        return withEscape(Character.valueOf(escape));\n+    }\n+\n+    /**\n+     * Sets the escape character of the format to the specified character.\n+     *\n+     * @param escape\n+     *            the escape character\n+     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withEscape(final Character escape) {\n+        if (isLineBreak(escape)) {\n+            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n+        }\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the header of the format. The header can either be parsed automatically from the\n+     * input file with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader();\n+     * </pre>\n+     *\n+     * or specified manually with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n+     * </pre>\n+     *\n+     * @param header\n+     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified header\n+     */\n+    public CSVFormat withHeader(final String... header) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the empty line skipping behavior of the format.\n+     *\n+     * @param ignoreEmptyLines\n+     *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n+     *            <tt>false</tt> to translate empty lines to empty records.\n+     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n+     */\n+    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the trimming behavior of the format.\n+     *\n+     * @param ignoreSurroundingSpaces\n+     *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n+     *            spaces as is.\n+     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n+     */\n+    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Performs conversions to and from null for strings on input and output.\n+     * <ul>\n+     * <li>\n+     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n+     * records.</li>\n+     * <li>\n+     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n+     * </ul>\n+     *\n+     * @param nullString\n+     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n+     */\n+    public CSVFormat withNullString(final String nullString) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the quoteChar of the format to the specified character.\n+     *\n+     * @param quoteChar\n+     *            the quoteChar character\n+     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withQuoteChar(final char quoteChar) {\n+        return withQuoteChar(Character.valueOf(quoteChar));\n+    }\n+\n+    /**\n+     * Sets the quoteChar of the format to the specified character.\n+     *\n+     * @param quoteChar\n+     *            the quoteChar character\n+     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withQuoteChar(final Character quoteChar) {\n+        if (isLineBreak(quoteChar)) {\n+            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n+        }\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the output quote policy of the format to the specified value.\n+     *\n+     * @param quotePolicy\n+     *            the quote policy to use for output.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified quote policy\n+     */\n+    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n+\n+    /**\n+     * Sets the record separator of the format to the specified character.\n+     *\n+     * @param recordSeparator\n+     *            the record separator to use for output.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n+     */\n+    public CSVFormat withRecordSeparator(final char recordSeparator) {\n+        return withRecordSeparator(String.valueOf(recordSeparator));\n+    }\n+\n+    /**\n+     * Sets the record separator of the format to the specified String.\n+     *\n+     * @param recordSeparator\n+     *            the record separator to use for output.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n+     */\n+    public CSVFormat withRecordSeparator(final String recordSeparator) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header);\n+    }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n  *\n  * <pre>\n  * Reader in = new StringReader(&quot;a\\tb\\nc\\td&quot;);\n- * Iterable&lt;CSVRecord&gt; parser = CSVFormat.newBuilder()\n+ * Iterable&lt;CSVRecord&gt; parser = CSVFormat.DEFAULT\n  *     .withCommentStart('#')\n  *     .withDelimiter('\\t')\n  *     .withQuoteChar('\"').parse(in);\n      *             If an I/O error occurs\n      */\n     public CSVParser(final Reader input, final CSVFormat format) throws IOException {\n+        format.validate();\n+        this.format = format;\n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n-        this.format = format;\n         this.headerMap = initializeHeader();\n     }\n \n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n     public CSVPrinter(final Appendable out, final CSVFormat format) {\n         this.out = out;\n         this.format = format == null ? CSVFormat.DEFAULT : format;\n+        format.validate();\n     }\n \n     // ======================================================\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n import java.util.Collection;\n import java.util.List;\n \n-import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n-        final CSVFormatBuilder builder = CSVFormat.newBuilder(',').withQuoteChar('\"');\n-        CSVFormat format = builder.build();\n+        CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\"');\n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n             final String[] option_parts = option.split(\"=\",2);\n             if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])){\n-                format = builder.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1])).build();\n+                format = format.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n-                format = builder.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1])).build();\n+                format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n-                format = builder.withCommentStart(option_parts[1].charAt(0)).build();\n+                format = format.withCommentStart(option_parts[1].charAt(0));\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n                 checkComments = true;\n             } else {\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.CSVFormat.RFC4180;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertTrue;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n     @Test\n     public void testEquals() {\n         final CSVFormat right = CSVFormat.DEFAULT;\n-        final CSVFormat left = CSVFormat.newBuilder().build();\n+        final CSVFormat left = CSVFormat.copy(right);\n \n         assertFalse(right.equals(null));\n         assertFalse(right.equals(\"A String Instance\"));\n \n     @Test\n     public void testEqualsDelimiter() {\n-        final CSVFormat right = CSVFormat.newBuilder('!').build();\n-        final CSVFormat left = CSVFormat.newBuilder('?').build();\n+        final CSVFormat right = CSVFormat.newFormat('!');\n+        final CSVFormat left = CSVFormat.newFormat('?');\n \n         assertNotEquals(right, left);\n     }\n \n     @Test\n     public void testEqualsQuoteChar() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'').withQuoteChar('\"').build();\n-        final CSVFormat left = CSVFormat.newBuilder(right).withQuoteChar('!').build();\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuoteChar('\"');\n+        final CSVFormat left = CSVFormat.copy(right).withQuoteChar('!');\n \n         assertNotEquals(right, left);\n     }\n \n     @Test\n     public void testEqualsQuotePolicy() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withQuotePolicy(Quote.MINIMAL)\n-                .build();\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withQuotePolicy(Quote.MINIMAL);\n \n         assertNotEquals(right, left);\n     }\n \n     @Test\n     public void testEqualsCommentStart() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n-                .withCommentStart('#')\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withCommentStart('!')\n-                .build();\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n+                .withQuoteChar('\"')\n+                .withCommentStart('#')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withCommentStart('!');\n \n         assertNotEquals(right, left);\n     }\n \n     @Test\n     public void testEqualsEscape() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n-                .withCommentStart('#')\n-                .withEscape('+')\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withEscape('!')\n-                .build();\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n+                .withQuoteChar('\"')\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withEscape('!');\n \n         assertNotEquals(right, left);\n     }\n \n     @Test\n     public void testEqualsIgnoreSurroundingSpaces() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withCommentStart('#')\n                 .withEscape('+')\n                 .withIgnoreSurroundingSpaces(true)\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withIgnoreSurroundingSpaces(false)\n-                .build();\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withIgnoreSurroundingSpaces(false);\n \n         assertNotEquals(right, left);\n     }\n \n     @Test\n     public void testEqualsIgnoreEmptyLines() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n-                .withCommentStart('#')\n-                .withEscape('+')\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withIgnoreEmptyLines(false);\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsRecordSeparator() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n+                .withRecordSeparator('*')\n+                .withCommentStart('#')\n+                .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withIgnoreEmptyLines(false)\n-                .build();\n-\n-        assertNotEquals(right, left);\n-    }\n-\n-    @Test\n-    public void testEqualsRecordSeparator() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n-                .withCommentStart('#')\n-                .withEscape('+')\n                 .withIgnoreSurroundingSpaces(true)\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withRecordSeparator('!');\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testEqualsHeader() {\n+        final CSVFormat right = CSVFormat.newFormat('\\'')\n+                .withRecordSeparator('*')\n+                .withCommentStart('#')\n+                .withEscape('+')\n+                .withHeader(\"One\", \"Two\", \"Three\")\n                 .withIgnoreEmptyLines(true)\n-                .withRecordSeparator('*')\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withRecordSeparator('!')\n-                .build();\n-\n-        assertNotEquals(right, left);\n-    }\n-\n-    @Test\n-    public void testEqualsHeader() {\n-        final CSVFormat right = CSVFormat.newBuilder('\\'')\n-                .withQuoteChar('\"')\n-                .withQuotePolicy(Quote.ALL)\n-                .withCommentStart('#')\n-                .withEscape('+')\n                 .withIgnoreSurroundingSpaces(true)\n-                .withIgnoreEmptyLines(true)\n-                .withRecordSeparator('*')\n-                .withHeader(\"One\", \"Two\", \"Three\")\n-                .build();\n-        final CSVFormat left = CSVFormat.newBuilder(right)\n-                .withHeader(\"Three\", \"Two\", \"One\")\n-                .build();\n-\n-        assertNotEquals(right, left);\n+                .withQuoteChar('\"')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = CSVFormat.copy(right)\n+                .withHeader(\"Three\", \"Two\", \"One\");\n+\n+        assertNotEquals(right, left);\n+    }\n+\n+    @Test\n+    public void testWithCommentStart() throws Exception {\n+        CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentStart('#');\n+        assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentStart());\n+    }\n+\n+    @Test\n+    public void testWithDelimiter() throws Exception {\n+        CSVFormat formatWithDelimiter = CSVFormat.DEFAULT.withDelimiter('!');\n+        assertEquals('!', formatWithDelimiter.getDelimiter());\n+    }\n+\n+    @Test\n+    public void testWithEscape() throws Exception {\n+        CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\n+        assertEquals(Character.valueOf('&'), formatWithEscape.getEscape());\n+    }\n+\n+    @Test\n+    public void testWithHeader() throws Exception {\n+        String[] header = new String[]{\"one\", \"two\", \"three\"};\n+        CSVFormat formatWithHeader = CSVFormat.DEFAULT.withHeader(header);\n+        assertArrayEquals(header, formatWithHeader.getHeader());\n+        assertNotSame(header, formatWithHeader.getHeader());\n+    }\n+\n+    @Test\n+    public void testWithIgnoreEmptyLines() throws Exception {\n+        assertFalse(CSVFormat.DEFAULT.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreEmptyLines(true).getIgnoreEmptyLines());\n+    }\n+\n+    @Test\n+    public void testWithIgnoreSurround() throws Exception {\n+        assertFalse(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n+        assertTrue(CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true).getIgnoreSurroundingSpaces());\n+    }\n+\n+    @Test\n+    public void testWithNullString() throws Exception {\n+        CSVFormat formatWithNullString = CSVFormat.DEFAULT.withNullString(\"null\");\n+        assertEquals(\"null\", formatWithNullString.getNullString());\n+    }\n+\n+    @Test\n+    public void testWithQuoteChar() throws Exception {\n+        CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuoteChar('\"');\n+        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteChar());\n+    }\n+\n+    @Test\n+    public void testWithQuotePolicy() throws Exception {\n+        CSVFormat formatWithQuotePolicy = CSVFormat.DEFAULT.withQuotePolicy(Quote.ALL);\n+        assertEquals(Quote.ALL, formatWithQuotePolicy.getQuotePolicy());\n+    }\n+\n+    @Test\n+    public void testWithRecordSeparator() throws Exception {\n+        CSVFormat formatWithRecordSeparator = CSVFormat.DEFAULT.withRecordSeparator('!');\n+        assertEquals(\"!\", formatWithRecordSeparator.getRecordSeparator());\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testDelimiterSameAsCommentStartThrowsException() {\n+        CSVFormat.DEFAULT.withDelimiter('!').withCommentStart('!').validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testDelimiterSameAsEscapeThrowsException() {\n+        CSVFormat.DEFAULT.withDelimiter('!').withEscape('!').validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testEscapeSameAsCommentStartThrowsException() {\n+        CSVFormat.DEFAULT.withEscape('!').withCommentStart('!').validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        CSVFormat.DEFAULT.withEscape(new Character('!')).withCommentStart(new Character('!')).validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testQuoteCharSameAsCommentStartThrowsException() {\n+        CSVFormat.DEFAULT.withQuoteChar('!').withCommentStart('!').validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        CSVFormat.DEFAULT.withQuoteChar(new Character('!')).withCommentStart('!').validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testQuoteCharSameAsDelimiterThrowsException() {\n+        CSVFormat.DEFAULT.withQuoteChar('!').withDelimiter('!').validate();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testQuotePolicyNoneWithoutEscapeThrowsException() {\n+        CSVFormat.newFormat('!').withQuotePolicy(Quote.NONE).validate();\n+    }\n+\n+    @Test\n+    public void testRFC4180() {\n+        assertEquals(null, RFC4180.getCommentStart());\n+        assertEquals(',', RFC4180.getDelimiter());\n+        assertEquals(null, RFC4180.getEscape());\n+        assertFalse(RFC4180.getIgnoreEmptyLines());\n+        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteChar());\n+        assertEquals(null, RFC4180.getQuotePolicy());\n+        assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithCommentStartCRThrowsException() {\n+        CSVFormat.DEFAULT.withCommentStart(CR).validate();\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithDelimiterLFThrowsException() {\n+        CSVFormat.DEFAULT.withDelimiter(LF).validate();\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithEscapeCRThrowsExceptions() {\n+        CSVFormat.DEFAULT.withEscape(CR).validate();\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithQuoteLFThrowsException() {\n+        CSVFormat.DEFAULT.withQuoteChar(LF).validate();\n     }\n \n     private static void assertNotEquals(final Object right, final Object left) {\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n \n     @Before\n     public void setUp() {\n-        formatWithEscaping = CSVFormat.newBuilder().withEscape('\\\\').build();\n+        formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n     }\n \n     private Lexer getLexer(final String input, final CSVFormat format) {\n     @Test\n     public void testSurroundingSpacesAreDeleted() throws IOException {\n         final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n     @Test\n     public void testSurroundingTabsAreDeleted() throws IOException {\n         final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n                 \"\\n\"+\n                 \"\\n\"+\n                 \"\\n\";\n-        final CSVFormat format = CSVFormat.newBuilder().withIgnoreEmptyLines(true).build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines(true);\n         final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n                 \"third,line,#no-comment\\n\"+\n                 \"# penultimate comment\\n\"+\n                 \"# Final comment\\n\";\n-        final CSVFormat format = CSVFormat.newBuilder().withCommentStart('#').build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n         final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n                 \"\\n\"+                      // 6b\n                 \"\\n\"+                      // 6c\n                 \"# Final comment\\n\";       // 7\n-        final CSVFormat format = CSVFormat.newBuilder().withCommentStart('#').withIgnoreEmptyLines(false).build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n         final Lexer parser = getLexer(code, format);\n         *       \\,,\n         */\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n-        final CSVFormat format = formatWithEscaping.toBuilder().withIgnoreEmptyLines(false).build();\n+        final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n         assertTrue(format.isEscaping());\n         final Lexer parser = getLexer(code, format);\n \n         *        a,  \" foo \" ,b\n         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final Lexer parser = getLexer(code, CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n         *       ;;\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        final CSVFormat format = CSVFormat.newBuilder().withDelimiter(';').withQuoteChar('\\'').withCommentStart('!').build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentStart('!').withDelimiter(';');\n         final Lexer parser = getLexer(code, format);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));\n     @Test\n     public void testEscapedControlCharacter() throws Exception {\n         // we are explicitly using an escape different from \\ here\n-        final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.newBuilder().withEscape('!').build());\n+        final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapedControlCharacter2() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.newBuilder().withEscape('\\\\').build());\n+        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.nextRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n         };\n \n \n-        final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\\'').withEscape('/')\n-                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'')\n+                               .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n         final CSVParser parser = new CSVParser(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         };\n \n \n-        final CSVFormat format = CSVFormat.newBuilder(',').withEscape('/')\n-                .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n+        final CSVFormat format = CSVFormat.newFormat(',')\n+                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n         final CSVParser parser = new CSVParser(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n                 {\"\\n\", \" \", \"#\"},\n         };\n \n-        format = CSVFormat.newBuilder().withCommentStart('#').build();\n+        format = CSVFormat.DEFAULT.withCommentStart('#');\n         parser = new CSVParser(code, format);\n         records = parser.getRecords();\n \n     public void testHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testHeaderComment() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withCommentStart('#').withHeader().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testProvidedHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n \n         for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n \n         // header record\n         assertTrue(records.hasNext());\n \n     @Test\n     public void testGetHeaderMap() throws Exception {\n-        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build());\n+        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n         final Map<String, Integer> headerMap = parser.getHeaderMap();\n         final Iterator<String> columnNames = headerMap.keySet().iterator();\n         // Headers are iterated in column order.\n     @Test\n     public void testGetRecordWithMultiiLineValues() throws Exception {\n         final CSVParser parser = new CSVParser(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n-                CSVFormat.newBuilder().withRecordSeparator(CRLF).build());\n+                CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertEquals(0, parser.getCurrentLineNumber());\n         validateRecordNumbers(String.valueOf(CR));\n     }\n \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidFormat() throws Exception {\n+        CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n+        new CSVParser((Reader) null, invalidFormat);\n+    }\n+\n     private void validateRecordNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n+        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n     }\n \n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n+        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         assertEquals(0, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n         assertEquals(1, parser.getCurrentLineNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.CR;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n \n     @Test\n     public void testMultiLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withCommentStart('#').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n         printer.printComment(\"This is a comment\\non multiple lines\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n     @Test\n     public void testPrintCustomNullValues() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.toBuilder().withNullString(\"NULL\").build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n         printer.printRecord(\"a\", null, \"b\");\n         assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n         printer.close();\n     @Test\n     public void testParseCustomNullValues() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVFormat format = CSVFormat.DEFAULT.toBuilder().withNullString(\"NULL\").build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withNullString(\"NULL\");\n         final CSVPrinter printer = new CSVPrinter(sw, format);\n         printer.printRecord(\"a\", null, \"b\");\n         printer.close();\n     @Test\n     public void testQuoteAll() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuotePolicy(Quote.ALL).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuotePolicy(Quote.ALL));\n         printer.printRecord(\"a\", \"b\\nc\", \"d\");\n         assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n         printer.close();\n     @Test\n     public void testQuoteNonNumeric() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuotePolicy(Quote.NON_NUMERIC).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuotePolicy(Quote.NON_NUMERIC));\n         printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n         assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n         printer.close();\n     @Test\n     public void testPlainQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar('\\'').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n         printer.print(\"abc\");\n         assertEquals(\"abc\", sw.toString());\n         printer.close();\n     @Test\n     public void testSingleLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withCommentStart('#').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n         printer.printComment(\"This is a comment\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n     @Test\n     public void testSingleQuoteQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar('\\'').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n         printer.print(\"a'b'c\");\n         printer.print(\"xyz\");\n         assertEquals(\"'a''b''c',xyz\", sw.toString());\n     @Test\n     public void testDelimeterQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar('\\'').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n         assertEquals(\"'a,b,c',xyz\", sw.toString());\n     @Test\n     public void testDelimeterQuoteNONE() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVFormat format = CSVFormat.newBuilder().withEscape('!').withQuotePolicy(Quote.NONE).build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuotePolicy(Quote.NONE);\n         final CSVPrinter printer = new CSVPrinter(sw, format);\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n     @Test\n     public void testEOLQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar('\\'').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n         printer.print(\"a\\rb\\nc\");\n         printer.print(\"x\\by\\fz\");\n         assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n     @Test\n     public void testPlainEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar(null).withEscape('!').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null).withEscape('!'));\n         printer.print(\"abc\");\n         printer.print(\"xyz\");\n         assertEquals(\"abc,xyz\", sw.toString());\n     @Test\n     public void testDelimiterEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar(null).withEscape('!').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuoteChar(null));\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n         assertEquals(\"a!,b!,c,xyz\", sw.toString());\n     @Test\n     public void testEOLEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar(null).withEscape('!').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null).withEscape('!'));\n         printer.print(\"a\\rb\\nc\");\n         printer.print(\"x\\fy\\bz\");\n         assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n     @Test\n     public void testPlainPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar(null).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null));\n         printer.print(\"abc\");\n         printer.print(\"xyz\");\n         assertEquals(\"abc,xyz\", sw.toString());\n     @Test\n     public void testDelimiterPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar(null).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null));\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n         assertEquals(\"a,b,c,xyz\", sw.toString());\n     @Test\n     public void testEOLPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuoteChar(null).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null));\n         printer.print(\"a\\rb\\nc\");\n         printer.print(\"x\\fy\\bz\");\n         assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n         printer.close();\n     }\n \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidFormat() throws Exception {\n+        CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n+        new CSVPrinter(null, invalidFormat);\n+    }\n }\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n     }\n \n     private long parse(final Reader in, final boolean traverseColumns) throws IOException {\n-        final CSVFormat format = CSVFormat.newBuilder().withIgnoreSurroundingSpaces(false).build();\n+        final CSVFormat format = CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false);\n         long recordCount = 0;\n         for (final CSVRecord record : format.parse(in)) {\n             recordCount++;", "timestamp": 1375195352, "metainfo": ""}