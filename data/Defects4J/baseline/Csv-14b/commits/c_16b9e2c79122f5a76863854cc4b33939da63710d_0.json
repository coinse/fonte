{"sha": "16b9e2c79122f5a76863854cc4b33939da63710d", "log": "[CSV-175] Support for ignoring trailing delimiter. [CSV-177] Support trimming leading and trailing blanks. [CSV-178] Create default formats for Informix UNLOAD and UNLOAD CSV.   ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\n import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.PIPE;\n import static org.apache.commons.csv.Constants.TAB;\n \n import java.io.IOException;\n         /**\n          * @see CSVFormat#DEFAULT\n          */\n-        Default(CSVFormat.DEFAULT), \n+        Default(CSVFormat.DEFAULT),\n \n         /**\n          * @see CSVFormat#EXCEL\n          */\n-        Excel(CSVFormat.EXCEL), \n+        Excel(CSVFormat.EXCEL),\n+\n+        /**\n+         * @see CSVFormat#INFORMIX_UNLOAD\n+         * @since 1.3\n+         */\n+        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n+\n+        /**\n+         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n+         * @since 1.3\n+         */\n+        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n \n         /**\n          * @see CSVFormat#MYSQL\n          */\n-        MySQL(CSVFormat.MYSQL), \n+        MySQL(CSVFormat.MYSQL),\n \n         /**\n          * @see CSVFormat#RFC4180\n         private Predefined(final CSVFormat format) {\n             this.format = format;\n         }\n-        \n+\n         /**\n          * Gets the format.\n          * \n             return format;\n         }\n     };\n-    \n+\n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n      *\n      * <li>withRecordSeparator(\"\\r\\n\")</li>\n      * <li>withIgnoreEmptyLines(true)</li>\n      * </ul>\n+     * \n      * @see Predefined#Default\n      */\n-    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true,\n-            CRLF, null, null, null, false, false, false);\n+    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n+            null, null, null, false, false, false, false, false);\n \n     /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n      * withAllowMissingColumnNames(true)}.\n      * </p>\n+     * \n      * @see Predefined#Excel\n      */\n     public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n+\n+    /**\n+     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n+     *\n+     * <p>\n+     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n+     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n+     * </p>\n+     *\n+     * <p>\n+     * Settings are:\n+     * </p>\n+     * <ul>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuote(\"\\\"\")</li>\n+     * <li>withRecordSeparator('\\n')</li>\n+     * <li>withEscape('\\\\')</li>\n+     * </ul>\n+     *\n+     * @see Predefined#MySQL\n+     * @see <a href=\n+     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n+     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n+     * @since 1.3\n+     */\n+    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH)\n+            .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF);\n+\n+    /**\n+     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n+     *\n+     * <p>\n+     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n+     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n+     * </p>\n+     *\n+     * <p>\n+     * Settings are:\n+     * </p>\n+     * <ul>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuote(\"\\\"\")</li>\n+     * <li>withRecordSeparator('\\n')</li>\n+     * </ul>\n+     *\n+     * @see Predefined#MySQL\n+     * @see <a href=\n+     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n+     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n+     * @since 1.3\n+     */\n+    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR)\n+            .withRecordSeparator(LF);\n \n     /**\n      * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n      * </ul>\n      *\n      * @see Predefined#MySQL\n-     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n-     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n+     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n+     *      -data.html</a>\n      */\n     public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n             .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n-    \n+\n     /**\n      * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n      *\n      * <li>withRecordSeparator(\"\\r\\n\")</li>\n      * <li>withIgnoreEmptyLines(false)</li>\n      * </ul>\n+     * \n      * @see Predefined#RFC4180\n      */\n     public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n-    \n+\n     private static final long serialVersionUID = 1L;\n-    \n+\n     /**\n      * Tab-delimited format.\n      *\n      * <li>withRecordSeparator(\"\\r\\n\")</li>\n      * <li>withIgnoreSurroundingSpaces(true)</li>\n      * </ul>\n+     * \n      * @see Predefined#TDF\n      */\n     public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n-    \n+\n     /**\n      * Returns true if the given character is a line break character.\n      *\n     private static boolean isLineBreak(final char c) {\n         return c == LF || c == CR;\n     }\n-    \n+\n     /**\n      * Returns true if the given character is a line break character.\n      *\n     private static boolean isLineBreak(final Character c) {\n         return c != null && isLineBreak(c.charValue());\n     }\n-    \n+\n     /**\n      * Creates a new CSV format with the specified delimiter.\n      *\n      * @see #TDF\n      */\n     public static CSVFormat newFormat(final char delimiter) {\n-        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n-    }\n-    \n+        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n+                false, false, false);\n+    }\n+\n     /**\n      * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n      * \n     public static CSVFormat valueOf(final String format) {\n         return CSVFormat.Predefined.valueOf(format).getFormat();\n     }\n-    \n+\n     private final boolean allowMissingColumnNames;\n-    \n+\n     private final Character commentMarker; // null if commenting is disabled\n-    \n+\n     private final char delimiter;\n-    \n+\n     private final Character escapeCharacter; // null if escaping is disabled\n-    \n+\n     private final String[] header; // array of header column names\n \n     private final String[] headerComments; // array of header comment lines\n     private final String recordSeparator; // for outputs\n \n     private final boolean skipHeaderRecord;\n+\n+    private final boolean trailingDelimiter;\n+\n+    private final boolean trim;\n \n     /**\n      * Creates a customized CSV format.\n      *            TODO\n      * @param ignoreHeaderCase\n      *            TODO\n+     * @param trim\n+     *            TODO\n+     * @param trailingDelimiter TODO\n      * @throws IllegalArgumentException\n      *             if the delimiter is a line break character\n      */\n             final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n             final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n             final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n-            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase) {\n+            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, boolean trim, boolean trailingDelimiter) {\n         this.delimiter = delimiter;\n         this.quoteCharacter = quoteChar;\n         this.quoteMode = quoteMode;\n         this.header = header == null ? null : header.clone();\n         this.skipHeaderRecord = skipHeaderRecord;\n         this.ignoreHeaderCase = ignoreHeaderCase;\n+        this.trailingDelimiter = trailingDelimiter;\n+        this.trim = trim;        \n         validate();\n     }\n \n     /**\n      * Gets the String to convert to and from {@code null}.\n      * <ul>\n-     * <li>\n-     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n+     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n      * records.</li>\n-     * <li>\n-     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n+     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n      * </ul>\n      *\n      * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n      */\n     public boolean getSkipHeaderRecord() {\n         return skipHeaderRecord;\n+    }\n+\n+    /**\n+     * Returns whether to add a trailing delimiter.\n+     *\n+     * @return whether to add a trailing delimiter.\n+     */\n+    public boolean getTrailingDelimiter() {\n+        return trailingDelimiter;\n+    }\n+\n+    /**\n+     * Returns whether to trim leading and trailing blanks.\n+     *\n+     * @return whether to trim leading and trailing blanks.\n+     */\n+    public boolean getTrim() {\n+        return trim;\n     }\n \n     @Override\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        \n+\n         if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n-            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n-                    quoteCharacter + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n         }\n \n         if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n-            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n-                    escapeCharacter + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n         }\n \n         if (commentMarker != null && delimiter == commentMarker.charValue()) {\n-            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n-                    commentMarker + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n         }\n \n         if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n-            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n-                    commentMarker + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n         }\n \n         if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n-            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n-                    commentMarker + \"')\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n         }\n \n         if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n             throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n         }\n-        \n+\n         // validate header\n         if (header != null) {\n             final Set<String> dupCheck = new HashSet<String>();\n             for (final String hdr : header) {\n                 if (!dupCheck.add(hdr)) {\n-                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n-                            Arrays.toString(header));\n+                    throw new IllegalArgumentException(\n+                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                 }\n             }\n         }\n     public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n-                allowMissingColumnNames, ignoreHeaderCase);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. \n-     * The header can either be parsed automatically from the input file with:\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n+     * either be parsed automatically from the input file with:\n      *\n      * <pre>\n      * CSVFormat format = aformat.withHeader();\n     }\n \n     /**\n-     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata.\n-     *  The header can either be parsed automatically from the input file with:\n+     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n+     * either be parsed automatically from the input file with:\n      *\n      * <pre>\n      * CSVFormat format = aformat.withHeader();\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with the header of the format set to the given values. \n-     * The header can either be parsed automatically from the input file with:\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n+     * parsed automatically from the input file with:\n      *\n      * <pre>\n      * CSVFormat format = aformat.withHeader();\n     public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n-    }\n-\n-    /**\n-     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. \n-     * The comments will be printed first, before the headers. This setting is ignored by the parser.\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n+     * be printed first, before the headers. This setting is ignored by the parser.\n      *\n      * <pre>\n      * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     public CSVFormat withHeaderComments(final Object... headerComments) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n      * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n      *\n      * @param ignoreHeaderCase\n-     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the\n-     *            mapping as is.\n+     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n+     *            is.\n      * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n      */\n     public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n      * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n      * <ul>\n-     * <li>\n-     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n+     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n      * records.</li>\n-     * <li>\n-     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n+     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n      * </ul>\n      *\n      * @param nullString\n     public CSVFormat withNullString(final String nullString) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n         }\n         return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                 ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n-                allowMissingColumnNames, ignoreHeaderCase);\n+                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n     public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n     }\n \n     /**\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n-                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n+     *\n+     * @param trim\n+     *            whether to trim leading and trailing blanks.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n+     */\n+    public CSVFormat withTrim(final boolean trim) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n+     *     *\n+     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n+     */\n+    public CSVFormat withTrailingDelimiter() {\n+        return withTrailingDelimiter(true);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n+     *\n+     * @param trim\n+     *            whether to add a trailing delimiter.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n+     */\n+    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n+                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n+    }\n+\n+    /**\n+     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the trim setting on.\n+     */\n+    public CSVFormat withTrim() {\n+        return withTrim(true);\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n         this.recordNumber = recordNumber - 1;\n     }\n \n-    private void addRecordValue() {\n+    private void addRecordValue(boolean lastRecord) {\n         final String input = this.reusableToken.content.toString();\n+        final String inputClean = this.format.getTrim() ? input.trim() : input;\n+        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n+            return;\n+        }\n         final String nullString = this.format.getNullString();\n-        this.record.add(input.equals(nullString) ? null : input);\n+        this.record.add(inputClean.equals(nullString) ? null : inputClean);\n     }\n \n     /**\n             this.lexer.nextToken(this.reusableToken);\n             switch (this.reusableToken.type) {\n             case TOKEN:\n-                this.addRecordValue();\n+                this.addRecordValue(false);\n                 break;\n             case EORECORD:\n-                this.addRecordValue();\n+                this.addRecordValue(true);\n                 break;\n             case EOF:\n                 if (this.reusableToken.isReady) {\n-                    this.addRecordValue();\n+                    this.addRecordValue(true);\n                 }\n                 break;\n             case INVALID:\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n         } else {\n             strValue = value.toString();\n         }\n+        strValue = format.getTrim() ? strValue.trim() : strValue;\n         this.print(value, strValue, 0, strValue.length());\n     }\n \n      *             If an I/O error occurs\n      */\n     public void println() throws IOException {\n+        if (format.getTrailingDelimiter()) {\n+            out.append(format.getDelimiter());            \n+        }\n         final String recordSeparator = format.getRecordSeparator();\n         if (recordSeparator != null) {\n             out.append(recordSeparator);\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         }\n     }\n \n+    @Test\n+    public void testTrailingDelimiter() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a,\\n\\\"1\\\",\\\"2\\\",\\\"3\\\",\\nx,y,z,\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrailingDelimiter()\n+                .parse(in).iterator();\n+        final CSVRecord record = records.next();\n+        assertEquals(\"1\", record.get(\"X\"));\n+        assertEquals(\"2\", record.get(\"Y\"));\n+        assertEquals(\"3\", record.get(\"Z\"));\n+        Assert.assertEquals(3, record.size());\n+    }\n+\n+    @Test\n+    public void testTrim() throws Exception {\n+        final Reader in = new StringReader(\"a,a,a\\n\\\" 1 \\\",\\\" 2 \\\",\\\" 3 \\\"\\nx,y,z\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"X\", \"Y\", \"Z\").withSkipHeaderRecord().withTrim()\n+                .parse(in).iterator();\n+        final CSVRecord record = records.next();\n+        assertEquals(\"1\", record.get(\"X\"));\n+        assertEquals(\"2\", record.get(\"Y\"));\n+        assertEquals(\"3\", record.get(\"Z\"));\n+        Assert.assertEquals(3, record.size());\n+    }\n+\n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n         final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n                 CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n \n     private static final int ITERATIONS_FOR_RANDOM_TEST = 50000;\n     \n-    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n-\n     private static String printable(final String s) {\n         final StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < s.length(); i++) {\n         return sb.toString();\n     }\n \n+    private final String recordSeparator = CSVFormat.DEFAULT.getRecordSeparator();\n+\n     private void doOneRandom(final CSVFormat format) throws Exception {\n         final Random r = new Random();\n \n         }\n         Utils.compare(\"Printer output :\" + printable(result), expected, parseResult);\n         parser.close();\n+    }\n+\n+    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n+        for (int i = 0; i < iter; i++) {\n+            doOneRandom(format);\n+        }\n+    }\n+\n+    /**\n+     * Converts an input CSV array into expected output values WRT NULLs. NULL strings are converted to null values\n+     * because the parser will convert these strings to null.\n+     */\n+    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n+        final T[] fixed = original.clone();\n+        for (int i = 0; i < fixed.length; i++) {\n+            if (ObjectUtils.equals(csvFormat.getNullString(), fixed[i])) {\n+                fixed[i] = null;\n+            }\n+        }\n+        return fixed;\n+    }\n+\n+    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n+        Class.forName(\"org.h2.Driver\");\n+        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n     }\n \n     private String[][] generateLines(final int nLines, final int nCol) {\n         return lines;\n     }\n \n-    private void doRandom(final CSVFormat format, final int iter) throws Exception {\n-        for (int i = 0; i < iter; i++) {\n-            doOneRandom(format);\n-        }\n+    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n+            throws IOException {\n+        CSVFormat format = baseFormat;\n+        // Use withHeaderComments first to test CSV-145\n+        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n+        format = format.withCommentMarker('#');\n+        format = format.withHeader(\"Col1\", \"Col2\");\n+        final CSVPrinter csvPrinter = format.print(sw);\n+        csvPrinter.printRecord(\"A\", \"B\");\n+        csvPrinter.printRecord(\"C\", \"D\");\n+        csvPrinter.close();\n+        return csvPrinter;\n     }\n \n     private String randStr() {\n         return new String(buf);\n     }\n \n+    private void setUpTable(final Connection connection) throws SQLException {\n+        final Statement statement = connection.createStatement();\n+        try {\n+            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n+            statement.execute(\"insert into TEST values(1, 'r1')\");\n+            statement.execute(\"insert into TEST values(2, 'r2')\");\n+        } finally {\n+            statement.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testDelimeterQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"'a,b,c',xyz\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testDelimeterQuoteNONE() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testDelimiterEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testDelimiterPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.print(\"a,b,c\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"a,b,c,xyz\", sw.toString());\n+        printer.close();\n+    }\n+\n     @Test\n     public void testDisabledComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n \n         assertEquals(\"\", sw.toString());\n         printer.close();\n+    }\n+    \n+    @Test\n+    public void testEOLEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n+        printer.print(\"a\\rb\\nc\");\n+        printer.print(\"x\\fy\\bz\");\n+        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEOLPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.print(\"a\\rb\\nc\");\n+        printer.print(\"x\\fy\\bz\");\n+        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEOLQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n+        printer.print(\"a\\rb\\nc\");\n+        printer.print(\"x\\by\\fz\");\n+        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n+        printer.close();\n+    }\n+    \n+    @Test\n+    public void testEscapeBackslash() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        final char quoteChar = '\\'';\n+        final String eol = \"\\r\\n\";\n+        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"\\\\\");\n+        printer.close();\n+        assertEquals(\"'\\\\'\", sw.toString());\n+\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"\\\\\\r\");\n+        printer.close();\n+        assertEquals(\"'\\\\\\r'\", sw.toString());\n+\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"X\\\\\\r\");\n+        printer.close();\n+        assertEquals(\"'X\\\\\\r'\", sw.toString());\n+\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.printRecord(new Object[] { \"\\\\\\r\" });\n+        printer.close();\n+        assertEquals(\"'\\\\\\r'\" + eol, sw.toString());\n+\n+        sw = new StringWriter();\n+        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n+        printer.print(\"\\\\\\\\\");\n+        printer.close();\n+        assertEquals(\"'\\\\\\\\'\", sw.toString());\n+\n     }\n \n     @Test\n         printer.close();\n     }\n \n-    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n-        Class.forName(\"org.h2.Driver\");\n-        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n-    }\n-\n-    @Test\n-    @Ignore\n-    public void testJira135All() throws IOException {\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        final List<String> list = new LinkedList<String>();\n-        list.add(\"\\\"\");\n-        list.add(\"\\n\");\n-        list.add(\"\\\\\");\n-        printer.printRecord(list);\n-        printer.close();\n-        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n-        assertEquals(expected, sw.toString());\n-        final String[] record0 = toFirstRecordValues(expected, format);\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n-    }\n-    \n-    @Test\n-    @Ignore\n-    public void testJira135_part3() throws IOException {\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        final List<String> list = new LinkedList<String>();\n-        list.add(\"\\\\\");\n-        printer.printRecord(list);\n-        printer.close();\n-        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n-        assertEquals(expected, sw.toString());\n-        final String[] record0 = toFirstRecordValues(expected, format);\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n-    }\n-    \n-    @Test\n-    @Ignore\n-    public void testJira135_part2() throws IOException {\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        final List<String> list = new LinkedList<String>();\n-        list.add(\"\\n\");\n-        printer.printRecord(list);\n-        printer.close();\n-        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n-        assertEquals(expected, sw.toString());\n-        final String[] record0 = toFirstRecordValues(expected, format);\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n-    }\n-    \n-    @Test\n-    @Ignore\n-    public void testJira135_part1() throws IOException {\n-        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        final List<String> list = new LinkedList<String>();\n-        list.add(\"\\\"\");\n-        printer.printRecord(list);\n-        printer.close();\n-        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n-        assertEquals(expected, sw.toString());\n-        final String[] record0 = toFirstRecordValues(expected, format);\n-        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n-    }\n-    \n+    @Test\n+    public void testHeader() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"));\n+        printer.printRecord(\"a\", \"b\", \"c\");\n+        printer.printRecord(\"x\", \"y\", \"z\");\n+        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testHeaderCommentExcel() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.EXCEL;\n+        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n+        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n+                sw.toString());\n+        csvPrinter.close();\n+    }\n+\n+    @Test\n+    public void testHeaderCommentTdf() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.TDF;\n+        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n+        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n+                sw.toString());\n+        csvPrinter.close();\n+    }\n+\n+    @Test\n+    public void testHeaderNotSet() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.printRecord(\"a\", \"b\", \"c\");\n+        printer.printRecord(\"x\", \"y\", \"z\");\n+        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testInvalidFormat() throws Exception {\n+        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n+        new CSVPrinter(new StringWriter(), invalidFormat).close();\n+    }\n+\n     @Test\n     public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\n         final StringWriter sw = new StringWriter();\n         }\n     }\n \n-    private void setUpTable(final Connection connection) throws SQLException {\n-        final Statement statement = connection.createStatement();\n-        try {\n-            statement.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n-            statement.execute(\"insert into TEST values(1, 'r1')\");\n-            statement.execute(\"insert into TEST values(2, 'r2')\");\n-        } finally {\n-            statement.close();\n-        }\n+    @Test\n+    @Ignore\n+    public void testJira135_part1() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\\"\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\\\\"\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Ignore\n+    public void testJira135_part2() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\n\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\n\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Ignore\n+    public void testJira135_part3() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\\\\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n+    }\n+\n+    @Test\n+    @Ignore\n+    public void testJira135All() throws IOException {\n+        final CSVFormat format = CSVFormat.DEFAULT.withRecordSeparator('\\n').withQuote('\"').withEscape('\\\\');\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, format);\n+        final List<String> list = new LinkedList<String>();\n+        list.add(\"\\\"\");\n+        list.add(\"\\n\");\n+        list.add(\"\\\\\");\n+        printer.printRecord(list);\n+        printer.close();\n+        final String expected = \"\\\"\\\\\\\"\\\",\\\"\\\\n\\\",\\\"\\\\\\\"\" + format.getRecordSeparator();\n+        assertEquals(expected, sw.toString());\n+        final String[] record0 = toFirstRecordValues(expected, format);\n+        assertArrayEquals(expectNulls(list.toArray(), format), record0);\n     }\n \n     @Test\n \n         assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n         printer.close();\n-    }\n-\n-    @Test\n-    public void testMySqlNullStringDefault() throws IOException {\n-        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n     }\n \n     @Test\n         assertArrayEquals(expectNulls(s, format), record0);\n     }\n \n-    /**\n-     * Converts an input CSV array into expected output values WRT NULLs. NULL strings are converted to null values\n-     * because the parser will convert these strings to null.\n-     */\n-    private <T> T[] expectNulls(final T[] original, final CSVFormat csvFormat) {\n-        final T[] fixed = original.clone();\n-        for (int i = 0; i < fixed.length; i++) {\n-            if (ObjectUtils.equals(csvFormat.getNullString(), fixed[i])) {\n-                fixed[i] = null;\n-            }\n-        }\n-        return fixed;\n-    }\n-\n-    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n-        return CSVParser.parse(expected, format).getRecords().get(0).values();\n-    }\n-\n-    @Test\n-    public void testPrinter1() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\");\n-        assertEquals(\"a,b\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrinter2() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a,b\", \"b\");\n-        assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrinter3() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a, b\", \"b \");\n-        assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrinter4() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\\"c\");\n-        assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrinter5() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\nc\");\n-        assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrinter6() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\r\\nc\");\n-        assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrinter7() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", \"b\\\\c\");\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrint() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = CSVFormat.DEFAULT.print(sw);\n-        printer.printRecord(\"a\", \"b\\\\c\");\n-        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrintNullValues() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-        printer.printRecord(\"a\", null, \"b\");\n-        assertEquals(\"a,,b\" + recordSeparator, sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPrintCustomNullValues() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n-        printer.printRecord(\"a\", null, \"b\");\n-        assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n-        printer.close();\n+    @Test\n+    public void testMySqlNullStringDefault() throws IOException {\n+        assertEquals(\"\\\\N\", CSVFormat.MYSQL.getNullString());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewCsvPrinterAppendableNullFormat() throws Exception {\n+        new CSVPrinter(new StringWriter(), null).close();\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewCSVPrinterNullAppendableFormat() throws Exception {\n+        new CSVPrinter(null, CSVFormat.DEFAULT).close();\n     }\n \n     @Test\n     }\n \n     @Test\n+    public void testPlainEscaped() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n+        printer.print(\"abc\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"abc,xyz\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPlainPlain() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n+        printer.print(\"abc\");\n+        printer.print(\"xyz\");\n+        assertEquals(\"abc,xyz\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPlainQuoted() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n+        printer.print(\"abc\");\n+        assertEquals(\"abc\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrint() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = CSVFormat.DEFAULT.print(sw);\n+        printer.printRecord(\"a\", \"b\\\\c\");\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrintCustomNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withNullString(\"NULL\"));\n+        printer.printRecord(\"a\", null, \"b\");\n+        assertEquals(\"a,NULL,b\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter1() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a\", \"b\");\n+        assertEquals(\"a,b\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter2() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a,b\", \"b\");\n+        assertEquals(\"\\\"a,b\\\",b\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter3() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a, b\", \"b \");\n+        assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter4() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a\", \"b\\\"c\");\n+        assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter5() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a\", \"b\\nc\");\n+        assertEquals(\"a,\\\"b\\nc\\\"\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter6() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a\", \"b\\r\\nc\");\n+        assertEquals(\"a,\\\"b\\r\\nc\\\"\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrinter7() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a\", \"b\\\\c\");\n+        assertEquals(\"a,b\\\\c\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testPrintNullValues() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n+        printer.printRecord(\"a\", null, \"b\");\n+        assertEquals(\"a,,b\" + recordSeparator, sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n     public void testQuoteAll() throws IOException {\n         final StringWriter sw = new StringWriter();\n         final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteMode(QuoteMode.ALL));\n     }\n \n     @Test\n+    public void testRandomRfc4180() throws Exception {\n+        doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\n+    }\n+\n+    @Test\n     public void testRandomTdf() throws Exception {\n         doRandom(CSVFormat.TDF, ITERATIONS_FOR_RANDOM_TEST);\n-    }\n-\n-    @Test\n-    public void testRandomRfc4180() throws Exception {\n-        doRandom(CSVFormat.RFC4180, ITERATIONS_FOR_RANDOM_TEST);\n-    }\n-\n-    @Test\n-    public void testPlainQuoted() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"abc\");\n-        assertEquals(\"abc\", sw.toString());\n-        printer.close();\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void testDelimeterQuoted() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"'a,b,c',xyz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testDelimeterQuoteNONE() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVFormat format = CSVFormat.DEFAULT.withEscape('!').withQuoteMode(QuoteMode.NONE);\n-        final CSVPrinter printer = new CSVPrinter(sw, format);\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testEOLQuoted() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n-        printer.print(\"a\\rb\\nc\");\n-        printer.print(\"x\\by\\fz\");\n-        assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testEscapeBackslash() throws IOException {\n-        StringWriter sw = new StringWriter();\n-        final char quoteChar = '\\'';\n-        final String eol = \"\\r\\n\";\n-        CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"\\\\\");\n-        printer.close();\n-        assertEquals(\"'\\\\'\", sw.toString());\n-\n-        sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"\\\\\\r\");\n-        printer.close();\n-        assertEquals(\"'\\\\\\r'\", sw.toString());\n-\n-        sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"X\\\\\\r\");\n-        printer.close();\n-        assertEquals(\"'X\\\\\\r'\", sw.toString());\n-\n-        sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.printRecord(new Object[] { \"\\\\\\r\" });\n-        printer.close();\n-        assertEquals(\"'\\\\\\r'\" + eol, sw.toString());\n-\n-        sw = new StringWriter();\n-        printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(quoteChar));\n-        printer.print(\"\\\\\\\\\");\n-        printer.close();\n-        assertEquals(\"'\\\\\\\\'\", sw.toString());\n-\n-    }\n-\n-    @Test\n-    public void testPlainEscaped() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n-        printer.print(\"abc\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"abc,xyz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testDelimiterEscaped() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"a!,b!,c,xyz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testEOLEscaped() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n-        printer.print(\"a\\rb\\nc\");\n-        printer.print(\"x\\fy\\bz\");\n-        assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testPlainPlain() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.print(\"abc\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"abc,xyz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testDelimiterPlain() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.print(\"a,b,c\");\n-        printer.print(\"xyz\");\n-        assertEquals(\"a,b,c,xyz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testHeader() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\"));\n+    public void testSkipHeaderRecordFalse() throws IOException {\n+        // functionally identical to testHeader, used to test CSV-153\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw,\n+                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false));\n         printer.printRecord(\"a\", \"b\", \"c\");\n         printer.printRecord(\"x\", \"y\", \"z\");\n         assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testHeaderNotSet() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.printRecord(\"a\", \"b\", \"c\");\n-        printer.printRecord(\"x\", \"y\", \"z\");\n-        assertEquals(\"a,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n         printer.close();\n     }\n \n     }\n \n     @Test\n-    public void testSkipHeaderRecordFalse() throws IOException {\n-        // functionally identical to testHeader, used to test CSV-153\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw,\n-                CSVFormat.DEFAULT.withQuote(null).withHeader(\"C1\", \"C2\", \"C3\").withSkipHeaderRecord(false));\n-        printer.printRecord(\"a\", \"b\", \"c\");\n-        printer.printRecord(\"x\", \"y\", \"z\");\n-        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testHeaderCommentExcel() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final Date now = new Date();\n-        final CSVFormat format = CSVFormat.EXCEL;\n-        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n-        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\",\n-                sw.toString());\n-        csvPrinter.close();\n-    }\n-\n-    @Test\n-    public void testHeaderCommentTdf() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final Date now = new Date();\n-        final CSVFormat format = CSVFormat.TDF;\n-        final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n-        assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\",\n-                sw.toString());\n-        csvPrinter.close();\n-    }\n-\n-    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n-            throws IOException {\n-        CSVFormat format = baseFormat;\n-        // Use withHeaderComments first to test CSV-145\n-        format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);\n-        format = format.withCommentMarker('#');\n-        format = format.withHeader(\"Col1\", \"Col2\");\n-        final CSVPrinter csvPrinter = format.print(sw);\n-        csvPrinter.printRecord(\"A\", \"B\");\n-        csvPrinter.printRecord(\"C\", \"D\");\n-        csvPrinter.close();\n-        return csvPrinter;\n-    }\n-\n-    @Test\n-    public void testEOLPlain() throws IOException {\n-        final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n-        printer.print(\"a\\rb\\nc\");\n-        printer.print(\"x\\fy\\bz\");\n-        assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n-        printer.close();\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testInvalidFormat() throws Exception {\n-        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n-        new CSVPrinter(new StringWriter(), invalidFormat).close();\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testNewCSVPrinterNullAppendableFormat() throws Exception {\n-        new CSVPrinter(null, CSVFormat.DEFAULT).close();\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testNewCsvPrinterAppendableNullFormat() throws Exception {\n-        new CSVPrinter(new StringWriter(), null).close();\n+    public void testTrimOnOneColumn() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n+        printer.print(\" A \");\n+        assertEquals(\"A\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testTrimOnTwoColumns() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim());\n+        printer.print(\" A \");\n+        printer.print(\" B \");\n+        assertEquals(\"A,B\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testTrailingDelimiterOnTwoColumns() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrailingDelimiter());\n+        printer.printRecord(\"A\", \"B\");\n+        assertEquals(\"A,B,\\r\\n\", sw.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testTrimOffOneColumn() throws IOException {\n+        final StringWriter sw = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withTrim(false));\n+        printer.print(\" A \");\n+        assertEquals(\"\\\" A \\\"\", sw.toString());\n+        printer.close();\n+    }\n+\n+    private String[] toFirstRecordValues(final String expected, final CSVFormat format) throws IOException {\n+        return CSVParser.parse(expected, format).getRecords().get(0).values();\n     }\n }", "timestamp": 1460960211, "metainfo": ""}