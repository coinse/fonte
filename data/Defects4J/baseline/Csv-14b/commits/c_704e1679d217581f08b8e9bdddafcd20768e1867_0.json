{"sha": "704e1679d217581f08b8e9bdddafcd20768e1867", "log": "CSV-124 replace string concatenation with StringBuilder  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n     /** The values of the record */\n     private final String[] values;\n \n-    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n-            final String comment, final long recordNumber) {\n+    CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber) {\n         this.recordNumber = recordNumber;\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n     public String get(final String name) {\n         if (mapping == null) {\n             throw new IllegalStateException(\n-                    \"No header mapping was specified, the record values can't be accessed by name\");\n+                \"No header mapping was specified, the record values can't be accessed by name\");\n         }\n         final Integer index = mapping.get(name);\n         if (index == null) {\n             throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n-                    mapping.keySet()));\n+                mapping.keySet()));\n         }\n         try {\n             return values[index.intValue()];\n         } catch (final ArrayIndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(String.format(\n-                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n-                    Integer.valueOf(values.length)));\n+                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n+                Integer.valueOf(values.length)));\n         }\n     }\n \n     /**\n      * Returns the comment for this record, if any.\n      *\n-     * @return the comment for this record, or null if no comment for this\n-     *         record is available.\n+     * @return the comment for this record, or null if no comment for this record is available.\n      */\n     public String getComment() {\n         return comment;\n      *\n      * @return an iterator over the values of this record.\n      */\n+    @Override\n     public Iterator<String> iterator() {\n         return toList().iterator();\n     }\n     /**\n      * Puts all values of this record into the given Map.\n      *\n-     * @param map The Map to populate.\n+     * @param map\n+     *            The Map to populate.\n      * @return the given map.\n      */\n     <M extends Map<String, String>> M putIn(final M map) {\n      * Converts the values to a List.\n      *\n      * TODO: Maybe make this public?\n+     * \n      * @return a new List\n      */\n     private List<String> toList() {\n         return putIn(new HashMap<String, String>(values.length));\n     }\n \n-\n     /**\n      * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n      * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n      */\n     @Override\n     public String toString() {\n-        return \"CSVRecord [comment=\" + comment + \", mapping=\" + mapping +\n-                \", recordNumber=\" + recordNumber + \", values=\" +\n-                Arrays.toString(values) + \"]\";\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"CSVRecord [comment=\").append(comment);\n+        sb.append(\", mapping=\").append(mapping);\n+        sb.append(\", recordNumber=\").append(recordNumber);\n+        sb.append(\", values=\").append(Arrays.toString(values)).append(']');\n+        return sb.toString();\n     }\n \n     String[] values() {\n         return values;\n     }\n \n-\n }", "timestamp": 1410370106, "metainfo": ""}