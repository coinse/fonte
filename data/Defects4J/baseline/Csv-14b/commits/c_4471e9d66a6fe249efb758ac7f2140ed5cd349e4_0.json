{"sha": "4471e9d66a6fe249efb758ac7f2140ed5cd349e4", "log": "[CSV-139] CSVPrinter.printRecord(ResultSet) with metadata.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n import java.io.Reader;\n import java.io.Serializable;\n import java.io.StringWriter;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Set;\n  * </p>\n  *\n  * <ul>\n- *      <li>{@link #DEFAULT}</li>\n- *      <li>{@link #EXCEL}</li>\n- *      <li>{@link #MYSQL}</li>\n- *      <li>{@link #RFC4180}</li>\n- *      <li>{@link #TDF}</li>\n+ * <li>{@link #DEFAULT}</li>\n+ * <li>{@link #EXCEL}</li>\n+ * <li>{@link #MYSQL}</li>\n+ * <li>{@link #RFC4180}</li>\n+ * <li>{@link #TDF}</li>\n  * </ul>\n  *\n  * <p>\n  * The {@link CSVParser} provides static methods to parse other input types, for example:\n  * </p>\n  *\n- * <pre>CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);</pre>\n+ * <pre>\n+ * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n+ * </pre>\n  *\n  * <h2>Defining formats</h2>\n  *\n  * </p>\n  *\n  * <pre>\n- * CSVFormat.EXCEL\n- *   .withNullString(&quot;N/A&quot;)\n- *   .withIgnoreSurroundingSpaces(true);\n+ * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n  * </pre>\n  *\n  * <h2>Defining column names</h2>\n  * <h2>Referencing columns safely</h2>\n  *\n  * <p>\n- * If your source contains a header record, you can simplify your code and safely reference columns,\n- * by using {@link #withHeader(String...)} with no arguments:\n+ * If your source contains a header record, you can simplify your code and safely reference columns, by using\n+ * {@link #withHeader(String...)} with no arguments:\n  * </p>\n  *\n  * <pre>\n      * Settings are:\n      * </p>\n      * <ul>\n-     *   <li>withDelimiter(',')</li>\n-     *   <li>withQuote('\"')</li>\n-     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n-     *   <li>withIgnoreEmptyLines(true)</li>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuote('\"')</li>\n+     * <li>withRecordSeparator(\"\\r\\n\")</li>\n+     * <li>withIgnoreEmptyLines(true)</li>\n      * </ul>\n      */\n-    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n-                                                            false, true, CRLF, null, null, null, false, false);\n+    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true,\n+            CRLF, null, null, null, false, false);\n \n     /**\n      * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n      * Settings are:\n      * </p>\n      * <ul>\n-     *   <li>withDelimiter(',')</li>\n-     *   <li>withQuote('\"')</li>\n-     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n-     *   <li>withIgnoreEmptyLines(false)</li>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuote('\"')</li>\n+     * <li>withRecordSeparator(\"\\r\\n\")</li>\n+     * <li>withIgnoreEmptyLines(false)</li>\n      * </ul>\n      */\n     public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n      * Settings are:\n      * </p>\n      * <ul>\n-     *   <li>withDelimiter('\\t')</li>\n-     *   <li>withQuote('\"')</li>\n-     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n-     *   <li>withIgnoreSurroundingSpaces(true)</li>\n+     * <li>withDelimiter('\\t')</li>\n+     * <li>withQuote('\"')</li>\n+     * <li>withRecordSeparator(\"\\r\\n\")</li>\n+     * <li>withIgnoreSurroundingSpaces(true)</li>\n      * </ul>\n      */\n-    public static final CSVFormat TDF =\n-            DEFAULT\n-            .withDelimiter(TAB)\n-            .withIgnoreSurroundingSpaces();\n+    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n \n     /**\n      * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n      * Settings are:\n      * </p>\n      * <ul>\n-     *   <li>withDelimiter('\\t')</li>\n-     *   <li>withQuote(null)</li>\n-     *   <li>withRecordSeparator('\\n')</li>\n-     *   <li>withIgnoreEmptyLines(false)</li>\n-     *   <li>withEscape('\\\\')</li>\n+     * <li>withDelimiter('\\t')</li>\n+     * <li>withQuote(null)</li>\n+     * <li>withRecordSeparator('\\n')</li>\n+     * <li>withIgnoreEmptyLines(false)</li>\n+     * <li>withEscape('\\\\')</li>\n      * </ul>\n+     *\n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n-    public static final CSVFormat MYSQL =\n-            DEFAULT\n-            .withDelimiter(TAB)\n-            .withEscape(BACKSLASH)\n-            .withIgnoreEmptyLines(false)\n-            .withQuote(null)\n-            .withRecordSeparator(LF);\n+    public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n+            .withQuote(null).withRecordSeparator(LF);\n \n     /**\n      * Returns true if the given character is a line break character.\n     /**\n      * Creates a new CSV format with the specified delimiter.\n      *\n-     * <p>Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be\n-     * initialized with null/false.</p>\n+     * <p>\n+     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n+     * with null/false.\n+     * </p>\n      *\n      * @param delimiter\n      *            the char used for value separation, must not be a line break character\n      * @return a new CSV format.\n-     * @throws IllegalArgumentException if the delimiter is a line break character\n+     * @throws IllegalArgumentException\n+     *             if the delimiter is a line break character\n      *\n      * @see #DEFAULT\n      * @see #RFC4180\n      *            the comments to be printed by the Printer before the actual CSV data\n      * @param header\n      *            the header\n-     * @param skipHeaderRecord TODO\n-     * @param allowMissingColumnNames TODO\n-     * @throws IllegalArgumentException if the delimiter is a line break character\n-     */\n-    private CSVFormat(final char delimiter, final Character quoteChar,\n-            final QuoteMode quoteMode, final Character commentStart,\n-            final Character escape, final boolean ignoreSurroundingSpaces,\n-            final boolean ignoreEmptyLines, final String recordSeparator,\n-            final String nullString, final Object[] headerComments, final String[] header,\n-            final boolean skipHeaderRecord, final boolean allowMissingColumnNames) {\n+     * @param skipHeaderRecord\n+     *            TODO\n+     * @param allowMissingColumnNames\n+     *            TODO\n+     * @throws IllegalArgumentException\n+     *             if the delimiter is a line break character\n+     */\n+    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n+            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n+            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n+            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n+            final boolean allowMissingColumnNames) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         validate();\n     }\n \n-    private String[] toStringArray(Object[] values) {\n+    private String[] toStringArray(final Object[] values) {\n         if (values == null) {\n             return null;\n         }\n-        String[] strings = new String[values.length];\n+        final String[] strings = new String[values.length];\n         for (int i = 0; i < values.length; i++) {\n-            Object value = values[i];\n+            final Object value = values[i];\n             strings[i] = value == null ? null : value.toString();\n         }\n         return strings;\n     /**\n      * Specifies whether spaces around values are ignored when parsing input.\n      *\n-     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the\n-     *         value.\n+     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n      */\n     public boolean getIgnoreSurroundingSpaces() {\n         return ignoreSurroundingSpaces;\n      * <ul>\n      * <li>\n      * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n-     * records.\n-     * </li>\n+     * records.</li>\n      * <li>\n      * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n      * </ul>\n     }\n \n     @Override\n-    public int hashCode()\n-    {\n+    public int hashCode() {\n         final int prime = 31;\n         int result = 1;\n \n      * </p>\n      *\n      * @param out\n-     *        the output\n+     *            the output\n      * @return a printer to an output\n      * @throws IOException\n-     *         thrown if the optional header cannot be printed.\n+     *             thrown if the optional header cannot be printed.\n      */\n     public CSVPrinter print(final Appendable out) throws IOException {\n         return new CSVPrinter(out, this);\n             sb.append(' ');\n             sb.append(\"NullString=<\").append(nullString).append('>');\n         }\n-        if(recordSeparator != null) {\n+        if (recordSeparator != null) {\n             sb.append(' ');\n             sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n         }\n      */\n     private void validate() throws IllegalArgumentException {\n         if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n-            throw new IllegalArgumentException(\n-                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n+            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n+                    quoteCharacter + \"')\");\n         }\n \n         if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n-            throw new IllegalArgumentException(\n-                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n+            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n+                    escapeCharacter + \"')\");\n         }\n \n         if (commentMarker != null && delimiter == commentMarker.charValue()) {\n-            throw new IllegalArgumentException(\n-                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n+            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n+                    commentMarker + \"')\");\n         }\n \n         if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n-            throw new IllegalArgumentException(\n-                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n+            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n+                    commentMarker + \"')\");\n         }\n \n         if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n-            throw new IllegalArgumentException(\n-                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n+            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n+                    commentMarker + \"')\");\n         }\n \n         if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n             throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      * Sets the header of the format. The header can either be parsed automatically from the input file with:\n      *\n      * <pre>\n-     * CSVFormat format = aformat.withHeader();</pre>\n+     * CSVFormat format = aformat.withHeader();\n+     * </pre>\n      *\n      * or specified manually with:\n      *\n      * <pre>\n-     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n+     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n+     * </pre>\n+     * <p>\n+     * The header is also used by the {@link CSVPrinter}..\n+     * </p>\n      *\n      * @param header\n      *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n      */\n     public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n+    }\n+\n+    /**\n+     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader();\n+     * </pre>\n+     *\n+     * or specified manually with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader(resultSet);\n+     * </pre>\n+     * <p>\n+     * The header is also used by the {@link CSVPrinter}..\n+     * </p>\n+     *\n+     * @param resultSet\n+     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n+     *            otherwise.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified header\n+     * @throws SQLException\n+     *             SQLException if a database access error occurs or this method is called on a closed result set.\n+     * @since 1.1\n+     */\n+    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n+        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n+    }\n+\n+    /**\n+     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader();\n+     * </pre>\n+     *\n+     * or specified manually with:\n+     *\n+     * <pre>\n+     * CSVFormat format = aformat.withHeader(metaData);\n+     * </pre>\n+     * <p>\n+     * The header is also used by the {@link CSVPrinter}..\n+     * </p>\n+     *\n+     * @param metaData\n+     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n+     *            otherwise.\n+     *\n+     * @return A new CSVFormat that is equal to this but with the specified header\n+     * @throws SQLException\n+     *             SQLException if a database access error occurs or this method is called on a closed result set.\n+     * @since 1.1\n+     */\n+    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n+        String[] labels = null;\n+        if (metaData != null) {\n+            final int columnCount = metaData.getColumnCount();\n+            labels = new String[columnCount];\n+            for (int i = 0; i < columnCount; i++) {\n+                labels[i] = metaData.getColumnLabel(i + 1);\n+            }\n+        }\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, labels, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withNullString(final String nullString) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n         if (isLineBreak(quoteChar)) {\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n+                ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord, allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n      * Sets the record separator of the format to the specified character.\n      *\n-     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n-     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n+     * <p>\n+     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n+     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n+     * </p>\n      *\n      * @param recordSeparator\n      *            the record separator to use for output.\n     /**\n      * Sets the record separator of the format to the specified String.\n      *\n-     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n-     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n+     * <p>\n+     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n+     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n+     * </p>\n      *\n      * @param recordSeparator\n      *            the record separator to use for output.\n      *\n      * @return A new CSVFormat that is equal to this but with the the specified output record separator\n      * @throws IllegalArgumentException\n-     *              if recordSeparator is none of CR, LF or CRLF\n+     *             if recordSeparator is none of CR, LF or CRLF\n      */\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n \n     /**\n      */\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n         return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header,\n-                skipHeaderRecord, allowMissingColumnNames);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, null, header, skipHeaderRecord,\n+                allowMissingColumnNames);\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n      *             if a database access error occurs\n      */\n     public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n-        ResultSetMetaData metaData = resultSet.getMetaData();\n-        final int columnCount = metaData.getColumnCount();\n-        // TODO should printing the header be a parameter to this function or an existing CSVFormat option or a new\n-        // CSVFormat option.\n-        boolean printHeader = false;\n-        if (printHeader) {\n-            for (int i = 1; i <= columnCount; i++) {\n-                print(metaData.getColumnLabel(i));\n-            }\n-            println();\n-        }\n+        final int columnCount = resultSet.getMetaData().getColumnCount();\n         while (resultSet.next()) {\n             for (int i = 1; i <= columnCount; i++) {\n                 print(resultSet.getObject(i));\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n import java.io.StringWriter;\n import java.sql.Connection;\n import java.sql.DriverManager;\n+import java.sql.ResultSet;\n import java.sql.SQLException;\n import java.sql.Statement;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n         printer.close();\n     }\n \n+    private Connection geH2Connection() throws SQLException, ClassNotFoundException {\n+        Class.forName(\"org.h2.Driver\");\n+        return DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n+    }\n+\n     @Test\n     public void testJdbcPrinter() throws IOException, ClassNotFoundException, SQLException {\n         final StringWriter sw = new StringWriter();\n-        Class.forName(\"org.h2.Driver\");\n-        final Connection connection = DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n+        final Connection connection = geH2Connection();\n         try {\n             final Statement stmt = connection.createStatement();\n             setUpTable(stmt);\n         }\n     }\n \n+    @Test\n+    public void testJdbcPrinterWithResultSet() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        Class.forName(\"org.h2.Driver\");\n+        final Connection connection = geH2Connection();\n+        try {\n+            @SuppressWarnings(\"resource\")\n+            // Closed when the connection is closed.\n+            final Statement stmt = connection.createStatement();\n+            setUpTable(stmt);\n+            @SuppressWarnings(\"resource\")\n+            // Closed when the connection is closed.\n+            final ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\");\n+            final CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet).print(sw);\n+            printer.printRecords(resultSet);\n+            assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator,\n+                    sw.toString());\n+            printer.close();\n+        } finally {\n+            connection.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testJdbcPrinterWithResultSetMetaData() throws IOException, ClassNotFoundException, SQLException {\n+        final StringWriter sw = new StringWriter();\n+        Class.forName(\"org.h2.Driver\");\n+        final Connection connection = geH2Connection();\n+        try {\n+            @SuppressWarnings(\"resource\")\n+            // Closed when the connection is closed.\n+            final Statement stmt = connection.createStatement();\n+            setUpTable(stmt);\n+            @SuppressWarnings(\"resource\")\n+            // Closed when the connection is closed.\n+            final ResultSet resultSet = stmt.executeQuery(\"select ID, NAME from TEST\");\n+            final CSVPrinter printer = CSVFormat.DEFAULT.withHeader(resultSet.getMetaData()).print(sw);\n+            printer.printRecords(resultSet);\n+            assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator,\n+                    sw.toString());\n+            printer.close();\n+        } finally {\n+            connection.close();\n+        }\n+    }\n+\n     private void setUpTable(final Statement stmt) throws SQLException {\n         stmt.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255))\");\n         stmt.execute(\"insert into TEST values(1, 'r1')\");\n         stmt.execute(\"insert into TEST values(2, 'r2')\");\n-    }\n-\n-    @Test\n-    @Ignore\n-    public void testJdbcPrinterWithHeaders() throws IOException, ClassNotFoundException, SQLException {\n-        final StringWriter sw = new StringWriter();\n-        Class.forName(\"org.h2.Driver\");\n-        final Connection connection = DriverManager.getConnection(\"jdbc:h2:mem:my_test;\", \"sa\", \"\");\n-        try {\n-            final Statement stmt = connection.createStatement();\n-            setUpTable(stmt);\n-            final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);\n-            printer.printRecords(stmt.executeQuery(\"select ID, NAME from TEST\"));\n-            assertEquals(\"ID,NAME\" + recordSeparator + \"1,r1\" + recordSeparator + \"2,r2\" + recordSeparator, sw.toString());\n-            printer.close();\n-        } finally {\n-            connection.close();\n-        }\n     }\n \n     @Test\n     @Test\n     public void testHeaderCommentExcel() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        Date now = new Date();\n-        CSVFormat format = CSVFormat.EXCEL;\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.EXCEL;\n         final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n         assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1,Col2\\r\\nA,B\\r\\nC,D\\r\\n\", sw.toString());\n         csvPrinter.close();\n     @Test\n     public void testHeaderCommentTdf() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        Date now = new Date();\n-        CSVFormat format = CSVFormat.TDF;\n+        final Date now = new Date();\n+        final CSVFormat format = CSVFormat.TDF;\n         final CSVPrinter csvPrinter = printWithHeaderComments(sw, now, format);\n         assertEquals(\"# Generated by Apache Commons CSV 1.1\\r\\n# \" + now + \"\\r\\nCol1\\tCol2\\r\\nA\\tB\\r\\nC\\tD\\r\\n\", sw.toString());\n         csvPrinter.close();\n     }\n \n-    private CSVPrinter printWithHeaderComments(final StringWriter sw, Date now, CSVFormat baseFormat)\n+    private CSVPrinter printWithHeaderComments(final StringWriter sw, final Date now, final CSVFormat baseFormat)\n             throws IOException {\n         CSVFormat format = baseFormat.withCommentMarker('#').withHeader(\"Col1\", \"Col2\");\n         format = format.withHeaderComments(\"Generated by Apache Commons CSV 1.1\", now);", "timestamp": 1415714447, "metainfo": ""}