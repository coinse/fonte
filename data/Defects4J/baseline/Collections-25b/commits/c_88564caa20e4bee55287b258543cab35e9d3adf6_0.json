{"sha": "88564caa20e4bee55287b258543cab35e9d3adf6", "log": "Remove trailing spaces, formatting + javadoc.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n      * This could be useful during testing as a placeholder.\n      *\n      * @see org.apache.commons.collections4.functors.ExceptionClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @return the closure\n      */\n      * The transformer's result will be ignored.\n      *\n      * @see org.apache.commons.collections4.functors.TransformerClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param transformer  the transformer to run each time in the closure, null means nop\n      * @return the closure\n      * A null closure or zero count returns the <code>NOPClosure</code>.\n      *\n      * @see org.apache.commons.collections4.functors.ForClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param count  the number of times to loop\n      * @param closure  the closure to call repeatedly\n     }\n \n     /**\n-     * Creates a Closure that will call the closure repeatedly until the \n+     * Creates a Closure that will call the closure repeatedly until the\n      * predicate returns false.\n      *\n      * @see org.apache.commons.collections4.functors.WhileClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param predicate  the predicate to use as an end of loop test, not null\n      * @param closure  the closure to call repeatedly, not null\n      * until the predicate returns false.\n      *\n      * @see org.apache.commons.collections4.functors.WhileClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param closure  the closure to call repeatedly, not null\n      * @param predicate  the predicate to use as an end of loop test, not null\n      *\n      * @see org.apache.commons.collections4.functors.InvokerTransformer\n      * @see org.apache.commons.collections4.functors.TransformerClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param methodName  the name of the method\n      * @return the <code>invoker</code> closure\n     /**\n      * Create a new Closure that calls two Closures, passing the result of\n      * the first into the second.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.ChainedClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param closure1  the first closure\n      * @param closure2  the second closure\n     }\n \n     /**\n-     * Create a new Closure that calls each closure in turn, passing the \n+     * Create a new Closure that calls each closure in turn, passing the\n      * result into the next closure.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.ChainedClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param closures  an array of closures to chain\n      * @return the <code>chained</code> closure\n     }\n \n     /**\n-     * Create a new Closure that calls each closure in turn, passing the \n+     * Create a new Closure that calls each closure in turn, passing the\n      * result into the next closure. The ordering is that of the iterator()\n      * method on the collection.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.ChainedClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param closures  a collection of closures to chain\n      * @return the <code>chained</code> closure\n     /**\n      * Create a new Closure that calls another closure based on the\n      * result of the specified predicate.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.IfClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param predicate  the validating predicate\n      * @param trueClosure  the closure called if the predicate is true\n     }\n \n     /**\n-     * Create a new Closure that calls one of two closures depending \n+     * Create a new Closure that calls one of two closures depending\n      * on the specified predicate.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.IfClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param predicate  the predicate to switch on\n      * @param trueClosure  the closure called if the predicate is true\n     }\n \n     /**\n-     * Create a new Closure that calls one of the closures depending \n+     * Create a new Closure that calls one of the closures depending\n      * on the predicates.\n      * <p>\n-     * The closure at array location 0 is called if the predicate at array \n+     * The closure at array location 0 is called if the predicate at array\n      * location 0 returned true. Each predicate is evaluated\n      * until one returns true.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.SwitchClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param predicates  an array of predicates to check, not null\n      * @param closures  an array of closures to call, not null\n     }\n \n     /**\n-     * Create a new Closure that calls one of the closures depending \n+     * Create a new Closure that calls one of the closures depending\n      * on the predicates.\n      * <p>\n      * The closure at array location 0 is called if the predicate at array\n      * location 0 returned true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n      * closure is called.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.SwitchClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param predicates  an array of predicates to check, not null\n      * @param closures  an array of closures to call, not null\n                                                final Closure<? super E> defaultClosure) {\n         return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n     }\n-    \n-    /**\n-     * Create a new Closure that calls one of the closures depending \n-     * on the predicates. \n-     * <p>\n-     * The Map consists of Predicate keys and Closure values. A closure \n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending\n+     * on the predicates.\n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure\n      * is called if its matching predicate returns true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n-     * closure is called. The default closure is set in the map with a \n-     * null key. The ordering is that of the iterator() method on the entryset \n+     * closure is called. The default closure is set in the map with a\n+     * null key. The ordering is that of the iterator() method on the entryset\n      * collection of the map.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.SwitchClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param predicatesAndClosures  a map of predicates to closures\n      * @return the <code>switch</code> closure\n \n     /**\n      * Create a new Closure that uses the input object as a key to find the\n-     * closure to call. \n-     * <p>\n-     * The Map consists of object keys and Closure values. A closure \n+     * closure to call.\n+     * <p>\n+     * The Map consists of object keys and Closure values. A closure\n      * is called if the input object equals the key. If there is no match, the\n      * default closure is called. The default closure is set in the map\n      * using a null key.\n-     * \n+     *\n      * @see org.apache.commons.collections4.functors.SwitchClosure\n-     * \n+     *\n      * @param <E>  the type that the closure acts on\n      * @param objectsAndClosures  a map of objects to closures\n      * @return the closure\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n      * @param <O>  the element type\n      */\n     private static class CardinalityHelper<O> {\n-        \n+\n         /** Contains the cardinality for each object in collection A. */\n         final Map<O, Integer> cardinalityA;\n-        \n+\n         /** Contains the cardinality for each object in collection B. */\n         final Map<O, Integer> cardinalityB;\n \n         /**\n          * Returns the maximum frequency of an object.\n          * @param obj  the object\n-         * @return the maximum frequency of the object \n+         * @return the maximum frequency of the object\n          */\n         public final int max(final Object obj) {\n             return Math.max(freqA(obj), freqB(obj));\n      * @param <O>  the element type\n      */\n     private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n-        \n+\n         /** Contains the unique elements of the two collections. */\n         private final Set<O> elements;\n-        \n+\n         /** Output collection. */\n         private final List<O> newList;\n \n     /**\n      * Returns an immutable empty collection if the argument is <code>null</code>,\n      * or the argument itself otherwise.\n-     * \n+     *\n      * @param <T> the element type\n      * @param collection the collection, possibly <code>null</code>\n      * @return an empty collection if the argument is <code>null</code>\n      * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n      * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n      * condition, <i>p</i> are subtracted from <i>a</i>.\n-     * \n+     *\n      * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n      * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n      * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n             return true;\n         }\n     }\n-    \n+\n     /**\n      * Returns <code>true</code> iff at least one element is in both collections.\n      * <p>\n                 return new EquatorWrapper(equator, input);\n             }\n         };\n-        \n+\n         return isEqualCollection(collect(a, transformer), collect(b, transformer));\n     }\n \n      * {@link #equals(Object)} and {@link #hashCode()}.\n      * <p>\n      * This class can be used to store objects into a Map.\n-     *  \n+     *\n      * @param <O>  the element type\n      * @since 4.0\n      */\n     private static class EquatorWrapper<O> {\n         private final Equator<O> equator;\n         private final O object;\n-        \n+\n         public EquatorWrapper(final Equator<O> equator, final O object) {\n             this.equator = equator;\n             this.object = object;\n         }\n-        \n+\n         public O getObject() {\n-            return object; \n-        }\n-        \n+            return object;\n+        }\n+\n         @Override\n         public boolean equals(final Object obj) {\n             if (!(obj instanceof EquatorWrapper)) {\n         @Override\n         public int hashCode() {\n             return equator.hash(object);\n-        }        \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n      *\n      *   they will be removed in the output collection\n      * @return a new sorted List, containing the elements of Collection a and b\n      * @throws IllegalArgumentException if either collection is null\n-     * @since 4.0 \n+     * @since 4.0\n      */\n     public static <O extends Comparable<? super O>> List<O> collate(final Collection<? extends O> a,\n                                                                     final Collection<? extends O> b,\n      * @param <O>  the element type\n      * @param a  the first collection, must not be null\n      * @param b  the second collection, must not be null\n-     * @param c  the comparator to use for the merge. \n+     * @param c  the comparator to use for the merge.\n      * @return a new sorted List, containing the elements of Collection a and b\n      * @throws IllegalArgumentException if either collection or the comparator is null\n-     * @since 4.0 \n+     * @since 4.0\n      */\n     public static <O> List<O> collate(final Collection<? extends O> a, final Collection<? extends O> b,\n                                       final Comparator<? super O> c) {\n         return collate(a, b, c, true);\n     }\n-    \n+\n     /**\n      * Merges two sorted Collections, a and b, into a single, sorted List\n      * such that the ordering of the elements according to Comparator c is retained.\n      * @param <O>  the element type\n      * @param a  the first collection, must not be null\n      * @param b  the second collection, must not be null\n-     * @param c  the comparator to use for the merge. \n+     * @param c  the comparator to use for the merge.\n      * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n      *   they will be removed in the output collection\n      * @return a new sorted List, containing the elements of Collection a and b\n      * @throws IllegalArgumentException if either collection or the comparator is null\n-     * @since 4.0 \n+     * @since 4.0\n      */\n     public static <O> List<O> collate(final Collection<? extends O> a, final Collection<? extends O> b,\n                                       final Comparator<? super O> c, final boolean includeDuplicates) {\n-        \n+\n         if (a == null || b == null) {\n             throw new IllegalArgumentException(\"The collections must not be null\");\n         }\n      * <p>\n      * For larger collections it is advised to use a {@link PermutationIterator} to\n      * iterate over all permutations.\n-     * \n+     *\n      * @see PermutationIterator\n-     * \n+     *\n      * @param <E>  the element type\n      * @param collection  the collection to create permutations for, may not be null\n      * @return an unordered collection of all permutations of the input collection\n      * @throws NullPointerException if collection is null\n-     * @since 4.0 \n+     * @since 4.0\n      */\n     public static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n         final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n         return new IteratorIterable<E>(iterator, false);\n     }\n \n-    \n     /**\n      * Gets an iterable that wraps an iterator.  The returned iterable can be\n      * used for multiple iterations.\n--- a/src/main/java/org/apache/commons/collections4/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java\n      * @param <E>  the element type\n      * @param a  the first list\n      * @param b  the second list\n+     * @param equator  the equator used to test object equality\n      * @return the longest common subsequence\n      * @throws IllegalArgumentException if either list or the equator is {@code null}\n      * @since 4.0\n      */\n-    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n+    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b,\n+                                                       final Equator<? super E> equator) {\n         if (a == null || b == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections4/MapUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/MapUtils.java\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     /**\n      * Returns an immutable empty map if the argument is <code>null</code>,\n      * or the argument itself otherwise.\n-     * \n+     *\n      * @param <K> the key type\n      * @param <V> the value type\n      * @param map the map, possibly <code>null</code>\n     public static <K,V> Map<K,V> emptyIfNull(final Map<K,V> map) {\n         return map == null ? Collections.<K,V>emptyMap() : map;\n     }\n-    \n+\n     /**\n      * Null-safe check if the specified map is empty.\n      * <p>\n      * @param valueTransformer the <code>Transformer</code> used to transform the collection value into a value\n      * @throws NullPointerException if the map, collection or transformers are null\n      */\n-    public static <K, V, E> void populateMap(final Map<K, V> map, final Collection<? extends E> collection, \n-                                             final Transformer<E, K> keyTransformer, \n+    public static <K, V, E> void populateMap(final Map<K, V> map, final Collection<? extends E> collection,\n+                                             final Transformer<E, K> keyTransformer,\n                                              final Transformer<E, V> valueTransformer) {\n         final Iterator<? extends E> iter = collection.iterator();\n         while (iter.hasNext()) {\n                                           final Transformer<V, K> keyTransformer) {\n         populateMap(map, collection, keyTransformer, TransformerUtils.<V>nopTransformer());\n     }\n-    \n+\n     /**\n      * Populates a MultiMap using the supplied <code>Transformer</code>s to transform the collection\n      * values into keys and values.\n      * @param valueTransformer the <code>Transformer</code> used to transform the collection value into a value\n      * @throws NullPointerException if the map, collection or transformers are null\n      */\n-    public static <K, V, E> void populateMap(final MultiMap<K, V> map, final Collection<? extends E> collection, \n-                                             final Transformer<E, K> keyTransformer, \n+    public static <K, V, E> void populateMap(final MultiMap<K, V> map, final Collection<? extends E> collection,\n+                                             final Transformer<E, K> keyTransformer,\n                                              final Transformer<E, V> valueTransformer) {\n         final Iterator<? extends E> iter = collection.iterator();\n         while (iter.hasNext()) {", "timestamp": 1367351056, "metainfo": ""}