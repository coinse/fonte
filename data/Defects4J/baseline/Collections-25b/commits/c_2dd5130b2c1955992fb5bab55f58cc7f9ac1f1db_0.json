{"sha": "2dd5130b2c1955992fb5bab55f58cc7f9ac1f1db", "log": "initial commit.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FactoryUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FactoryUtils.java,v 1.1 2002/05/29 02:57:41 arron Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/05/29 02:57:41 $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Struts\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ * A Factory for the creation of Factories. This is more of the factory\n+ * \"pattern\" by definition, but what it creates, is objects which subscribe to\n+ * a factory interface which other systems can rely on them to manufacture\n+ * objects.\n+ *\n+ * @author Arron Bates\n+ * @version $Revision: 1.1 $\n+ */\n+public class FactoryUtils {\n+  \n+  /** Creates a SimpleObjectFactory whith a class definition, which will be\n+   * used to create a new object from an empty constructor.\n+   *\n+   * @param inClass class definition which will be ued to create the new object\n+   * @return the simple object factory.\n+   */\n+  public static SimpleObjectFactory createStandardFactory(Class inClass) {\n+    return new StandardFactory(inClass);\n+  }\n+  \n+  /** Creates a SimpleObjectFactory whith the class definition and argument\n+   * details, which can create a new object from a constructor which requires\n+   * arguments.\n+   *\n+   * @param inClass class definition which will be ued to create the new object\n+   * @param argTypes argument class types for the constructor\n+   * @param argObjects the objects for the arguments themselves\n+   * @return the simple object factory.\n+   */\n+  public static SimpleObjectFactory createStandardFactory(Class inClass,\n+                                                          Class[] argTypes,\n+                                                          Object[] argObjects) {\n+    return new StandardFactory(inClass, argTypes, argObjects);\n+  }\n+  \n+  \n+  \n+  /* A simple factory, which takes the bare bones of object creation to do just\n+   * that, create new objects.\n+   */\n+  private static class StandardFactory implements SimpleObjectFactory {\n+    \n+    /* builds the object factory. The class definition can creat objects which\n+     * have no-argument constructors.\n+     */\n+    public StandardFactory(Class inClass) {\n+      this.classDefinition = inClass;\n+    }\n+    \n+    /* builds the object factory taking all the options needed to provide\n+     * arguments to a constructor.\n+     */\n+    public StandardFactory(Class inClass, Class[] argTypes, Object[] argObjects) {\n+      this(inClass);\n+      this.argTypes = argTypes;\n+      this.argObjects = argObjects;\n+    }\n+  \n+  \n+  \n+    /* This method is the beast that creates the new objects. Problem faced is that\n+     * the Exceptions thrown are all RuntimeExceptions, meaning that for this class\n+     * to be used as a java.util.Map implementation itself, it has to guide the\n+     * exceptions as the runtime excpetions commonly thrown by these objects.\n+     *\n+     * Thinly disguising the error as a null pointer, with a modified message for\n+     * debugging.\n+     */\n+    public Object createObject() {\n+      \n+      Object obj = null;\n+      /* for catching error specifics */\n+      String fubar = null;\n+      \n+      try {\n+        if ((argTypes == null) || (argObjects == null)) {\n+          /* no arguments, make object with empty constructor */\n+          obj = this.classDefinition.newInstance();\n+        } else {\n+          /* construct object with argument details */\n+          Constructor constructor = this.classDefinition.getConstructor(argTypes);\n+          obj = constructor.newInstance(argObjects);\n+        }\n+      } catch (InstantiationException ex) {\n+        fubar = ex.getMessage();\n+      } catch (IllegalAccessException ex) {\n+        fubar = ex.getMessage();\n+      } catch (IllegalArgumentException ex) {\n+        fubar = ex.getMessage();\n+      } catch (NoSuchMethodException ex) {\n+        fubar = ex.getMessage();\n+      } catch (InvocationTargetException ex) {\n+        fubar = ex.getMessage();\n+      }\n+      \n+      /* fake our Exception if required */\n+      if (fubar != null) {\n+        /* guise the error as a more typical error */\n+  \t    throw new NullPointerException(\"Failed object creation :: \"+ fubar +\"\\n\");\n+      }\n+      \n+      return obj;\n+    }\n+  \n+    /* class definition for new object creation */\n+    private Class classDefinition;\n+  \n+    /* construcor details, optional */\n+    private Class[] argTypes;\n+    private Object[] argObjects;\n+  }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/LazyCollections.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/LazyCollections.java,v 1.1 2002/05/29 02:57:41 arron Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/05/29 02:57:41 $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Struts\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ * This is the factory manager for the lazy object creation collections. The\n+ * collections are within package scope only, so factory creation can be\n+ * standardised for these collections, and to provide a more convenient single\n+ * point entry for their use.\n+ *\n+ * Use the static factory methods to wrap your various collections in the Lazy\n+ * implementations so they can creat objects for incomming requestes.\n+ *\n+ * This class also holds the standard object factory, which has the means to\n+ * create simply the objects for the incomming requests. If all you need is a\n+ * new class built from an empty constructor, then all you need to provide is\n+ * the class definition.\n+ *\n+ * @see org.apache.commons.collections.LazyList\n+ * @see org.apache.commons.collections.LazyMap\n+ * @see org.apache.commons.collections.LazySortedMap\n+ *\n+ * @author Arron Bates\n+ * @version $Revision: 1.1 $\n+ */\n+public class LazyCollections {\n+  \n+  \n+  /** Creates a LazyMap whith the provided object factory.\n+   *\n+   * @param inMap the java.util.Map implementation we have to wrap.\n+   * @param factory SimpleObjectFactory for new object creation\n+   * @return the wrapped Map reference\n+   */\n+  public static Map lazyMap(Map inMap, SimpleObjectFactory factory) {\n+    /* creates a new lazy map with the provided factory */\n+\t  return new LazyMap(inMap, factory);\n+  }\n+  \n+  /** Creates a LazyMap whith the class definition, which will be used to create\n+   * a SimpleObjectFactory which will create a new object from an empty\n+   * constructor.\n+   *\n+   * @param inMap the java.util.Map implementation we have to wrap.\n+   * @param inClass class definition which will be ued to create the new object\n+   * @return the wrapped Map reference\n+   */\n+  public static Map lazyMap(Map inMap, Class inClass) {\n+    /* creates a new lazy map with a new object factory */\n+    SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass);\n+\t  return new LazyMap(inMap, f);\n+  }\n+  \n+  /** Creates a LazyMap whith the class definition and argument details, which\n+   * will be used to create a SimpleObjectFactory which will create a new object\n+   * from a constructor which requires arguments.\n+   *\n+   * @param inMap the java.util.Map implementation we have to wrap.\n+   * @param inClass class definition which will be ued to create the new object\n+   * @param argTypes argument class types for the constructor\n+   * @param argObjects the objects for the arguments themselves\n+   * @return the wrapped Map reference\n+   */\n+  public static Map lazyMap(Map inMap, Class inClass, Class[] argTypes,\n+                            Object[] argObjects) {\n+    /* creates a new lazy map with a new object factory */\n+    SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass, argTypes, argObjects);\n+    return new LazyMap(inMap, f);\n+  }\n+\n+\n+  /** Creates a LazySortedMap whith the provided object factory.\n+   *\n+   * @param inMap the java.util.SortedMap implementation we have to wrap.\n+   * @param factory SimpleObjectFactory for new object creation\n+   * @return the wrapped SortedMap reference\n+   */\n+  public static SortedMap lazySortedMap(SortedMap inMap,\n+                                        SimpleObjectFactory factory) {\n+    /* creates a new lazy sorted map with the provided factory */\n+\t  return new LazySortedMap(inMap, factory);\n+  }\n+  \n+  /** Creates a LazySortedMap whith the class definition, which will be used to\n+   * create a SimpleObjectFactory which will create a new object from an empty\n+   * constructor.\n+   *\n+   * @param inMap the java.util.SortedMap implementation we have to wrap.\n+   * @param inClass class definition which will be ued to create the new object\n+   * @return the wrapped SortedMap reference\n+   */\n+  public static SortedMap lazySortedMap(SortedMap inMap, Class inClass) {\n+    /* creates a new lazy sorted map with a new object factory */\n+    SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass);\n+\t  return new LazySortedMap(inMap, f);\n+  }\n+  \n+  /** Creates a LazySortedMap whith the class definition and argument details,\n+   * which will be used to create a SimpleObjectFactory which will create a new\n+   * object from a constructor which requires arguments.\n+   *\n+   * @param inMap the java.util.SortedMap implementation we have to wrap.\n+   * @param inClass class definition which will be ued to create the new object\n+   * @param argTypes argument class types for the constructor\n+   * @param argObjects the objects for the arguments themselves\n+   * @return the wrapped SortedMap reference\n+   */\n+  public static SortedMap lazySortedMap(SortedMap inMap, Class inClass,\n+                                        Class[] argTypes, Object[] argObjects) {\n+    /* creates a new lazy sorted map with a new object factory */\n+    SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass, argTypes, argObjects);\n+    return new LazySortedMap(inMap, f);\n+  }\n+  \n+  \n+  /** Creates a LazyList whith the provided object factory.\n+   *\n+   * @param inMap the java.util.List implementation we have to wrap.\n+   * @param factory SimpleObjectFactory for new object creation\n+   * @return the wrapped List reference\n+   */\n+  public static List lazyList(List inList, SimpleObjectFactory factory) {\n+    /* creates a new lazy list with the provided factory */\n+    return new LazyList(inList, factory);\n+  }\n+  \n+  /** Creates a LazyList whith the class definition, which will be used to\n+   * create a SimpleObjectFactory which will create a new object from an empty\n+   * constructor.\n+   *\n+   * @param inMap the java.util.List implementation we have to wrap.\n+   * @param inClass class definition which will be ued to create the new object\n+   * @return the wrapped List reference\n+   */\n+  public static List lazyList(List inList, Class inClass) {\n+    /* creates a new lazy list with a new object factory */\n+    SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass);\n+    return new LazyList(inList, f);\n+  }\n+  \n+  /** Creates a LazyList whith the class definition and argument details,\n+   * which will be used to create a SimpleObjectFactory which will create a new\n+   * object from a constructor which requires arguments.\n+   *\n+   * @param inMap the java.util.List implementation we have to wrap.\n+   * @param inClass class definition which will be ued to create the new object\n+   * @param argTypes argument class types for the constructor\n+   * @param argObjects the objects for the arguments themselves\n+   * @return the wrapped List reference\n+   */\n+  public static List lazyList(List inList, Class inClass, Class[] argTypes,\n+                              Object[] argObjects) {\n+    /* creates a new lazy list with a new object factory */\n+    SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass, argTypes, argObjects);\n+    return new LazyList(inList, f);\n+  }\n+  \n+  \n+  \n+  /** Cleans a List implementation from nulls. Because a rampant index up the\n+   * line can create many nulls. At some point, the collection has to become\n+   * useful outside of reliable index use. clean() does this.\n+   *\n+   * @param inList Lsit to rip the nulls out of\n+   */\n+  public static void clean(List inList) {\n+    /* loop through backwards, removing out any nulls found */\n+    for (int i = (inList.size()-1); i >= 0; i--) {\n+      if (inList.get(i) == null) {\n+        inList.remove(i);\n+      }\n+    }\n+  }\n+  \n+  \n+  \n+  /* This is a java.util.List implementation which provides the means of objects\n+   * when requested. When a system expects an object to be provided when accessed\n+   * via an index, this collection has been provided the rules (factory reference)\n+   * to create an object, add it to the list and return it to the request.\n+   *\n+   * For example, when a request comes into the Struts controller for a bean, it\n+   * will created the bean. These request references can be indexed or mapped.\n+   * Problem for many reasons is that there is not an object waiting within the\n+   * session object. To recieve these updates, objects have to be created from the\n+   * collections that hold them.\n+   *\n+   * Only issue for lists, is that indexes will most often ben requested outside\n+   * the boulds of the list. This implementation will pack the spaces with null\n+   * objects. To make the list useful to business logic, a call to\n+   * <code>clean()</code> will clear the list of these null references.\n+   */\n+  private static class LazyList implements List {\n+    \n+    \n+    /* Builds a LazyList with the provided SimpleObjectFactory as the means of\n+     * creating the objects.\n+     */\n+    public LazyList(List inList, SimpleObjectFactory factory) {\n+      this.listImpl = inList;\n+      this.factory = factory;\n+    }\n+    \n+    \n+    /* Proxy method to the impl's get method. With the exception that if it's out\n+     * of bounds, then the collection will grow, leaving place-holders in its\n+     * wake, so that an item can be set at any given index. Later the\n+     * place-holders are removed to return to a pure collection.\n+     *\n+     * If there's a place-holder at the index, then it's replaced with a proper\n+     * object to be used.\n+     */\n+    public Object get(int index) {\n+      Object obj;\n+      int size = listImpl.size();\n+      if (index < this.listImpl.size()) {\n+        /* within bounds, get the object */\n+        obj = this.listImpl.get(index);\n+        if (obj == null) {\n+          /* item is a place holder, create new one, set and return */\n+          obj = this.factory.createObject();\n+          this.listImpl.set(index, obj);\n+          return obj;\n+        } else {\n+          /* good and ready to go */\n+          return obj;\n+        }\n+      } else {\n+        /* we have to grow the list */\n+        for (int i = this.listImpl.size(); i < (this.listImpl.size()-1); i++) {\n+          this.listImpl.add(null);\n+        }\n+        /* create our last object, set and return */\n+        obj = this.factory.createObject();\n+        this.listImpl.add(obj);\n+        return obj;\n+      }\n+    }\n+  \n+  \n+    /* proxy the call to the provided list implementation. */\n+    public List subList(int fromIndex, int toIndex) {\n+      /* wrap the returned sublist so it can continue the functionality */\n+      return new LazyList(this.listImpl.subList(fromIndex, toIndex), factory);\n+    }\n+    \n+    /* proxy the call to the provided list implementation.*/\n+    public int size() {\n+      return this.listImpl.size();\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean isEmpty() {\n+      return this.listImpl.isEmpty();\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean contains(Object o) {\n+      return this.listImpl.contains(o);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public Iterator iterator() {\n+      return this.listImpl.iterator();\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public Object[] toArray() {\n+      return this.listImpl.toArray();\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public Object[] toArray(Object[] a) {\n+      return this.listImpl.toArray(a);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean add(Object o) {\n+      return this.listImpl.add(o);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean remove(Object o) {\n+      return this.listImpl.remove(o);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean containsAll(Collection c) {\n+      return this.listImpl.containsAll(c);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean addAll(Collection c) {\n+      return this.listImpl.addAll(c);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean addAll(int index, Collection c) {\n+      return this.listImpl.addAll(index, c);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean removeAll(Collection c) {\n+      return this.listImpl.removeAll(c);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public boolean retainAll(Collection c) {\n+      return this.listImpl.retainAll(c);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public void clear() {\n+      this.listImpl.clear();\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public Object set(int index, Object element) {\n+      return this.listImpl.set(index, element);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public void add(int index, Object element) {\n+      this.listImpl.add(index, element);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public Object remove(int index) {\n+      return this.listImpl.remove(index);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public int indexOf(Object o) {\n+      return this.listImpl.indexOf(o);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public int lastIndexOf(Object o) {\n+      return this.listImpl.lastIndexOf(o);\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public ListIterator listIterator() {\n+      return this.listImpl.listIterator();\n+    }\n+    \n+    /* proxy the call to the provided list implementation. */\n+    public ListIterator listIterator(int index) {\n+      return this.listImpl.listIterator(index); \n+    }\n+    \n+  \n+  \n+    /* java.util.List implementation to proxy against */\n+    private List listImpl;\n+    \n+    /* optional object factory */\n+    private SimpleObjectFactory factory;\n+  }\n+    \n+    \n+    \n+    \n+  /* This is a java.util.Map implementation which provides the means of objects\n+   * when requested. When a system expects an object to be provided when accessed\n+   * via a key, this collection has been provided the rules (factory reference)\n+   * to create an object, add it to the map and return it to the request.\n+   *\n+   * For example, when a request comes into the Struts controller for a bean, it\n+   * will created the bean. These request references can be indexed or mapped.\n+   * Problem for many reasons is that there is not an object waiting within the\n+   * session object. To recieve these updates, objects have to be created from the\n+   * collections that hold them.\n+   */\n+  private static class LazyMap implements Map {\n+    \n+    \n+    /* Builds a LazyMap with the provided SimpleObjectFactory as the means of\n+     * creating the objects.\n+     */\n+    public LazyMap(Map inMap, SimpleObjectFactory factory) {\n+      this.mapImpl = inMap;\n+      this.factory = factory;\n+    }\n+    \n+    \n+    /* Proxy method to the impl's get method. With the exception that if there\n+     * is no keyed object waiting for it, an object will be created, set and\n+     * returned.\n+     */\n+    public Object get(Object key) {\n+      Object obj = this.mapImpl.get(key);\n+      if (obj == null) {\n+        /* create our last object, set and return */\n+        obj = this.factory.createObject();\n+        this.mapImpl.put(key, obj);\n+      }\n+      return obj;\n+    }\n+    \n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public int size() {\n+      return this.mapImpl.size();\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public boolean isEmpty() {\n+      return this.mapImpl.isEmpty();\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public boolean containsKey(Object key) {\n+      return this.mapImpl.containsKey(key);\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public boolean containsValue(Object value) {\n+      return this.mapImpl.containsValue(value);\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public Object put(Object key, Object value) {\n+      return this.mapImpl.put(key, value);\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public Object remove(Object key) {\n+      return this.mapImpl.remove(key);\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public void putAll(Map t) {\n+      this.mapImpl.putAll(t);\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public void clear() {\n+      this.mapImpl.clear();\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public Set keySet() {\n+      return this.mapImpl.keySet();\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public Collection values() {\n+      return this.mapImpl.values();\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public Set entrySet() {\n+      return this.mapImpl.entrySet();\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public boolean equals(Object o) {\n+      return this.mapImpl.equals(o);\n+    }\n+    \n+    /* proxy the call to the provided Map implementation. */\n+    public int hashCode() {\n+      return this.mapImpl.hashCode();\n+    }\n+  \n+  \n+    /* java.util.Map implementation to proxy against */\n+    protected Map mapImpl;\n+    \n+    /* optional object factory */\n+    protected SimpleObjectFactory factory;\n+  }\n+  \n+  \n+  \n+  \n+  \n+  /* This is a java.util.SortedMap implementation which provides the means of objects\n+   * when requested. When a system expects an object to be provided when accessed\n+   * via a key, this collection has been provided the rules (factory reference)\n+   * to create an object, add it to the map and return it to the request.\n+   *\n+   * For example, when a request comes into the Struts controller for a bean, it\n+   * will created the bean. These request references can be indexed or mapped.\n+   * Problem for many reasons is that there is not an object waiting within the\n+   * session object. To recieve these updates, objects have to be created from the\n+   * collections that hold them.\n+   */\n+  private static class LazySortedMap extends LazyMap implements SortedMap {\n+    \n+    \n+    /* Builds a LazySortedMap with the provided SimpleObjectFactory as the means of\n+     * creating the objects.\n+     */\n+    public LazySortedMap(SortedMap inMap, SimpleObjectFactory factory) {\n+      super(inMap, factory);\n+    }\n+    \n+    \n+    /* proxy the call to the provided LazySortedMap implementation. */\n+    public Comparator comparator() {\n+      return ((SortedMap)super.mapImpl).comparator();\n+    }\n+    \n+    /* proxy the call to the provided LazySortedMap implementation. */\n+    public SortedMap subMap(Object fromKey, Object toKey) {\n+      SortedMap subby = ((SortedMap)super.mapImpl).subMap(fromKey, toKey);\n+      return new LazySortedMap(subby, super.factory);\n+    }\n+    \n+    /* proxy the call to the provided LazySortedMap implementation. */\n+    public SortedMap headMap(Object toKey) {\n+      SortedMap heady = ((SortedMap)super.mapImpl).headMap(toKey);\n+      return new LazySortedMap(heady, super.factory);\n+    }\n+    \n+    /* proxy the call to the provided LazySortedMap implementation. */\n+    public SortedMap tailMap(Object fromKey) {\n+      SortedMap tailer = ((SortedMap)super.mapImpl).tailMap(fromKey);\n+      return new LazySortedMap(tailer, super.factory);\n+    }\n+    \n+    /* proxy the call to the provided LazySortedMap implementation. */\n+    public Object firstKey() {\n+      return ((SortedMap)super.mapImpl).firstKey();\n+    }\n+    \n+    /* proxy the call to the provided LazySortedMap implementation. */\n+    public Object lastKey() {\n+      return ((SortedMap)super.mapImpl).lastKey();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/SimpleObjectFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/SimpleObjectFactory.java,v 1.1 2002/05/29 02:57:41 arron Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/05/29 02:57:41 $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Struts\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+/**\n+ * SimpleObjectFactory\n+ * A simple interface that describes the most basic means of having the ability\n+ * to create an object.\n+ *\n+ * @author Arron Bates\n+ * @version $Revision: 1.1 $\n+ */\n+public interface SimpleObjectFactory {\n+\n+  /** Simple method from which will come the new object from the factory.\n+   *\n+   * @return Object reference to the new object.\n+   */\n+  public Object createObject();\n+  \n+}", "timestamp": 1022641061, "metainfo": ""}