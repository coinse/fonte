{"sha": "2854004d91d5c1d19945b97a40d904227bc91e47", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r468690 | scolebourne | 2006-10-28 06:03:11 -0700 (Sat, 28 Oct 2006) | 1 line          COLLECTIONS-229 - Remove deprecated classes and code     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractDualBidiMap implements BidiMap {\n-\n-    /**\n-     * Delegate map array.  The first map contains standard entries, and the \n-     * second contains inverses.\n-     */\n-    protected transient final Map[] maps = new Map[2];\n+public abstract class AbstractDualBidiMap<K, V> implements BidiMap<K, V> {\n+\n+    /**\n+     * Normal delegate map.\n+     */\n+    protected transient Map<K, V> normalMap;\n+\n+    /**\n+     * Reverse delegate map.\n+     */\n+    protected transient Map<V, K> reverseMap;\n+\n     /**\n      * Inverse view of this map.\n      */\n-    protected transient BidiMap inverseBidiMap = null;\n+    protected transient BidiMap<V, K> inverseBidiMap = null;\n+\n     /**\n      * View of the keys.\n      */\n-    protected transient Set keySet = null;\n+    protected transient Set<K> keySet = null;\n+\n     /**\n      * View of the values.\n      */\n-    protected transient Collection values = null;\n+    protected transient Collection<V> values = null;\n+\n     /**\n      * View of the entries.\n      */\n-    protected transient Set entrySet = null;\n+    protected transient Set<Map.Entry<K, V>> entrySet = null;\n \n     /**\n      * Creates an empty map, initialised by <code>createMap</code>.\n      */\n     protected AbstractDualBidiMap() {\n         super();\n-        maps[0] = createMap();\n-        maps[1] = createMap();\n     }\n \n     /**\n      * Neither map is validated, so nulls may be passed in.\n      * If you choose to do this then the subclass constructor must populate\n      * the <code>maps[]</code> instance variable itself.\n-     * \n+     *\n      * @param normalMap  the normal direction map\n      * @param reverseMap  the reverse direction map\n      * @since Commons Collections 3.1\n      */\n-    protected AbstractDualBidiMap(Map normalMap, Map reverseMap) {\n+    protected AbstractDualBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap) {\n         super();\n-        maps[0] = normalMap;\n-        maps[1] = reverseMap;\n-    }\n-\n-    /** \n+        this.normalMap = normalMap;\n+        this.reverseMap = reverseMap;\n+    }\n+\n+    /**\n      * Constructs a map that decorates the specified maps,\n      * used by the subclass <code>createBidiMap</code> implementation.\n      *\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected AbstractDualBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+    protected AbstractDualBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n         super();\n-        maps[0] = normalMap;\n-        maps[1] = reverseMap;\n+        this.normalMap = normalMap;\n+        this.reverseMap = reverseMap;\n         this.inverseBidiMap = inverseBidiMap;\n     }\n \n     /**\n-     * Creates a new instance of the map used by the subclass to store data.\n-     * <p>\n-     * This design is deeply flawed and has been deprecated.\n-     * It relied on subclass data being used during a superclass constructor.\n-     * \n-     * @return the map to be used for internal storage\n-     * @deprecated For constructors, use the new two map constructor.\n-     * For deserialization, populate the maps array directly in readObject.\n-     */\n-    protected Map createMap() {\n-        return null;\n-    }\n-\n-    /**\n      * Creates a new instance of the subclass.\n-     * \n+     *\n      * @param normalMap  the normal direction map\n      * @param reverseMap  the reverse direction map\n      * @param inverseMap  this map, which is the inverse in the new map\n      * @return the inverse map\n      */\n-    protected abstract BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseMap);\n+    protected abstract BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap);\n \n     // Map delegation\n     //-----------------------------------------------------------------------\n-    public Object get(Object key) {\n-        return maps[0].get(key);\n+    public V get(Object key) {\n+        return normalMap.get(key);\n     }\n \n     public int size() {\n-        return maps[0].size();\n+        return normalMap.size();\n     }\n \n     public boolean isEmpty() {\n-        return maps[0].isEmpty();\n+        return normalMap.isEmpty();\n     }\n \n     public boolean containsKey(Object key) {\n-        return maps[0].containsKey(key);\n+        return normalMap.containsKey(key);\n     }\n \n     public boolean equals(Object obj) {\n-        return maps[0].equals(obj);\n+        return normalMap.equals(obj);\n     }\n \n     public int hashCode() {\n-        return maps[0].hashCode();\n+        return normalMap.hashCode();\n     }\n \n     public String toString() {\n-        return maps[0].toString();\n+        return normalMap.toString();\n     }\n \n     // BidiMap changes\n     //-----------------------------------------------------------------------\n-    public Object put(Object key, Object value) {\n-        if (maps[0].containsKey(key)) {\n-            maps[1].remove(maps[0].get(key));\n-        }\n-        if (maps[1].containsKey(value)) {\n-            maps[0].remove(maps[1].get(value));\n-        }\n-        final Object obj = maps[0].put(key, value);\n-        maps[1].put(value, key);\n+    public V put(K key, V value) {\n+        if (normalMap.containsKey(key)) {\n+            reverseMap.remove(normalMap.get(key));\n+        }\n+        if (reverseMap.containsKey(value)) {\n+            normalMap.remove(reverseMap.get(value));\n+        }\n+        final V obj = normalMap.put(key, value);\n+        reverseMap.put(value, key);\n         return obj;\n     }\n-    \n-    public void putAll(Map map) {\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n \n-    public Object remove(Object key) {\n-        Object value = null;\n-        if (maps[0].containsKey(key)) {\n-            value = maps[0].remove(key);\n-            maps[1].remove(value);\n+    public V remove(Object key) {\n+        V value = null;\n+        if (normalMap.containsKey(key)) {\n+            value = normalMap.remove(key);\n+            reverseMap.remove(value);\n         }\n         return value;\n     }\n \n     public void clear() {\n-        maps[0].clear();\n-        maps[1].clear();\n+        normalMap.clear();\n+        reverseMap.clear();\n     }\n \n     public boolean containsValue(Object value) {\n-        return maps[1].containsKey(value);\n+        return reverseMap.containsKey(value);\n     }\n \n     // BidiMap\n      * The setValue() methods only allow a new value to be set.\n      * If the value being set is already in the map, an IllegalArgumentException\n      * is thrown (as setValue cannot change the size of the map).\n-     * \n+     *\n      * @return a map iterator\n      */\n-    public MapIterator mapIterator() {\n-        return new BidiMapIterator(this);\n-    }\n-    \n-    public Object getKey(Object value) {\n-        return maps[1].get(value);\n-    }\n-\n-    public Object removeValue(Object value) {\n-        Object key = null;\n-        if (maps[1].containsKey(value)) {\n-            key = maps[1].remove(value);\n-            maps[0].remove(key);\n+    public MapIterator<K, V> mapIterator() {\n+        return new BidiMapIterator<K, V>(this);\n+    }\n+\n+    public K getKey(Object value) {\n+        return reverseMap.get(value);\n+    }\n+\n+    public K removeValue(Object value) {\n+        K key = null;\n+        if (reverseMap.containsKey(value)) {\n+            key = reverseMap.remove(value);\n+            normalMap.remove(key);\n         }\n         return key;\n     }\n \n-    public BidiMap inverseBidiMap() {\n+    public BidiMap<V, K> inverseBidiMap() {\n         if (inverseBidiMap == null) {\n-            inverseBidiMap = createBidiMap(maps[1], maps[0], this);\n+            inverseBidiMap = createBidiMap(reverseMap, normalMap, this);\n         }\n         return inverseBidiMap;\n     }\n-    \n+\n     // Map views\n     //-----------------------------------------------------------------------\n     /**\n      * Gets a keySet view of the map.\n      * Changes made on the view are reflected in the map.\n      * The set supports remove and clear but not add.\n-     * \n+     *\n      * @return the keySet view\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         if (keySet == null) {\n-            keySet = new KeySet(this);\n+            keySet = new KeySet<K>(this);\n         }\n         return keySet;\n     }\n     /**\n      * Creates a key set iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @param iterator  the iterator to decorate\n      * @return the keySet iterator\n      */\n-    protected Iterator createKeySetIterator(Iterator iterator) {\n-        return new KeySetIterator(iterator, this);\n+    protected Iterator<K> createKeySetIterator(Iterator<K> iterator) {\n+        return new KeySetIterator<K>(iterator, this);\n     }\n \n     /**\n      * Gets a values view of the map.\n      * Changes made on the view are reflected in the map.\n      * The set supports remove and clear but not add.\n-     * \n+     *\n      * @return the values view\n      */\n-    public Collection values() {\n+    public Collection<V> values() {\n         if (values == null) {\n-            values = new Values(this);\n+            values = new Values<V>(this);\n         }\n         return values;\n     }\n     /**\n      * Creates a values iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @param iterator  the iterator to decorate\n      * @return the values iterator\n      */\n-    protected Iterator createValuesIterator(Iterator iterator) {\n-        return new ValuesIterator(iterator, this);\n+    protected Iterator<V> createValuesIterator(Iterator<V> iterator) {\n+        return new ValuesIterator<V>(iterator, this);\n     }\n \n     /**\n      * The Map Entry setValue() method only allow a new value to be set.\n      * If the value being set is already in the map, an IllegalArgumentException\n      * is thrown (as setValue cannot change the size of the map).\n-     * \n+     *\n      * @return the entrySet view\n      */\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         if (entrySet == null) {\n-            entrySet = new EntrySet(this);\n+            entrySet = new EntrySet<K, V>(this);\n         }\n         return entrySet;\n     }\n-    \n+\n     /**\n      * Creates an entry set iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @param iterator  the iterator to decorate\n      * @return the entrySet iterator\n      */\n-    protected Iterator createEntrySetIterator(Iterator iterator) {\n-        return new EntrySetIterator(iterator, this);\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {\n+        return new EntrySetIterator<K, V>(iterator, this);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Inner class View.\n      */\n-    protected static abstract class View extends AbstractCollectionDecorator {\n-        \n+    @SuppressWarnings(\"serial\")\n+    protected static abstract class View<K, V, E> extends AbstractCollectionDecorator<E> {\n+\n         /** The parent map */\n-        protected final AbstractDualBidiMap parent;\n-        \n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n         /**\n          * Constructs a new view of the BidiMap.\n-         * \n+         *\n          * @param coll  the collection view being decorated\n          * @param parent  the parent BidiMap\n          */\n-        protected View(Collection coll, AbstractDualBidiMap parent) {\n+        protected View(Collection<E> coll, AbstractDualBidiMap<K, V> parent) {\n             super(coll);\n             this.parent = parent;\n         }\n \n-        public boolean removeAll(Collection coll) {\n+        public boolean removeAll(Collection<?> coll) {\n             if (parent.isEmpty() || coll.isEmpty()) {\n                 return false;\n             }\n             boolean modified = false;\n-            Iterator it = iterator();\n+            Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 if (coll.contains(it.next())) {\n                     it.remove();\n             return modified;\n         }\n \n-        public boolean retainAll(Collection coll) {\n+        public boolean retainAll(Collection<?> coll) {\n             if (parent.isEmpty()) {\n                 return false;\n             }\n                 return true;\n             }\n             boolean modified = false;\n-            Iterator it = iterator();\n+            Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 if (coll.contains(it.next()) == false) {\n                     it.remove();\n             }\n             return modified;\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Inner class KeySet.\n      */\n-    protected static class KeySet extends View implements Set {\n-        \n+    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = -7107935777385040694L;\n+\n         /**\n          * Constructs a new view of the BidiMap.\n-         * \n+         *\n          * @param parent  the parent BidiMap\n          */\n-        protected KeySet(AbstractDualBidiMap parent) {\n-            super(parent.maps[0].keySet(), parent);\n-        }\n-\n-        public Iterator iterator() {\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySet(AbstractDualBidiMap<K, ?> parent) {\n+            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n+        }\n+\n+        public Iterator<K> iterator() {\n             return parent.createKeySetIterator(super.iterator());\n         }\n-        \n+\n         public boolean contains(Object key) {\n-            return parent.maps[0].containsKey(key);\n+            return parent.normalMap.containsKey(key);\n         }\n \n         public boolean remove(Object key) {\n-            if (parent.maps[0].containsKey(key)) {\n-                Object value = parent.maps[0].remove(key);\n-                parent.maps[1].remove(value);\n+            if (parent.normalMap.containsKey(key)) {\n+                Object value = parent.normalMap.remove(key);\n+                parent.reverseMap.remove(value);\n                 return true;\n             }\n             return false;\n         }\n     }\n-    \n+\n     /**\n      * Inner class KeySetIterator.\n      */\n-    protected static class KeySetIterator extends AbstractIteratorDecorator {\n-        \n+    protected static class KeySetIterator<K> extends AbstractIteratorDecorator<K> {\n+\n         /** The parent map */\n-        protected final AbstractDualBidiMap parent;\n+        protected final AbstractDualBidiMap<K, ?> parent;\n+\n         /** The last returned key */\n-        protected Object lastKey = null;\n+        protected K lastKey = null;\n+\n         /** Whether remove is allowed at present */\n         protected boolean canRemove = false;\n-        \n+\n         /**\n          * Constructor.\n          * @param iterator  the iterator to decorate\n          * @param parent  the parent map\n          */\n-        protected KeySetIterator(Iterator iterator, AbstractDualBidiMap parent) {\n+        protected KeySetIterator(Iterator<K> iterator, AbstractDualBidiMap<K, ?> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n-        \n-        public Object next() {\n+\n+        public K next() {\n             lastKey = super.next();\n             canRemove = true;\n             return lastKey;\n         }\n-        \n+\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n-            Object value = parent.maps[0].get(lastKey);\n+            Object value = parent.normalMap.get(lastKey);\n             super.remove();\n-            parent.maps[1].remove(value);\n+            parent.reverseMap.remove(value);\n             lastKey = null;\n             canRemove = false;\n         }\n     /**\n      * Inner class Values.\n      */\n-    protected static class Values extends View implements Set {\n-        \n+    protected static class Values<V> extends View<Object, V, V> implements Set<V> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 4023777119829639864L;\n+\n         /**\n          * Constructs a new view of the BidiMap.\n-         * \n+         *\n          * @param parent  the parent BidiMap\n          */\n-        protected Values(AbstractDualBidiMap parent) {\n-            super(parent.maps[0].values(), parent);\n-        }\n-\n-        public Iterator iterator() {\n+        @SuppressWarnings(\"unchecked\")\n+        protected Values(AbstractDualBidiMap<?, V> parent) {\n+            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n+        }\n+\n+        public Iterator<V> iterator() {\n             return parent.createValuesIterator(super.iterator());\n         }\n-        \n+\n         public boolean contains(Object value) {\n-            return parent.maps[1].containsKey(value);\n+            return parent.reverseMap.containsKey(value);\n         }\n \n         public boolean remove(Object value) {\n-            if (parent.maps[1].containsKey(value)) {\n-                Object key = parent.maps[1].remove(value);\n-                parent.maps[0].remove(key);\n+            if (parent.reverseMap.containsKey(value)) {\n+                Object key = parent.reverseMap.remove(value);\n+                parent.normalMap.remove(key);\n                 return true;\n             }\n             return false;\n         }\n     }\n-    \n+\n     /**\n      * Inner class ValuesIterator.\n      */\n-    protected static class ValuesIterator extends AbstractIteratorDecorator {\n-        \n+    protected static class ValuesIterator<V> extends AbstractIteratorDecorator<V> {\n+\n         /** The parent map */\n-        protected final AbstractDualBidiMap parent;\n+        protected final AbstractDualBidiMap<Object, V> parent;\n+\n         /** The last returned value */\n-        protected Object lastValue = null;\n+        protected V lastValue = null;\n+\n         /** Whether remove is allowed at present */\n         protected boolean canRemove = false;\n-        \n+\n         /**\n          * Constructor.\n          * @param iterator  the iterator to decorate\n          * @param parent  the parent map\n          */\n-        protected ValuesIterator(Iterator iterator, AbstractDualBidiMap parent) {\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(Iterator<V> iterator, AbstractDualBidiMap<?, V> parent) {\n             super(iterator);\n-            this.parent = parent;\n-        }\n-        \n-        public Object next() {\n+            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n+        }\n+\n+        public V next() {\n             lastValue = super.next();\n             canRemove = true;\n             return lastValue;\n         }\n-        \n+\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n             super.remove(); // removes from maps[0]\n-            parent.maps[1].remove(lastValue);\n+            parent.reverseMap.remove(lastValue);\n             lastValue = null;\n             canRemove = false;\n         }\n     /**\n      * Inner class EntrySet.\n      */\n-    protected static class EntrySet extends View implements Set {\n-        \n+    protected static class EntrySet<K, V> extends View<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 4040410962603292348L;\n+\n         /**\n          * Constructs a new view of the BidiMap.\n-         * \n+         *\n          * @param parent  the parent BidiMap\n          */\n-        protected EntrySet(AbstractDualBidiMap parent) {\n-            super(parent.maps[0].entrySet(), parent);\n-        }\n-\n-        public Iterator iterator() {\n+        protected EntrySet(AbstractDualBidiMap<K, V> parent) {\n+            super(parent.normalMap.entrySet(), parent);\n+        }\n+\n+        public Iterator<Map.Entry<K, V>> iterator() {\n             return parent.createEntrySetIterator(super.iterator());\n         }\n-        \n+\n         public boolean remove(Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry entry = (Map.Entry) obj;\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n             Object key = entry.getKey();\n             if (parent.containsKey(key)) {\n-                Object value = parent.maps[0].get(key);\n+                V value = parent.normalMap.get(key);\n                 if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n-                    parent.maps[0].remove(key);\n-                    parent.maps[1].remove(value);\n+                    parent.normalMap.remove(key);\n+                    parent.reverseMap.remove(value);\n                     return true;\n                 }\n             }\n             return false;\n         }\n     }\n-    \n+\n     /**\n      * Inner class EntrySetIterator.\n      */\n-    protected static class EntrySetIterator extends AbstractIteratorDecorator {\n-        \n+    protected static class EntrySetIterator<K, V> extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n         /** The parent map */\n-        protected final AbstractDualBidiMap parent;\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n         /** The last returned entry */\n-        protected Map.Entry last = null;\n+        protected Map.Entry<K, V> last = null;\n+\n         /** Whether remove is allowed at present */\n         protected boolean canRemove = false;\n-        \n+\n         /**\n          * Constructor.\n          * @param iterator  the iterator to decorate\n          * @param parent  the parent map\n          */\n-        protected EntrySetIterator(Iterator iterator, AbstractDualBidiMap parent) {\n+        protected EntrySetIterator(Iterator<Map.Entry<K, V>> iterator, AbstractDualBidiMap<K, V> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n-        \n-        public Object next() {\n-            last = new MapEntry((Map.Entry) super.next(), parent);\n+\n+        public Map.Entry<K, V> next() {\n+            last = new MapEntry<K, V>(super.next(), parent);\n             canRemove = true;\n             return last;\n         }\n-        \n+\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             // store value as remove may change the entry in the decorator (eg.TreeMap)\n             Object value = last.getValue();\n             super.remove();\n-            parent.maps[1].remove(value);\n+            parent.reverseMap.remove(value);\n             last = null;\n             canRemove = false;\n         }\n     /**\n      * Inner class MapEntry.\n      */\n-    protected static class MapEntry extends AbstractMapEntryDecorator {\n-\n-        /** The parent map */        \n-        protected final AbstractDualBidiMap parent;\n-        \n+    protected static class MapEntry<K, V> extends AbstractMapEntryDecorator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n         /**\n          * Constructor.\n          * @param entry  the entry to decorate\n          * @param parent  the parent map\n          */\n-        protected MapEntry(Map.Entry entry, AbstractDualBidiMap parent) {\n+        protected MapEntry(Map.Entry<K, V> entry, AbstractDualBidiMap<K, V> parent) {\n             super(entry);\n             this.parent = parent;\n         }\n-        \n-        public Object setValue(Object value) {\n-            Object key = MapEntry.this.getKey();\n-            if (parent.maps[1].containsKey(value) &&\n-                parent.maps[1].get(value) != key) {\n+\n+        public V setValue(V value) {\n+            K key = MapEntry.this.getKey();\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != key) {\n                 throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n             }\n             parent.put(key, value);\n-            final Object oldValue = super.setValue(value);\n+            final V oldValue = super.setValue(value);\n             return oldValue;\n         }\n     }\n-    \n+\n     /**\n      * Inner class MapIterator.\n      */\n-    protected static class BidiMapIterator implements MapIterator, ResettableIterator {\n-        \n+    protected static class BidiMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+\n         /** The parent map */\n-        protected final AbstractDualBidiMap parent;\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n         /** The iterator being wrapped */\n-        protected Iterator iterator;\n+        protected Iterator<Map.Entry<K, V>> iterator;\n+\n         /** The last returned entry */\n-        protected Map.Entry last = null;\n+        protected Map.Entry<K, V> last = null;\n+\n         /** Whether remove is allowed at present */\n         protected boolean canRemove = false;\n-        \n+\n         /**\n          * Constructor.\n          * @param parent  the parent map\n          */\n-        protected BidiMapIterator(AbstractDualBidiMap parent) {\n+        protected BidiMapIterator(AbstractDualBidiMap<K, V> parent) {\n             super();\n             this.parent = parent;\n-            this.iterator = parent.maps[0].entrySet().iterator();\n-        }\n-        \n+            this.iterator = parent.normalMap.entrySet().iterator();\n+        }\n+\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n-        \n-        public Object next() {\n-            last = (Map.Entry) iterator.next();\n+\n+        public K next() {\n+            last = iterator.next();\n             canRemove = true;\n             return last.getKey();\n         }\n-        \n+\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n             // store value as remove may change the entry in the decorator (eg.TreeMap)\n-            Object value = last.getValue();\n+            V value = last.getValue();\n             iterator.remove();\n-            parent.maps[1].remove(value);\n+            parent.reverseMap.remove(value);\n             last = null;\n             canRemove = false;\n         }\n-        \n-        public Object getKey() {\n+\n+        public K getKey() {\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n             }\n             return last.getKey();\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n             }\n             return last.getValue();\n         }\n-        \n-        public Object setValue(Object value) {\n+\n+        public V setValue(V value) {\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n             }\n-            if (parent.maps[1].containsKey(value) &&\n-                parent.maps[1].get(value) != last.getKey()) {\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != last.getKey()) {\n                 throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n             }\n             return parent.put(last.getKey(), value);\n         }\n-        \n+\n         public void reset() {\n-            iterator = parent.maps[0].entrySet().iterator();\n+            iterator = parent.normalMap.entrySet().iterator();\n             last = null;\n             canRemove = false;\n         }\n-        \n+\n         public String toString() {\n             if (last != null) {\n                 return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n-            } else {\n-                return \"MapIterator[]\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"MapIterator[]\";\n+        }\n+    }\n+\n }", "timestamp": 1252994056, "metainfo": ""}