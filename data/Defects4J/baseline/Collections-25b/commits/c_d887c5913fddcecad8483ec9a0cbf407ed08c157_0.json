{"sha": "d887c5913fddcecad8483ec9a0cbf407ed08c157", "log": "Applying Joerg's final patch from COLLECTIONS-266, including the unit test that shows the problem and fixes the problem by making the hashcode transient, and moving the hashcode implementation such that it can be called from the deserialization as well as the hashcode method  ", "commit": "\n--- a/src/java/org/apache/commons/collections/keyvalue/MultiKey.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/MultiKey.java\n  */\n package org.apache.commons.collections.keyvalue;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n import java.io.Serializable;\n import java.util.Arrays;\n \n     /** The individual keys */\n     private final Object[] keys;\n     /** The cached hashCode */\n-    private final int hashCode;\n+    private transient int hashCode;\n     \n     /**\n      * Constructor taking two keys.\n             this.keys = keys;\n         }\n         \n-        int total = 0;\n+        calculateHashCode(keys);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a clone of the array of keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed.\n+     * \n+     * @return the individual keys\n+     */\n+    public Object[] getKeys() {\n+        return (Object[]) keys.clone();\n+    }\n+    \n+    /**\n+     * Gets the key at the specified index.\n+     * <p>\n+     * The key should be immutable.\n+     * If it is not then it must not be changed.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since Commons Collections 3.1\n+     */\n+    public Object getKey(int index) {\n+        return keys[index];\n+    }\n+    \n+    /**\n+     * Gets the size of the list of keys.\n+     * \n+     * @return the size of the list of keys\n+     * @since Commons Collections 3.1\n+     */\n+    public int size() {\n+        return keys.length;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to another.\n+     * <p>\n+     * To be equal, the other object must be a <code>MultiKey</code> with the\n+     * same number of keys which are also equal.\n+     * \n+     * @param other  the other object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object other) {\n+        if (other == this) {\n+            return true;\n+        }\n+        if (other instanceof MultiKey) {\n+            MultiKey otherMulti = (MultiKey) other;\n+            return Arrays.equals(keys, otherMulti.keys);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the combined hash code that is computed from all the keys.\n+     * <p>\n+     * This value is computed once and then cached, so elements should not\n+     * change their hash codes once created (note that this is the same \n+     * constraint that would be used if the individual keys elements were\n+     * themselves {@link java.util.Map Map} keys.\n+     * \n+     * @return the hash code\n+     */\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    /**\n+     * Gets a debugging string version of the key.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        return \"MultiKey\" + Arrays.asList(keys).toString();\n+    }\n+\n+\t/**\n+\t * Calculate the hash code of the instance using the provided keys.\n+\t * @param keys\n+\t */\n+\tprivate void calculateHashCode(Object[] keys)\n+\t{\n+\t\tint total = 0;\n         for (int i = 0; i < keys.length; i++) {\n             if (keys[i] != null) {\n                 total ^= keys[i].hashCode();\n             }\n         }\n         hashCode = total;\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets a clone of the array of keys.\n-     * <p>\n-     * The keys should be immutable\n-     * If they are not then they must not be changed.\n-     * \n-     * @return the individual keys\n-     */\n-    public Object[] getKeys() {\n-        return (Object[]) keys.clone();\n-    }\n-    \n-    /**\n-     * Gets the key at the specified index.\n-     * <p>\n-     * The key should be immutable.\n-     * If it is not then it must not be changed.\n-     * \n-     * @param index  the index to retrieve\n-     * @return the key at the index\n-     * @throws IndexOutOfBoundsException if the index is invalid\n-     * @since Commons Collections 3.1\n-     */\n-    public Object getKey(int index) {\n-        return keys[index];\n-    }\n-    \n-    /**\n-     * Gets the size of the list of keys.\n-     * \n-     * @return the size of the list of keys\n-     * @since Commons Collections 3.1\n-     */\n-    public int size() {\n-        return keys.length;\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compares this object to another.\n-     * <p>\n-     * To be equal, the other object must be a <code>MultiKey</code> with the\n-     * same number of keys which are also equal.\n-     * \n-     * @param other  the other object to compare to\n-     * @return true if equal\n-     */\n-    public boolean equals(Object other) {\n-        if (other == this) {\n-            return true;\n-        }\n-        if (other instanceof MultiKey) {\n-            MultiKey otherMulti = (MultiKey) other;\n-            return Arrays.equals(keys, otherMulti.keys);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Gets the combined hash code that is computed from all the keys.\n-     * <p>\n-     * This value is computed once and then cached, so elements should not\n-     * change their hash codes once created (note that this is the same \n-     * constraint that would be used if the individual keys elements were\n-     * themselves {@link java.util.Map Map} keys.\n-     * \n-     * @return the hash code\n-     */\n-    public int hashCode() {\n-        return hashCode;\n-    }\n-\n-    /**\n-     * Gets a debugging string version of the key.\n-     * \n-     * @return a debugging string\n-     */\n-    public String toString() {\n-        return \"MultiKey\" + Arrays.asList(keys).toString();\n-    }\n-\n+\t}\n+\t\n+\t/**\n+\t * Recalculate the hash code after deserialization. The hash code of some\n+\t * keys might have change (hash codes based on the system hash code are\n+\t * only stable for the same process). \n+\t * @return the instance with recalculated hash code\n+\t */\n+\tprivate Object readResolve() {\n+\t\tcalculateHashCode(keys);\n+\t\treturn this;\n+\t}\n }\n--- a/src/test/org/apache/commons/collections/keyvalue/TestMultiKey.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/TestMultiKey.java\n  */\n package org.apache.commons.collections.keyvalue;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import junit.framework.Assert;\n import junit.framework.Test;\n         Assert.assertTrue(mk1.equals(null) == false);\n     }\n     \n+    static class SystemHashCodeSimulatingKey implements Serializable {\n+    \t\n+\t\tprivate static final long serialVersionUID = 1L;\n+\t\tprivate final String name;\n+    \tprivate int hashCode = 1;\n+\n+\t\tpublic SystemHashCodeSimulatingKey(String name)\n+\t\t{\n+\t\t\tthis.name = name;\n+\t\t}\n+\n+\t\tpublic boolean equals(Object obj)\n+\t\t{\n+\t\t\treturn obj instanceof SystemHashCodeSimulatingKey \n+\t\t\t\t&& name.equals(((SystemHashCodeSimulatingKey)obj).name);\n+\t\t}\n+\n+\t\tpublic int hashCode()\n+\t\t{\n+\t\t\treturn hashCode;\n+\t\t}\n+\n+\t\tprivate Object readResolve() {\n+\t\t\thashCode=2; // simulate different hashCode after deserialization in another process\n+\t\t\treturn this;\n+\t\t}\n+    }\n+    \n+    public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException\n+\t{\n+        SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n+\t\tMultiKey mk = new MultiKey(ONE, sysKey);\n+        Map map = new HashMap();\n+        map.put(mk, TWO);\n+\n+        // serialize\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(sysKey);\n+        out.writeObject(map);\n+        out.close();\n+\n+        // deserialize\n+        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        ObjectInputStream in = new ObjectInputStream(bais);\n+        sysKey = (SystemHashCodeSimulatingKey)in.readObject(); // simulate deserialization in another process\n+        Map map2 = (Map) in.readObject();\n+        in.close();\n+\n+        assertEquals(2, sysKey.hashCode()); // different hashCode now\n+\n+        MultiKey mk2 = new MultiKey(ONE, sysKey);\n+        assertEquals(TWO, map2.get(mk2));\t\t\n+\t}\n }", "timestamp": 1212128625, "metainfo": ""}