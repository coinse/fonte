{"sha": "050c817ad5a377a2ab60a51c2f44dad6ce90e106", "log": "37607: Enhance BlockingBuffer to allow for a timeout value  ", "commit": "\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n import org.apache.commons.collections.buffer.TransformedBuffer;\n import org.apache.commons.collections.buffer.TypedBuffer;\n import org.apache.commons.collections.buffer.UnmodifiableBuffer;\n-import org.apache.commons.collections.buffer.TimeoutBuffer;\n \n /**\n  * Provides utility methods and decorators for {@link Buffer} instances.\n  *\n  * @since Commons Collections 2.1\n  * @version $Revision$ $Date$\n- * \n+ *\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  */\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a synchronized buffer backed by the given buffer.\n-     * Much like the synchronized collections returned by \n-     * {@link java.util.Collections}, you must manually synchronize on \n+     * Much like the synchronized collections returned by\n+     * {@link java.util.Collections}, you must manually synchronize on\n      * the returned buffer's iterator to avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * Buffer b = BufferUtils.synchronizedBuffer(myBuffer);\n      * synchronized (b) {\n     /**\n      * Returns a synchronized buffer backed by the given buffer that will\n      * block on {@link Buffer#get()} and {@link Buffer#remove()} operations.\n-     * If the buffer is empty, then the {@link Buffer#get()} and \n+     * If the buffer is empty, then the {@link Buffer#get()} and\n      * {@link Buffer#remove()} operations will block until new elements\n-     * are added to the buffer, rather than immediately throwing a \n+     * are added to the buffer, rather than immediately throwing a\n      * <code>BufferUnderflowException</code>.\n      *\n      * @param buffer  the buffer to synchronize, must not be null\n      * @throws IllegalArgumentException  if the Buffer is null\n      * @since Commons Collections 3.2\n      */\n-    public static Buffer timeoutBuffer(Buffer buffer, long timeout) {\n-        return TimeoutBuffer.decorate(buffer, timeout);\n+    public static Buffer blockingBuffer(Buffer buffer, long timeout) {\n+        return BlockingBuffer.decorate(buffer, timeout);\n     }\n-    \n+\n     /**\n      * Returns an unmodifiable buffer backed by the given buffer.\n      *\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n  */\n package org.apache.commons.collections.buffer;\n \n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n import java.io.PrintWriter;\n import java.io.StringWriter;\n import java.util.Collection;\n \n-import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.BufferUnderflowException;\n-\n /**\n- * Decorates another <code>Buffer</code> to make {@link #get()} and\n- * {@link #remove()} block when the <code>Buffer</code> is empty.\n- * <p>\n- * If either <code>get</code> or <code>remove</code> is called on an empty\n- * <code>Buffer</code>, the calling thread waits for notification that\n- * an <code>add</code> or <code>addAll</code> operation has completed.\n- * <p>\n- * When one or more entries are added to an empty <code>Buffer</code>,\n- * all threads blocked in <code>get</code> or <code>remove</code> are notified.\n- * There is no guarantee that concurrent blocked <code>get</code> or\n- * <code>remove</code> requests will be \"unblocked\" and receive data in the\n- * order that they arrive.\n- * <p>\n+ * Decorates another <code>Buffer</code> to make {@link #get()} and {@link #remove()} block when the <code>Buffer</code>\n+ * is empty.\n+ * <p/>\n+ * If either <code>get</code> or <code>remove</code> is called on an empty <code>Buffer</code>, the calling thread waits\n+ * for notification that an <code>add</code> or <code>addAll</code> operation has completed.\n+ * <p/>\n+ * When one or more entries are added to an empty <code>Buffer</code>, all threads blocked in <code>get</code> or\n+ * <code>remove</code> are notified. There is no guarantee that concurrent blocked <code>get</code> or\n+ * <code>remove</code> requests will be \"unblocked\" and receive data in the order that they arrive.\n+ * <p/>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n  * @author Stephen Colebourne\n  * @author Janek Bogucki\n  * @author Phil Steitz\n+ * @author James Carman\n  * @version $Revision$ $Date$\n  * @since Commons Collections 3.0\n  */\n public class BlockingBuffer extends SynchronizedBuffer {\n+\n     /**\n      * Serialization version\n      */\n     private static final long serialVersionUID = 1719328905017860541L;\n+\n+    private long timeout;\n \n     /**\n      * Factory method to create a blocking buffer.\n      * @return a new blocking Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static Buffer decorate(Buffer buffer) {\n-        return new BlockingBuffer(buffer);\n-    }\n-\n-    //-----------------------------------------------------------------------    \n+    public static Buffer decorate( Buffer buffer ) {\n+        return new BlockingBuffer( buffer );\n+    }\n+\n+    /**\n+     * Factory method to create a blocking buffer with a timeout value.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param timeout the maximum amount of time to block\n+     * @return a new blocking buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    public static Buffer decorate( Buffer buffer, long timeout ) {\n+        return new BlockingBuffer( buffer, timeout );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n     /**\n      * Constructor that wraps (not copies).\n      *\n      * @param buffer the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    protected BlockingBuffer(Buffer buffer) {\n-        super(buffer);\n+    protected BlockingBuffer( Buffer buffer ) {\n+        super( buffer );\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param timeout the maximum amount of time to block\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected BlockingBuffer( Buffer buffer, long timeout ) {\n+        super( buffer );\n+        this.timeout = timeout < 0 ? 0 : timeout;\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add(Object o) {\n-        synchronized (lock) {\n-            boolean result = collection.add(o);\n+    public boolean add( Object o ) {\n+        synchronized( lock ) {\n+            boolean result = collection.add( o );\n             lock.notifyAll();\n             return result;\n         }\n     }\n \n-    public boolean addAll(Collection c) {\n-        synchronized (lock) {\n-            boolean result = collection.addAll(c);\n+    public boolean addAll( Collection c ) {\n+        synchronized( lock ) {\n+            boolean result = collection.addAll( c );\n             lock.notifyAll();\n             return result;\n         }\n     }\n \n     /**\n-     * Gets the next value from the buffer, waiting until an object is\n-     * added if the buffer is empty.\n+     * Gets the next value from the buffer, waiting until an object is added if the buffer is empty.\n      *\n      * @throws BufferUnderflowException if an interrupt is received\n      */\n     public Object get() {\n-        synchronized (lock) {\n-            while (collection.isEmpty()) {\n-                try {\n-                    lock.wait();\n-                } catch (InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n-                    e.printStackTrace(out);\n-                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+        synchronized( lock ) {\n+            while( collection.isEmpty() ) {\n+                try {\n+                    if( timeout <= 0 ) {\n+                        lock.wait();\n+                    }\n+                    else {\n+                        return get( timeout );\n+                    }\n+                }\n+                catch( InterruptedException e ) {\n+                    PrintWriter out = new PrintWriter( new StringWriter() );\n+                    e.printStackTrace( out );\n+                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n                 }\n             }\n             return getBuffer().get();\n     }\n \n     /**\n-     * Gets the next value from the buffer, waiting until an object is\n-     * added for up to the specified timeout value if the buffer is empty.\n-     *\n-     * @param timeout  the timeout value in milliseconds\n+     * Gets the next value from the buffer, waiting until an object is added for up to the specified timeout value if\n+     * the buffer is empty.\n+     *\n+     * @param timeout the timeout value in milliseconds\n      * @throws BufferUnderflowException if an interrupt is received\n      * @throws BufferUnderflowException if the timeout expires\n      * @since Commons Collections 3.2\n      */\n-    public Object get(final long timeout) {\n-        synchronized (lock) {\n+    public Object get( final long timeout ) {\n+        synchronized( lock ) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while (timeLeft > 0 && collection.isEmpty()) {\n-                try {\n-                    lock.wait(timeLeft);\n+            while( timeLeft > 0 && collection.isEmpty() ) {\n+                try {\n+                    lock.wait( timeLeft );\n                     timeLeft = expiration - System.currentTimeMillis();\n-                } catch(InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n-                    e.printStackTrace(out);\n-                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n-                }\n-            }\n-            if (collection.isEmpty()) {\n-                throw new BufferUnderflowException(\"Timeout expired.\");\n+                }\n+                catch( InterruptedException e ) {\n+                    PrintWriter out = new PrintWriter( new StringWriter() );\n+                    e.printStackTrace( out );\n+                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n+                }\n+            }\n+            if( collection.isEmpty() ) {\n+                throw new BufferUnderflowException( \"Timeout expired.\" );\n             }\n             return getBuffer().get();\n         }\n     }\n \n     /**\n-     * Removes the next value from the buffer, waiting until an object is\n-     * added if the buffer is empty.\n+     * Removes the next value from the buffer, waiting until an object is added if the buffer is empty.\n      *\n      * @throws BufferUnderflowException if an interrupt is received\n      */\n     public Object remove() {\n-        synchronized (lock) {\n-            while (collection.isEmpty()) {\n-                try {\n-                    lock.wait();\n-                } catch (InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n-                    e.printStackTrace(out);\n-                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+        synchronized( lock ) {\n+            while( collection.isEmpty() ) {\n+                try {\n+                    if( timeout <= 0 ) {\n+                        lock.wait();\n+                    }\n+                    else {\n+                        return remove( timeout );\n+                    }\n+                }\n+                catch( InterruptedException e ) {\n+                    PrintWriter out = new PrintWriter( new StringWriter() );\n+                    e.printStackTrace( out );\n+                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n                 }\n             }\n             return getBuffer().remove();\n     }\n \n     /**\n-     * Removes the next value from the buffer, waiting until an object is\n-     * added for up to the specified timeout value if the buffer is empty.\n-     *\n-     * @param timeout  the timeout value in milliseconds\n+     * Removes the next value from the buffer, waiting until an object is added for up to the specified timeout value if\n+     * the buffer is empty.\n+     *\n+     * @param timeout the timeout value in milliseconds\n      * @throws BufferUnderflowException if an interrupt is received\n      * @throws BufferUnderflowException if the timeout expires\n      * @since Commons Collections 3.2\n      */\n-    public Object remove(final long timeout) {\n-        synchronized (lock) {\n+    public Object remove( final long timeout ) {\n+        synchronized( lock ) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while (timeLeft > 0 && collection.isEmpty()) {\n-                try {\n-                    lock.wait(timeLeft);\n+            while( timeLeft > 0 && collection.isEmpty() ) {\n+                try {\n+                    lock.wait( timeLeft );\n                     timeLeft = expiration - System.currentTimeMillis();\n-                } catch(InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n-                    e.printStackTrace(out);\n-                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n-                }\n-            }\n-            if (collection.isEmpty()) {\n-                throw new BufferUnderflowException(\"Timeout expired.\");\n+                }\n+                catch( InterruptedException e ) {\n+                    PrintWriter out = new PrintWriter( new StringWriter() );\n+                    e.printStackTrace( out );\n+                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n+                }\n+            }\n+            if( collection.isEmpty() ) {\n+                throw new BufferUnderflowException( \"Timeout expired.\" );\n             }\n             return getBuffer().remove();\n         }\n     }\n-\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n  */\n package org.apache.commons.collections.buffer;\n \n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.Set;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-import org.apache.commons.collections.AbstractTestObject;\n-import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.BufferUnderflowException;\n-\n /**\n- * Extension of {@link TestObject} for exercising the {@link BlockingBuffer}\n- * implementation.\n+ * Extension of {@link AbstractTestObject} for exercising the {@link BlockingBuffer} implementation.\n  *\n- * @since Commons Collections 3.0\n- * @version $Revision$\n- * \n  * @author Janek Bogucki\n  * @author Phil Steitz\n+ * @version $Revision$\n+ * @since Commons Collections 3.0\n  */\n public class TestBlockingBuffer extends AbstractTestObject {\n \n-    public TestBlockingBuffer(String testName) {\n-        super(testName);\n+    public TestBlockingBuffer( String testName ) {\n+        super( testName );\n     }\n \n     public static Test suite() {\n-        return new TestSuite(TestBlockingBuffer.class);\n-    }\n-\n-    public static void main(String args[]) {\n-        String[] testCaseName = { TestBlockingBuffer.class.getName()};\n-        junit.textui.TestRunner.main(testCaseName);\n+        return new TestSuite( TestBlockingBuffer.class );\n+    }\n+\n+    public static void main( String args[] ) {\n+        String[] testCaseName = {TestBlockingBuffer.class.getName()};\n+        junit.textui.TestRunner.main( testCaseName );\n     }\n \n     public Object makeObject() {\n-        return BlockingBuffer.decorate(new MyBuffer());\n+        return BlockingBuffer.decorate( new MyBuffer() );\n     }\n \n     public boolean isEqualsCheckable() {\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add()}.\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add(Object)}.\n      */\n     public void testGetWithAdd() {\n-      \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-\n-        new DelayedAdd(blockingBuffer, obj).start();\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+        new DelayedAdd( blockingBuffer, obj ).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame(obj, blockingBuffer.get());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll()}.\n+        assertSame( obj, blockingBuffer.get() );\n+    }\n+\n+    public void testGetWithAddTimeout() {\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 500 );\n+        Object obj = new Object();\n+        new DelayedAdd( blockingBuffer, obj, 100 ).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame( obj, blockingBuffer.get() );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}.\n      */\n     public void testGetWithAddAll() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-\n-        new DelayedAddAll(blockingBuffer, obj).start();\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+        new DelayedAddAll( blockingBuffer, obj ).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame(obj, blockingBuffer.get());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add()}.\n+        assertSame( obj, blockingBuffer.get() );\n+    }\n+\n+    public void testGetWithAddAllTimeout() {\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 500 );\n+        Object obj = new Object();\n+        new DelayedAddAll( blockingBuffer, obj, 100 ).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame( obj, blockingBuffer.get() );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add(Object)}.\n      */\n     public void testRemoveWithAdd() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-\n-        new DelayedAdd(blockingBuffer, obj).start();\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+        new DelayedAdd( blockingBuffer, obj ).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame(obj, blockingBuffer.remove());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll()}.\n+        assertSame( obj, blockingBuffer.remove() );\n+    }\n+\n+    public void testRemoveWithAddTimeout() {\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 100 );\n+        Object obj = new Object();\n+        new DelayedAdd( blockingBuffer, obj, 500 ).start();\n+        try {\n+            blockingBuffer.remove();\n+        }\n+        catch( BufferUnderflowException e ) {\n+        }\n+    }\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}.\n      */\n     public void testRemoveWithAddAll() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-\n-        new DelayedAddAll(blockingBuffer, obj).start();\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+        new DelayedAddAll( blockingBuffer, obj ).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame(obj, blockingBuffer.remove());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add()} using multiple read threads.\n-     *\n-     *  Two read threads should block on an empty buffer until one object\n-     *  is added then both threads should complete.\n+        assertSame( obj, blockingBuffer.remove() );\n+    }\n+\n+    public void testRemoveWithAddAllTimeout() {\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 100 );\n+        Object obj = new Object();\n+        new DelayedAddAll( blockingBuffer, obj, 500 ).start();\n+        try {\n+            blockingBuffer.remove();\n+        }\n+        catch( BufferUnderflowException e ) {\n+        }\n+    }\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add(Object)} using multiple read\n+     * threads.\n+     * <p/>\n+     * Two read threads should block on an empty buffer until one object is added then both threads should complete.\n      */\n     public void testBlockedGetWithAdd() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-        \n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+\n         // run methods will get and compare -- must wait for add\n-        Thread thread1 = new ReadThread(blockingBuffer, obj);\n-        Thread thread2 = new ReadThread(blockingBuffer, obj);\n+        Thread thread1 = new ReadThread( blockingBuffer, obj );\n+        Thread thread2 = new ReadThread( blockingBuffer, obj );\n         thread1.start();\n         thread2.start();\n-        \n+\n         // give hungry read threads ample time to hang\n         delay();\n-           \n+\n         // notifyAll should allow both read threads to complete\n-        blockingBuffer.add(obj);\n-        \n+        blockingBuffer.add( obj );\n+\n         // allow notified threads to complete \n         delay();\n-        \n+\n         // There should not be any threads waiting.\n-        if (thread1.isAlive() || thread2.isAlive())\n-            fail(\"Live thread(s) when both should be dead.\");\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll()} using multiple read threads.\n-     *\n-     *  Two read threads should block on an empty buffer until a\n-     *  singleton is added then both threads should complete.\n+        if( thread1.isAlive() || thread2.isAlive() ) {\n+            fail( \"Live thread(s) when both should be dead.\" );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)} using\n+     * multiple read threads.\n+     * <p/>\n+     * Two read threads should block on an empty buffer until a singleton is added then both threads should complete.\n      */\n     public void testBlockedGetWithAddAll() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-        \n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+\n         // run methods will get and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread(blockingBuffer, obj);\n-        Thread thread2 = new ReadThread(blockingBuffer, obj);\n+        Thread thread1 = new ReadThread( blockingBuffer, obj );\n+        Thread thread2 = new ReadThread( blockingBuffer, obj );\n         thread1.start();\n         thread2.start();\n-        \n+\n         // give hungry read threads ample time to hang\n         delay();\n-           \n+\n         // notifyAll should allow both read threads to complete\n-        blockingBuffer.addAll(Collections.singleton(obj));\n-               \n+        blockingBuffer.addAll( Collections.singleton( obj ) );\n+\n         // allow notified threads to complete \n         delay();\n-        \n+\n         // There should not be any threads waiting.\n-        if (thread1.isAlive() || thread2.isAlive())\n-            fail(\"Live thread(s) when both should be dead.\");\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests interrupted {@link BlockingBuffer#get()}.\n+        if( thread1.isAlive() || thread2.isAlive() ) {\n+            fail( \"Live thread(s) when both should be dead.\" );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests interrupted {@link BlockingBuffer#get()}.\n      */\n     public void testInterruptedGet() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-        \n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+\n         // spawn a read thread to wait on the empty buffer\n         ArrayList exceptionList = new ArrayList();\n-        Thread thread = new ReadThread(blockingBuffer, obj, exceptionList);\n+        Thread thread = new ReadThread( blockingBuffer, obj, exceptionList );\n         thread.start();\n-        \n+\n         // Interrupting the thread should cause it to throw BufferUnderflowException\n         thread.interrupt();\n-        \n+\n         // Chill, so thread can throw and add message to exceptionList\n         delay();\n-        \n-        assertTrue(\"Thread interrupt should have led to underflow\", \n-            exceptionList.contains(\"BufferUnderFlow\"));\n-        \n-        if (thread.isAlive()) {\n-            fail(\"Read thread has hung.\");\n-        }\n-        \n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add()} using multiple read threads.\n-     *\n-     *  Two read threads should block on an empty buffer until one\n-     *  object is added then one thread should complete. The remaining\n-     *  thread should complete after the addition of a second object.\n+        assertTrue( \"Thread interrupt should have led to underflow\",\n+                    exceptionList.contains( \"BufferUnderFlow\" ) );\n+        if( thread.isAlive() ) {\n+            fail( \"Read thread has hung.\" );\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add(Object)} using multiple read\n+     * threads.\n+     * <p/>\n+     * Two read threads should block on an empty buffer until one object is added then one thread should complete. The\n+     * remaining thread should complete after the addition of a second object.\n      */\n     public void testBlockedRemoveWithAdd() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-        \n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+\n         // run methods will remove and compare -- must wait for add\n-        Thread thread1 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n-        Thread thread2 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n+        Thread thread1 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n+        Thread thread2 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n         thread1.start();\n         thread2.start();\n-        \n+\n         // give hungry read threads ample time to hang\n         delay();\n-           \n-        blockingBuffer.add(obj);\n-        \n+        blockingBuffer.add( obj );\n+\n         // allow notified threads to complete \n         delay();\n-        \n+\n         // There should be one thread waiting.\n-        assertTrue (\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n-           \n-        blockingBuffer.add(obj);\n-        \n+        assertTrue( \"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive() );\n+        blockingBuffer.add( obj );\n+\n         // allow notified thread to complete \n         delay();\n \n         // There should not be any threads waiting.\n-        if(thread1.isAlive() || thread2.isAlive())\n-            fail(\"Live thread(s) when both should be dead.\");\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll()} using multiple read threads.\n-     *\n-     *  Two read threads should block on an empty buffer until a\n-     *  singleton collection is added then one thread should\n-     *  complete. The remaining thread should complete after the\n-     *  addition of a second singleton.\n+        if( thread1.isAlive() || thread2.isAlive() ) {\n+            fail( \"Live thread(s) when both should be dead.\" );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}\n+     * using multiple read threads.\n+     * <p/>\n+     * Two read threads should block on an empty buffer until a singleton collection is added then one thread should\n+     * complete. The remaining thread should complete after the addition of a second singleton.\n      */\n     public void testBlockedRemoveWithAddAll1() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-        \n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+\n         // run methods will remove and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n-        Thread thread2 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n+        Thread thread1 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n+        Thread thread2 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n         thread1.start();\n         thread2.start();\n-        \n+\n         // give hungry read threads ample time to hang\n         delay();\n-           \n-        blockingBuffer.addAll(Collections.singleton(obj));\n-        \n+        blockingBuffer.addAll( Collections.singleton( obj ) );\n+\n         // allow notified threads to complete \n         delay();\n-        \n+\n         // There should be one thread waiting.\n-        assertTrue (\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n-           \n-        blockingBuffer.addAll(Collections.singleton(obj));\n-        \n+        assertTrue( \"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive() );\n+        blockingBuffer.addAll( Collections.singleton( obj ) );\n+\n         // allow notified thread to complete \n         delay();\n \n         // There should not be any threads waiting.\n-        if(thread1.isAlive() || thread2.isAlive())\n-            fail(\"Live thread(s) when both should be dead.\");\n-    }\n-\n-   \n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll()} using multiple read threads.\n-     *\n-     *  Two read threads should block on an empty buffer until a\n-     *  collection with two distinct objects is added then both\n-     *  threads should complete. Each thread should have read a\n-     *  different object.\n+        if( thread1.isAlive() || thread2.isAlive() ) {\n+            fail( \"Live thread(s) when both should be dead.\" );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}\n+     * using multiple read threads.\n+     * <p/>\n+     * Two read threads should block on an empty buffer until a collection with two distinct objects is added then both\n+     * threads should complete. Each thread should have read a different object.\n      */\n     public void testBlockedRemoveWithAddAll2() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n         Object obj1 = new Object();\n         Object obj2 = new Object();\n-        \n-        Set objs = Collections.synchronizedSet(new HashSet());\n-        objs.add(obj1);\n-        objs.add(obj2);\n+        Set objs = Collections.synchronizedSet( new HashSet() );\n+        objs.add( obj1 );\n+        objs.add( obj2 );\n \n         // run methods will remove and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread(blockingBuffer, objs, \"remove\");\n-        Thread thread2 = new ReadThread(blockingBuffer, objs, \"remove\");\n+        Thread thread1 = new ReadThread( blockingBuffer, objs, \"remove\" );\n+        Thread thread2 = new ReadThread( blockingBuffer, objs, \"remove\" );\n         thread1.start();\n         thread2.start();\n-        \n+\n         // give hungry read threads ample time to hang\n         delay();\n-           \n-        blockingBuffer.addAll(objs);\n-        \n+        blockingBuffer.addAll( objs );\n+\n         // allow notified threads to complete \n         delay();\n-        \n-        assertEquals(\"Both objects were removed\", 0, objs.size());\n+        assertEquals( \"Both objects were removed\", 0, objs.size() );\n \n         // There should not be any threads waiting.\n-        if(thread1.isAlive() || thread2.isAlive())\n-            fail(\"Live thread(s) when both should be dead.\");\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests interrupted remove.\n+        if( thread1.isAlive() || thread2.isAlive() ) {\n+            fail( \"Live thread(s) when both should be dead.\" );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests interrupted remove.\n      */\n     public void testInterruptedRemove() {\n-        \n-        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n-        Object obj = new Object();\n-        \n+        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n+        Object obj = new Object();\n+\n         // spawn a read thread to wait on the empty buffer\n         ArrayList exceptionList = new ArrayList();\n-        Thread thread = new ReadThread(blockingBuffer, obj, exceptionList, \"remove\");\n+        Thread thread = new ReadThread( blockingBuffer, obj, exceptionList, \"remove\" );\n         thread.start();\n-        \n+\n         // Interrupting the thread should cause it to throw BufferUnderflowException\n         thread.interrupt();\n-        \n+\n         // Chill, so thread can throw and add message to exceptionList\n         delay();\n-        \n-        assertTrue(\"Thread interrupt should have led to underflow\", \n-            exceptionList.contains(\"BufferUnderFlow\"));\n-        \n-        if (thread.isAlive()) {\n-            fail(\"Read thread has hung.\");\n-        }\n-        \n+        assertTrue( \"Thread interrupt should have led to underflow\",\n+                    exceptionList.contains( \"BufferUnderFlow\" ) );\n+        if( thread.isAlive() ) {\n+            fail( \"Read thread has hung.\" );\n+        }\n+\n     }\n \n     public void testTimeoutGet() {\n-        final BlockingBuffer buffer = new BlockingBuffer(new MyBuffer());\n+        final BlockingBuffer buffer = new BlockingBuffer( new MyBuffer() );\n         try {\n             buffer.get( 100 );\n             fail( \"Get should have timed out.\" );\n         }\n-        catch( BufferUnderflowException e ){\n+        catch( BufferUnderflowException e ) {\n         }\n     }\n \n     public void testTimeoutRemove() {\n-        final BlockingBuffer buffer = new BlockingBuffer(new MyBuffer());\n+        final BlockingBuffer buffer = new BlockingBuffer( new MyBuffer() );\n         try {\n             buffer.remove( 100 );\n             fail( \"Get should have timed out.\" );\n         }\n-        catch( BufferUnderflowException e ){\n-        }\n-    }\n+        catch( BufferUnderflowException e ) {\n+        }\n+    }\n+\n     protected static class DelayedAdd extends Thread {\n \n         Buffer buffer;\n+\n         Object obj;\n \n-        DelayedAdd (Buffer buffer, Object obj) {\n+        long delay = 1000;\n+\n+        public DelayedAdd( Buffer buffer, Object obj, long delay ) {\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.delay = delay;\n+        }\n+\n+        DelayedAdd( Buffer buffer, Object obj ) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         }\n-                \n+\n         public void run() {\n-\n             try {\n                 // wait for other thread to block on get() or remove()\n-                Thread.sleep(100);\n-            }\n-            catch (InterruptedException e) {}\n-\n-            buffer.add(obj);\n-        }\n-    }\n-    \n+                Thread.sleep( delay );\n+            }\n+            catch( InterruptedException e ) {\n+            }\n+            buffer.add( obj );\n+        }\n+    }\n+\n     protected static class DelayedAddAll extends Thread {\n \n         Buffer buffer;\n+\n         Object obj;\n \n-        DelayedAddAll (Buffer buffer, Object obj) {\n+        long delay = 100;\n+\n+        public DelayedAddAll( Buffer buffer, Object obj, long delay ) {\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.delay = delay;\n+        }\n+\n+        DelayedAddAll( Buffer buffer, Object obj ) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         }\n-                \n+\n         public void run() {\n-\n             try {\n                 // wait for other thread to block on get() or remove()\n-                Thread.sleep(100);\n-            }\n-            catch (InterruptedException e) {}\n-\n-            buffer.addAll(Collections.singleton(obj));\n-        }\n-    }\n-    \n+                Thread.sleep( delay );\n+            }\n+            catch( InterruptedException e ) {\n+            }\n+            buffer.addAll( Collections.singleton( obj ) );\n+        }\n+    }\n+\n     protected static class ReadThread extends Thread {\n \n         Buffer buffer;\n+\n         Object obj;\n+\n         ArrayList exceptionList = null;\n+\n         String action = \"get\";\n+\n         Set objs;\n-        \n-        ReadThread (Buffer buffer, Object obj) {\n+\n+        ReadThread( Buffer buffer, Object obj ) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         }\n \n-        ReadThread (Buffer buffer, Object obj, ArrayList exceptionList) {\n+        ReadThread( Buffer buffer, Object obj, ArrayList exceptionList ) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             this.exceptionList = exceptionList;\n         }\n-        \n-        ReadThread (Buffer buffer, Object obj, ArrayList exceptionList, String action) {\n+\n+        ReadThread( Buffer buffer, Object obj, ArrayList exceptionList, String action ) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             this.exceptionList = exceptionList;\n             this.action = action;\n         }\n-                \n-        ReadThread (Buffer buffer, Set objs, String action) {\n+\n+        ReadThread( Buffer buffer, Set objs, String action ) {\n             super();\n             this.buffer = buffer;\n             this.objs = objs;\n             this.action = action;\n         }\n-                \n-        public void run()  {\n+\n+        public void run() {\n             try {\n-                if (action == \"get\") {\n-                    assertSame(obj, buffer.get());\n-                } else {\n-                    if (null != obj)\n-                        assertSame(obj, buffer.remove());\n-                    else\n-                        assertTrue(objs.remove(buffer.remove()));\n+                if( action == \"get\" ) {\n+                    assertSame( obj, buffer.get() );\n                 }\n-            } catch (BufferUnderflowException ex) {\n-                exceptionList.add(\"BufferUnderFlow\");\n-            }\n-        }\n-    }\n-        \n+                else {\n+                    if( null != obj ) {\n+                        assertSame( obj, buffer.remove() );\n+                    }\n+                    else {\n+                        assertTrue( objs.remove( buffer.remove() ) );\n+                    }\n+                }\n+            }\n+            catch( BufferUnderflowException ex ) {\n+                exceptionList.add( \"BufferUnderFlow\" );\n+            }\n+        }\n+    }\n \n     protected static class MyBuffer extends LinkedList implements Buffer {\n \n         public Object get() {\n-            if(isEmpty())\n+            if( isEmpty() ) {\n                 throw new BufferUnderflowException();\n-            return get(0);\n+            }\n+            return get( 0 );\n         }\n \n         public Object remove() {\n-            if(isEmpty())\n+            if( isEmpty() ) {\n                 throw new BufferUnderflowException();\n-            return remove(0);\n-        }\n-    }\n-\n-    private void delay(){\n+            }\n+            return remove( 0 );\n+        }\n+    }\n+\n+    private void delay() {\n         try {\n-            Thread.sleep(100);\n-        } catch (InterruptedException e) {}\n+            Thread.sleep( 100 );\n+        }\n+        catch( InterruptedException e ) {\n+        }\n     }\n \n     public String getCompatibilityVersion() {\n \n //    public void testCreate() throws Exception {\n //        Buffer buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n-//        writeExternalFormToDisk((java.io.Serializable) buffer, \"D:/dev/collections/data/test/BlockingBuffer.emptyCollection.version3.1.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) buffer,\n+//        \"D:/dev/collections/data/test/BlockingBuffer.emptyCollection.version3.1.obj\");\n //        buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n //        buffer.add(\"A\");\n //        buffer.add(\"B\");\n //        buffer.add(\"C\");\n-//        writeExternalFormToDisk((java.io.Serializable) buffer, \"D:/dev/collections/data/test/BlockingBuffer.fullCollection.version3.1.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) buffer,\n+//        \"D:/dev/collections/data/test/BlockingBuffer.fullCollection.version3.1.obj\");\n //    }\n-\n }", "timestamp": 1132751584, "metainfo": ""}