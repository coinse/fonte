{"sha": "8fb4813c012c1ebbc0c04f7b7b0439c1083ad201", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r643795 | skestle | 2008-04-02 01:49:57 -0700 (Wed, 02 Apr 2008) | 5 lines          Generified EqualPredicate and created individual test class moved from TestPredicateUtils          Added assertFalse() and assertTrue to BasicPredicateTestBase with (Predicate, Object) parameters          Issues: COLLECTIONS-243, COLLECTIONS-253, COLLECTIONS-293     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ClosureUtils.java\n+++ b/src/java/org/apache/commons/collections/ClosureUtils.java\n package org.apache.commons.collections;\n \n import java.util.Collection;\n-import java.util.Iterator;\n import java.util.Map;\n \n import org.apache.commons.collections.functors.ChainedClosure;\n      * \n      * @return the closure\n      */\n-    public static Closure exceptionClosure() {\n-        return ExceptionClosure.INSTANCE;\n+    public static <E> Closure<E> exceptionClosure() {\n+        return ExceptionClosure.<E>getInstance();\n     }\n \n     /**\n      * \n      * @return the closure\n      */\n-    public static Closure nopClosure() {\n-        return NOPClosure.INSTANCE;\n+    public static <E> Closure<E> nopClosure() {\n+        return NOPClosure.<E>getInstance();\n     }\n \n     /**\n      * @param transformer  the transformer to run each time in the closure, null means nop\n      * @return the closure\n      */\n-    public static Closure asClosure(Transformer transformer) {\n+    public static <E> Closure<E> asClosure(Transformer<? super E, ?> transformer) {\n         return TransformerClosure.getInstance(transformer);\n     }\n \n      * @param closure  the closure to call repeatedly\n      * @return the <code>for</code> closure\n      */\n-    public static Closure forClosure(int count, Closure closure) {\n+    public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n         return ForClosure.getInstance(count, closure);\n     }\n \n      * @return the <code>while</code> closure\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static Closure whileClosure(Predicate predicate, Closure closure) {\n-        return WhileClosure.getInstance(predicate, closure, false);\n+    public static <E> Closure<E> whileClosure(Predicate<? super E> predicate, Closure<? super E> closure) {\n+        return WhileClosure.<E>getInstance(predicate, closure, false);\n     }\n \n     /**\n      * @return the <code>do-while</code> closure\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static Closure doWhileClosure(Closure closure, Predicate predicate) {\n-        return WhileClosure.getInstance(predicate, closure, true);\n+    public static <E> Closure<E> doWhileClosure(Closure<? super E> closure, Predicate<? super E> predicate) {\n+        return WhileClosure.<E>getInstance(predicate, closure, true);\n     }\n \n     /**\n      * @return the <code>invoker</code> closure\n      * @throws IllegalArgumentException if the method name is null\n      */\n-    public static Closure invokerClosure(String methodName) {\n+    public static <E> Closure<E> invokerClosure(String methodName) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n-        return asClosure(InvokerTransformer.getInstance(methodName));\n+        return asClosure(InvokerTransformer.<E, Object>getInstance(methodName));\n     }\n \n     /**\n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static Closure invokerClosure(String methodName, Class[] paramTypes, Object[] args) {\n+    public static <E> Closure<E> invokerClosure(String methodName, Class<?>[] paramTypes, Object[] args) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n-        return asClosure(InvokerTransformer.getInstance(methodName, paramTypes, args));\n+        return asClosure(InvokerTransformer.<E, Object>getInstance(methodName, paramTypes, args));\n     }\n \n     /**\n      * @return the <code>chained</code> closure\n      * @throws IllegalArgumentException if either closure is null\n      */\n-    public static Closure chainedClosure(Closure closure1, Closure closure2) {\n-        return ChainedClosure.getInstance(closure1, closure2);\n+    public static <E> Closure<E> chainedClosure(Closure<? super E> closure1, Closure<? super E> closure2) {\n+        return ChainedClosure.<E>getInstance(closure1, closure2);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the closures array is null\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n-    public static Closure chainedClosure(Closure[] closures) {\n+    public static <E> Closure<E> chainedClosure(Closure<? super E>[] closures) {\n         return ChainedClosure.getInstance(closures);\n     }\n \n      * @throws IllegalArgumentException if the closures collection is empty\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n-    public static Closure chainedClosure(Collection closures) {\n+    public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n         return ChainedClosure.getInstance(closures);\n     }\n \n      * @throws IllegalArgumentException if the closure is null\n      * @since Commons Collections 3.2\n      */\n-    public static Closure ifClosure(Predicate predicate, Closure trueClosure) {\n-        return IfClosure.getInstance(predicate, trueClosure);\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+        return IfClosure.<E>getInstance(predicate, trueClosure);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicate is null\n      * @throws IllegalArgumentException if either closure is null\n      */\n-    public static Closure ifClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n-        return IfClosure.getInstance(predicate, trueClosure, falseClosure);\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n+        return IfClosure.<E>getInstance(predicate, trueClosure, falseClosure);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static Closure switchClosure(Predicate[] predicates, Closure[] closures) {\n-        return SwitchClosure.getInstance(predicates, closures, null);\n+    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures) {\n+        return SwitchClosure.<E>getInstance(predicates, closures, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static Closure switchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n-        return SwitchClosure.getInstance(predicates, closures, defaultClosure);\n+    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n+        return SwitchClosure.<E>getInstance(predicates, closures, defaultClosure);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if any closure in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n-    public static Closure switchClosure(Map predicatesAndClosures) {\n+    public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n         return SwitchClosure.getInstance(predicatesAndClosures);\n     }\n \n      * @throws IllegalArgumentException if the map is empty\n      * @throws IllegalArgumentException if any closure in the map is null\n      */\n-    public static Closure switchMapClosure(Map objectsAndClosures) {\n-        Closure[] trs = null;\n-        Predicate[] preds = null;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchMapClosure(Map<? extends E, Closure<E>> objectsAndClosures) {\n+        Closure<? super E>[] trs = null;\n+        Predicate<E>[] preds = null;\n         if (objectsAndClosures == null) {\n             throw new IllegalArgumentException(\"The object and closure map must not be null\");\n         }\n-        Closure def = (Closure) objectsAndClosures.remove(null);\n+        Closure<? super E> def = objectsAndClosures.remove(null);\n         int size = objectsAndClosures.size();\n         trs = new Closure[size];\n         preds = new Predicate[size];\n         int i = 0;\n-        for (Iterator it = objectsAndClosures.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            preds[i] = EqualPredicate.getInstance(entry.getKey());\n-            trs[i] = (Closure) entry.getValue();\n+        for (Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n+            preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n+            trs[i] = entry.getValue();\n             i++;\n         }\n-        return switchClosure(preds, trs, def);\n+        return ClosureUtils.<E>switchClosure(preds, trs, def);\n     }\n \n }", "timestamp": 1252994079, "metainfo": ""}