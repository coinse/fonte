{"sha": "a932442109df1e24501f22e613772c1add595a3d", "log": "Add LinkedMap map implementation   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/HashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/HashedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.4 2003/12/02 23:51:50 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.5 2003/12/03 19:04:41 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/12/02 23:51:50 $\n+ * @version $Revision: 1.5 $ $Date: 2003/12/03 19:04:41 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n     protected static final Object NULL = new Object();\n     \n     /** Load factor, normally 0.75 */\n-    private final float loadFactor;\n+    protected final float loadFactor;\n     /** The size of the map */\n-    private transient int size;\n+    protected transient int size;\n     /** Map entries */\n-    private transient HashEntry[] data;\n+    protected transient HashEntry[] data;\n     /** Size at which to rehash */\n-    private transient int threshold;\n+    protected transient int threshold;\n     /** Modification count for iterators */\n-    private transient int modCount;\n+    protected transient int modCount;\n     /** Entry set */\n-    private transient EntrySet entrySet;\n+    protected transient EntrySet entrySet;\n     /** Key set */\n-    private transient KeySet keySet;\n+    protected transient KeySet keySet;\n     /** Values */\n-    private transient Values values;\n+    protected transient Values values;\n \n     /**\n      * Constructs a new empty map with default size and load factor.\n         this.loadFactor = DEFAULT_LOAD_FACTOR;\n         this.threshold = calculateThreshold(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n         this.data = new HashEntry[DEFAULT_CAPACITY];\n+        init();\n     }\n \n     /**\n         this.threshold = calculateThreshold(initialCapacity, loadFactor);\n         initialCapacity = calculateNewCapacity(initialCapacity);\n         this.data = new HashEntry[initialCapacity];\n+        init();\n     }\n \n     /**\n     public HashedMap(Map map) {\n         this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n         putAll(map);\n+    }\n+\n+    /**\n+     * Initialise subclasses during construction.\n+     */\n+    protected void init() {\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the entry mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    protected HashEntry getEntry(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry;\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n      * Converts input keys to another object for storage in the map.\n      * This implementation masks nulls.\n      * Subclasses can override this to perform alternate key conversions.\n      * Base Iterator\n      */\n     protected static abstract class HashIterator implements Iterator {\n-        private final HashedMap map;\n-        private int hashIndex;\n-        private HashEntry current;\n-        private HashEntry next;\n-        private int expectedModCount;\n+        protected final HashedMap map;\n+        protected int hashIndex;\n+        protected HashEntry current;\n+        protected HashEntry next;\n+        protected int expectedModCount;\n         \n         protected HashIterator(HashedMap map) {\n             super();\n         int capacity = in.readInt();\n         int size = in.readInt();\n         data = new HashEntry[capacity];\n+        init();\n         for (int i = 0; i < size; i++) {\n             Object key = in.readObject();\n             Object value = in.readObject();\n             cloned.values = null;\n             cloned.modCount = 0;\n             cloned.size = 0;\n+            init();\n             cloned.putAll(this);\n             return cloned;\n             \n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.1 2003/12/03 19:04:41 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * A <code>Map</code> implementation that maintains the order of the entries.\n+ * The order maintained is by insertion.\n+ * <p>\n+ * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n+ * {@link org.apache.commons.collections.iterators.MapIterator MapIterator}\n+ * functionality, additional convenience methods and allowing\n+ * bidirectional iteration. It also implements <code>OrderedMap</code>.\n+ * <p>\n+ * The <code>orderedMapIterator()</code> method provides direct access to a\n+ * bidirectional iterator. The iterators from the other views can also be cast\n+ * to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/03 19:04:41 $\n+ *\n+ * @author java util LinkedHashMap\n+ * @author Stephen Colebourne\n+ */\n+public class LinkedMap extends HashedMap implements OrderedMap {\n+    \n+    /** Serialisation version */\n+    static final long serialVersionUID = -1954063410665686469L;\n+    \n+    /** Header in the linked list */\n+    private transient LinkedEntry header;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public LinkedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     */\n+    public LinkedMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     * @throws IllegalArgumentException if the load factor is less than one\n+     */\n+    public LinkedMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public LinkedMap(Map map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Initialise this subclass during construction.\n+     */\n+    protected void init() {\n+        header = new LinkedEntry(null, -1, null, null);\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        // override uses faster iterator\n+        if (value == null) {\n+            for (LinkedEntry entry = header.after; entry != header; entry = entry.after) {\n+                if (entry.getValue() == null) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (LinkedEntry entry = header.after; entry != header; entry = entry.after) {\n+                if (isEqualValue(value, entry.getValue())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    public void clear() {\n+        // override to reset the linked list\n+        super.clear();\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first key in the map, which is the most recently inserted.\n+     * \n+     * @return the most recently inserted key\n+     */\n+    public Object firstKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.after.getKey();\n+    }\n+\n+    /**\n+     * Gets the last key in the map, which is the first inserted.\n+     * \n+     * @return the eldest key\n+     */\n+    public Object lastKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.before.getKey();\n+    }\n+\n+    /**\n+     * Gets the next key in sequence.\n+     * \n+     * @param key  the key to get after\n+     * @return the next key\n+     */\n+    public Object nextKey(Object key) {\n+        LinkedEntry entry = (LinkedEntry) getEntry(key);\n+        return (entry == null || entry.after == header ? null : entry.after.getKey());\n+    }\n+\n+    /**\n+     * Gets the previous key in sequence.\n+     * \n+     * @param key  the key to get before\n+     * @return the previous key\n+     */\n+    public Object previousKey(Object key) {\n+        LinkedEntry entry = (LinkedEntry) getEntry(key);\n+        return (entry == null || entry.before == header ? null : entry.before.getKey());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates an entry to store the data.\n+     * This implementation creates a LinkEntry instance in the linked list.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n+        LinkedEntry entry = new LinkedEntry(next, hashCode, key, value);\n+        entry.after  = header;\n+        entry.before = header.before;\n+        header.before.after = entry;\n+        header.before = entry;\n+        return entry;\n+    }\n+    \n+    /**\n+     * Kills an entry ready for the garbage collector.\n+     * This implementation manages the linked list and prepares the\n+     * LinkEntry for garbage collection.\n+     * \n+     * @param entry  the entry to destroy\n+     * @return the value from the entry\n+     */\n+    protected Object destroyEntry(HashEntry entry) {\n+        LinkedEntry link = (LinkedEntry) entry;\n+        link.before.after = link.after;\n+        link.after.before = link.before;\n+        link.next = null;\n+        link.after = null;\n+        link.before = null;\n+        return entry.value;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Mep Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        if (size == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+        }\n+        return new LinkedMapIterator(this);\n+    }\n+\n+    /**\n+     * Gets a bidirectional iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Mep Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public OrderedMapIterator orderedMapIterator() {\n+        if (size == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+        }\n+        return new LinkedMapIterator(this);\n+    }\n+\n+    /**\n+     * MapIterator\n+     */\n+    static class LinkedMapIterator extends LinkedIterator implements OrderedMapIterator {\n+        \n+        LinkedMapIterator(LinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry().getKey();\n+        }\n+\n+        public Object getKey() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            return current.getKey();\n+        }\n+\n+        public Object getValue() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            return current.getValue();\n+        }\n+\n+        public Object setValue(Object value) {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the entrySet iterator\n+     */\n+    protected Iterator createEntrySetIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n+        }\n+        return new EntrySetIterator(this);\n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator extends LinkedIterator {\n+        \n+        EntrySetIterator(LinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the keySet iterator\n+     */\n+    protected Iterator createKeySetIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n+        }\n+        return new KeySetIterator(this);\n+    }\n+\n+    /**\n+     * KeySetIterator\n+     */\n+    static class KeySetIterator extends EntrySetIterator {\n+        \n+        KeySetIterator(LinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry().getKey();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the values iterator\n+     */\n+    protected Iterator createValuesIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n+        }\n+        return new ValuesIterator(this);\n+    }\n+\n+    /**\n+     * ValuesIterator\n+     */\n+    static class ValuesIterator extends LinkedIterator {\n+        \n+        ValuesIterator(LinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getValue();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry().getValue();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * LinkEntry\n+     */\n+    protected static class LinkedEntry extends HashEntry {\n+        \n+        LinkedEntry before;\n+        LinkedEntry after;\n+        \n+        protected LinkedEntry(HashEntry next, int hashCode, Object key, Object value) {\n+            super(next, hashCode, key, value);\n+        }\n+    }\n+    \n+    /**\n+     * Base Iterator\n+     */\n+    protected static abstract class LinkedIterator\n+            implements OrderedIterator, ResettableIterator {\n+                \n+        private final LinkedMap map;\n+        private LinkedEntry current;\n+        private LinkedEntry next;\n+        private int expectedModCount;\n+        \n+        protected LinkedIterator(LinkedMap map) {\n+            super();\n+            this.map = map;\n+            this.next = map.header.after;\n+            this.expectedModCount = map.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return (next != map.header);\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (next.before != map.header);\n+        }\n+\n+        protected LinkedEntry nextEntry() {\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (next == map.header)  {\n+                throw new NoSuchElementException(\"No more elements in the iteration\");\n+            }\n+            current = next;\n+            next = next.after;\n+            return current;\n+        }\n+\n+        protected LinkedEntry previousEntry() {\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            LinkedEntry previous = next.before;\n+            if (previous == map.header)  {\n+                throw new NoSuchElementException(\"No more elements in the iteration\");\n+            }\n+            next = previous;\n+            current = previous;\n+            return current;\n+        }\n+        \n+        protected LinkedEntry currentEntry() {\n+            return current;\n+        }\n+        \n+        public void remove() {\n+            if (current == null) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            map.remove(current.getKey());\n+            current = null;\n+            expectedModCount = map.modCount;\n+        }\n+        \n+        public void reset() {\n+            current = null;\n+            next = map.header.after;\n+        }\n+\n+        public String toString() {\n+            if (current != null) {\n+                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n+            } else {\n+                return \"Iterator[]\";\n+            }\n+        }\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/collections/map/TestAll.java\n+++ b/src/test/org/apache/commons/collections/map/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.8 2003/12/03 15:50:12 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.9 2003/12/03 19:04:41 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.8 $ $Date: 2003/12/03 15:50:12 $\n+ * @version $Revision: 1.9 $ $Date: 2003/12/03 19:04:41 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestFlat3Map.suite());\n         suite.addTest(TestHashedMap.suite());\n         suite.addTest(TestIdentityMap.suite());\n+        suite.addTest(TestLinkedMap.suite());\n         suite.addTest(TestReferenceMap.suite());\n         suite.addTest(TestStaticBucketMap.suite());\n         \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLinkedMap.java,v 1.1 2003/12/03 19:04:41 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/12/03 19:04:41 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestLinkedMap extends AbstractTestOrderedMap {\n+\n+    public TestLinkedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestLinkedMap.class);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new LinkedMap();\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap ordered = (OrderedMap) map;\n+        ((ResettableIterator) ordered.mapIterator()).reset();\n+        \n+        resetFull();\n+        ordered = (OrderedMap) map;\n+        List list = new ArrayList(ordered.keySet());\n+        ResettableIterator it = (ResettableIterator) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LinkedMap.fullCollection.version3.obj\");\n+//    }\n+}", "timestamp": 1070478351, "metainfo": ""}