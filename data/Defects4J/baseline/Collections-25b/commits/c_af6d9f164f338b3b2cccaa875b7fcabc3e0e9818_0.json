{"sha": "af6d9f164f338b3b2cccaa875b7fcabc3e0e9818", "log": "Add lazyMap versions that use a Transformer as their factory. These are in fact incredibly powerful, especially if wrapped in a synchronized wrapper. In this case it forms a self-populating cache. Idea by Dennis Mitchell,  bugzilla ref 17953   ", "commit": "\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.18 2003/04/06 19:32:18 scolebourne Exp $\n- * $Revision: 1.18 $\n- * $Date: 2003/04/06 19:32:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.19 2003/04/06 20:07:55 scolebourne Exp $\n+ * $Revision: 1.19 $\n+ * $Date: 2003/04/06 20:07:55 $\n  *\n  * ====================================================================\n  *\n     }\n \n     /**\n+     * Implementation of a map that creates objects on demand.\n+     */\n+    static class LazyTransformerMap \n+            extends ProxyMap {\n+\n+        protected final Transformer transformer;\n+\n+        public LazyTransformerMap(Map map, Transformer transformer) {\n+            super(map);\n+            if (map == null) {\n+                throw new IllegalArgumentException(\"Map must not be null\");\n+            }\n+            if (transformer == null) {\n+                throw new IllegalArgumentException(\"Transformer must not be null\");\n+            }\n+            this.transformer = transformer;\n+        }\n+\n+\n+        public Object get(Object key) {\n+            if (!map.containsKey(key)) {\n+                Object value = transformer.transform(key);\n+                map.put(key, value);\n+                return value;\n+            }\n+            return map.get(key);\n+        }\n+\n+    }\n+\n+    /**\n      * Implementation of a sorted map that checks additions.\n      */\n     static class PredicatedSortedMap \n             return getSortedMap().firstKey();\n         }\n \n-\n         public Object lastKey() {\n             return getSortedMap().lastKey();\n         }\n \n-\n         public Comparator comparator() {\n             return getSortedMap().comparator();\n         }\n-\n \n         public SortedMap subMap(Object o1, Object o2) {\n             SortedMap sub = getSortedMap().subMap(o1, o2);\n             return getSortedMap().firstKey();\n         }\n \n-\n         public Object lastKey() {\n             return getSortedMap().lastKey();\n         }\n \n-\n         public Comparator comparator() {\n             return getSortedMap().comparator();\n         }\n-\n \n         public SortedMap subMap(Object o1, Object o2) {\n             return new FixedSizeSortedMap(getSortedMap().subMap(o1, o2));\n             return getSortedMap().firstKey();\n         }\n \n-\n         public Object lastKey() {\n             return getSortedMap().lastKey();\n         }\n \n-\n         public Comparator comparator() {\n             return getSortedMap().comparator();\n         }\n \n-\n         public SortedMap subMap(Object o1, Object o2) {\n             return new LazySortedMap(getSortedMap().subMap(o1, o2), factory);\n         }\n \n         public SortedMap tailMap(Object o1) {\n             return new LazySortedMap(getSortedMap().tailMap(o1), factory);\n+        }\n+\n+        private SortedMap getSortedMap() {\n+            return (SortedMap)map;\n+        }\n+\n+    }\n+\n+    /**\n+     * Implementation of a sorted map that creates objects on demand.\n+     */\n+    static class LazyTransformerSortedMap \n+            extends LazyTransformerMap \n+            implements SortedMap {\n+\n+        public LazyTransformerSortedMap(SortedMap m, Transformer transformer) {\n+            super(m, transformer);\n+        }\n+\n+        public Object firstKey() {\n+            return getSortedMap().firstKey();\n+        }\n+\n+        public Object lastKey() {\n+            return getSortedMap().lastKey();\n+        }\n+\n+        public Comparator comparator() {\n+            return getSortedMap().comparator();\n+        }\n+\n+        public SortedMap subMap(Object o1, Object o2) {\n+            return new LazyTransformerSortedMap(getSortedMap().subMap(o1, o2), transformer);\n+        }\n+\n+        public SortedMap headMap(Object o1) {\n+            return new LazyTransformerSortedMap(getSortedMap().headMap(o1), transformer);\n+        }\n+\n+        public SortedMap tailMap(Object o1) {\n+            return new LazyTransformerSortedMap(getSortedMap().tailMap(o1), transformer);\n         }\n \n         private SortedMap getSortedMap() {\n     }\n \n     /**\n-     * Returns a \"lazy\" map whose values will be created on demand.<P>\n+     * Returns a \"lazy\" map whose values will be created on demand.\n      * <p>\n      * When the key passed to the returned map's {@link Map#get(Object)}\n      * method is not present in the map, then the factory will be used\n      * associated with that key.\n      * <p>\n      * For instance:\n-     *\n      * <pre>\n      * Factory factory = new Factory() {\n      *     public Object create() {\n      *         return new Date();\n      *     }\n      * }\n-     * Map lazy = MapUtils.lazyMap(new HashMap(), factory);\n-     * Object obj = lazy.get(\"test\");\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"test\");\n      * </pre>\n      *\n      * After the above code is executed, <code>obj</code> will contain\n      * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n-     * instance is the value for the <code>test</code> key.\n+     * instance is the value for the <code>\"test\"</code> key in the map.\n      *\n      * @param map  the map to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n      */\n     public static Map lazyMap(Map map, Factory factory) {\n         return new LazyMap(map, factory);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key. The factory is a {@link Transformer}\n+     * that will be passed the key which it must transform into the value.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Transformer factory = new Transformer() {\n+     *     public Object transform(Object mapKey) {\n+     *         return new File(mapKey);\n+     *     }\n+     * }\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"C:/dev\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>File</code> instance for the C drive dev directory.\n+     * Furthermore, that <code>File</code> instance is the value for the\n+     * <code>\"C:/dev\"</code> key in the map.\n+     * <p>\n+     * If a lazy map is wrapped by a synchronized map, the result is a simple\n+     * synchronized cache. When an object is not is the cache, the cache itself\n+     * calls back to the factory Transformer to populate itself, all within the\n+     * same synchronized block.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param transformerFactory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     */\n+    public static Map lazyMap(Map map, Transformer transformerFactory) {\n+        return new LazyTransformerMap(map, transformerFactory);\n     }\n \n     //-----------------------------------------------------------------------\n      *\n      * After the above code is executed, <code>obj</code> will contain\n      * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n-     * instance is the value for the <code>test</code> key.\n+     * instance is the value for the <code>\"test\"</code> key.\n      *\n      * @param map  the map to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n         return new LazySortedMap(map, factory);\n     }\n     \n+    /**\n+     * Returns a \"lazy\" sorted map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key. The factory is a {@link Transformer}\n+     * that will be passed the key which it must transform into the value.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Transformer factory = new Transformer() {\n+     *     public Object transform(Object mapKey) {\n+     *         return new File(mapKey);\n+     *     }\n+     * }\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"C:/dev\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>File</code> instance for the C drive dev directory.\n+     * Furthermore, that <code>File</code> instance is the value for the\n+     * <code>\"C:/dev\"</code> key in the map.\n+     * <p>\n+     * If a lazy map is wrapped by a synchronized map, the result is a simple\n+     * synchronized cache. When an object is not is the cache, the cache itself\n+     * calls back to the factory Transformer to populate itself, all within the\n+     * same synchronized block.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param transformerFactory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     */\n+    public static SortedMap lazySortedMap(SortedMap map, Transformer transformerFactory) {\n+        return new LazyTransformerSortedMap(map, transformerFactory);\n+    }\n+\n }\n--- a/src/test/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.3 2003/04/04 22:22:28 scolebourne Exp $\n- * $Revision: 1.3 $\n- * $Date: 2003/04/04 22:22:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.4 2003/04/06 20:07:55 scolebourne Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/04/06 20:07:55 $\n  *\n  * ====================================================================\n  *\n         };\n     }\n \n+    public void testLazyMapFactory() {\n+        Map map = MapUtils.lazyMap(new HashMap(), new Factory() {\n+            public Object create() {\n+                return new Integer(5);\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        Integer i1 = (Integer) map.get(\"Five\");\n+        assertEquals(new Integer(5), i1);\n+        assertEquals(1, map.size());\n+        Integer i2 = (Integer) map.get(new String(new char[] {'F','i','v','e'}));\n+        assertEquals(new Integer(5), i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+    }\n+\n+    public void testLazyMapTransformer() {\n+        Map map = MapUtils.lazyMap(new HashMap(), new Transformer() {\n+            public Object transform(Object mapKey) {\n+                if (mapKey instanceof String) {\n+                    return new Integer((String) mapKey);\n+                }\n+                return null;\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        Integer i1 = (Integer) map.get(\"5\");\n+        assertEquals(new Integer(5), i1);\n+        assertEquals(1, map.size());\n+        Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n+        assertEquals(new Integer(5), i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+    }\n \n }", "timestamp": 1049659675, "metainfo": ""}