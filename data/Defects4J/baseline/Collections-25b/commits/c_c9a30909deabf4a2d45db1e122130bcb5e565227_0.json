{"sha": "c9a30909deabf4a2d45db1e122130bcb5e565227", "log": "Add keywords  ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiValueMap.java\n-/*\n- *  Copyright 2001-2005 The Apache Software Foundation\n- *\n- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n- *  you may not use this file except in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-package org.apache.commons.collections.map;\n-\n-import java.util.AbstractCollection;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.apache.commons.collections.Factory;\n-import org.apache.commons.collections.MultiMap;\n-import org.apache.commons.collections.iterators.EmptyIterator;\n-import org.apache.commons.collections.iterators.IteratorChain;\n-\n-/**\n- * A MultiValueMap decorates another map, allowing it to have\n- * more than one value for a key.\n- * <p>\n- * A <code>MultiMap</code> is a Map with slightly different semantics.\n- * Putting a value into the map will add the value to a Collection at that key.\n- * Getting a value will return a Collection, holding all the values put to that key.\n- * <p>\n- * This implementation is a decorator, allowing any Map implementation\n- * to be used as the base.\n- * <p>\n- * In addition, this implementation allows the type of collection used\n- * for the values to be controlled. By default, an <code>ArrayList</code>\n- * is used, however a <code>Class</code> to instantiate may be specified,\n- * or a factory that returns a <code>Collection</code> instance.\n- *\n- * @author James Carman\n- * @author Christopher Berry\n- * @author James Strachan\n- * @author Steve Downey\n- * @author Stephen Colebourne\n- * @author Julien Buret\n- * @author Serhiy Yevtushenko\n- * @version $Revision: $ $Date: $\n- * @since Commons Collections 3.2\n- */\n-public class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n-\n-    /** The factory for creating value collections. */\n-    private final Factory collectionFactory;\n-    /** The cached values. */\n-    private transient Collection values;\n-\n-    /**\n-     * Creates a map which wraps the given map and\n-     * maps keys to ArrayLists.\n-     *\n-     * @param map  the map to wrap\n-     */\n-    public static MultiValueMap decorate(Map map) {\n-        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n-    }\n-\n-    /**\n-     * Creates a map which decorates the given <code>map</code> and\n-     * maps keys to collections of type <code>collectionClass</code>.\n-     *\n-     * @param map  the map to wrap\n-     * @param collectionClass  the type of the collection class\n-     */\n-    public static MultiValueMap decorate(Map map, Class collectionClass) {\n-        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n-    }\n-\n-    /**\n-     * Creates a map which decorates the given <code>map</code> and\n-     * creates the value collections using the supplied <code>collectionFactory</code>.\n-     *\n-     * @param map  the map to decorate\n-     * @param collectionFactory  the collection factory (must return a Collection object).\n-     */\n-    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n-        return new MultiValueMap(map, collectionFactory);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Creates a MultiValueMap based on a <code>HashMap</code> and\n-     * storing the multiple values in an <code>ArrayList</code>.\n-     */\n-    public MultiValueMap() {\n-        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n-    }\n-\n-    /**\n-     * Creates a MultiValueMap which decorates the given <code>map</code> and\n-     * creates the value collections using the supplied <code>collectionFactory</code>.\n-     *\n-     * @param map  the map to decorate\n-     * @param collectionFactory  the collection factory which must return a Collection instance\n-     */\n-    protected MultiValueMap(Map map, Factory collectionFactory) {\n-        super(map);\n-        if (collectionFactory == null) {\n-            throw new IllegalArgumentException(\"The factory must not be null\");\n-        }\n-        this.collectionFactory = collectionFactory;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Clear the map.\n-     */\n-    public void clear() {\n-        // If you believe that you have GC issues here, try uncommenting this code\n-//        Set pairs = getMap().entrySet();\n-//        Iterator pairsIterator = pairs.iterator();\n-//        while (pairsIterator.hasNext()) {\n-//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n-//            Collection coll = (Collection) keyValuePair.getValue();\n-//            coll.clear();\n-//        }\n-        getMap().clear();\n-    }\n-\n-    /**\n-     * Removes a specific value from map.\n-     * <p>\n-     * The item is removed from the collection mapped to the specified key.\n-     * Other values attached to that key are unaffected.\n-     * <p>\n-     * If the last value for a key is removed, <code>null</code> will be returned\n-     * from a subsequant <code>get(key)</code>.\n-     *\n-     * @param key  the key to remove from\n-     * @param value the value to remove\n-     * @return the value removed (which was passed in), null if nothing removed\n-     */\n-    public Object remove(Object key, Object value) {\n-        Collection valuesForKey = getCollection(key);\n-        if (valuesForKey == null) {\n-            return null;\n-        }\n-        boolean removed = valuesForKey.remove(value);\n-        if (removed == false) {\n-            return null;\n-        }\n-        if (valuesForKey.isEmpty()) {\n-            remove(key);\n-        }\n-        return value;\n-    }\n-\n-    /**\n-     * Checks whether the map contains the value specified.\n-     * <p>\n-     * This checks all collections against all keys for the value, and thus could be slow.\n-     *\n-     * @param value  the value to search for\n-     * @return true if the map contains the value\n-     */\n-    public boolean containsValue(Object value) {\n-        Set pairs = getMap().entrySet();\n-        if (pairs == null) {\n-            return false;\n-        }\n-        Iterator pairsIterator = pairs.iterator();\n-        while (pairsIterator.hasNext()) {\n-            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n-            Collection coll = (Collection) keyValuePair.getValue();\n-            if (coll.contains(value)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Adds the value to the collection associated with the specified key.\n-     * <p>\n-     * Unlike a normal <code>Map</code> the previous value is not replaced.\n-     * Instead the new value is added to the collection stored against the key.\n-     *\n-     * @param key  the key to store against\n-     * @param value  the value to add to the collection at the key\n-     * @return the value added if the map changed and null if the map did not change\n-     */\n-    public Object put(Object key, Object value) {\n-        boolean result = false;\n-        Collection coll = getCollection(key);\n-        if (coll == null) {\n-            coll = createCollection(1);\n-            result = coll.add(value);\n-            if (coll.size() > 0) {\n-                // only add if non-zero size to maintain class state\n-                getMap().put(key, coll);\n-                result = false;\n-            }\n-        } else {\n-            result = coll.add(value);\n-        }\n-        return (result ? value : null);\n-    }\n-\n-    /**\n-     * Gets a collection containing all the values in the map.\n-     * <p>\n-     * This returns a collection containing the combination of values from all keys.\n-     *\n-     * @return a collection view of the values contained in this map\n-     */\n-    public Collection values() {\n-        Collection vs = values;\n-        return (vs != null ? vs : (values = new Values()));\n-    }\n-\n-    /**\n-     * Checks whether the collection at the specified key contains the value.\n-     *\n-     * @param value  the value to search for\n-     * @return true if the map contains the value\n-     */\n-    public boolean containsValue(Object key, Object value) {\n-        Collection coll = getCollection(key);\n-        if (coll == null) {\n-            return false;\n-        }\n-        return coll.contains(value);\n-    }\n-\n-    /**\n-     * Gets the collection mapped to the specified key.\n-     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n-     *\n-     * @param key  the key to retrieve\n-     * @return the collection mapped to the key, null if no mapping\n-     */\n-    public Collection getCollection(Object key) {\n-        return (Collection) getMap().get(key);\n-    }\n-\n-    /**\n-     * Gets the size of the collection mapped to the specified key.\n-     *\n-     * @param key  the key to get size for\n-     * @return the size of the collection at the key, zero if key not in map\n-     */\n-    public int size(Object key) {\n-        Collection coll = getCollection(key);\n-        if (coll == null) {\n-            return 0;\n-        }\n-        return coll.size();\n-    }\n-\n-    /**\n-     * Adds a collection of values to the collection associated with\n-     * the specified key.\n-     *\n-     * @param key  the key to store against\n-     * @param values  the values to add to the collection at the key, null ignored\n-     * @return true if this map changed\n-     */\n-    public boolean putAll(Object key, Collection values) {\n-        if (values == null || values.size() == 0) {\n-            return false;\n-        }\n-        Collection coll = getCollection(key);\n-        if (coll == null) {\n-            coll = createCollection(values.size());\n-            boolean result = coll.addAll(values);\n-            if (coll.size() > 0) {\n-                // only add if non-zero size to maintain class state\n-                getMap().put(key, coll);\n-                result = false;\n-            }\n-            return result;\n-        } else {\n-            return coll.addAll(values);\n-        }\n-    }\n-\n-    /**\n-     * Gets an iterator for the collection mapped to the specified key.\n-     *\n-     * @param key  the key to get an iterator for\n-     * @return the iterator of the collection at the key, empty iterator if key not in map\n-     */\n-    public Iterator iterator(Object key) {\n-        if (!containsKey(key)) {\n-            return EmptyIterator.INSTANCE;\n-        } else {\n-            return new ValuesIterator(key);\n-        }\n-    }\n-\n-    /**\n-     * Gets the total size of the map by counting all the values.\n-     *\n-     * @return the total size of the map counting all values\n-     */\n-    public int totalSize() {\n-        int total = 0;\n-        Collection values = getMap().values();\n-        for (Iterator it = values.iterator(); it.hasNext();) {\n-            Collection coll = (Collection) it.next();\n-            total += coll.size();\n-        }\n-        return total;\n-    }\n-\n-    /**\n-     * Creates a new instance of the map value Collection container\n-     * using the factory.\n-     * <p>\n-     * This method can be overridden to perform your own processing\n-     * instead of using the factory.\n-     *\n-     * @param size  the collection size that is about to be added\n-     * @return the new collection\n-     */\n-    protected Collection createCollection(int size) {\n-        return (Collection) collectionFactory.create();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Inner class that provides the values view.\n-     */\n-    private class Values extends AbstractCollection {\n-        public Iterator iterator() {\n-            final IteratorChain chain = new IteratorChain();\n-            for (Iterator it = keySet().iterator(); it.hasNext();) {\n-                chain.addIterator(new ValuesIterator(it.next()));\n-            }\n-            return chain;\n-        }\n-\n-        public int size() {\n-            return totalSize();\n-        }\n-\n-        public void clear() {\n-            MultiValueMap.this.clear();\n-        }\n-    }\n-\n-    /**\n-     * Inner class that provides the values iterator.\n-     */\n-    private class ValuesIterator implements Iterator {\n-        private final Object key;\n-        private final Collection values;\n-        private final Iterator iterator;\n-\n-        public ValuesIterator(Object key) {\n-            this.key = key;\n-            this.values = getCollection(key);\n-            this.iterator = values.iterator();\n-        }\n-\n-        public void remove() {\n-            iterator.remove();\n-            if (values.isEmpty()) {\n-                MultiValueMap.this.remove(key);\n-            }\n-        }\n-\n-        public boolean hasNext() {\n-            return iterator.hasNext();\n-        }\n-\n-        public Object next() {\n-            return iterator.next();\n-        }\n-    }\n-\n-    /**\n-     * Inner class that provides a simple reflection factory.\n-     */\n-    private static class ReflectionFactory implements Factory {\n-        private final Class clazz;\n-\n-        public ReflectionFactory(Class clazz) {\n-            this.clazz = clazz;\n-        }\n-\n-        public Object create() {\n-            try {\n-                return clazz.newInstance();\n-            } catch (Exception ex) {\n-                throw new RuntimeException(\"Cannot instantiate class: \" + clazz, ex);\n-            }\n-        }\n-    }\n-\n-}\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.MultiMap;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+\n+/**\n+ * A MultiValueMap decorates another map, allowing it to have\n+ * more than one value for a key.\n+ * <p>\n+ * A <code>MultiMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that key.\n+ * <p>\n+ * This implementation is a decorator, allowing any Map implementation\n+ * to be used as the base.\n+ * <p>\n+ * In addition, this implementation allows the type of collection used\n+ * for the values to be controlled. By default, an <code>ArrayList</code>\n+ * is used, however a <code>Class</code> to instantiate may be specified,\n+ * or a factory that returns a <code>Collection</code> instance.\n+ *\n+ * @author James Carman\n+ * @author Christopher Berry\n+ * @author James Strachan\n+ * @author Steve Downey\n+ * @author Stephen Colebourne\n+ * @author Julien Buret\n+ * @author Serhiy Yevtushenko\n+ * @version $Revision$ $Date$\n+ * @since Commons Collections 3.2\n+ */\n+public class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n+\n+    /** The factory for creating value collections. */\n+    private final Factory collectionFactory;\n+    /** The cached values. */\n+    private transient Collection values;\n+\n+    /**\n+     * Creates a map which wraps the given map and\n+     * maps keys to ArrayLists.\n+     *\n+     * @param map  the map to wrap\n+     */\n+    public static MultiValueMap decorate(Map map) {\n+        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * maps keys to collections of type <code>collectionClass</code>.\n+     *\n+     * @param map  the map to wrap\n+     * @param collectionClass  the type of the collection class\n+     */\n+    public static MultiValueMap decorate(Map map, Class collectionClass) {\n+        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory (must return a Collection object).\n+     */\n+    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n+        return new MultiValueMap(map, collectionFactory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> and\n+     * storing the multiple values in an <code>ArrayList</code>.\n+     */\n+    public MultiValueMap() {\n+        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory which must return a Collection instance\n+     */\n+    protected MultiValueMap(Map map, Factory collectionFactory) {\n+        super(map);\n+        if (collectionFactory == null) {\n+            throw new IllegalArgumentException(\"The factory must not be null\");\n+        }\n+        this.collectionFactory = collectionFactory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clear the map.\n+     */\n+    public void clear() {\n+        // If you believe that you have GC issues here, try uncommenting this code\n+//        Set pairs = getMap().entrySet();\n+//        Iterator pairsIterator = pairs.iterator();\n+//        while (pairsIterator.hasNext()) {\n+//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+//            Collection coll = (Collection) keyValuePair.getValue();\n+//            coll.clear();\n+//        }\n+        getMap().clear();\n+    }\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, <code>null</code> will be returned\n+     * from a subsequant <code>get(key)</code>.\n+     *\n+     * @param key  the key to remove from\n+     * @param value the value to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     */\n+    public Object remove(Object key, Object value) {\n+        Collection valuesForKey = getCollection(key);\n+        if (valuesForKey == null) {\n+            return null;\n+        }\n+        boolean removed = valuesForKey.remove(value);\n+        if (removed == false) {\n+            return null;\n+        }\n+        if (valuesForKey.isEmpty()) {\n+            remove(key);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the value specified.\n+     * <p>\n+     * This checks all collections against all keys for the value, and thus could be slow.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        Set pairs = getMap().entrySet();\n+        if (pairs == null) {\n+            return false;\n+        }\n+        Iterator pairsIterator = pairs.iterator();\n+        while (pairsIterator.hasNext()) {\n+            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+            Collection coll = (Collection) keyValuePair.getValue();\n+            if (coll.contains(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     *\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return the value added if the map changed and null if the map did not change\n+     */\n+    public Object put(Object key, Object value) {\n+        boolean result = false;\n+        Collection coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(1);\n+            result = coll.add(value);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                getMap().put(key, coll);\n+                result = false;\n+            }\n+        } else {\n+            result = coll.add(value);\n+        }\n+        return (result ? value : null);\n+    }\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * This returns a collection containing the combination of values from all keys.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    public Collection values() {\n+        Collection vs = values;\n+        return (vs != null ? vs : (values = new Values()));\n+    }\n+\n+    /**\n+     * Checks whether the collection at the specified key contains the value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object key, Object value) {\n+        Collection coll = getCollection(key);\n+        if (coll == null) {\n+            return false;\n+        }\n+        return coll.contains(value);\n+    }\n+\n+    /**\n+     * Gets the collection mapped to the specified key.\n+     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the collection mapped to the key, null if no mapping\n+     */\n+    public Collection getCollection(Object key) {\n+        return (Collection) getMap().get(key);\n+    }\n+\n+    /**\n+     * Gets the size of the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get size for\n+     * @return the size of the collection at the key, zero if key not in map\n+     */\n+    public int size(Object key) {\n+        Collection coll = getCollection(key);\n+        if (coll == null) {\n+            return 0;\n+        }\n+        return coll.size();\n+    }\n+\n+    /**\n+     * Adds a collection of values to the collection associated with\n+     * the specified key.\n+     *\n+     * @param key  the key to store against\n+     * @param values  the values to add to the collection at the key, null ignored\n+     * @return true if this map changed\n+     */\n+    public boolean putAll(Object key, Collection values) {\n+        if (values == null || values.size() == 0) {\n+            return false;\n+        }\n+        Collection coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(values.size());\n+            boolean result = coll.addAll(values);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                getMap().put(key, coll);\n+                result = false;\n+            }\n+            return result;\n+        } else {\n+            return coll.addAll(values);\n+        }\n+    }\n+\n+    /**\n+     * Gets an iterator for the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get an iterator for\n+     * @return the iterator of the collection at the key, empty iterator if key not in map\n+     */\n+    public Iterator iterator(Object key) {\n+        if (!containsKey(key)) {\n+            return EmptyIterator.INSTANCE;\n+        } else {\n+            return new ValuesIterator(key);\n+        }\n+    }\n+\n+    /**\n+     * Gets the total size of the map by counting all the values.\n+     *\n+     * @return the total size of the map counting all values\n+     */\n+    public int totalSize() {\n+        int total = 0;\n+        Collection values = getMap().values();\n+        for (Iterator it = values.iterator(); it.hasNext();) {\n+            Collection coll = (Collection) it.next();\n+            total += coll.size();\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Creates a new instance of the map value Collection container\n+     * using the factory.\n+     * <p>\n+     * This method can be overridden to perform your own processing\n+     * instead of using the factory.\n+     *\n+     * @param size  the collection size that is about to be added\n+     * @return the new collection\n+     */\n+    protected Collection createCollection(int size) {\n+        return (Collection) collectionFactory.create();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class that provides the values view.\n+     */\n+    private class Values extends AbstractCollection {\n+        public Iterator iterator() {\n+            final IteratorChain chain = new IteratorChain();\n+            for (Iterator it = keySet().iterator(); it.hasNext();) {\n+                chain.addIterator(new ValuesIterator(it.next()));\n+            }\n+            return chain;\n+        }\n+\n+        public int size() {\n+            return totalSize();\n+        }\n+\n+        public void clear() {\n+            MultiValueMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides the values iterator.\n+     */\n+    private class ValuesIterator implements Iterator {\n+        private final Object key;\n+        private final Collection values;\n+        private final Iterator iterator;\n+\n+        public ValuesIterator(Object key) {\n+            this.key = key;\n+            this.values = getCollection(key);\n+            this.iterator = values.iterator();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            if (values.isEmpty()) {\n+                MultiValueMap.this.remove(key);\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public Object next() {\n+            return iterator.next();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides a simple reflection factory.\n+     */\n+    private static class ReflectionFactory implements Factory {\n+        private final Class clazz;\n+\n+        public ReflectionFactory(Class clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        public Object create() {\n+            try {\n+                return clazz.newInstance();\n+            } catch (Exception ex) {\n+                throw new RuntimeException(\"Cannot instantiate class: \" + clazz, ex);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1120779099, "metainfo": ""}