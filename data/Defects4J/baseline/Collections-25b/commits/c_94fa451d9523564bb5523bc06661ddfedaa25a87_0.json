{"sha": "94fa451d9523564bb5523bc06661ddfedaa25a87", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r814050 | sebb | 2009-09-11 15:01:25 -0700 (Fri, 11 Sep 2009) | 1 line          Some minor Javadoc fixes     ------------------------------------------------------------------------     r471579 | scolebourne | 2006-11-05 16:14:58 -0800 (Sun, 05 Nov 2006) | 1 line          Generify, remove getBuffer() - use covariant decorated()     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n  * @author Janek Bogucki\n  * @author Phil Steitz\n  * @author James Carman\n+ * @param <E> the type of the elements in the buffer\n  * @version $Revision$ $Date$\n  * @since Commons Collections 3.0\n  */\n-public class BlockingBuffer extends SynchronizedBuffer {\n+public class BlockingBuffer<E> extends SynchronizedBuffer<E> {\n \n     /** Serialization version. */\n     private static final long serialVersionUID = 1719328905017860541L;\n     /**\n      * Factory method to create a blocking buffer.\n      *\n+     * @param <T> the type of the elements in the buffer\n      * @param buffer the buffer to decorate, must not be null\n      * @return a new blocking Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static Buffer decorate(Buffer buffer) {\n-        return new BlockingBuffer(buffer);\n+    public static <T> Buffer<T> decorate(Buffer<T> buffer) {\n+        return new BlockingBuffer<T>(buffer);\n     }\n \n     /**\n      * Factory method to create a blocking buffer with a timeout value.\n      *\n+     * @param <t> the type of the elements in the buffer\n      * @param buffer  the buffer to decorate, must not be null\n      * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n      * @return a new blocking buffer\n      * @throws IllegalArgumentException if the buffer is null\n      * @since Commons Collections 3.2\n      */\n-    public static Buffer decorate(Buffer buffer, long timeoutMillis) {\n-        return new BlockingBuffer(buffer, timeoutMillis);\n+    public static <T> Buffer<T> decorate(Buffer<T> buffer, long timeoutMillis) {\n+        return new BlockingBuffer<T>(buffer, timeoutMillis);\n     }\n \n     //-----------------------------------------------------------------------    \n      * @param buffer the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    protected BlockingBuffer(Buffer buffer) {\n+    protected BlockingBuffer(Buffer<E> buffer) {\n         super(buffer);\n         this.timeout = 0;\n     }\n      * @throws IllegalArgumentException if the buffer is null\n      * @since Commons Collections 3.2\n      */\n-    protected BlockingBuffer(Buffer buffer, long timeoutMillis) {\n+    protected BlockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n         super(buffer);\n         this.timeout = (timeoutMillis < 0 ? 0 : timeoutMillis);\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add(Object o) {\n+    public boolean add(E o) {\n         synchronized (lock) {\n             boolean result = collection.add(o);\n             lock.notifyAll();\n         }\n     }\n \n-    public boolean addAll(Collection c) {\n+    public boolean addAll(Collection<? extends E> c) {\n         synchronized (lock) {\n             boolean result = collection.addAll(c);\n             lock.notifyAll();\n      *\n      * @throws BufferUnderflowException if an interrupt is received\n      */\n-    public Object get() {\n+    public E get() {\n         synchronized (lock) {\n             while (collection.isEmpty()) {\n                 try {\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n-            return getBuffer().get();\n+            return decorated().get();\n         }\n     }\n \n      * @throws BufferUnderflowException if the timeout expires\n      * @since Commons Collections 3.2\n      */\n-    public Object get(final long timeout) {\n+    public E get(final long timeout) {\n         synchronized (lock) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n             if (collection.isEmpty()) {\n                 throw new BufferUnderflowException(\"Timeout expired\");\n             }\n-            return getBuffer().get();\n+            return decorated().get();\n         }\n     }\n \n      *\n      * @throws BufferUnderflowException if an interrupt is received\n      */\n-    public Object remove() {\n+    public E remove() {\n         synchronized (lock) {\n             while (collection.isEmpty()) {\n                 try {\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n-            return getBuffer().remove();\n+            return decorated().remove();\n         }\n     }\n \n      * @throws BufferUnderflowException if the timeout expires\n      * @since Commons Collections 3.2\n      */\n-    public Object remove(final long timeout) {\n+    public E remove(final long timeout) {\n         synchronized (lock) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n             if (collection.isEmpty()) {\n                 throw new BufferUnderflowException(\"Timeout expired\");\n             }\n-            return getBuffer().remove();\n+            return decorated().remove();\n         }\n     }\n ", "timestamp": 1252994067, "metainfo": ""}