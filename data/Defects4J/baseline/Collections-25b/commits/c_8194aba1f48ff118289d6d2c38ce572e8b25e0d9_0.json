{"sha": "8194aba1f48ff118289d6d2c38ce572e8b25e0d9", "log": "[COLLECTIONS-351] Moved IdentityMap to tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/map/package-info.java\n+++ b/src/main/java/org/apache/commons/collections/map/package-info.java\n  *   <li>CaseInsensitiveMap - map that compares keys in a case insensitive way\n  *   <li>CompositeMap - map that combines multiple maps into a single view\n  *   <li>HashedMap - general purpose HashMap replacement supporting MapIterator\n- *   <li>IdentityMap - map that uses == for comparison instead of equals()\n  *   <li>Flat3Map - designed for good performance at size 3 or less\n  *   <li>LinkedMap - a hash map that maintains insertion order, supporting OrderedMapIterator\n  *   <li>LRUMap - a hash map that maintains a maximum size by removing the least recently used entries\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/IdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * A <code>Map</code> implementation that matches keys and values based\n+ * on <code>==</code> not <code>equals()</code>.\n+ * <p>\n+ * <strong>This map will violate the detail of various Map and map view contracts.</note>\n+ * As a general rule, don't compare this map to other maps. In particular, you can't\n+ * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n+ * contracts are fulfilled.\n+ * <p>\n+ * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * From 4.0, this class is replaced by java.util.IdentityHashMap but kept as a\n+ * test-class because it is still used by the ReferenceIdentityMapTest.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class IdentityMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 2028493495224302329L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public IdentityMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public IdentityMap(final int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public IdentityMap(final int initialCapacity, final float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public IdentityMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hash code for the key specified.\n+     * This implementation uses the identity hash code.\n+     *\n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    @Override\n+    protected int hash(final Object key) {\n+        return System.identityHashCode(key);\n+    }\n+\n+    /**\n+     * Compares two keys for equals.\n+     * This implementation uses <code>==</code>.\n+     *\n+     * @param key1  the first key to compare\n+     * @param key2  the second key to compare\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualKey(final Object key1, final Object key2) {\n+        return key1 == key2;\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses <code>==</code>.\n+     *\n+     * @param value1  the first value to compare\n+     * @param value2  the second value to compare\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n+        return value1 == value2;\n+    }\n+\n+    /**\n+     * Creates an entry to store the data.\n+     * This implementation creates an IdentityEntry instance.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n+                                              final K key, final V value) {\n+        return new IdentityEntry<K, V>(next, hashCode, key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * HashEntry\n+     */\n+    protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n+\n+        protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+            super(next, hashCode, key, value);\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return\n+                getKey() == other.getKey() &&\n+                getValue() == other.getValue();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(getKey()) ^\n+                   System.identityHashCode(getValue());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public IdentityMap<K, V> clone() {\n+        return (IdentityMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}", "timestamp": 1363548254, "metainfo": ""}