{"sha": "c16a5e8ea51e80ad9eb1e3cec6a46ac967513d8a", "log": "Update licence and javadoc   ", "commit": "\n--- a/src/java/org/apache/commons/collections/DefaultMapBag.java\n+++ b/src/java/org/apache/commons/collections/DefaultMapBag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DefaultMapBag.java,v 1.7 2003/01/13 23:54:38 rwaldhoff Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DefaultMapBag.java,v 1.8 2003/05/16 14:24:55 scolebourne Exp $\n  * ====================================================================\n+ *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections;\n \n import java.util.ArrayList;\n  * Subclasses need only to call <code>setMap(Map)</code> in their constructor \n  * (or invoke the {@link #DefaultMapBag(java.util.Map) Map-constructor})\n  * specifying a map instance that will be used to store the contents of \n- * the bag.<P>\n- *\n+ * the bag.\n+ * <p>\n  * The map will be used to map bag elements to a number; the number represents\n- * the number of occurrences of that element in the bag.<P>\n+ * the number of occurrences of that element in the bag.\n  *\n  * @since Commons Collections 2.0\n- * @version $Revision: 1.7 $ $Date: 2003/01/13 23:54:38 $\n+ * @version $Revision: 1.8 $ $Date: 2003/05/16 14:24:55 $\n+ * \n  * @author Chuck Burdick\n  * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n- **/\n+ * @author Stephen Colebourne\n+ */\n public abstract class DefaultMapBag implements Bag {\n-   private Map _map = null;\n-   private int _total = 0;\n-   private int _mods = 0;\n-\n-\n-   /**\n-    *  No-argument constructor.  \n-    *  Subclasses should invoke <code>setMap(Map)</code> in\n-    *  their constructors.\n-    */\n-   public DefaultMapBag() {\n-   }\n-   \n-   /**\n-    * @since Commons Collections 2.2\n-    */\n-   public DefaultMapBag(Map map) {\n-      setMap(map);\n-   }\n-\n-   /**\n-    *  Adds a new element to the bag by incrementing its count in the \n-    *  underlying map.\n-    *\n-    *  @see Bag#add(Object) \n-    */\n-   public boolean add(Object o) {\n-      return add(o, 1);\n-   }\n-\n-   /**\n-    *  Adds a new element to the bag by incrementing its count in the map.\n-    *\n-    *  @see Bag#add(Object, int)\n-    */\n-   public boolean add(Object o, int i) {\n-      _mods++;\n-      if (i > 0) {\n-         int count = (i + getCount(o));\n-         _map.put(o, new Integer(count));\n-         _total += i;\n-         return (count == i);\n-      } else {\n-         return false;\n-      }\n-   }\n-\n-   /**\n-    *  Invokes {@link #add(Object)} for each element in the given collection.\n-    *\n-    *  @see Bag#addAll(Collection)\n-    */\n-   public boolean addAll(Collection c) {\n-      boolean changed = false;\n-      Iterator i = c.iterator();\n-      while (i.hasNext()) {\n-         boolean added = add(i.next());\n-         changed = changed || added;\n-      }\n-      return changed;\n-   }\n-\n-\n-   /**\n-    *  Clears the bag by clearing the underlying map.\n-    */\n-   public void clear() {\n-      _mods++;\n-      _map.clear();\n-      _total = 0;\n-   }\n-\n-   /**\n-    *  Determines if the bag contains the given element by checking if the\n-    *  underlying map contains the element as a key.\n-    *\n-    *  @return true if the bag contains the given element\n-    */\n-   public boolean contains(Object o) {\n-      return _map.containsKey(o);\n-   }\n-\n-   public boolean containsAll(Collection c) {\n-      return containsAll(new HashBag(c));\n-   }\n-\n-   /**\n-    * Returns <code>true</code> if the bag contains all elements in\n-    * the given collection, respecting cardinality.\n-    * @see #containsAll(Collection)\n-    **/\n-   public boolean containsAll(Bag other) {\n-      boolean result = true;\n-      Iterator i = other.uniqueSet().iterator();\n-      while (i.hasNext()) {\n-         Object current = i.next();\n-         boolean contains =\n-            getCount(current) >= ((Bag)other).getCount(current);\n-         result = result && contains;\n-      }\n-      return result;\n-   }\n-\n-   /**\n-    * Returns true if the given object is not null, has the precise type \n-    * of this bag, and contains the same number of occurrences of all the\n-    * same elements.\n-    *\n-    * @param o the object to test for equality\n-    * @return true if that object equals this bag\n-    */\n-   public boolean equals(Object o) {\n-      return (o == this || \n-              (o != null && o.getClass().equals(this.getClass()) &&\n-               ((DefaultMapBag)o)._map.equals(this._map)));\n-   }\n-\n-   /**\n-    * Returns the hash code of the underlying map.\n-    *\n-    * @return the hash code of the underlying map\n-    */\n-   public int hashCode() {\n-      return _map.hashCode();\n-   }\n-\n-   /**\n-    * Returns true if the underlying map is empty.\n-    *\n-    * @return true if there are no elements in this bag\n-    */\n-   public boolean isEmpty() {\n-      return _map.isEmpty();\n-   }\n-\n-   public Iterator iterator() {\n-      return new BagIterator(this, extractList().iterator()); \n-   }\n-\n-   private class BagIterator implements Iterator {\n-      private DefaultMapBag _parent = null;\n-      private Iterator _support = null;\n-      private Object _current = null;\n-      private int _mods = 0;\n-\n-      public BagIterator(DefaultMapBag parent, Iterator support) {\n-         _parent = parent;\n-         _support = support;\n-         _current = null;\n-         _mods = parent.modCount();\n-      }\n-\n-      public boolean hasNext() {\n-         return _support.hasNext();\n-      }\n-\n-      public Object next() {\n-         if (_parent.modCount() != _mods) {\n-            throw new ConcurrentModificationException();\n-         }\n-         _current = _support.next();\n-         return _current;\n-      }\n-      \n-      public void remove() {\n-         if (_parent.modCount() != _mods) {\n-            throw new ConcurrentModificationException();\n-         }\n-         _support.remove();\n-         _parent.remove(_current, 1);\n-         _mods++;\n-      }\n-   }\n-\n-   public boolean remove (Object o) {\n-      return remove(o, getCount(o));\n-   }\n-\n-   public boolean remove (Object o, int i) {\n-      _mods++;\n-      boolean result = false;\n-      int count = getCount(o);\n-      if (i <= 0) {\n-         result = false;\n-      } else if (count > i) {\n-         _map.put(o, new Integer(count - i));\n-         result = true;\n-         _total -= i;\n-      } else { // count > 0 && count <= i  \n-         // need to remove all\n-         result = (_map.remove(o) != null);\n-         _total -= count;\n-      }\n-      return result;\n-   }\n-\n-   public boolean removeAll(Collection c) {\n-      boolean result = false;\n-      if (c != null) {\n-         Iterator i = c.iterator();\n-         while (i.hasNext()) {\n-            boolean changed = remove(i.next(), 1);\n-            result = result || changed;\n-         }\n-      }\n-      return result;\n-   }\n-\n-   /**\n-    * Remove any members of the bag that are not in the given\n-    * bag, respecting cardinality.\n-    *\n-    * @return true if this call changed the collection\n-    */\n-   public boolean retainAll(Collection c) {\n-      return retainAll(new HashBag(c));\n-   }\n-\n-   /**\n-    * Remove any members of the bag that are not in the given\n-    * bag, respecting cardinality.\n-    * @see #retainAll(Collection)\n-    * @return <code>true</code> if this call changed the collection\n-    **/\n-   public boolean retainAll(Bag other) {\n-      boolean result = false;\n-      Bag excess = new HashBag();\n-      Iterator i = uniqueSet().iterator();\n-      while (i.hasNext()) {\n-         Object current = i.next();\n-         int myCount = getCount(current);\n-         int otherCount = other.getCount(current);\n-         if (1 <= otherCount && otherCount <= myCount) {\n-            excess.add(current, myCount - otherCount);\n-         } else {\n-            excess.add(current, myCount);\n-         }\n-      }\n-      if (!excess.isEmpty()) {\n-         result = removeAll(excess);\n-      }\n-      return result;\n-   }\n-\n-   /**\n-    *  Returns an array of all of this bag's elements.\n-    *\n-    *  @return an array of all of this bag's elements\n-    */\n-   public Object[] toArray() {\n-      return extractList().toArray();\n-   }\n-\n-   /**\n-    *  Returns an array of all of this bag's elements.\n-    *\n-    *  @param a  the array to populate\n-    *  @return an array of all of this bag's elements\n-    */\n-   public Object[] toArray(Object[] a) {\n-      return extractList().toArray(a);\n-   }\n-\n-   /**\n-    *  Returns the number of occurrence of the given element in this bag\n-    *  by looking up its count in the underlying map.\n-    *\n-    *  @see Bag#getCount(Object)\n-    */\n-   public int getCount(Object o) {\n-      int result = 0;\n-      Integer count = MapUtils.getInteger(_map, o);\n-      if (count != null) {\n-         result = count.intValue();\n-      }\n-      return result;\n-   }\n-\n-   /**\n-    *  Returns an unmodifiable view of the underlying map's key set.\n-    *\n-    *  @return the set of unique elements in this bag\n-    */\n-   public Set uniqueSet() {\n-      return Collections.unmodifiableSet(_map.keySet());\n-   }\n-\n-   /**\n-    *  Returns the number of elements in this bag.\n-    *\n-    *  @return the number of elements in this bag\n-    */\n-   public int size() {\n-      return _total;\n-   }\n-\n-   /**\n-    * Actually walks the bag to make sure the count is correct and\n-    * resets the running total\n-    **/\n-   protected int calcTotalSize() {\n-      _total = extractList().size();\n-      return _total;\n-   }\n-\n-   /**\n-    * Utility method for implementations to set the map that backs\n-    * this bag. Not intended for interactive use outside of\n-    * subclasses.\n-    **/\n-   protected void setMap(Map m) {\n-      _map = m;\n-   }\n-\n-   /**\n-    * Utility method for implementations to access the map that backs\n-    * this bag. Not intended for interactive use outside of\n-    * subclasses.\n-    **/\n-   protected Map getMap() {\n-      return _map;\n-   }\n-\n-   /**\n-    * Create a list for use in iteration, etc.\n-    **/\n-   private List extractList() {\n-      List result = new ArrayList();\n-      Iterator i = uniqueSet().iterator();\n-      while (i.hasNext()) {\n-         Object current = i.next();\n-         for (int index = getCount(current); index > 0; index--) {\n-            result.add(current);\n-         }\n-      }\n-      return result;\n-   }\n-\n-   /**\n-    * Return number of modifications for iterator\n-    **/\n-   private int modCount() {\n-      return _mods;\n-   }\n-\n-    /**\n-     *  Implement a toString() method suitable for debugging\n-     **/\n+    private Map _map = null;\n+    private int _total = 0;\n+    private int _mods = 0;\n+\n+    /**\n+     * No-argument constructor.  \n+     * Subclasses should invoke <code>setMap(Map)</code> in\n+     * their constructors.\n+     */\n+    public DefaultMapBag() {\n+    }\n+\n+    /**\n+     * Constructor that assigns the specified Map as the backing store.\n+     * The map must be empty.\n+     * \n+     * @param map  the map to assign\n+     */\n+    protected DefaultMapBag(Map map) {\n+        setMap(map);\n+    }\n+\n+    /**\n+     * Adds a new element to the bag by incrementing its count in the \n+     * underlying map.\n+     *\n+     * @param object  the object to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    public boolean add(Object object) {\n+        return add(object, 1);\n+    }\n+\n+    /**\n+     * Adds a new element to the bag by incrementing its count in the map.\n+     *\n+     * @param object  the object to search for\n+     * @param nCopies  the number of copies to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    public boolean add(Object object, int nCopies) {\n+        _mods++;\n+        if (nCopies > 0) {\n+            int count = (nCopies + getCount(object));\n+            _map.put(object, new Integer(count));\n+            _total += nCopies;\n+            return (count == nCopies);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Invokes {@link #add(Object)} for each element in the given collection.\n+     *\n+     * @param coll  the collection to add\n+     * @return <code>true</code> if this call changed the bag\n+     */\n+    public boolean addAll(Collection coll) {\n+        boolean changed = false;\n+        Iterator i = coll.iterator();\n+        while (i.hasNext()) {\n+            boolean added = add(i.next());\n+            changed = changed || added;\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Clears the bag by clearing the underlying map.\n+     */\n+    public void clear() {\n+        _mods++;\n+        _map.clear();\n+        _total = 0;\n+    }\n+\n+    /**\n+     * Determines if the bag contains the given element by checking if the\n+     * underlying map contains the element as a key.\n+     *\n+     * @param object  the object to search for\n+     * @return true if the bag contains the given element\n+     */\n+    public boolean contains(Object object) {\n+        return _map.containsKey(object);\n+    }\n+\n+    /**\n+     * Determines if the bag contains the given elements.\n+     * \n+     * @param coll  the collection to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    public boolean containsAll(Collection coll) {\n+        return containsAll(new HashBag(coll));\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the bag contains all elements in\n+     * the given collection, respecting cardinality.\n+     * \n+     * @param other  the bag to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    public boolean containsAll(Bag other) {\n+        boolean result = true;\n+        Iterator i = other.uniqueSet().iterator();\n+        while (i.hasNext()) {\n+            Object current = i.next();\n+            boolean contains = getCount(current) >= ((Bag) other).getCount(current);\n+            result = result && contains;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns true if the given object is not null, has the precise type \n+     * of this bag, and contains the same number of occurrences of all the\n+     * same elements.\n+     *\n+     * @param object  the object to test for equality\n+     * @return true if that object equals this bag\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return (object != null &&\n+                object.getClass().equals(this.getClass()) &&\n+                ((DefaultMapBag) object)._map.equals(this._map));\n+    }\n+\n+    /**\n+     * Returns the hash code of the underlying map.\n+     *\n+     * @return the hash code of the underlying map\n+     */\n+    public int hashCode() {\n+        return _map.hashCode();\n+    }\n+\n+    /**\n+     * Returns true if the underlying map is empty.\n+     *\n+     * @return true if there are no elements in this bag\n+     */\n+    public boolean isEmpty() {\n+        return _map.isEmpty();\n+    }\n+\n+    public Iterator iterator() {\n+        return new BagIterator(this, extractList().iterator());\n+    }\n+\n+    private class BagIterator implements Iterator {\n+        private DefaultMapBag _parent = null;\n+        private Iterator _support = null;\n+        private Object _current = null;\n+        private int _mods = 0;\n+\n+        public BagIterator(DefaultMapBag parent, Iterator support) {\n+            _parent = parent;\n+            _support = support;\n+            _current = null;\n+            _mods = parent.modCount();\n+        }\n+\n+        public boolean hasNext() {\n+            return _support.hasNext();\n+        }\n+\n+        public Object next() {\n+            if (_parent.modCount() != _mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            _current = _support.next();\n+            return _current;\n+        }\n+\n+        public void remove() {\n+            if (_parent.modCount() != _mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            _support.remove();\n+            _parent.remove(_current, 1);\n+            _mods++;\n+        }\n+    }\n+\n+    public boolean remove(Object object) {\n+        return remove(object, getCount(object));\n+    }\n+\n+    public boolean remove(Object object, int nCopies) {\n+        _mods++;\n+        boolean result = false;\n+        int count = getCount(object);\n+        if (nCopies <= 0) {\n+            result = false;\n+        } else if (count > nCopies) {\n+            _map.put(object, new Integer(count - nCopies));\n+            result = true;\n+            _total -= nCopies;\n+        } else { // count > 0 && count <= i  \n+            // need to remove all\n+            result = (_map.remove(object) != null);\n+            _total -= count;\n+        }\n+        return result;\n+    }\n+\n+    public boolean removeAll(Collection coll) {\n+        boolean result = false;\n+        if (coll != null) {\n+            Iterator i = coll.iterator();\n+            while (i.hasNext()) {\n+                boolean changed = remove(i.next(), 1);\n+                result = result || changed;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given\n+     * bag, respecting cardinality.\n+     *\n+     * @param coll  the collection to retain\n+     * @return true if this call changed the collection\n+     */\n+    public boolean retainAll(Collection coll) {\n+        return retainAll(new HashBag(coll));\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given\n+     * bag, respecting cardinality.\n+     * @see #retainAll(Collection)\n+     * \n+     * @param other  the bag to retain\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    public boolean retainAll(Bag other) {\n+        boolean result = false;\n+        Bag excess = new HashBag();\n+        Iterator i = uniqueSet().iterator();\n+        while (i.hasNext()) {\n+            Object current = i.next();\n+            int myCount = getCount(current);\n+            int otherCount = other.getCount(current);\n+            if (1 <= otherCount && otherCount <= myCount) {\n+                excess.add(current, myCount - otherCount);\n+            } else {\n+                excess.add(current, myCount);\n+            }\n+        }\n+        if (!excess.isEmpty()) {\n+            result = removeAll(excess);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an array of all of this bag's elements.\n+     *\n+     * @return an array of all of this bag's elements\n+     */\n+    public Object[] toArray() {\n+        return extractList().toArray();\n+    }\n+\n+    /**\n+     * Returns an array of all of this bag's elements.\n+     *\n+     * @param array  the array to populate\n+     * @return an array of all of this bag's elements\n+     */\n+    public Object[] toArray(Object[] array) {\n+        return extractList().toArray(array);\n+    }\n+\n+    /**\n+     * Returns the number of occurrence of the given element in this bag\n+     * by looking up its count in the underlying map.\n+     *\n+     * @param object  the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    public int getCount(Object object) {\n+        int result = 0;\n+        Integer count = MapUtils.getInteger(_map, object);\n+        if (count != null) {\n+            result = count.intValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the underlying map's key set.\n+     *\n+     * @return the set of unique elements in this bag\n+     */\n+    public Set uniqueSet() {\n+        return Collections.unmodifiableSet(_map.keySet());\n+    }\n+\n+    /**\n+     * Returns the number of elements in this bag.\n+     *\n+     * @return the number of elements in this bag\n+     */\n+    public int size() {\n+        return _total;\n+    }\n+\n+    /**\n+     * Actually walks the bag to make sure the count is correct and\n+     * resets the running total\n+     * \n+     * @return the current total size\n+     */\n+    protected int calcTotalSize() {\n+        _total = extractList().size();\n+        return _total;\n+    }\n+\n+    /**\n+     * Utility method for implementations to set the map that backs\n+     * this bag. Not intended for interactive use outside of\n+     * subclasses.\n+     */\n+    protected void setMap(Map map) {\n+        if (map == null || map.isEmpty() == false) {\n+            throw new IllegalArgumentException(\"The map must be non-null and empty\");\n+        }\n+        _map = map;\n+    }\n+\n+    /**\n+     * Utility method for implementations to access the map that backs\n+     * this bag. Not intended for interactive use outside of\n+     * subclasses.\n+     */\n+    protected Map getMap() {\n+        return _map;\n+    }\n+\n+    /**\n+     * Create a list for use in iteration, etc.\n+     */\n+    private List extractList() {\n+        List result = new ArrayList();\n+        Iterator i = uniqueSet().iterator();\n+        while (i.hasNext()) {\n+            Object current = i.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                result.add(current);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Return number of modifications for iterator.\n+     * \n+     * @return the modification count\n+     */\n+    private int modCount() {\n+        return _mods;\n+    }\n+\n+    /**\n+     * Implement a toString() method suitable for debugging.\n+     * \n+     * @return a debugging toString\n+     */\n     public String toString() {\n         StringBuffer buf = new StringBuffer();\n         buf.append(\"[\");\n         Iterator i = uniqueSet().iterator();\n-        while(i.hasNext()) {\n+        while (i.hasNext()) {\n             Object current = i.next();\n             int count = getCount(current);\n             buf.append(count);\n             buf.append(\":\");\n             buf.append(current);\n-            if(i.hasNext()) {\n+            if (i.hasNext()) {\n                 buf.append(\",\");\n             }\n         }\n         buf.append(\"]\");\n         return buf.toString();\n     }\n+    \n }\n-\n-\n-\n--- a/src/java/org/apache/commons/collections/DefaultMapEntry.java\n+++ b/src/java/org/apache/commons/collections/DefaultMapEntry.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DefaultMapEntry.java,v 1.8 2002/08/15 20:04:31 pjack Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/08/15 20:04:31 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DefaultMapEntry.java,v 1.9 2003/05/16 14:24:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n \n import java.util.Map;\n \n-/** A default implementation of {@link java.util.Map.Entry}\n-  *\n-  * @since 1.0\n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n-  */\n-  \n+/**\n+ * A default implementation of {@link java.util.Map.Entry}\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision: 1.9 $ $Date: 2003/05/16 14:24:54 $\n+ * \n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n+ */\n public class DefaultMapEntry implements Map.Entry {\n     \n+    /** The key */\n     private Object key;\n+    /** The value */\n     private Object value;\n     \n     /**\n-     *  Constructs a new <Code>DefaultMapEntry</Code> with a null key\n-     *  and null value.\n+     * Constructs a new <Code>DefaultMapEntry</Code> with a null key\n+     * and null value.\n      */\n     public DefaultMapEntry() {\n     }\n \n     /**\n-     *  Constructs a new <Code>DefaultMapEntry</Code> with the given\n-     *  key and given value.\n+     * Constructs a new <Code>DefaultMapEntry</Code> with the given\n+     * key and given value.\n      *\n-     *  @param key  the key for the entry, may be null\n-     *  @param value  the value for the entyr, may be null\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entyr, may be null\n      */\n     public DefaultMapEntry(Object key, Object value) {\n         this.key = key;\n     }\n \n     /**\n-     *  Implemented per API documentation of \n-     *  {@link java.util.Map.Entry#equals(Object)}\n-     **/\n+     * Implemented per API documentation of \n+     * {@link java.util.Map.Entry#equals(Object)}\n+     */\n     public boolean equals(Object o) {\n         if( o == null ) return false;\n         if( o == this ) return true;        \n      \n      \n     /**\n-     *  Implemented per API documentation of \n-     *  {@link java.util.Map.Entry#hashCode()}\n-     **/\n+     * Implemented per API documentation of \n+     * {@link java.util.Map.Entry#hashCode()}\n+     */\n     public int hashCode() {\n         return ( ( getKey() == null ? 0 : getKey().hashCode() ) ^\n                  ( getValue() == null ? 0 : getValue().hashCode() ) ); \n     //-------------------------------------------------------------------------\n \n     /**\n-     *  Returns the key.\n+     * Returns the key.\n      *\n-     *  @return the key \n+     * @return the key \n      */\n     public Object getKey() {\n         return key;\n     }\n \n-\n     /**\n-     *  Returns the value.\n+     * Returns the value.\n      *\n-     *  @return the value\n+     * @return the value\n      */\n     public Object getValue() {\n         return value;\n     //-------------------------------------------------------------------------    \n \n     /**\n-     *  Sets the key.  This method does not modify any map.\n+     * Sets the key.  This method does not modify any map.\n      *\n-     *  @param key  the new key\n+     * @param key  the new key\n      */\n     public void setKey(Object key) {\n         this.key = key;\n     }\n     \n-    /** Note that this method only sets the local reference inside this object and\n-      * does not modify the original Map.\n-      *\n-      * @return the old value of the value\n-      * @param value the new value\n-      */\n+    /** \n+     * Note that this method only sets the local reference inside this object and\n+     * does not modify the original Map.\n+     *\n+     * @return the old value of the value\n+     * @param value the new value\n+     */\n     public Object setValue(Object value) {\n         Object answer = this.value;\n         this.value = value;\n--- a/src/java/org/apache/commons/collections/DoubleOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/DoubleOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DoubleOrderedMap.java,v 1.3 2002/10/12 22:15:18 scolebourne Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/12 22:15:18 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DoubleOrderedMap.java,v 1.4 2003/05/16 14:24:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections;\n-\n-\n \n import java.util.AbstractCollection;\n import java.util.AbstractMap;\n import java.util.NoSuchElementException;\n import java.util.Set;\n \n-\n /**\n-* Red-Black tree-based implementation of Map. This class guarantees\n-* that the map will be in both ascending key order and ascending\n-* value order, sorted according to the natural order for the key's\n-* and value's classes.<p>\n-*\n-* This Map is intended for applications that need to be able to look\n-* up a key-value pairing by either key or value, and need to do so\n-* with equal efficiency.<p>\n-*\n-* While that goal could be accomplished by taking a pair of TreeMaps\n-* and redirecting requests to the appropriate TreeMap (e.g.,\n-* containsKey would be directed to the TreeMap that maps values to\n-* keys, containsValue would be directed to the TreeMap that maps keys\n-* to values), there are problems with that implementation,\n-* particularly when trying to keep the two TreeMaps synchronized with\n-* each other. And if the data contained in the TreeMaps is large, the\n-* cost of redundant storage becomes significant.<p>\n-*\n-* This solution keeps the data properly synchronized and minimizes\n-* the data storage. The red-black algorithm is based on TreeMap's,\n-* but has been modified to simultaneously map a tree node by key and\n-* by value. This doubles the cost of put operations (but so does\n-* using two TreeMaps), and nearly doubles the cost of remove\n-* operations (there is a savings in that the lookup of the node to be\n-* removed only has to be performed once). And since only one node\n-* contains the key and value, storage is significantly less than that\n-* required by two TreeMaps.<p>\n-*\n-* There are some limitations placed on data kept in this Map. The\n-* biggest one is this:<p>\n-*\n-* When performing a put operation, neither the key nor the value may\n-* already exist in the Map. In the java.util Map implementations\n-* (HashMap, TreeMap), you can perform a put with an already mapped\n-* key, and neither cares about duplicate values at all ... but this\n-* implementation's put method with throw an IllegalArgumentException\n-* if either the key or the value is already in the Map.<p>\n-*\n-* Obviously, that same restriction (and consequence of failing to\n-* heed that restriction) applies to the putAll method.<p>\n-*\n-* The Map.Entry instances returned by the appropriate methods will\n-* not allow setValue() and will throw an\n-* UnsupportedOperationException on attempts to call that method.<p>\n-*\n-* New methods are added to take advantage of the fact that values are\n-* kept sorted independently of their keys:<p>\n-*\n-* Object getKeyForValue(Object value) is the opposite of get; it\n-* takes a value and returns its key, if any.<p>\n-*\n-* Object removeValue(Object value) finds and removes the specified\n-* value and returns the now un-used key.<p>\n-*\n-* Set entrySetByValue() returns the Map.Entry's in a Set whose\n-* iterator will iterate over the Map.Entry's in ascending order by\n-* their corresponding values.<p>\n-*\n-* Set keySetByValue() returns the keys in a Set whose iterator will\n-* iterate over the keys in ascending order by their corresponding\n-* values.<p>\n-*\n-* Collection valuesByValue() returns the values in a Collection whose\n-* iterator will iterate over the values in ascending order.<p>\n-*\n-* @since 2.0\n-* @author Marc Johnson (marcj at users dot sourceforge dot net)\n-*/\n-\n-// final for performance\n+ * Red-Black tree-based implementation of Map. This class guarantees\n+ * that the map will be in both ascending key order and ascending\n+ * value order, sorted according to the natural order for the key's\n+ * and value's classes.<p>\n+ *\n+ * This Map is intended for applications that need to be able to look\n+ * up a key-value pairing by either key or value, and need to do so\n+ * with equal efficiency.<p>\n+ *\n+ * While that goal could be accomplished by taking a pair of TreeMaps\n+ * and redirecting requests to the appropriate TreeMap (e.g.,\n+ * containsKey would be directed to the TreeMap that maps values to\n+ * keys, containsValue would be directed to the TreeMap that maps keys\n+ * to values), there are problems with that implementation,\n+ * particularly when trying to keep the two TreeMaps synchronized with\n+ * each other. And if the data contained in the TreeMaps is large, the\n+ * cost of redundant storage becomes significant.<p>\n+ *\n+ * This solution keeps the data properly synchronized and minimizes\n+ * the data storage. The red-black algorithm is based on TreeMap's,\n+ * but has been modified to simultaneously map a tree node by key and\n+ * by value. This doubles the cost of put operations (but so does\n+ * using two TreeMaps), and nearly doubles the cost of remove\n+ * operations (there is a savings in that the lookup of the node to be\n+ * removed only has to be performed once). And since only one node\n+ * contains the key and value, storage is significantly less than that\n+ * required by two TreeMaps.<p>\n+ *\n+ * There are some limitations placed on data kept in this Map. The\n+ * biggest one is this:<p>\n+ *\n+ * When performing a put operation, neither the key nor the value may\n+ * already exist in the Map. In the java.util Map implementations\n+ * (HashMap, TreeMap), you can perform a put with an already mapped\n+ * key, and neither cares about duplicate values at all ... but this\n+ * implementation's put method with throw an IllegalArgumentException\n+ * if either the key or the value is already in the Map.<p>\n+ *\n+ * Obviously, that same restriction (and consequence of failing to\n+ * heed that restriction) applies to the putAll method.<p>\n+ *\n+ * The Map.Entry instances returned by the appropriate methods will\n+ * not allow setValue() and will throw an\n+ * UnsupportedOperationException on attempts to call that method.<p>\n+ *\n+ * New methods are added to take advantage of the fact that values are\n+ * kept sorted independently of their keys:<p>\n+ *\n+ * Object getKeyForValue(Object value) is the opposite of get; it\n+ * takes a value and returns its key, if any.<p>\n+ *\n+ * Object removeValue(Object value) finds and removes the specified\n+ * value and returns the now un-used key.<p>\n+ *\n+ * Set entrySetByValue() returns the Map.Entry's in a Set whose\n+ * iterator will iterate over the Map.Entry's in ascending order by\n+ * their corresponding values.<p>\n+ *\n+ * Set keySetByValue() returns the keys in a Set whose iterator will\n+ * iterate over the keys in ascending order by their corresponding\n+ * values.<p>\n+ *\n+ * Collection valuesByValue() returns the values in a Collection whose\n+ * iterator will iterate over the values in ascending order.<p>\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision: 1.4 $ $Date: 2003/05/16 14:24:54 $\n+ * \n+ * @author Marc Johnson (marcj at users dot sourceforge dot net)\n+ */\n public final class DoubleOrderedMap extends AbstractMap {\n-\n-    private Node[]                rootNode           = new Node[]{ null,\n-                                                           null };\n-    private int                   nodeCount          = 0;\n-    private int                   modifications      = 0;\n-    private Set[]                 setOfKeys          = new Set[]{ null,\n-                                                           null };\n-    private Set[]                 setOfEntries       = new Set[]{ null,\n-                                                           null };\n-    private Collection[]          collectionOfValues = new Collection[]{ \n-null,\n-                                                                         \n-null };\n-    private static final int      KEY                = 0;\n-    private static final int      VALUE              = 1;\n-    private static final int      SUM_OF_INDICES     = KEY + VALUE;\n-    private static final int      FIRST_INDEX        = 0;\n-    private static final int      NUMBER_OF_INDICES  = 2;\n-    private static final String[] dataName           = new String[]{ \"key\",\n-                                                                     \"value\" \n-};\n+//  final for performance\n+\n+    private static final int KEY = 0;\n+    private static final int VALUE = 1;\n+    private static final int SUM_OF_INDICES = KEY + VALUE;\n+    private static final int FIRST_INDEX = 0;\n+    private static final int NUMBER_OF_INDICES = 2;\n+    private static final String[] dataName = new String[] { \"key\", \"value\" };\n+    \n+    private Node[] rootNode = new Node[] { null, null };\n+    private int nodeCount = 0;\n+    private int modifications = 0;\n+    private Set[] setOfKeys = new Set[] { null, null };\n+    private Set[] setOfEntries = new Set[] { null, null };\n+    private Collection[] collectionOfValues = new Collection[] { null, null };\n \n     /**\n      * Construct a new DoubleOrderedMap\n      */\n-    public DoubleOrderedMap() {}\n+    public DoubleOrderedMap() {\n+    }\n \n     /**\n      * Constructs a new DoubleOrderedMap from an existing Map, with keys and\n      *\n      * @param map the map whose mappings are to be placed in this map.\n      *\n-     * @exception ClassCastException if the keys in the map are not\n+     * @throws ClassCastException if the keys in the map are not\n      *                               Comparable, or are not mutually\n      *                               comparable; also if the values in\n      *                               the map are not Comparable, or\n      *                               are not mutually Comparable\n-     * @exception NullPointerException if any key or value in the map\n+     * @throws NullPointerException if any key or value in the map\n      *                                 is null\n-     * @exception IllegalArgumentException if there are duplicate keys\n+     * @throws IllegalArgumentException if there are duplicate keys\n      *                                     or duplicate values in the\n      *                                     map\n      */\n      * @return the key to which this map maps the specified value, or\n      *         null if the map contains no mapping for this value.\n      *\n-     * @exception ClassCastException if the value is of an\n+     * @throws ClassCastException if the value is of an\n      *                               inappropriate type for this map.\n-     * @exception NullPointerException if the value is null\n+     * @throws NullPointerException if the value is null\n      */\n     public Object getKeyForValue(final Object value)\n             throws ClassCastException, NullPointerException {\n      * @param insertedNode the node to be inserted\n      * @param index KEY or VALUE\n      */\n-    private void doRedBlackInsert(final Node insertedNode, final int index) \n-{\n+    private void doRedBlackInsert(final Node insertedNode, final int index) {\n \n         Node currentNode = insertedNode;\n \n                     makeRed(getGrandParent(currentNode, index), index);\n \n                     if (getGrandParent(currentNode, index) != null) {\n-                        rotateLeft(getGrandParent(currentNode, index), \n-index);\n+                        rotateLeft(getGrandParent(currentNode, index), index);\n                     }\n                 }\n             }\n                     rootNode[index] = replacement;\n                 } else if (deletedNode\n                            == deletedNode.getParent(index).getLeft(index)) {\n-                    deletedNode.getParent(index).setLeft(replacement, \n-index);\n+                    deletedNode.getParent(index).setLeft(replacement, index);\n                 } else {\n-                    deletedNode.getParent(index).setRight(replacement, \n-index);\n+                    deletedNode.getParent(index).setRight(replacement, index);\n                 }\n \n                 deletedNode.setLeft(null, index);\n                         if (deletedNode\n                                 == deletedNode.getParent(index)\n                                     .getLeft(index)) {\n-                            deletedNode.getParent(index).setLeft(null, \n-index);\n+                            deletedNode.getParent(index).setLeft(null, index);\n                         } else {\n                             deletedNode.getParent(index).setRight(null,\n                                                   index);\n                     makeRed(getParent(currentNode, index), index);\n                     rotateLeft(getParent(currentNode, index), index);\n \n-                    siblingNode = getRightChild(getParent(currentNode, \n-index),\n-                                                index);\n+                    siblingNode = getRightChild(getParent(currentNode, index), index);\n                 }\n \n                 if (isBlack(getLeftChild(siblingNode, index), index)\n                         rotateRight(siblingNode, index);\n \n                         siblingNode =\n-                            getRightChild(getParent(currentNode, index),\n-                                          index);\n+                            getRightChild(getParent(currentNode, index), index);\n                     }\n \n                     copyColor(getParent(currentNode, index), siblingNode,\n                     currentNode = rootNode[index];\n                 }\n             } else {\n-                Node siblingNode = getLeftChild(getParent(currentNode, \n-index),\n-                                                index);\n+                Node siblingNode = getLeftChild(getParent(currentNode, index), index);\n \n                 if (isRed(siblingNode, index)) {\n                     makeBlack(siblingNode, index);\n                     makeRed(getParent(currentNode, index), index);\n                     rotateRight(getParent(currentNode, index), index);\n \n-                    siblingNode = getLeftChild(getParent(currentNode, \n-index),\n-                                               index);\n+                    siblingNode = getLeftChild(getParent(currentNode, index), index);\n                 }\n \n                 if (isBlack(getRightChild(siblingNode, index), index)\n-                        && isBlack(getLeftChild(siblingNode, index), index)) \n-{\n+                        && isBlack(getLeftChild(siblingNode, index), index)) {\n                     makeRed(siblingNode, index);\n \n                     currentNode = getParent(currentNode, index);\n                         rotateLeft(siblingNode, index);\n \n                         siblingNode =\n-                            getLeftChild(getParent(currentNode, index),\n-                                         index);\n+                            getLeftChild(getParent(currentNode, index), index);\n                     }\n \n                     copyColor(getParent(currentNode, index), siblingNode,\n      * @param index KEY or VALUE (used to put the right word in the\n      *              exception message)\n      *\n-     * @exception NullPointerException if o is null\n-     * @exception ClassCastException if o is not Comparable\n+     * @throws NullPointerException if o is null\n+     * @throws ClassCastException if o is not Comparable\n      */\n     private static void checkNonNullComparable(final Object o,\n                                                final int index) {\n      *\n      * @param key the key to be checked\n      *\n-     * @exception NullPointerException if key is null\n-     * @exception ClassCastException if key is not Comparable\n+     * @throws NullPointerException if key is null\n+     * @throws ClassCastException if key is not Comparable\n      */\n     private static void checkKey(final Object key) {\n         checkNonNullComparable(key, KEY);\n      *\n      * @param value the value to be checked\n      *\n-     * @exception NullPointerException if value is null\n-     * @exception ClassCastException if value is not Comparable\n+     * @throws NullPointerException if value is null\n+     * @throws ClassCastException if value is not Comparable\n      */\n     private static void checkValue(final Object value) {\n         checkNonNullComparable(value, VALUE);\n      * @param key the key to be checked\n      * @param value the value to be checked\n      *\n-     * @exception NullPointerException if key or value is null\n-     * @exception ClassCastException if key or value is not Comparable\n+     * @throws NullPointerException if key or value is null\n+     * @throws ClassCastException if key or value is not Comparable\n      */\n     private static void checkKeyAndValue(final Object key,\n                                          final Object value) {\n      *\n      * @param newNode the node to be inserted\n      *\n-     * @exception IllegalArgumentException if the node already exists\n+     * @throws IllegalArgumentException if the node already exists\n      *                                     in the value mapping\n      */\n     private void insertValue(final Node newNode)\n      * @return true if this map contains a mapping for the specified\n      *         key.\n      *\n-     * @exception ClassCastException if the key is of an inappropriate\n+     * @throws ClassCastException if the key is of an inappropriate\n      *                               type for this map.\n-     * @exception NullPointerException if the key is null\n+     * @throws NullPointerException if the key is null\n      */\n     public boolean containsKey(final Object key)\n             throws ClassCastException, NullPointerException {\n      * @return the value to which this map maps the specified key, or\n      *         null if the map contains no mapping for this key.\n      *\n-     * @exception ClassCastException if the key is of an inappropriate\n+     * @throws ClassCastException if the key is of an inappropriate\n      *                               type for this map.\n-     * @exception NullPointerException if the key is null\n+     * @throws NullPointerException if the key is null\n      */\n     public Object get(final Object key)\n             throws ClassCastException, NullPointerException {\n      *\n      * @return null\n      *\n-     * @exception ClassCastException if the class of the specified key\n+     * @throws ClassCastException if the class of the specified key\n      *                               or value prevents it from being\n      *                               stored in this map.\n-     * @exception NullPointerException if the specified key or value\n+     * @throws NullPointerException if the specified key or value\n      *                                 is null\n-     * @exception IllegalArgumentException if the key duplicates an\n+     * @throws IllegalArgumentException if the key duplicates an\n      *                                     existing key, or if the\n      *                                     value duplicates an\n      *                                     existing value\n                     Node      node  = lookup((Comparable) entry.getKey(),\n                                              KEY);\n \n-                    if ((node != null) && node.getData(VALUE).equals(value)) \n-{\n+                    if ((node != null) && node.getData(VALUE).equals(value)) {\n                         doRedBlackDelete(node);\n \n                         return true;\n         /**\n          * @return the next element in the iteration.\n          *\n-         * @exception NoSuchElementException if iteration has no more\n+         * @throws NoSuchElementException if iteration has no more\n          *                                   elements.\n-         * @exception ConcurrentModificationException if the\n+         * @throws ConcurrentModificationException if the\n          *                                            DoubleOrderedMap is\n          *                                            modified behind\n          *                                            the iterator's\n          * the iteration is in progress in any way other than by\n          * calling this method.\n          *\n-         * @exception IllegalStateException if the next method has not\n+         * @throws IllegalStateException if the next method has not\n          *                                  yet been called, or the\n          *                                  remove method has already\n          *                                  been called after the last\n          *                                  call to the next method.\n-         * @exception ConcurrentModificationException if the\n+         * @throws ConcurrentModificationException if the\n          *                                            DoubleOrderedMap is\n          *                                            modified behind\n          *                                            the iterator's\n          *\n          * @return does not return\n          *\n-         * @exception UnsupportedOperationException\n+         * @throws UnsupportedOperationException\n          */\n         public Object setValue(Object ignored)\n                 throws UnsupportedOperationException {", "timestamp": 1053095095, "metainfo": ""}