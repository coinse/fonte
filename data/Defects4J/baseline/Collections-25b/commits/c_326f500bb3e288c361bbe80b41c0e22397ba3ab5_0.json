{"sha": "326f500bb3e288c361bbe80b41c0e22397ba3ab5", "log": "Modified tests that used makeEmptyMap and makeFullMap to use the map field along with resetEmpty() and resetFull().  This allows for more calls to verify to ensure that calls to methods that should not modify a collection don't actually modify it.  Split the verify() method into four separate verification methods.  This way, if a Map implementation needs to change the way verification is performed for just one of the collection views, they only need to override one method and won't need to reimplement all the other verifications.  Override TestMultiHashMap's verifyValues() method to retrieve a fresh copy of the values collection before verification.  This ensures some verification testing on the values, even though the values is not backed by the map (bug 9573)  Override a few more test methods and the verifyyMap and verifyEntrySet methods for TestMultiHashMap since it's values are collections rather than the expected objects.  These will need to be filled in with better implementations to actually test the MultiMap contact.  Removed the SupportsPut marker interface.  Removed some duplicate tests (i.e. some old tests that weren't written with the current framework in mind and just duplicate the tests that have been added).   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestMap.java\n+++ b/src/test/org/apache/commons/collections/TestMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.17 2002/06/18 03:17:34 mas Exp $\n- * $Revision: 1.17 $\n- * $Date: 2002/06/18 03:17:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.18 2002/06/18 03:28:35 mas Exp $\n+ * $Revision: 1.18 $\n+ * $Date: 2002/06/18 03:28:35 $\n  *\n  * ====================================================================\n  *\n  * Override these methods if your map requires special entries:\n  *\n  * <UL>\n- * <LI>{@link #getSampleKeys}\n- * <LI>{@link #getSampleValues}\n- * <LI>{@link #getNewSampleValues}\n- * <LI>{@link #getOtherKeys}\n- * <LI>{@link #getOtherValues}\n+ * <LI>{@link #getSampleKeys()}\n+ * <LI>{@link #getSampleValues()}\n+ * <LI>{@link #getNewSampleValues()}\n+ * <LI>{@link #getOtherKeys()}\n+ * <LI>{@link #getOtherValues()}\n  * </UL>\n  *\n  * <B>Supported Operation Methods</B><P>\n  * Override these methods if your map doesn't support certain operations:\n  *\n  * <UL>\n- * <LI> {@link #useDuplicateValues}\n- * <LI> {@link #useNullKey}\n- * <LI> {@link #useNullValue}\n- * <LI> {@link #isAddRemoveModifiable}\n- * <LI> {@link #isChangeable}\n+ * <LI> {@link #useDuplicateValues()}\n+ * <LI> {@link #useNullKey()}\n+ * <LI> {@link #useNullValue()}\n+ * <LI> {@link #isAddRemoveModifiable()}\n+ * <LI> {@link #isChangeable()}\n  * </UL>\n  *\n  * <B>Fixture Methods</B><P>\n  * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n  * that map's collection views.  And the {@link #confirmed} field holds\n  * an instance of the confirmed collection implementation.  The \n- * {@link #resetEmpty} and {@link #resetFull} methods set these fields to \n+ * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to \n  * empty or full maps, so that tests can proceed from a known state.<P>\n  *\n- * After a modification operation to both {@link #map} and \n- * {@link #confirmed}, the {@link #verify} method is invoked to compare the\n- * results.  You may want to override {@link #verify} to perform additional\n- * verifications.  For instance, {@link TestDoubleOrderedMap} would want \n- * override its {@link #verify} method to verify that the values are unique\n- * and in ascending order.<P>\n+ * After a modification operation to both {@link #map} and {@link #confirmed},\n+ * the {@link #verify()} method is invoked to compare the results.  The {@link\n+ * verify()} method calls separate methods to verify the map and its three\n+ * collection views ({@link verifyMap(), {@link verifyEntrySet()}, {@link\n+ * verifyKeySet()}, and {@link verifyValues()}).  You may want to override one\n+ * of the verification methodsto perform additional verifications.  For\n+ * instance, {@link TestDoubleOrderedMap} would want override its {@link\n+ * #verifyValues()} method to verify that the values are unique and in\n+ * ascending order.<P>\n  *  \n  * <B>Other Notes</B><P>\n  *\n  * @author Michael Smith\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n- * @version $Id: TestMap.java,v 1.17 2002/06/18 03:17:34 mas Exp $\n+ * @version $Id: TestMap.java,v 1.18 2002/06/18 03:28:35 mas Exp $\n  */\n public abstract class TestMap extends TestObject {\n \n     protected Collection values;\n \n     /** HashMap created by reset(). */\n-    protected HashMap confirmed;\n+    protected Map confirmed;\n \n \n     public TestMap(String testName) {\n      *  Tests Map.isEmpty()\n      **/\n     public void testMapIsEmpty() {\n-        Map em = makeEmptyMap();\n+        resetEmpty();\n         assertEquals(\"Map.isEmpty() should return true with an empty map\", \n-                     true, em.isEmpty());\n-\n-        Map fm = makeFullMap();\n+                     true, map.isEmpty());\n+        verify();\n+\n+        resetFull();\n         assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n-                     false, fm.isEmpty());\n+                     false, map.isEmpty());\n+        verify();\n     }\n \n     /**\n      *  Tests Map.size()\n      **/\n     public void testMapSize() {\n-        Map em = makeEmptyMap();\n+        resetEmpty();\n         assertEquals(\"Map.size() should be 0 with an empty map\",\n-                     0, em.size());\n-\n-        Map fm = makeFullMap();\n-        assertEquals(\"Map.size() should equal the number of entries in the map\",\n-                     getSampleKeys().length, fm.size());\n+                     0, map.size());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.size() should equal the number of entries \" +\n+                     \"in the map\", getSampleKeys().length, map.size());\n+        verify();\n     }\n \n     /**\n      *  Map#isEmpty()} are used to ensure that map has no elements after a call\n      *  to clear.  If the map does not support adding and removing elements,\n      *  this method checks to ensure clear throws an\n-     *  UnsupportedOperationException.  This method checks that the both maps\n-     *  returned by makeEmptyMap and makeFullMap have correct behavior.\n+     *  UnsupportedOperationException.\n      **/\n     public void testMapClear() {\n         if (!isAddRemoveModifiable()) return;\n \n     /**\n      *  Tests Map.containsKey(Object) by verifying it returns false for all\n-     *  sample keys on a map created using makeEmptyMap() and returns true for\n-     *  all sample keys returned on a map created using makeFullMap()\n+     *  sample keys on a map created using an empty map and returns true for\n+     *  all sample keys returned on a full map. \n      **/\n     public void testMapContainsKey() {\n         Object[] keys = getSampleKeys();\n \n-        Map em = makeEmptyMap();\n-\n+        resetEmpty();\n         for(int i = 0; i < keys.length; i++) {\n             assertTrue(\"Map must not contain key when map is empty\", \n-                       !em.containsKey(keys[i]));\n-        }\n-\n-        Map fm = makeFullMap();\n-\n+                       !map.containsKey(keys[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n         for(int i = 0; i < keys.length; i++) {\n             assertTrue(\"Map must contain key for a mapping in the map. \" +\n-\t\t       \"Missing: \" + keys[i], fm.containsKey(keys[i]));\n-        }\n+\t\t       \"Missing: \" + keys[i], map.containsKey(keys[i]));\n+        }\n+        verify();\n     }\n \n     /**\n      *  Tests Map.containsValue(Object) by verifying it returns false for all\n-     *  sample alues on a map created using makeEmptyMap() and returns true for\n-     *  all sample values returned on a map created using makeFullMap.\n+     *  sample values on an empty map and returns true for all sample values on\n+     *  a full map.\n      **/\n     public void testMapContainsValue() {\n         Object[] values = getSampleValues();\n \n-        Map em = makeEmptyMap();\n-\n+        resetEmpty();\n         for(int i = 0; i < values.length; i++) {\n             assertTrue(\"Empty map must not contain value\", \n-                       !em.containsValue(values[i]));\n-        }\n-\n-        Map fm = makeFullMap();\n-\n+                       !map.containsValue(values[i]));\n+        }\n+        verify();\n+        \n+        resetFull();\n         for(int i = 0; i < values.length; i++) {\n             assertTrue(\"Map must contain value for a mapping in the map.\", \n-                       fm.containsValue(values[i]));\n-        }\n+                       map.containsValue(values[i]));\n+        }\n+        verify();\n     }\n \n \n      *  Tests Map.equals(Object)\n      **/\n     public void testMapEquals() {\n-        Map m = makeEmptyMap();\n-        assertTrue(\"Empty maps unequal.\", m.equals(new HashMap()));\n-\n-        m = makeFullMap();\n-        Map m2 = new HashMap();\n-        m2.putAll(m);\n-        assertTrue(\"Full maps unequal.\", m.equals(m2));\n-\n+        resetEmpty();\n+        assertTrue(\"Empty maps unequal.\", map.equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full maps unequal.\", map.equals(confirmed));\n+        verify();\n+\n+        resetFull();\n \t// modify the HashMap created from the full map and make sure this\n \t// change results in map.equals() to return false.\n-        Iterator iter = m2.keySet().iterator();\n+        Iterator iter = confirmed.keySet().iterator();\n         iter.next();\n         iter.remove();\n-        assertTrue(\"Different maps equal.\", !m.equals(m2));\n-\n-        assertTrue(\"equals(null) returned true.\", !m.equals(null));\n+        assertTrue(\"Different maps equal.\", !map.equals(confirmed));\n+        \n+        resetFull();\n+        assertTrue(\"equals(null) returned true.\", !map.equals(null));\n         assertTrue(\"equals(new Object()) returned true.\", \n-\t\t   !m.equals(new Object()));\n+\t\t   !map.equals(new Object()));\n+        verify();\n     }\n \n \n      *  Tests Map.get(Object)\n      **/\n     public void testMapGet() {\n-        Map m = makeEmptyMap();\n+        resetEmpty();\n \n         Object[] keys = getSampleKeys();\n         Object[] values = getSampleValues();\n \n         for (int i = 0; i < keys.length; i++) {\n             assertTrue(\"Empty map.get() should return null.\", \n-\t\t       m.get(keys[i]) == null);\n-        }\n-\n-        m = makeFullMap();\n+\t\t       map.get(keys[i]) == null);\n+        }\n+        verify();\n+\n+        resetFull();\n         for (int i = 0; i < keys.length; i++) {\n \t    assertEquals(\"Full map.get() should return value from mapping.\", \n-\t\t\t values[i], m.get(keys[i]));\n+\t\t\t values[i], map.get(keys[i]));\n         }\n     }\n \n      *  Tests Map.hashCode()\n      **/\n     public void testMapHashCode() {\n-        Map m = makeEmptyMap();\n-\tMap m2 = new HashMap();\n+        resetEmpty();\n         assertTrue(\"Empty maps have different hashCodes.\", \n-\t\t   m.hashCode() == m2.hashCode());\n-\n-        m = makeFullMap();\n-        m2.putAll(m);\n+\t\t   map.hashCode() == confirmed.hashCode());\n+\n+        resetFull();\n         assertTrue(\"Equal maps have different hashCodes.\", \n-\t\t   m.hashCode() == m2.hashCode());\n+\t\t   map.hashCode() == confirmed.hashCode());\n     }\n \n     /**\n      *  not return null.\n      **/\n     public void testMapToString() {\n-        Map m = makeEmptyMap();\n-        String s = m.toString();\n-        assertTrue(\"Empty map toString() should not return null\", s != null);\n-    }\n-\n-\n-    public void testMapSupportsNullValues() {\n-\n-        if ((this instanceof TestMap.SupportsPut) == false) {\n-            return;\n-        }\n-\n-        Map map = makeEmptyMap();\n-        map.put(new Integer(1),\"foo\");\n-        \n-        assertTrue(\"no null values in Map\",map.containsValue(null) == false);\n-\n-        map.put(new Integer(2),null);\n-\n-        assertTrue(\"null value in Map\",map.containsValue(null));\n-        assertTrue(\"key to a null value\",map.containsKey(new Integer(2)));\n-    }\n-\n-    public void testMultiplePuts() {\n-\n-        if ((this instanceof TestMap.SupportsPut) == false) {\n-            return;\n-        }\n-\n-        Map map = makeEmptyMap();\n-        map.put(new Integer(4),\"foo\");\n-        map.put(new Integer(4),\"bar\");\n-        map.put(new Integer(4),\"foo\");\n-        map.put(new Integer(4),\"bar\");\n-\n-        assertTrue(\"same key different value\",map.get(new Integer(4)).equals(\"bar\"));\n-    }\n-\n-\n-    public void testCapacity() {\n-\n-        if ((this instanceof TestMap.SupportsPut) == false) {\n-            return;\n-        }\n-\n-        Map map = makeEmptyMap();\n-        map.put(new Integer(1),\"foo\");\n-        map.put(new Integer(2),\"foo\");\n-        map.put(new Integer(3),\"foo\");\n-        map.put(new Integer(1),\"foo\");\n-        \n-        assertTrue(\"size of Map should be 3, but was \" + map.size(), map.size() == 3);\n-    }\n-\n-\n-    public void testEmptyMapSerialization() \n-    throws IOException, ClassNotFoundException {\n-        Map map = makeEmptyMap();\n-        if (!(map instanceof Serializable)) return;\n-        \n-        byte[] objekt = writeExternalFormToBytes((Serializable) map);\n-        Map map2 = (Map) readExternalFormFromBytes(objekt);\n-\n-        assertTrue(\"Both maps are empty\",map.isEmpty()  == true);\n-        assertTrue(\"Both maps are empty\",map2.isEmpty() == true);\n-    }\n-\n-    public void testFullMapSerialization() \n-    throws IOException, ClassNotFoundException {\n-        Map map = makeFullMap();\n-        if (!(map instanceof Serializable)) return;\n-        \n-        byte[] objekt = writeExternalFormToBytes((Serializable) map);\n-        Map map2 = (Map) readExternalFormFromBytes(objekt);\n-\n-        assertEquals(\"Both maps are same size\",map.size(), getSampleKeys().length);\n-        assertEquals(\"Both maps are same size\",map2.size(),getSampleKeys().length);\n-    }\n+        resetEmpty();\n+        assertTrue(\"Empty map toString() should not return null\", \n+                   map.toString() != null);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Empty map toString() should not return null\", \n+                   map.toString() != null);\n+        verify();\n+    }\n+\n \n     /**\n      * Compare the current serialized form of the Map\n     public void testMapRemove() {\n         if (!isAddRemoveModifiable()) return;\n \n-        Map m = makeEmptyMap();\n+        resetEmpty();\n+\n \tObject[] keys = getSampleKeys();\n \tObject[] values = getSampleValues();\n \tfor(int i = 0; i < keys.length; i++) {\n-\t    Object o = m.remove(keys[i]);\n+\t    Object o = map.remove(keys[i]);\n \t    assertTrue(\"First map.remove should return null\", o == null);\n \t}\n+        verify();\n \n         resetFull();\n \n \t}\n \n         Object[] other = getOtherKeys();\n-        m = makeFullMap();\n-        int size = m.size();\n+\n+        resetFull();\n+        int size = map.size();\n         for (int i = 0; i < other.length; i++) {\n-            Object o = m.remove(other[i]);\n+            Object o = map.remove(other[i]);\n             assertEquals(\"map.remove for nonexistent key should return null\",\n                          o, null);\n             assertEquals(\"map.remove for nonexistent key should not \" +\n-                         \"shrink map\", size, m.size());\n-        }\n-    }\n-\n-\n-    /**\n-     * Marker interface, indicating that a TestMap subclass\n-     * can test put(Object,Object) operations.\n-     */\n-    public interface SupportsPut {\n-\n+                         \"shrink map\", size, map.size());\n+        }\n+        verify();\n     }\n \n \n \n \n     /**\n-     *  Bulk test {@link Map#entrySet}.  This method runs through all of\n+     *  Bulk test {@link Map#entrySet()}.  This method runs through all of\n      *  the tests in {@link TestSet}.  \n-     *  After modification operations, {@link #verify} is invoked to ensure\n+     *  After modification operations, {@link #verify()} is invoked to ensure\n      *  that the map and the other collection views are still valid.\n      *\n      *  @return a {@link TestSet} instance for testing the map's entry set\n             return makeFullMap().entrySet();\n         }\n         \n-        protected boolean supportsAdd() {\n+        protected boolean isAddSupported() {\n             // Collection views don't support add operations.\n             return false;\n         }\n         \n-        protected boolean supportsRemove() {\n+        protected boolean isRemoveSupported() {\n             // Entry set should only support remove if map does\n             return isAddRemoveModifiable();\n         }\n         protected void resetFull() {\n             TestMap.this.resetFull();\n             collection = map.entrySet();\n-            TestMapEntrySet.this.confirmed = \n-                TestMap.this.confirmed.entrySet();\n+            TestMapEntrySet.this.confirmed = TestMap.this.confirmed.entrySet();\n         }\n         \n         protected void resetEmpty() {\n             TestMap.this.resetEmpty();\n             collection = map.entrySet();\n-            TestMapEntrySet.this.confirmed = \n-                TestMap.this.confirmed.entrySet();\n+            TestMapEntrySet.this.confirmed = TestMap.this.confirmed.entrySet();\n         }\n         \n         protected void verify() {\n \n \n     /**\n-     *  Bulk test {@link Map#keySet}.  This method runs through all of\n+     *  Bulk test {@link Map#keySet()}.  This method runs through all of\n      *  the tests in {@link TestSet}.  \n-     *  After modification operations, {@link #verify} is invoked to ensure\n+     *  After modification operations, {@link #verify()} is invoked to ensure\n      *  that the map and the other collection views are still valid.\n      *\n      *  @return a {@link TestSet} instance for testing the map's key set\n             return makeFullMap().keySet();\n         }\n         \n-        protected boolean supportsAdd() {\n+        protected boolean isAddSupported() {\n             return false;\n         }\n         \n-        protected boolean supportsRemove() {\n+        protected boolean isRemoveSupported() {\n             return isAddRemoveModifiable();\n         }\n         \n \n \n     /**\n-     *  Bulk test {@link Map#values}.  This method runs through all of\n+     *  Bulk test {@link Map#values()}.  This method runs through all of\n      *  the tests in {@link TestCollection}.  \n-     *  After modification operations, {@link #verify} is invoked to ensure\n+     *  After modification operations, {@link #verify()} is invoked to ensure\n      *  that the map and the other collection views are still valid.\n      *\n      *  @return a {@link TestCollection} instance for testing the map's \n             return makeFullMap().values();\n         }\n         \n-        protected boolean supportsAdd() {\n+        protected boolean isAddSupported() {\n             return false;\n         }\n         \n-        protected boolean supportsRemove() {\n+        protected boolean isRemoveSupported() {\n             return isAddRemoveModifiable();\n         }\n-        \n+\n+        protected boolean areEqualElementsDistinguishable() {\n+            // equal values are associated with different keys, so they are\n+            // distinguishable.  \n+            return true;\n+        }\n+\n         protected Collection makeConfirmedCollection() {\n             // never gets called, reset methods are overridden\n             return null;\n             collection = map.values();\n             TestMapValues.this.confirmed = TestMap.this.confirmed.values();\n         }\n-        \n+\n         protected void verify() {\n             super.verify();\n             TestMap.this.verify();\n         }\n+\n+        // TODO: should test that a remove on the values collection view\n+        // removes the proper mapping and not just any mapping that may have\n+        // the value equal to the value returned from the values iterator.\n     }\n \n \n      *  collection views.\n      */\n     protected void verify() {\n+        verifyMap();\n+        verifyEntrySet();\n+        verifyKeySet();\n+        verifyValues();\n+    }\n+\n+    protected void verifyMap() {\n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"Map should be same size as HashMap\", \n+                     size, map.size());\n+        assertEquals(\"Map should be empty if HashMap is\", \n+                     empty, map.isEmpty());\n+        assertEquals(\"hashCodes should be the same\",\n+                     confirmed.hashCode(), map.hashCode());\n+        // this fails for LRUMap because confirmed.equals() somehow modifies\n+        // map, causing concurrent modification exceptions.\n+        //assertEquals(\"Map should still equal HashMap\", confirmed, map);\n+        // this works though and performs the same verification:\n+        assertTrue(\"Map should still equal HashMap\", map.equals(confirmed));\n+        // TODO: this should really be rexamined to figure out why LRU map\n+        // behaves like it does (the equals shouldn't modify since all accesses\n+        // by the confirmed collection should be through an iterator, thus not\n+        // causing LRUMap to change).\n+    }\n+\n+    protected void verifyEntrySet() {\n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"entrySet should be same size as HashMap's\",\n+                     size, entrySet.size());\n+        assertEquals(\"entrySet should be empty if HashMap is\", \n+                     empty, entrySet.isEmpty());\n+        assertTrue(\"entrySet should contain all HashMap's elements\",\n+                   entrySet.containsAll(confirmed.entrySet()));\n+        assertEquals(\"entrySet hashCodes should be the same\", \n+                     confirmed.entrySet().hashCode(), entrySet.hashCode());\n+        assertEquals(\"Map's entry set should still equal HashMap's\", \n+                     confirmed.entrySet(), entrySet);\n+    }\n+\n+    protected void verifyKeySet() { \n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"keySet should be same size as HashMap's\",\n+                     size, keySet.size());\n+        assertEquals(\"keySet should be empty if HashMap is\", \n+                     empty, keySet.isEmpty());\n+        assertTrue(\"keySet should contain all HashMap's elements\",\n+                   keySet.containsAll(confirmed.keySet()));\n+        assertEquals(\"keySet hashCodes should be the same\", \n+                     confirmed.keySet().hashCode(), keySet.hashCode());\n+        assertEquals(\"Map's key set should still equal HashMap's\",\n+                     confirmed.keySet(), keySet);\n+    }\n+\n+    protected void verifyValues() {\n         Bag bag1 = new HashBag(confirmed.values());\n         Bag bag2 = new HashBag(values);\n \n-        assertEquals(\"Map should still equal HashMap\", confirmed, map);\n-        assertEquals(\"Map's entry set should still equal HashMap's\", \n-                     confirmed.entrySet(), entrySet);\n-        assertEquals(\"Map's key set should still equal HashMap's\",\n-                     confirmed.keySet(), keySet);\n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"values should be same size as HashMap's\",\n+                     size, values.size());\n+        assertEquals(\"values should be empty if HashMap is\", \n+                     empty, values.isEmpty());\n+        assertTrue(\"values should contain all HashMap's elements\",\n+                   values.containsAll(confirmed.values()));\n         assertEquals(\"Map's values should still equal HashMap's\",\n                      bag1, bag2);\n-        \n-        int size = confirmed.size();\n-        assertEquals(\"Map should be same size as HashMap\", \n-                     size, map.size());\n-        assertEquals(\"keySet should be same size as HashMap's\",\n-                     size, keySet.size());\n-        assertEquals(\"entrySet should be same size as HashMap's\",\n-                     size, entrySet.size());\n-        assertEquals(\"values should be same size as HashMap's\",\n-                     size, values.size());\n-        \n-        boolean empty = confirmed.isEmpty();\n-        assertEquals(\"Map should be empty if HashMap is\", \n-                     empty, map.isEmpty());\n-        assertEquals(\"keySet should be empty if HashMap is\", \n-                     empty, keySet.isEmpty());\n-        assertEquals(\"entrySet should be empty if HashMap is\", \n-                     empty, entrySet.isEmpty());\n-        assertEquals(\"values should be empty if HashMap is\", \n-                     empty, values.isEmpty());\n-        \n-        assertTrue(\"entrySet should contain all HashMap's elements\",\n-                   entrySet.containsAll(confirmed.entrySet()));\n-        assertTrue(\"keySet should contain all HashMap's elements\",\n-                   keySet.containsAll(confirmed.keySet()));\n-        assertTrue(\"values should contain all HashMap's elements\",\n-                   values.containsAll(confirmed.values()));\n-        \n-        assertEquals(\"hashCodes should be the same\",\n-                     confirmed.hashCode(), map.hashCode());\n-        assertEquals(\"entrySet hashCodes should be the same\", \n-                     confirmed.entrySet().hashCode(), entrySet.hashCode());\n-        assertEquals(\"keySet hashCodes should be the same\", \n-                     confirmed.keySet().hashCode(), keySet.hashCode());\n-        assertEquals(\"values hashCodes should be the same\", \n-                     bag1.hashCode(), bag2.hashCode());\n     }\n \n \n--- a/src/test/org/apache/commons/collections/TestMultiHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestMultiHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.4 2002/05/28 06:51:03 mas Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/05/28 06:51:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.5 2002/06/18 03:28:35 mas Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/06/18 03:28:35 $\n  *\n  * ====================================================================\n  *\n         return;\n     }\n \n-    // Next four are overriden \n-    // because MultiHashMap values are always a collection\n+    // Next methods are overriden because MultiHashMap values are always a\n+    // collection, and deviate from the Map contract because of this.\n \n     // TODO: implement the tests to ensure that Map.get(Object) returns the\n     // appropriate collection of values\n     public void testMapRemove() {\n     }\n \n-    public void testMapValues() {\n-    }\n-\n+    public void testMapEquals() {\n+    }\n+\n+    public void testMapHashCode() {\n+    }\n+\n+    // The verification for the map and its entry set must also be overridden\n+    // because the values are not going to be the same as the values in the\n+    // confirmed map (they're going to be collections of values instead).\n+    public void verifyMap() {\n+        // TODO: implement test to ensure that map is the same as confirmed if\n+        // its values were converted into collections.\n+    }\n+\n+    public void verifyEntrySet() {\n+        // TODO: implement test to ensure that each entry is the same as one in\n+        // the confirmed map, but with the value wrapped in a collection.\n+    }\n+\n+    // The verification method must be overridden because MultiHashMap's\n+    // values() is not properly backed by the map (Bug 9573).\n+\n+    public void verifyValues() {\n+        // update the values view to the latest version, then proceed to verify\n+        // as usual.  \n+        values = map.values();\n+        super.verifyValues();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  */\n-public class TestSequencedHashMap extends TestMap \n-implements TestMap.SupportsPut\n-{\n+public class TestSequencedHashMap extends TestMap {\n     /**\n      * The instance to experiment on.\n      */", "timestamp": 1024370915, "metainfo": ""}