{"sha": "43a7d2aa27dffe30d46d69544e9377d4068db90a", "log": "Javadoc fixes  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/main/java/org/apache/commons/collections/BufferUtils.java\n      * Get an empty <code>Buffer</code>.\n      *\n      * @param <E> the type of the elements in the buffer\n-     * @return an empty {@link Buffer<E>}\n+     * @return an empty {@link Buffer}\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Buffer<E> emptyBuffer() {\n--- a/src/main/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LRUMap.java\n  * of modifying the map's iteration order and thus invalidating any\n  * iterators currently in use.  It is therefore suggested that iterations\n  * over an {@link LRUMap} instance access entry values only through a\n- * {@link MapIterator} or {@link #entrySet()} iterator.\n+ * {@link org.apache.commons.collections.MapIterator MapIterator} or {@link #entrySet()} iterator.\n  * <p>\n  * The map implements <code>OrderedMap</code> and entries may be queried using\n  * the bidirectional <code>OrderedMapIterator</code>. The order returned is\n--- a/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java\n      *\n      * @param index the position of the element in the ordered {@link Set}.\n      * @return the element at position {@code index}\n-     * @see {@link List#get(int)}\n+     * @see List#get(int)\n      */\n     public E get(int index) {\n         return setOrder.get(index);\n      * @param object the element to search for\n      * @return the index of the first occurrence of the object, or {@code -1} if this\n      * ordered set does not contain this object\n-     * @see {@link List#indexOf(Object)}\n+     * @see List#indexOf(Object)\n      */\n     public int indexOf(Object object) {\n         return setOrder.indexOf(object);\n      *\n      * @param index the index at which the element is to be inserted\n      * @param object the element to be inserted\n-     * @see {@link List#add(int, Object)}\n+     * @see List#add(int, Object)\n      */\n     public void add(int index, E object) {\n         if (!contains(object)) {\n      * @param index the position to insert the elements\n      * @param coll the collection containing the elements to be inserted\n      * @return {@code true} if this ordered set changed as a result of the call\n-     * @see {@link List#addAll(int, Collection)}\n+     * @see List#addAll(int, Collection)\n      */\n     public boolean addAll(int index, Collection<? extends E> coll) {\n         boolean changed = false;\n      * \n      * @param index the index of the element to be removed\n      * @return the element that has been remove from the ordered set\n-     * @see {@link List#remove(int)}\n+     * @see List#remove(int)\n      */\n     public Object remove(int index) {\n         Object obj = setOrder.remove(index);", "timestamp": 1340500971, "metainfo": ""}