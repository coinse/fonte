{"sha": "bccc0cbfa2ef33051372184a0e3e92aea59224a9", "log": "Added Stephen's new PredicateUtils submission. Looks good; just need some unit test cases ;-)   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/PredicateUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PredicateUtils.java,v 1.1 2002/05/02 06:17:19 jstrachan Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/05/02 06:17:19 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Serializable;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.Map;\n+import java.util.SortedMap;\n+/**\n+ * PredicateUtils provides access to common predicate functionality.\n+ * <p>\n+ * Included are collections wrapper that support validation.\n+ * Only elements that pass a predicate (validation test) can \n+ * be added to the collection. An <tt>IllegalArgumentException</tt> is\n+ * thrown if the validation fails.\n+ * <p>\n+ * The collections can be accessed by static factory methods. A wrapper\n+ * is provided for all the java and commons collections.\n+ * <p>\n+ * Also included are predicate implementations for True, False, Not,\n+ * And, Or and instanceof.\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class PredicateUtils {\n+    \n+\t/**\n+\t * A predicate that always returns true\n+\t */    \n+    public static final Predicate TRUE_PREDICATE = new TruePredicate();\n+\t/**\n+\t * A predicate that always returns false\n+\t */    \n+    public static final Predicate FALSE_PREDICATE = new FalsePredicate();\n+    \n+\t/**\n+\t * Restructive constructor\n+\t */\n+\tprivate PredicateUtils() {\n+\t    super();\n+\t}\n+\n+\t/**\n+\t * Create a new Collection that wraps another Collection and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original collection is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param coll  the collection to wrap and restrict\n+\t * @param predicate  the predicate to control what to allow into the collection\n+\t */\n+\tpublic static Collection predicateCollection(Collection coll, Predicate predicate) {\n+         return new PredicateCollection(coll, predicate);\n+    }\n+\n+\t/**\n+\t * Create a new List that wraps another List and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original list is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param list  the list to wrap and restrict\n+\t * @param predicate  the predicate to control what to allow into the list\n+\t */\n+\tpublic static List predicateList(List list, Predicate predicate) {\n+         return new PredicateList(list, predicate);\n+    }\n+\n+\t/**\n+\t * Create a new Set that wraps another Set and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original set is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param set  the set to wrap and restrict\n+\t * @param predicate  the predicate to control what to allow into the set\n+\t */\n+\tpublic static Set predicateSet(Set set, Predicate predicate) {\n+         return new PredicateSet(set, predicate);\n+    }\n+\n+\t/**\n+\t * Create a new SortedSet that wraps another SortedSet and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original set is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param set  the set to wrap and restrict\n+\t * @param predicate  the predicate to control what to allow into the set\n+\t */\n+\tpublic static SortedSet predicateSortedSet(SortedSet set, Predicate predicate) {\n+         return new PredicateSortedSet(set, predicate);\n+    }\n+\n+\t/**\n+\t * Create a new Bag that wraps another Bag and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original bag is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param bag  the bag to wrap and restrict\n+\t * @param predicate  the predicate to control what to allow into the bag\n+\t */\n+\tpublic static Bag predicateBag(Bag bag, Predicate predicate) {\n+         return new PredicateBag(bag, predicate);\n+    }\n+\n+\t/**\n+\t * Create a new SortedBag that wraps another SortedBag and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original bag is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param bag  the bag to wrap and restrict\n+\t * @param predicate  the predicate to control what to allow into the bag\n+\t */\n+\tpublic static SortedBag predicateSortedBag(SortedBag bag, Predicate predicate) {\n+         return new PredicateSortedBag(bag, predicate);\n+    }\n+\n+\t/**\n+\t * Create a new Map that wraps another Map and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original map is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param map  the map to wrap and restrict\n+\t * @param keyPredicate  the predicate to control what to allow into the bag\n+\t * @param valuePredicate  the predicate to control what to allow into the bag\n+\t */\n+\tpublic static Map predicateMap(Map map, Predicate keyPredicate, Predicate valuePredicate) {\n+         return new PredicateMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+\t/**\n+\t * Create a new SortedMap that wraps another SortedMap and validates\n+\t * entries. Only objects that pass the test in the predicate can be\n+\t * added to the list.\n+\t * It is important that the original map is not used again after\n+\t * this call, as it is a backdoor to add non-validated objects.\n+\t * @param map  the map to wrap and restrict\n+\t * @param keyPredicate  the predicate to control what to allow into the bag\n+\t * @param valuePredicate  the predicate to control what to allow into the bag\n+\t */\n+\tpublic static SortedMap predicateSortedMap(SortedMap map, Predicate keyPredicate, Predicate valuePredicate) {\n+         return new PredicateSortedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+\t/**\n+\t * Create a new predicate that returns true only if both of the passed\n+\t * in predicates are true.\n+\t * @param predicate1  the first predicate\n+\t * @param predicate2  the second predicate\n+\t */\n+\tpublic static Predicate andPredicate(Predicate predicate1, Predicate predicate2) {\n+         return new AndPredicate(predicate1, predicate2);\n+    }\n+\n+\t/**\n+\t * Create a new predicate that returns true if either of the passed\n+\t * in predicates are true.\n+\t * @param predicate1  the first predicate\n+\t * @param predicate2  the second predicate\n+\t */\n+\tpublic static Predicate orPredicate(Predicate predicate1, Predicate predicate2) {\n+         return new OrPredicate(predicate1, predicate2);\n+    }\n+\n+\t/**\n+\t * Create a new predicate that returns true if the passed in predicate\n+\t * returns false and vice versa.\n+\t * @param predicate  the predicate to not\n+\t */\n+\tpublic static Predicate notPredicate(Predicate predicate) {\n+         return new NotPredicate(predicate);\n+    }\n+\n+\t/**\n+\t * Create a new predicate that checks if the object passed in is of\n+\t * a particular type.\n+\t * @param type  the type to check for\n+\t */\n+\tpublic static Predicate instanceofPredicate(Class type) {\n+         return new InstanceofPredicate(type);\n+    }\n+\n+\t/**\n+\t * Perform the validation against the predicate.\n+\t * @param object  object to be validated\n+\t */\t\n+\tprivate static void validate(Predicate predicate, Object object) {\n+\t    if (predicate.evaluate(object) == false) {\n+\t        throw new IllegalArgumentException(\"Predicate validation: \" +\n+\t        \tobject + \" cannot be added to the list\");\n+\t    }\n+\t}\n+\n+\t/**\n+\t * PredicateCollection validates a Collection\n+\t */\n+\tprivate static class PredicateCollection \n+\t\t\timplements Collection, Serializable {\n+\t\t\t    \n+        /** The predicate to control entry into the collection */\n+        protected final Predicate iPredicate;\n+        /** The collection being wrapped */\n+        protected final Collection iCollection;\n+\t\t\t    \n+    \t/**\n+    \t * Create a new PredicateCollection that wraps another collection.\n+    \t * It is important that the original collection is not used again\n+    \t * after this call, as it is a backdoor to add non-validated objects.\n+    \t * @param coll  the collection to wrap and restrict\n+    \t * @param predicate  the predicate used to validate entry into the list\n+    \t */\n+    \tpublic PredicateCollection(Collection coll, Predicate predicate) {\n+    \t    super();\n+    \t    if (coll == null) {\n+    \t        throw new IllegalArgumentException(\"Collection to be wrapped must not be null\");\n+    \t    }\n+    \t    if (predicate == null) {\n+    \t        throw new IllegalArgumentException(\"Predicate must not be null\");\n+    \t    }\n+    \t    iPredicate = predicate;\n+    \t    iCollection = coll;\n+            Iterator it = iCollection.iterator();\n+            while (it.hasNext()) {\n+                validate(iPredicate, it.next());\n+            }\n+    \t}\n+    \n+        /**\n+         * Add an item to the end of the list. If the item is not an instance\n+         * of the list's validation type an exception is thrown. The state of\n+         * the list will be unaltered if an exception is thrown.\n+         * @see Collection#add(Object)\n+         * @param item  the item to add\n+         * @throws IllegalArgumentException if the object is not of a valid type\n+         */\n+        public boolean add(Object item) {\n+            validate(iPredicate, item);\n+            return iCollection.add(item);\n+        }\n+    \n+        /**\n+         * Add a collection to the end of the list. If any of the items in the\n+         * collection is not an instance of the list's validation type an\n+         * exception is thrown. The state of the list will be unaltered if an\n+         * exception is thrown.\n+         * @see Collection#addAll(Collection)\n+         * @param coll  the collection to add\n+         * @throws IllegalArgumentException if the object is not of a valid type\n+         */\n+        public boolean addAll(Collection coll) {\n+            Iterator it = coll.iterator();\n+            while (it.hasNext()) {\n+    \t        validate(iPredicate, it.next());\n+            }\n+            return iCollection.addAll(coll);\n+        }\n+    \n+        /**\n+         * @see Collection#iterator()\n+         */\n+        public Iterator iterator() {\n+            return iCollection.iterator();\n+        }\n+\n+        /**\n+         * @see Collection#size()\n+         */\n+        public int size() {\n+            return iCollection.size();\n+        }\n+\n+        /**\n+         * @see Collection#clear()\n+         */\n+        public void clear() {\n+            iCollection.clear();\n+        }\n+\n+        /**\n+         * @see Collection#isEmpty()\n+         */\n+        public boolean isEmpty() {\n+            return iCollection.isEmpty();\n+        }\n+\n+        /**\n+         * @see Collection#contains(Object)\n+         */\n+        public boolean contains(Object item) {\n+            return iCollection.contains(item);\n+        }\n+\n+        /**\n+         * @see Collection#containsAll(Collection)\n+         */\n+        public boolean containsAll(Collection coll) {\n+            return iCollection.containsAll(coll);\n+        }\n+\n+        /**\n+         * @see Collection#remove(Object)\n+         */\n+        public boolean remove(Object item) {\n+            return iCollection.remove(item);\n+        }\n+\n+        /**\n+         * @see Collection#removeAll(Collection)\n+         */\n+        public boolean removeAll(Collection coll) {\n+            return iCollection.remove(coll);\n+        }\n+\n+        /**\n+         * @see Collection#retainAll(Collection)\n+         */\n+        public boolean retainAll(Collection coll) {\n+            return iCollection.retainAll(coll);\n+        }\n+\n+        /**\n+         * @see Collection#toArray()\n+         */\n+        public Object[] toArray() {\n+            return iCollection.toArray();\n+        }\n+\n+        /**\n+         * @see Collection#toArray(Object[])\n+         */\n+        public Object[] toArray(Object[] array) {\n+            return iCollection.toArray(array);\n+        }\n+\n+        /**\n+         * @see Object#equals(Object)\n+         */\n+        public boolean equals(Object obj) {\n+            return iCollection.equals(obj);\n+        }\n+    \n+        /**\n+         * @see Object#hashCode()\n+         */\n+        public int hashCode() {\n+            return iCollection.hashCode();\n+        }\n+    \n+        /**\n+         * @see Object#toString()\n+         */\n+        public String toString() {\n+            return iCollection.toString();\n+        }\n+\t}\n+\t\n+\t/**\n+\t * PredicateList validates a List\n+\t */\n+\tprivate static class PredicateList\n+\t\t\textends PredicateCollection\n+\t\t\timplements List {\n+\t\n+    \t/**\n+    \t * Create a new PredicateList that wraps another list.\n+    \t * It is important that the original list is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param list  the list to wrap and restrict\n+    \t * @param predicate  the predicate used to validate entry into the list\n+    \t */\n+    \tpublic PredicateList(List list, Predicate predicate) {\n+    \t    super(list, predicate);\n+    \t}\n+    \t\n+        /**\n+         * Add an item to the list at the specified index. If the item is\n+         * not an instance of the list's validation type an exception is\n+         * thrown. The state of the list will be unaltered if an exception \n+         * is thrown.\n+         * @see List#add(int, Object)\n+         * @param index  the index at which to add the item\n+         * @param item  the item to add\n+         * @throws IllegalArgumentException if the object is not of a valid type\n+         */\n+        public void add(int index, Object item) {\n+            validate(iPredicate, item);\n+            ((List) iCollection).add(index, item);\n+        }\n+    \n+        /**\n+         * Add a collection at the specified index. If any of the items in the\n+         * collection is not an instance of the list's validation type an\n+         * exception is thrown. The state of the list will be unaltered if an\n+         * exception is thrown.\n+         * @see List#addAll(int, Collection)\n+         * @param index  the index at which to add the collection\n+         * @param coll  the collection to add\n+         * @throws IllegalArgumentException if the object is not of a valid type\n+         */\n+        public boolean addAll(int index, Collection coll) {\n+            Iterator it = coll.iterator();\n+            while (it.hasNext()) {\n+    \t        validate(iPredicate, it.next());\n+            }\n+            return ((List) iCollection).addAll(index, coll);\n+        }\n+    \n+        /**\n+         * Set the value at the specified index. If the item is not an instance\n+         * of the list's validation type an exception is thrown. The state of\n+         * the list will be unaltered if an exception is thrown.\n+         * @see List#set(int, Object)\n+         * @param index  the index to change\n+         * @param item  the item to change to\n+         * @throws IllegalArgumentException if the object is not of a valid type\n+         */\n+        public Object set(int index, Object item) {\n+            validate(iPredicate, item);\n+            return ((List) iCollection).set(index, item);\n+        }\n+        \n+        /**\n+         * @see List#listIterator()\n+         */\n+        public ListIterator listIterator() {\n+            return new PredicateListIterator(((List) iCollection).listIterator(), iPredicate);\n+        }\n+    \n+        /**\n+         * @see List#listIterator(int)\n+         */\n+        public ListIterator listIterator(int index) {\n+            return new PredicateListIterator(((List) iCollection).listIterator(index), iPredicate);\n+        }\n+    \n+        /**\n+         * @see List#subList(int, int)\n+         */\n+        public List subList(int fromIndex, int toIndex) {\n+            return new PredicateList(((List) iCollection).subList(fromIndex, toIndex), iPredicate);\n+        }\n+\n+        /**\n+         * @see List#get(int)\n+         */\n+        public Object get(int index) {\n+            return ((List) iCollection).get(index);\n+        }\n+    \n+        /**\n+         * @see List#indexOf(Object)\n+         */\n+        public int indexOf(Object item) {\n+            return ((List) iCollection).indexOf(item);\n+        }\n+    \n+        /**\n+         * @see List#lastIndexOf(Object)\n+         */\n+        public int lastIndexOf(Object item) {\n+            return ((List) iCollection).lastIndexOf(item);\n+        }\n+    \n+        /**\n+         * @see List#remove(int)\n+         */\n+        public Object remove(int index) {\n+            return ((List) iCollection).remove(index);\n+        }\n+\t}\n+\n+\t/**\n+\t * PredicateListIterator handles the list iterator for PredicateList\n+\t */\n+\tprivate static class PredicateListIterator implements ListIterator {\n+\t    \n+\t    private final ListIterator iIterator;\n+\t    private final Predicate iPredicate;\n+\t    \n+\t    /**\n+\t     * Constructor\n+\t     */\n+\t    private PredicateListIterator(ListIterator iterator, Predicate predicate) {\n+\t        super();\n+\t        iIterator = iterator;\n+\t        iPredicate = predicate;\n+\t\t}\n+\t\t\n+        /**\n+         * @see Iterator#hasNext()\n+         */\n+        public boolean hasNext() {\n+            return iIterator.hasNext();\n+        }\n+\n+        /**\n+         * @see ListIterator#hasPrevious()\n+         */\n+        public boolean hasPrevious() {\n+            return iIterator.hasPrevious();\n+        }\n+\n+        /**\n+         * @see Iterator#next()\n+         */\n+        public Object next() {\n+            return iIterator.next();\n+        }\n+\n+        /**\n+         * @see ListIterator#nextIndex()\n+         */\n+        public int nextIndex() {\n+            return iIterator.nextIndex();\n+        }\n+\n+        /**\n+         * @see ListIterator#previous()\n+         */\n+        public Object previous() {\n+            return iIterator.previous();\n+        }\n+\n+        /**\n+         * @see ListIterator#previousIndex()\n+         */\n+        public int previousIndex() {\n+            return iIterator.previousIndex();\n+        }\n+\n+        /**\n+         * @see Iterator#remove()\n+         */\n+        public void remove() {\n+            iIterator.remove();\n+        }\n+\n+        /**\n+         * @see ListIterator#add(Object)\n+         */\n+        public void add(Object item) {\n+\t        validate(iPredicate, item);\n+            iIterator.add(item);\n+        }\n+\n+        /**\n+         * @see ListIterator#set(Object)\n+         */\n+        public void set(Object item) {\n+\t        validate(iPredicate, item);\n+            iIterator.set(item);\n+        }\n+\t}\n+\t\n+\t/**\n+\t * PredicateSet validates a Set\n+\t */\n+\tprivate static class PredicateSet\n+\t\t\textends PredicateCollection\n+\t\t\timplements Set {\n+\t\n+    \t/**\n+    \t * Create a new PredicateSet that wraps another Set.\n+    \t * It is important that the original set is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param set  the set to wrap and restrict\n+    \t * @param predicate  the predicate used to validate entry into the set\n+    \t */\n+    \tpublic PredicateSet(Set set, Predicate predicate) {\n+    \t    super(set, predicate);\n+    \t}\n+\t}\n+\t\n+\t/**\n+\t * PredicateSet validates a SortedSet\n+\t */\n+\tprivate static class PredicateSortedSet\n+\t\t\textends PredicateSet\n+\t\t\timplements SortedSet {\n+\t\n+    \t/**\n+    \t * Create a new PredicateSortedSet that wraps another SortedSet.\n+    \t * It is important that the original SortedSet is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param set  the set to wrap and restrict\n+    \t * @param predicate  the predicate used to validate entry into the SortedSet\n+    \t */\n+    \tpublic PredicateSortedSet(SortedSet set, Predicate predicate) {\n+    \t    super(set, predicate);\n+    \t}\n+    \t\n+        /**\n+         * @see SortedSet#headSet(Object)\n+         */\n+        public SortedSet headSet(Object toElement) {\n+            return new PredicateSortedSet(((SortedSet) iCollection).headSet(toElement), iPredicate);\n+        }\n+    \n+        /**\n+         * @see SortedSet#subSet(Object, Object)\n+         */\n+        public SortedSet subSet(Object fromElement, Object toElement) {\n+            return new PredicateSortedSet(((SortedSet) iCollection).subSet(fromElement, toElement), iPredicate);\n+        }\n+    \n+        /**\n+         * @see SortedSet#tailSet(Object)\n+         */\n+        public SortedSet tailSet(Object fromElement) {\n+            return new PredicateSortedSet(((SortedSet) iCollection).tailSet(fromElement), iPredicate);\n+        }\n+    \n+        /**\n+         * @see SortedSet#first()\n+         */\n+        public Object first() {\n+            return ((SortedSet) iCollection).first();\n+        }\n+    \n+        /**\n+         * @see SortedSet#last()\n+         */\n+        public Object last() {\n+            return ((SortedSet) iCollection).last();\n+        }\n+        \n+        /**\n+         * @see SortedSet#comparator()\n+         */\n+        public Comparator comparator() {\n+            return ((SortedSet) iCollection).comparator();\n+        }\n+\t}\n+\t\n+\t/**\n+\t * PredicateBag validates a Bag\n+\t */\n+\tprivate static class PredicateBag\n+\t\t\textends PredicateCollection\n+\t\t\timplements Bag {\n+\t\n+    \t/**\n+    \t * Create a new PredicateBag that wraps another Bag.\n+    \t * It is important that the original Bag is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param bag  the bag to wrap and restrict\n+    \t * @param predicate  the predicate used to validate entry into the Bag\n+    \t */\n+    \tpublic PredicateBag(Bag bag, Predicate predicate) {\n+    \t    super(bag, predicate);\n+    \t}\n+    \t\n+        /**\n+         * @see Bag#add(Object, int)\n+         */\n+        public boolean add(Object item, int i) {\n+            validate(iPredicate, item);\n+            return ((Bag) iCollection).add(item, i);\n+        }\n+\n+        /**\n+         * @see Bag#getCount(Object)\n+         */\n+        public int getCount(Object item) {\n+            return ((Bag) iCollection).getCount(item);\n+        }\n+\n+        /**\n+         * @see Bag#remove(Object, int)\n+         */\n+        public boolean remove(Object item, int i) {\n+            return ((Bag) iCollection).remove(item, i);\n+        }\n+\n+        /**\n+         * @see Bag#uniqueSet()\n+         */\n+        public Set uniqueSet() {\n+            return ((Bag) iCollection).uniqueSet();\n+        }\n+\t}\n+\t\n+\t/**\n+\t * PredicateSortedBag validates a SortedBag\n+\t */\n+\tprivate static class PredicateSortedBag\n+\t\t\textends PredicateBag\n+\t\t\timplements SortedBag {\n+\t\n+    \t/**\n+    \t * Create a new PredicateSortedBag that wraps another SortedBag.\n+    \t * It is important that the original SortedBag is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param bag  the bag to wrap and restrict\n+    \t * @param predicate  the predicate used to validate entry into the SortedBag\n+    \t */\n+    \tpublic PredicateSortedBag(SortedBag bag, Predicate predicate) {\n+    \t    super(bag, predicate);\n+    \t}\n+    \t\n+        /**\n+         * @see SortedBag#comparator()\n+         */\n+        public Comparator comparator() {\n+            return ((SortedBag) iCollection).comparator();\n+        }\n+\n+        /**\n+         * @see SortedBag#first()\n+         */\n+        public Object first() {\n+            return ((SortedBag) iCollection).first();\n+        }\n+\n+        /**\n+         * @see SortedBag#last()\n+         */\n+        public Object last() {\n+            return ((SortedBag) iCollection).last();\n+        }\n+\t}\n+\t\n+\t/**\n+\t * PredicateBag validates a Map\n+\t */\n+\tprivate static class PredicateMap\n+\t\t\timplements Map {\n+\t\n+        /** The predicate to control entry into the map */\n+        protected final Predicate iKeyPredicate;\n+        /** The predicate to control entry into the map */\n+        protected final Predicate iValuePredicate;\n+        /** The list being wrapped */\n+        protected final Map iMap;\n+\t\t\t    \n+    \t/**\n+    \t * Create a new PredicateMap that wraps another Map.\n+    \t * It is important that the original Map is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param map  the map to wrap and restrict\n+    \t * @param keyPredicate  the predicate used to validate entry into the SortedMap\n+    \t * @param valuePredicate  the predicate used to validate entry into the SortedMap\n+    \t */\n+    \tpublic PredicateMap(Map map, Predicate keyPredicate, Predicate valuePredicate) {\n+    \t    super();\n+    \t    if (map == null) {\n+    \t        throw new IllegalArgumentException(\"Collection to be wrapped must not be null\");\n+    \t    }\n+    \t    if (keyPredicate == null) {\n+    \t        throw new IllegalArgumentException(\"Key Predicate must not be null\");\n+    \t    }\n+    \t    if (valuePredicate == null) {\n+    \t        throw new IllegalArgumentException(\"Value Predicate must not be null\");\n+    \t    }\n+    \t    iKeyPredicate = keyPredicate;\n+    \t    iValuePredicate = valuePredicate;\n+    \t    iMap = map;\n+    \t    for (Iterator it = iMap.keySet().iterator(); it.hasNext();) {\n+                validate(iKeyPredicate, it.next());\n+            }\n+    \t    for (Iterator it = iMap.values().iterator(); it.hasNext();) {\n+                validate(iValuePredicate, it.next());\n+            }\n+    \t}\n+    \t\n+        /**\n+         * @see Map#put(Object, Object)\n+         */\n+        public Object put(Object key, Object value) {\n+            validate(iKeyPredicate, key);\n+            validate(iValuePredicate, value);\n+            return iMap.put(key, value);\n+        }\n+\n+        /**\n+         * @see Map#putAll(Map)\n+         */\n+        public void putAll(Map map) {\n+            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+\t            validate(iKeyPredicate, entry.getKey());\n+    \t        validate(iValuePredicate, entry.getValue());\n+            }\n+            iMap.putAll(map);\n+        }\n+\n+        /**\n+         * @see Map#entrySet()\n+         */\n+        public Set entrySet() {\n+            return new PredicateMapEntrySet(iMap.entrySet(), iValuePredicate);\n+        }\n+\n+        /**\n+         * @see Map#keySet()\n+         */\n+        public Set keySet() {\n+            return new PredicateSet(iMap.keySet(), iKeyPredicate);\n+        }\n+\n+        /**\n+         * @see Map#values()\n+         */\n+        public Collection values() {\n+            return new PredicateCollection(iMap.values(), iValuePredicate);\n+        }\n+\n+        /**\n+         * @see Map#get(Object)\n+         */\n+        public Object get(Object key) {\n+            return iMap.get(key);\n+        }\n+\n+        /**\n+         * @see Map#size()\n+         */\n+        public int size() {\n+            return iMap.size();\n+        }\n+\n+        /**\n+         * @see Map#clear()\n+         */\n+        public void clear() {\n+            iMap.clear();\n+        }\n+\n+        /**\n+         * @see Map#isEmpty()\n+         */\n+        public boolean isEmpty() {\n+            return iMap.isEmpty();\n+        }\n+\n+        /**\n+         * @see Map#containsKey(Object)\n+         */\n+        public boolean containsKey(Object key) {\n+            return iMap.containsKey(key);\n+        }\n+\n+        /**\n+         * @see Map#containsValue(Object)\n+         */\n+        public boolean containsValue(Object value) {\n+            return iMap.containsValue(value);\n+        }\n+\n+        /**\n+         * @see Map#remove(Object)\n+         */\n+        public Object remove(Object key) {\n+            return iMap.remove(key);\n+        }\n+\n+        /**\n+         * @see Object#equals(Object)\n+         */\n+        public boolean equals(Object obj) {\n+            return iMap.equals(obj);\n+        }\n+    \n+        /**\n+         * @see Object#hashCode()\n+         */\n+        public int hashCode() {\n+            return iMap.hashCode();\n+        }\n+    \n+        /**\n+         * @see Object#toString()\n+         */\n+        public String toString() {\n+            return iMap.toString();\n+        }\n+\t}   \n+\t\n+\t/**\n+\t * PredicateSortedBag validates a SortedMap\n+\t */\n+\tprivate static class PredicateSortedMap\n+\t\t\textends PredicateMap\n+\t\t\timplements SortedMap {\n+\t\n+    \t/**\n+    \t * Create a new PredicateSortedMap that wraps another SortedMap.\n+    \t * It is important that the original SortedBag is not used again after\n+    \t * this call, as it is a backdoor to add non-validated objects.\n+    \t * @param bag  the bag to wrap and restrict\n+    \t * @param keyPredicate  the predicate used to validate entry into the SortedMap\n+    \t * @param valuePredicate  the predicate used to validate entry into the SortedMap\n+    \t */\n+    \tpublic PredicateSortedMap(SortedMap map, Predicate keyPredicate, Predicate valuePredicate) {\n+    \t    super(map, keyPredicate, valuePredicate);\n+    \t}\n+    \t\n+        /**\n+         * @see SortedMap#comparator()\n+         */\n+        public Comparator comparator() {\n+            return ((SortedMap) iMap).comparator();\n+        }\n+\n+        /**\n+         * @see SortedMap#firstKey()\n+         */\n+        public Object firstKey() {\n+            return ((SortedMap) iMap).firstKey();\n+        }\n+\n+        /**\n+         * @see SortedMap#lastKey()\n+         */\n+        public Object lastKey() {\n+            return ((SortedMap) iMap).lastKey();\n+        }\n+\n+        /**\n+         * @see SortedMap#headMap(Object)\n+         */\n+        public SortedMap headMap(Object toKey) {\n+            return new PredicateSortedMap(\n+            \t((SortedMap) iMap).headMap(toKey), iKeyPredicate, iValuePredicate);\n+        }\n+\n+        /**\n+         * @see SortedMap#tailMap(Object)\n+         */\n+        public SortedMap tailMap(Object fromKey) {\n+            return new PredicateSortedMap(\n+            \t((SortedMap) iMap).tailMap(fromKey), iKeyPredicate, iValuePredicate);\n+        }\n+\n+        /**\n+         * @see SortedMap#subMap(Object, Object)\n+         */\n+        public SortedMap subMap(Object fromKey, Object toKey) {\n+            return new PredicateSortedMap(\n+            \t((SortedMap) iMap).subMap(fromKey, toKey), iKeyPredicate, iValuePredicate);\n+        }\n+\t}\n+\t\n+\t/**\n+\t * Map helper class to access iterator\n+\t */\n+\tpublic static class PredicateMapEntrySet\n+\t        extends AbstractSet {\n+\t    private final Set iSet;\n+        private final Predicate iValuePredicate;\n+\t    \n+\t    /**\n+\t     * Constructor\n+\t     */\n+\t    private PredicateMapEntrySet(Set set, Predicate predicate) {\n+\t        super();\n+\t        iSet = set;\n+\t        iValuePredicate = predicate;\n+\t    }\n+            \n+        /**\n+         * @see Collection#clear()\n+         */\n+        public void clear() {\n+            iSet.clear();\n+        }\n+\n+        /**\n+         * @see Collection#iterator()\n+         */\n+        public Iterator iterator() {\n+            return new PredicateMapEntrySetIterator(iSet.iterator(), iValuePredicate);\n+        }\n+\n+        /**\n+         * @see Collection#remove(Object)\n+         */\n+        public boolean remove(Object obj) {\n+            return iSet.remove(obj);\n+        }\n+\n+        /**\n+         * @see Collection#size()\n+         */\n+        public int size() {\n+            return iSet.size();\n+        }\n+\n+\t}\n+\t\n+\t/**\n+\t * Iterator to protect the setValue method of Map.Entry\n+\t */\n+    public static class PredicateMapEntrySetIterator\n+    \t\timplements Iterator {\n+\t    private final Iterator iIterator;\n+        private final Predicate iValuePredicate;\n+\t    \n+\t    /**\n+\t     * Constructor\n+\t     */\n+\t    private PredicateMapEntrySetIterator(Iterator iterator, Predicate predicate) {\n+\t        super();\n+\t        iIterator = iterator;\n+\t        iValuePredicate = predicate;\n+\t    }\n+            \n+        /**\n+         * @see Iterator#next()\n+         */\n+        public Object next() {\n+            Object obj = iIterator.next();\n+            return new PredicateMapEntry((Map.Entry) obj, iValuePredicate);\n+        }\n+\n+        /**\n+         * @see Iterator#hasNext()\n+         */\n+        public boolean hasNext() {\n+            return iIterator.hasNext();\n+        }\n+\n+        /**\n+         * @see Iterator#remove()\n+         */\n+        public void remove() {\n+            iIterator.remove();\n+        }\n+\n+    }\n+    \n+\t/**\n+\t * MapEntry to protect the setValue method\n+\t */\n+    public static class PredicateMapEntry\n+    \t\timplements Map.Entry {\n+\t    private final Map.Entry iEntry;\n+        private final Predicate iValuePredicate;\n+        \n+\t    /**\n+\t     * Constructor\n+\t     */\n+\t    private PredicateMapEntry(Map.Entry entry, Predicate predicate) {\n+\t        super();\n+\t        iEntry = entry;\n+\t        iValuePredicate = predicate;\n+\t    }\n+\t    \n+        /**\n+         * @see Map.Entry#getKey()\n+         */\n+        public Object getKey() {\n+            return iEntry.getKey();\n+        }\n+\n+        /**\n+         * @see Map.Entry#getValue()\n+         */\n+        public Object getValue() {\n+            return iEntry.getValue();\n+        }\n+\n+        /**\n+         * @see Map.Entry#setValue()\n+         */\n+        public Object setValue(Object object) {\n+            validate(iValuePredicate, object);\n+            return iEntry.setValue(object);\n+        }\n+\n+    }\n+    \n+\t/**\n+\t * True predicate implementation\n+\t */    \n+    private static class TruePredicate implements Predicate {\n+        private TruePredicate() {\n+            super();\n+        }\n+\t    public boolean evaluate(Object input) {\n+\t        return true;\n+\t    }\n+    }\n+    \n+\t/**\n+\t * False predicate implementation\n+\t */    \n+    private static class FalsePredicate implements Predicate {\n+        private FalsePredicate() {\n+            super();\n+        }\n+\t    public boolean evaluate(Object input) {\n+\t        return false;\n+\t    }\n+    }\n+    \n+\t/**\n+\t * And predicate implementation\n+\t */    \n+    private static class AndPredicate implements Predicate {\n+        private final Predicate iPredicate1;\n+        private final Predicate iPredicate2;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private AndPredicate(Predicate predicate1, Predicate predicate2) {\n+            super();\n+    \t    if ((predicate1 == null) || (predicate2 == null)) {\n+    \t        throw new IllegalArgumentException(\"Predicate must not be null\");\n+    \t    }\n+            iPredicate1 = predicate1;\n+            iPredicate2 = predicate2;\n+        }\n+\t    public boolean evaluate(Object input) {\n+\t        return iPredicate1.evaluate(input) && iPredicate2.evaluate(input);\n+\t    }\n+    }\n+    \n+\t/**\n+\t * Or predicate implementation\n+\t */    \n+    private static class OrPredicate implements Predicate {\n+        private final Predicate iPredicate1;\n+        private final Predicate iPredicate2;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private OrPredicate(Predicate predicate1, Predicate predicate2) {\n+            super();\n+    \t    if ((predicate1 == null) || (predicate2 == null)) {\n+    \t        throw new IllegalArgumentException(\"Predicate must not be null\");\n+    \t    }\n+            iPredicate1 = predicate1;\n+            iPredicate2 = predicate2;\n+        }\n+\t    public boolean evaluate(Object input) {\n+\t        return iPredicate1.evaluate(input) || iPredicate2.evaluate(input);\n+\t    }\n+    }\n+    \n+\t/**\n+\t * Not predicate implementation\n+\t */    \n+    private static class NotPredicate implements Predicate {\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NotPredicate(Predicate predicate) {\n+            super();\n+    \t    if (predicate == null) {\n+    \t        throw new IllegalArgumentException(\"Predicate must not be null\");\n+    \t    }\n+            iPredicate = predicate;\n+        }\n+\t    public boolean evaluate(Object input) {\n+\t        return ! iPredicate.evaluate(input);\n+\t    }\n+    }\n+    \n+    /**\n+     * Predicate that checks the type of an object\n+     */\n+    public static class InstanceofPredicate implements Predicate {\n+        private final Class iType;\n+    \n+    \t/**\n+    \t * Constructor\n+    \t * @param type  the type to validate for\n+    \t */\n+    \tpublic InstanceofPredicate(Class type) {\n+    \t    super();\n+    \t    if (type == null) {\n+    \t        throw new IllegalArgumentException(\"Type to be checked for must not be null\");\n+    \t    }\n+    \t    iType = type;\n+    \t}\n+    \n+        /**\n+         * Validate the input object to see if it is an instanceof the \n+         * type of the predicate.\n+         * @param object  the object to be checked\n+         * @return true if it is an instance\n+         */\n+        public boolean evaluate(Object object) {\n+            return iType.isInstance(object);\n+        }\n+    }\n+}\n+", "timestamp": 1020320239, "metainfo": ""}