{"sha": "487621cb99343c37f66673879f4af5d8d644e541", "log": "Add LoopingListIterator bug 30166, from Eric Crampton   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/iterators/LoopingListIterator.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * A ListIterator that restarts when it reaches the end or when it\n+ * reaches the beginning.\n+ * <p>\n+ * The iterator will loop continuously around the provided list,\n+ * unless there are no elements in the collection to begin with, or\n+ * all of the elements have been {@link #remove removed}.\n+ * <p>\n+ * Concurrent modifications are not directly supported, and for most\n+ * collection implementations will throw a\n+ * ConcurrentModificationException.\n+ *\n+ * @since Commons Collections 3.2\n+ * @version $Revision: 1.1 $ $Date: 2004/07/17 21:02:47 $\n+ *\n+ * @author Eric Crampton <ccesc@eonomine.com>\n+ */\n+public class LoopingListIterator implements ResettableIterator {\n+\n+    /** The list to base the iterator on */\n+    private List list;\n+    /** The current list iterator */\n+    private ListIterator iterator;\n+\n+    /**\n+     * Constructor that wraps a list.\n+     * <p>\n+     * There is no way to reset a ListIterator instance without\n+     * recreating it from the original source, so the List must be\n+     * passed in and a reference to it held.\n+     *\n+     * @param list the list to wrap\n+     * @throws NullPointerException if the list it null\n+     */\n+    public LoopingListIterator(List list) {\n+        if (list == null) {\n+            throw new NullPointerException(\"The list must not be null\");\n+        }\n+        this.list = list;\n+        reset();\n+    }\n+\n+    /**\n+     * Returns whether this iterator has any more elements.\n+     * <p>\n+     * Returns false only if the list originally had zero elements, or\n+     * all elements have been {@link #remove removed}.\n+     *\n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasNext() {\n+        return !list.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the next object in the list.\n+     * <p>\n+     * If at the end of the list, returns the first element.\n+     *\n+     * @return the object after the last element returned\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public Object next() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            reset();\n+        }\n+        return iterator.next();\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a\n+     * subsequent call to {@link #next}.\n+     * <p>\n+     * As would be expected, if the iterator is at the physical end of\n+     * the underlying list, 0 is returned, signifying the beginning of\n+     * the list.\n+     *\n+     * @return the index of the element that would be returned if next() were called\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public int nextIndex() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            return 0;\n+        } else {\n+            return iterator.nextIndex();\n+        }\n+    }\n+\n+    /**\n+     * Returns whether this iterator has any more previous elements.\n+     * <p>\n+     * Returns false only if the list originally had zero elements, or\n+     * all elements have been {@link #remove removed}.\n+     *\n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasPrevious() {\n+        return !list.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the previous object in the list.\n+     * <p>\n+     * If at the beginning of the list, return the last element. Note\n+     * that in this case, traversal to find that element takes linear time.\n+     *\n+     * @return the object before the last element returned\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public Object previous() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasPrevious() == false) {\n+            Object result = null;\n+            while (iterator.hasNext()) {\n+                result = iterator.next();\n+            }\n+            iterator.previous();\n+            return result;\n+        } else {\n+            return iterator.previous();\n+        }\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a\n+     * subsequent call to {@link #previous}.\n+     * <p>\n+     * As would be expected, if at the iterator is at the physical\n+     * beginning of the underlying list, the list's size minus one is\n+     * returned, signifying the end of the list.\n+     *\n+     * @return the index of the element that would be returned if previous() were called\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public int previousIndex() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasPrevious() == false) {\n+            return list.size() - 1;\n+        } else {\n+            return iterator.previousIndex();\n+        }\n+    }\n+\n+    /**\n+     * Removes the previously retrieved item from the underlying list.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#iterator iterator} method returns an implementation\n+     * that supports it.\n+     * <p>\n+     * This method can only be called after at least one {@link #next}\n+     * or {@link #previous} method call. After a removal, the remove\n+     * method may not be called again until another {@link #next} or\n+     * {@link #previous} has been performed. If the {@link #reset} is\n+     * called, then remove may not be called until {@link #next} or\n+     * {@link #previous} is called again.\n+     *\n+     * @throws UnsupportedOperationException if the remove method is\n+     * not supported by the iterator implementation of the underlying\n+     * list\n+     */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Inserts the specified element into the underlying list.\n+     * <p>\n+     * The element is inserted before the next element that would be\n+     * returned by {@link #next}, if any, and after the next element\n+     * that would be returned by {@link #previous}, if any.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#listIterator} method returns an implementation\n+     * that supports it.\n+     *\n+     * @param obj  the element to insert\n+     * @throws UnsupportedOperationException if the add method is not\n+     *  supported by the iterator implementation of the underlying list\n+     */\n+    public void add(Object obj) {\n+        iterator.add(obj);\n+    }\n+\n+    /**\n+     * Replaces the last element that was returned by {@link #next} or\n+     * {@link #previous}.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#listIterator} method returns an implementation\n+     * that supports it.\n+     *\n+     * @param obj  the element with which to replace the last element returned\n+     * @throws UnsupportedOperationException if the set method is not\n+     *  supported by the iterator implementation of the underlying list\n+     */\n+    public void set(Object obj) {\n+        iterator.set(obj);\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start of the list.\n+     */\n+    public void reset() {\n+        iterator = list.listIterator();\n+    }\n+\n+    /**\n+     * Gets the size of the list underlying the iterator.\n+     *\n+     * @return the current list size\n+     */\n+    public int size() {\n+        return list.size();\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/iterators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestAll.java\n /**\n  * Entry point for all iterator tests.\n  * \n- * @version $Revision: 1.15 $ $Date: 2004/04/09 14:38:47 $\n+ * @version $Revision: 1.16 $ $Date: 2004/07/17 21:02:47 $\n  * \n  * @author Rodney Waldhoff\n  */\n         suite.addTest(TestIteratorChain.suite());\n         suite.addTest(TestListIteratorWrapper.suite());\n         suite.addTest(TestLoopingIterator.suite());\n+        suite.addTest(TestLoopingListIterator.suite());\n         suite.addTest(TestSingletonIterator.suite());\n         suite.addTest(TestSingletonIterator2.suite());\n         suite.addTest(TestSingletonListIterator.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/iterators/TestLoopingListIterator.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Tests the LoopingListIterator class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/07/17 21:02:47 $\n+ *\n+ * @author Eric Crampton <ccesc@eonomine.com>\n+ */\n+public class TestLoopingListIterator extends TestCase {\n+\n+    public TestLoopingListIterator(String testName) {\n+        super(testName);\n+    }\n+    \n+    public static Test suite() {\n+        return new TestSuite(TestLoopingListIterator.class);\n+    }\n+\n+    /**\n+     * Tests constructor exception.\n+     */\n+    public void testConstructorEx() throws Exception {\n+        try {\n+            new LoopingListIterator(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether an empty looping list iterator works.\n+     */\n+    public void testLooping0() throws Exception {\n+        List list = new ArrayList();\n+        LoopingListIterator loop = new LoopingListIterator(list);\n+        assertFalse(loop.hasNext());\n+        assertFalse(loop.hasPrevious());\n+        \n+        try {\n+            loop.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+\n+        try {\n+            loop.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether a looping list iterator works on a list with only\n+     * one element.\n+     */\n+    public void testLooping1() throws Exception {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+    }\n+\n+    /**\n+     * Tests whether a looping list iterator works on a list with two\n+     * elements.\n+     */\n+    public void testLooping2() throws Exception {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"b\", loop.next());     // <a> b\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        // Reset the iterator and try using previous.\n+        loop.reset();                       // <a> b\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+    }\n+\n+    /**\n+     * Tests jogging back and forth between two elements, but not over\n+     * the begin/end boundary of the list.\n+     */\n+    public void testJoggingNotOverBoundary() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b\n+    \n+        // Try jogging back and forth between the elements, but not\n+        // over the begin/end boundary.\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());     // a <b>\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        assertEquals(\"b\", loop.next());     // <a> b\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        assertEquals(\"b\", loop.next());     // <a> b\n+    }\n+\n+    /**\n+     * Tests jogging back and forth between two elements over the\n+     * begin/end boundary of the list.\n+     */\n+    public void testJoggingOverBoundary() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b\n+    \n+        // Try jogging back and forth between the elements, but not\n+        // over the begin/end boundary.\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        assertEquals(\"b\", loop.next());     // <a> b\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+        assertEquals(\"a\", loop.next());     // a <b>\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+    }\n+\n+    /**\n+     * Tests removing an element from a wrapped ArrayList.\n+     */\n+    public void testRemovingElementsAndIteratingForward() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        loop.remove();                  // <b> c\n+        assertEquals(2, list.size());\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"b\", loop.next()); // b <c>\n+        loop.remove();                  // <c>\n+        assertEquals(1, list.size());\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"c\", loop.next()); // <c>\n+        loop.remove();                  // ---\n+        assertEquals(0, list.size());\n+\n+        assertFalse(loop.hasNext());\n+        try {\n+            loop.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests removing an element from a wrapped ArrayList.\n+     */\n+    public void testRemovingElementsAndIteratingBackwards() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        loop.remove();                      // <a> b\n+        assertEquals(2, list.size());\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        loop.remove();                      // <a>\n+        assertEquals(1, list.size());\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+        loop.remove();                      // ---\n+        assertEquals(0, list.size());\n+\n+        assertFalse(loop.hasPrevious());\n+        try {\n+            loop.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests the reset method.\n+     */\n+    public void testReset() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        assertEquals(\"b\", loop.next()); // a b <c>\n+        loop.reset();                   // <a> b c\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        loop.reset();                   // <a> b c\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        assertEquals(\"b\", loop.next()); // a b <c>\n+        assertEquals(\"c\", loop.next()); // <a> b c\n+        loop.reset();                   // <a> b c\n+\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        assertEquals(\"b\", loop.previous()); // a <b> c\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        assertEquals(\"b\", loop.previous()); // a <b> c\n+        assertEquals(\"a\", loop.previous()); // <a> b c\n+    }\n+\n+    /**\n+     * Tests the add method.\n+     */\n+    public void testAdd() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <b> e f\n+\n+        loop.add(\"a\");                      // <a> b e f\n+        assertEquals(\"b\", loop.next());     // a <b> e f\n+        loop.reset();                       // <a> b e f\n+        assertEquals(\"a\", loop.next());     // a <b> e f\n+        assertEquals(\"b\", loop.next());     // a b <e> f\n+\n+        loop.add(\"c\");                      // a b c <e> f\n+        assertEquals(\"e\", loop.next());     // a b c e <f>\n+        assertEquals(\"e\", loop.previous()); // a b c <e> f\n+        assertEquals(\"c\", loop.previous()); // a b <c> e f\n+        assertEquals(\"c\", loop.next());     // a b c <e> f\n+        \n+        loop.add(\"d\");                      // a b c d <e> f\n+        loop.reset();                       // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+        assertEquals(\"b\", loop.next());     // a b <c> d e f\n+        assertEquals(\"c\", loop.next());     // a b c <d> e f\n+        assertEquals(\"d\", loop.next());     // a b c d <e> f\n+        assertEquals(\"e\", loop.next());     // a b c d e <f>\n+        assertEquals(\"f\", loop.next());     // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+\n+        list = new ArrayList(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        loop = new LoopingListIterator(list); // <b> e f        \n+\n+        loop.add(\"a\");                      // a <b> e f\n+        assertEquals(\"a\", loop.previous()); // a b e <f>\n+        loop.reset();                       // <a> b e f\n+        assertEquals(\"f\", loop.previous()); // a b e <f>\n+        assertEquals(\"e\", loop.previous()); // a b <e> f\n+\n+        loop.add(\"d\");                      // a b d <e> f\n+        assertEquals(\"d\", loop.previous()); // a b <d> e f\n+\n+        loop.add(\"c\");                      // a b c <d> e f\n+        assertEquals(\"c\", loop.previous()); // a b <c> d e f\n+\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+        assertEquals(\"b\", loop.next());     // a b <c> d e f\n+        assertEquals(\"c\", loop.next());     // a b c <d> e f\n+        assertEquals(\"d\", loop.next());     // a b c d <e> f\n+        assertEquals(\"e\", loop.next());     // a b c d e <f>\n+        assertEquals(\"f\", loop.next());     // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+    }\n+\n+    /**\n+     * Tests nextIndex and previousIndex.\n+     */\n+    public void testNextAndPreviousIndex() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.next());        // a <b> c\n+        assertEquals(1, loop.nextIndex());\n+        assertEquals(0, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.previous());    // <a> b c\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+\n+        assertEquals(\"c\", loop.previous());    // a b <c>\n+        assertEquals(2, loop.nextIndex());\n+        assertEquals(1, loop.previousIndex());\n+\n+        assertEquals(\"b\", loop.previous());    // a <b> c\n+        assertEquals(1, loop.nextIndex());\n+        assertEquals(0, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.previous());    // <a> b c\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+    }\n+\n+    /**\n+     * Tests using the set method to change elements.\n+     */\n+    public void testSet() {\n+        List list = new ArrayList(Arrays.asList(new String[] { \"q\", \"r\", \"z\" }));\n+        LoopingListIterator loop = new LoopingListIterator(list); // <q> r z\n+\n+        assertEquals(\"z\", loop.previous()); // q r <z>\n+        loop.set(\"c\");                      // q r <c>\n+\n+        loop.reset();                       // <q> r c\n+        assertEquals(\"q\", loop.next());     // q <r> c\n+        loop.set(\"a\");                      // a <r> c\n+        \n+        assertEquals(\"r\", loop.next());     // a r <c>\n+        loop.set(\"b\");                      // a b <c>\n+\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"a\", loop.next());     // a <b> c\n+        assertEquals(\"b\", loop.next());     // a b <c>\n+        assertEquals(\"c\", loop.next());     // <a> b c\n+    }\n+    \n+}", "timestamp": 1090098167, "metainfo": ""}