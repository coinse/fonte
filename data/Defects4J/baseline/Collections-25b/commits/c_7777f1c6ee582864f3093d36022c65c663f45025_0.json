{"sha": "7777f1c6ee582864f3093d36022c65c663f45025", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r740153 | mbenson | 2009-02-02 15:41:20 -0800 (Mon, 02 Feb 2009) | 1 line          since I changed the test hierarchy, AbstractTestMap shouldn't force IterableMap     ------------------------------------------------------------------------     r740150 | mbenson | 2009-02-02 15:24:00 -0800 (Mon, 02 Feb 2009) | 1 line          make all [collections] maps implement IterableMap     ------------------------------------------------------------------------     r571381 | skestle | 2007-08-30 22:13:56 -0700 (Thu, 30 Aug 2007) | 1 line          Generified LazyMap     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n+++ b/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.Map.Entry;\n \n import org.apache.commons.collections.AbstractTestObject;\n import org.apache.commons.collections.BulkTest;\n  * The upshot of all that is that <I>any</I> test that modifies the map in\n  * <I>any</I> way will verify that <I>all</I> of the map's state is still\n  * correct, including the state of its collection views.  So for instance\n- * if a key is removed by the map's key set's iterator, then the entry set \n+ * if a key is removed by the map's key set's iterator, then the entry set\n  * is checked to make sure the key/value pair no longer appears.<P>\n  *\n  * The {@link #map} field holds an instance of your collection implementation.\n  * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n  * that map's collection views.  And the {@link #confirmed} field holds\n- * an instance of the confirmed collection implementation.  The \n- * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to \n+ * an instance of the confirmed collection implementation.  The\n+ * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to\n  * empty or full maps, so that tests can proceed from a known state.<P>\n  *\n  * After a modification operation to both {@link #map} and {@link #confirmed},\n  * instance, TestDoubleOrderedMap would want override its\n  * {@link #verifyValues()} method to verify that the values are unique and in\n  * ascending order.<P>\n- *  \n+ *\n  * <b>Other Notes</b>\n  * <p>\n  * If your {@link Map} fails one of these tests by design, you may still use\n  * @author Stephen Colebourne\n  * @version $Revision$ $Date$\n  */\n-public abstract class AbstractTestMap extends AbstractTestObject {\n+public abstract class AbstractTestMap<K, V> extends AbstractTestObject {\n \n     /**\n      * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString\n     }\n \n     // These instance variables are initialized with the reset method.\n-    // Tests for map methods that alter the map (put, putAll, remove) \n+    // Tests for map methods that alter the map (put, putAll, remove)\n     // first call reset() to create the map and its views; then perform\n     // the modification on the map; perform the same modification on the\n     // confirmed; and then call verify() to ensure that the map is equal\n     // to the confirmed, that the already-constructed collection views\n     // are still equal to the confirmed's collection views.\n \n-\n     /** Map created by reset(). */\n-    protected Map map;\n+    protected Map<K, V> map;\n \n     /** Entry set of map created by reset(). */\n-    protected Set entrySet;\n+    protected Set<Map.Entry<K, V>> entrySet;\n \n     /** Key set of map created by reset(). */\n-    protected Set keySet;\n+    protected Set<K> keySet;\n \n     /** Values collection of map created by reset(). */\n-    protected Collection values;\n+    protected Collection<V> values;\n \n     /** HashMap created by reset(). */\n-    protected Map confirmed;\n+    protected Map<K, V> confirmed;\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test name\n      */\n     public AbstractTestMap(String testName) {\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * support the <code>put</code> and <code>putAll</code> operations\n      * adding new mappings.\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * support the <code>put</code> and <code>putAll</code> operations\n      * changing existing mappings.\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * support the <code>setValue</code> operation on entrySet entries.\n      * <p>\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * support the <code>remove</code> and <code>clear</code> operations.\n      * <p>\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * can cause structural modification on a get(). The example is LRUMap.\n      * <p>\n      * Returns whether the sub map views of SortedMap are serializable.\n      * If the class being tested is based around a TreeMap then you should\n      * override and return false as TreeMap has a bug in deserialization.\n-     * \n+     *\n      * @return false\n      */\n     public boolean isSubMapViewsSerializable() {\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * supports null keys.\n      * <p>\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * supports null values.\n      * <p>\n     }\n \n     /**\n-     * Returns true if the maps produced by \n+     * Returns true if the maps produced by\n      * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n      * supports duplicate values.\n      * <p>\n     }\n \n     /**\n+     * Returns true if the maps produced by\n+     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * provide fail-fast behavior on their various iterators.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support fast failure.\n+     */\n+    public boolean isFailFastExpected() {\n+        return true;\n+    }\n+\n+    /**\n      *  Returns the set of keys in the mappings used to test the map.  This\n      *  method must return an array with the same length as {@link\n      *  #getSampleValues()} and all array elements must be different. The\n      *  default implementation constructs a set of String keys, and includes a\n      *  single null key if {@link #isAllowNullKey()} returns <code>true</code>.\n      */\n-    public Object[] getSampleKeys() {\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n         Object[] result = new Object[] {\n-            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\", \n+            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\",\n             \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n             \"key\",\n             \"key2\",\n             (isAllowNullKey() && !JDK12) ? null : \"nonnullkey\"\n         };\n-        return result;\n-    }\n-\n-\n-    public Object[] getOtherKeys() {\n-        return getOtherNonNullStringElements();\n-    }\n-\n-    public Object[] getOtherValues() {\n-        return getOtherNonNullStringElements();\n+        return (K[]) result;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getOtherKeys() {\n+        return (K[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getOtherValues() {\n+        return (V[]) getOtherNonNullStringElements();\n     }\n \n     /**\n      * Returns the set of values in the mappings used to test the map.  This\n      * method must return an array with the same length as\n      * {@link #getSampleKeys()}.  The default implementation constructs a set of\n-     * String values and includes a single null value if \n+     * String values and includes a single null value if\n      * {@link #isAllowNullValue()} returns <code>true</code>, and includes\n      * two values that are the same if {@link #isAllowDuplicateValues()} returns\n      * <code>true</code>.\n      */\n-    public Object[] getSampleValues() {\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n         Object[] result = new Object[] {\n             \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n             \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n             \"value\",\n             (isAllowDuplicateValues()) ? \"value\" : \"value2\",\n         };\n-        return result;\n+        return (V[]) result;\n     }\n \n     /**\n      * set of String values and includes a single null value if\n      * {@link #isAllowNullValue()} returns <code>true</code>, and includes two values\n      * that are the same if {@link #isAllowDuplicateValues()} returns\n-     * <code>true</code>.  \n-     */\n-    public Object[] getNewSampleValues() {\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n         Object[] result = new Object[] {\n             (isAllowNullValue() && !JDK12 && isAllowDuplicateValues()) ? null : \"newnonnullvalue\",\n             \"newvalue\",\n             (isAllowDuplicateValues()) ? \"newvalue\" : \"newvalue2\",\n-            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\", \n-            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\", \n+            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\",\n+            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\",\n             \"newseev\", \"newyouv\", \"newallv\", \"newagainv\",\n         };\n-        return result;\n+        return (V[]) result;\n     }\n \n     /**\n      *  Helper method to add all the mappings described by\n      * {@link #getSampleKeys()} and {@link #getSampleValues()}.\n      */\n-    public void addSampleMappings(Map m) {\n-\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        \n-        for(int i = 0; i < keys.length; i++) {\n+    public void addSampleMappings(Map<? super K, ? super V> m) {\n+\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n             try {\n                 m.put(keys[i], values[i]);\n             } catch (NullPointerException exception) {\n                 assertTrue(\"NullPointerException only allowed to be thrown \" +\n-                           \"if either the key or value is null.\", \n+                           \"if either the key or value is null.\",\n                            keys[i] == null || values[i] == null);\n-                \n+\n                 assertTrue(\"NullPointerException on null key, but \" +\n-                           \"isAllowNullKey is not overridden to return false.\", \n+                           \"isAllowNullKey is not overridden to return false.\",\n                            keys[i] == null || !isAllowNullKey());\n-                \n+\n                 assertTrue(\"NullPointerException on null value, but \" +\n                            \"isAllowNullValue is not overridden to return false.\",\n                            values[i] == null || !isAllowNullValue());\n-                \n+\n                 assertTrue(\"Unknown reason for NullPointer.\", false);\n             }\n         }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Return a new, empty {@link Map} to be used for testing. \n-     * \n+     * Return a new, empty {@link Map} to be used for testing.\n+     *\n      * @return the map to be tested\n      */\n-    public abstract Map makeEmptyMap();\n+    public abstract Map<K,V> makeObject();\n \n     /**\n      * Return a new, populated map.  The mappings in the map should match the\n      * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()\n      * and calls {@link #addSampleMappings} to add all the mappings to the\n      * map.\n-     * \n+     *\n      * @return the map to be tested\n      */\n-    public Map makeFullMap() {\n-        Map m = makeEmptyMap();\n+    public Map<K, V> makeFullMap() {\n+        Map<K, V> m = makeObject();\n         addSampleMappings(m);\n         return m;\n     }\n \n     /**\n-     * Implements the superclass method to return the map to be tested.\n-     * \n-     * @return the map to be tested\n-     */\n-    public Object makeObject() {\n-        return makeEmptyMap();\n-    }\n-\n-    /**\n      * Override to return a map other than HashMap as the confirmed map.\n-     * \n+     *\n      * @return a map that is known to be valid\n      */\n-    public Map makeConfirmedMap() {\n-        return new HashMap();\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n     }\n \n     /**\n      * Creates a new Map Entry that is independent of the first and the map.\n      */\n-    public Map.Entry cloneMapEntry(Map.Entry entry) {\n-        HashMap map = new HashMap();\n+    public static <K, V> Map.Entry<K, V> cloneMapEntry(Map.Entry<K, V> entry) {\n+        HashMap<K, V> map = new HashMap<K, V>();\n         map.put(entry.getKey(), entry.getValue());\n-        return (Map.Entry) map.entrySet().iterator().next();\n+        return map.entrySet().iterator().next();\n     }\n \n     /**\n     public String getCompatibilityVersion() {\n         return super.getCompatibilityVersion();\n     }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Test to ensure the test setup is working properly.  This method checks\n      * duplicate values, and may only contain a (single) null key if\n      * isNullKeySupported() returns true.  The values array must only have a null\n      * value if useNullValue() is true and may only have duplicate values if\n-     * isAllowDuplicateValues() returns true.  \n+     * isAllowDuplicateValues() returns true.\n      */\n     public void testSampleMappings() {\n-      Object[] keys = getSampleKeys();\n-      Object[] values = getSampleValues();\n-      Object[] newValues = getNewSampleValues();\n-\n-      assertTrue(\"failure in test: Must have keys returned from \" +\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Object[] newValues = getNewSampleValues();\n+\n+        assertTrue(\"failure in test: Must have keys returned from \" +\n                  \"getSampleKeys.\", keys != null);\n \n-      assertTrue(\"failure in test: Must have values returned from \" +\n+        assertTrue(\"failure in test: Must have values returned from \" +\n                  \"getSampleValues.\", values != null);\n \n-      // verify keys and values have equivalent lengths (in case getSampleX are\n-      // overridden)\n-      assertEquals(\"failure in test: not the same number of sample \" +\n+        // verify keys and values have equivalent lengths (in case getSampleX are\n+        // overridden)\n+        assertEquals(\"failure in test: not the same number of sample \" +\n                    \"keys and values.\",  keys.length, values.length);\n-      \n-      assertEquals(\"failure in test: not the same number of values and new values.\",\n+\n+        assertEquals(\"failure in test: not the same number of values and new values.\",\n                    values.length, newValues.length);\n \n-      // verify there aren't duplicate keys, and check values\n-      for(int i = 0; i < keys.length - 1; i++) {\n-          for(int j = i + 1; j < keys.length; j++) {\n-              assertTrue(\"failure in test: duplicate null keys.\",\n-                         (keys[i] != null || keys[j] != null));\n-              assertTrue(\"failure in test: duplicate non-null key.\",\n-                         (keys[i] == null || keys[j] == null || \n-                          (!keys[i].equals(keys[j]) && \n-                           !keys[j].equals(keys[i]))));\n-          }\n-          assertTrue(\"failure in test: found null key, but isNullKeySupported \" +\n-                     \"is false.\", keys[i] != null || isAllowNullKey());\n-          assertTrue(\"failure in test: found null value, but isNullValueSupported \" +\n-                     \"is false.\", values[i] != null || isAllowNullValue());\n-          assertTrue(\"failure in test: found null new value, but isNullValueSupported \" +\n-                     \"is false.\", newValues[i] != null || isAllowNullValue());\n-          assertTrue(\"failure in test: values should not be the same as new value\",\n-                     values[i] != newValues[i] && \n-                     (values[i] == null || !values[i].equals(newValues[i])));\n-      }\n-    }\n-    \n+        // verify there aren't duplicate keys, and check values\n+        for (int i = 0; i < keys.length - 1; i++) {\n+            for (int j = i + 1; j < keys.length; j++) {\n+                assertTrue(\"failure in test: duplicate null keys.\",\n+                        (keys[i] != null || keys[j] != null));\n+                assertTrue(\n+                        \"failure in test: duplicate non-null key.\",\n+                        (keys[i] == null || keys[j] == null || (!keys[i].equals(keys[j]) && !keys[j]\n+                                .equals(keys[i]))));\n+            }\n+            assertTrue(\"failure in test: found null key, but isNullKeySupported \" + \"is false.\",\n+                    keys[i] != null || isAllowNullKey());\n+            assertTrue(\n+                    \"failure in test: found null value, but isNullValueSupported \" + \"is false.\",\n+                    values[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: found null new value, but isNullValueSupported \"\n+                    + \"is false.\", newValues[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: values should not be the same as new value\",\n+                    values[i] != newValues[i]\n+                            && (values[i] == null || !values[i].equals(newValues[i])));\n+        }\n+    }\n+\n     // tests begin here.  Each test adds a little bit of tested functionality.\n     // Many methods assume previous methods passed.  That is, they do not\n     // exhaustively recheck things that have already been checked in a previous\n-    // test methods.  \n+    // test methods.\n \n     /**\n      * Test to ensure that makeEmptyMap and makeFull returns a new non-null\n-     * map with each invocation.  \n+     * map with each invocation.\n      */\n     public void testMakeMap() {\n-        Map em = makeEmptyMap();\n+        Map<K, V> em = makeObject();\n         assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n                    em != null);\n-        \n-        Map em2 = makeEmptyMap();\n+\n+        Map<K, V> em2 = makeObject();\n         assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n                    em != null);\n \n         assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n                    \"with each invocation.\", em != em2);\n \n-        Map fm = makeFullMap();\n+        Map<K, V> fm = makeFullMap();\n         assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n                    fm != null);\n-        \n-        Map fm2 = makeFullMap();\n+\n+        Map<K, V> fm2 = makeFullMap();\n         assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n                    fm != null);\n \n      */\n     public void testMapIsEmpty() {\n         resetEmpty();\n-        assertEquals(\"Map.isEmpty() should return true with an empty map\", \n-                     true, map.isEmpty());\n+        assertEquals(\"Map.isEmpty() should return true with an empty map\",\n+                     true, getMap().isEmpty());\n         verify();\n \n         resetFull();\n         assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n-                     false, map.isEmpty());\n+                     false, getMap().isEmpty());\n         verify();\n     }\n \n     public void testMapSize() {\n         resetEmpty();\n         assertEquals(\"Map.size() should be 0 with an empty map\",\n-                     0, map.size());\n+                     0, getMap().size());\n         verify();\n \n         resetFull();\n         assertEquals(\"Map.size() should equal the number of entries \" +\n-                     \"in the map\", getSampleKeys().length, map.size());\n+                     \"in the map\", getSampleKeys().length, getMap().size());\n         verify();\n     }\n \n         if (!isRemoveSupported()) {\n             try {\n                 resetFull();\n-                map.clear();\n+                getMap().clear();\n                 fail(\"Expected UnsupportedOperationException on clear\");\n             } catch (UnsupportedOperationException ex) {}\n             return;\n         }\n \n         resetEmpty();\n-        map.clear();\n-        confirmed.clear();\n-        verify();\n-        \n-        resetFull();\n-        map.clear();\n-        confirmed.clear();\n-        verify();\n-    }\n-\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+\n+        resetFull();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n \n     /**\n      * Tests Map.containsKey(Object) by verifying it returns false for all\n      * sample keys on a map created using an empty map and returns true for\n-     * all sample keys returned on a full map. \n+     * all sample keys returned on a full map.\n      */\n     public void testMapContainsKey() {\n         Object[] keys = getSampleKeys();\n \n         resetEmpty();\n         for(int i = 0; i < keys.length; i++) {\n-            assertTrue(\"Map must not contain key when map is empty\", \n-                       !map.containsKey(keys[i]));\n+            assertTrue(\"Map must not contain key when map is empty\",\n+                       !getMap().containsKey(keys[i]));\n         }\n         verify();\n \n         resetFull();\n         for(int i = 0; i < keys.length; i++) {\n             assertTrue(\"Map must contain key for a mapping in the map. \" +\n-                       \"Missing: \" + keys[i], map.containsKey(keys[i]));\n+                       \"Missing: \" + keys[i], getMap().containsKey(keys[i]));\n         }\n         verify();\n     }\n \n         resetEmpty();\n         for(int i = 0; i < values.length; i++) {\n-            assertTrue(\"Empty map must not contain value\", \n-                       !map.containsValue(values[i]));\n-        }\n-        verify();\n-        \n+            assertTrue(\"Empty map must not contain value\",\n+                       !getMap().containsValue(values[i]));\n+        }\n+        verify();\n+\n         resetFull();\n         for(int i = 0; i < values.length; i++) {\n-            assertTrue(\"Map must contain value for a mapping in the map.\", \n-                       map.containsValue(values[i]));\n+            assertTrue(\"Map must contain value for a mapping in the map.\",\n+                    getMap().containsValue(values[i]));\n         }\n         verify();\n     }\n      */\n     public void testMapEquals() {\n         resetEmpty();\n-        assertTrue(\"Empty maps unequal.\", map.equals(confirmed));\n-        verify();\n-\n-        resetFull();\n-        assertTrue(\"Full maps unequal.\", map.equals(confirmed));\n+        assertTrue(\"Empty maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full maps unequal.\", getMap().equals(confirmed));\n         verify();\n \n         resetFull();\n         // modify the HashMap created from the full map and make sure this\n         // change results in map.equals() to return false.\n-        Iterator iter = confirmed.keySet().iterator();\n+        Iterator<K> iter = confirmed.keySet().iterator();\n         iter.next();\n         iter.remove();\n-        assertTrue(\"Different maps equal.\", !map.equals(confirmed));\n-        \n-        resetFull();\n-        assertTrue(\"equals(null) returned true.\", !map.equals(null));\n-        assertTrue(\"equals(new Object()) returned true.\", \n-                   !map.equals(new Object()));\n-        verify();\n-    }\n-\n+        assertTrue(\"Different maps equal.\", !getMap().equals(confirmed));\n+\n+        resetFull();\n+        assertTrue(\"equals(null) returned true.\", !getMap().equals(null));\n+        assertTrue(\"equals(new Object()) returned true.\",\n+                   !getMap().equals(new Object()));\n+        verify();\n+    }\n \n     /**\n      * Tests Map.get(Object)\n         Object[] values = getSampleValues();\n \n         for (int i = 0; i < keys.length; i++) {\n-            assertTrue(\"Empty map.get() should return null.\", \n-                       map.get(keys[i]) == null);\n+            assertTrue(\"Empty map.get() should return null.\",\n+                    getMap().get(keys[i]) == null);\n         }\n         verify();\n \n         resetFull();\n         for (int i = 0; i < keys.length; i++) {\n-            assertEquals(\"Full map.get() should return value from mapping.\", \n-                         values[i], map.get(keys[i]));\n+            assertEquals(\"Full map.get() should return value from mapping.\",\n+                         values[i], getMap().get(keys[i]));\n         }\n     }\n \n      */\n     public void testMapHashCode() {\n         resetEmpty();\n-        assertTrue(\"Empty maps have different hashCodes.\", \n-                   map.hashCode() == confirmed.hashCode());\n-\n-        resetFull();\n-        assertTrue(\"Equal maps have different hashCodes.\", \n-                   map.hashCode() == confirmed.hashCode());\n+        assertTrue(\"Empty maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+\n+        resetFull();\n+        assertTrue(\"Equal maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n     }\n \n     /**\n      */\n     public void testMapToString() {\n         resetEmpty();\n-        assertTrue(\"Empty map toString() should not return null\", \n-                   map.toString() != null);\n-        verify();\n-\n-        resetFull();\n-        assertTrue(\"Empty map toString() should not return null\", \n-                   map.toString() != null);\n-        verify();\n-    }\n-\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+    }\n \n     /**\n      * Compare the current serialized form of the Map\n      * against the canonical version in SVN.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testEmptyMapCompatibility() throws Exception {\n         /**\n          * Create canonical objects with this code\n         Map map = makeEmptyMap();\n         if (!(map instanceof Serializable)) return;\n-        \n+\n         writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));\n         */\n \n         // test to make sure the canonical form has been preserved\n-        Map map = makeEmptyMap();\n+        Map map = makeObject();\n         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n             Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n             assertEquals(\"Map is empty\", 0, map2.size());\n      * Compare the current serialized form of the Map\n      * against the canonical version in SVN.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testFullMapCompatibility() throws Exception {\n         /**\n          * Create canonical objects with this code\n         Map map = makeFullMap();\n         if (!(map instanceof Serializable)) return;\n-        \n+\n         writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));\n         */\n \n      */\n     public void testMapPut() {\n         resetEmpty();\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        Object[] newValues = getNewSampleValues();\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        V[] newValues = getNewSampleValues();\n \n         if (isPutAddSupported()) {\n             for (int i = 0; i < keys.length; i++) {\n-                Object o = map.put(keys[i], values[i]);\n-                confirmed.put(keys[i], values[i]);\n+                Object o = getMap().put(keys[i], values[i]);\n+                getConfirmed().put(keys[i], values[i]);\n                 verify();\n                 assertTrue(\"First map.put should return null\", o == null);\n-                assertTrue(\"Map should contain key after put\", \n-                           map.containsKey(keys[i]));\n-                assertTrue(\"Map should contain value after put\", \n-                           map.containsValue(values[i]));\n+                assertTrue(\"Map should contain key after put\",\n+                        getMap().containsKey(keys[i]));\n+                assertTrue(\"Map should contain value after put\",\n+                        getMap().containsValue(values[i]));\n             }\n             if (isPutChangeSupported()) {\n                 for (int i = 0; i < keys.length; i++) {\n-                    Object o = map.put(keys[i], newValues[i]);\n-                    confirmed.put(keys[i], newValues[i]);\n+                    Object o = getMap().put(keys[i], newValues[i]);\n+                    getConfirmed().put(keys[i], newValues[i]);\n                     verify();\n-                    assertEquals(\"Map.put should return previous value when changed\",\n-                                 values[i], o);\n+                    assertEquals(\"Map.put should return previous value when changed\", values[i], o);\n                     assertTrue(\"Map should still contain key after put when changed\",\n-                               map.containsKey(keys[i]));\n+                            getMap().containsKey(keys[i]));\n                     assertTrue(\"Map should contain new value after put when changed\",\n-                               map.containsValue(newValues[i]));\n-        \n+                            getMap().containsValue(newValues[i]));\n+\n                     // if duplicates are allowed, we're not guaranteed that the value\n                     // no longer exists, so don't try checking that.\n                     if (!isAllowDuplicateValues()) {\n                         assertTrue(\"Map should not contain old value after put when changed\",\n-                                   !map.containsValue(values[i]));\n+                                !getMap().containsValue(values[i]));\n                     }\n                 }\n             } else {\n                 try {\n                     // two possible exception here, either valid\n-                    map.put(keys[0], newValues[0]);\n+                    getMap().put(keys[0], newValues[0]);\n                     fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n                 } catch (IllegalArgumentException ex) {\n                 } catch (UnsupportedOperationException ex) {}\n             }\n-            \n+\n         } else if (isPutChangeSupported()) {\n             resetEmpty();\n             try {\n-                map.put(keys[0], values[0]);\n+                getMap().put(keys[0], values[0]);\n                 fail(\"Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size\");\n             } catch (IllegalArgumentException ex) {\n             } catch (UnsupportedOperationException ex) {\n             }\n-            \n+\n             resetFull();\n             int i = 0;\n-            for (Iterator it = map.keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n-                Object key = it.next();\n-                Object o = map.put(key, newValues[i]);\n-                Object value = confirmed.put(key, newValues[i]);\n+            for (Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n+                K  key = it.next();\n+                V o = getMap().put(key, newValues[i]);\n+                V value = getConfirmed().put(key, newValues[i]);\n                 verify();\n-                assertEquals(\"Map.put should return previous value when changed\",\n-                    value, o);\n-                assertTrue(\"Map should still contain key after put when changed\",\n-                    map.containsKey(key));\n-                assertTrue(\"Map should contain new value after put when changed\",\n-                    map.containsValue(newValues[i]));\n-        \n+                assertEquals(\"Map.put should return previous value when changed\", value, o);\n+                assertTrue(\"Map should still contain key after put when changed\", getMap()\n+                        .containsKey(key));\n+                assertTrue(\"Map should contain new value after put when changed\", getMap()\n+                        .containsValue(newValues[i]));\n+\n                 // if duplicates are allowed, we're not guaranteed that the value\n                 // no longer exists, so don't try checking that.\n                 if (!isAllowDuplicateValues()) {\n                     assertTrue(\"Map should not contain old value after put when changed\",\n-                        !map.containsValue(values[i]));\n+                        !getMap().containsValue(values[i]));\n                 }\n             }\n         } else {\n             try {\n-                map.put(keys[0], values[0]);\n+                getMap().put(keys[0], values[0]);\n                 fail(\"Expected UnsupportedOperationException on put (add)\");\n             } catch (UnsupportedOperationException ex) {}\n         }\n      */\n     public void testMapPutNullKey() {\n         resetFull();\n-        Object[] values = getSampleValues();\n-    \n+        V[] values = getSampleValues();\n+\n         if (isPutAddSupported()) {\n             if (isAllowNullKey()) {\n-                map.put(null, values[0]);\n+                getMap().put(null, values[0]);\n             } else {\n                 try {\n-                    map.put(null, values[0]);\n+                    getMap().put(null, values[0]);\n                     fail(\"put(null, value) should throw NPE/IAE\");\n                 } catch (NullPointerException ex) {\n                 } catch (IllegalArgumentException ex) {}\n             }\n         }\n     }\n-    \n+\n     /**\n      * Tests Map.put(null, value)\n      */\n     public void testMapPutNullValue() {\n         resetFull();\n-        Object[] keys = getSampleKeys();\n-        \n+        K[] keys = getSampleKeys();\n+\n         if (isPutAddSupported()) {\n             if (isAllowNullValue()) {\n-                map.put(keys[0], null);\n+                getMap().put(keys[0], null);\n             } else {\n                 try {\n-                    map.put(keys[0], null);\n+                    getMap().put(keys[0], null);\n                     fail(\"put(key, null) should throw NPE/IAE\");\n                 } catch (NullPointerException ex) {\n                 } catch (IllegalArgumentException ex) {}\n             }\n         }\n     }\n-    \n+\n     /**\n      * Tests Map.putAll(map)\n      */\n     public void testMapPutAll() {\n         if (!isPutAddSupported()) {\n             if (!isPutChangeSupported()) {\n-                Map temp = makeFullMap();\n+                Map<K, V> temp = makeFullMap();\n                 resetEmpty();\n                 try {\n-                    map.putAll(temp);\n+                    getMap().putAll(temp);\n                     fail(\"Expected UnsupportedOperationException on putAll\");\n                 } catch (UnsupportedOperationException ex) {}\n             }\n \n         // check putAll OK adding empty map to empty map\n         resetEmpty();\n-        assertEquals(0, map.size());\n-        map.putAll(new HashMap());\n-        assertEquals(0, map.size());\n+        assertEquals(0, getMap().size());\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(0, getMap().size());\n \n         // check putAll OK adding empty map to non-empty map\n         resetFull();\n-        int size = map.size();\n-        map.putAll(new HashMap());\n-        assertEquals(size, map.size());\n+        int size = getMap().size();\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(size, getMap().size());\n \n         // check putAll OK adding non-empty map to empty map\n         resetEmpty();\n-        Map m2 = makeFullMap();\n-        map.putAll(m2);\n-        confirmed.putAll(m2);\n+        Map<K, V> m2 = makeFullMap();\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n         verify();\n \n         // check putAll OK adding non-empty JDK map to empty map\n         resetEmpty();\n         m2 = makeConfirmedMap();\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n         for(int i = 0; i < keys.length; i++) {\n             m2.put(keys[i], values[i]);\n         }\n-        map.putAll(m2);\n-        confirmed.putAll(m2);\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n         verify();\n \n         // check putAll OK adding non-empty JDK map to non-empty map\n         resetEmpty();\n         m2 = makeConfirmedMap();\n-        map.put(keys[0], values[0]);\n-        confirmed.put(keys[0], values[0]);\n+        getMap().put(keys[0], values[0]);\n+        getConfirmed().put(keys[0], values[0]);\n         verify();\n         for(int i = 1; i < keys.length; i++) {\n             m2.put(keys[i], values[i]);\n         }\n-        map.putAll(m2);\n-        confirmed.putAll(m2);\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n         verify();\n     }\n \n         if (!isRemoveSupported()) {\n             try {\n                 resetFull();\n-                map.remove(map.keySet().iterator().next());\n+                getMap().remove(getMap().keySet().iterator().next());\n                 fail(\"Expected UnsupportedOperationException on remove\");\n             } catch (UnsupportedOperationException ex) {}\n             return;\n \n         Object[] keys = getSampleKeys();\n         Object[] values = getSampleValues();\n-        for(int i = 0; i < keys.length; i++) {\n-            Object o = map.remove(keys[i]);\n+        for (int i = 0; i < keys.length; i++) {\n+            Object o = getMap().remove(keys[i]);\n             assertTrue(\"First map.remove should return null\", o == null);\n         }\n         verify();\n \n         resetFull();\n \n-        for(int i = 0; i < keys.length; i++) {\n-            Object o = map.remove(keys[i]);\n-            confirmed.remove(keys[i]);\n+        for (int i = 0; i < keys.length; i++) {\n+            Object o = getMap().remove(keys[i]);\n+            getConfirmed().remove(keys[i]);\n             verify();\n \n             assertEquals(\"map.remove with valid key should return value\",\n         Object[] other = getOtherKeys();\n \n         resetFull();\n-        int size = map.size();\n+        int size = getMap().size();\n         for (int i = 0; i < other.length; i++) {\n-            Object o = map.remove(other[i]);\n+            Object o = getMap().remove(other[i]);\n             assertNull(\"map.remove for nonexistent key should return null\", o);\n             assertEquals(\"map.remove for nonexistent key should not \" +\n-                         \"shrink map\", size, map.size());\n+                         \"shrink map\", size, getMap().size());\n         }\n         verify();\n     }\n      */\n     public void testValuesClearChangesMap() {\n         if (!isRemoveSupported()) return;\n-        \n+\n         // clear values, reflected in map\n         resetFull();\n-        Collection values = map.values();\n-        assertTrue(map.size() > 0);\n+        Collection<V> values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n         assertTrue(values.size() > 0);\n         values.clear();\n-        assertTrue(map.size() == 0);\n+        assertTrue(getMap().size() == 0);\n         assertTrue(values.size() == 0);\n-        \n+\n         // clear map, reflected in values\n         resetFull();\n-        values = map.values();\n-        assertTrue(map.size() > 0);\n+        values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n         assertTrue(values.size() > 0);\n-        map.clear();\n-        assertTrue(map.size() == 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n         assertTrue(values.size() == 0);\n     }\n-    \n+\n     /**\n      * Tests that the {@link Map#keySet} collection is backed by\n      * the underlying map for clear().\n      */\n     public void testKeySetClearChangesMap() {\n         if (!isRemoveSupported()) return;\n-        \n+\n         // clear values, reflected in map\n         resetFull();\n-        Set keySet = map.keySet();\n-        assertTrue(map.size() > 0);\n+        Set<K> keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n         assertTrue(keySet.size() > 0);\n         keySet.clear();\n-        assertTrue(map.size() == 0);\n+        assertTrue(getMap().size() == 0);\n         assertTrue(keySet.size() == 0);\n-        \n+\n         // clear map, reflected in values\n         resetFull();\n-        keySet = map.keySet();\n-        assertTrue(map.size() > 0);\n+        keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n         assertTrue(keySet.size() > 0);\n-        map.clear();\n-        assertTrue(map.size() == 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n         assertTrue(keySet.size() == 0);\n     }\n-    \n+\n     /**\n      * Tests that the {@link Map#entrySet()} collection is backed by\n      * the underlying map for clear().\n      */\n     public void testEntrySetClearChangesMap() {\n         if (!isRemoveSupported()) return;\n-        \n+\n         // clear values, reflected in map\n         resetFull();\n-        Set entrySet = map.entrySet();\n-        assertTrue(map.size() > 0);\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n         assertTrue(entrySet.size() > 0);\n         entrySet.clear();\n-        assertTrue(map.size() == 0);\n+        assertTrue(getMap().size() == 0);\n         assertTrue(entrySet.size() == 0);\n-        \n+\n         // clear map, reflected in values\n         resetFull();\n-        entrySet = map.entrySet();\n-        assertTrue(map.size() > 0);\n+        entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n         assertTrue(entrySet.size() > 0);\n-        map.clear();\n-        assertTrue(map.size() == 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n         assertTrue(entrySet.size() == 0);\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     public void testEntrySetContains1() {\n         resetFull();\n-        Set entrySet = map.entrySet();\n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n         assertEquals(true, entrySet.contains(entry));\n     }\n+\n     public void testEntrySetContains2() {\n         resetFull();\n-        Set entrySet = map.entrySet();\n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n-        Map.Entry test = cloneMapEntry(entry);\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        Map.Entry<K, V> test = cloneMapEntry(entry);\n         assertEquals(true, entrySet.contains(test));\n     }\n+    \n+    @SuppressWarnings(\"unchecked\")\n     public void testEntrySetContains3() {\n         resetFull();\n-        Set entrySet = map.entrySet();\n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n-        HashMap temp = new HashMap();\n-        temp.put(entry.getKey(), \"A VERY DIFFERENT VALUE\");\n-        Map.Entry test = (Map.Entry) temp.entrySet().iterator().next();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n         assertEquals(false, entrySet.contains(test));\n     }\n-    \n+\n     public void testEntrySetRemove1() {\n         if (!isRemoveSupported()) return;\n         resetFull();\n-        int size = map.size();\n-        Set entrySet = map.entrySet();\n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n-        Object key = entry.getKey();\n-        \n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+\n         assertEquals(true, entrySet.remove(entry));\n-        assertEquals(false, map.containsKey(key));\n-        assertEquals(size - 1, map.size());\n-    }            \n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n     public void testEntrySetRemove2() {\n         if (!isRemoveSupported()) return;\n         resetFull();\n-        int size = map.size();\n-        Set entrySet = map.entrySet();\n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n-        Object key = entry.getKey();\n-        Map.Entry test = cloneMapEntry(entry);\n-        \n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+        Map.Entry<K, V> test = cloneMapEntry(entry);\n+\n         assertEquals(true, entrySet.remove(test));\n-        assertEquals(false, map.containsKey(key));\n-        assertEquals(size - 1, map.size());\n-    }\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testEntrySetRemove3() {\n         if (!isRemoveSupported()) return;\n         resetFull();\n-        int size = map.size();\n-        Set entrySet = map.entrySet();\n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n-        Object key = entry.getKey();\n-        HashMap temp = new HashMap();\n-        temp.put(entry.getKey(), \"A VERY DIFFERENT VALUE\");\n-        Map.Entry test = (Map.Entry) temp.entrySet().iterator().next();\n-        \n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+        HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+\n         assertEquals(false, entrySet.remove(test));\n-        assertEquals(true, map.containsKey(key));\n-        assertEquals(size, map.size());\n-    }\n-    \n+        assertEquals(true, getMap().containsKey(key));\n+        assertEquals(size, getMap().size());\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Tests that the {@link Map#values} collection is backed by\n      */\n     public void testValuesRemoveChangesMap() {\n         resetFull();\n-        Object[] sampleValues = getSampleValues();\n-        Collection values = map.values();\n+        V[] sampleValues = getSampleValues();\n+        Collection<V> values = getMap().values();\n         for (int i = 0; i < sampleValues.length; i++) {\n             if (map.containsValue(sampleValues[i])) {\n                 int j = 0;  // loop counter prevents infinite loops when remove is broken\n                 assertTrue(\"values().remove(obj) is broken\", j < 10000);\n                 assertTrue(\n                     \"Value should have been removed from the underlying map.\",\n-                    !map.containsValue(sampleValues[i]));\n+                    !getMap().containsValue(sampleValues[i]));\n             }\n         }\n     }\n      */\n     public void testKeySetRemoveChangesMap() {\n         resetFull();\n-        Object[] sampleKeys = getSampleKeys();\n-        Set keys = map.keySet();\n+        K[] sampleKeys = getSampleKeys();\n+        Set<K> keys = getMap().keySet();\n         for (int i = 0; i < sampleKeys.length; i++) {\n             try {\n                 keys.remove(sampleKeys[i]);\n             }\n             assertTrue(\n                 \"Key should have been removed from the underlying map.\",\n-                !map.containsKey(sampleKeys[i]));\n+                !getMap().containsKey(sampleKeys[i]));\n         }\n     }\n \n      * @param values  the array of values\n      * @return an array of Map.Entry of those keys to those values\n      */\n-    private Map.Entry[] makeEntryArray(Object[] keys, Object[] values) {\n-        Map.Entry[] result = new Map.Entry[keys.length];\n+    @SuppressWarnings(\"unchecked\")\n+    private Map.Entry<K, V>[] makeEntryArray(K[] keys, V[] values) {\n+        Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n         for (int i = 0; i < keys.length; i++) {\n-            Map map = makeConfirmedMap();\n+            Map<K, V> map = makeConfirmedMap();\n             map.put(keys[i], values[i]);\n-            result[i] = (Map.Entry) map.entrySet().iterator().next();\n+            result[i] = map.entrySet().iterator().next();\n         }\n         return result;\n     }\n-\n \n     /**\n      * Bulk test {@link Map#entrySet()}.  This method runs through all of\n         return new TestMapEntrySet();\n     }\n \n-    public class TestMapEntrySet extends AbstractTestSet {\n+    public class TestMapEntrySet extends AbstractTestSet<Map.Entry<K, V>> {\n         public TestMapEntrySet() {\n             super(\"MapEntrySet\");\n         }\n \n         // Have to implement manually; entrySet doesn't support addAll\n-        public Object[] getFullElements() {\n-            Object[] k = getSampleKeys();\n-            Object[] v = getSampleValues();\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Entry<K, V>[] getFullElements() {\n+            return getFullNonNullElements();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Map.Entry<K, V>[] getFullNonNullElements() {\n+            K[] k = getSampleKeys();\n+            V[] v = getSampleValues();\n             return makeEntryArray(k, v);\n         }\n-        \n+\n         // Have to implement manually; entrySet doesn't support addAll\n-        public Object[] getOtherElements() {\n-            Object[] k = getOtherKeys();\n-            Object[] v = getOtherValues();\n+        public Map.Entry<K, V>[] getOtherElements() {\n+            K[] k = getOtherKeys();\n+            V[] v = getOtherValues();\n             return makeEntryArray(k, v);\n         }\n-        \n-        public Set makeEmptySet() {\n-            return makeEmptyMap().entrySet();\n-        }\n-        \n-        public Set makeFullSet() {\n+\n+        public Set<Map.Entry<K, V>> makeObject() {\n+            return AbstractTestMap.this.makeObject().entrySet();\n+        }\n+\n+        public Set<Map.Entry<K, V>> makeFullCollection() {\n             return makeFullMap().entrySet();\n         }\n-        \n+\n         public boolean isAddSupported() {\n             // Collection views don't support add operations.\n             return false;\n         }\n+\n         public boolean isRemoveSupported() {\n             // Entry set should only support remove if map does\n             return AbstractTestMap.this.isRemoveSupported();\n         }\n+\n         public boolean isGetStructuralModify() {\n             return AbstractTestMap.this.isGetStructuralModify();\n         }\n+        \n         public boolean isTestSerialization() {\n             return false;\n         }\n \n         public void resetFull() {\n             AbstractTestMap.this.resetFull();\n-            collection = map.entrySet();\n-            TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();\n-        }\n-        \n+            setCollection(AbstractTestMap.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().entrySet());\n+        }\n+\n         public void resetEmpty() {\n             AbstractTestMap.this.resetEmpty();\n-            collection = map.entrySet();\n-            TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();\n-        }\n-        \n+            setCollection(AbstractTestMap.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().entrySet());\n+        }\n+\n         public void testMapEntrySetIteratorEntry() {\n             resetFull();\n-            Iterator it = collection.iterator();\n+            Iterator<Map.Entry<K, V>> it = getCollection().iterator();\n             int count = 0;\n             while (it.hasNext()) {\n-                Map.Entry entry = (Map.Entry) it.next();\n-                assertEquals(true, AbstractTestMap.this.map.containsKey(entry.getKey()));\n-                assertEquals(true, AbstractTestMap.this.map.containsValue(entry.getValue()));\n+                Map.Entry<K, V> entry = it.next();\n+                assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry.getKey()));\n+                assertEquals(true, AbstractTestMap.this.getMap().containsValue(entry.getValue()));\n                 if (isGetStructuralModify() == false) {\n-                    assertEquals(AbstractTestMap.this.map.get(entry.getKey()), entry.getValue());\n+                    assertEquals(AbstractTestMap.this.getMap().get(entry.getKey()), entry.getValue());\n                 }\n                 count++;\n             }\n-            assertEquals(collection.size(), count);\n+            assertEquals(getCollection().size(), count);\n         }\n \n         public void testMapEntrySetIteratorEntrySetValue() {\n-            Object key1 = getSampleKeys()[0];\n-            Object key2 = (getSampleKeys().length ==1 ? getSampleKeys()[0] : getSampleKeys()[1]);\n-            Object newValue1 = getNewSampleValues()[0];\n-            Object newValue2 = (getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1]);\n-            \n+            K key1 = getSampleKeys()[0];\n+            K key2 = (getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1]);\n+            V newValue1 = getNewSampleValues()[0];\n+            V newValue2 = (getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1]);\n+\n             resetFull();\n             // explicitly get entries as sample values/keys are connected for some maps\n             // such as BeanMap\n-            Iterator it = TestMapEntrySet.this.collection.iterator();\n-            Map.Entry entry1 = getEntry(it, key1);\n-            it = TestMapEntrySet.this.collection.iterator();\n-            Map.Entry entry2 = getEntry(it, key2);\n-            Iterator itConfirmed = TestMapEntrySet.this.confirmed.iterator();\n-            Map.Entry entryConfirmed1 = getEntry(itConfirmed, key1);\n-            itConfirmed = TestMapEntrySet.this.confirmed.iterator();\n-            Map.Entry entryConfirmed2 = getEntry(itConfirmed, key2);\n+            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n             verify();\n-            \n+\n             if (isSetValueSupported() == false) {\n                 try {\n                     entry1.setValue(newValue1);\n                 }\n                 return;\n             }\n-            \n+\n             entry1.setValue(newValue1);\n             entryConfirmed1.setValue(newValue1);\n             assertEquals(newValue1, entry1.getValue());\n-            assertEquals(true, AbstractTestMap.this.map.containsKey(entry1.getKey()));\n-            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue1));\n-            assertEquals(newValue1, AbstractTestMap.this.map.get(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestMap.this.getMap().get(entry1.getKey()));\n             verify();\n-            \n+\n             entry1.setValue(newValue1);\n             entryConfirmed1.setValue(newValue1);\n             assertEquals(newValue1, entry1.getValue());\n-            assertEquals(true, AbstractTestMap.this.map.containsKey(entry1.getKey()));\n-            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue1));\n-            assertEquals(newValue1, AbstractTestMap.this.map.get(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestMap.this.getMap().get(entry1.getKey()));\n             verify();\n-            \n+\n             entry2.setValue(newValue2);\n             entryConfirmed2.setValue(newValue2);\n             assertEquals(newValue2, entry2.getValue());\n-            assertEquals(true, AbstractTestMap.this.map.containsKey(entry2.getKey()));\n-            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue2));\n-            assertEquals(newValue2, AbstractTestMap.this.map.get(entry2.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsValue(newValue2));\n+            assertEquals(newValue2, AbstractTestMap.this.getMap().get(entry2.getKey()));\n             verify();\n         }\n-        \n-        public Map.Entry getEntry(Iterator itConfirmed, Object key) {\n-            Map.Entry entry = null;\n+\n+        public Map.Entry<K, V> getEntry(Iterator<Map.Entry<K, V>> itConfirmed, K key) {\n+            Map.Entry<K, V> entry = null;\n             while (itConfirmed.hasNext()) {\n-                Map.Entry temp = (Map.Entry) itConfirmed.next();\n+                Map.Entry<K, V> temp = itConfirmed.next();\n                 if (temp.getKey() == null) {\n                     if (key == null) {\n                         entry = temp;\n         public void testMapEntrySetRemoveNonMapEntry() {\n             if (isRemoveSupported() == false) return;\n             resetFull();\n-            assertEquals(false, getSet().remove(null));\n-            assertEquals(false, getSet().remove(new Object()));\n-        }\n-        \n+            assertEquals(false, getCollection().remove(null));\n+            assertEquals(false, getCollection().remove(new Object()));\n+        }\n+\n         public void verify() {\n             super.verify();\n             AbstractTestMap.this.verify();\n         return new TestMapKeySet();\n     }\n \n-    public class TestMapKeySet extends AbstractTestSet {\n+    public class TestMapKeySet extends AbstractTestSet<K> {\n         public TestMapKeySet() {\n             super(\"\");\n         }\n-        public Object[] getFullElements() {\n+\n+        public K[] getFullElements() {\n             return getSampleKeys();\n         }\n-        \n-        public Object[] getOtherElements() {\n+\n+        public K[] getOtherElements() {\n             return getOtherKeys();\n         }\n-        \n-        public Set makeEmptySet() {\n-            return makeEmptyMap().keySet();\n-        }\n-        \n-        public Set makeFullSet() {\n-            return makeFullMap().keySet();\n-        }\n-        \n+\n+        public Set<K> makeObject() {\n+            return AbstractTestMap.this.makeObject().keySet();\n+        }\n+\n+        public Set<K> makeFullCollection() {\n+            return AbstractTestMap.this.makeFullMap().keySet();\n+        }\n+\n         public boolean isNullSupported() {\n             return AbstractTestMap.this.isAllowNullKey();\n         }\n+\n         public boolean isAddSupported() {\n             return false;\n         }\n+        \n         public boolean isRemoveSupported() {\n             return AbstractTestMap.this.isRemoveSupported();\n         }\n+        \n         public boolean isTestSerialization() {\n             return false;\n         }\n-        \n+\n         public void resetEmpty() {\n             AbstractTestMap.this.resetEmpty();\n-            collection = map.keySet();\n-            TestMapKeySet.this.confirmed = AbstractTestMap.this.confirmed.keySet();\n-        }\n-        \n+            setCollection(AbstractTestMap.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().keySet());\n+        }\n+\n         public void resetFull() {\n             AbstractTestMap.this.resetFull();\n-            collection = map.keySet();\n-            TestMapKeySet.this.confirmed = AbstractTestMap.this.confirmed.keySet();\n-        }\n-        \n+            setCollection(AbstractTestMap.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().keySet());\n+        }\n+\n         public void verify() {\n             super.verify();\n             AbstractTestMap.this.verify();\n         }\n     }\n-\n \n     /**\n      * Bulk test {@link Map#values()}.  This method runs through all of\n         return new TestMapValues();\n     }\n \n-    public class TestMapValues extends AbstractTestCollection {\n+    public class TestMapValues extends AbstractTestCollection<V> {\n         public TestMapValues() {\n             super(\"\");\n         }\n \n-        public Object[] getFullElements() {\n+        public V[] getFullElements() {\n             return getSampleValues();\n         }\n-        \n-        public Object[] getOtherElements() {\n+\n+        public V[] getOtherElements() {\n             return getOtherValues();\n         }\n-        \n-        public Collection makeCollection() {\n-            return makeEmptyMap().values();\n-        }\n-        \n-        public Collection makeFullCollection() {\n-            return makeFullMap().values();\n-        }\n-        \n+\n+        public Collection<V> makeObject() {\n+            return AbstractTestMap.this.makeObject().values();\n+        }\n+\n+        public Collection<V> makeFullCollection() {\n+            return AbstractTestMap.this.makeFullMap().values();\n+        }\n+\n         public boolean isNullSupported() {\n             return AbstractTestMap.this.isAllowNullKey();\n         }\n+\n         public boolean isAddSupported() {\n             return false;\n         }\n+\n         public boolean isRemoveSupported() {\n             return AbstractTestMap.this.isRemoveSupported();\n         }\n+        \n         public boolean isTestSerialization() {\n             return false;\n         }\n-        \n+\n         public boolean areEqualElementsDistinguishable() {\n             // equal values are associated with different keys, so they are\n-            // distinguishable.  \n+            // distinguishable.\n             return true;\n         }\n \n-        public Collection makeConfirmedCollection() {\n+        public Collection<V> makeConfirmedCollection() {\n             // never gets called, reset methods are overridden\n             return null;\n         }\n-        \n-        public Collection makeConfirmedFullCollection() {\n+\n+        public Collection<V> makeConfirmedFullCollection() {\n             // never gets called, reset methods are overridden\n             return null;\n         }\n-        \n+\n         public void resetFull() {\n             AbstractTestMap.this.resetFull();\n-            collection = map.values();\n-            TestMapValues.this.confirmed = AbstractTestMap.this.confirmed.values();\n-        }\n-        \n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractTestMap.this.getConfirmed().values());\n+        }\n+\n         public void resetEmpty() {\n             AbstractTestMap.this.resetEmpty();\n-            collection = map.values();\n-            TestMapValues.this.confirmed = AbstractTestMap.this.confirmed.values();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractTestMap.this.getConfirmed().values());\n         }\n \n         public void verify() {\n      * {@link #values} and {@link #confirmed} fields to empty.\n      */\n     public void resetEmpty() {\n-        this.map = makeEmptyMap();\n+        this.map = makeObject();\n         views();\n         this.confirmed = makeConfirmedMap();\n     }\n         this.map = makeFullMap();\n         views();\n         this.confirmed = makeConfirmedMap();\n-        Object[] k = getSampleKeys();\n-        Object[] v = getSampleValues();\n+        K[] k = getSampleKeys();\n+        V[] v = getSampleValues();\n         for (int i = 0; i < k.length; i++) {\n             confirmed.put(k[i], v[i]);\n         }\n     }\n \n-\n     /**\n      * Resets the collection view fields.\n      */\n     private void views() {\n-        this.keySet = map.keySet();\n-        this.values = map.values();\n-        this.entrySet = map.entrySet();\n-    }\n-\n+        this.keySet = getMap().keySet();\n+        this.values = getMap().values();\n+        this.entrySet = getMap().entrySet();\n+    }\n \n     /**\n      * Verifies that {@link #map} is still equal to {@link #confirmed}.\n-     * This method checks that the map is equal to the HashMap, \n+     * This method checks that the map is equal to the HashMap,\n      * <I>and</I> that the map's collection views are still equal to\n      * the HashMap's collection views.  An <Code>equals</Code> test\n      * is done on the maps and their collection views; their size and\n      * <Code>isEmpty</Code> results are compared; their hashCodes are\n-     * compared; and <Code>containsAll</Code> tests are run on the \n+     * compared; and <Code>containsAll</Code> tests are run on the\n      * collection views.\n      */\n     public void verify() {\n     }\n \n     public void verifyMap() {\n-        int size = confirmed.size();\n-        boolean empty = confirmed.isEmpty();\n-        assertEquals(\"Map should be same size as HashMap\", \n-                     size, map.size());\n-        assertEquals(\"Map should be empty if HashMap is\", \n-                     empty, map.isEmpty());\n-        assertEquals(\"hashCodes should be the same\",\n-                     confirmed.hashCode(), map.hashCode());\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"Map should be same size as HashMap\", size, getMap().size());\n+        assertEquals(\"Map should be empty if HashMap is\", empty, getMap().isEmpty());\n+        assertEquals(\"hashCodes should be the same\", getConfirmed().hashCode(), getMap().hashCode());\n         // this fails for LRUMap because confirmed.equals() somehow modifies\n         // map, causing concurrent modification exceptions.\n         //assertEquals(\"Map should still equal HashMap\", confirmed, map);\n         // this works though and performs the same verification:\n-        assertTrue(\"Map should still equal HashMap\", map.equals(confirmed));\n+        assertTrue(\"Map should still equal HashMap\", getMap().equals(getConfirmed()));\n         // TODO: this should really be reexamined to figure out why LRU map\n         // behaves like it does (the equals shouldn't modify since all accesses\n         // by the confirmed collection should be through an iterator, thus not\n     }\n \n     public void verifyEntrySet() {\n-        int size = confirmed.size();\n-        boolean empty = confirmed.isEmpty();\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"entrySet should be same size as HashMap's\" +\n-                     \"\\nTest: \" + entrySet + \"\\nReal: \" + confirmed.entrySet(),\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n                      size, entrySet.size());\n         assertEquals(\"entrySet should be empty if HashMap is\" +\n-                     \"\\nTest: \" + entrySet + \"\\nReal: \" + confirmed.entrySet(),\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n                      empty, entrySet.isEmpty());\n         assertTrue(\"entrySet should contain all HashMap's elements\" +\n-                   \"\\nTest: \" + entrySet + \"\\nReal: \" + confirmed.entrySet(),\n-                   entrySet.containsAll(confirmed.entrySet()));\n+                   \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                   entrySet.containsAll(getConfirmed().entrySet()));\n         assertEquals(\"entrySet hashCodes should be the same\" +\n-                     \"\\nTest: \" + entrySet + \"\\nReal: \" + confirmed.entrySet(),\n-                     confirmed.entrySet().hashCode(), entrySet.hashCode());\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     getConfirmed().entrySet().hashCode(), entrySet.hashCode());\n         assertEquals(\"Map's entry set should still equal HashMap's\",\n-                     confirmed.entrySet(), entrySet);\n-    }\n-\n-    public void verifyKeySet() { \n-        int size = confirmed.size();\n-        boolean empty = confirmed.isEmpty();\n+                     getConfirmed().entrySet(), entrySet);\n+    }\n+\n+    public void verifyKeySet() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"keySet should be same size as HashMap's\" +\n-                     \"\\nTest: \" + keySet + \"\\nReal: \" + confirmed.keySet(),\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n                      size, keySet.size());\n         assertEquals(\"keySet should be empty if HashMap is\" +\n-                     \"\\nTest: \" + keySet + \"\\nReal: \" + confirmed.keySet(),\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n                      empty, keySet.isEmpty());\n         assertTrue(\"keySet should contain all HashMap's elements\" +\n-                   \"\\nTest: \" + keySet + \"\\nReal: \" + confirmed.keySet(),\n-                   keySet.containsAll(confirmed.keySet()));\n+                   \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                   keySet.containsAll(getConfirmed().keySet()));\n         assertEquals(\"keySet hashCodes should be the same\" +\n-                     \"\\nTest: \" + keySet + \"\\nReal: \" + confirmed.keySet(),\n-                     confirmed.keySet().hashCode(), keySet.hashCode());\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     getConfirmed().keySet().hashCode(), keySet.hashCode());\n         assertEquals(\"Map's key set should still equal HashMap's\",\n-                     confirmed.keySet(), keySet);\n+                getConfirmed().keySet(), keySet);\n     }\n \n     public void verifyValues() {\n-        List known = new ArrayList(confirmed.values());\n-        List test = new ArrayList(values);\n-\n-        int size = confirmed.size();\n-        boolean empty = confirmed.isEmpty();\n+        List<V> known = new ArrayList<V>(getConfirmed().values());\n+        List<V> test = new ArrayList<V>(values);\n+\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"values should be same size as HashMap's\" +\n                      \"\\nTest: \" + test + \"\\nReal: \" + known,\n                      size, values.size());\n                    \"\\nTest: \" + test + \"\\nReal: \" + known,\n                    known.containsAll(test));\n         // originally coded to use a HashBag, but now separate jar so...\n-        for (Iterator it = known.iterator(); it.hasNext();) {\n+        for (Iterator<V> it = known.iterator(); it.hasNext();) {\n             boolean removed = test.remove(it.next());\n             assertTrue(\"Map's values should still equal HashMap's\", removed);\n         }\n         assertTrue(\"Map's values should still equal HashMap's\", test.isEmpty());\n     }\n-\n \n     /**\n      * Erases any leftover instance variables by setting them to null.\n         confirmed = null;\n     }\n \n+    /**\n+     * Get the map.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getMap() {\n+        return map;\n+    }\n+\n+    /**\n+     * Get the confirmed.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getConfirmed() {\n+        return confirmed;\n+    }\n }", "timestamp": 1252994241, "metainfo": ""}