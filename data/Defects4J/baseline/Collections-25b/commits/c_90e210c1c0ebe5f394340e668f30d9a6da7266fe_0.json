{"sha": "90e210c1c0ebe5f394340e668f30d9a6da7266fe", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r557435 | skestle | 2007-07-18 17:35:50 -0700 (Wed, 18 Jul 2007) | 1 line          Skipped failing SerializedCanonicalTests.  Marked code to be revisited through collections re-work.     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/test/org/apache/commons/collections/list/AbstractTestList.java\n+++ b/src/test/org/apache/commons/collections/list/AbstractTestList.java\n  * @author Stephen Colebourne\n  * @author Neil O'Toole\n  */\n-public abstract class AbstractTestList extends AbstractTestCollection {\n+public abstract class AbstractTestList<E> extends AbstractTestCollection<E> {\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractTestList(String testName) {\n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Returns true if the collections produced by \n+     *  Returns true if the collections produced by\n      *  {@link #makeCollection()} and {@link #makeFullCollection()}\n      *  support the <code>set operation.<p>\n      *  Default implementation returns true.  Override if your collection\n      *  Verifies that the test list implementation matches the confirmed list\n      *  implementation.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void verify() {\n         super.verify();\n \n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n \n         assertEquals(\"List should equal confirmed\", list1, list2);\n         assertEquals(\"Confirmed should equal list\", list2, list1);\n         assertEquals(\"Hash codes should be equal\", list1.hashCode(), list2.hashCode());\n \n         int i = 0;\n-        Iterator iterator1 = list1.iterator();\n-        Iterator iterator2 = list2.iterator();\n-        Object[] array = list1.toArray();\n+        Iterator<E> iterator1 = list1.iterator();\n+        Iterator<E> iterator2 = list2.iterator();\n+        E[] array = (E[]) list1.toArray();\n         while (iterator2.hasNext()) {\n             assertTrue(\"List iterator should have next\", iterator1.hasNext());\n             Object o1 = iterator1.next();\n     /**\n      * Returns an empty {@link ArrayList}.\n      */\n-    public Collection makeConfirmedCollection() {\n-        ArrayList list = new ArrayList();\n+    public Collection<E> makeConfirmedCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n         return list;\n     }\n \n     /**\n      * Returns a full {@link ArrayList}.\n      */\n-    public Collection makeConfirmedFullCollection() {\n-        ArrayList list = new ArrayList();\n-        list.addAll(Arrays.asList(getFullElements()));\n-        return list;\n-    }\n-\n-    /**\n-     * Return a new, empty {@link List} to be used for testing.\n-     *\n-     * @return an empty list for testing.\n-     */\n-    public abstract List makeEmptyList();\n-\n-    /**\n-     * Return a new, full {@link List} to be used for testing.\n-     *\n-     * @return a full list for testing\n-     */\n-    public List makeFullList() {\n-        // only works if list supports optional \"addAll(Collection)\" \n-        List list = makeEmptyList();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n      *\n      * @return an empty list to be used for testing\n      */\n-    public final Collection makeCollection() {\n-        return makeEmptyList();\n-    }\n-\n-    /**\n-     * Returns {@link #makeFullList()}.\n-     *\n-     * @return a full list to be used for testing\n-     */\n-    public final Collection makeFullCollection() {\n-        return makeFullList();\n+    public abstract List<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<E> makeFullCollection() {\n+        // only works if list supports optional \"addAll(Collection)\"\n+        List<E> list = makeObject();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n     }\n \n     //-----------------------------------------------------------------------\n      *\n      * @return the collection field as a List\n      */\n-    public List getList() {\n-        return (List) collection;\n+    @Override\n+    public List<E> getCollection() {\n+        return (List<E>) super.getCollection();\n     }\n \n     /**\n      *\n      * @return the confirmed field as a List\n      */\n-    public List getConfirmedList() {\n-        return (List) confirmed;\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n     }\n \n     //-----------------------------------------------------------------------\n             return;\n         }\n \n-        List list;\n-        Object element = getOtherElements()[0];\n-\n-        try {\n-            list = makeEmptyList();\n+        List<E> list;\n+        E element = getOtherElements()[0];\n+\n+        try {\n+            list = makeObject();\n             list.add(Integer.MIN_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n         } catch (IndexOutOfBoundsException e) {\n         }\n \n         try {\n-            list = makeEmptyList();\n+            list = makeObject();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n         } catch (IndexOutOfBoundsException e) {\n         }\n \n         try {\n-            list = makeEmptyList();\n+            list = makeObject();\n             list.add(1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n         } catch (IndexOutOfBoundsException e) {\n         }\n \n         try {\n-            list = makeEmptyList();\n+            list = makeObject();\n             list.add(Integer.MAX_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n         } catch (IndexOutOfBoundsException e) {\n             return;\n         }\n \n-        List list;\n-        Object element = getOtherElements()[0];\n-\n-        try {\n-            list = makeFullList();\n+        List<E> list;\n+        E element = getOtherElements()[0];\n+\n+        try {\n+            list = makeFullCollection();\n             list.add(Integer.MIN_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n         } catch (IndexOutOfBoundsException e) {\n         }\n \n         try {\n-            list = makeFullList();\n+            list = makeFullCollection();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n         } catch (IndexOutOfBoundsException e) {\n         }\n \n         try {\n-            list = makeFullList();\n+            list = makeFullCollection();\n             list.add(list.size() + 1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n         } catch (IndexOutOfBoundsException e) {\n         }\n \n         try {\n-            list = makeFullList();\n+            list = makeFullCollection();\n             list.add(Integer.MAX_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n         } catch (IndexOutOfBoundsException e) {\n             return;\n         }\n \n-        Object element = getOtherElements()[0];\n+        E element = getOtherElements()[0];\n         int max = getFullElements().length;\n \n         for (int i = 0; i <= max; i++) {\n             resetFull();\n-            ((List) collection).add(i, element);\n-            ((List) confirmed).add(i, element);\n+            ((List<E>) getCollection()).add(i, element);\n+            ((List<E>) getConfirmed()).add(i, element);\n             verify();\n         }\n     }\n      */\n     public void testListEquals() {\n         resetEmpty();\n-        List list = getList();\n-        assertEquals(\"Empty lists should be equal\", true, list.equals(confirmed));\n+        List<E> list = getCollection();\n+        assertEquals(\"Empty lists should be equal\", true, list.equals(getConfirmed()));\n         verify();\n         assertEquals(\"Empty list should equal self\", true, list.equals(list));\n         verify();\n \n-        List list2 = Arrays.asList(getFullElements());\n+        List<E> list2 = Arrays.asList(getFullElements());\n         assertEquals(\"Empty list shouldn't equal full\", false, list.equals(list2));\n         verify();\n \n         verify();\n \n         resetFull();\n-        list = getList();\n-        assertEquals(\"Full lists should be equal\", true, list.equals(confirmed));\n+        list = getCollection();\n+        assertEquals(\"Full lists should be equal\", true, list.equals(getConfirmed()));\n         verify();\n         assertEquals(\"Full list should equal self\", true, list.equals(list));\n         verify();\n \n-        list2 = makeEmptyList();\n+        list2 = makeObject();\n         assertEquals(\"Full list shouldn't equal empty\", false, list.equals(list2));\n         verify();\n \n         if (list2.size() < 2 && isAddSupported()) {\n             // main list is only size 1, so lets add other elements to get a better list\n             list.addAll(Arrays.asList(getOtherElements()));\n-            confirmed.addAll(Arrays.asList(getOtherElements()));\n-            list2 = new ArrayList(list2);\n+            getConfirmed().addAll(Arrays.asList(getOtherElements()));\n+            list2 = new ArrayList<E>(list2);\n             list2.addAll(Arrays.asList(getOtherElements()));\n         }\n         if (list2.size() > 1) {\n         }\n \n         resetFull();\n-        list = getList();\n+        list = getCollection();\n         assertEquals(\"List shouldn't equal String\", false, list.equals(\"\"));\n         verify();\n \n-        final List listForC = Arrays.asList(getFullElements());\n-        Collection c = new AbstractCollection() {\n+        final List<E> listForC = Arrays.asList(getFullElements());\n+        Collection<E> c = new AbstractCollection<E>() {\n             public int size() {\n                 return listForC.size();\n             }\n \n-            public Iterator iterator() {\n+            public Iterator<E> iterator() {\n                 return listForC.iterator();\n             }\n         };\n      */\n     public void testListHashCode() {\n         resetEmpty();\n-        int hash1 = collection.hashCode();\n-        int hash2 = confirmed.hashCode();\n+        int hash1 = getCollection().hashCode();\n+        int hash2 = getConfirmed().hashCode();\n         assertEquals(\"Empty lists should have equal hashCodes\", hash1, hash2);\n         verify();\n \n         resetFull();\n-        hash1 = collection.hashCode();\n-        hash2 = confirmed.hashCode();\n+        hash1 = getCollection().hashCode();\n+        hash2 = getConfirmed().hashCode();\n         assertEquals(\"Full lists should have equal hashCodes\", hash1, hash2);\n         verify();\n     }\n      */\n     public void testListGetByIndex() {\n         resetFull();\n-        List list = getList();\n-        Object[] elements = getFullElements();\n+        List<E> list = getCollection();\n+        E[] elements = getFullElements();\n         for (int i = 0; i < elements.length; i++) {\n             assertEquals(\"List should contain correct elements\", elements[i], list.get(i));\n             verify();\n      *  empty list.\n      */\n     public void testListGetByIndexBoundsChecking() {\n-        List list = makeEmptyList();\n+        List<E> list = makeObject();\n \n         try {\n             list.get(Integer.MIN_VALUE);\n      *  full list.\n      */\n     public void testListGetByIndexBoundsChecking2() {\n-        List list = makeFullList();\n+        List<E> list = makeFullCollection();\n \n         try {\n             list.get(Integer.MIN_VALUE);\n      */\n     public void testListIndexOf() {\n         resetFull();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Iterator iterator = list2.iterator();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        Iterator<E> iterator = list2.iterator();\n         while (iterator.hasNext()) {\n             Object element = iterator.next();\n             assertEquals(\"indexOf should return correct result\",\n             verify();\n         }\n \n-        Object[] other = getOtherElements();\n+        E[] other = getOtherElements();\n         for (int i = 0; i < other.length; i++) {\n             assertEquals(\"indexOf should return -1 for nonexistent element\",\n                 -1, list1.indexOf(other[i]));\n      */\n     public void testListLastIndexOf() {\n         resetFull();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Iterator iterator = list2.iterator();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        Iterator<E> iterator = list2.iterator();\n         while (iterator.hasNext()) {\n-            Object element = iterator.next();\n+            E element = iterator.next();\n             assertEquals(\"lastIndexOf should return correct result\",\n               list1.lastIndexOf(element), list2.lastIndexOf(element));\n             verify();\n         }\n \n-        Object[] other = getOtherElements();\n+        E[] other = getOtherElements();\n         for (int i = 0; i < other.length; i++) {\n             assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n                 \"element\", -1, list1.lastIndexOf(other[i]));\n             return;\n         }\n \n-        List list = makeEmptyList();\n-        Object element = getOtherElements()[0];\n+        List<E> list = makeObject();\n+        E element = getOtherElements()[0];\n \n         try {\n             list.set(Integer.MIN_VALUE, element);\n     public void testListSetByIndexBoundsChecking2() {\n         if (!isSetSupported()) return;\n \n-        List list = makeFullList();\n-        Object element = getOtherElements()[0];\n+        List<E> list = makeFullCollection();\n+        E element = getOtherElements()[0];\n \n         try {\n             list.set(Integer.MIN_VALUE, element);\n               \"[Integer.MIN_VALUE]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n+        }\n \n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n+        }\n \n         try {\n             list.set(getFullElements().length, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n+        }\n \n         try {\n             list.set(Integer.MAX_VALUE, element);\n               \"[Integer.MAX_VALUE]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n+        }\n     }\n \n \n         if (!isSetSupported()) return;\n \n         resetFull();\n-        Object[] elements = getFullElements();\n-        Object[] other = getOtherElements();\n+        E[] elements = getFullElements();\n+        E[] other = getOtherElements();\n \n         for (int i = 0; i < elements.length; i++) {\n-            Object n = other[i % other.length];\n-            Object v = ((List)collection).set(i, n);\n+            E n = other[i % other.length];\n+            E v = ((List<E>) getCollection()).set(i, n);\n             assertEquals(\"Set should return correct element\", elements[i], v);\n-            ((List)confirmed).set(i, n);\n+            ((List<E>) getConfirmed()).set(i, n);\n             verify();\n         }\n     }\n-\n \n     /**\n      *  If {@link #isSetSupported()} returns false, tests that set operation\n      */\n     public void testUnsupportedSet() {\n         if (isSetSupported()) return;\n-        \n-        resetFull();\n-        try {\n-            ((List) collection).set(0, new Object());\n+\n+        resetFull();\n+        try {\n+            ((List<E>) getCollection()).set(0, getFullElements()[0]);\n             fail(\"Emtpy collection should not support set.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         // thrown.\n         verify();\n     }\n-    \n \n     /**\n      *  Tests bounds checking for {@link List#remove(int)} on an\n     public void testListRemoveByIndexBoundsChecking() {\n         if (!isRemoveSupported()) return;\n \n-        List list = makeEmptyList();\n+        List<E> list = makeObject();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(0);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on a\n+     *  full list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking2() {\n+        if (!isRemoveSupported()) return;\n+\n+        List<E> list = makeFullCollection();\n \n         try {\n             list.remove(Integer.MIN_VALUE);\n               \"[Integer.MIN_VALUE]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n+        }\n \n         try {\n             list.remove(-1);\n             fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n-\n-        try {\n-            list.remove(0);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n+        }\n+\n+        try {\n+            list.remove(getFullElements().length);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } \n-\n-        try {\n-            list.remove(1);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n+        }\n \n         try {\n             list.remove(Integer.MAX_VALUE);\n \n \n     /**\n-     *  Tests bounds checking for {@link List#remove(int)} on a\n-     *  full list.\n-     */\n-    public void testListRemoveByIndexBoundsChecking2() {\n-        if (!isRemoveSupported()) return;\n-\n-        List list = makeFullList();\n-\n-        try {\n-            list.remove(Integer.MIN_VALUE);\n-            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(-1);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(getFullElements().length);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(Integer.MAX_VALUE);\n-            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-    }\n-\n-\n-    /**\n      *  Tests {@link List#remove(int)}.\n      */\n     public void testListRemoveByIndex() {\n         int max = getFullElements().length;\n         for (int i = 0; i < max; i++) {\n             resetFull();\n-            Object o1 = ((List)collection).remove(i);\n-            Object o2 = ((List)confirmed).remove(i);\n+            E o1 = ((List<E>) getCollection()).remove(i);\n+            E o2 = ((List<E>) getConfirmed()).remove(i);\n             assertEquals(\"remove should return correct element\", o1, o2);\n             verify();\n         }\n     }\n \n-\n     /**\n      *  Tests the read-only bits of {@link List#listIterator()}.\n      */\n     public void testListListIterator() {\n         resetFull();\n-        forwardTest(getList().listIterator(), 0);\n-        backwardTest(getList().listIterator(), 0);\n-    }\n-\n+        forwardTest(getCollection().listIterator(), 0);\n+        backwardTest(getCollection().listIterator(), 0);\n+    }\n \n     /**\n      *  Tests the read-only bits of {@link List#listIterator(int)}.\n     public void testListListIteratorByIndex() {\n         resetFull();\n         try {\n-            getList().listIterator(-1);\n+            getCollection().listIterator(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         resetFull();\n         try {\n-            getList().listIterator(getList().size() + 1);\n+            getCollection().listIterator(getCollection().size() + 1);\n         } catch (IndexOutOfBoundsException ex) {}\n         resetFull();\n-        for (int i = 0; i <= confirmed.size(); i++) {\n-            forwardTest(getList().listIterator(i), i);\n-            backwardTest(getList().listIterator(i), i);\n-        }\n-        resetFull();\n-        for (int i = 0; i <= confirmed.size(); i++) {\n-            backwardTest(getList().listIterator(i), i);\n+        for (int i = 0; i <= getConfirmed().size(); i++) {\n+            forwardTest(getCollection().listIterator(i), i);\n+            backwardTest(getCollection().listIterator(i), i);\n+        }\n+        resetFull();\n+        for (int i = 0; i <= getConfirmed().size(); i++) {\n+            backwardTest(getCollection().listIterator(i), i);\n         }\n     }\n \n     public void testListListIteratorPreviousRemoveNext() {\n         if (isRemoveSupported() == false) return;\n         resetFull();\n-        if (collection.size() < 4) return;\n-        ListIterator it = getList().listIterator();\n-        Object zero = it.next();\n-        Object one = it.next();\n-        Object two = it.next();\n-        Object two2 = it.previous();\n-        Object one2 = it.previous();\n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        E two2 = it.previous();\n+        E one2 = it.previous();\n         assertEquals(one, one2);\n         assertEquals(two, two2);\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(one, getList().get(1));\n-        assertEquals(two, getList().get(2));\n-        \n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n         it.remove(); // removed element at index 1 (one)\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(two, getList().get(1));\n-        Object two3 = it.next();  // do next after remove\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(two, getCollection().get(1));\n+        E two3 = it.next();  // do next after remove\n         assertEquals(two, two3);\n-        assertEquals(collection.size() > 2, it.hasNext());\n+        assertEquals(getCollection().size() > 2, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n     }\n \n     public void testListListIteratorPreviousRemovePrevious() {\n         if (isRemoveSupported() == false) return;\n         resetFull();\n-        if (collection.size() < 4) return;\n-        ListIterator it = getList().listIterator();\n-        Object zero = it.next();\n-        Object one = it.next();\n-        Object two = it.next();\n-        Object two2 = it.previous();\n-        Object one2 = it.previous();\n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        E two2 = it.previous();\n+        E one2 = it.previous();\n         assertEquals(one, one2);\n         assertEquals(two, two2);\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(one, getList().get(1));\n-        assertEquals(two, getList().get(2));\n-        \n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n         it.remove(); // removed element at index 1 (one)\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(two, getList().get(1));\n-        Object zero3 = it.previous();  // do previous after remove\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(two, getCollection().get(1));\n+        E zero3 = it.previous();  // do previous after remove\n         assertEquals(zero, zero3);\n         assertEquals(false, it.hasPrevious());\n-        assertEquals(collection.size() > 2, it.hasNext());\n+        assertEquals(getCollection().size() > 2, it.hasNext());\n     }\n \n     /**\n     public void testListListIteratorNextRemoveNext() {\n         if (isRemoveSupported() == false) return;\n         resetFull();\n-        if (collection.size() < 4) return;\n-        ListIterator it = getList().listIterator();\n-        Object zero = it.next();\n-        Object one = it.next();\n-        Object two = it.next();\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(one, getList().get(1));\n-        assertEquals(two, getList().get(2));\n-        Object three = getList().get(3);\n-        \n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+        E three = getCollection().get(3);\n+\n         it.remove(); // removed element at index 2 (two)\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(one, getList().get(1));\n-        Object three2 = it.next();  // do next after remove\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        E three2 = it.next();  // do next after remove\n         assertEquals(three, three2);\n-        assertEquals(collection.size() > 3, it.hasNext());\n+        assertEquals(getCollection().size() > 3, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n     }\n \n     public void testListListIteratorNextRemovePrevious() {\n         if (isRemoveSupported() == false) return;\n         resetFull();\n-        if (collection.size() < 4) return;\n-        ListIterator it = getList().listIterator();\n-        Object zero = it.next();\n-        Object one = it.next();\n-        Object two = it.next();\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(one, getList().get(1));\n-        assertEquals(two, getList().get(2));\n-        \n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n         it.remove(); // removed element at index 2 (two)\n-        assertEquals(zero, getList().get(0));\n-        assertEquals(one, getList().get(1));\n-        Object one2 = it.previous();  // do previous after remove\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        E one2 = it.previous();  // do previous after remove\n         assertEquals(one, one2);\n         assertEquals(true, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n      *  @param iter  the iterator to traverse\n      *  @param i     the starting index\n      */\n-    private void forwardTest(ListIterator iter, int i) {\n-        List list = getList();\n+    private void forwardTest(ListIterator<E> iter, int i) {\n+        List<E> list = getCollection();\n         int max = getFullElements().length;\n \n         while (i < max) {\n             assertTrue(\"Iterator should have next\", iter.hasNext());\n-            assertEquals(\"Iterator.nextIndex should work\", \n+            assertEquals(\"Iterator.nextIndex should work\",\n                 i, iter.nextIndex());\n             assertEquals(\"Iterator.previousIndex should work\",\n                 i - 1, iter.previousIndex());\n \n         assertTrue(\"Iterator shouldn't have next\", !iter.hasNext());\n         assertEquals(\"nextIndex should be size\", max, iter.nextIndex());\n-        assertEquals(\"previousIndex should be size - 1\", \n-            max - 1, iter.previousIndex());\n+        assertEquals(\"previousIndex should be size - 1\", max - 1, iter.previousIndex());\n \n         try {\n             iter.next();\n             // expected\n         }\n     }\n-\n \n     /**\n      *  Traverses to the beginning of the given iterator.\n      *  @param iter  the iterator to traverse\n      *  @param i     the starting index\n      */\n-    private void backwardTest(ListIterator iter, int i) {\n-        List list = getList();\n+    private void backwardTest(ListIterator<E> iter, int i) {\n+        List<E> list = getCollection();\n \n         while (i > 0) {\n             assertTrue(\"Iterator should have previous, i:\" + i,\n                 i, iter.nextIndex());\n             assertEquals(\"Iterator.previousIndex should work, i:\" + i,\n                 i - 1, iter.previousIndex());\n-            Object o = iter.previous();\n+            E o = iter.previous();\n             assertEquals(\"Iterator returned correct element\",\n                 list.get(i - 1), o);\n             i--;\n         if (!isAddSupported()) return;\n \n         resetEmpty();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Object[] elements = getFullElements();\n-        ListIterator iter1 = list1.listIterator();\n-        ListIterator iter2 = list2.listIterator();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        E[] elements = getFullElements();\n+        ListIterator<E> iter1 = list1.listIterator();\n+        ListIterator<E> iter2 = list2.listIterator();\n \n         for (int i = 0; i < elements.length; i++) {\n             iter1.add(elements[i]);\n         }\n \n         resetFull();\n-        iter1 = getList().listIterator();\n-        iter2 = getConfirmedList().listIterator();\n+        iter1 = getCollection().listIterator();\n+        iter2 = getConfirmed().listIterator();\n         for (int i = 0; i < elements.length; i++) {\n             iter1.next();\n             iter2.next();\n         }\n     }\n \n-\n     /**\n      *  Tests the {@link ListIterator#set(Object)} method of the list\n      *  iterator.\n     public void testListIteratorSet() {\n         if (!isSetSupported()) return;\n \n-        Object[] elements = getFullElements();\n-\n-        resetFull();\n-        ListIterator iter1 = getList().listIterator();\n-        ListIterator iter2 = getConfirmedList().listIterator();\n+        E[] elements = getFullElements();\n+\n+        resetFull();\n+        ListIterator<E> iter1 = getCollection().listIterator();\n+        ListIterator<E> iter2 = getConfirmed().listIterator();\n         for (int i = 0; i < elements.length; i++) {\n             iter1.next();\n             iter2.next();\n         }\n     }\n \n-\n-    public void testEmptyListSerialization() \n-    throws IOException, ClassNotFoundException {\n-        List list = makeEmptyList();\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyListSerialization() throws IOException, ClassNotFoundException {\n+        List<E> list = makeObject();\n         if (!(list instanceof Serializable && isTestSerialization())) return;\n-        \n+\n         byte[] objekt = writeExternalFormToBytes((Serializable) list);\n-        List list2 = (List) readExternalFormFromBytes(objekt);\n+        List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n \n         assertEquals(\"Both lists are empty\", 0, list.size());\n         assertEquals(\"Both lists are empty\", 0, list2.size());\n     }\n \n-    public void testFullListSerialization() \n-    throws IOException, ClassNotFoundException {\n-        List list = makeFullList();\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullListSerialization() throws IOException, ClassNotFoundException {\n+        List<E> list = makeFullCollection();\n         int size = getFullElements().length;\n         if (!(list instanceof Serializable && isTestSerialization())) return;\n-        \n+\n         byte[] objekt = writeExternalFormToBytes((Serializable) list);\n-        List list2 = (List) readExternalFormFromBytes(objekt);\n+        List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n \n         assertEquals(\"Both lists are same size\", size, list.size());\n         assertEquals(\"Both lists are same size\", size, list2.size());\n     }\n \n     /**\n+     * Skip the serialized canonical tests for now.\n+     *\n+     * @return true\n+     *\n+     * TODO: store new serialized objects in CVS.\n+     */\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    /**\n      * Compare the current serialized form of the List\n      * against the canonical version in SVN.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {\n         /**\n          * Create canonical objects with this code\n         List list = makeEmptyList();\n         if (!(list instanceof Serializable)) return;\n-        \n+\n         writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));\n         */\n \n         // test to make sure the canonical form has been preserved\n-        List list = makeEmptyList();\n-        if(list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n-            List list2 = (List) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n+        List<E> list = makeObject();\n+        if (list instanceof Serializable && !skipSerializedCanonicalTests()\n+                && isTestSerialization()) {\n+            List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n             assertEquals(\"List is empty\", 0, list2.size());\n             assertEquals(list, list2);\n         }\n      * Compare the current serialized form of the List\n      * against the canonical version in SVN.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testFullListCompatibility() throws IOException, ClassNotFoundException {\n         /**\n          * Create canonical objects with this code\n         List list = makeFullList();\n         if (!(list instanceof Serializable)) return;\n-        \n+\n         writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));\n         */\n \n         // test to make sure the canonical form has been preserved\n-        List list = makeFullList();\n+        List<E> list = makeFullCollection();\n         if(list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n-            List list2 = (List) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n+            List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n             if (list2.size() == 4) {\n                 // old serialized tests\n                 return;\n      */\n     public BulkTest bulkTestSubList() {\n         if (getFullElements().length - 6 < 10) return null;\n-        return new BulkTestSubList(this);\n-    }\n-\n-\n-   public static class BulkTestSubList extends AbstractTestList {\n-\n-       private AbstractTestList outer;\n-\n-\n-       public BulkTestSubList(AbstractTestList outer) {\n+        return new BulkTestSubList<E>(this);\n+    }\n+\n+   public static class BulkTestSubList<E> extends AbstractTestList<E> {\n+\n+       private AbstractTestList<E> outer;\n+\n+       public BulkTestSubList(AbstractTestList<E> outer) {\n            super(\"\");\n            this.outer = outer;\n        }\n \n-\n-       public Object[] getFullElements() {\n-           List l = Arrays.asList(outer.getFullElements());\n-           return l.subList(3, l.size() - 3).toArray();\n-       }\n-\n-\n-       public Object[] getOtherElements() {\n+       @SuppressWarnings(\"unchecked\")\n+       public E[] getFullElements() {\n+           List<E> l = Arrays.asList(outer.getFullElements());\n+           return (E[]) l.subList(3, l.size() - 3).toArray();\n+       }\n+\n+       public E[] getOtherElements() {\n            return outer.getOtherElements();\n        }\n-\n \n        public boolean isAddSupported() {\n            return outer.isAddSupported();\n            return outer.isRemoveSupported();\n        }\n \n-\n-       public List makeEmptyList() { \n-           return outer.makeFullList().subList(4, 4); \n-       }\n-\n-\n-       public List makeFullList() {\n+       public List<E> makeObject() {\n+           return outer.makeFullCollection().subList(4, 4);\n+       }\n+\n+       public List<E> makeFullCollection() {\n            int size = getFullElements().length;\n-           return outer.makeFullList().subList(3, size - 3);\n-       }\n-\n+           return outer.makeFullCollection().subList(3, size - 3);\n+       }\n \n        public void resetEmpty() {\n            outer.resetFull();\n-           this.collection = outer.getList().subList(4, 4);\n-           this.confirmed = outer.getConfirmedList().subList(4, 4);\n+           this.setCollection(outer.getCollection().subList(4, 4));\n+           this.setConfirmed(outer.getConfirmed().subList(4, 4));\n        }\n \n        public void resetFull() {\n            outer.resetFull();\n-           int size = outer.confirmed.size();\n-           this.collection = outer.getList().subList(3, size - 3);\n-           this.confirmed = outer.getConfirmedList().subList(3, size - 3);\n-       }\n-\n+           int size = outer.getConfirmed().size();\n+           this.setCollection(outer.getCollection().subList(3, size - 3));\n+           this.setConfirmed(outer.getConfirmed().subList(3, size - 3));\n+       }\n \n        public void verify() {\n            super.verify();\n            return false;\n        }\n    }\n-\n \n    /**\n     *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n        if (!isAddSupported()) return;\n \n        resetFull();\n-       int size = collection.size();\n-       List sub = getList().subList(1, size);\n-       getList().add(getOtherElements()[0]);\n+       int size = getCollection().size();\n+       List<E> sub = getCollection().subList(1, size);\n+       getCollection().add(getOtherElements()[0]);\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().add(0, getOtherElements()[0]);\n+       sub = getCollection().subList(1, size);\n+       getCollection().add(0, getOtherElements()[0]);\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().addAll(Arrays.asList(getOtherElements()));\n+       sub = getCollection().subList(1, size);\n+       getCollection().addAll(Arrays.asList(getOtherElements()));\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().addAll(0, Arrays.asList(getOtherElements()));\n+       sub = getCollection().subList(1, size);\n+       getCollection().addAll(0, Arrays.asList(getOtherElements()));\n        failFastAll(sub);\n-\n    }\n-\n \n    /**\n     *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n        if (!isRemoveSupported()) return;\n \n        resetFull();\n-       int size = collection.size();\n-       List sub = getList().subList(1, size);\n-       getList().remove(0);\n+       int size = getCollection().size();\n+       List<E> sub = getCollection().subList(1, size);\n+       getCollection().remove(0);\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().remove(getFullElements()[2]);\n+       sub = getCollection().subList(1, size);\n+       getCollection().remove(getFullElements()[2]);\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().removeAll(Arrays.asList(getFullElements()));\n+       sub = getCollection().subList(1, size);\n+       getCollection().removeAll(Arrays.asList(getFullElements()));\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().retainAll(Arrays.asList(getOtherElements()));\n+       sub = getCollection().subList(1, size);\n+       getCollection().retainAll(Arrays.asList(getOtherElements()));\n        failFastAll(sub);\n \n        resetFull();\n-       sub = getList().subList(1, size);\n-       getList().clear();\n+       sub = getCollection().subList(1, size);\n+       getCollection().clear();\n        failFastAll(sub);\n    }\n-\n \n    /**\n     *  Invokes all the methods on the given sublist to make sure they raise\n     *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n     */\n-   protected void failFastAll(List list) {\n+   protected void failFastAll(List<E> list) {\n        Method[] methods = List.class.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            failFastMethod(list, methods[i]);\n        }\n    }\n-\n \n    /**\n     *  Invokes the given method on the given sublist to make sure it raises\n     *  @param list  the sublist to test\n     *  @param m     the method to invoke\n     */\n-   protected void failFastMethod(List list, Method m) {\n+   protected void failFastMethod(List<E> list, Method m) {\n        if (m.getName().equals(\"equals\")) return;\n \n-       Object element = getOtherElements()[0];\n-       Collection c = Collections.singleton(element);\n-\n-       Class[] types = m.getParameterTypes();\n+       E element = getOtherElements()[0];\n+       Collection<E> c = Collections.singleton(element);\n+\n+       Class<?>[] types = m.getParameterTypes();\n        Object[] params = new Object[types.length];\n        for (int i = 0; i < params.length; i++) {\n            if (types[i] == Integer.TYPE) params[i] = new Integer(0);\n    public BulkTest bulkTestListIterator() {\n        return new TestListIterator();\n    }\n-    \n-   public class TestListIterator extends AbstractTestListIterator {\n+\n+   public class TestListIterator extends AbstractTestListIterator<E> {\n        public TestListIterator() {\n            super(\"TestListIterator\");\n        }\n-        \n-       public Object addSetValue() {\n+\n+       public E addSetValue() {\n            return AbstractTestList.this.getOtherElements()[0];\n        }\n-        \n+\n        public boolean supportsRemove() {\n            return AbstractTestList.this.isRemoveSupported();\n        }\n            return AbstractTestList.this.isSetSupported();\n        }\n \n-       public ListIterator makeEmptyListIterator() {\n+       public ListIterator<E> makeEmptyIterator() {\n            resetEmpty();\n-           return ((List) AbstractTestList.this.collection).listIterator();\n-       }\n-\n-       public ListIterator makeFullListIterator() {\n+           return AbstractTestList.this.getCollection().listIterator();\n+       }\n+\n+       public ListIterator<E> makeObject() {\n            resetFull();\n-           return ((List) AbstractTestList.this.collection).listIterator();\n+           return AbstractTestList.this.getCollection().listIterator();\n        }\n    }\n-    \n+\n }", "timestamp": 1252994237, "metainfo": ""}