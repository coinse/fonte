{"sha": "5b3f6003c5bf0d4b95fe503a2421c94189d6888e", "log": "TestList tests have been rewritten to conform to the general TestCollection patterns.  A bulk test has been included for sublists and sub-sublists.  Removed the deprecated method from TestCollection, as no one uses it anymore.  Modified TestCursorableLinkedList so that serialization tests on sublists and sub-sublists are ignored.  Submitted by:  Paul Jack ( pjack at sfaf dot org )   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestList.java\n+++ b/src/test/org/apache/commons/collections/TestList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.9 2002/06/18 01:14:23 mas Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/06/18 01:14:23 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.10 2002/06/21 03:28:54 mas Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/06/21 03:28:54 $\n  *\n  * ====================================================================\n  *\n import junit.framework.*;\n import java.io.IOException;\n import java.io.Serializable;\n-import java.util.List;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.AbstractCollection;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n import java.util.Arrays;\n import java.util.ArrayList;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n \n /**\n  * Tests base {@link java.util.List} methods and contracts.\n  * test case (method) your {@link List} fails.\n  *\n  * @author Rodney Waldhoff\n- * @version $Id: TestList.java,v 1.9 2002/06/18 01:14:23 mas Exp $\n+ * @author Paul Jack\n+ * @version $Id: TestList.java,v 1.10 2002/06/21 03:28:54 mas Exp $\n  */\n public abstract class TestList extends TestCollection {\n+\n+\n     public TestList(String testName) {\n         super(testName);\n     }\n \n-    /**\n-     * Return a new, empty {@link List} to used for testing.\n-     */\n-    public abstract List makeEmptyList();\n-\n-    public List makeFullList() {\n-        // only works if list supports optional \"add(Object)\" \n-        // and \"add(int,Object)\" operations\n+\n+    /**\n+     *  Return a new, empty {@link List} to be used for testing.\n+     *\n+     *  @return an empty list for testing.\n+     */\n+    protected abstract List makeEmptyList();\n+\n+\n+    /**\n+     *  Return a new, full {@link List} to be used for testing.\n+     *\n+     *  @return a full list for testing\n+     */\n+    protected List makeFullList() {\n+        // only works if list supports optional \"addAll(Collection)\" \n         List list = makeEmptyList();\n-        list.add(\"1\");\n-        // must be able to add to the end this way\n-        list.add(list.size(),\"4\");\n-        // must support duplicates\n-        list.add(\"1\");\n-        // must support insertions\n-        list.add(1,\"3\");\n-\n-        // resultant list: 1, 3, 4, 1\n+        list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n \n-    public Collection makeCollection() {\n+\n+    /**\n+     *  Returns {@link makeEmptyList()}.\n+     *\n+     *  @return an empty list to be used for testing\n+     */\n+    final protected Collection makeCollection() {\n         return makeEmptyList();\n     }\n \n+\n+    /**\n+     *  Returns {@link makeFullList()}.\n+     *\n+     *  @return a full list to be used for testing\n+     */\n+    final protected Collection makeFullCollection() {\n+        return makeFullList();\n+    }\n+\n+\n+    /**\n+     *  Returns the {@link collection} field cast to a {@link List}.\n+     *\n+     *  @return the collection field as a List\n+     */\n+    protected List getList() {\n+        return (List)collection;\n+    } \n+\n+\n+    /**\n+     *  Returns the {@link confirmed} field cast to a {@link List}.\n+     *\n+     *  @return the confirmed field as a List\n+     */\n+    protected List getConfirmedList() {\n+        return (List)confirmed;\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on an\n+     *  empty list.\n+     */\n     public void testListAddByIndexBoundsChecking() {\n+        if (!isAddSupported()) return;\n+\n         List list = makeEmptyList();\n-\n-        try {\n-            list.add(Integer.MIN_VALUE,\"element\");\n-            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(-1,\"element\");\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(1,\"element\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(Integer.MAX_VALUE,\"element\");\n-            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on a\n+     *  full list.\n+     */\n     public void testListAddByIndexBoundsChecking2() {\n-        List list = makeEmptyList();\n-        boolean added = tryToAdd(list,\"element\");\n-\n-        try {\n-            list.add(-1,\"element2\");\n+        if (!isAddSupported()) return;\n+\n+        List list = makeFullList();\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(2,\"element2\");\n-            fail(\"List.add should throw IndexOutOfBoundsException [2]\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(list.size() + 1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#add(int,Object)}.\n+     */\n     public void testListAddByIndex() {\n-        List list = makeEmptyList();\n-        assertEquals(0,list.size());\n-        if(tryToAdd(list,0,\"element2\")) {\n-            assertEquals(1,list.size());\n-            if(tryToAdd(list,0,\"element0\")) {\n-                assertTrue(Arrays.equals(new String[] { \"element0\", \"element2\" },list.toArray()));\n-                if(tryToAdd(list,1,\"element1\")) {\n-                    assertTrue(Arrays.equals(new String[] { \"element0\", \"element1\", \"element2\" },list.toArray()));\n-                    if(tryToAdd(list,4,\"element3\")) {\n-                        assertTrue(Arrays.equals(new String[] { \"element0\", \"element1\", \"element2\", \"element3\" },list.toArray()));\n-                    }\n-                }\n+        if (!isAddSupported()) return;\n+\n+        Object element = getOtherElements()[0];\n+        int max = getFullElements().length;\n+\n+        for (int i = 0; i <= max; i++) {\n+            resetFull();\n+            ((List)collection).add(i, element);\n+            ((List)confirmed).add(i, element);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#equals(Object)}.\n+     */\n+    public void testListEquals() {\n+        resetEmpty();\n+        List list = getList();\n+        assertTrue(\"Empty lists should be equal\", list.equals(confirmed));\n+        verify();\n+        assertTrue(\"Empty list should equal self\", list.equals(list));\n+        verify();\n+\n+        List list2 = Arrays.asList(getFullElements());\n+        assertTrue(\"Empty list shouldn't equal full\", !list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertTrue(\"Empty list shouldn't equal other\", !list.equals(list2));\n+        verify();\n+\n+        resetFull();\n+        list = getList();\n+        assertTrue(\"Full lists should be equal\", list.equals(confirmed));\n+        verify();\n+        assertTrue(\"Full list should equal self\", list.equals(list));\n+        verify();\n+\n+        list2 = makeEmptyList();\n+        assertTrue(\"Full list shouldn't equal empty\", !list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertTrue(\"Full list shouldn't equal other\", !list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getFullElements());\n+        Collections.reverse(list2);\n+        assertTrue(\"Full list shouldn't equal full list with same elements\" +\n+          \" but different order\", !list.equals(list2));\n+        verify();\n+\n+        assertTrue(\"List shouldn't equal String\", !list.equals(\"\"));\n+        verify();\n+\n+        final List listForC = Arrays.asList(getFullElements());\n+        Collection c = new AbstractCollection() {\n+            public int size() {\n+                return listForC.size();\n             }\n-        }\n-    }\n-\n-    public void testListAdd() {\n-        List list = makeEmptyList();\n-        if(tryToAdd(list,\"1\")) {\n-            assertTrue(list.contains(\"1\"));\n-            if(tryToAdd(list,\"2\")) {\n-                assertTrue(list.contains(\"1\"));\n-                assertTrue(list.contains(\"2\"));\n-                if(tryToAdd(list,\"3\")) {\n-                    assertTrue(list.contains(\"1\"));\n-                    assertTrue(list.contains(\"2\"));\n-                    assertTrue(list.contains(\"3\"));\n-                    if(tryToAdd(list,\"4\")) {\n-                        assertTrue(list.contains(\"1\"));\n-                        assertTrue(list.contains(\"2\"));\n-                        assertTrue(list.contains(\"3\"));\n-                        assertTrue(list.contains(\"4\"));\n-                    }\n-                }\n+\n+            public Iterator iterator() {\n+                return listForC.iterator();\n             }\n-        }\n-    }\n-\n-    public void testListEqualsSelf() {\n-        List list = makeEmptyList();\n-        assertTrue(list.equals(list));\n-        tryToAdd(list,\"elt\");\n-        assertTrue(list.equals(list));\n-        tryToAdd(list,\"elt2\");\n-        assertTrue(list.equals(list));\n-    }\n-\n-    public void testListEqualsArrayList() {\n-        List list1 = makeEmptyList();\n-        List list2 = new ArrayList();\n-        assertTrue(list1.equals(list2));\n-        assertEquals(list1.hashCode(),list2.hashCode());\n-        tryToAdd(list1,\"a\");\n-        assertTrue(!list1.equals(list2));\n-        tryToAdd(list1,\"b\");\n-        tryToAdd(list1,\"c\");\n-        tryToAdd(list1,\"d\");\n-        tryToAdd(list1,\"b\");\n-\n-        Iterator it = list1.iterator();\n-        while(it.hasNext()) {\n-            list2.add(it.next());\n-        }\n-        assertTrue(list1.equals(list2));\n-        assertEquals(list1.hashCode(),list2.hashCode());\n-    }\n-\n-    public void testListEquals() {\n-        List list1 = makeEmptyList();\n-        List list2 = makeEmptyList();\n-        assertTrue(list1.equals(list2));\n-        if(tryToAdd(list1,\"a\") && tryToAdd(list2,\"a\")) {\n-            assertTrue(list1.equals(list2));\n-            if(tryToAdd(list1,\"b\") && tryToAdd(list2,\"b\")) {\n-                assertTrue(list1.equals(list2));\n-                if(tryToAdd(list1,\"c\") && tryToAdd(list2,\"c\")) {\n-                    assertTrue(list1.equals(list2));\n-                    if(tryToAdd(list1,\"b\") && tryToAdd(list2,\"b\")) {\n-                        assertTrue(list1.equals(list2));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n+        };\n+\n+        assertTrue(\"List shouldn't equal nonlist with same elements \" +\n+          \" in same order\", !list.equals(c));\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#hashCode()}.\n+     */\n+    public void testListHashCode() {\n+        resetEmpty();\n+        int hash1 = collection.hashCode();\n+        int hash2 = confirmed.hashCode();\n+        assertEquals(\"Empty lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+\n+        resetFull();\n+        hash1 = collection.hashCode();\n+        hash2 = confirmed.hashCode();\n+        assertEquals(\"Full lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#get(int)}.\n+     */\n     public void testListGetByIndex() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"a\");\n-        tryToAdd(list,\"b\");\n-        tryToAdd(list,\"c\");\n-        tryToAdd(list,\"d\");\n-        tryToAdd(list,\"e\");\n-        tryToAdd(list,\"f\");\n-        Object[] expected = list.toArray();\n-        for(int i=0;i<expected.length;i++) {\n-            assertEquals(expected[i],list.get(i));\n-        }\n-    }\n-\n+        resetFull();\n+        List list = getList();\n+        Object[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertEquals(\"List should contain correct elements\", \n+              elements[i], list.get(i));\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on an\n+     *  empty list.\n+     */\n     public void testListGetByIndexBoundsChecking() {\n         List list = makeEmptyList();\n \n         try {\n             list.get(Integer.MIN_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+            fail(\"List.get should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(Integer.MAX_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n+            fail(\"List.get should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on a\n+     *  full list.\n+     */\n     public void testListGetByIndexBoundsChecking2() {\n-        List list = makeEmptyList();\n-        boolean added = tryToAdd(list,\"a\");\n+        List list = makeFullList();\n \n         try {\n             list.get(Integer.MIN_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+            fail(\"List.get should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MIN_VALUE]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n         }\n         }\n \n         try {\n-            list.get(1);\n-            fail(\"List.get should throw IndexOutOfBoundsException [1]\");\n+            list.get(getFullElements().length);\n+            fail(\"List.get should throw IndexOutOfBoundsException [size]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(Integer.MAX_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n+            fail(\"List.get should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#indexOf()}.\n+     */\n     public void testListIndexOf() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"a\");\n-        tryToAdd(list,\"b\");\n-        tryToAdd(list,\"c\");\n-        tryToAdd(list,\"d\");\n-        tryToAdd(list,\"e\");\n-        tryToAdd(list,\"f\");\n-        Object[] expected = list.toArray();\n-        for(int i=0;i<expected.length;i++) {\n-            assertEquals(i,list.indexOf(expected[i]));\n-        }\n-        assertEquals(-1,list.indexOf(\"g\"));\n-    }\n-\n-    public void testListLastIndexOf1() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"a\");\n-        tryToAdd(list,\"b\");\n-        tryToAdd(list,\"c\");\n-        tryToAdd(list,\"d\");\n-        tryToAdd(list,\"e\");\n-        tryToAdd(list,\"f\");\n-        Object[] expected = list.toArray();\n-        for(int i=0;i<expected.length;i++) {\n-            assertEquals(i,list.lastIndexOf(expected[i]));\n-        }\n-        assertEquals(-1,list.indexOf(\"g\"));\n-    }\n-\n-    public void testListLastIndexOf2() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"a\");\n-        tryToAdd(list,\"b\");\n-        tryToAdd(list,\"c\");\n-        tryToAdd(list,\"d\");\n-        tryToAdd(list,\"e\");\n-        tryToAdd(list,\"f\");\n-        tryToAdd(list,\"a\");\n-        tryToAdd(list,\"b\");\n-        tryToAdd(list,\"c\");\n-        tryToAdd(list,\"d\");\n-        tryToAdd(list,\"e\");\n-        tryToAdd(list,\"f\");\n-        Object[] expected = list.toArray();\n-        int lastIndexOfA = -1;\n-        int lastIndexOfB = -1;\n-        int lastIndexOfC = -1;\n-        int lastIndexOfD = -1;\n-        int lastIndexOfE = -1;\n-        int lastIndexOfF = -1;\n-        int lastIndexOfG = -1;\n-        for(int i=0;i<expected.length;i++) {\n-            if(\"a\".equals(expected[i])) {\n-                lastIndexOfA = i;\n-            } else if(\"b\".equals(expected[i])) {\n-                lastIndexOfB = i;\n-            } else if(\"c\".equals(expected[i])) {\n-                lastIndexOfC = i;\n-            } else if(\"d\".equals(expected[i])) {\n-                lastIndexOfD = i;\n-            } else if(\"e\".equals(expected[i])) {\n-                lastIndexOfE = i;\n-            } else if(\"f\".equals(expected[i])) {\n-                lastIndexOfF = i;\n-            } else if(\"g\".equals(expected[i])) {\n-                lastIndexOfG = i;\n-            }\n-        }\n-        assertEquals(lastIndexOfA,list.lastIndexOf(\"a\"));\n-        assertEquals(lastIndexOfB,list.lastIndexOf(\"b\"));\n-        assertEquals(lastIndexOfC,list.lastIndexOf(\"c\"));\n-        assertEquals(lastIndexOfD,list.lastIndexOf(\"d\"));\n-        assertEquals(lastIndexOfE,list.lastIndexOf(\"e\"));\n-        assertEquals(lastIndexOfF,list.lastIndexOf(\"f\"));\n-        assertEquals(lastIndexOfG,list.lastIndexOf(\"g\"));\n-    }\n-\n+        resetFull();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Iterator iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            Object element = iterator.next();\n+            assertEquals(\"indexOf should return correct result\", \n+              list1.indexOf(element), list2.indexOf(element));            \n+            verify();\n+        }\n+\n+        Object[] other = getOtherElements();\n+        for (int i = 0; i < other.length; i++) {\n+            assertEquals(\"indexOf should return -1 for nonexistent element\",\n+              list1.indexOf(other[i]), -1);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#lastIndexOf()}.\n+     */\n+    public void testListLastIndexOf() {\n+        resetFull();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Iterator iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            Object element = iterator.next();\n+            assertEquals(\"lastIndexOf should return correct result\",\n+              list1.lastIndexOf(element), list2.lastIndexOf(element));\n+            verify();\n+        }\n+\n+        Object[] other = getOtherElements();\n+        for (int i = 0; i < other.length; i++) {\n+            assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n+              \"element\", list1.lastIndexOf(other[i]), -1);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on an\n+     *  empty list.\n+     */\n     public void testListSetByIndexBoundsChecking() {\n         List list = makeEmptyList();\n-\n-        try {\n-            list.set(Integer.MIN_VALUE,\"a\");\n-            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(-1,\"a\");\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(0,\"a\");\n+        } \n+\n+        try {\n+            list.set(0, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [0]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(1,\"a\");\n+        } \n+\n+        try {\n+            list.set(1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [1]\");\n         } catch(IndexOutOfBoundsException e) {\n             // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(Integer.MAX_VALUE,\"a\");\n-            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-    }\n-\n+        } \n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on a\n+     *  full list.\n+     */\n     public void testListSetByIndexBoundsChecking2() {\n+        List list = makeFullList();\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(getFullElements().length, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+    }\n+\n+\n+    /**\n+     *  Test {@link List#set(int,Object)}.\n+     */\n+    public void testListSetByIndex() {\n+        resetFull();\n+        Object[] elements = getFullElements();\n+        Object[] other = getOtherElements();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            Object n = other[i % other.length];\n+            Object v = ((List)collection).set(i, n);\n+            assertEquals(\"Set should return correct element\", elements[i], v);\n+            ((List)confirmed).set(i, n);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on an\n+     *  empty list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking() {\n+        if (!isRemoveSupported()) return;\n+\n         List list = makeEmptyList();\n-        tryToAdd(list,\"element\");\n-        tryToAdd(list,\"element2\");\n-\n-        try {\n-            list.set(Integer.MIN_VALUE,\"a\");\n-            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(-1,\"a\");\n-            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(2,\"a\");\n-            fail(\"List.set should throw IndexOutOfBoundsException [2]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.set(Integer.MAX_VALUE,\"a\");\n-            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException  e) {\n-            // expected\n-        }\n-    }\n-\n-    public void testListSetByIndex() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"element\");\n-        tryToAdd(list,\"element2\");\n-        tryToAdd(list,\"element3\");\n-        tryToAdd(list,\"element4\");\n-\n-        Object[] values = list.toArray();\n-\n-        for(int i=0;i<values.length;i++) {\n-            try {\n-                Object obj = list.set(i,String.valueOf(i));\n-                assertEquals(obj,values[i]);\n-                values[i] = String.valueOf(i);\n-                assertTrue(Arrays.equals(values,list.toArray()));\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            } catch(ClassCastException e) {\n-                // expected\n-            } catch(IllegalArgumentException  e) {\n-                // expected\n-            }\n-        }\n-    }\n-\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(0);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on a\n+     *  full list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking2() {\n+        if (!isRemoveSupported()) return;\n+\n+        List list = makeFullList();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(getFullElements().length);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#remove(int)}.\n+     */\n     public void testListRemoveByIndex() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"element\");\n-        tryToAdd(list,\"element2\");\n-        tryToAdd(list,\"element3\");\n-        tryToAdd(list,\"element4\");\n-        tryToAdd(list,\"element5\");\n-\n-        Object[] values = list.toArray();\n-\n-        for(int i=1;i<values.length;i++) {\n-            try {\n-                Object obj = list.remove(1);\n-                assertEquals(obj,values[i]);\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            }\n-        }\n-\n-        if(values.length != 0) {\n-            try {\n-                Object obj = list.remove(0);\n-                assertEquals(obj,values[0]);\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            }\n-        }\n-    }\n-\n-    public void testListRemoveByValue() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"element1\");\n-        tryToAdd(list,\"element2\");\n-        tryToAdd(list,\"element3\");\n-        tryToAdd(list,\"element4\");\n-        tryToAdd(list,\"element5\");\n-\n-        Object[] values = list.toArray();\n-\n-        for(int i=0;i<values.length;i++) {\n-            try {\n-                assertTrue(!list.remove(\"X\"));\n-                assertTrue(list.contains(values[i]));\n-                assertTrue(list.remove(values[i]));\n-                assertTrue(!list.contains(values[i]));\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            }\n-        }\n-    }\n-\n-    public void testListListIteratorNextPrev() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"element1\");\n-        tryToAdd(list,\"element2\");\n-        tryToAdd(list,\"element3\");\n-        tryToAdd(list,\"element4\");\n-        tryToAdd(list,\"element5\");\n-        Object[] values = list.toArray();\n-        ListIterator iter = list.listIterator();\n-        for(int i=0;i<values.length;i++) {\n-            assertTrue( iter.hasNext() );\n-            assertTrue((i!=0) == iter.hasPrevious());\n-            assertEquals(values[i],iter.next());\n-        }\n-        assertTrue(!iter.hasNext());\n-        for(int i=values.length-1;i>=0;i--) {\n-            assertTrue( iter.hasPrevious() );\n-            assertTrue((i!=(values.length-1)) == iter.hasNext());\n-            assertEquals(values[i],iter.previous());\n-        }\n-        assertTrue(!iter.hasPrevious());\n-        for(int i=0;i<values.length;i++) {\n-            assertTrue( iter.hasNext() );\n-            assertTrue((i!=0) == iter.hasPrevious());\n-            assertEquals(values[i],iter.next());\n-            assertEquals(values[i],iter.previous());\n-            assertEquals(values[i],iter.next());\n-        }\n-    }\n-\n-    public void testListListIteratorNextIndexPrevIndex() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"element1\");\n-        tryToAdd(list,\"element2\");\n-        tryToAdd(list,\"element3\");\n-        tryToAdd(list,\"element4\");\n-        tryToAdd(list,\"element5\");\n-        Object[] values = list.toArray();\n-        ListIterator iter = list.listIterator();\n-        for(int i=0;i<values.length;i++) {\n-            assertEquals(\"nextIndex should be \" + i,i,iter.nextIndex());\n-            assertEquals(\"previousIndex should be \" + (i-1),i-1,iter.previousIndex());\n-            assertEquals(values[i],iter.next());\n-        }\n-        assertTrue(!iter.hasNext());\n-        for(int i=values.length-1;i>=0;i--) {\n-            assertEquals(\"previousIndex should be \" + i,i,iter.previousIndex());\n-            assertEquals(\"nextIndex should be \" + (i+1),i+1,iter.nextIndex());\n-            assertEquals(values[i],iter.previous());\n-        }\n-    }\n-\n-    public void testListListIteratorSet() {\n-        List list = makeEmptyList();\n-        tryToAdd(list,\"element1\");\n-        tryToAdd(list,\"element2\");\n-        tryToAdd(list,\"element3\");\n-        tryToAdd(list,\"element4\");\n-        tryToAdd(list,\"element5\");\n-        Object[] values = list.toArray();\n-        ListIterator iter = list.listIterator();\n-\n-        try {\n-            iter.set(\"should fail\");\n-            fail(\"ListIterator.set should fail when neither next nor previous has been called\");\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(IllegalStateException e) {\n-            // expected\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        for(int i=0;i<values.length;i++) {\n+        if (!isRemoveSupported()) return;\n+\n+        int max = getFullElements().length;\n+        for (int i = 0; i < max; i++) {\n+            resetFull();\n+            Object o1 = ((List)collection).remove(i);\n+            Object o2 = ((List)confirmed).remove(i);\n+            assertEquals(\"remove should return correct element\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator()}.\n+     */\n+    public void testListListIterator() {\n+        resetFull();\n+        forwardTest(getList().listIterator(), 0);\n+        backwardTest(getList().listIterator(), 0);\n+    }\n+\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator(int)}.\n+     */\n+    public void testListListIteratorByIndex() {\n+        resetFull();\n+        for (int i = 0; i < confirmed.size(); i++) {\n+            forwardTest(getList().listIterator(i), i);\n+            backwardTest(getList().listIterator(i), i);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Traverses to the end of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void forwardTest(ListIterator iter, int i) {\n+        List list = getList();\n+        int max = getFullElements().length;\n+\n+        while (i < max) {\n+            assertTrue(\"Iterator should have next\", iter.hasNext());\n+            assertEquals(\"Iterator.nextIndex should work\", \n+              iter.nextIndex(), i);\n+            assertEquals(\"Iterator.previousIndex should work\",\n+              iter.previousIndex(), i - 1);\n+            Object o = iter.next();\n+            assertEquals(\"Iterator returned correct element\", list.get(i), o);\n+            i++;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have next\", !iter.hasNext());\n+        assertEquals(\"nextIndex should be size\", iter.nextIndex(), max);\n+        assertEquals(\"previousIndex should be size - 1\", \n+          iter.previousIndex(), max - 1);\n+\n+        try {\n             iter.next();\n-            try {\n-                iter.set(new Integer(i));\n-                values[i] = new Integer(i);\n-                assertTrue(Arrays.equals(values,list.toArray()));\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            } catch(IllegalStateException e) {\n-                // expected\n-            } catch(ClassCastException e) {\n-                // expected\n-            } catch(IllegalArgumentException e) {\n-                // expected\n-            }\n-        }\n-        assertTrue(!iter.hasNext());\n-        for(int i=values.length-1;i>=0;i--) {\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Traverses to the beginning of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void backwardTest(ListIterator iter, int i) {\n+        List list = getList();\n+        int max = getFullElements().length;\n+\n+        while (i > 0) {\n+            assertTrue(\"Iterator should have next\", iter.hasPrevious());\n+            assertEquals(\"Iterator.nextIndex should work\", \n+              iter.nextIndex(), i);\n+            assertEquals(\"Iterator.previousIndex should work\",\n+              iter.previousIndex(), i - 1);\n+            Object o = iter.previous();\n+            assertEquals(\"Iterator returned correct element\", \n+              list.get(i - 1), o);\n+            i--;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have previous\", !iter.hasPrevious());\n+        assertEquals(\"nextIndex should be 0\", iter.nextIndex(), 0);\n+        assertEquals(\"previousIndex should be -1\", \n+          iter.previousIndex(), -1);\n+\n+        try {\n             iter.previous();\n-            try {\n-                iter.set(String.valueOf(i));\n-                values[i] = String.valueOf(i);\n-                assertTrue(Arrays.equals(values,list.toArray()));\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            } catch(IllegalStateException e) {\n-                // expected\n-            } catch(ClassCastException e) {\n-                // expected\n-            } catch(IllegalArgumentException e) {\n-                // expected\n-            }\n-        }\n-    }\n-\n-    /*\n-\n-    public void testListListIterator() {\n-        // XXX finish me\n-    }\n-\n-    public void testListListIteratorByIndex() {\n-        // XXX finish me\n-    }\n-\n-\n-    public void testListSubList() {\n-        // XXX finish me\n-    }\n-\n-    */\n-\n-    private boolean tryToAdd(List list, int index, Object obj) {\n-        try {\n-            list.add(index,obj);\n-            return true;\n-        } catch(UnsupportedOperationException e) {\n-            return false;\n-        } catch(ClassCastException e) {\n-            return false;\n-        } catch(IllegalArgumentException e) {\n-            return false;\n-        } catch(IndexOutOfBoundsException e) {\n-            return false;\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"List.add should only throw UnsupportedOperationException, ClassCastException, IllegalArgumentException, or IndexOutOfBoundsException. Found \" + t.toString());\n-            return false; // never get here, since fail throws exception\n-        }\n-    }\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests the {@link ListIterator#add(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorAdd() {\n+        if (!isAddSupported()) return;\n+\n+        resetEmpty();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Object[] elements = getFullElements();\n+        ListIterator iter1 = list1.listIterator();\n+        ListIterator iter2 = list2.listIterator();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            verify();\n+        }\n+\n+        resetFull();\n+        iter1 = getList().listIterator();\n+        iter2 = getConfirmedList().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests the {@link ListIterator#set(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorSet() {\n+        if (!isAddSupported()) return;\n+\n+        Object[] elements = getFullElements();\n+\n+        resetFull();\n+        ListIterator iter1 = getList().listIterator();\n+        ListIterator iter2 = getConfirmedList().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.set(elements[i]);\n+            iter2.set(elements[i]);\n+            verify();\n+        }\n+    }\n+\n \n     public void testEmptyListSerialization() \n     throws IOException, ClassNotFoundException {\n     public void testFullListSerialization() \n     throws IOException, ClassNotFoundException {\n         List list = makeFullList();\n+        int size = getFullElements().length;\n         if (!(list instanceof Serializable)) return;\n         \n         byte[] objekt = writeExternalFormToBytes((Serializable) list);\n         List list2 = (List) readExternalFormFromBytes(objekt);\n \n-        assertEquals(\"Both lists are same size\",list.size(), 4);\n-        assertEquals(\"Both lists are same size\",list2.size(),4);\n+        assertEquals(\"Both lists are same size\",list.size(), size);\n+        assertEquals(\"Both lists are same size\",list2.size(), size);\n     }\n \n     /**\n         assertTrue(\"List is empty\",list.size()  == 0);\n     }\n \n-        /**\n+    /**\n      * Compare the current serialized form of the List\n      * against the canonical version in CVS.\n      */\n         assertEquals(\"List is the right size\",list.size(), 4);\n     }\n \n+\n+    /**\n+     *  Returns an empty {@link ArrayList}.\n+     */\n     protected Collection makeConfirmedCollection() {\n         ArrayList list = new ArrayList();\n         return list;\n     }\n \n+\n+    /**\n+     *  Returns a full {@link ArrayList}.\n+     */\n     protected Collection makeConfirmedFullCollection() {\n         ArrayList list = new ArrayList();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n+\n+\n+    /**\n+     *  Verifies that the test list implementation matches the confirmed list\n+     *  implementation.\n+     */\n+    protected void verify() {\n+        super.verify();\n+\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        assertEquals(\"List should equal confirmed\", list1, list2);\n+        assertEquals(\"Confirmed should equal list\", list2, list1);\n+\n+        assertEquals(\"Hash codes should be equal\", \n+          list1.hashCode(), list2.hashCode());\n+\n+        int i = 0;\n+        Iterator iterator1 = list1.iterator();\n+        Iterator iterator2 = list2.iterator();\n+        Object[] array = list1.toArray();\n+        while (iterator2.hasNext()) {\n+            assertTrue(\"List iterator should have next\", iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(\"Iterator elements should be equal\", o1, o2);\n+            o2 = list1.get(i);\n+            assertEquals(\"get should return correct element\", o1, o2);\n+            o2 = array[i];\n+            assertEquals(\"toArray should have correct element\", o1, o2);\n+            i++;\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.\n+     *  The returned bulk test will run through every <Code>TestList</Code>\n+     *  method, <I>including</I> another <Code>bulkTestSubList</Code>.\n+     *  Sublists are tested until the size of the sublist is less than 10.\n+     *  Each sublist is 6 elements smaller than its parent list.\n+     *  (By default this means that two rounds of sublists will be tested).\n+     *  The verify() method is overloaded to test that the original list is\n+     *  modified when the sublist is.\n+     */\n+    public BulkTest bulkTestSubList() {\n+        if (getFullElements().length < 10) return null;\n+        return new BulkTestSubList(this);\n+    }\n+\n+\n+   static class BulkTestSubList extends TestList {\n+\n+       private TestList outer;\n+\n+\n+       BulkTestSubList(TestList outer) {\n+           super(\"\");\n+           this.outer = outer;\n+       }\n+\n+\n+       protected Object[] getFullElements() {\n+           List l = Arrays.asList(outer.getFullElements());\n+           return l.subList(3, l.size() - 3).toArray();\n+       }\n+\n+\n+       protected Object[] getOtherElements() {\n+           return outer.getOtherElements();\n+       }\n+\n+\n+       protected boolean isAddSupported() {\n+           return outer.isAddSupported();\n+       }\n+\n+\n+       protected boolean isRemoveSupported() {\n+           return outer.isRemoveSupported();\n+       }\n+\n+\n+       protected List makeEmptyList() { \n+           return outer.makeFullList().subList(4, 4); \n+       }\n+\n+\n+       protected List makeFullList() {\n+           int size = getFullElements().length;\n+           return outer.makeFullList().subList(3, size - 3);\n+       }\n+\n+\n+       protected void resetEmpty() {\n+           outer.resetFull();\n+           this.collection = outer.getList().subList(4, 4);\n+           this.confirmed = outer.getConfirmedList().subList(4, 4);\n+       }\n+\n+       protected void resetFull() {\n+           outer.resetFull();\n+           int size = outer.confirmed.size();\n+           this.collection = outer.getList().subList(3, size - 3);\n+           this.confirmed = outer.getConfirmedList().subList(3, size - 3);\n+       }\n+\n+\n+       protected void verify() {\n+           super.verify();\n+           outer.verify();\n+       }\n+\n+   }\n+\n+\n+   /**\n+    *  Tests that a sublist raises a {@link ConcurrentModificationException}\n+    *  if elements are added to the original list.\n+    */\n+   public void testListSubListFailFastOnAdd() {\n+       if (!isAddSupported()) return;\n+\n+       resetFull();\n+       int size = collection.size();\n+       List sub = getList().subList(1, size);\n+       getList().add(getOtherElements()[0]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().add(0, getOtherElements()[0]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().addAll(Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().addAll(0, Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+   }\n+\n+\n+   /**\n+    *  Tests that a sublist raises a {@link ConcurrentModificationException}\n+    *  if elements are removed from the original list.\n+    */\n+   public void testListSubListFailFastOnRemove() {\n+       if (!isRemoveSupported()) return;\n+\n+       resetFull();\n+       int size = collection.size();\n+       List sub = getList().subList(1, size);\n+       getList().remove(0);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().remove(getFullElements()[2]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().removeAll(Arrays.asList(getFullElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().retainAll(Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getList().subList(1, size);\n+       getList().clear();\n+       failFastAll(sub);\n+   }\n+\n+\n+   /**\n+    *  Invokes all the methods on the given sublist to make sure they raise\n+    *  a {@link ConcurrentModificationException}.\n+    */\n+   protected void failFastAll(List list) {\n+       Method[] methods = List.class.getMethods();\n+       for (int i = 0; i < methods.length; i++) {\n+           failFastMethod(list, methods[i]);\n+       }\n+   }\n+\n+\n+   /**\n+    *  Invokes the given method on the given sublist to make sure it raises\n+    *  a {@link ConcurrentModificationException}.\n+    *\n+    *  Unless the method happens to be the equals() method, in which case\n+    *  the test is skipped.  There seems to be a bug in\n+    *  java.util.AbstractList.subList(int,int).equals(Object) -- it never\n+    *  raises a ConcurrentModificationException.\n+    *\n+    *  @param list  the sublist to test\n+    *  @param m     the method to invoke\n+    */\n+   protected void failFastMethod(List list, Method m) {\n+       if (m.getName().equals(\"equals\")) return;\n+\n+       Object element = getOtherElements()[0];\n+       Collection c = Collections.singleton(element);\n+\n+       Class[] types = m.getParameterTypes();\n+       Object[] params = new Object[types.length];\n+       for (int i = 0; i < params.length; i++) {\n+           if (types[i] == Integer.TYPE) params[i] = new Integer(0);\n+           else if (types[i] == Collection.class) params[i] = c;\n+           else if (types[i] == Object.class) params[i] = element;\n+           else if (types[i] == Object[].class) params[i] = new Object[0];\n+       }\n+\n+       try {\n+           m.invoke(list, params);\n+           fail(m.getName() + \" should raise ConcurrentModification\");\n+       } catch (IllegalAccessException e) {\n+           // impossible\n+       } catch (InvocationTargetException e) {\n+           Throwable t = e.getTargetException();\n+           if (t instanceof ConcurrentModificationException) {\n+               // expected\n+               return;\n+           } else {\n+               fail(m.getName() + \" raised unexpected \" + e);\n+           }\n+       }\n+   }\n+\n }", "timestamp": 1024630134, "metainfo": ""}