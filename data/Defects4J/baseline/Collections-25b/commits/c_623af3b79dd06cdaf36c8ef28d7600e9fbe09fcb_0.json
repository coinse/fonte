{"sha": "623af3b79dd06cdaf36c8ef28d7600e9fbe09fcb", "log": "Add UnmodifiableMapIterator   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java,v 1.1 2003/11/02 18:29:59 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.pairs.UnmodifiableMapEntry;\n+\n+/** \n+ * Decorates a map iterator such that it cannot be modified.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/02 18:29:59 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableMapIterator implements MapIterator, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private MapIterator iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param iterator  the iterator to decoarate\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static MapIterator decorate(MapIterator iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableMapIterator(iterator);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decoarate\n+     */\n+    protected UnmodifiableMapIterator(MapIterator iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public Object next() {\n+        return iterator.next();\n+    }\n+\n+    public Object getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public Object getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public Entry asMapEntry() {\n+        return new UnmodifiableMapEntry(getKey(), getValue());\n+    }\n+\n+    public Object setValue(Object value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java,v 1.1 2003/11/02 18:29:59 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.Map.Entry;\n+\n+/**\n+ * Abstract class for testing the MapIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of MapIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/02 18:29:59 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestMapIterator extends AbstractTestIterator {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return a map iterator over an empty map.\n+     * \n+     * @return an empty iterator\n+     */\n+    protected abstract MapIterator makeEmptyMapIterator();\n+\n+    /**\n+     * Implement this method to return a map iterator over a map with elements.\n+     * \n+     * @return a full iterator\n+     */\n+    protected abstract MapIterator makeFullMapIterator();\n+\n+    /**\n+     * Implement this method to return the map which contains the same data as the\n+     * iterator.\n+     * \n+     * @return a full map which can be updated\n+     */\n+    protected abstract Map getMap();\n+    \n+    /**\n+     * Override if the map returned by getMap() is NOT the one tied to the iterator.\n+     * \n+     * @return true if the getMap() map is the one tied to the iterator\n+     */\n+    protected boolean supportsTiedMap() {\n+        return true;\n+    }\n+\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     * \n+     * @return an empty iterator\n+     */\n+    protected final Iterator makeEmptyIterator() {\n+        return makeEmptyMapIterator();\n+    }\n+\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     * \n+     * @return a full iterator\n+     */\n+    protected final Iterator makeFullIterator() {\n+        return makeFullMapIterator();\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports setValue().\n+     * Default is true.\n+     * \n+     * @return true if Iterator supports set\n+     */\n+    protected boolean supportsSetValue() {\n+        return true;\n+    }\n+\n+    /**\n+     * The value to be used in the add and set tests.\n+     * Default is null.\n+     */\n+    protected Object addSetValue() {\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    public void testEmptyMapIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        MapIterator it = makeEmptyMapIterator();\n+        assertEquals(false, it.hasNext());\n+        \n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        // getKey() should throw an IllegalStateException\n+        try {\n+            it.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        // getValue() should throw an IllegalStateException\n+        try {\n+            it.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        // asMapEntry() should throw an IllegalStateException\n+        try {\n+            it.asMapEntry();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        \n+        if (supportsSetValue() == false) {\n+            // setValue() should throw an UnsupportedOperationException/IllegalStateException\n+            try {\n+                it.setValue(addSetValue());\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            } catch (IllegalStateException ex) {}\n+        } else {\n+            // setValue() should throw an IllegalStateException\n+            try {\n+                it.setValue(addSetValue());\n+                fail();\n+            } catch (IllegalStateException ex) {}\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the full list iterator contract is correct.\n+     */\n+    public void testFullMapIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        MapIterator it = makeFullMapIterator();\n+        Map map = getMap();\n+        assertEquals(true, it.hasNext());\n+        \n+        assertEquals(true, it.hasNext());\n+        Map.Entry lastEntry = null;\n+        Object lastKey = null;\n+        Object lastValue = null;\n+        Set set = new HashSet();\n+        while (it.hasNext()) {\n+            // getKey\n+            Object key = it.next();\n+            assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.add(key));\n+            \n+            // getValue\n+            Object value = it.getValue();\n+            assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+            assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            \n+            // asMapEntry\n+            Map.Entry entry = it.asMapEntry();\n+            assertSame(\"MapEntry key must match\", key, entry.getKey());\n+            assertSame(\"MapEntry value must match\", value, entry.getValue());\n+            \n+            assertTrue(\"MapEntry must be independent\", entry != lastEntry);\n+            if (lastKey != null && lastValue != null) {\n+                assertSame(\"MapEntry must not change after next()\", lastKey, lastEntry.getKey());\n+                assertSame(\"MapEntry must not change after next()\", lastValue, lastEntry.getValue());\n+            }\n+            \n+            lastEntry = entry;\n+            lastKey = key;\n+            lastValue = value;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSet() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        Object newValue = addSetValue();\n+        MapIterator it = makeFullMapIterator();\n+        Map map = getMap();\n+        assertEquals(true, it.hasNext());\n+        Object key = it.next();\n+        Object value = it.getValue();\n+        Entry entry = it.asMapEntry();\n+        \n+        if (supportsSetValue() == false) {\n+            try {\n+                it.setValue(newValue);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        \n+        Object old = it.setValue(newValue);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Key must not change after setValue\", key, entry.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        assertSame(\"Value must be changed after setValue\", newValue, entry.getValue());\n+        assertSame(\"setValue must return old value\", value, old);\n+        if (supportsTiedMap()) {\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Old value must not be in map\",  map.containsValue(value) == false);\n+            assertTrue(\"Value must be in map\",  map.containsValue(newValue));\n+            assertSame(\"Value must be mapped to key\", map.get(key), newValue);\n+        }\n+        \n+        it.setValue(newValue);  // same value - should be OK\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Key must not change after setValue\", key, entry.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        assertSame(\"Value must be changed after setValue\", newValue, entry.getValue());\n+        if (supportsTiedMap()) {\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Old value must not be in map\",  map.containsValue(value) == false);\n+            assertTrue(\"Value must be in map\",  map.containsValue(newValue));\n+            assertSame(\"Value must be mapped to key\", map.get(key), newValue);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorMapEntrySet() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        Object newValue = addSetValue();\n+        MapIterator it = makeFullMapIterator();\n+        Map map = getMap();\n+        assertEquals(true, it.hasNext());\n+        Object key = it.next();\n+        Object value = it.getValue();\n+        Entry entry = it.asMapEntry();\n+        \n+        if (supportsSetValue() == false) {\n+            try {\n+                entry.setValue(newValue);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        \n+        Object old = entry.setValue(newValue);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Key must not change after setValue\", key, entry.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        assertSame(\"Value must be changed after setValue\", newValue, entry.getValue());\n+        assertSame(\"setValue must return old value\", value, old);\n+        if (supportsTiedMap()) {\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Old value must not be in map\",  map.containsValue(value) == false);\n+            assertTrue(\"Value must be in map\",  map.containsValue(newValue));\n+            assertSame(\"Value must be mapped to key\", map.get(key), newValue);\n+        }\n+        \n+        entry.setValue(newValue);  // same value - should be OK\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Key must not change after setValue\", key, entry.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        assertSame(\"Value must be changed after setValue\", newValue, entry.getValue());\n+        if (supportsTiedMap()) {\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Old value must not be in map\",  map.containsValue(value) == false);\n+            assertTrue(\"Value must be in map\",  map.containsValue(newValue));\n+            assertSame(\"Value must be mapped to key\", map.get(key), newValue);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiMapIteratorSetRemoveSet() {\n+        if (supportsSetValue() == false || supportsRemove() == false) {\n+            return;\n+        }\n+        Object newValue = addSetValue();\n+        \n+        MapIterator it = makeFullMapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key = it.next();\n+        \n+        it.setValue(newValue);\n+        it.remove();\n+        \n+        try {\n+            it.setValue(newValue);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/iterators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/TestAll.java,v 1.8 2003/11/02 17:26:36 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/TestAll.java,v 1.9 2003/11/02 18:29:59 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Entry point for all iterator tests.\n  * \n- * @version $Revision: 1.8 $ $Date: 2003/11/02 17:26:36 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/02 18:29:59 $\n  * \n  * @author Rodney Waldhoff\n  */\n         suite.addTest(TestUniqueFilterIterator.suite());\n         suite.addTest(TestUnmodifiableIterator.suite());\n         suite.addTest(TestUnmodifiableListIterator.suite());\n+        suite.addTest(TestUnmodifiableMapIterator.suite());\n         return suite;\n     }\n         \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java,v 1.1 2003/11/02 18:29:59 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.DualHashBidiMap;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Tests the UnmodifiableMapIterator.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/02 18:29:59 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableMapIterator extends AbstractTestMapIterator {\n+\n+    public static Test suite() {\n+        return new TestSuite(TestUnmodifiableMapIterator.class);\n+    }\n+\n+    public TestUnmodifiableMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    public MapIterator makeEmptyMapIterator() {\n+        return UnmodifiableMapIterator.decorate(new DualHashBidiMap().mapIterator());\n+    }\n+\n+    public MapIterator makeFullMapIterator() {\n+        return UnmodifiableMapIterator.decorate(((BidiMap) getMap()).mapIterator());\n+    }\n+    \n+    protected Map getMap() {\n+        Map testMap = new DualHashBidiMap();\n+        testMap.put(\"A\", \"a\");\n+        testMap.put(\"B\", \"b\");\n+        testMap.put(\"C\", \"c\");\n+        return testMap;\n+    }\n+\n+\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public boolean supportsSetValue() {\n+        return false;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testMapIterator() {\n+        assertTrue(makeEmptyMapIterator() instanceof Unmodifiable);\n+    }\n+    \n+    public void testDecorateFactory() {\n+        MapIterator it = makeFullMapIterator();\n+        assertSame(it, UnmodifiableMapIterator.decorate(it));\n+        \n+        it = ((BidiMap) getMap()).mapIterator() ;\n+        assertTrue(it != UnmodifiableMapIterator.decorate(it));\n+        \n+        try {\n+            UnmodifiableMapIterator.decorate(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}", "timestamp": 1067797799, "metainfo": ""}