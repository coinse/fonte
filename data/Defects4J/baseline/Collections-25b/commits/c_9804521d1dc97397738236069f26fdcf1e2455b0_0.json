{"sha": "9804521d1dc97397738236069f26fdcf1e2455b0", "log": "Adding in OrderedMap class. Similar functionality to a SequencedHashmap, it is decorable and able to sit on top of other Map implementations.  This is the first version to pass the unit tests, so I'm pushing it in. The major thing I know it doesn't do is that keySet/entrySet and values iterator() methods do not back their remove()'s onto the Map itself. The views themselves do, just not their iterators yet.  This shows that we need unit tests for these :)   ", "commit": "\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.37 2003/09/21 16:26:08 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.38 2003/10/03 06:24:13 bayard Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.decorators.FixedSizeSortedMap;\n import org.apache.commons.collections.decorators.LazyMap;\n import org.apache.commons.collections.decorators.LazySortedMap;\n+import org.apache.commons.collections.decorators.OrderedMap;\n import org.apache.commons.collections.decorators.PredicatedMap;\n import org.apache.commons.collections.decorators.PredicatedSortedMap;\n import org.apache.commons.collections.decorators.TransformedMap;\n  *  </ul>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.37 $ $Date: 2003/09/21 16:26:08 $\n+ * @version $Revision: 1.38 $ $Date: 2003/10/03 06:24:13 $\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n         return LazyMap.decorate(map, transformerFactory);\n     }\n \n+    /**\n+     * Returns a map that maintains the order of keys that are added\n+     * backed by the given map.\n+     * <p>\n+     * If a key is added twice, the order is determined by the first add.\n+     * The order is observed through the keySet, values and entrySet.\n+     *\n+     * @param map  the map to order, must not be null\n+     * @return an ordered map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static Map orderedMap(Map map) {\n+        return OrderedMap.decorate(map);\n+    }\n+    \n     // SortedMap decorators\n     //-----------------------------------------------------------------------\n     /**\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/decorators/OrderedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/OrderedMap.java,v 1.1 2003/10/03 06:24:13 bayard Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.DefaultMapEntry;\n+\n+/**\n+ * Decorates a <code>Map</code> to ensure that the order of addition\n+ * is retained and used by the values and keySet iterators.\n+ * <p>\n+ * If an object is added to the Map for a second time, it will remain in the\n+ * original position in the iteration.\n+ * <p>\n+ * The order can be observed via the iterator or toArray methods.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/10/03 06:24:13 $\n+ * \n+ * @author Henri Yandell\n+ */\n+public class OrderedMap extends AbstractMapDecorator implements Map {\n+\n+    /** Internal list to hold the sequence of objects */\n+    protected final List insertOrder = new ArrayList();\n+\n+    /**\n+     * Factory method to create an ordered map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static Map decorate(Map map) {\n+        return new OrderedMap(map);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected OrderedMap(Map map) {\n+        super(map);\n+        insertOrder.addAll( getMap().keySet() );\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void clear() {\n+        getMap().clear();\n+        insertOrder.clear();\n+    }\n+\n+    public void putAll(Map m) {\n+        for (Iterator it = m.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        if (getMap().containsKey(key)) {\n+            // re-adding doesn't change order\n+            return getMap().put(key, value);\n+        } else {\n+            // first add, so add to both map and list\n+            Object result = getMap().put(key, value);\n+            insertOrder.add(key);\n+            return result;\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Object result = getMap().remove(key);\n+        insertOrder.remove(key);\n+        return result;\n+    }\n+\n+    //// From here on down, this becomes hell.\n+\n+    public Set keySet() {\n+        // TODO: calling remove on the Set needs to remove from this Map\n+        // Iterator.remove, Set.remove, removeAll retainAll, and clear \n+\n+        return new KeyView( this, this.insertOrder );\n+\n+        /* OLD\n+        Set set = new java.util.HashSet( insertOrder.size() );\n+        set = OrderedSet.decorate( set );\n+        for (Iterator it = insertOrder.iterator(); it.hasNext();) {\n+            set.add( it.next() );\n+        }\n+        return set;\n+        */\n+    }\n+\n+    public Collection values() {\n+        // TODO: calling remove on the Collection needs to remove from this Map\n+        // Iterator.remove, Collection.remove, removeAll, retainAll and clear\n+        return new ValuesView( this, this.insertOrder );\n+    }\n+\n+    // QUERY: Should a change of value change insertion order?\n+    public Set entrySet() {\n+        // TODO: calling remove on the Set needs to remove from this Map\n+        // Iterator.remove, Set.remove, removeAll, retainAll and clear\n+        return new EntrySetView( this, this.insertOrder );\n+    }\n+\n+    // TODO: Code a toString up. \n+    //       It needs to retain the right order, else it will \n+    //       look peculiar.\n+    public String toString() {\n+        return super.toString();\n+    }\n+\n+    // class for handling the values() method's callback to this Map\n+    // THESE NEED UNIT TESTING as their own collections\n+    class ValuesView implements Collection {\n+        private OrderedMap parent;\n+        private List insertOrder;\n+\n+        ValuesView(OrderedMap parent, List insertOrder) {\n+            this.parent = parent;\n+            this.insertOrder = insertOrder;\n+        }\n+\n+        // slow to call\n+        Collection _values() {\n+            Iterator keys = this.insertOrder.iterator();\n+            ArrayList list = new ArrayList( insertOrder.size() );\n+            while( keys.hasNext() ) {\n+                list.add( this.parent.getMap().get( keys.next() ) );\n+            }\n+            return list;\n+        }\n+\n+        public int size() {\n+            return this.parent.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return this.parent.isEmpty();\n+        }\n+\n+        public boolean contains(Object value) {\n+            return this.parent.containsValue(value);\n+        }\n+\n+        public Iterator iterator() {\n+            // TODO: Allow this to be backed\n+            return _values().iterator();\n+//            return new ValuesViewIterator( who? );\n+        }\n+\n+        public Object[] toArray() {\n+            return _values().toArray();\n+        }\n+\n+        public Object[] toArray(Object[] array) {\n+            return _values().toArray(array);\n+        }\n+\n+        public boolean add(Object obj) {\n+            throw new UnsupportedOperationException(\"Not allowed. \");\n+        }\n+\n+        public boolean remove(Object obj) {\n+            // who?? which value do I choose? first one?\n+            for(Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n+                Object key = itr.next();\n+                Object value = this.parent.get(key);\n+\n+                // also handles null\n+                if(value == obj) {\n+                    return (this.parent.remove(key) != null);\n+                } \n+\n+                if( (value != null) && value.equals(obj) ) {\n+                    return (this.parent.remove(key) != null);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        public boolean containsAll(Collection coll) {\n+            // TODO: What does Collection spec say about null/empty?\n+            for(Iterator itr = coll.iterator(); itr.hasNext(); ) {\n+                if( !this.parent.containsValue( itr.next() ) ) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        public boolean addAll(Collection coll) {\n+            throw new UnsupportedOperationException(\"Not allowed. \");\n+        }\n+\n+        public boolean removeAll(Collection coll) {\n+            // not transactional. No idea if removeAll's boolean\n+            // reply is meant to be\n+            boolean ret = false;\n+            for( Iterator itr = coll.iterator(); itr.hasNext(); ) {\n+                ret = ret && remove(itr.next());\n+            }\n+            return ret;\n+        }\n+\n+        public boolean retainAll(Collection coll) {\n+            // transactional?\n+            boolean ret = false;\n+\n+            for( Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n+                Object key = itr.next();\n+                Object value = this.parent.get(key);\n+                if( coll.contains(value) ) {\n+                    // retain\n+                } else {\n+                    ret = ret && (parent.remove(key) != null);\n+                }\n+            }\n+\n+            return ret;\n+        }\n+\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        public boolean equals(Object obj) {\n+            // exactly what to do here?\n+            return super.equals(obj);\n+        }\n+        public int hashCode() {\n+            return _values().hashCode();\n+        }\n+\n+        public String toString() {\n+            return _values().toString();\n+        }\n+    }\n+\n+    class KeyView implements Set {\n+\n+        private OrderedMap parent;\n+        private List insertOrder;\n+\n+        public KeyView(OrderedMap parent, List insertOrder) {\n+            this.parent = parent;\n+            this.insertOrder = insertOrder;\n+        }\n+\n+        public int size() {\n+            return this.parent.size();\n+        }\n+        public boolean isEmpty() {\n+            return this.parent.isEmpty();\n+        }\n+        public boolean contains(Object obj) {\n+            return this.parent.containsKey(obj);\n+        }\n+        public Iterator iterator() {\n+            // TODO: Needs to return a KeyViewIterator, which \n+            //       removes from this and from the Map\n+            return this.insertOrder.iterator();\n+        }\n+        public Object toArray()[] {\n+            return this.insertOrder.toArray();\n+        }\n+        public Object toArray(Object[] array)[] {\n+            return this.insertOrder.toArray(array);\n+        }\n+        public boolean add(Object obj) {\n+            throw new UnsupportedOperationException(\"Not allowed. \");\n+        }\n+        public boolean remove(Object obj) {\n+            return (this.parent.remove(obj) != null);\n+        }\n+        public boolean containsAll(Collection coll) {\n+            // TODO: What does Collection spec say about null/empty?\n+            for(Iterator itr = coll.iterator(); itr.hasNext(); ) {\n+                if( !this.parent.containsKey( itr.next() ) ) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        public boolean addAll(Collection coll) {\n+            throw new UnsupportedOperationException(\"Not allowed. \");\n+        }\n+        public boolean removeAll(Collection coll) {\n+            // not transactional. No idea if removeAll's boolean\n+            // reply is meant to be\n+            boolean ret = false;\n+            for( Iterator itr = coll.iterator(); itr.hasNext(); ) {\n+                ret = ret && remove(itr.next());\n+            }\n+            return ret;\n+        }\n+        public boolean retainAll(Collection coll) {\n+            // transactional?\n+            boolean ret = false;\n+\n+            for( Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n+                Object key = itr.next();\n+                if( coll.contains(key) ) {\n+                    // retain\n+                } else {\n+                    ret = ret && (parent.remove(key) != null);\n+                }\n+            }\n+\n+            return ret;\n+        }\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+        public boolean equals(Object obj) {\n+            // exactly what to do here?\n+            return super.equals(obj);\n+        }\n+        public int hashCode() {\n+            return this.parent.getMap().keySet().hashCode();\n+        }\n+\n+        public String toString() {\n+            return this.insertOrder.toString();\n+        }\n+    }\n+\n+    class EntrySetView implements Set {\n+\n+        private OrderedMap parent;\n+        private List insertOrder;\n+\n+        public EntrySetView(OrderedMap parent, List insertOrder) {\n+            this.parent = parent;\n+            this.insertOrder = insertOrder;\n+        }\n+\n+        public int size() {\n+            return this.parent.size();\n+        }\n+        public boolean isEmpty() {\n+            return this.parent.isEmpty();\n+        }\n+\n+        public boolean contains(Object obj) {\n+            if(obj instanceof Map.Entry) {\n+                Map.Entry entry = (Map.Entry) obj;\n+                if( this.parent.containsKey(entry.getKey()) ) {\n+                    Object value = this.parent.get(entry.getKey());\n+                    if( obj == null && value == null ) {\n+                        return true;\n+                    } else {\n+                        return obj.equals(value);\n+                    }\n+                } else {\n+                    return false;\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Parameter must be a Map.Entry\");\n+            }\n+        }\n+        // tmp\n+        public Set _entries() {\n+            // TODO: Needs to return a EntrySetViewIterator, which \n+            //       removes from this and from the Map\n+            Set set = new java.util.HashSet( this.insertOrder.size() );\n+            set = OrderedSet.decorate( set );\n+            for (Iterator it = insertOrder.iterator(); it.hasNext();) {\n+                Object key = it.next();\n+                set.add( new DefaultMapEntry( key, getMap().get( key ) ) );\n+            }\n+            return set;\n+        }\n+        public Iterator iterator() {\n+            return _entries().iterator();\n+        }\n+        public Object toArray()[] {\n+            return _entries().toArray();\n+        }\n+        public Object toArray(Object[] array)[] {\n+            return _entries().toArray(array);\n+        }\n+        public boolean add(Object obj) {\n+            throw new UnsupportedOperationException(\"Not allowed. \");\n+        }\n+        public boolean remove(Object obj) {\n+            if(obj instanceof Map.Entry) {\n+                Map.Entry entry = (Map.Entry) obj;\n+                return (this.parent.remove(entry.getKey()) != null);\n+            } else {\n+                throw new IllegalArgumentException(\"Parameter must be a Map.Entry\");\n+            }\n+        }\n+        // need to decide on IllegalArgument or ClassCast in this class\n+        // when not Map.Entry\n+        public boolean containsAll(Collection coll) {\n+            // TODO: What does Collection spec say about null/empty?\n+            for(Iterator itr = coll.iterator(); itr.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) itr.next();\n+                if( !this.parent.containsKey( entry.getKey() ) ) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        public boolean addAll(Collection coll) {\n+            throw new UnsupportedOperationException(\"Not allowed. \");\n+        }\n+        public boolean removeAll(Collection coll) {\n+            // not transactional. No idea if removeAll's boolean\n+            // reply is meant to be\n+            boolean ret = false;\n+            for( Iterator itr = coll.iterator(); itr.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) itr.next();\n+                ret = ret && remove( entry.getKey() );\n+            }\n+            return ret;\n+        }\n+        public boolean retainAll(Collection coll) {\n+            // transactional?\n+            boolean ret = false;\n+\n+            for( Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) itr.next();\n+                Object key = entry.getKey();\n+                if( coll.contains(key) ) {\n+                    // retain\n+                } else {\n+                    ret = ret && (parent.remove(key) != null);\n+                }\n+            }\n+\n+            return ret;\n+        }\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+        public boolean equals(Object obj) {\n+            // exactly what to do here?\n+            return super.equals(obj);\n+        }\n+        public int hashCode() {\n+            return this.parent.getMap().entrySet().hashCode();\n+        }\n+\n+        public String toString() {\n+            return this._entries().toString();\n+        }\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/decorators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.16 2003/10/02 22:34:44 matth Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.17 2003/10/03 06:24:13 bayard Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for all collections decorators tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.16 $ $Date: 2003/10/02 22:34:44 $\n+ * @version $Revision: 1.17 $ $Date: 2003/10/03 06:24:13 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestLazySortedMap.suite());\n         \n         suite.addTest(TestOrderedSet.suite());\n+        suite.addTest(TestOrderedMap.suite());\n+\n         suite.addTest(TestSetList.suite());\n         \n         suite.addTest(TestTransformedBag.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/TestOrderedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestOrderedMap.java,v 1.1 2003/10/03 06:24:13 bayard Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestMap;\n+\n+/**\n+ * Extension of {@link TestMap} for exercising the {@link OrderedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/10/03 06:24:13 $\n+ * \n+ * @author Henri Yandell\n+ */\n+public class TestOrderedMap extends TestMap {\n+\n+    public TestOrderedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestOrderedMap.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestOrderedMap.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return OrderedMap.decorate(new HashMap());\n+    }\n+\n+    // Creates a known series of Objects, puts them in \n+    // an OrderedMap and ensures that all three Collection \n+    // methods return in the correct order.\n+    public void testInsertionOrder() {\n+        int size = 10; // number to try\n+        ArrayList list = new ArrayList(size);\n+        for( int i=0; i<size; i++ ) {\n+            list.add( new Object() );\n+        }\n+\n+        Map map = makeEmptyMap();\n+        for( Iterator itr = list.iterator(); itr.hasNext(); ) {\n+            Object obj = itr.next();\n+            map.put( obj, obj );\n+        }\n+\n+        assertSameContents(map.values(), list);\n+        assertSameContents(map.keySet(), list);\n+\n+        // check entrySet\n+        Set entries = map.entrySet();\n+        assertEquals( entries.size(), list.size() );\n+        Iterator i1 = entries.iterator();\n+        Iterator i2 = list.iterator();\n+        while( i1.hasNext() && i2.hasNext() ) {\n+            Map.Entry entry = (Map.Entry) i1.next();\n+            Object obj = i2.next();\n+            assertSame( entry.getKey(), obj );\n+            assertSame( entry.getValue(), obj );\n+        }\n+        assertTrue( !(i1.hasNext() && i2.hasNext()) );\n+\n+    }\n+\n+    private void assertSameContents(Collection c1, Collection c2) {\n+        assertNotNull(c1);\n+        assertNotNull(c2);\n+        assertEquals( c1.size(), c2.size() );\n+        Iterator i1 = c1.iterator();\n+        Iterator i2 = c2.iterator();\n+        while( i1.hasNext() && i2.hasNext() ) {\n+            assertSame( i1.next(), i2.next() );\n+        }\n+        // ensure they've both ended\n+        assertTrue( !(i1.hasNext() && i2.hasNext()) );\n+    }\n+\n+}", "timestamp": 1065162253, "metainfo": ""}