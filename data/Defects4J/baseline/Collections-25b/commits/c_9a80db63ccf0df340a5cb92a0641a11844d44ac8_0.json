{"sha": "9a80db63ccf0df340a5cb92a0641a11844d44ac8", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r814061 | mbenson | 2009-09-11 15:22:41 -0700 (Fri, 11 Sep 2009) | 1 line          finish extraction of abstract class     ------------------------------------------------------------------------     r814060 | mbenson | 2009-09-11 15:21:50 -0700 (Fri, 11 Sep 2009) | 1 line          Get does not clear()     ------------------------------------------------------------------------     r814050 | sebb | 2009-09-11 15:01:25 -0700 (Fri, 11 Sep 2009) | 1 line          Some minor Javadoc fixes     ------------------------------------------------------------------------     r751901 | mbenson | 2009-03-09 16:06:49 -0700 (Mon, 09 Mar 2009) | 1 line          comments     ------------------------------------------------------------------------     r751894 | mbenson | 2009-03-09 15:48:07 -0700 (Mon, 09 Mar 2009) | 1 line          add splitmap package whose original goal is to provide a more versatile TransformedMap implementation     ------------------------------------------------------------------------   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.IterableGet;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.map.EntrySetToMapIteratorAdapter;\n+\n+/**\n+ * {@link IterableGet} that uses a {@link Map}<K, V> for the {@link Get}<K, V>\n+ * implementation.\n+ *\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matt Benson\n+ */\n+public class AbstractIterableGetMapDecorator<K, V> implements IterableGet<K, V> {\n+    /** The map to decorate */\n+    protected transient Map<K, V> map;\n+\n+    /**\n+     * Create a new AbstractSplitMapDecorator.\n+     * @param decorated the Map to decorate\n+     */\n+    public AbstractIterableGetMapDecorator(Map<K, V> decorated) {\n+        this.map = decorated;\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     *\n+     * @return the decorated map\n+     */\n+    protected Map<K, V> decorated() {\n+        return map;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsKey(Object key) {\n+        return decorated().containsKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsValue(Object value) {\n+        return decorated().containsValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return decorated().entrySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V get(Object key) {\n+        return decorated().get(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V remove(Object key) {\n+        return decorated().remove(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Collection<V> values() {\n+        return decorated().values();\n+    }\n+\n+    /**\n+     * Get a MapIterator over this Get.\n+     * @return MapIterator<K, V>\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new EntrySetToMapIteratorAdapter<K, V>(entrySet());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return decorated().equals(object);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/splitmap/SplitMapUtils.java\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.IterableGet;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections.map.EntrySetToMapIteratorAdapter;\n+import org.apache.commons.collections.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Utilities for working with \"split maps:\" objects that implement {@link Put}\n+ * and/or {@link Get} but not {@link Map}.\n+ *\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ * @see Get\n+ * @see Put\n+ * @author Matt Benson\n+ */\n+public class SplitMapUtils {\n+\n+    /**\n+     * <code>SplitMapUtils</code> should not normally be instantiated.\n+     */\n+    public SplitMapUtils() {\n+    }\n+\n+    private static class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n+        private Get<K, V> get;\n+\n+        private WrappedGet(Get<K, V> get) {\n+            this.get = get;\n+        }\n+\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            return get.containsKey(key);\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            return get.containsValue(value);\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            return UnmodifiableEntrySet.decorate(get.entrySet());\n+        }\n+\n+        @Override\n+        public boolean equals(Object arg0) {\n+            if (arg0 == this) {\n+                return true;\n+            }\n+            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(this.get);\n+        }\n+\n+        public V get(Object key) {\n+            return get.get(key);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedGet\".hashCode() << 4) | get.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            return get.isEmpty();\n+        }\n+\n+        public Set<K> keySet() {\n+            return UnmodifiableSet.decorate(get.keySet());\n+        }\n+\n+        public V put(K key, V value) {\n+            throw new UnsupportedOperationException();\n+        };\n+\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V remove(Object key) {\n+            return get.remove(key);\n+        }\n+\n+        public int size() {\n+            return get.size();\n+        }\n+\n+        public Collection<V> values() {\n+            return UnmodifiableCollection.decorate(get.values());\n+        }\n+\n+        public MapIterator<K, V> mapIterator() {\n+            MapIterator<K, V> it;\n+            if (get instanceof IterableGet) {\n+                it = ((IterableGet<K, V>) get).mapIterator();\n+            } else {\n+                it = new EntrySetToMapIteratorAdapter<K, V>(get.entrySet());\n+            }\n+            return UnmodifiableMapIterator.decorate(it);\n+        }\n+    }\n+\n+    private static class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n+        private Put<K, V> put;\n+\n+        private WrappedPut(Put<K, V> put) {\n+            this.put = put;\n+        }\n+\n+        public void clear() {\n+            put.clear();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(this.put);\n+        }\n+\n+        public V get(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedPut\".hashCode() << 4) | put.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<K> keySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V put(K key, V value) {\n+            return (V) put.put(key, value);\n+        };\n+\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+            put.putAll(t);\n+        }\n+\n+        public V remove(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int size() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Collection<V> values() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Get the specified {@link Get} as an instance of {@link IterableMap}.\n+     * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n+     * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n+     * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n+     * @param <K>\n+     * @param <V>\n+     * @param get to wrap, must not be null\n+     * @return {@link IterableMap}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> IterableMap<K, V> readableMap(Get<K, V> get) {\n+        if (get == null) {\n+            throw new IllegalArgumentException(\"Get must not be null\");\n+        }\n+        if (get instanceof Map) {\n+            return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils\n+                    .iterableMap((Map<K, V>) get);\n+        }\n+        return new WrappedGet<K, V>(get);\n+    }\n+\n+    /**\n+     * Get the specified {@link Put} as an instanceof {@link Map}.\n+     * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n+     * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n+     * it is recommended that the result of #put(K, V) be discarded as it likely will not\n+     * match <code>V</code> at runtime.\n+     *\n+     * @param <K>\n+     * @param <V>\n+     * @param put to wrap, must not be null\n+     * @return {@link Map}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> Map<K, V> writableMap(Put<K, V> put) {\n+        if (put == null) {\n+            throw new IllegalArgumentException(\"Put must not be null\");\n+        }\n+        if (put instanceof Map) {\n+            return (Map<K, V>) put;\n+        }\n+        return new WrappedPut<K, V>(put);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/splitmap/TransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.map.LinkedMap;\n+\n+/**\n+ * Decorates another <code>Map</code> to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must use\n+ * the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. The simplest approach\n+ * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n+ * This class may throw exceptions when accessed by concurrent threads without\n+ * synchronization.\n+ * <p>\n+ * The \"put\" and \"get\" type constraints of this class are mutually independent;\n+ * contrast with {@link org.apache.commons.collections.map.TransformedMap} which,\n+ * by virtue of its implementing {@link Map}&lt;K, V&gt;, must be constructed in such\n+ * a way that its read and write parameters are generalized to a common (super-)type.\n+ * In practice this would often mean <code>&gt;Object, Object&gt;</code>, defeating\n+ * much of the usefulness of having parameterized types.\n+ * <p>\n+ * On the downside, this class is not a drop-in replacement for {@link java.util.Map}\n+ * but is intended to be worked with either directly or by {@link Put} and {@link Get}\n+ * generalizations.\n+ *\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class TransformedMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V> implements\n+        Put<J, U>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5966875321133456994L;\n+\n+    /** The transformer to use for the key */\n+    private final Transformer<? super J, ? extends K> keyTransformer;\n+    /** The transformer to use for the value */\n+    private final Transformer<? super U, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are\n+     * NOT transformed.\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     * means no transformation\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     * means no transformation\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <J, K, U, V> TransformedMap<J, K, U, V> decorate(Map<K, V> map,\n+            Transformer<? super J, ? extends K> keyTransformer,\n+            Transformer<? super U, ? extends V> valueTransformer) {\n+        return new TransformedMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     * means no conversion\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     * means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedMap(Map<K, V> map, Transformer<? super J, ? extends K> keyTransformer,\n+            Transformer<? super U, ? extends V> valueTransformer) {\n+        super(map);\n+        if (keyTransformer == null) {\n+            throw new IllegalArgumentException(\"keyTransformer cannot be null\");\n+        }\n+        this.keyTransformer = keyTransformer;\n+        if (valueTransformer == null) {\n+            throw new IllegalArgumentException(\"valueTransformer cannot be null\");\n+        }\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     *\n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     *\n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @throws the transformed object\n+     */\n+    protected K transformKey(J object) {\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @throws the transformed object\n+     */\n+    protected V transformValue(U object) {\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map the map to transform\n+     * @throws the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(Map<? extends J, ? extends U> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n+            result.put((K) transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     *\n+     * @param value the value to transform\n+     * @return the transformed value\n+     */\n+    protected V checkSetValue(U value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V put(J key, U value) {\n+        return decorated().put(transformKey(key), transformValue(value));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void putAll(Map<? extends J, ? extends U> mapToCopy) {\n+        decorated().putAll(transformMap(mapToCopy));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void clear() {\n+        decorated().clear();\n+    }\n+}", "timestamp": 1252994210, "metainfo": ""}