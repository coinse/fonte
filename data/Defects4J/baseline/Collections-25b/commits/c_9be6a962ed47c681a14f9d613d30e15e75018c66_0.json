{"sha": "9be6a962ed47c681a14f9d613d30e15e75018c66", "log": "Refactor SetList to be a subclass of the abstract decorator   ", "commit": "\n--- a/src/java/org/apache/commons/collections/decorators/SetList.java\n+++ b/src/java/org/apache/commons/collections/decorators/SetList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/SetList.java,v 1.1 2003/10/02 22:34:44 matth Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/SetList.java,v 1.2 2003/10/04 00:50:35 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.decorators;\n \n-import java.util.AbstractList;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Set;\n \n /**\n  * class provides an alternative approach, by wrapping an existing Set and\n  * retaining insertion order in the iterator. This class offers the <code>List</code>\n  * interface implementation as well.\n- * <p>\n- * If the <code>Set</code> aspects are important to you (fast add/contains/remove)\n- * then <code>OrderedSet</code> is a better choice.\n- * This implementation is based solely on <code>ArrayList</code>, and so has\n- * slow add/contains/remove operations for all except small lists.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/10/02 22:34:44 $\n+ * @version $Revision: 1.2 $ $Date: 2003/10/04 00:50:35 $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public class SetList extends AbstractList {\n-\n-    /**\n-     * Delegate list.\n-     */\n-    private final List delegate = new ArrayList();\n-\n-    /**\n-     * Helps to maintain uniqueness.\n-     */\n-    private final Set set = new HashSet();\n-\n-    /**\n-     * Factory method to create a SetList.\n-     * @param list the list to decorate\n+public class SetList extends AbstractListDecorator {\n+\n+    /**\n+     * Internal Set to maintain uniqueness.\n+     */\n+    protected final Set set;\n+\n+    /**\n+     * Factory method to create a SetList using the supplied list to retain order.\n+     * <p>\n+     * If the list contains duplicates, these are removed (first indexed one kept).\n+     * A <code>HashSet</code> is used for the set behaviour.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n      */\n     public static SetList decorate(List list) {\n-        return new SetList(list);\n-    }\n-\n-    /**\n-     * Contructs an new list copying the specified elements.\n-     * @param coll  a collection to copy\n-     */\n-    protected SetList(List list) {\n-        addAll(list);\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (list.isEmpty()) {\n+            return new SetList(list, new HashSet());\n+        } else {\n+            List temp = new ArrayList(list);\n+            list.clear();\n+            SetList sl = new SetList(list, new HashSet());\n+            sl.addAll(temp);\n+            return sl;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) the List and specifies the set to use.\n+     * <p>\n+     * The set and list must both be correctly initialised to the same elements.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if set or list is null\n+     */\n+    protected SetList(List list, Set set) {\n+        super(list);\n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        this.set = set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an unmodifiable view as a Set.\n+     * \n+     * @return an unmodifiable set view\n+     */\n+    public Set asSet() {\n+        return Collections.unmodifiableSet(set);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param object  the object to add\n      */\n     public void add(int index, Object object) {\n-        // Adds element if it is not contained already\n-        if (!set.contains(object)) {\n-            delegate.add(index, object);\n+        // adds element if it is not contained already\n+        if (set.contains(object) == false) {\n+            super.add(index, object);\n             set.add(object);\n         }\n     }\n \n-    //-----------------------------------------------------------------------\n+    /**\n+     * Adds an element to the end of the list if it is not already present.\n+     * <p>\n+     * <i>(Violation)</i>\n+     * The <code>List</code> interface makes the assumption that the element is\n+     * always inserted. This may not happen with this implementation.\n+     * \n+     * @param index  the index to insert at\n+     * @param object  the object to add\n+     */\n+    public boolean addAll(Collection coll) {\n+        return addAll(size(), coll);\n+    }\n+\n     /**\n      * Adds a collection of objects to the end of the list avoiding duplicates.\n      * <p>\n      */\n     public Object set(int index, Object object) {\n         int pos = indexOf(object);\n-        Object result = delegate.set(index, object);\n+        Object result = super.set(index, object);\n         if (pos == -1 || pos == index) {\n             return result;\n         }\n         return remove(pos);\n     }\n \n-    public Object get(int index) {\n-        return delegate.get(index);\n-    }\n-\n-    public int size() {\n-        return delegate.size();\n+    public boolean remove(Object object) {\n+        boolean result = super.remove(object);\n+        set.remove(object);\n+        return result;\n     }\n \n     public Object remove(int index) {\n-        return delegate.remove(index);\n+        Object result = super.remove(index);\n+        set.remove(result);\n+        return result;\n+    }\n+\n+    public boolean removeAll(Collection coll) {\n+        boolean result = super.removeAll(coll);\n+        set.removeAll(coll);\n+        return result;\n+    }\n+\n+    public boolean retainAll(Collection coll) {\n+        boolean result = super.retainAll(coll);\n+        set.retainAll(coll);\n+        return result;\n     }\n \n     public void clear() {\n-        delegate.clear();\n+        super.clear();\n         set.clear();\n     }\n \n+    public boolean contains(Object object) {\n+        return set.contains(object);\n+    }\n+\n+    public boolean containsAll(Collection coll) {\n+        return set.containsAll(coll);\n+    }\n+\n+    public Iterator iterator() {\n+        return new SetListIterator(super.iterator(), set);\n+    }\n+\n+    public ListIterator listIterator() {\n+        return new SetListListIterator(super.listIterator(), set);\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        return new SetListListIterator(super.listIterator(index), set);\n+    }\n+\n+    public List subList(int fromIndex, int toIndex) {\n+        return new SetList(super.subList(fromIndex, toIndex), set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class iterator.\n+     */\n+    protected static class SetListIterator extends AbstractIteratorDecorator {\n+        \n+        protected final Set set;\n+        protected Object last = null;\n+        \n+        protected SetListIterator(Iterator it, Set set) {\n+            super(it);\n+            this.set = set;\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+\n+    }\n+    \n+    /**\n+     * Inner class iterator.\n+     */\n+    protected static class SetListListIterator extends AbstractListIteratorDecorator {\n+        \n+        protected final Set set;\n+        protected Object last = null;\n+        \n+        protected SetListListIterator(ListIterator it, Set set) {\n+            super(it);\n+            this.set = set;\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public Object previous() {\n+            last = super.previous();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+\n+        public void add(Object object) {\n+            if (set.contains(object) == false) {\n+                super.add(object);\n+                set.add(object);\n+            }\n+        }\n+        \n+        public void set(Object object) {\n+            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n+        }\n+\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/collections/decorators/TestSetList.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestSetList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestSetList.java,v 1.1 2003/10/02 22:34:44 matth Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestSetList.java,v 1.2 2003/10/04 00:50:35 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.ListIterator;\n \n import junit.framework.Test;\n-import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n \n+import org.apache.commons.collections.AbstractTestList;\n+\n /**\n  * JUnit tests.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/10/02 22:34:44 $\n+ * @version $Revision: 1.2 $ $Date: 2003/10/04 00:50:35 $\n  * \n  * @author Matthew Hawthorne\n  */\n-public class TestSetList extends TestCase {\n+public class TestSetList extends AbstractTestList {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testConstructor() {\n-        final SetList lset =\n-            new SetList(\n-                Arrays.asList(new Integer[] { new Integer(1), new Integer(1)}));\n-\n-        assertEquals(\"Duplicate element was added.\", 1, lset.size());\n+    protected List makeEmptyList() {\n+        return new SetList(new ArrayList(), new HashSet());\n+    }\n+\n+    public void testListIteratorSet() {\n+        // override to block\n+        resetFull();\n+        ListIterator it = getList().listIterator();\n+        it.next();\n+        try {\n+            it.set(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+    \n+    protected Object[] getFullNonNullElements() {\n+        // override to avoid duplicate \"One\"\n+        return new Object[] {\n+            new String(\"\"),\n+            new String(\"One\"),\n+            new Integer(2),\n+            \"Three\",\n+            new Integer(4),\n+            new Double(5),\n+            new Float(6),\n+            \"Seven\",\n+            \"Eight\",\n+            new String(\"Nine\"),\n+            new Integer(10),\n+            new Short((short)11),\n+            new Long(12),\n+            \"Thirteen\",\n+            \"14\",\n+            \"15\",\n+            new Byte((byte)16)\n+        };\n+    }\n+    \n+    public void testListIteratorAdd() {\n+        // override to cope with Set behaviour\n+        resetEmpty();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Object[] elements = getOtherElements();  // changed here\n+        ListIterator iter1 = list1.listIterator();\n+        ListIterator iter2 = list2.listIterator();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            super.verify();  // changed here\n+        }\n+\n+        resetFull();\n+        iter1 = getList().listIterator();\n+        iter2 = getConfirmedList().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            super.verify();  // changed here\n+        }\n+    }\n+    \n+    public void testCollectionAddAll() {\n+        // override for set behaviour\n+        resetEmpty();\n+        Object[] elements = getFullElements();\n+        boolean r = collection.addAll(Arrays.asList(elements));\n+        confirmed.addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Collection should contain added element\",\n+                       collection.contains(elements[i]));\n+        }\n+\n+        resetFull();\n+        int size = collection.size();\n+        elements = getOtherElements();\n+        r = collection.addAll(Arrays.asList(elements));\n+        confirmed.addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain added element \" + i,\n+                       collection.contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\", \n+                     size + elements.length, collection.size());\n+    }\n+    \n+    public void testListSetByIndex() {\n+        // override for set behaviour\n+        resetFull();\n+        int size = collection.size();\n+        getList().set(0, new Long(1000));\n+        assertEquals(size, collection.size());\n+\n+        getList().set(2, new Long(1000));\n+        assertEquals(size - 1, collection.size());\n+        assertEquals(new Long(1000), getList().get(1));  // set into 2, but shifted down to 1\n+    }\n+    \n+    boolean extraVerify = true;\n+    public void testCollectionIteratorRemove() {\n+        try {\n+            extraVerify = false;\n+            super.testCollectionIteratorRemove();\n+        } finally {\n+            extraVerify = true;\n+        }\n+    }\n+    \n+    protected void verify() {\n+        super.verify();\n+        \n+        if (extraVerify) {\n+            int size = collection.size();\n+            getList().add(new Long(1000));\n+            assertEquals(size + 1, collection.size());\n+\n+            getList().add(new Long(1000));\n+            assertEquals(size + 1, collection.size());\n+            assertEquals(new Long(1000), getList().get(size));\n+        \n+            getList().remove(size);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testFactory() {\n+        Integer[] array = new Integer[] {new Integer(1), new Integer(2), new Integer(1)};\n+        ArrayList list = new ArrayList(Arrays.asList(array));\n+        final SetList lset = SetList.decorate(list);\n+\n+        assertEquals(\"Duplicate element was added.\", 2, lset.size());\n+        assertEquals(new Integer(1), lset.get(0));\n+        assertEquals(new Integer(2), lset.get(1));\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(2), list.get(1));\n     }\n \n     public void testAdd() {\n-        final SetList lset = new SetList(new ArrayList());\n+        final SetList lset = new SetList(new ArrayList(), new HashSet());\n \n         // Duplicate element\n         final Object obj = new Integer(1);\n     }\n \n     public void testAddAll() {\n-        final SetList lset = new SetList(new ArrayList());\n+        final SetList lset = new SetList(new ArrayList(), new HashSet());\n \n         lset.addAll(\n             Arrays.asList(new Integer[] { new Integer(1), new Integer(1)}));\n     }\n \n     public void testSet() {\n-        final SetList lset = new SetList(new ArrayList());\n+        final SetList lset = new SetList(new ArrayList(), new HashSet());\n \n         // Duplicate element\n         final Object obj1 = new Integer(1);\n     }\n \n     public void testListIterator() {\n-        final SetList lset = new SetList(new ArrayList());\n+        final SetList lset = new SetList(new ArrayList(), new HashSet());\n \n         final Object obj1 = new Integer(1);\n         final Object obj2 = new Integer(2);", "timestamp": 1065228635, "metainfo": ""}