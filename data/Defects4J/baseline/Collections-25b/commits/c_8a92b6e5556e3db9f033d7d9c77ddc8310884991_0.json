{"sha": "8a92b6e5556e3db9f033d7d9c77ddc8310884991", "log": "Add ObservedCollection implementation with tests and event classes   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/decorators/ObservedCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedCollection.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.event.ModificationHandler;\n+import org.apache.commons.collections.event.ModificationListener;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+import org.apache.commons.collections.event.StandardModificationListener;\n+\n+/**\n+ * <code>ObservedCollection</code> decorates a <code>Collection</code>\n+ * implementation to observe changes in the collection.\n+ * <p>\n+ * Each modifying method call made on this <code>Collection</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ * <p>\n+ * For convenience, add, remove and get listener methods are made available on\n+ * this class. They accept a generic listener type, whereas handlers generally\n+ * require a specific type. Thus a ClassCastException may be thrown from these\n+ * methods. They may also throw UnsupportedOperationException if the handler\n+ * uses a technique other than listeners to communicate events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedCollection extends AbstractCollectionDecorator {\n+    \n+    /** The handler to delegate event handling to */\n+    protected final ModificationHandler handler;\n+\n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable collection.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public static ObservedCollection decorate(final Collection coll) {\n+        return new ObservedCollection(coll, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection and register one\n+     * listener to receive all events.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @param listener  collection listener, must not be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection or listener is null\n+     */\n+    public static ObservedCollection decorate(\n+            final Collection coll,\n+            final StandardModificationListener listener) {\n+        \n+        return decorate(coll, listener, -1, -1);\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection and register one\n+     * listener to receive all post events.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @param listener  collection listener, must not be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection or listener is null\n+     */\n+    public static ObservedCollection decoratePostEventsOnly(\n+            final Collection coll,\n+            final StandardModificationListener listener) {\n+        \n+        return decorate(coll, listener, 0, -1);\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection and\n+     * register one listener using event masks.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     * The masks are defined in \n+     * {@link org.apache.commons.collections.event.ModificationEventType ModificationEventType}.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @param listener  collection listener, must not be null\n+     * @param preEventMask  mask for pre events (0 for none, -1 for all)\n+     * @param postEventMask  mask for post events (0 for none, -1 for all)\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection or listener is null\n+     */\n+    public static ObservedCollection decorate(\n+            final Collection coll,\n+            final StandardModificationListener listener,\n+            final int preEventMask,\n+            final int postEventMask) {\n+            \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedCollection oc = new ObservedCollection(coll, handler);\n+        handler.addModificationListener(listener, preEventMask, postEventMask);\n+        return oc;\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection using a\n+     * specific handler.\n+     * <p>\n+     * The handler may be configured independently with listeners or other\n+     * event recognition.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @param handler  observed handler, must not be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection or handler is null\n+     */\n+    public static ObservedCollection decorate(\n+            final Collection coll,\n+            final ModificationHandler handler) {\n+                \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        if (handler == null) {\n+            throw new IllegalArgumentException(\"Handler must not be null\");\n+        }\n+        return new ObservedCollection(coll, handler);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * If a <code>null</code> handler is specified, an \n+     * <code>ObservedHandler</code> is created. \n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param handler  the observing handler, may be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected ObservedCollection(\n+            final Collection coll,\n+            final ModificationHandler handler) {\n+        super(coll);\n+        this.handler = (handler == null ? new StandardModificationHandler() : handler);\n+        this.handler.init(this);\n+    }\n+\n+    // Handler access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the handler that is observing this collection.\n+     * \n+     * @return the observing handler, never null\n+     */\n+    public ModificationHandler getHandler() {\n+        return handler;\n+    }\n+    \n+    // Listener convenience methods\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the listeners active in the handler.\n+     * This method simply delegates to the handler.\n+     * \n+     * @return the listeners\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public ModificationListener[] getModificationListeners() {\n+        return getHandler().getModificationListeners();\n+    }\n+    \n+    /**\n+     * Adds a listener to the list held in the handler.\n+     * This method simply delegates to the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not of the correct type\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void addModificationListener(ModificationListener listener) {\n+        getHandler().addModificationListener(listener);\n+    }\n+    \n+    /**\n+     * Removes a listener to the list held in the handler. \n+     * This method simply delegates to the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void removeModificationListener(ModificationListener listener) {\n+        getHandler().removeModificationListener(listener);\n+    }\n+    \n+    // Collection\n+    //-----------------------------------------------------------------------\n+    public boolean add(Object object) {\n+        boolean result = false;\n+        if (handler.preAdd(object)) {\n+            result = collection.add(object);\n+            handler.postAdd(object, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean addAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preAddAll(coll)) {\n+            result = collection.addAll(coll);\n+            handler.postAddAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public void clear() {\n+        if (handler.preClear()) {\n+            collection.clear();\n+            handler.postClear();\n+        }\n+    }\n+\n+    public Iterator iterator() {\n+        return new ObservedIterator(collection.iterator());\n+    }\n+\n+    public boolean remove(Object object) {\n+        boolean result = false;\n+        if (handler.preRemove(object)) {\n+            result = collection.remove(object);\n+            handler.postRemove(object, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean removeAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preRemoveAll(coll)) {\n+            result = collection.removeAll(coll);\n+            handler.postRemoveAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean retainAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preRetainAll(coll)) {\n+            result = collection.retainAll(coll);\n+            handler.postRetainAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    // Iterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Iterator for the ObservedCollection.\n+     */\n+    protected class ObservedIterator extends AbstractIteratorDecorator {\n+        \n+        protected Object last;\n+        \n+        protected ObservedIterator(Iterator iterator) {\n+            super(iterator);\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (handler.preRemove(last)) {\n+                iterator.remove();\n+                handler.postRemove(last, true);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/decorators/ObservedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedList.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.event.ModificationHandler;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+import org.apache.commons.collections.event.StandardModificationListener;\n+\n+/**\n+ * <code>ObservedList</code> decorates a <code>List</code>\n+ * implementation to observe changes.\n+ * <p>\n+ * Each modifying method call made on this <code>List</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ * <p>\n+ * For convenience, add, remove and get listener methods are made available on\n+ * this class. They accept a generic listener type, whereas handlers generally\n+ * require a specific type. Thus a ClassCastException may be thrown from these\n+ * methods. They may also throw UnsupportedOperationException if the handler\n+ * uses a technique other than listeners to communicate events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedList extends ObservedCollection implements List {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable list.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @return the observed List\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    public static ObservedList decorate(final List list) {\n+        return new ObservedList(list, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable list and register one\n+     * listener to receive all events.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @param listener  the listener, must not be null\n+     * @return the observed list\n+     * @throws IllegalArgumentException if the list or listener is null\n+     */\n+    public static ObservedList decorate(\n+            final List list,\n+            final StandardModificationListener listener) {\n+        \n+        return decorate(list, listener, -1, -1);\n+    }\n+\n+    /**\n+     * Factory method to create an observable list and register one\n+     * listener to receive all post events.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @param listener  the listener, must not be null\n+     * @return the observed list\n+     * @throws IllegalArgumentException if the list or listener is null\n+     */\n+    public static ObservedList decoratePostEventsOnly(\n+            final List list,\n+            final StandardModificationListener listener) {\n+        \n+        return decorate(list, listener, 0, -1);\n+    }\n+\n+    /**\n+     * Factory method to create an observable list and\n+     * register one listener using event masks.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     * The masks are defined in \n+     * {@link org.apache.commons.collections.event.ModificationEventType ModificationEventType}.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @param listener  the listener, must not be null\n+     * @param preEventMask  mask for pre events (0 for none, -1 for all)\n+     * @param postEventMask  mask for post events (0 for none, -1 for all)\n+     * @return the observed list\n+     * @throws IllegalArgumentException if the list or listener is null\n+     */\n+    public static ObservedList decorate(\n+            final List list,\n+            final StandardModificationListener listener,\n+            final int preEventMask,\n+            final int postEventMask) {\n+            \n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedList oc = new ObservedList(list, handler);\n+        handler.addModificationListener(listener, preEventMask, postEventMask);\n+        return oc;\n+    }\n+\n+    /**\n+     * Factory method to create an observable list using a\n+     * specific handler.\n+     * <p>\n+     * The handler may be configured independently with listeners or other\n+     * event recognition.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @param handler  observed handler, must not be null\n+     * @return the observed list\n+     * @throws IllegalArgumentException if the list or handler is null\n+     */\n+    public static ObservedList decorate(\n+            final List list,\n+            final ModificationHandler handler) {\n+                \n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (handler == null) {\n+            throw new IllegalArgumentException(\"Handler must not be null\");\n+        }\n+        return new ObservedList(list, handler);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * If a <code>null</code> handler is specified, an \n+     * <code>ObservedHandler</code> is created. \n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param handler  the observing handler, may be null\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    protected ObservedList(\n+            final List list,\n+            final ModificationHandler handler) {\n+        super(list, handler);\n+    }\n+    \n+    /**\n+     * Typecast the collection to a List.\n+     * \n+     * @return the wrapped collection as a List\n+     */\n+    private List getList() {\n+        return (List) getCollection();\n+    }\n+\n+    // List API\n+    //-----------------------------------------------------------------------\n+    public Object get(int index) {\n+        return getList().get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return getList().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        return getList().lastIndexOf(object);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, Object object) {\n+        if (handler.preAdd(index, object)) {\n+            getList().add(index, object);\n+            handler.postAdd(index, object);\n+        }\n+    }\n+\n+    public boolean addAll(int index, Collection coll) {\n+        boolean result = false;\n+        if (handler.preAddAll(index, coll)) {\n+            result = getList().addAll(index, coll);\n+            handler.postAddAll(index, coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public Object remove(int index) {\n+        Object result = null;\n+        if (handler.preRemove(index)) {\n+            result = getList().remove(index);\n+            handler.postRemove(index, result);\n+        }\n+        return result;\n+    }\n+\n+    public Object set(int index, Object object) {\n+        Object result = null;\n+        if (handler.preSet(index, object)) {\n+            result = getList().set(index, object);\n+            handler.postSet(index, object, result);\n+        }\n+        return result;\n+    }\n+\n+    public ListIterator listIterator() {\n+        return new ObservedListIterator(getList().listIterator());\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        return new ObservedListIterator(getList().listIterator(index));\n+    }\n+\n+    public List subList(int fromIndex, int toIndex) {\n+        // TODO: This list needs to be a special impl, as the index is offset\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class ListIterator for the ObservedList.\n+     */\n+    protected class ObservedListIterator extends AbstractListIteratorDecorator {\n+        \n+        protected Object last;\n+        \n+        protected ObservedListIterator(ListIterator iterator) {\n+            super(iterator);\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public Object previous() {\n+            last = iterator.previous();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            int index = iterator.previousIndex();\n+            if (handler.preRemove(index)) {\n+                iterator.remove();\n+                handler.postRemove(index, last);\n+            }\n+        }\n+        \n+        public void add(Object object) {\n+            int index = iterator.nextIndex();\n+            if (handler.preAdd(index, object)) {\n+                iterator.add(object);\n+                handler.postAdd(index, object);\n+            }\n+        }\n+\n+        public void set(Object object) {\n+            int index = iterator.previousIndex();\n+            if (handler.preSet(index, object)) {\n+                iterator.set(object);\n+                handler.postSet(index, object, last);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/decorators/ObservedSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedSet.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.event.ModificationHandler;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+import org.apache.commons.collections.event.StandardModificationListener;\n+\n+/**\n+ * <code>ObservedSet</code> decorates a <code>Set</code>\n+ * implementation to observe changes.\n+ * <p>\n+ * Each modifying method call made on this <code>Set</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ * <p>\n+ * For convenience, add, remove and get listener methods are made available on\n+ * this class. They accept a generic listener type, whereas handlers generally\n+ * require a specific type. Thus a ClassCastException may be thrown from these\n+ * methods. They may also throw UnsupportedOperationException if the handler\n+ * uses a technique other than listeners to communicate events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedSet extends ObservedCollection implements Set {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable set.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @return the observed Set\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public static ObservedSet decorate(final Set set) {\n+        return new ObservedSet(set, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set and register one\n+     * listener to receive all events.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param listener  the listener, must not be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set or listener is null\n+     */\n+    public static ObservedSet decorate(\n+            final Set set,\n+            final StandardModificationListener listener) {\n+        \n+        return decorate(set, listener, -1, -1);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set and register one\n+     * listener to receive all post events.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param listener  the listener, must not be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set or listener is null\n+     */\n+    public static ObservedSet decoratePostEventsOnly(\n+            final Set set,\n+            final StandardModificationListener listener) {\n+        \n+        return decorate(set, listener, 0, -1);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set and\n+     * register one listener using event masks.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     * The masks are defined in \n+     * {@link org.apache.commons.collections.event.ModificationEventType ModificationEventType}.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param listener  the listener, must not be null\n+     * @param preEventMask  mask for pre events (0 for none, -1 for all)\n+     * @param postEventMask  mask for post events (0 for none, -1 for all)\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set or listener is null\n+     */\n+    public static ObservedSet decorate(\n+            final Set set,\n+            final StandardModificationListener listener,\n+            final int preEventMask,\n+            final int postEventMask) {\n+            \n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedSet oc = new ObservedSet(set, handler);\n+        handler.addModificationListener(listener, preEventMask, postEventMask);\n+        return oc;\n+    }\n+\n+    /**\n+     * Factory method to create an observable set using a\n+     * specific handler.\n+     * <p>\n+     * The handler may be configured independently with listeners or other\n+     * event recognition.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param handler  observed handler, must not be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set or handler is null\n+     */\n+    public static ObservedSet decorate(\n+            final Set set,\n+            final ModificationHandler handler) {\n+                \n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        if (handler == null) {\n+            throw new IllegalArgumentException(\"Handler must not be null\");\n+        }\n+        return new ObservedSet(set, handler);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * If a <code>null</code> handler is specified, an \n+     * <code>ObservedHandler</code> is created. \n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param handler  the observing handler, may be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected ObservedSet(\n+            final Set set,\n+            final ModificationHandler handler) {\n+        super(set, handler);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/ModificationEvent.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationEvent.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+import java.util.Collection;\n+import java.util.EventObject;\n+\n+/**\n+ * Base event class extended by each class that encapsulates event information.\n+ * <p>\n+ * This class can be used as is, but generally it is subclassed.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ModificationEvent extends EventObject {\n+\n+    /** The source collection */\n+    protected final Collection collection;\n+    /** The handler */\n+    protected final ModificationHandler handler;\n+    /** The event code */\n+    protected final int type;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param collection  the event source\n+     * @param handler  the handler\n+     * @param type  the event type\n+     */\n+    public ModificationEvent(\n+        final Collection collection,\n+        final ModificationHandler handler,\n+        final int type) {\n+\n+        super(collection);\n+        this.collection = collection;\n+        this.handler = handler;\n+        this.type = type;\n+    }\n+\n+    // Basic info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the collection the event is reporting on.\n+     * <p>\n+     * This method returns the <code>ObservedCollection</code> instance.\n+     * If this collection is wrapped, by a synchronized wrapper for example,\n+     * changing this collection will bypass the wrapper. For the synchronized\n+     * example, this will be OK so long as the event is processed in the same\n+     * thread and program stack as the modification was made in.\n+     * \n+     * @return the collection\n+     */\n+    public Collection getSourceCollection() {\n+        return collection;\n+    }\n+\n+    /**\n+     * Gets the handler of the events.\n+     * \n+     * @return the handler\n+     */\n+    public ModificationHandler getHandler() {\n+        return handler;\n+    }\n+\n+    /**\n+     * Gets the event type constant.\n+     * <p>\n+     * This is one of the <i>method</i> constants from {@link ModificationEventType}.\n+     * \n+     * @return the method event type constant\n+     */\n+    public int getType() {\n+        return type;\n+    }\n+\n+    // toString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of the event.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(64);\n+        buf.append(\"ObservedEvent[type=\");\n+        buf.append(ModificationEventType.toString(type));\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/ModificationEventType.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationEventType.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * Defines event constants for event handling and matching.\n+ * <p>\n+ * The constants in this class are of two types:\n+ * <ol>\n+ * <li>Methods - the base definitions (unique bits)\n+ * <li>Groups - combination definitions (method bits combined)\n+ * </ol>\n+ * <p>\n+ * Only a method constant may be compared using == to an event type.\n+ * This can include use in a switch statement\n+ * <p>\n+ * Any constant may be used for filtering.\n+ * They may combined using the bitwise OR, <code>|</code>.\n+ * They may negated using the bitwise NOT, <code>~</code>.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ModificationEventType {\n+    \n+    /** The method add(Object) */\n+    public static final int ADD =           0x00000001;\n+    /** The method add(int,Object) */\n+    public static final int ADD_INDEXED =   0x00000002;\n+    /** The method addAll(Collection) */\n+    public static final int ADD_ALL =       0x00000004;\n+    /** The method addAll(int,Collection) */\n+    public static final int ADD_ALL_INDEXED=0x00000008;\n+    /** The method remove(Object) */\n+    public static final int REMOVE =        0x00000010;\n+    /** The method remove(int) */\n+    public static final int REMOVE_INDEXED =0x00000020;\n+    /** The method removeAll(Collection) */\n+    public static final int REMOVE_ALL =    0x00000040;\n+    /** The method retainAll(Collection) */\n+    public static final int RETAIN_ALL =    0x00000080;\n+    /** The method clear() */\n+    public static final int CLEAR =         0x00000100;\n+    /** The method set(int,Object) */\n+    public static final int SET_INDEXED =   0x00000200;\n+\n+    /** All add methods */\n+    public static final int GROUP_ADD = ADD | ADD_INDEXED | ADD_ALL | ADD_ALL_INDEXED;\n+    /** All methods that change without structure modification */\n+    public static final int GROUP_CHANGE = SET_INDEXED;\n+    /** All remove methods */\n+    public static final int GROUP_REMOVE = REMOVE | REMOVE_INDEXED | REMOVE_ALL;\n+    /** All retain methods */\n+    public static final int GROUP_RETAIN = RETAIN_ALL;\n+    /** All clear methods */\n+    public static final int GROUP_CLEAR = CLEAR;\n+    /** All reducing methods (remove, retain and clear) */\n+    public static final int GROUP_REDUCE = GROUP_REMOVE | GROUP_CLEAR | GROUP_RETAIN;\n+    \n+    /** All indexed methods */\n+    public static final int GROUP_INDEXED = ADD_INDEXED | ADD_ALL_INDEXED | REMOVE_INDEXED | SET_INDEXED;\n+    /** All non indexed methods */\n+    public static final int GROUP_NON_INDEXED = ADD | ADD_ALL | REMOVE | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All bulk methods (xxxAll and clear) */\n+    public static final int GROUP_BULK = ADD_ALL | ADD_ALL_INDEXED | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All non bulk methods */\n+    public static final int GROUP_NON_BULK = ADD | ADD_INDEXED | REMOVE | REMOVE_INDEXED | SET_INDEXED;\n+    /** All methods that modify the structure */\n+    public static final int GROUP_STRUCTURE_MODIFIED = \n+        ADD | ADD_INDEXED | ADD_ALL | ADD_ALL_INDEXED | REMOVE | REMOVE_INDEXED | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All non structure modifying methods */\n+    public static final int GROUP_NON_STRUCTURE_MODIFIED = SET_INDEXED;\n+\n+    /** All methods sent by a Collection */\n+    public static final int GROUP_FROM_COLLECTION = ADD | ADD_ALL | REMOVE | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All methods sent by a Set */\n+    public static final int GROUP_FROM_SET = GROUP_FROM_COLLECTION;\n+    /** All methods sent by a List */\n+    public static final int GROUP_FROM_LIST = GROUP_FROM_COLLECTION | ADD_INDEXED | ADD_ALL_INDEXED | REMOVE_INDEXED | SET_INDEXED;\n+\n+    /** No methods */\n+    public static final int GROUP_NONE = 0x00000000;\n+    /** All methods */\n+    public static final int GROUP_ALL = 0xFFFFFFFF;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected ModificationEventType() {\n+        super();\n+    }\n+    \n+    /**\n+     * Gets a string version of a method event type.\n+     * \n+     * @param methodType  the method event type constant\n+     * @return a string description\n+     */\n+    public static String toString(final int methodType) {\n+        switch (methodType) {\n+            case ADD:\n+            return \"Add\";\n+            case ADD_INDEXED:\n+            return \"AddIndexed\";\n+            case ADD_ALL:\n+            return \"AddAll\";\n+            case ADD_ALL_INDEXED:\n+            return \"AddAllIndexed\";\n+            case REMOVE:\n+            return \"Remove\";\n+            case REMOVE_INDEXED:\n+            return \"RemoveIndexed\";\n+            case REMOVE_ALL:\n+            return \"RemoveAll\";\n+            case RETAIN_ALL:\n+            return \"RetainAll\";\n+            case CLEAR:\n+            return \"Clear\";\n+            case SET_INDEXED:\n+            return \"SetIndexed\";\n+            default:\n+            return \"Unknown\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/ModificationHandler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationHandler.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.decorators.ObservedCollection;\n+\n+/**\n+ * Abstract base implementation of a handler for collection modification.\n+ * <p>\n+ * All data storage and event sending is performed by a subclass.\n+ * This class provides a default implementation for the event handling methods\n+ * that forwards to single points.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public abstract class ModificationHandler {\n+    \n+    /** The collection being observed */\n+    private ObservedCollection collection = null;\n+    \n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected ModificationHandler() {\n+        super();\n+    }\n+\n+    /**\n+     * Initialize the handler.\n+     * <p>\n+     * The handler cannot be used until this method is called.\n+     * However, the handler's setup methods can be called.\n+     * All other methods will throw NullPointerException until then.\n+     * \n+     * @param coll  the observed collection, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     * @throws IllegalStateException if init has already been called\n+     */\n+    public void init(final ObservedCollection coll) {\n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        if (this.collection != null) {\n+            throw new IllegalArgumentException(\"init() has already been called\");\n+        }\n+        this.collection = coll;\n+    }\n+\n+    // Collection access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the observed collection.\n+     * \n+     * @return the observed collection\n+     */\n+    public Collection getCollection() {\n+        return collection;\n+    }\n+    \n+    // Listeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the listeners active in the handler.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @return the listeners\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public ModificationListener[] getModificationListeners() {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Adds a listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not of the correct type\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void addModificationListener(ModificationListener listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Removes a listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void removeModificationListener(ModificationListener listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    // Event sending\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles the pre event.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     */\n+    protected abstract boolean preEvent(int type, int index, Object object, int repeat);\n+\n+    /**\n+     * Handles the post event.\n+     * \n+     * @param success  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     */\n+    protected abstract void postEvent(boolean success, int type, int index, Object object, int repeat);\n+\n+    /**\n+     * Handles the post event.\n+     * \n+     * @param success  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @param result  the result of the method\n+     */\n+    protected abstract void postEvent(boolean success, int type, int index, Object object, int repeat, Object result);\n+\n+    // Event handling\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before add(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param object  the object being added\n+     * @return true\n+     */\n+    public boolean preAdd(Object object) {\n+        return preEvent(ModificationEventType.ADD, -1, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after add(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param object  the object being added\n+     * @param result  the result from the add method\n+     */\n+    public void postAdd(Object object, boolean result) {\n+        postEvent(result, ModificationEventType.ADD, -1, object, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before add(int,obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     * @return true\n+     */\n+    public boolean preAdd(int index, Object object) {\n+        return preEvent(ModificationEventType.ADD_INDEXED, index, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after add(int,obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     */\n+    public void postAdd(int index, Object object) {\n+        postEvent(true, ModificationEventType.ADD_INDEXED, index, object, 1, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before addAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being added\n+     * @return true\n+     */\n+    public boolean preAddAll(Collection coll) {\n+        return preEvent(ModificationEventType.ADD_ALL, -1, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after addAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being added\n+     * @param result  the result from the addAll method\n+     */\n+    public void postAddAll(Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.ADD_ALL, -1, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before addAll(int,coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to addAll at\n+     * @param coll  the collection being added\n+     * @return true\n+     */\n+    public boolean preAddAll(int index, Collection coll) {\n+        return preEvent(ModificationEventType.ADD_ALL_INDEXED, index, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after addAll(int,coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param index  the index to addAll at\n+     * @param coll  the collection being added\n+     * @param result  the result from the addAll method\n+     */\n+    public void postAddAll(int index, Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.ADD_ALL_INDEXED, index, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before clear() is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @return true\n+     */\n+    public boolean preClear() {\n+        return preEvent(ModificationEventType.CLEAR, -1, null, 1);\n+    }\n+\n+    /**\n+     * Send an event after clear() is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     */\n+    public void postClear() {\n+        // assumes a modification occurred\n+        postEvent(true, ModificationEventType.CLEAR, -1, null, 1, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before remove(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param object  the object being removed\n+     * @return true\n+     */\n+    public boolean preRemove(Object object) {\n+        return preEvent(ModificationEventType.REMOVE, -1, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after remove(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param object  the object being removed\n+     * @param result  the result from the remove method\n+     */\n+    public void postRemove(Object object, boolean result) {\n+        postEvent(result, ModificationEventType.REMOVE, -1, object, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before remove(int) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to remove at\n+     * @return true\n+     */\n+    public boolean preRemove(int index) {\n+        return preEvent(ModificationEventType.REMOVE_INDEXED, index, null, 1);\n+    }\n+\n+    /**\n+     * Send an event after remove(int) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param index  the index to remove at\n+     * @param result  the result from the remove method\n+     */\n+    public void postRemove(int index, Object result) {\n+        postEvent(true, ModificationEventType.REMOVE_INDEXED, index, null, 1, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before removeAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being removed\n+     * @return true\n+     */\n+    public boolean preRemoveAll(Collection coll) {\n+        return preEvent(ModificationEventType.REMOVE_ALL, -1, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after removeAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being removed\n+     * @param result  the result from the removeAll method\n+     */\n+    public void postRemoveAll(Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.REMOVE_ALL, -1, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before retainAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being retained\n+     * @return true\n+     */\n+    public boolean preRetainAll(Collection coll) {\n+        return preEvent(ModificationEventType.RETAIN_ALL, -1, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after retainAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being retained\n+     * @param result  the result from the retainAll method\n+     */\n+    public void postRetainAll(Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.RETAIN_ALL, -1, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before set(int,obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     * @return true\n+     */\n+    public boolean preSet(int index, Object object) {\n+        return preEvent(ModificationEventType.SET_INDEXED, index, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after set(int,obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     * @param result  the result from the set method\n+     */\n+    public void postSet(int index, Object object, Object result) {\n+        postEvent(true, ModificationEventType.SET_INDEXED, index, object, 1, result);\n+    }\n+\n+    // toString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of this object.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        String name = getClass().getName();\n+        int pos = name.lastIndexOf('.');\n+        if (pos != -1) {\n+            name = name.substring(pos + 1);\n+        }\n+        return name + '[' + (collection == null ? \"\" : \"initialised\") + ']';\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/ModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationListener.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * An empty listener designed to be subclassed.\n+ * <p>\n+ * This interface exists to mark independent subclasses as fulfilling the\n+ * role of an event listener for collection modification events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface ModificationListener extends EventListener {\n+\n+    // no methods - subinterfaces define them\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/ModificationVetoedException.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationVetoedException.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * Exception thrown when a modifcation to a collection is vetoed.\n+ * It extends IllegalArgumentException for compatability with the collections API.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ModificationVetoedException extends IllegalArgumentException {\n+\n+    /** The source event */\n+    protected final ModificationEvent event;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param message  the text message, may be null\n+     * @param event  the observed event, should not be null\n+     */\n+    public ModificationVetoedException(final String message, final ModificationEvent event) {\n+        super((message == null ? \"Modification vetoed\" : message));\n+        this.event = event;\n+    }\n+\n+    // Event access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the event that caused the veto.\n+     * \n+     * @return the event\n+     */\n+    public ModificationEvent getEvent() {\n+        return event;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/StandardModificationAdaptor.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationAdaptor.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * An adaptor for <code>StandardModificationListener</code> that provides no-op\n+ * implementations of both methods.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class StandardModificationAdaptor implements StandardModificationListener {\n+\n+    /**\n+     * A collection modification is occurring and may be vetoed.\n+     * <p>\n+     * This implementation does nothing.\n+     * \n+     * @param event  the event detail\n+     * @throws ModicationVetoedException to veto\n+     */\n+    public void modificationOccurring(StandardModificationEvent event) {\n+        // do nothing\n+    }\n+    \n+    /**\n+     * A collection modification occurred.\n+     * <p>\n+     * This implementation does nothing.\n+     * \n+     * @param event  the event detail\n+     */\n+    public void modificationOccurred(StandardModificationEvent event) {\n+        // do nothing\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/StandardModificationEvent.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationEvent.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+\n+/**\n+ * Event class that encapsulates all the event information for a\n+ * standard collection event.\n+ * <p>\n+ * The information stored in this event is all that is available as\n+ * parameters or return values.\n+ * In addition, the <code>size</code> method is used on the collection.\n+ * All objects used are the real objects from the method calls, not clones.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class StandardModificationEvent extends ModificationEvent {\n+\n+    /** The size before the event */\n+    protected final int preSize;\n+    /** The size after the event */\n+    protected final int postSize;\n+    /** The index of the change */\n+    protected final int index;\n+    /** The object of the change */\n+    protected final Object object;\n+    /** The number of changes */\n+    protected final int repeat;\n+    /** The result of the method call */\n+    protected final Object result;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param collection  the event source\n+     * @param handler  the handler\n+     * @param type  the event type\n+     * @param preSize  the size before the change\n+     * @param index  the index that changed\n+     * @param object  the value that changed\n+     * @param repeat  the number of repeats\n+     * @param result  the method result\n+     */\n+    public StandardModificationEvent(\n+        final Collection collection,\n+        final ModificationHandler handler,\n+        final int type,\n+        final int preSize,\n+        final int index,\n+        final Object object,\n+        final int repeat,\n+        final Object result) {\n+\n+        super(collection, handler, type);\n+        this.preSize = preSize;\n+        this.postSize = collection.size();\n+        this.index = index;\n+        this.object = object;\n+        this.repeat = repeat;\n+        this.result = result;\n+    }\n+\n+    // Change info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the index of the change.\n+     * <p>\n+     * This is <code>-1</code> when not applicable. Typically only used\n+     * for {@link java.util.List} events.\n+     * \n+     * @return the change index\n+     */\n+    public int getChangeIndex() {\n+        return index;\n+    }\n+\n+    /**\n+     * Gets the object that was added/removed/set.\n+     * <p>\n+     * This is <code>null</code> when not applicable, such as for clear().\n+     * \n+     * @return the changing object\n+     */\n+    public Object getChangeObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * Gets the collection of changed objects.\n+     * <p>\n+     * For clear, it is an empty list.\n+     * For bulk operations, it is the collection.\n+     * For non-bulk operations, it is a size one list.\n+     * \n+     * @return the changing collection, never null\n+     */\n+    public Collection getChangeCollection() {\n+        if (object == null) {\n+            return Collections.EMPTY_LIST;\n+        } else if (isType(ModificationEventType.GROUP_BULK)) {\n+            if (object instanceof Collection) {\n+                return (Collection) object;\n+            } else {\n+                throw new IllegalStateException(\n+                    \"Bulk operations must involve a Collection, but was \" + object.getClass().getName());\n+            }\n+        } else {\n+            return Collections.singletonList(object);\n+        }\n+    }\n+\n+    /**\n+     * Gets the number of times the object was added/removed.\n+     * <p>\n+     * This is normally <code>1</code>, but will be used for \n+     * {@link org.apache.commons.collections.Bag Bag} events.\n+     * \n+     * @return the repeat\n+     */\n+    public int getChangeRepeat() {\n+        return repeat;\n+    }\n+\n+    /**\n+     * Gets the result of the method call.\n+     * <p>\n+     * For set(int) and remove(int) this will be the previous value\n+     * being replaced.\n+     * <p>\n+     * If there is no result yet, <code>null</code> will be returned.\n+     * If the result was a <code>boolean</code>, a <code>Boolean</code> is returned.\n+     * If the result was void, <code>null</code> will be returned.\n+     * \n+     * @return the repeat\n+     */\n+    public Object getResult() {\n+        return result;\n+    }\n+\n+    // Size info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size before the change.\n+     * \n+     * @return the size before the change\n+     */\n+    public int getPreSize() {\n+        return preSize;\n+    }\n+\n+    /**\n+     * Gets the size after the change.\n+     * <p>\n+     * This method will return the same as <code>getPreSzie</code> if\n+     * called when handling a pre event.\n+     * \n+     * @return the size before the change\n+     */\n+    public int getPostSize() {\n+        return postSize;\n+    }\n+\n+    /**\n+     * Gets the size change, negative for remove/clear.\n+     * <p>\n+     * This method will return <code>zero</code> if called when handling a pre event.\n+     * \n+     * @return the size before the change\n+     */\n+    public int getSizeChange() {\n+        return postSize - preSize;\n+    }\n+\n+    /**\n+     * Returns true if the size of the collection changed.\n+     * <p>\n+     * This method will return <code>false</code> if called when handling a pre event.\n+     * \n+     * @return true is the size changed\n+     */\n+    public boolean isSizeChanged() {\n+        return (preSize != postSize);\n+    }\n+\n+    // Event type\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks to see if the event is of the specified type.\n+     * <p>\n+     * This is any combination of constants from {@link ObservedEventType}.\n+     * \n+     * @param eventType  an event type constant\n+     * @return true if of the specified type\n+     */\n+    public boolean isType(final int eventType) {\n+        return (type & eventType) > 0;\n+    }\n+\n+    // toString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of the event.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(64);\n+        buf.append(\"ObservedEvent[type=\");\n+        buf.append(ModificationEventType.toString(type));\n+        if (index >= 0) {\n+            buf.append(\",index=\");\n+            buf.append(index);\n+        }\n+        if (type != ModificationEventType.CLEAR) {\n+            buf.append(\",object=\");\n+            if (object instanceof List) {\n+                buf.append(\"List:size:\");\n+                buf.append(((List) object).size());\n+            } else if (object instanceof Set) {\n+                buf.append(\"Set:size:\");\n+                buf.append(((Set) object).size());\n+            } else if (object instanceof Bag) {\n+                buf.append(\"Bag:size:\");\n+                buf.append(((Bag) object).size());\n+            } else if (object instanceof Collection) {\n+                buf.append(\"Collection:size:\");\n+                buf.append(((Collection) object).size());\n+            } else if (object instanceof Map) {\n+                buf.append(\"Map:size:\");\n+                buf.append(((Map) object).size());\n+            } else if (object instanceof Object[]) {\n+                buf.append(\"Array:size:\");\n+                buf.append(((Object[]) object).length);\n+            } else if (object == null) {\n+                buf.append(\"null\");\n+            } else {\n+                buf.append(object.toString());\n+            }\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/StandardModificationHandler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationHandler.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * The standard implementation of a <code>ModificationHandler</code> that\n+ * sends standard JavaBean style events to listeners.\n+ * <p>\n+ * The information gathered by this implementation is all that is available\n+ * as parameters or return values.\n+ * In addition, the <code>size</code> method is used on the collection.\n+ * All objects used are the real objects from the method calls, not clones.\n+ * <p>\n+ * Each listener can be filtered. There are separate filters for pre events\n+ * (modificationOccurring) and post events (modificationOccurred).\n+ * <p>\n+ * This implementation is the standard one. Most listeners will probably be\n+ * content with the events generated from here. However, if you need something\n+ * extra then this class can be subclassed or replaced as required. For example:\n+ * <ul>\n+ * <li>to store the state of the collection before the change\n+ * <li>to change the event classes\n+ * <li>to change the event dispatch mechanism to something other than listeners\n+ * <li>to clone the objects before placing them in the event\n+ * </ul>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class StandardModificationHandler extends ModificationHandler {\n+\n+    /** A reusable empty holders array. */    \n+    protected static final Holder[] EMPTY_HOLDERS = new Holder[0];\n+    \n+    /** The event mask as to which event types to send on pre events. */\n+    protected int preMask = ModificationEventType.GROUP_NONE;\n+    /** The event mask as to which event types to send on post events. */\n+    protected int postMask = ModificationEventType.GROUP_NONE;\n+    /** The event listeners. */\n+    protected Holder[] holders = EMPTY_HOLDERS;\n+    /**\n+     * Temporary store for the size.\n+     * This makes the class thread-unsafe, but you should sync collections anyway.\n+     */\n+    protected int preSize;\n+    \n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor the creates the handler but leaves it invalid.\n+     * <p>\n+     * The handler can only be used after {@link #init(ObservedCollection)} is\n+     * called. This is normally done automatically by\n+     * {@link ObservedCollection#decorate(Collection, ModificationHandler)}.\n+     */\n+    public StandardModificationHandler() {\n+        super();\n+    }\n+\n+    // Listeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the listeners active in the handler.\n+     * <p>\n+     * All listeners will be instances of StandardModificationListener.\n+     * \n+     * @return the listeners\n+     */\n+    public synchronized ModificationListener[] getModificationListeners() {\n+        ModificationListener[] lnrs = new ModificationListener[holders.length];\n+        for (int i = 0; i < holders.length; i++) {\n+            lnrs[i] = holders[i].listener;\n+        }\n+        return lnrs;\n+    }\n+    \n+    /**\n+     * Adds a listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not a StandardModificationListener\n+     */\n+    public void addModificationListener(ModificationListener listener) {\n+        addModificationListener(listener, -1, -1);\n+    }\n+    \n+    /**\n+     * Adds a listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @param preMask  the mask for pre events (0 for none, -1 for all)\n+     * @param postMask  the mask for post events (0 for none, -1 for all)\n+     * @throws ClassCastException if the listener is not a StandardModificationListener\n+     */\n+    public synchronized void addModificationListener(ModificationListener listener, int preMask, int postMask) {\n+        if (listener != null) {\n+            int oldSize = holders.length;\n+            Holder[] array = new Holder[oldSize + 1];\n+            System.arraycopy(holders, 0, array, 0, oldSize);\n+            array[oldSize] = new Holder((StandardModificationListener) listener, preMask, postMask);\n+            holders = array;\n+            calculateMasks();\n+        }\n+    }\n+    \n+    /**\n+     * Removes a listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     */\n+    public synchronized void removeModificationListener(ModificationListener listener) {\n+        if (listener != null) {\n+            switch (holders.length) {\n+                case 0:\n+                return;\n+                \n+                case 1:\n+                if (holders[0].listener == listener) {\n+                    holders = EMPTY_HOLDERS;\n+                    calculateMasks();\n+                }\n+                return;\n+                \n+                default:\n+                Holder[] array = new Holder[holders.length - 1];\n+                boolean match = false;\n+                for (int i = 0; i < holders.length; i++) {\n+                    if (match) {\n+                        array[i - 1] = holders[i];\n+                    } else if (holders[i].listener == listener) {\n+                        match = true;\n+                    } else {\n+                        array[i] = holders[i];\n+                    }\n+                }\n+                holders = array;\n+                calculateMasks();\n+                return;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Sets the masks of a listener.\n+     * <p>\n+     * No error occurs if the listener is not in the list.\n+     * The listener is matched using ==.\n+     * \n+     * @return a non-null array of listeners\n+     */\n+    public synchronized void setModificationListenerMasks(StandardModificationListener listener, int preMask, int postMask) {\n+        if (listener != null) {\n+            for (int i = 0; i < holders.length; i++) {\n+                if (holders[i].listener == listener) {\n+                    holders[i].preMask = preMask;\n+                    holders[i].postMask = postMask;\n+                    calculateMasks();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    // Holder for listener and masks\n+    //-----------------------------------------------------------------------\n+    protected static class Holder {\n+        StandardModificationListener listener;\n+        int preMask;\n+        int postMask;\n+        \n+        Holder(StandardModificationListener listener, int preMask, int postMask) {\n+            this.listener = listener;\n+            this.preMask = preMask;\n+            this.postMask = postMask;\n+        }\n+        \n+        public String toString() {\n+            return \"[\" + listener + \",\"\n+                + ModificationEventType.toString(preMask) + \",\"\n+                + ModificationEventType.toString(postMask) + \"]\";\n+        }\n+\n+    }\n+    \n+    // Masks\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calculate the combined masks.\n+     */\n+    protected void calculateMasks() {\n+        preMask = ModificationEventType.GROUP_NONE;\n+        postMask = ModificationEventType.GROUP_NONE;\n+        for (int i = 0; i < holders.length; i++) {\n+            preMask |= holders[i].preMask;\n+            postMask |= holders[i].postMask;\n+        }\n+    }\n+\n+    // Pre event sending\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles the pre event.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @return true to call the decorated collection\n+     */\n+    protected boolean preEvent(int type, int index, Object object, int repeat) {\n+        preSize = getCollection().size();\n+        return firePreEvent(type, index, object, repeat);\n+    }\n+\n+    /**\n+     * Sends the pre event to the listeners.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @return true to call the decorated collection\n+     */\n+    protected boolean firePreEvent(int type, int index, Object object, int repeat) {\n+        if ((preMask & type) > 0) {\n+            StandardModificationEvent event = null;\n+            synchronized (this) {\n+                for (int i = 0; i < holders.length; i++) {\n+                    Holder holder = holders[i];\n+                    if ((holder.preMask & type) > 0) {\n+                        if (event == null) {\n+                            event = new StandardModificationEvent(\n+                                getCollection(), this, type, preSize, index, object, repeat, null);\n+                        }\n+                        holder.listener.modificationOccurring(event);\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Post event sending\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles the post event.\n+     * \n+     * @param success  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     */\n+    protected void postEvent(boolean success, int type, int index, Object object, int repeat) {\n+        if (success) {\n+            firePostEvent(type, index, object, repeat, (success ? Boolean.TRUE : Boolean.FALSE));\n+        }\n+    }\n+    \n+    /**\n+     * Handles the post event.\n+     * \n+     * @param success  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @param result  the method result\n+     */\n+    protected void postEvent(boolean success, int type, int index, Object object, int repeat, Object result) {\n+        if (success) {\n+            firePostEvent(type, index, object, repeat, result);\n+        }\n+    }\n+    \n+    /**\n+     * Sends the post event to the listeners.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @param result  the method result\n+     */\n+    protected void firePostEvent(int type, int index, Object object, int repeat, Object result) {\n+        if ((postMask & type) > 0) {\n+            StandardModificationEvent event = null;\n+            synchronized (this) {\n+                for (int i = 0; i < holders.length; i++) {\n+                    Holder holder = holders[i];\n+                    if ((holder.postMask & type) > 0) {\n+                        if (event == null) {\n+                            event = new StandardModificationEvent(\n+                                getCollection(), this, type, preSize, index, object, repeat, result);\n+                        }\n+                        holder.listener.modificationOccurred(event);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event handling\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Send an event after clear() is called.\n+     * <p>\n+     * Override to only send event if something actually cleared.\n+     */\n+    public void postClear() {\n+        postEvent(preSize > 0, ModificationEventType.CLEAR, -1, null, 1, null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/StandardModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationListener.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * A listener that receives events from the <code>StandardModificationHandler</code>.\n+ * <p>\n+ * This listener has two methods.\n+ * <ol>\n+ * <li><code>modificationOccurring</code> - called before the modification\n+ * occurs and can veto the change.\n+ * <li><code>modificationOccurred</code> - called after the change and is\n+ * for information.\n+ * </ol>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface StandardModificationListener extends ModificationListener {\n+\n+    /**\n+     * A collection modification is occurring.\n+     * <p>\n+     * To veto the change, throw <code>ModicationVetoedException</code>.\n+     * <p>\n+     * This method should be processed quickly, as with all event handling.\n+     * It should also avoid modifying the event source (the collection).\n+     * \n+     * @param event  the event detail\n+     * @throws ModicationVetoedException to veto\n+     */\n+    public void modificationOccurring(StandardModificationEvent event);\n+    \n+    /**\n+     * A collection modification occurred.\n+     * <p>\n+     * This method should be processed quickly, as with all event handling.\n+     * It should also avoid modifying the event source (the collection).\n+     * Finally it should avoid throwing an exception.\n+     * \n+     * @param event  the event detail\n+     */\n+    public void modificationOccurred(StandardModificationEvent event);\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/ObservedTestHelper.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/ObservedTestHelper.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.collections.event.ModificationEventType;\n+import org.apache.commons.collections.event.ModificationListener;\n+import org.apache.commons.collections.event.StandardModificationEvent;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+import org.apache.commons.collections.event.StandardModificationListener;\n+\n+/**\n+ * Helper for testing\n+ * {@link ObservedCollection} implementations.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedTestHelper {\n+    \n+    public static Integer SIX = new Integer(6);\n+    public static Integer SEVEN = new Integer(7);\n+    public static Integer EIGHT = new Integer(8);\n+    public static List SIX_SEVEN_LIST = new ArrayList();\n+    static {\n+        SIX_SEVEN_LIST.add(SIX);\n+        SIX_SEVEN_LIST.add(SEVEN);\n+    }\n+    \n+    public static class Listener implements StandardModificationListener {\n+        public StandardModificationEvent preEvent = null;\n+        public StandardModificationEvent postEvent = null;\n+        \n+        public void modificationOccurring(StandardModificationEvent event) {\n+            this.preEvent = event;\n+        }\n+\n+        public void modificationOccurred(StandardModificationEvent event) {\n+            this.postEvent = event;\n+        }\n+    }\n+    \n+    public static final Listener LISTENER = new Listener();\n+    public static final Listener LISTENER2 = new Listener();\n+    \n+    public ObservedTestHelper() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestFactoryPlain(ObservedCollection coll) {\n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(0, coll.getModificationListeners().length);\n+    }\n+    \n+    public static void doTestFactoryWithListener(ObservedCollection coll) {\n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(1, coll.getModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n+    }\n+    \n+    public static void doTestFactoryPostEvents(ObservedCollection coll) {\n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(1, coll.getModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        Assert.assertTrue(LISTENER.preEvent == null);\n+        Assert.assertTrue(LISTENER.postEvent != null);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public static void doTestAddRemoveGetListeners(ObservedCollection coll) {\n+        Assert.assertEquals(0, coll.getModificationListeners().length);\n+        coll.addModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n+        \n+        coll.addModificationListener(LISTENER2);\n+        Assert.assertEquals(2, coll.getModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n+        Assert.assertSame(LISTENER2, coll.getModificationListeners()[1]);\n+        \n+        coll.removeModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getModificationListeners()[0]);\n+        \n+        coll.removeModificationListener(LISTENER);  // check no error if not present\n+        Assert.assertEquals(1, coll.getModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getModificationListeners()[0]);\n+        \n+        coll.removeModificationListener(LISTENER2);\n+        Assert.assertEquals(0, coll.getModificationListeners().length);\n+        \n+        try {\n+            coll.addModificationListener(new ModificationListener() {});\n+            Assert.fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public static void doTestAdd(ObservedCollection coll) {\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(0, coll.size());\n+        coll.add(SIX);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.add(SEVEN);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(1, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.add(SIX_SEVEN_LIST);\n+        Assert.assertEquals(3, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestAddIndexed(ObservedList coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.add(1, EIGHT);\n+        Assert.assertEquals(3, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestAddAll(ObservedCollection coll) {\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(0, coll.size());\n+        coll.addAll(SIX_SEVEN_LIST);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestAddAllIndexed(ObservedList coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.addAll(1, SIX_SEVEN_LIST);\n+        Assert.assertEquals(4, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(4, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestClear(ObservedCollection coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.clear();\n+        Assert.assertEquals(0, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.CLEAR, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.CLEAR, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(0, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(0, coll.size());\n+        coll.clear();  // already done this\n+        Assert.assertEquals(0, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRemove(ObservedCollection coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.remove(SEVEN);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.remove(SEVEN);  // already removed\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRemoveIndexed(ObservedList coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.remove(0);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(0, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRemoveAll(ObservedCollection coll) {\n+        coll.add(EIGHT);\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(3, coll.size());\n+        coll.removeAll(SIX_SEVEN_LIST);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ALL, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ALL, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.removeAll(SIX_SEVEN_LIST);  // already done this\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRetainAll(ObservedCollection coll) {\n+        coll.add(EIGHT);\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(3, coll.size());\n+        coll.retainAll(SIX_SEVEN_LIST);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.RETAIN_ALL, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.RETAIN_ALL, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.retainAll(SIX_SEVEN_LIST);  // already done this\n+        Assert.assertEquals(2, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestIteratorRemove(ObservedCollection coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        Iterator it = coll.iterator();\n+        it.next();\n+        it.next();\n+        it.remove();\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.remove(SEVEN);  // already removed\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestSetIndexed(ObservedList coll) {\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.set(0, EIGHT);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.SET_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.SET_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(0, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/TestObservedCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedCollection.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestCollection;\n+import org.apache.commons.collections.event.ModificationEventType;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+\n+/**\n+ * Extension of {@link TestCollection} for exercising the\n+ * {@link ObservedCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedCollection extends TestCollection {\n+    \n+    private static Integer SIX = new Integer(6);\n+    private static Integer SEVEN = new Integer(7);\n+    private static Integer EIGHT = new Integer(8);\n+    private static final ObservedTestHelper.Listener LISTENER = ObservedTestHelper.LISTENER;\n+    \n+    public TestObservedCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedCollection.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedCollection.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    protected Collection makeConfirmedFullCollection() {\n+        List list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+    \n+    public Collection makeCollection() {\n+        return ObservedCollection.decorate(new ArrayList(), LISTENER);\n+    }\n+\n+    protected Collection makeFullCollection() {\n+        List list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return ObservedCollection.decorate(list, LISTENER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testObservedCollection() {\n+        ObservedCollection coll = ObservedCollection.decorate(new ArrayList());\n+        ObservedTestHelper.doTestFactoryPlain(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestFactoryWithListener(coll);\n+        \n+        coll = ObservedCollection.decoratePostEventsOnly(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestFactoryPostEvents(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList());\n+        ObservedTestHelper.doTestAddRemoveGetListeners(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestAdd(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestAddAll(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestClear(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRemove(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRemoveAll(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRetainAll(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestIteratorRemove(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testFactoryWithHandler() {\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedCollection coll = ObservedCollection.decorate(new ArrayList(), handler);\n+        \n+        assertSame(handler, coll.getHandler());\n+        assertEquals(0, coll.getModificationListeners().length);\n+    }\n+    \n+    public void testFactoryWithMasks() {\n+        ObservedCollection coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, 0);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent == null);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, -1);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent == null);\n+        assertTrue(LISTENER.postEvent != null);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, -1);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent != null);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, 0);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent == null);\n+        assertTrue(LISTENER.postEvent == null);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent == null);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/TestObservedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedList.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestList;\n+import org.apache.commons.collections.event.ModificationEventType;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+\n+/**\n+ * Extension of {@link TestList} for exercising the\n+ * {@link ObservedList} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedList extends TestList {\n+    \n+    private static Integer SIX = new Integer(6);\n+    private static Integer SEVEN = new Integer(7);\n+    private static Integer EIGHT = new Integer(8);\n+    private static final ObservedTestHelper.Listener LISTENER = ObservedTestHelper.LISTENER;\n+    \n+    public TestObservedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedList.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedList.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public List makeEmptyList() {\n+        return ObservedList.decorate(new ArrayList(), LISTENER);\n+    }\n+\n+    protected List makeFullList() {\n+        List set = new ArrayList();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return ObservedList.decorate(set, LISTENER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testObservedList() {\n+        ObservedList coll = ObservedList.decorate(new ArrayList());\n+        ObservedTestHelper.doTestFactoryPlain(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestFactoryWithListener(coll);\n+        \n+        coll = ObservedList.decoratePostEventsOnly(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestFactoryPostEvents(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList());\n+        ObservedTestHelper.doTestAddRemoveGetListeners(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestAdd(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestAddIndexed(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestAddAll(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestAddAllIndexed(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestClear(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRemove(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRemoveIndexed(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRemoveAll(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestRetainAll(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestIteratorRemove(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER);\n+        ObservedTestHelper.doTestSetIndexed(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testFactoryWithHandler() {\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedList coll = ObservedList.decorate(new ArrayList(), handler);\n+        \n+        assertSame(handler, coll.getHandler());\n+        assertEquals(0, coll.getModificationListeners().length);\n+    }\n+    \n+    public void testFactoryWithMasks() {\n+        ObservedList coll = ObservedList.decorate(new ArrayList(), LISTENER, -1, 0);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent == null);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER, 0, -1);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent == null);\n+        assertTrue(LISTENER.postEvent != null);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER, -1, -1);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent != null);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER, 0, 0);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent == null);\n+        assertTrue(LISTENER.postEvent == null);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent == null);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/TestObservedSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedSet.java,v 1.1 2003/08/28 18:31:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestSet;\n+import org.apache.commons.collections.event.ModificationEventType;\n+import org.apache.commons.collections.event.StandardModificationHandler;\n+\n+/**\n+ * Extension of {@link TestSet} for exercising the\n+ * {@link ObservedSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/28 18:31:13 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedSet extends TestSet {\n+    \n+    private static Integer SIX = new Integer(6);\n+    private static Integer SEVEN = new Integer(7);\n+    private static Integer EIGHT = new Integer(8);\n+    private static final ObservedTestHelper.Listener LISTENER = ObservedTestHelper.LISTENER;\n+    \n+    public TestObservedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedSet.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedSet.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Set makeEmptySet() {\n+        return ObservedSet.decorate(new HashSet(), LISTENER);\n+    }\n+\n+    protected Set makeFullSet() {\n+        Set set = new HashSet();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return ObservedSet.decorate(set, LISTENER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testObservedSet() {\n+        ObservedSet coll = ObservedSet.decorate(new HashSet());\n+        ObservedTestHelper.doTestFactoryPlain(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestFactoryWithListener(coll);\n+        \n+        coll = ObservedSet.decoratePostEventsOnly(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestFactoryPostEvents(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet());\n+        ObservedTestHelper.doTestAddRemoveGetListeners(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestAdd(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestAddAll(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestClear(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestRemove(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestRemoveAll(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestRetainAll(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER);\n+        ObservedTestHelper.doTestIteratorRemove(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testFactoryWithHandler() {\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedSet coll = ObservedSet.decorate(new HashSet(), handler);\n+        \n+        assertSame(handler, coll.getHandler());\n+        assertEquals(0, coll.getModificationListeners().length);\n+    }\n+    \n+    public void testFactoryWithMasks() {\n+        ObservedSet coll = ObservedSet.decorate(new HashSet(), LISTENER, -1, 0);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent == null);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER, 0, -1);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent == null);\n+        assertTrue(LISTENER.postEvent != null);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER, -1, -1);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent != null);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER, 0, 0);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent == null);\n+        assertTrue(LISTENER.postEvent == null);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        assertTrue(LISTENER.preEvent != null);\n+        assertTrue(LISTENER.postEvent == null);\n+    }\n+    \n+}", "timestamp": 1062095473, "metainfo": ""}