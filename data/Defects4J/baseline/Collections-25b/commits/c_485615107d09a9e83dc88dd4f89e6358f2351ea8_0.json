{"sha": "485615107d09a9e83dc88dd4f89e6358f2351ea8", "log": "Added new Map implementations and Closure classes   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ArrayIterator.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Iterator;\n+\n+/** Implements {@link Iterator} over an array of objects\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  * @version $Revision: 1.1 $\n+  */\n+public class ArrayIterator implements Iterator {\n+    \n+    private Object[] array;\n+    private int index = -1;\n+\n+    \n+    public ArrayIterator() {\n+    }\n+    \n+    public ArrayIterator(Object[] array) {\n+        this.array = array;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return ++index >= 0 && index < array.length;\n+    }\n+\n+    public Object next() {\n+        return array[ index ];\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException( \"remove() method is not supported\" );\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    public Object[] getArray() {\n+        return array;\n+    }\n+    \n+    public void setArray( Object[] array ) {\n+        this.array = array;\n+        this.index = -1;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/BeanMap.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.beans.BeanInfo;\n+import java.beans.Introspector;\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/** An implementation of Map for JavaBeans which uses introspection to\n+  * get and put properties in the bean.\n+  *\n+  * If an exception occurs during attempts to get or set a property then the\n+  * property is considered non existent in the Map\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class BeanMap extends AbstractMap {\n+\n+    private Object bean;\n+\n+    private HashMap readMethods = new HashMap();\n+    private HashMap writeMethods = new HashMap();\n+    private HashMap types = new HashMap();\n+\n+    public static final Object[] NULL_ARGUMENTS = {};\n+    public static HashMap defaultTransformers = new HashMap();\n+    \n+    static {\n+        defaultTransformers.put( \n+            Boolean.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Boolean.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Character.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return new Character( input.toString().charAt( 0 ) );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Byte.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Byte.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Short.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Short.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Integer.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Integer.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Long.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Long.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Float.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Float.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Double.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Double.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+    }\n+    \n+    \n+    // Constructors\n+    //-------------------------------------------------------------------------\n+    public BeanMap() {\n+    }\n+\n+    public BeanMap(Object bean) {\n+        this.bean = bean;\n+        initialise();\n+    }\n+\n+    // Map interface\n+    //-------------------------------------------------------------------------\n+\n+    public Object clone() {\n+        Class beanClass = bean.getClass();\n+        try {\n+            Object newBean = beanClass.newInstance();\n+            Map newMap = new BeanMap( newBean );\n+            newMap.putAll( this );\n+            return newMap;\n+        } \n+        catch (Exception e) {\n+            throw new UnsupportedOperationException( \"Could not create new instance of class: \" + beanClass );\n+        }\n+    }\n+\n+    public void clear() {\n+        Class beanClass = bean.getClass();\n+        try {\n+            bean = beanClass.newInstance();\n+        }\n+        catch (Exception e) {\n+            throw new UnsupportedOperationException( \"Could not create new instance of class: \" + beanClass );\n+        }\n+    }\n+\n+    public boolean containsKey(String name) {\n+        Method method = getReadMethod( name );\n+        return method != null;\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        // use default implementation\n+        return super.containsValue( value );\n+    }\n+\n+    public Object get(Object name) {\n+        if ( bean != null ) {\n+            Method method = getReadMethod( name );\n+            if ( method != null ) {\n+                try {\n+                    return method.invoke( bean, NULL_ARGUMENTS );\n+                }\n+                catch (  IllegalAccessException e ) {\n+                    logWarn( e );\n+                }\n+                catch ( IllegalArgumentException e ) {\n+                    logWarn(  e );\n+                }\n+                catch ( InvocationTargetException e ) {\n+                    logWarn(  e );\n+                }\n+                catch ( NullPointerException e ) {\n+                    logWarn(  e );\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public Object put(Object name, Object value) throws IllegalArgumentException, ClassCastException {\n+        if ( bean != null ) {\n+            Object oldValue = get( name );\n+            Method method = getWriteMethod( name );\n+            if ( method == null ) {\n+                throw new IllegalArgumentException( \"The bean of type: \"+ bean.getClass().getName() + \" has no property called: \" + name );\n+            }\n+            try {\n+                Object[] arguments = createWriteMethodArguments( method, value );\n+                method.invoke( bean, arguments );\n+\n+                Object newValue = get( name );\n+                firePropertyChange( name, oldValue, newValue );\n+            }\n+            catch ( InvocationTargetException e ) {\n+                logInfo( e );\n+                throw new IllegalArgumentException( e.getMessage() );\n+            }\n+            catch ( IllegalAccessException e ) {\n+                logInfo( e );\n+                throw new IllegalArgumentException( e.getMessage() );\n+            }\n+            return oldValue;\n+        }\n+        return null;\n+    }\n+                    \n+    public int size() {\n+        return readMethods.size();\n+    }\n+\n+    \n+    public Set keySet() {\n+        return readMethods.keySet();\n+    }\n+\n+    public Set entrySet() {\n+        return readMethods.keySet();\n+    }\n+\n+    public Collection values() {\n+        ArrayList answer = new ArrayList( readMethods.size() );\n+        for ( Iterator iter = valueIterator(); iter.hasNext(); ) {\n+            answer.add( iter.next() );\n+        }\n+        return answer;\n+    }\n+\n+\n+    // Helper methods\n+    //-------------------------------------------------------------------------\n+    \n+    public Class getType(String name) {\n+        return (Class) types.get( name );\n+    }\n+\n+    public Iterator keyIterator() {\n+        return readMethods.keySet().iterator();\n+    }\n+\n+    public Iterator valueIterator() {\n+        final Iterator iter = keyIterator();\n+        return new Iterator() {            \n+            public boolean hasNext() {\n+                return iter.hasNext();\n+            }\n+            public Object next() {\n+                Object key = iter.next();\n+                return get( (String) key );\n+            }\n+            public void remove() {\n+                throw new UnsupportedOperationException( \"remove() not supported for BeanMap\" );\n+            }\n+        };\n+    }\n+\n+    public Iterator entryIterator() {\n+        final Iterator iter = keyIterator();\n+        return new Iterator() {            \n+            public boolean hasNext() {\n+                return iter.hasNext();\n+            }            \n+            public Object next() {\n+                Object key = iter.next();\n+                Object value = get( (String) key );\n+                return new MyMapEntry( BeanMap.this, key, value );\n+            }            \n+            public void remove() {\n+                throw new UnsupportedOperationException( \"remove() not supported for BeanMap\" );\n+            }\n+        };\n+    }\n+\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    public Object getBean() {\n+        return bean;\n+    }\n+\n+    public void setBean( Object newBean ) {\n+        bean = newBean;\n+        reinitialise();\n+    }\n+\n+\n+    // Implementation methods\n+    //-------------------------------------------------------------------------\n+\n+    protected Method getReadMethod( Object name ) {\n+        return (Method) readMethods.get( name );\n+    }\n+\n+    protected Method getWriteMethod( Object name ) {\n+        return (Method) writeMethods.get( name );\n+    }\n+\n+    protected void reinitialise() {\n+        readMethods.clear();\n+        writeMethods.clear();\n+        types.clear();\n+        initialise();\n+    }\n+\n+    private void initialise() {\n+        Class  beanClass = getBean().getClass();\n+        try {\n+            //BeanInfo beanInfo = Introspector.getBeanInfo( bean, null );\n+            BeanInfo beanInfo = Introspector.getBeanInfo( beanClass );\n+            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n+            if ( propertyDescriptors != null ) {\n+                for ( int i = 0; i < propertyDescriptors.length; i++ ) {\n+                    PropertyDescriptor propertyDescriptor = propertyDescriptors[i];\n+                    if ( propertyDescriptor != null ) {\n+                        String name = propertyDescriptor.getName();\n+                        Method readMethod = propertyDescriptor.getReadMethod();\n+                        Method writeMethod = propertyDescriptor.getWriteMethod();\n+                        Class aType = propertyDescriptor.getPropertyType();\n+\n+                        if ( readMethod != null ) {\n+                            readMethods.put( name, readMethod );\n+                        }\n+                        if ( writeMethods != null ) {\n+                            writeMethods.put( name, writeMethod );\n+                        }\n+                        types.put( name, aType );\n+                    }\n+                }\n+            }\n+        }\n+        catch ( IntrospectionException e ) {\n+            logWarn(  e );\n+        }\n+    }\n+\n+    protected void firePropertyChange( Object key, Object oldValue, Object newValue ) {\n+    }\n+\n+    // Implementation classes\n+    //-------------------------------------------------------------------------\n+    protected static class MyMapEntry extends DefaultMapEntry {        \n+        private BeanMap owner;\n+        \n+        protected MyMapEntry( BeanMap owner, Object key, Object value ) {\n+            super( key, value );\n+            this.owner = owner;\n+        }\n+\n+        public Object setValue(Object value) {\n+            Object key = getKey();\n+            Object oldValue = owner.get( key );\n+\n+            owner.put( key, value );\n+            Object newValue = owner.get( key );\n+            super.setValue( newValue );\n+            return oldValue;\n+        }\n+    }\n+    \n+    protected Object[] createWriteMethodArguments( Method method, Object value ) throws IllegalAccessException, ClassCastException {            \n+        try {\n+            if ( value != null ) {\n+                Class[] types = method.getParameterTypes();\n+                if ( types != null && types.length > 0 ) {\n+                    Class paramType = types[0];\n+                    if ( ! paramType.isAssignableFrom( value.getClass() ) ) {\n+                        value = convertType( paramType, value );\n+                    }\n+                }\n+            }\n+            Object[] answer = { value };\n+            return answer;\n+        }\n+        catch ( InvocationTargetException e ) {\n+            logInfo( e );\n+            throw new IllegalArgumentException( e.getMessage() );\n+        }\n+        catch ( InstantiationException e ) {\n+            logInfo( e );\n+            throw new IllegalArgumentException( e.getMessage() );\n+        }\n+    }\n+    \n+    protected Object convertType( Class newType, Object value ) \n+        throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+        \n+        // try call constructor\n+        Class[] types = { value.getClass() };\n+        try {\n+            Constructor constructor = newType.getConstructor( types );        \n+            Object[] arguments = { value };\n+            return constructor.newInstance( arguments );\n+        }\n+        catch ( NoSuchMethodException e ) {\n+            // try using the transformers\n+            Transformer transformer = getTypeTransformer( newType );\n+            if ( transformer != null ) {\n+                return transformer.transform( value );\n+            }\n+            return value;\n+        }\n+    }\n+    \n+    protected Transformer getTypeTransformer( Class aType ) {\n+        return (Transformer) defaultTransformers.get( aType );\n+    }\n+    \n+    protected void logInfo(Exception e) {\n+        // XXXX: should probably use log4j here instead...\n+        System.out.println( \"INFO: Exception: \" + e );\n+    }\n+    \n+    protected void logWarn(Exception e) {\n+        // XXXX: should probably use log4j here instead...\n+        System.out.println( \"WARN: Exception: \" + e );\n+        e.printStackTrace();\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/Closure.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+/** An interface to represent some Closure, a block of code which is executed \n+  * from inside some block, function or iteration which operates on an input \n+  * object.\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+public interface Closure {\n+\n+    /** Performs some operation on the input object\n+      */\n+    public void execute(Object input);\n+}\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.2 2001/05/04 16:32:17 rwaldhoff Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/05/04 16:32:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.3 2001/05/06 11:04:25 jstrachan Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/05/06 11:04:25 $\n  *\n  * ====================================================================\n  *\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n  *\n  * @author Rodney Waldhoff\n  *\n- * @version $Id: CollectionUtils.java,v 1.2 2001/05/04 16:32:17 rwaldhoff Exp $\n+ * @version $Id: CollectionUtils.java,v 1.3 2001/05/06 11:04:25 jstrachan Exp $\n  */\n public class CollectionUtils {\n     /**\n         return count;\n     }\n \n+    \n+    \n+    \n+    /** Finds the first element in the given collection which matches the given predicate\n+      *\n+      * @return the first element of the collection which matches the predicate or null if none could be found\n+      */\n+    public static Object find( Collection collection, Predicate predicate ) {\n+        if ( collection != null && predicate != null ) {            \n+            for ( Iterator iter = collection.iterator(); iter.hasNext(); ) {\n+                Object item = iter.next();\n+                if ( predicate.evaluate( item ) ) {\n+                    return item;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /** Executes the given closure on each element in the colleciton\n+      */\n+    public static void forAllDo( Collection collection, Closure closure) {\n+        if ( collection != null ) {\n+            for ( Iterator iter = collection.iterator(); iter.hasNext(); ) {\n+                Object element = iter.next();\n+                closure.execute( element );\n+            }\n+        }\n+    }\n+\n+    /** Selects all elements from inputCollection which match the given predicate\n+      * into an output collection\n+      */\n+    public static Collection select( Collection inputCollection, Predicate predicate ) {\n+        ArrayList answer = new ArrayList( inputCollection.size() );\n+        select( inputCollection, predicate, answer );\n+        return answer;\n+    }\n+    \n+    /** Selects all elements from inputCollection which match the given predicate\n+      * and adds them to outputCollection\n+      *\n+      * @return the outputCollection\n+      */\n+    public static Collection select( Collection inputCollection, Predicate predicate, Collection outputCollection ) {\n+        if ( inputCollection != null && predicate != null ) {            \n+            for ( Iterator iter = inputCollection.iterator(); iter.hasNext(); ) {\n+                Object item = iter.next();\n+                if ( predicate.evaluate( item ) ) {\n+                    outputCollection.add( item );\n+                }\n+            }\n+        }\n+        return outputCollection;\n+    }\n+    \n+    /** Transforms all elements from inputCollection with the given transformer \n+      * and adds them to the outputCollection\n+      */\n+    public static Collection collect( Collection inputCollection, Transformer transformer ) {\n+        ArrayList answer = new ArrayList( inputCollection.size() );\n+        collect( inputCollection, transformer, answer );\n+        return answer;\n+    }\n+    \n+    /** Transforms all elements from the inputIterator  with the given transformer \n+      * and adds them to the outputCollection\n+      */\n+    public static Collection collect( Iterator inputIterator, Transformer transformer ) {\n+        ArrayList answer = new ArrayList();\n+        collect( inputIterator, transformer, answer );\n+        return answer;\n+    }\n+    \n+    /** Transforms all elements from inputCollection with the given transformer \n+      * and adds them to the outputCollection\n+      *\n+      * @return the outputCollection\n+      */\n+    public static Collection collect( Collection inputCollection, final Transformer transformer, final Collection outputCollection ) {\n+        if ( inputCollection != null ) {\n+            return collect( inputCollection.iterator(), transformer, outputCollection );\n+        }\n+        return outputCollection;\n+    }\n+\n+    /** Transforms all elements from the inputIterator with the given transformer \n+      * and adds them to the outputCollection\n+      *\n+      * @return the outputCollection\n+      */\n+    public static Collection collect( Iterator inputIterator, final Transformer transformer, final Collection outputCollection ) {\n+        if ( inputIterator != null && transformer != null ) {            \n+            while ( inputIterator.hasNext() ) {\n+                Object item = inputIterator.next();\n+                Object value = transformer.transform( item );\n+                outputCollection.add( value );\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    /** Adds all elements in the iteration to the given collection \n+      */\n+    public static void addAll( Collection collection, Iterator iterator ) {\n+        while ( iterator.hasNext() ) {\n+            collection.add( iterator.next() );\n+        }\n+    }\n+    \n+    /** Adds all elements in the enumeration to the given collection \n+      */\n+    public static void addAll( Collection collection, Enumeration enumeration ) {\n+        while ( enumeration.hasMoreElements() ) {\n+            collection.add( enumeration.nextElement() );\n+        }\n+    }    \n+    \n+    /** Adds all elements in the array to the given collection \n+      */\n+    public static void addAll( Collection collection, Object[] elements ) {\n+        for ( int i = 0, size = elements.length; i < size; i++ ) {\n+            collection.add( elements[i] );\n+        }\n+    }    \n+    \n     private static final int getFreq(final Object obj, final Map freqMap) {\n         try {\n             return ((Integer)(freqMap.get(obj))).intValue();\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/DefaultMapEntry.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.*;\n+\n+/** A default implementation of {@link Map.Entry Map.Entry}\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+  \n+public class DefaultMapEntry implements Map.Entry {\n+    \n+    private Object              key;\n+    private Object              value;\n+\n+    protected static final int HASH_CODE_SEED = 123456789;\n+    \n+    \n+    public DefaultMapEntry() {\n+    }\n+\n+    public DefaultMapEntry(Object key, Object value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if ( ! (o instanceof DefaultMapEntry ) )\n+            return false;\n+        DefaultMapEntry that = (DefaultMapEntry) o;\n+\n+        if ( ( this.key == null && that.key == null )\n+            || ( this.key != null && this.key.equals( that.key ) ) )\n+        {\n+            if ( ( this.value == null && that.value == null )\n+                || ( this.value != null && this.value.equals( that.value ) ) )\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean equals( DefaultMapEntry that ) {\n+        if ( ( key == null && that.key == null ) || ( key != null && key.equals( that.key ) ) ) {\n+            return ( value == null && value == null ) || ( value != null && value.equals( that.value ) );\n+        }\n+        return false;\n+    }\n+    \n+    public int hashCode() {\n+        int answer = HASH_CODE_SEED;\n+        if ( key != null ) {\n+            answer ^= key.hashCode();\n+        }\n+        if ( value != null ) {\n+            answer ^= value.hashCode();\n+        }\n+        return answer;\n+    }\n+\n+\n+    // Map.Entry interface\n+    //-------------------------------------------------------------------------\n+    public Object getKey() {\n+        return key;\n+    }\n+\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------    \n+    public void setKey(Object key) {\n+        this.key = key;\n+    }\n+    \n+    /** Note that this method only sets the local reference inside this object and\n+      * does not modify the original Map.\n+      *\n+      * @return the old value of the value\n+      * @param value the new value\n+      */\n+    public Object setValue(Object value) {\n+        Object answer = this.value;\n+        this.value = value;\n+        return answer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/EnumerationIterator.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** Adapter to make {@link Enumeration Enumeration} instances appear to be {@link Iterator Iterator} instances\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class EnumerationIterator implements Iterator {\n+    \n+    private Enumeration enumeration;\n+\n+    \n+    public EnumerationIterator() {\n+    }\n+    \n+    public EnumerationIterator( Enumeration enumeration ) {\n+        this.enumeration = enumeration;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return enumeration.hasMoreElements();\n+    }\n+\n+    public Object next() {\n+        return enumeration.nextElement();\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException( \"remove() method is not supported\" );\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    public Enumeration getEnumeration() {\n+        return enumeration;\n+    }\n+    \n+    public void setEnumeration( Enumeration enumeration ) {\n+        this.enumeration = enumeration;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FilterIterator.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** A Proxy {@link Iterator Iterator} which takes a {@link Predicate Predicate} instance to filter\n+  * out objects from an underlying {@link Iterator Iterator} instance.\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class FilterIterator extends ProxyIterator {\n+    \n+    /** Holds value of property predicate. */\n+    private Predicate predicate;\n+    private Object nextObject;\n+    \n+    \n+    //-------------------------------------------------------------------------\n+    public FilterIterator() {\n+    }\n+    \n+    public FilterIterator( Iterator iterator ) {\n+        super( iterator );\n+    }\n+\n+    public FilterIterator( Iterator iterator, Predicate predicate ) {\n+        super( iterator );\n+        this.predicate = predicate;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+    public boolean hasNext() {\n+        Iterator iterator = getIterator();\n+        Predicate predicate = getPredicate();\n+        while ( iterator.hasNext() ) {\n+            Object object = iterator.next();\n+            if ( predicate.evaluate( object ) ) {\n+                nextObject = object;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Object next() {\n+        return nextObject;\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    /** Getter for property predicate.\n+     * @return Value of property predicate.\n+     */\n+    public Predicate getPredicate() {\n+        return predicate;\n+    }\n+    /** Setter for property predicate.\n+     * @param predicate New value of property predicate.\n+     */\n+    public void setPredicate(Predicate predicate) {\n+        this.predicate = predicate;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/IteratorEnumeration.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** Adapter to make an {@link Iterator Iterator} instance appear to be an {@link Enumeration Enumeration} instances\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class IteratorEnumeration implements Enumeration {\n+    \n+    private Iterator iterator;\n+    \n+    public IteratorEnumeration() {\n+    }\n+\n+    public IteratorEnumeration( Iterator iterator ) {\n+        this.iterator = iterator;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+    public boolean hasMoreElements() {\n+        return iterator.hasNext();\n+    }\n+\n+    public Object nextElement() {\n+        return iterator.next();\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    public Iterator getIterator() {\n+        return iterator;\n+    }\n+    \n+    public void setIterator( Iterator iterator ) {\n+        this.iterator = iterator;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/LRUMap.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+/** <p>\n+  * An implementation of a Map which has a maximum size and uses a Least Recently Used\n+  * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n+  * </p>\n+  *\n+  * <p>\n+  * This implementation uses a simple bubbling\n+  * algorithm, whereby every random access get() method call bubbles the item\n+  * up the list, further away from the 'drop zone'.\n+  * </p>\n+  *\n+  * <p>\n+  * A synchronized version can be obtained with:\n+  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n+  * </p>\n+  *\n+  * <p>\n+  * <b>WARNING</b> the values() and entrySet() methods require optimisation\n+  * like the standard {@link HashMap} implementations so that iteration\n+  * over this Map is efficient.\n+  * </p>\n+  * \n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+public class LRUMap extends HashMap implements Externalizable {\n+    \n+    /** Holds value of property maximumSize. */\n+    private int maximumSize;\n+    /** Used to hold the bubble list - bubbles keys up the list as they are accessed */\n+    private ArrayList bubbleList;\n+    \n+    //static final long serialVersionUID = 0x9e1e06764b24cb05L;\n+\n+    public LRUMap() {\n+        this( 100 );\n+    }\n+\n+    public LRUMap(int i) {\n+        super( i );\n+        maximumSize = i;\n+        bubbleList = new ArrayList( i );\n+    }\n+\n+    /** Removes the least recently used object from the Map.\n+      * @return the key of the removed item\n+      */\n+    public Object removeLRU() {\n+        int lastItem = size();\n+        Object key = bubbleList.remove( lastItem );\n+        ValuePositionPair pair = removePair( key );\n+        return key;\n+    }\n+    \n+    // Map interface\n+    //-------------------------------------------------------------------------        \n+    public Object get( Object key ) {\n+        ValuePositionPair pair = getPair( key );\n+        if ( pair == null ) {\n+            return null;\n+        }\n+        int position = pair.position;\n+        if ( position > 0 ) {\n+            // lets bubble up this entry up the list\n+            // avoiding expesive list removal / insertion\n+            int position2 = position - 1;\n+            Object key2 = bubbleList.get( position2 );\n+            ValuePositionPair pair2 = getPair( key2 );\n+            if ( pair2 != null ) {\n+                pair2.position = position;\n+                pair.position = position2;\n+                bubbleList.set( position, key2 );\n+                bubbleList.set( position2, key );\n+            }\n+        }\n+        return pair.value;\n+    }\n+\n+    public Object put( Object key, Object value ) {\n+        int i = size();\n+        ValuePositionPair pair = new ValuePositionPair( value );\n+        if ( i >= maximumSize ) {\n+            // lets retire the least recently used item in the cache\n+            int lastIndex = maximumSize - 1;\n+            pair.position = lastIndex;\n+            Object oldKey = bubbleList.set( lastIndex, key );\n+            super.remove( oldKey );\n+        } \n+        else {\n+            pair.position = i;\n+            bubbleList.add( i, key );\n+        }\n+        pair = (ValuePositionPair) putPair( key, pair );\n+        return ( pair != null ) ? pair.value : null;\n+    }\n+\n+    public Object remove( Object key ) {\n+        ValuePositionPair pair = removePair( key );\n+        return ( pair != null ) ? pair.value : null;\n+    }\n+    \n+    public boolean containsKey( Object key ) {\n+        return super.containsKey( key );\n+    }\n+\n+    public boolean containsValue( Object value ) {\n+        for ( Iterator iter = pairIterator(); iter.hasNext(); ) {\n+            ValuePositionPair pair = (ValuePositionPair) iter.next();\n+            Object otherValue = pair.value;\n+            if ( value == otherValue ) {\n+                return true;\n+            }\n+            if ( value != null && value.equals( otherValue ) ) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    public Set keySet() {\n+        return super.keySet();\n+    }\n+    \n+    public Set entrySet() {\n+        HashSet answer = new HashSet();\n+        for ( Iterator iter = super.entrySet().iterator(); iter.hasNext(); ) {\n+            Map.Entry otherEntry = (Map.Entry) iter.next();\n+            Object key = otherEntry.getKey();\n+            ValuePositionPair pair = (ValuePositionPair) otherEntry.getValue();\n+            Object value = pair.value;\n+            Entry newEntry = new Entry( key, value );\n+            answer.add( newEntry );\n+        }\n+        return answer;\n+    }\n+\n+    public Collection values() {\n+        ArrayList answer = new ArrayList();\n+        for ( Iterator iter = super.entrySet().iterator(); iter.hasNext(); ) {\n+            Map.Entry otherEntry = (Map.Entry) iter.next();\n+            Entry newEntry = new Entry( otherEntry.getKey(), otherEntry.getValue() );\n+            answer.add( newEntry );\n+        }\n+        return answer;\n+    }\n+\n+\n+ \n+    // Externalizable interface\n+    //-------------------------------------------------------------------------        \n+    public void readExternal( ObjectInput in )  throws IOException, ClassNotFoundException {\n+        maximumSize = in.readInt();\n+        int size = in.readInt();\n+        \n+        // create a populated list\n+        bubbleList = new ArrayList( maximumSize );\n+        for( int i = 0; i < size; i++ )  {\n+            bubbleList.add( \"\" );\n+        }\n+\n+        for( int i = 0; i < size; i++ )  {\n+            Object key = in.readObject();\n+            Object value = in.readObject();\n+            ValuePositionPair pair = (ValuePositionPair) value;            \n+            int position = pair.position;\n+            bubbleList.set( position, pair );\n+            putPair( key, pair );\n+        }\n+    }\n+\n+    public void writeExternal( ObjectOutput out ) throws IOException {\n+        out.writeInt( maximumSize );\n+        out.writeInt( size() );\n+        for( Iterator iterator = keySet().iterator(); iterator.hasNext(); ) {\n+            Object key = iterator.next();\n+            out.writeObject( key );\n+            Object value = getPair( key );\n+            out.writeObject( value );\n+        }\n+    }\n+    \n+    \n+    // Properties\n+    //-------------------------------------------------------------------------        \n+    /** Getter for property maximumSize.\n+     * @return Value of property maximumSize.\n+     */\n+    public int getMaximumSize() {\n+        return maximumSize;\n+    }\n+    /** Setter for property maximumSize.\n+     * @param maximumSize New value of property maximumSize.\n+     */\n+    public void setMaximumSize(int maximumSize) {\n+        this.maximumSize = maximumSize;\n+    }\n+    \n+    \n+    // Implementation methods\n+    //-------------------------------------------------------------------------        \n+    protected ValuePositionPair getPair( Object key ) {\n+        return (ValuePositionPair) super.get( key );\n+    }\n+    \n+    protected ValuePositionPair putPair( Object key, ValuePositionPair pair ) {\n+        return (ValuePositionPair) super.put( key, pair );\n+    }\n+    \n+    protected ValuePositionPair removePair( Object key ) {\n+        return (ValuePositionPair) super.remove( key );\n+    }\n+    \n+    protected Iterator pairIterator() {\n+        return super.values().iterator();\n+    }\n+    \n+    // Implementation classes\n+    //-------------------------------------------------------------------------    \n+    protected static class ValuePositionPair implements Serializable {\n+\n+        public Object value;\n+        public int position;\n+\n+        public ValuePositionPair() {\n+        }\n+        \n+        public ValuePositionPair( Object value ) {\n+            this.value = value;\n+        }\n+        \n+        public String toString() {\n+            return \"[ \" + position + \": \" + value + \" ]\";\n+        }\n+    }\n+    \n+    /** \n+     * A map entry, which is backed by this RefHashMap\n+     */\n+    class Entry implements Map.Entry {\n+        \n+        /**\n+         * Constructor\n+         */\n+        public Entry( Object key, Object value ) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        // Map.Entry interface\n+        // -----------------------------------------------------------\n+        \n+        /**\n+         * Retrieves the key of this mapping\n+         */\n+        public Object getKey() {\n+            return key;\n+        }\n+        \n+        /**\n+         * Retrieves the value of this mapping\n+         */\n+        public Object getValue() {\n+           return value;\n+        }\n+        \n+        /**\n+         * Sets the value of this mapping\n+         */\n+        public Object setValue( Object value ) {\n+            this.value = value;\n+            put( key, value ); \n+            return value;\n+        }\n+        \n+        /**\n+         * Return the hash code of this mapping.\n+         * This algorithm was taken from the JavaDoc for Map.Entry\n+         */\n+        public int hashCode() {\n+            return ( getKey() == null ? 0 : getKey().hashCode() ) ^\n+                ( getValue() == null ? 0 : getValue().hashCode() );\n+         }\n+        \n+        /** The domain of this mapping */\n+        private Object key;\n+        /** The range of this mapping */\n+        private Object value;    \n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.*;\n+import java.text.*;\n+import java.util.*;\n+\n+/** A helper class for using {@link Map Map} instances.\n+  *\n+  * It contains various typesafe methods\n+  * as well as other useful features like deep copying\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+public class MapUtils {\n+\n+    private static int debugIndent = 0;\n+    \n+    \n+    \n+    // Type safe getters\n+    //-------------------------------------------------------------------------\n+    public static Object getObject( Map map, Object key ) {\n+        if ( map != null ) {\n+            return map.get( key );\n+        }\n+        return null;\n+    }\n+\n+    public static String getString( Map map, Object key ) {\n+        if ( map != null ) {\n+            Object answer = map.get( key );\n+            if ( answer != null ) {\n+                return answer.toString();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static Boolean getBoolean( Map map, Object key ) {\n+        if ( map != null ) {\n+            Object answer = map.get( key );\n+            if ( answer != null ) {\n+                if ( answer instanceof Boolean ) {\n+                    return (Boolean) answer;\n+                }\n+                else\n+                if ( answer instanceof String ) {\n+                    return new Boolean( (String) answer );\n+                }\n+                else\n+                if ( answer instanceof Number ) {\n+                    Number n = (Number) answer;\n+                    return ( n.intValue() != 0 ) ? Boolean.TRUE : Boolean.FALSE;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static Number getNumber( Map map, Object key ) {\n+        if ( map != null ) {\n+            Object answer = map.get( key );\n+            if ( answer != null ) {\n+                if ( answer instanceof Number ) {\n+                    return (Number) answer;\n+                }\n+                else\n+                if ( answer instanceof String ) {\n+                    try {\n+                        String text = (String) answer;\n+                        return NumberFormat.getInstance().parse( text );\n+                    }\n+                    catch (ParseException e) {\n+                        logInfo( e );\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static Byte getByte( Map map, Object key ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            return null;\n+        }\n+        else\n+        if ( answer instanceof Byte ) {\n+            return (Byte) answer;\n+        }\n+        return new Byte( answer.byteValue() );\n+    }\n+\n+    public static Short getShort( Map map, Object key ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            return null;\n+        }\n+        else\n+        if ( answer instanceof Short ) {\n+            return (Short) answer;\n+        }\n+        return new Short( answer.shortValue() );\n+    }\n+\n+    public static Integer getInteger( Map map, Object key ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            return null;\n+        }\n+        else\n+        if ( answer instanceof Integer ) {\n+            return (Integer) answer;\n+        }\n+        return new Integer( answer.intValue() );\n+    }\n+\n+    public static Long getLong( Map map, Object key ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            return null;\n+        }\n+        else\n+        if ( answer instanceof Long ) {\n+            return (Long) answer;\n+        }\n+        return new Long( answer.longValue() );\n+    }\n+\n+    public static Float getFloat( Map map, Object key ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            return null;\n+        }\n+        else\n+        if ( answer instanceof Float ) {\n+            return (Float) answer;\n+        }\n+        return new Float( answer.floatValue() );\n+    }\n+\n+    public static Double getDouble( Map map, Object key ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            return null;\n+        }\n+        else\n+        if ( answer instanceof Double ) {\n+            return (Double) answer;\n+        }\n+        return new Double( answer.doubleValue() );\n+    }\n+\n+    public static Map getMap( Map map, Object key ) {\n+        if ( map != null ) {\n+            Object answer = map.get( key );\n+            if ( answer != null && answer instanceof Map ) {\n+                return (Map) answer;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Type safe getters with default values\n+    //-------------------------------------------------------------------------\n+    public static Object getObject( Map map, Object key, Object defaultValue ) {\n+        if ( map != null ) {\n+            Object answer = map.get( key );\n+            if ( answer != null ) {\n+                return answer;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    public static String getString( Map map, Object key, String defaultValue ) {\n+        String answer = getString( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Boolean getBoolean( Map map, Object key, Boolean defaultValue ) {\n+        Boolean answer = getBoolean( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Number getNumber( Map map, Object key, Number defaultValue ) {\n+        Number answer = getNumber( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Byte getByte( Map map, Object key, Byte defaultValue ) {\n+        Byte answer = getByte( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Short getShort( Map map, Object key, Short defaultValue ) {\n+        Short answer = getShort( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Integer getInteger( Map map, Object key, Integer defaultValue ) {\n+        Integer answer = getInteger( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Long getLong( Map map, Object key, Long defaultValue ) {\n+        Long answer = getLong( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Float getFloat( Map map, Object key, Float defaultValue ) {\n+        Float answer = getFloat( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Double getDouble( Map map, Object key, Double defaultValue ) {\n+        Double answer = getDouble( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    public static Map getMap( Map map, Object key, Map defaultValue ) {\n+        Map answer = getMap( map, key );\n+        if ( answer == null ) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    // Conversion methods\n+    //-------------------------------------------------------------------------\n+    public static Properties toProperties(Map input) {\n+        Properties answer = new Properties();\n+        if ( input != null ) {\n+            for ( Iterator iter = input.entrySet().iterator(); iter.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) iter.next();\n+                Object key = entry.getKey();\n+                Object value = entry.getValue();\n+                answer.put(key, value);\n+            }\n+        }\n+        return answer;\n+    }\n+\n+    // Printing methods\n+    //-------------------------------------------------------------------------\n+    public static synchronized void verbosePrint( PrintStream out, Object key, Map map ) {\n+        debugPrintIndent( out );\n+        out.println( key + \" = \" );\n+\n+        debugPrintIndent( out );\n+        out.println( \"{\" );\n+        ++debugIndent;\n+\n+        for ( Iterator iter = map.entrySet().iterator(); iter.hasNext(); ) {\n+            Map.Entry entry = (Map.Entry) iter.next();\n+            String childKey = (String) entry.getKey();\n+            Object childValue = entry.getValue();\n+            if ( childValue instanceof Map ) {\n+                verbosePrint( out, childKey, (Map) childValue );\n+            }\n+            else {\n+                debugPrintIndent( out );\n+                out.println( childKey + \" = \" + childValue);\n+            }\n+        }\n+        --debugIndent;\n+        debugPrintIndent( out );\n+        out.println( \"}\" );\n+    }\n+\n+    public static synchronized void debugPrint( PrintStream out, Object key, Map map ) {\n+        debugPrintIndent( out );\n+        out.println( key + \" = \" );\n+\n+        debugPrintIndent( out );\n+        out.println( \"{\" );\n+        ++debugIndent;\n+\n+        for ( Iterator iter = map.entrySet().iterator(); iter.hasNext(); ) {\n+            Map.Entry entry = (Map.Entry) iter.next();\n+            String childKey = (String) entry.getKey();\n+            Object childValue = entry.getValue();\n+            if ( childValue instanceof Map ) {\n+                verbosePrint( out, childKey, (Map) childValue );\n+            }\n+            else {\n+                debugPrintIndent( out );\n+\n+                String typeName = ( childValue != null )\n+                    ? childValue.getClass().getName()\n+                    : null;\n+\n+                out.println( childKey + \" = \" + childValue + \" class: \" + typeName );\n+            }\n+        }\n+        --debugIndent;\n+        debugPrintIndent( out );\n+        out.println( \"}\" );\n+    }\n+\n+    // Implementation methods\n+    //-------------------------------------------------------------------------\n+    protected static void debugPrintIndent( PrintStream out ) {\n+        for ( int i = 0; i < debugIndent; i++ ) {\n+            out.print( \"    \" );\n+        }\n+    }\n+    \n+    protected static void logInfo(Exception e) {\n+        // XXXX: should probably use log4j here instead...\n+        System.out.println( \"INFO: Exception: \" + e );\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/Predicate.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+/** Performs some predicate which returns true or false based on the input object.\n+  * Predicate instances can be used to implement queries or to do filtering.\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+public interface Predicate {\n+\n+    /** @return true if the input object matches this predicate, else returns false\n+      */\n+    public boolean evaluate(Object input);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ProxyIterator.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** A Proxy {@link Iterator Iterator} which delegates its methods to a proxy instance.\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class ProxyIterator implements Iterator {\n+    \n+    /** Holds value of property iterator. */\n+    private Iterator iterator;\n+    \n+    \n+    public ProxyIterator() {\n+    }\n+    \n+    public ProxyIterator( Iterator iterator ) {\n+        this.iterator = iterator;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return getIterator().hasNext();\n+    }\n+\n+    public Object next() {\n+        return getIterator().next();\n+    }\n+\n+    public void remove() {\n+        getIterator().remove();\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    /** Getter for property iterator.\n+     * @return Value of property iterator.\n+     */\n+    public Iterator getIterator() {\n+        return iterator;\n+    }\n+    /** Setter for property iterator.\n+     * @param iterator New value of property iterator.\n+     */\n+    public void setIterator(Iterator iterator) {\n+        this.iterator = iterator;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/SoftRefHashMap.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.lang.ref.*;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+/** <p>\n+  * HashMap with SoftReference links to values which allows the values of the Map\n+  * to be garbage collected by the JVM if it becomes low on memory.  \n+  * Derive from this class and \n+  * override the factory method <code>createReference()</code> method to make \n+  * a Map wrapped in other types of Reference.\n+  * </p>\n+  * \n+  * <p>\n+  * A synchronized version can be obtained with:\n+  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n+  * </p>\n+  *\n+  * <p>\n+  * <b>WARNING</b> the values() and entrySet() methods require optimisation\n+  * like the standard {@link HashMap} implementations so that iteration\n+  * over this Map is efficient.\n+  * </p>\n+  * \n+  * @author  James.Dodd\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+public class SoftRefHashMap implements Map {\n+    \n+    /** The wrapped HashMap */\n+    private Map hashMap = new HashMap();\n+\n+    \n+    public SoftRefHashMap() {\n+    }\n+\n+    \n+    /** \n+     * Removes References that have had their referents garbage collected\n+     */\n+    public void purge() {\n+        Map map = getMap();\n+        Set keys = map.keySet();\n+        if ( keys == null ) {\n+            return;\n+        }\n+        for ( Iterator i = keys.iterator(); i.hasNext(); ) {\n+            Object key = (Object) i.next();\n+            Reference ref = (Reference) map.get( key );\n+            if ( ref.get() == null ) {\n+                map.remove( key );\n+            }\n+        }\n+    }\n+    \n+    // Map implementation\n+    // -------------------------------------------------------\n+\n+    /**\n+     * Retrieves the referent of the Referenced value\n+     * @param key The key with which to retrieve the value\n+     */\n+    public Object get( final Object key ) {\n+        Reference ref = (Reference) getMap().get( key );\n+        if ( ref == null ) {\n+            return null;\n+        }\n+        return ref.get();    \n+    }\n+    \n+    /**\n+     * Adds a key-value mapping, wrapping the value in a Reference \n+     */\n+    public Object put( final Object key, final Object value ) {\n+        Object answer = getMap().put( key, createReference( value ) );\n+        if ( answer != null ) {\n+            return ((Reference) answer).get();\n+        }\n+        return null;\n+    }\n+\n+    /** \n+      * Returns a collection of the Referenced values\n+      */\n+    public Collection values() {\n+        Set wrappedValues = (Set) getMap().values();\n+        Set values = new TreeSet();\n+        if ( wrappedValues == null ) {\n+            return values;\n+        }\n+        for ( Iterator i = wrappedValues.iterator(); i.hasNext(); ) {\n+            Reference ref = (Reference) i.next();\n+            if ( ref != null ) {\n+                values.add( ref.get() );\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Answers whether the argument is in the domain of the mappings\n+     */\n+    public boolean containsKey( Object key ) {\n+        return getMap().containsKey( key );\n+    }\n+\n+    /**\n+     * Answers whether the argument is a Referenced value\n+     */\n+    public boolean containsValue( Object value ) {\n+        Collection values = (Collection) getMap().values();\n+        if ( values == null ) {\n+            return false;\n+        }\n+        for ( Iterator i = values.iterator(); i.hasNext(); ) {\n+            Reference ref = (Reference) i.next();\n+            if ( ref == null ) {\n+                continue;\n+            }\n+            Object target = ref.get();\n+            if ( target == value ) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** \n+      * Put all of the mappings in the argument into this wrapped map\n+      */\n+    public void putAll( final java.util.Map map ) {\n+        if ( map == null || map.size() == 0 ) {\n+            return;\n+        }   \n+        for ( Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n+            Object key = (Object) i.next();\n+            put( key, map.get( key ) );\n+        }\n+    }\n+    \n+    /**\n+      * Returns a set view of the mappings in the wrapped map\n+      */\n+    public Set entrySet() {\n+        Set entries = new HashSet();\n+        if ( size() == 0 ) {\n+            return entries;\n+        }\n+        for ( Iterator i = keySet().iterator(); i.hasNext(); ) {\n+            Object key = i.next();\n+            Object value = get( key );\n+            Entry entry = new Entry( key, value );\n+            entries.add( entry );\n+        }\n+        return entries;\n+    }\n+    \n+    /** \n+      * Removes a mapping from this map\n+      */\n+    public Object remove( final Object key ) {\n+        Reference ref = (Reference) getMap().remove( key );\n+        if ( ref != null ) {\n+            return ref.get();\n+        }\n+        return null;\n+    }\n+    \n+    /** \n+      * Clears all  mappings \n+      */\n+    public void clear() {\n+        getMap().clear();\n+    }\n+\n+    /** \n+      * Calculates the hash code for this map\n+      */\n+    public int hashCode() {\n+        return getMap().hashCode();\n+    }\n+    \n+    /** \n+      * Returns the domain of the mappings\n+      */\n+    public Set keySet() {\n+        return getMap().keySet();\n+    }\n+               \n+    /** \n+      * Answers whether there are any mappings\n+      */\n+    public boolean isEmpty() {\n+        return getMap().isEmpty();\n+    }\n+    \n+    /** \n+      * Answers whether this map and the argument are 'the same' \n+      */\n+    public boolean equals( final Object object ) {\n+        return getMap().equals( object );\n+    }\n+    \n+    /**\n+      * Returns the number of mappings in this map\n+      */\n+    public int size() {\n+        return getMap().size();\n+    }\n+    \n+    // Inner Classes \n+    // ---------------------------------------------------------------------\n+    \n+    /** \n+     * A map entry, which is backed by this RefHashMap\n+     */\n+    class Entry implements Map.Entry {\n+        \n+        /**\n+         * Constructor\n+         */\n+        public Entry( Object key, Object value ) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        // Map.Entry interface\n+        // -----------------------------------------------------------\n+        \n+        /**\n+         * Retrieves the key of this mapping\n+         */\n+        public Object getKey() {\n+            return key;\n+        }\n+        \n+        /**\n+         * Retrieves the value of this mapping\n+         */\n+        public Object getValue() {\n+           return value;\n+        }\n+        \n+        /**\n+         * Sets the value of this mapping\n+         */\n+        public Object setValue( Object value ) {\n+            this.value = value;\n+            put( key, value ); \n+            return value;\n+        }\n+        \n+        /**\n+         * Return the hash code of this mapping.\n+         * This algorithm was taken from the JavaDoc for Map.Entry\n+         */\n+        public int hashCode() {\n+            return ( getKey() == null ? 0 : getKey().hashCode() ) ^\n+                ( getValue() == null ? 0 : getValue().hashCode() );\n+         }\n+        \n+        /** The domain of this mapping */\n+        private Object key;\n+        /** The range of this mapping */\n+        private Object value;    \n+    }\n+\n+    /**\n+     * Returns a reference to the argument.\n+     * Override this method to make wrapped maps for other Reference types\n+     */\n+    protected Reference createReference( Object referent ) {\n+        return new SoftReference( referent );\n+    }\n+    \n+    /** \n+     * Retrieves the wrapped HashMap\n+     * @return The wrapped HashMap\n+     */\n+    protected Map getMap() {\n+        return hashMap;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/TransformIterator.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** A Proxy {@link Iterator Iterator} which uses a {@link Transformer Transformer} instance to \n+  * transform the contents of the {@link Iterator Iterator} into some other form\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class TransformIterator extends ProxyIterator {\n+    \n+    /** Holds value of property transformer. */\n+    private Transformer transformer;\n+    \n+    \n+    public TransformIterator() {\n+    }\n+    \n+    public TransformIterator( Iterator iterator ) {\n+        super( iterator );\n+    }\n+\n+    public TransformIterator( Iterator iterator, Transformer transformer ) {\n+        super( iterator );\n+        this.transformer = transformer;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+    public Object next() {\n+        return transform( super.next() );\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    /** Getter for property transformer.\n+     * @return Value of property transformer.\n+     */\n+    public Transformer getTransformer() {\n+        return transformer;\n+    }\n+    /** Setter for property transformer.\n+     * @param transformer New value of property transformer.\n+     */\n+    public void setTransformer(Transformer transformer) {\n+        this.transformer = transformer;\n+    }\n+    \n+    // Implementation methods\n+    //-------------------------------------------------------------------------\n+    protected Object transform( Object source ) {\n+        Transformer transformer = getTransformer();\n+        if ( transformer != null ) {\n+            return transformer.transform( source );\n+        }\n+        return source;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/Transformer.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+/** An object capable of transforming an input object into some output object.\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+public interface Transformer {\n+\n+    /** Transforms the input object (leaving it unchanged) into some output object.\n+      * @return the transformation of the input object to the output object\n+      */\n+    public Object transform(Object input);\n+}", "timestamp": 989147065, "metainfo": ""}