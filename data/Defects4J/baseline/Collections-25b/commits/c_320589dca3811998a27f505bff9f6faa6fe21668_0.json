{"sha": "320589dca3811998a27f505bff9f6faa6fe21668", "log": "MultiKey enhancements to add getKey(index) and size() Make protected constructor public Add lots of javadoc examples and warnings   ", "commit": "\n--- a/src/java/org/apache/commons/collections/keyvalue/MultiKey.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/MultiKey.java\n  * maps of maps. An example might be the need to lookup a filename by \n  * key and locale. The typical solution might be nested maps. This class\n  * can be used instead by creating an instance passing in the key and locale.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * // populate map with data mapping key+locale to localizedText\n+ * Map map = new HashMap();\n+ * MultiKey multiKey = new MultiKey(key, locale);\n+ * map.put(multiKey, localizedText);\n+ *\n+ * // later retireve the localized text\n+ * MultiKey multiKey = new MultiKey(key, locale);\n+ * String localizedText = (String) map.get(multiKey);\n+ * </pre>\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2004/02/18 01:00:08 $\n+ * @version $Revision: 1.5 $ $Date: 2004/03/13 12:43:43 $\n  * \n  * @author Howard Lewis Ship\n  * @author Stephen Colebourne\n  */\n public class MultiKey implements Serializable {\n+    // This class could implement List, but that would confuse it's purpose\n \n     /** Serialisation version */\n     private static final long serialVersionUID = 4465448607415788805L;\n     \n     /**\n      * Constructor taking two keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n      * \n      * @param key1  the first key\n      * @param key2  the second key\n     \n     /**\n      * Constructor taking three keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n      * \n      * @param key1  the first key\n      * @param key2  the second key\n     \n     /**\n      * Constructor taking four keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n      * \n      * @param key1  the first key\n      * @param key2  the second key\n     \n     /**\n      * Constructor taking five keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n      * \n      * @param key1  the first key\n      * @param key2  the second key\n     }\n     \n     /**\n-     * Constructor taking an array of keys.\n+     * Constructor taking an array of keys which is cloned.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * <p>\n+     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n      *\n-     * @param keys  the array of keys\n+     * @param keys  the array of keys, not null\n      * @throws IllegalArgumentException if the key array is null\n      */\n     public MultiKey(Object[] keys) {\n     }\n     \n     /**\n-     * Constructor taking an array of keys.\n-     * <p>\n-     * If the array is not copied, then it must not be modified.\n+     * Constructor taking an array of keys, optionally choosing whether to clone.\n+     * <p>\n+     * <b>If the array is not cloned, then it must not be modified.</b>\n+     * <p>\n+     * This method is public for performance reasons only, to avoid a clone.\n+     * The hashcode is calculated once here in this method.\n+     * Therefore, changing the array passed in would not change the hashcode but\n+     * would change the equals method, which is a bug.\n+     * <p>\n+     * This is the only fully safe usage of this constructor, as the object array\n+     * is never made available in a variable:\n+     * <pre>\n+     * new MultiKey(new Object[] {...}, false);\n+     * </pre>\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n      *\n-     * @param keys  the array of keys\n-     * @param makeCopy  true to copy the array, false to assign it\n+     * @param keys  the array of keys, not null\n+     * @param makeClone  true to clone the array, false to assign it\n      * @throws IllegalArgumentException if the key array is null\n-     */\n-    protected MultiKey(Object[] keys, boolean makeCopy) {\n+     * @since Commons Collections 3.1\n+     */\n+    public MultiKey(Object[] keys, boolean makeClone) {\n         super();\n         if (keys == null) {\n             throw new IllegalArgumentException(\"The array of keys must not be null\");\n         }\n-        if (makeCopy) {\n+        if (makeClone) {\n             this.keys = (Object[]) keys.clone();\n         } else {\n             this.keys = keys;\n         int total = 0;\n         for (int i = 0; i < keys.length; i++) {\n             if (keys[i] != null) {\n-                if (i == 0) {\n-                    total = keys[i].hashCode();\n-                } else {\n-                    total ^= keys[i].hashCode();\n-                }\n+                total ^= keys[i].hashCode();\n             }\n         }\n         hashCode = total;\n     }\n     \n-    /**\n-     * Gets a copy of the individual keys.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a clone of the array of keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed.\n      * \n      * @return the individual keys\n      */\n         return (Object[]) keys.clone();\n     }\n     \n+    /**\n+     * Gets the key at the specified index.\n+     * <p>\n+     * The key should be immutable.\n+     * If it is not then it must not be changed.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since Commons Collections 3.1\n+     */\n+    public Object getKey(int index) {\n+        return keys[index];\n+    }\n+    \n+    /**\n+     * Gets the size of the list of keys.\n+     * \n+     * @return the size of the list of keys\n+     * @since Commons Collections 3.1\n+     */\n+    public int size() {\n+        return keys.length;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n     /**\n      * Compares this object to another.\n      * <p>\n--- a/src/test/org/apache/commons/collections/keyvalue/TestMultiKey.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/TestMultiKey.java\n /**\n  * Unit tests for {@link org.apache.commons.collections.MultiKey}.\n  * \n- * @version $Revision: 1.3 $ $Date: 2004/02/18 01:20:40 $\n+ * @version $Revision: 1.4 $ $Date: 2004/03/13 12:43:43 $\n  * \n  * @author Stephen Colebourne\n  */\n         super.tearDown();\n     }\n     \n-\n-    public void testConstructorsAndGet() throws Exception {\n+    //-----------------------------------------------------------------------\n+    public void testConstructors() throws Exception {\n         MultiKey mk = null;\n         mk = new MultiKey(ONE, TWO);\n         Assert.assertTrue(Arrays.equals(new Object[] {ONE, TWO}, mk.getKeys()));\n \n         mk = new MultiKey(new Object[] {THREE, FOUR, ONE, TWO}, false);\n         Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, TWO}, mk.getKeys()));\n-\n-        // don't do this!\n+    }\n+    \n+    public void testConstructorsByArray() throws Exception {\n+        MultiKey mk = null;\n         Object[] keys = new Object[] {THREE, FOUR, ONE, TWO};\n         mk = new MultiKey(keys);\n         Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, TWO}, mk.getKeys()));\n         keys[3] = FIVE;  // no effect\n         Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, TWO}, mk.getKeys()));\n+\n+        keys = new Object[] {};\n+        mk = new MultiKey(keys);\n+        Assert.assertTrue(Arrays.equals(new Object[] {}, mk.getKeys()));\n+\n+        keys = new Object[] {THREE, FOUR, ONE, TWO};\n+        mk = new MultiKey(keys, true);\n+        Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, TWO}, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, TWO}, mk.getKeys()));\n+\n+        keys = new Object[] {THREE, FOUR, ONE, TWO};\n+        mk = new MultiKey(keys, false);\n+        Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, TWO}, mk.getKeys()));\n+        // change key - don't do this!\n+        // the hashcode of the MultiKey is now broken\n+        keys[3] = FIVE;\n+        Assert.assertTrue(Arrays.equals(new Object[] {THREE, FOUR, ONE, FIVE}, mk.getKeys()));\n+    }        \n+    \n+    public void testConstructorsByArrayNull() throws Exception {\n+        Object[] keys = null;\n+        try {\n+            new MultiKey(keys);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey(keys, true);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey(keys, false);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testSize() {\n+        Assert.assertEquals(2, new MultiKey(ONE, TWO).size());\n+        Assert.assertEquals(2, new MultiKey(null, null).size());\n+        Assert.assertEquals(3, new MultiKey(ONE, TWO, THREE).size());\n+        Assert.assertEquals(3, new MultiKey(null, null, null).size());\n+        Assert.assertEquals(4, new MultiKey(ONE, TWO, THREE, FOUR).size());\n+        Assert.assertEquals(4, new MultiKey(null, null, null, null).size());\n+        Assert.assertEquals(5, new MultiKey(ONE, TWO, THREE, FOUR, FIVE).size());\n+        Assert.assertEquals(5, new MultiKey(null, null, null, null, null).size());\n+        \n+        Assert.assertEquals(0, new MultiKey(new Object[] {}).size());\n+        Assert.assertEquals(1, new MultiKey(new Object[] {ONE}).size());\n+        Assert.assertEquals(2, new MultiKey(new Object[] {ONE, TWO}).size());\n+        Assert.assertEquals(7, new MultiKey(new Object[] {ONE, TWO, ONE, TWO, ONE, TWO, ONE}).size());\n+    }\n+    \n+    public void testGetIndexed() {\n+        MultiKey mk = new MultiKey(ONE, TWO);\n+        Assert.assertSame(ONE, mk.getKey(0));\n+        Assert.assertSame(TWO, mk.getKey(1));\n+        try {\n+            mk.getKey(-1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            mk.getKey(2);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+    \n+    public void testGetKeysSimpleConstructor() {\n+        MultiKey mk = new MultiKey(ONE, TWO);\n+        Object[] array = mk.getKeys();\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+    \n+    public void testGetKeysArrayConstructorCloned() {\n+        Object[] keys = new Object[] {ONE, TWO};\n+        MultiKey mk = new MultiKey(keys, true);\n+        Object[] array = mk.getKeys();\n+        Assert.assertTrue(array != keys);\n+        Assert.assertTrue(Arrays.equals(array, keys));\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+    \n+    public void testGetKeysArrayConstructorNonCloned() {\n+        Object[] keys = new Object[] {ONE, TWO};\n+        MultiKey mk = new MultiKey(keys, false);\n+        Object[] array = mk.getKeys();\n+        Assert.assertTrue(array != keys);  // still not equal\n+        Assert.assertTrue(Arrays.equals(array, keys));\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n     }\n     \n     public void testHashCode() {\n         Assert.assertTrue(mk1.hashCode() == mk1.hashCode());\n         Assert.assertTrue(mk1.hashCode() == mk2.hashCode());\n         Assert.assertTrue(mk1.hashCode() != mk3.hashCode());\n+        \n+        int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();\n+        Assert.assertEquals(total, mk1.hashCode());\n     }\n     \n     public void testEquals() {", "timestamp": 1079181823, "metainfo": ""}