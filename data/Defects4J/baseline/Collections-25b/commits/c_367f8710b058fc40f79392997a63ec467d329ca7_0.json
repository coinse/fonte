{"sha": "367f8710b058fc40f79392997a63ec467d329ca7", "log": "Make ListOrderedMap implement OrderedMap Improve associated tests   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.1 2003/11/16 00:05:45 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.2 2003/11/20 00:03:05 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n \n import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n-import org.apache.commons.collections.iterators.EntrySetMapIterator;\n import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.iterators.OrderedMapIterator;\n+import org.apache.commons.collections.iterators.ResettableIterator;\n import org.apache.commons.collections.pairs.AbstractMapEntry;\n \n /**\n  * <p>\n  * The order will be used via the iterators and toArray methods on the views.\n  * The order is also returned by the <code>MapIterator</code>.\n+ * The <code>orderedMapIterator()</code> method accesses an iterator that can\n+ * iterate both forwards and backwards through the map.\n  * <p>\n  * If an object is added to the Map for a second time, it will remain in the\n  * original position in the iteration.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/11/16 00:05:45 $\n+ * @version $Revision: 1.2 $ $Date: 2003/11/20 00:03:05 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n  */\n-public class ListOrderedMap extends AbstractMapDecorator implements Map {\n+public class ListOrderedMap extends AbstractMapDecorator implements OrderedMap {\n \n     /** Internal list to hold the sequence of objects */\n     protected final List insertOrder = new ArrayList();\n     protected ListOrderedMap(Map map) {\n         super(map);\n         insertOrder.addAll(getMap().keySet());\n+    }\n+\n+    // Implement OrderedMap\n+    //-----------------------------------------------------------------------\n+    public MapIterator mapIterator() {\n+        return orderedMapIterator();\n+    }\n+\n+    public OrderedMapIterator orderedMapIterator() {\n+        return new ListOrderedMapIterator(this);\n+    }\n+\n+    /**\n+     * Gets the first key in this map by insert order.\n+     *\n+     * @return the first key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object firstKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return insertOrder.get(0);\n+    }\n+\n+    /**\n+     * Gets the last key in this map by insert order.\n+     *\n+     * @return the last key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object lastKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return insertOrder.get(size() - 1);\n+    }\n+    \n+    /**\n+     * Gets the next key to the one specified using insert order.\n+     * This method performs a list search to find the key and is O(n).\n+     * \n+     * @param key  the key to find previous for\n+     * @return the next key, null if no match or at start\n+     */\n+    public Object nextKey(Object key) {\n+        int index = insertOrder.indexOf(key);\n+        if (index >= 0 && index < size() - 1) {\n+            return insertOrder.get(index + 1);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous key to the one specified using insert order.\n+     * This method performs a list search to find the key and is O(n).\n+     * \n+     * @param key  the key to find previous for\n+     * @return the previous key, null if no match or at start\n+     */\n+    public Object previousKey(Object key) {\n+        int index = insertOrder.indexOf(key);\n+        if (index > 0) {\n+            return insertOrder.get(index - 1);\n+        }\n+        return null;\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public MapIterator mapIterator() {\n-        return new EntrySetMapIterator(this);\n-    }\n-    \n     public Set keySet() {\n         return new KeySetView(this);\n     }\n             Map.Entry entry = (Map.Entry) it.next();\n             Object key = entry.getKey();\n             Object value = entry.getValue();\n-            buf.append(key == this ? \"(this Map)\" : key);\n-            buf.append('=');\n-            buf.append(value == this ? \"(this Map)\" : value);\n             if (first) {\n                 first = false;\n             } else {\n                 buf.append(\", \");\n             }\n+            buf.append(key == this ? \"(this Map)\" : key);\n+            buf.append('=');\n+            buf.append(value == this ? \"(this Map)\" : value);\n         }\n         buf.append('}');\n         return buf.toString();\n         }\n         \n         public Iterator iterator() {\n-            return new OrderedIterator(parent, insertOrder);\n+            return new ListOrderedIterator(parent, insertOrder);\n         }\n     }\n     \n-    static class OrderedIterator extends AbstractIteratorDecorator {\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedIterator extends AbstractIteratorDecorator {\n         private final ListOrderedMap parent;\n         private Object last = null;\n         \n-        OrderedIterator(ListOrderedMap parent, List insertOrder) {\n+        ListOrderedIterator(ListOrderedMap parent, List insertOrder) {\n             super(insertOrder.iterator());\n             this.parent = parent;\n         }\n         \n         public Object next() {\n             last = super.next();\n-            return new OrderedMapEntry(parent, last);\n+            return new ListOrderedMapEntry(parent, last);\n         }\n \n         public void remove() {\n         }\n     }\n     \n-    static class OrderedMapEntry extends AbstractMapEntry {\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapEntry extends AbstractMapEntry {\n         private final ListOrderedMap parent;\n         \n-        OrderedMapEntry(ListOrderedMap parent, Object key) {\n+        ListOrderedMapEntry(ListOrderedMap parent, Object key) {\n             super(key, null);\n             this.parent = parent;\n         }\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapIterator implements OrderedMapIterator, ResettableIterator {\n+        private final ListOrderedMap parent;\n+        private ListIterator iterator;\n+        private Object last = null;\n+        private boolean readable = false;\n+        \n+        ListOrderedMapIterator(ListOrderedMap parent) {\n+            super();\n+            this.parent = parent;\n+            this.iterator = parent.insertOrder.listIterator();\n+        }\n+        \n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+        \n+        public Object next() {\n+            last = iterator.next();\n+            readable = true;\n+            return last;\n+        }\n+        \n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+        \n+        public Object previous() {\n+            last = iterator.previous();\n+            readable = true;\n+            return last;\n+        }\n+        \n+        public void remove() {\n+            if (readable == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called after next() and before remove()\");\n+            }\n+            iterator.remove();\n+            parent.map.remove(last);\n+            readable = false;\n+        }\n+        \n+        public Object getKey() {\n+            if (readable == false) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last;\n+        }\n+\n+        public Object getValue() {\n+            if (readable == false) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return parent.get(last);\n+        }\n+        \n+        public Object setValue(Object value) {\n+            if (readable == false) {\n+                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            return parent.map.put(last, value);\n+        }\n+        \n+        public void reset() {\n+            iterator = parent.insertOrder.listIterator();\n+            last = null;\n+            readable = false;\n+        }\n+        \n+        public String toString() {\n+            if (readable == true) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            } else {\n+                return \"MapIterator[]\";\n+            }\n+        }\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java,v 1.4 2003/11/18 22:37:14 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java,v 1.5 2003/11/20 00:03:05 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * overriding the supportsXxx() methods if necessary.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/11/18 22:37:14 $\n+ * @version $Revision: 1.5 $ $Date: 2003/11/20 00:03:05 $\n  * \n  * @author Stephen Colebourne\n  */\n         assertSame(\"Key must not change after setValue\", key, it.getKey());\n         assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n         assertSame(\"setValue must return old value\", value, old);\n+        assertEquals(\"Map must contain key\", true, map.containsKey(key));\n+        assertEquals(\"Map must not contain old value\", false, map.containsValue(old));\n+        assertEquals(\"Map must contain old value\", true, map.containsValue(newValue));\n         verify();\n         \n         it.setValue(newValue);  // same value - should be OK\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestOrderedMapIterator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/AbstractTestOrderedMapIterator.java,v 1.1 2003/11/20 00:03:05 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * Abstract class for testing the OrderedMapIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of MapIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/20 00:03:05 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestOrderedMapIterator extends AbstractTestMapIterator {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestOrderedMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    public void testEmptyMapIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        super.testEmptyMapIterator();\n+        \n+        OrderedMapIterator it = (OrderedMapIterator) makeEmptyMapIterator();\n+        Map map = getMap();\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the full list iterator contract is correct.\n+     */\n+    public void testFullMapIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        super.testFullMapIterator();\n+        \n+        OrderedMapIterator it = (OrderedMapIterator) makeFullMapIterator();\n+        Map map = getMap();\n+        \n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        Set set = new HashSet();\n+        while (it.hasNext()) {\n+            // getKey\n+            Object key = it.next();\n+            assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.add(key));\n+            \n+            // getValue\n+            Object value = it.getValue();\n+            assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+            assertSame(\"Value must be mapped to key\", map.get(key), value);\n+\n+            assertEquals(true, it.hasPrevious());\n+            \n+            verify();\n+        }\n+        while (it.hasPrevious()) {\n+            // getKey\n+            Object key = it.previous();\n+            assertSame(\"it.previous() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.remove(key));\n+            \n+            // getValue\n+            Object value = it.getValue();\n+            assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+            assertSame(\"Value must be mapped to key\", map.get(key), value);\n+\n+            assertEquals(true, it.hasNext());\n+            \n+            verify();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the iterator order matches the keySet order.\n+     */\n+    public void testMapIteratorOrder() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        OrderedMapIterator it = (OrderedMapIterator) makeFullMapIterator();\n+        Map map = getMap();\n+        \n+        assertEquals(\"keySet() not consistent\", new ArrayList(map.keySet()), new ArrayList(map.keySet()));\n+        \n+        Iterator it2 = map.keySet().iterator();\n+        assertEquals(true, it.hasNext());\n+        assertEquals(true, it2.hasNext());\n+        List list = new ArrayList();\n+        while (it.hasNext()) {\n+            Object key = it.next();\n+            assertEquals(it2.next(), key);\n+            list.add(key);\n+        }\n+        while (it.hasPrevious()) {\n+            Object key = it.previous();\n+            assertEquals(list.get(list.size() - 1), key);\n+            list.remove(list.size() - 1);\n+        }\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestListOrderedMap.java,v 1.3 2003/11/18 22:37:17 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestListOrderedMap.java,v 1.4 2003/11/20 00:03:06 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.Test;\n \n import org.apache.commons.collections.BulkTest;\n-import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+import org.apache.commons.collections.iterators.AbstractTestOrderedMapIterator;\n import org.apache.commons.collections.iterators.MapIterator;\n \n /**\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/11/18 22:37:17 $\n+ * @version $Revision: 1.4 $ $Date: 2003/11/20 00:03:06 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n \n     //-----------------------------------------------------------------------\n     public BulkTest bulkTestMapIterator() {\n-        return new TestOrderedMapIterator();\n+        return new TestListOrderedMapIterator();\n     }\n     \n-    public class TestOrderedMapIterator extends AbstractTestMapIterator {\n-        public TestOrderedMapIterator() {\n-            super(\"TestOrderedMapIterator\");\n+    // TODO: Test mapIterator() and orderedMapIterator() separately\n+    public class TestListOrderedMapIterator extends AbstractTestOrderedMapIterator {\n+        public TestListOrderedMapIterator() {\n+            super(\"TestListOrderedMapIterator\");\n         }\n         \n         public boolean supportsRemove() {\n         }\n     }\n     \n-    //-----------------------------------------------------------------------\n-    public void testMapIteratorRemove() {\n-        resetFull();\n-        ListOrderedMap testMap = (ListOrderedMap) map;\n-        MapIterator it = testMap.mapIterator();\n-        assertEquals(true, it.hasNext());\n-        Object key = it.next();\n-        \n-        if (isRemoveSupported() == false) {\n-            try {\n-                it.remove();\n-                fail();\n-            } catch (UnsupportedOperationException ex) {\n-            }\n-            return;\n-        }\n-        \n-        it.remove();\n-        confirmed.remove(key);\n-        assertEquals(false, testMap.containsKey(key));\n-        verify();\n-        \n-        try {\n-            it.remove();  // second remove fails\n-        } catch (IllegalStateException ex) {\n-        }\n-        verify();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testMapIteratorSet() {\n-        Object newValue1 = getOtherValues()[0];\n-        Object newValue2 = getOtherValues()[1];\n-        \n-        resetFull();\n-        ListOrderedMap testMap = (ListOrderedMap) map;\n-        MapIterator it = testMap.mapIterator();\n-        assertEquals(true, it.hasNext());\n-        Object key1 = it.next();\n-        \n-        if (isSetValueSupported() == false) {\n-            try {\n-                it.setValue(newValue1);\n-                fail();\n-            } catch (UnsupportedOperationException ex) {\n-            }\n-            return;\n-        }\n-        \n-        it.setValue(newValue1);\n-        confirmed.put(key1, newValue1);\n-        assertSame(key1, it.getKey());\n-        assertSame(newValue1, it.getValue());\n-        assertEquals(true, testMap.containsKey(key1));\n-        assertEquals(true, testMap.containsValue(newValue1));\n-        assertEquals(newValue1, testMap.get(key1));\n-        verify();\n-        \n-        it.setValue(newValue1);  // same value - should be OK\n-        confirmed.put(key1, newValue1);\n-        assertSame(key1, it.getKey());\n-        assertSame(newValue1, it.getValue());\n-        assertEquals(true, testMap.containsKey(key1));\n-        assertEquals(true, testMap.containsValue(newValue1));\n-        assertEquals(newValue1, testMap.get(key1));\n-        verify();\n-        \n-        Object key2 = it.next();\n-        it.setValue(newValue2);\n-        confirmed.put(key2, newValue2);\n-        assertSame(key2, it.getKey());\n-        assertSame(newValue2, it.getValue());\n-        assertEquals(true, testMap.containsKey(key2));\n-        assertEquals(true, testMap.containsValue(newValue2));\n-        assertEquals(newValue2, testMap.get(key2));\n-        verify();\n-    }\n-\n     //-----------------------------------------------------------------------\n     // Creates a known series of Objects, puts them in \n     // an OrderedMap and ensures that all three Collection ", "timestamp": 1069286586, "metainfo": ""}