{"sha": "39513f9142cb82b84181a11905b3866a49d5a3c0", "log": "[COLLECTIONS-550] Added IterableUtils#toString(...) to newly created IterableUtils class. Thanks to Goncalo Marques. This closes #7.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/IterableUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Iterable} instances.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class IterableUtils {\n+\n+    /**\n+     * Default prefix used while converting an Iterable to its String representation.\n+     */\n+    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n+\n+    /**\n+     * Default suffix used while converting an Iterable to its String representation.\n+     */\n+    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n+\n+    /**\n+     * Default delimiter used to delimit elements while converting an Iterable\n+     * to its String representation.\n+     */\n+    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n+\n+    /**\n+     * Returns a string representation of the elements of the specified iterable.\n+     * The string representation consists of a list of the iterable's elements,\n+     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n+     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n+     * converted to strings as by {@code String.valueOf(Object)}.\n+     *\n+     * @param <C>  the element type\n+     * @param iterable  the iterable to convert to a string\n+     * @return a string representation of {@code iterable}\n+     * @throws IllegalArgumentException if {@code iterable} is null\n+     */\n+    public static <C> String toString(Iterable<C> iterable) {\n+        return toString(iterable, new Transformer<C, String>() {\n+            public String transform(C input) {\n+                return String.valueOf(input);\n+            }\n+        }, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n+    }\n+\n+    /**\n+     * Returns a string representation of the elements of the specified iterable.\n+     * The string representation consists of a list of the iterable's elements,\n+     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n+     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n+     * converted to strings as by using the provided {@code transformer}.\n+     *\n+     * @param <C>  the element type\n+     * @param iterable  the iterable to convert to a string\n+     * @param transformer  the transformer used to get a string representation of an element\n+     * @return a string representation of {@code iterable}\n+     * @throws IllegalArgumentException if {@code iterable} or {@code transformer} is null\n+     */\n+    public static <C> String toString(Iterable<C> iterable, Transformer<? super C, String> transformer) {\n+        return toString(iterable, transformer, DEFAULT_TOSTRING_DELIMITER,\n+                        DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n+    }\n+\n+    /**\n+     * Returns a string representation of the elements of the specified iterable.\n+     * The string representation consists of a list of the iterable's elements,\n+     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n+     * are separated by the provided {@code delimiter}. Elements are converted to\n+     * strings as by using the provided {@code transformer}.\n+     *\n+     * @param <C>  the element type\n+     * @param iterable  the iterable to convert to a string\n+     * @param transformer  the transformer used to get a string representation of an element\n+     * @param delimiter  the string to delimit elements\n+     * @param prefix  the prefix, prepended to the string representation\n+     * @param suffix  the suffix, appended to the string representation\n+     * @return a string representation of {@code iterable}\n+     * @throws IllegalArgumentException if any argument is null\n+     */\n+    public static <C> String toString(Iterable<C> iterable,\n+                                      Transformer<? super C, String> transformer,\n+                                      String delimiter,\n+                                      String prefix,\n+                                      String suffix) {\n+        if (iterable == null) {\n+            throw new IllegalArgumentException(\"iterable may not be null\");\n+        }\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"transformer may not be null\");\n+        }\n+        if (delimiter == null) {\n+            throw new IllegalArgumentException(\"delimiter may not be null\");\n+        }\n+        if (prefix == null) {\n+            throw new IllegalArgumentException(\"prefix may not be null\");\n+        }\n+        if (suffix == null) {\n+            throw new IllegalArgumentException(\"suffix may not be null\");\n+        }\n+        final StringBuilder stringBuilder = new StringBuilder(prefix);\n+        for(final C element : iterable) {\n+            stringBuilder.append(transformer.transform(element));\n+            stringBuilder.append(delimiter);\n+        }\n+        if(stringBuilder.length() > prefix.length()) {\n+            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n+        }\n+        stringBuilder.append(suffix);\n+        return stringBuilder.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Tests for IterableUtils.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class IterableUtilsTest extends BulkTest {\n+\n+    /**\n+     * Iterable of {@link Integer}s\n+     */\n+    private Iterable<Integer> iterableA = null;\n+    \n+    public IterableUtilsTest(final String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(IterableUtilsTest.class);\n+    }\n+    \n+    @Override\n+    public void setUp() {\n+        List<Integer> listA = new ArrayList<Integer>();\n+        listA.add(1);\n+        listA.add(2);\n+        listA.add(2);\n+        listA.add(3);\n+        listA.add(3);\n+        listA.add(3);\n+        listA.add(4);\n+        listA.add(4);\n+        listA.add(4);\n+        listA.add(4);\n+        iterableA = listA;\n+    }\n+    \n+    public void testToString() {\n+        String result = IterableUtils.toString(iterableA);\n+        assertEquals(\"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\", result);\n+        \n+        result = IterableUtils.toString(new ArrayList<Integer>());\n+        assertEquals(\"[]\", result);\n+\n+        try {\n+            IterableUtils.toString(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+\n+        result = IterableUtils.toString(iterableA, new Transformer<Integer, String>() {\n+            public String transform(Integer input) {\n+                return new Integer(input * 2).toString();\n+            }\n+        });\n+        assertEquals(\"[2, 4, 4, 6, 6, 6, 8, 8, 8, 8]\", result);\n+\n+        result = IterableUtils.toString(new ArrayList<Integer>(), new Transformer<Integer, String>() {\n+            public String transform(Integer input) {\n+                fail(\"not supposed to reach here\");\n+                return \"\";\n+            }\n+        });\n+        assertEquals(\"[]\", result);\n+\n+        try {\n+            IterableUtils.toString(null, new Transformer<Integer, String>() {\n+                public String transform(Integer input) {\n+                    fail(\"not supposed to reach here\");\n+                    return \"\";\n+                }\n+            });\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testToStringDelimiter() {\n+        \n+        Transformer<Integer, String> transformer = new Transformer<Integer, String>() {\n+            public String transform(Integer input) {\n+                return new Integer(input * 2).toString();\n+            }\n+        };\n+        \n+        String result = IterableUtils.toString(iterableA, transformer, \"\", \"\", \"\");\n+        assertEquals(\"2446668888\", result);\n+        \n+        result = IterableUtils.toString(iterableA, transformer, \",\", \"\", \"\");\n+        assertEquals(\"2,4,4,6,6,6,8,8,8,8\", result);\n+        \n+        result = IterableUtils.toString(iterableA, transformer, \"\", \"[\", \"]\");\n+        assertEquals(\"[2446668888]\", result);\n+        \n+        result = IterableUtils.toString(iterableA, transformer, \",\", \"[\", \"]\");\n+        assertEquals(\"[2,4,4,6,6,6,8,8,8,8]\", result);\n+        \n+        result = IterableUtils.toString(iterableA, transformer, \",\", \"[[\", \"]]\");\n+        assertEquals(\"[[2,4,4,6,6,6,8,8,8,8]]\", result);\n+        \n+        result = IterableUtils.toString(iterableA, transformer, \",,\", \"[\", \"]\");\n+        assertEquals(\"[2,,4,,4,,6,,6,,6,,8,,8,,8,,8]\", result);\n+        \n+        result = IterableUtils.toString(iterableA, transformer, \",,\", \"((\", \"))\");\n+        assertEquals(\"((2,,4,,4,,6,,6,,6,,8,,8,,8,,8))\", result);\n+\n+        result = IterableUtils.toString(new ArrayList<Integer>(), transformer, \"\", \"(\", \")\");\n+        assertEquals(\"()\", result);\n+        \n+        result = IterableUtils.toString(new ArrayList<Integer>(), transformer, \"\", \"\", \"\");\n+        assertEquals(\"\", result);\n+    }\n+    \n+    public void testToStringWithNullArguments() {\n+        try {\n+            IterableUtils.toString(null, new Transformer<Integer, String>() {\n+                public String transform(Integer input) {\n+                    fail(\"not supposed to reach here\");\n+                    return \"\";\n+                }\n+            }, \"\", \"(\", \")\");\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+\n+        try {\n+            IterableUtils.toString(new ArrayList<Integer>(), null, \"\", \"(\", \")\");\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+\n+        try {\n+            IterableUtils.toString(new ArrayList<Integer>(), new Transformer<Integer, String>() {\n+                public String transform(Integer input) {\n+                    fail(\"not supposed to reach here\");\n+                    return \"\";\n+                }\n+            }, null, \"(\", \")\");\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+\n+        try {\n+            IterableUtils.toString(new ArrayList<Integer>(), new Transformer<Integer, String>() {\n+                public String transform(Integer input) {\n+                    fail(\"not supposed to reach here\");\n+                    return \"\";\n+                }\n+            }, \"\", null, \")\");\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+\n+        try {\n+            IterableUtils.toString(new ArrayList<Integer>(), new Transformer<Integer, String>() {\n+                public String transform(Integer input) {\n+                    fail(\"not supposed to reach here\");\n+                    return \"\";\n+                }\n+            }, \"\", \"(\", null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1422918632, "metainfo": ""}