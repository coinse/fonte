{"sha": "84f48d54e1ef49c9dac532e30ce04785bd6f70e0", "log": "Refactor functors from inner classes to subpackage   ", "commit": "\n--- a/src/java/org/apache/commons/collections/TransformerUtils.java\n+++ b/src/java/org/apache/commons/collections/TransformerUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TransformerUtils.java,v 1.8 2003/11/23 17:48:20 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TransformerUtils.java,v 1.9 2003/11/23 23:25:33 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n-import java.io.Serializable;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n \n+import org.apache.commons.collections.functors.ChainedTransformer;\n+import org.apache.commons.collections.functors.CloneTransformer;\n+import org.apache.commons.collections.functors.ClosureTransformer;\n+import org.apache.commons.collections.functors.ConstantTransformer;\n import org.apache.commons.collections.functors.ExceptionTransformer;\n-import org.apache.commons.collections.functors.FunctorException;\n+import org.apache.commons.collections.functors.FactoryTransformer;\n+import org.apache.commons.collections.functors.InstantiateTransformer;\n+import org.apache.commons.collections.functors.InvokerTransformer;\n+import org.apache.commons.collections.functors.MapTransformer;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.functors.PredicateTransformer;\n+import org.apache.commons.collections.functors.StringValueTransformer;\n+import org.apache.commons.collections.functors.SwitchTransformer;\n \n /**\n  * <code>TransformerUtils</code> provides reference implementations and \n  * All the supplied transformers are Serializable.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.8 $ $Date: 2003/11/23 17:48:20 $\n+ * @version $Revision: 1.9 $ $Date: 2003/11/23 23:25:33 $\n  * \n  * @author Stephen Colebourne\n  * @author James Carman\n public class TransformerUtils {\n \n     /**\n-     * A transformer that always returns null\n-     */\n-    private static final Transformer NULL_TRANSFORMER = new ConstantTransformer(null);\n-    /**\n-     * A transformer that returns the input object\n-     */\n-    private static final Transformer NOP_TRANSFORMER = new NOPTransformer();\n-    /**\n-     * A transformer that clones the input object\n-     */\n-    private static final Transformer CLONE_TRANSFORMER = new CloneTransformer();\n-    /**\n-     * A transformer that creates an object from a Class\n-     */\n-    private static final Transformer INSTANTIATE_TRANSFORMER = new InstantiateTransformer(null, null);\n-\n-    /**\n-     * A transformer that returns a <code>java.lang.String</code> representation\n-     * of the input object.\n-     */\n-    private static final Transformer STRING_VALUE_TRANSFORMER = new StringValueTransformer();\n-    \n-    /**\n      * This class is not normally instantiated.\n      */\n     public TransformerUtils() {\n      * @return the transformer\n      */\n     public static Transformer nullTransformer() {\n-        return NULL_TRANSFORMER;\n+        return ConstantTransformer.NULL_INSTANCE;\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static Transformer nopTransformer() {\n-        return NOP_TRANSFORMER;\n+        return NOPTransformer.INSTANCE;\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static Transformer cloneTransformer() {\n-        return CLONE_TRANSFORMER;\n+        return CloneTransformer.INSTANCE;\n     }\n \n     /**\n      * @return the transformer.\n      */\n     public static Transformer constantTransformer(Object constantToReturn) {\n-        return new ConstantTransformer(constantToReturn);\n+        return ConstantTransformer.getInstance(constantToReturn);\n     }\n \n     /**\n      * Creates a Transformer that calls a Closure each time the transformer is used.\n      * The transformer returns the input object.\n      *\n-     * @param closure  the closure to run each time in the transformer\n-     * @return the transformer.\n+     * @param closure  the closure to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the closure is null\n      */\n     public static Transformer asTransformer(Closure closure) {\n-        if (closure == null) {\n-            throw new IllegalArgumentException(\"The closure must not be null\");\n-        }\n-        return new ClosureTransformer(closure);\n+        return ClosureTransformer.getInstance(closure);\n     }\n \n     /**\n      * Creates a Transformer that calls a Predicate each time the transformer is used.\n      * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n      *\n-     * @param predicate  the predicate to run each time in the transformer\n-     * @return the transformer.\n+     * @param predicate  the predicate to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the predicate is null\n      */\n     public static Transformer asTransformer(Predicate predicate) {\n-        if (predicate == null) {\n-            throw new IllegalArgumentException(\"The predicate must not be null\");\n-        }\n-        return new PredicateTransformer(predicate);\n+        return PredicateTransformer.getInstance(predicate);\n     }\n \n     /**\n      * Creates a Transformer that calls a Factory each time the transformer is used.\n      * The transformer will return the value returned by the factory.\n      *\n-     * @param factory  the factory to run each time in the transformer\n-     * @return the transformer.\n+     * @param factory  the factory to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the factory is null\n      */\n     public static Transformer asTransformer(Factory factory) {\n-        if (factory == null) {\n-            throw new IllegalArgumentException(\"The factory must not be null\");\n-        }\n-        return new FactoryTransformer(factory);\n+        return FactoryTransformer.getInstance(factory);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either transformer is null\n      */\n     public static Transformer chainedTransformer(Transformer transformer1, Transformer transformer2) {\n-        Transformer[] trs = new Transformer[] {transformer1, transformer2};\n-        validate(trs);\n-        return new ChainedTransformer(trs);\n+        return ChainedTransformer.getInstance(transformer1, transformer2);\n     }\n \n     /**\n      * @param transformers  an array of transformers to chain\n      * @return the transformer\n      * @throws IllegalArgumentException if the transformers array is null\n-     * @throws IllegalArgumentException if the transformers array has 0 elements\n      * @throws IllegalArgumentException if any transformer in the array is null\n      */\n     public static Transformer chainedTransformer(Transformer[] transformers) {\n-        Transformer[] trs = copy(transformers);\n-        validate(trs);\n-        return new ChainedTransformer(trs);\n+        return ChainedTransformer.getInstance(transformers);\n     }\n \n     /**\n      * @param transformers  a collection of transformers to chain\n      * @return the transformer\n      * @throws IllegalArgumentException if the transformers collection is null\n-     * @throws IllegalArgumentException if the transformers collection is empty\n      * @throws IllegalArgumentException if any transformer in the collection is null\n      */\n     public static Transformer chainedTransformer(Collection transformers) {\n-        Transformer[] trs = null;\n-        if (transformers == null) {\n-            throw new IllegalArgumentException(\"The transformer collection must not be null\");\n-        }\n-        // convert to array like this to guarantee iterator() ordering\n-        trs = new Transformer[transformers.size()];\n-        int i = 0;\n-        for (Iterator it = transformers.iterator(); it.hasNext();) {\n-            trs[i++] = (Transformer) it.next();\n-        }\n-        validate(trs);\n-        return new ChainedTransformer(trs);\n+        return ChainedTransformer.getInstance(transformers);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either transformer is null\n      */\n     public static Transformer switchTransformer(Predicate predicate, Transformer trueTransformer, Transformer falseTransformer) {\n-        return switchTransformerInternal(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n+        return SwitchTransformer.getInstance(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static Transformer switchTransformer(Predicate[] predicates, Transformer[] transformers) {\n-        return switchTransformerInternal(copy(predicates), copy(transformers), null);\n+        return SwitchTransformer.getInstance(predicates, transformers, null);\n     }\n \n     /**\n      * on the predicates. The transformer at array location 0 is called if the\n      * predicate at array location 0 returned true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n-     * transformer is called.\n+     * transformer is called. If the default transformer is null, null is returned.\n      * \n      * @param predicates  an array of predicates to check\n      * @param transformers  an array of transformers to call\n-     * @param defaultTransformer  the default to call if no predicate matches\n+     * @param defaultTransformer  the default to call if no predicate matches, null means return null\n      * @return the transformer\n      * @throws IllegalArgumentException if the either array is null\n      * @throws IllegalArgumentException if the either array has 0 elements\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static Transformer switchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n-        return switchTransformerInternal(copy(predicates), copy(transformers), defaultTransformer);\n+        return SwitchTransformer.getInstance(predicates, transformers, defaultTransformer);\n     }\n \n     /**\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     public static Transformer switchTransformer(Map predicatesAndTransformers) {\n-        Transformer[] trs = null;\n-        Predicate[] preds = null;\n-        if (predicatesAndTransformers == null) {\n-            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n-        }\n-        // convert to array like this to guarantee iterator() ordering\n-        Transformer def = (Transformer) predicatesAndTransformers.remove(null);\n-        int size = predicatesAndTransformers.size();\n-        trs = new Transformer[size];\n-        preds = new Predicate[size];\n-        int i = 0;\n-        for (Iterator it = predicatesAndTransformers.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            preds[i] = (Predicate) entry.getKey();\n-            trs[i] = (Transformer) entry.getValue();\n-            i++;\n-        }\n-        return switchTransformerInternal(preds, trs, def);\n-    }\n-\n-    /**\n-     * Validate input and create transformer\n-     */\n-    private static Transformer switchTransformerInternal(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n-        validate(predicates);\n-        validate(transformers);\n-        if (predicates.length != transformers.length) {\n-            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n-        }\n-        if (defaultTransformer == null) {\n-            defaultTransformer = nullTransformer();\n-        }\n-        return new SwitchTransformer(predicates, transformers, defaultTransformer);\n-    }\n-    \n+        return SwitchTransformer.getInstance(predicatesAndTransformers);\n+    }\n+\n     /**\n      * Create a new Transformer that uses the input object as a key to find the\n      * transformer to call. \n      * @return the transformer\n      */\n     public static Transformer instantiateTransformer() {\n-        return INSTANTIATE_TRANSFORMER;\n+        return InstantiateTransformer.NO_ARG_INSTANCE;\n     }\n \n     /** \n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static Transformer instantiateTransformer(Class[] paramTypes, Object[] args) {\n-        return new InstantiateTransformer(paramTypes, args);\n+        return InstantiateTransformer.getInstance(paramTypes, args);\n     }\n \n     /** \n      * @throws IllegalArgumentException if the map is null\n      */\n     public static Transformer mapTransformer(Map map) {\n-        if (map == null) {\n-            throw new IllegalArgumentException(\"The map must not be null\");\n-        }\n-        return new MapTransformer(map);\n+        return MapTransformer.getInstance(map);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the methodName is null.\n      */\n     public static Transformer invokerTransformer(String methodName){\n-        return new InvokerTransformer(methodName, null, null);\n+        return InvokerTransformer.getInstance(methodName, null, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static Transformer invokerTransformer(String methodName, Class[] paramTypes, Object[] args){\n-        return new InvokerTransformer(methodName, paramTypes, args);\n+        return InvokerTransformer.getInstance(methodName, paramTypes, args);\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static Transformer stringValueTransformer() {\n-        return STRING_VALUE_TRANSFORMER;\n+        return StringValueTransformer.INSTANCE;\n     }\n     \n-    /**\n-     * Copy method\n-     * \n-     * @param predicates  the predicates to copy\n-     */\n-    private static Predicate[] copy(Predicate[] predicates) {\n-        if (predicates == null) {\n-            return null;\n-        }\n-        return (Predicate[]) predicates.clone();\n-    }\n-    \n-    /**\n-     * Validate method\n-     * \n-     * @param predicates  the predicates to validate\n-     */\n-    private static void validate(Predicate[] predicates) {\n-        if (predicates == null) {\n-            throw new IllegalArgumentException(\"The predicate array must not be null\");\n-        }\n-        if (predicates.length < 1) {\n-            throw new IllegalArgumentException(\n-                \"At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n-        }\n-        for (int i = 0; i < predicates.length; i++) {\n-            if (predicates[i] == null) {\n-                throw new IllegalArgumentException(\n-                    \"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Copy method\n-     * \n-     * @param transformers  the transformers to copy\n-     */\n-    private static Transformer[] copy(Transformer[] transformers) {\n-        if (transformers == null) {\n-            return null;\n-        }\n-        return (Transformer[]) transformers.clone();\n-    }\n-    \n-    /**\n-     * Validate method\n-     * \n-     * @param transformers  the transformers to validate\n-     */\n-    private static void validate(Transformer[] transformers) {\n-        if (transformers == null) {\n-            throw new IllegalArgumentException(\"The transformer array must not be null\");\n-        }\n-        if (transformers.length < 1) {\n-            throw new IllegalArgumentException(\n-                \"At least 1 transformer must be specified in the transformer array, size was \" + transformers.length);\n-        }\n-        for (int i = 0; i < transformers.length; i++) {\n-            if (transformers[i] == null) {\n-                throw new IllegalArgumentException(\n-                    \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n-            }\n-        }\n-    }\n-\n-    // NOPTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * NOPTransformer returns the input object.\n-     */\n-    private static class NOPTransformer implements Transformer, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private NOPTransformer() {\n-            super();\n-        }\n-\n-        /**\n-         * Return the input object\n-         */\n-        public Object transform(Object input) {\n-            return input;\n-        }\n-    }\n-\n-    // CloneTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * CloneTransformer returns a clone of the input object.\n-     */\n-    private static class CloneTransformer implements Transformer, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private CloneTransformer() {\n-            super();\n-        }\n-\n-        /**\n-         * Returns a clone of the input object\n-         */\n-        public Object transform(Object input) {\n-            if (input == null) {\n-                return null;\n-            }\n-            return FactoryUtils.prototypeFactory(input).create();\n-        }\n-    }\n-\n-    // ConstantTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ConstantTransformer returns the same instance each time.\n-     */\n-    private static class ConstantTransformer implements Transformer, Serializable {\n-        /** The constant to return each time */\n-        private final Object iConstant;\n-\n-        /**\n-         * Constructor to store constant.\n-         */\n-        private ConstantTransformer(Object constant) {\n-            super();\n-            iConstant = constant;\n-        }\n-\n-        /**\n-         * Always return constant.\n-         */\n-        public Object transform(Object input) {\n-            return iConstant;\n-        }\n-    }\n-\n-    // ClosureTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ClosureTransformer executes a Closure object.\n-     */\n-    private static class ClosureTransformer implements Transformer, Serializable {\n-        /** The closure to call each time */\n-        private final Closure iClosure;\n-\n-        /**\n-         * Constructor to store closure.\n-         */\n-        private ClosureTransformer(Closure closure) {\n-            super();\n-            iClosure = closure;\n-        }\n-\n-        /**\n-         * Exceute the closure and return the input.\n-         */\n-        public Object transform(Object input) {\n-            iClosure.execute(input);\n-            return input;\n-        }\n-    }\n-\n-    // PredicateTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * PredicateTransformer evaluates a Predicate object.\n-     */\n-    private static class PredicateTransformer implements Transformer, Serializable {\n-        /** The predicate to call each time */\n-        private final Predicate iPredicate;\n-\n-        /**\n-         * Constructor to store predicate.\n-         */\n-        private PredicateTransformer(Predicate predicate) {\n-            super();\n-            iPredicate = predicate;\n-        }\n-\n-        /**\n-         * Evaluate the predicate and return the result as a Boolean.\n-         */\n-        public Object transform(Object input) {\n-            return new Boolean(iPredicate.evaluate(input));\n-        }\n-    }\n-\n-    // FactoryTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * FactoryTransformer returns the result of calling a Factory.\n-     */\n-    private static class FactoryTransformer implements Transformer, Serializable {\n-        /** The factory to call each time */\n-        private final Factory iFactory;\n-\n-        /**\n-         * Constructor to store factory.\n-         */\n-        private FactoryTransformer(Factory factory) {\n-            super();\n-            iFactory = factory;\n-        }\n-\n-        /**\n-         * Return the result of calling the factory.\n-         */\n-        public Object transform(Object input) {\n-            return iFactory.create();\n-        }\n-    }\n-\n-    // ChainedTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ChainedTransformer returns the result of calling a list of transformers.\n-     */\n-    private static class ChainedTransformer implements Transformer, Serializable {\n-        /** The array of transformers to call */\n-        private final Transformer[] iTransformers;\n-\n-        /**\n-         * Constructor to store params.\n-         */\n-        private ChainedTransformer(Transformer[] transformers) {\n-            super();\n-            iTransformers = transformers;\n-        }\n-\n-        /**\n-         * Returns the result of calling a list of transformers.\n-         */\n-        public Object transform(Object object) {\n-            for (int i = 0; i < iTransformers.length; i++) {\n-                object = iTransformers[i].transform(object);\n-            }\n-            return object;\n-        }\n-    }\n-\n-    // SwitchTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * SwitchTransformer returns the result of the transformer whose predicate returns true.\n-     */\n-    private static class SwitchTransformer implements Transformer, Serializable {\n-        /** The array of predicates to switch on */\n-        private final Predicate[] iPredicates;\n-        /** The array of transformers to call */\n-        private final Transformer[] iTransformers;\n-        /** The default transformer called if no predicate matches */\n-        private final Transformer iDefault;\n-\n-        /**\n-         * Constructor to store params.\n-         */\n-        private SwitchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n-            super();\n-            iPredicates = predicates;\n-            iTransformers = transformers;\n-            iDefault = defaultTransformer;\n-        }\n-\n-        /**\n-         * Returns the result of the transformer whose predicate returns true.\n-         */\n-        public Object transform(Object input) {\n-            for (int i = 0; i < iPredicates.length; i++) {\n-                if (iPredicates[i].evaluate(input) == true) {\n-                    return iTransformers[i].transform(input);\n-                }\n-            }\n-            return iDefault.transform(input);\n-        }\n-    }\n-\n-    // InstantiateTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * InstantiateTransformer returns the result of instantiating the input Class object.\n-     */\n-    private static class InstantiateTransformer implements Transformer, Serializable {\n-        /** The array of reflection parameter types */\n-        private final Class[] iParamTypes;\n-        /** The array of reflection arguments */\n-        private final Object[] iArgs;\n-\n-        /**\n-         * Constructor to store params.\n-         */\n-        private InstantiateTransformer(Class[] paramTypes, Object[] args) {\n-            super();\n-            if (((paramTypes == null) && (args != null))\n-                || ((paramTypes != null) && (args == null))\n-                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n-                throw new IllegalArgumentException(\"InstantiateTransformer: The parameter types must match the arguments\");\n-            }\n-            if ((paramTypes == null) && (args == null)) {\n-                iParamTypes = null;\n-                iArgs = null;\n-            } else {\n-                iParamTypes = (Class[]) paramTypes.clone();\n-                iArgs = (Object[]) args.clone();\n-            }\n-        }\n-\n-        /**\n-         * Return the result of instantiating the input Class object.\n-         */\n-        public Object transform(Object input) {\n-            try {\n-                if (input instanceof Class == false) {\n-                    throw new FunctorException(\n-                        \"InstantiateTransformer: Input object was not an instanceof Class, it was a \"\n-                            + (input == null ? \"null object\" : input.getClass().getName()));\n-                }\n-                return FactoryUtils.instantiateFactory((Class) input, iParamTypes, iArgs).create();\n-\n-            } catch (IllegalArgumentException ex) {\n-                throw new FunctorException(\"InstantiateTransformer\", ex);\n-            }\n-        }\n-    }\n-\n-    // MapTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * MapTransformer returns the result by looking up in the map.\n-     */\n-    private static class MapTransformer implements Transformer, Serializable {\n-        /** The map of data to lookup in */\n-        private final Map iMap;\n-\n-        /**\n-         * Constructor to store map.\n-         */\n-        private MapTransformer(Map map) {\n-            super();\n-            iMap = map;\n-        }\n-\n-        /**\n-         * Returns the result by looking up in the map.\n-         */\n-        public Object transform(Object input) {\n-            return iMap.get(input);\n-        }\n-    }\n-\n-    // InvokerTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * InvokerTransformer returns the result of invoking the specified method on \n-     * the input object.\n-     */\n-    private static class InvokerTransformer implements Transformer, Serializable {\n-        /** The method name to call */\n-        private final String iMethodName;\n-        /** The array of reflection parameter types */\n-        private final Class[] iParamTypes;\n-        /** The array of reflection arguments */\n-        private final Object[] iArgs;\n-\n-        /**\n-         * Constructor.\n-         */\n-        public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n-            super();\n-            if (methodName == null) {\n-                throw new IllegalArgumentException(\"InvokerTransformer: The method to invoke must not be null\");\n-            }\n-            if (((paramTypes == null) && (args != null))\n-                || ((paramTypes != null) && (args == null))\n-                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n-                throw new IllegalArgumentException(\"InvokerTransformer: The parameter types must match the arguments\");\n-            }\n-\n-            iMethodName = methodName;\n-            if ((paramTypes == null) && (args == null)) {\n-                iParamTypes = null;\n-                iArgs = null;\n-            } else {\n-                iParamTypes = (Class[]) paramTypes.clone();\n-                iArgs = (Object[]) args.clone();\n-            }\n-        }\n-\n-        /**\n-         * Invoke the specified method on the input object.\n-         */\n-        public Object transform(Object input) {\n-            if (input == null) {\n-                return null;\n-            }\n-            try {\n-                Class cls = input.getClass();\n-                Method method = cls.getMethod(iMethodName, iParamTypes);\n-                return method.invoke(input, iArgs);\n-                \n-            } catch (NoSuchMethodException ex) {\n-                throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n-            } catch (IllegalAccessException ex) {\n-                throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n-            } catch (InvocationTargetException ex) {\n-                throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n-            }\n-        }\n-    }\n-    \n-    // StringValueTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * StringValueTransformer returns a <code>java.lang.String</code> representation\n-     * of the input object using the <code>String.valueOf()</code> method.\n-     */\n-    private static class StringValueTransformer implements Transformer, Serializable {\n-        \n-        /**\n-         * returns a <code>java.lang.String</code> representation of the input object \n-         * using the <code>String.valueOf()</code> method.\n-         */\n-        public Object transform(Object input) {\n-            return String.valueOf(input);\n-        }\n-    }\n-\n-}                                                                                                                                                                                                                                                                                                \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ChainedTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ChainedTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that chains the specifed closures together.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ChainedTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 3514945074733160196L;\n+\n+    /** The transformers to call in turn */\n+    private final Transformer[] iTransformers;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter array.\n+     * \n+     * @param transformers  the transformers to chain, copied, no nulls\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if the transformers array is null\n+     * @throws IllegalArgumentException if any transformer in the array is null\n+     */\n+    public static Transformer getInstance(Transformer[] transformers) {\n+        FunctorUtils.validate(transformers);\n+        if (transformers.length == 0) {\n+            return NOPTransformer.INSTANCE;\n+        }\n+        transformers = FunctorUtils.copy(transformers);\n+        return new ChainedTransformer(transformers);\n+    }\n+    \n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param transformers  a collection of transformers to chain\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if the transformers collection is null\n+     * @throws IllegalArgumentException if any transformer in the collection is null\n+     */\n+    public static Transformer getInstance(Collection transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"Transformer collection must not be null\");\n+        }\n+        if (transformers.size() == 0) {\n+            return NOPTransformer.INSTANCE;\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Transformer[] cmds = new Transformer[transformers.size()];\n+        int i = 0;\n+        for (Iterator it = transformers.iterator(); it.hasNext();) {\n+            cmds[i++] = (Transformer) it.next();\n+        }\n+        FunctorUtils.validate(cmds);\n+        return new ChainedTransformer(cmds);\n+    }\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param transformer1  the first transformer, not null\n+     * @param transformer2  the second transformer, not null\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    public static Transformer getInstance(Transformer transformer1, Transformer transformer2) {\n+        if (transformer1 == null || transformer2 == null) {\n+            throw new IllegalArgumentException(\"Transformers must not be null\");\n+        }\n+        Transformer[] transformers = new Transformer[] { transformer1, transformer2 };\n+        return new ChainedTransformer(transformers);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param transformers  the transformers to chain, not copied, no nulls\n+     */\n+    public ChainedTransformer(Transformer[] transformers) {\n+        super();\n+        iTransformers = transformers;\n+    }\n+\n+    /**\n+     * Execute a list of transformers.\n+     * \n+     * @param input  the input object passed to each transformer\n+     */\n+    public Object transform(Object object) {\n+        for (int i = 0; i < iTransformers.length; i++) {\n+            object = iTransformers[i].transform(object);\n+        }\n+        return object;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/CloneTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/CloneTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns a clone of the input object.\n+ * <p>\n+ * Clone is performed using <code>PrototypeFactory.getInstance(input).create()</code>.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class CloneTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = -8188742709499652567L;\n+\n+    /** Singleton predicate instance */    \n+    public static final Transformer INSTANCE = new CloneTransformer();\n+    \n+    /**\n+     * Constructor\n+     */\n+    private CloneTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Do nothing\n+     */\n+    public Object transform(Object input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        return PrototypeFactory.getInstance(input).create();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ClosureTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ClosureTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Closure using the input object\n+ * and then returns the input.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ClosureTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 478466901448617286L;\n+\n+    /** The closure to wrap */\n+    private final Closure iClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param closure  the closure to call, not null\n+     * @return the <code>closure</code> transformer\n+     * @throws IllegalArgumentException if the closure is null\n+     */\n+    public static Transformer getInstance(Closure closure) {\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"Closure must not be null\");\n+        }\n+        return new ClosureTransformer(closure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param closure  the closure to call, not null\n+     */\n+    public ClosureTransformer(Closure closure) {\n+        super();\n+        iClosure = closure;\n+    }\n+\n+    /**\n+     * Call the closure.\n+     */\n+    public Object transform(Object input) {\n+        iClosure.execute(input);\n+        return input;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ConstantTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ConstantTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the same constant each time.\n+ * <p>\n+ * No check is made that the object is immutable. In general, only immutable\n+ * objects should use the constant factory. Mutable objects should\n+ * use the prototype factory.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ConstantTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 6374440726369055124L;\n+    \n+    /** Returns null each time */\n+    public static final Transformer NULL_INSTANCE = new ConstantTransformer(null);\n+\n+    /** The closures to call in turn */\n+    private final Object iConstant;\n+\n+    /**\n+     * Transformer method that performs validation.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    public static Transformer getInstance(Object constantToReturn) {\n+        if (constantToReturn == null) {\n+            return NULL_INSTANCE;\n+        }\n+        return new ConstantTransformer(constantToReturn);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param constantToReturn  the constant to return each time\n+     */\n+    public ConstantTransformer(Object constantToReturn) {\n+        super();\n+        iConstant = constantToReturn;\n+    }\n+\n+    /**\n+     * Always return constant.\n+     */\n+    public Object transform(Object input) {\n+        return iConstant;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/FactoryTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/FactoryTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Factory and returns the result.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FactoryTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = -6817674502475353160L;\n+\n+    /** The closure to wrap */\n+    private final Factory iFactory;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param factory  the factory to call, not null\n+     * @return the <code>factory</code> transformer\n+     * @throws IllegalArgumentException if the factory is null\n+     */\n+    public static Transformer getInstance(Factory factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        return new FactoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param factory  the factory to call, not null\n+     */\n+    public FactoryTransformer(Factory factory) {\n+        super();\n+        iFactory = factory;\n+    }\n+\n+    /**\n+     * Call the factory.\n+     */\n+    public Object transform(Object input) {\n+        return iFactory.create();\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/collections/functors/FunctorUtils.java\n+++ b/src/java/org/apache/commons/collections/functors/FunctorUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/FunctorUtils.java,v 1.2 2003/11/23 22:05:24 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/FunctorUtils.java,v 1.3 2003/11/23 23:25:33 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.collections.Closure;\n import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n \n /**\n  * Internal utilities for functors.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/11/23 22:05:24 $\n+ * @version $Revision: 1.3 $ $Date: 2003/11/23 23:25:33 $\n  *\n  * @author Stephen Colebourne\n  */\n         }\n     }\n \n+    /**\n+     * Copy method\n+     * \n+     * @param transformers  the transformers to copy\n+     */\n+    static Transformer[] copy(Transformer[] transformers) {\n+        if (transformers == null) {\n+            return null;\n+        }\n+        return (Transformer[]) transformers.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param transformers  the transformers to validate\n+     */\n+    static void validate(Transformer[] transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"The transformer array must not be null\");\n+        }\n+        for (int i = 0; i < transformers.length; i++) {\n+            if (transformers[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/InstantiateTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that creates a new object instance by reflection.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class InstantiateTransformer implements Transformer, Serializable {\n+\n+    /** The serial version */\n+    static final long serialVersionUID = 3786388740793356347L;\n+    \n+    /** Singleton instance that uses the no arg constructor */\n+    public static final Transformer NO_ARG_INSTANCE = new InstantiateTransformer();\n+\n+    /** The constructor parameter types */\n+    private final Class[] iParamTypes;\n+    /** The constructor arguments */\n+    private final Object[] iArgs;\n+\n+    /**\n+     * Transformer method that performs validation.\n+     * \n+     * @param paramTypes  the constructor parameter types\n+     * @param args  the constructor arguments\n+     */\n+    public static Transformer getInstance(Class[] paramTypes, Object[] args) {\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n+        }\n+\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return NO_ARG_INSTANCE;\n+        } else {\n+            paramTypes = (Class[]) paramTypes.clone();\n+            args = (Object[]) args.clone();\n+        }\n+        return new InstantiateTransformer(paramTypes, args);\n+    }\n+\n+    /**\n+     * Constructor for no arg instance.\n+     */\n+    private InstantiateTransformer() {\n+        super();\n+        iParamTypes = null;\n+        iArgs = null;\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InstantiateTransformer(Class[] paramTypes, Object[] args) {\n+        super();\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+    }\n+\n+    /**\n+     * Return the result of instantiating the input Class object.\n+     */\n+    public Object transform(Object input) {\n+        try {\n+            if (input instanceof Class == false) {\n+                throw new FunctorException(\n+                    \"InstantiateTransformer: Input object was not an instanceof Class, it was a \"\n+                        + (input == null ? \"null object\" : input.getClass().getName()));\n+            }\n+            Constructor con = ((Class) input).getConstructor(iParamTypes);\n+            return con.newInstance(iArgs);\n+\n+        } catch (NoSuchMethodException ex) {\n+            throw new IllegalArgumentException(\"InstantiateTransformer: The constructor must exist and be public \");\n+        } catch (InstantiationException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex);\n+        } catch (IllegalAccessException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex);\n+        } catch (InvocationTargetException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/InvokerTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/InvokerTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that creates a new object instance by reflection.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class InvokerTransformer implements Transformer, Serializable {\n+\n+    /** The serial version */\n+    static final long serialVersionUID = -8653385846894047688L;\n+    \n+    /** The method name to call */\n+    private final String iMethodName;\n+    /** The array of reflection parameter types */\n+    private final Class[] iParamTypes;\n+    /** The array of reflection arguments */\n+    private final Object[] iArgs;\n+\n+    /**\n+     * Transformer method that performs validation.\n+     * \n+     * @param paramTypes  the constructor parameter types\n+     * @param args  the constructor arguments\n+     */\n+    public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) {\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+        }\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n+        }\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            paramTypes = null;\n+            args = null;\n+        } else {\n+            paramTypes = (Class[]) paramTypes.clone();\n+            args = (Object[]) args.clone();\n+        }\n+        return new InvokerTransformer(methodName, paramTypes, args);\n+    }\n+\n+    /**\n+     * Constructor for no arg instance.\n+     * \n+     * @param methodName  the method to call\n+     */\n+    private InvokerTransformer(String methodName) {\n+        super();\n+        iMethodName = methodName;\n+        iParamTypes = null;\n+        iArgs = null;\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param methodName  the method to call\n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n+        super();\n+        iMethodName = methodName;\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+    }\n+\n+    /**\n+     * Return the result of instantiating the input Class object.\n+     */\n+    public Object transform(Object input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        try {\n+            Class cls = input.getClass();\n+            Method method = cls.getMethod(iMethodName, iParamTypes);\n+            return method.invoke(input, iArgs);\n+                \n+        } catch (NoSuchMethodException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n+        } catch (IllegalAccessException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n+        } catch (InvocationTargetException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/MapTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/MapTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Predicate implementation that returns true the first time an object is\n+ * passed into the predicate.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class MapTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 862391807045468939L;\n+    \n+    /** The map of data to lookup in */\n+    private final Map iMap;\n+\n+    /**\n+     * Factory to create the transformer.\n+     * \n+     * @return the map, not cloned, not null\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static Transformer getInstance(Map map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"The map must not be null\");\n+        }\n+        return new MapTransformer(map);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param map  the map to use for lookup, not cloned\n+     */\n+    private MapTransformer(Map map) {\n+        super();\n+        iMap = map;\n+    }\n+\n+    /**\n+     * Returns the result by looking up in the map.\n+     */\n+    public Object transform(Object input) {\n+        return iMap.get(input);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/NOPTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/NOPTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that does nothing.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class NOPTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 2133891748318574490L;\n+\n+    /** Singleton predicate instance */    \n+    public static final Transformer INSTANCE = new NOPTransformer();\n+    \n+    /**\n+     * Constructor\n+     */\n+    private NOPTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Do nothing\n+     */\n+    public Object transform(Object input) {\n+        return input;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/PredicateTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/PredicateTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Predicate using the input object\n+ * and then returns the input.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class PredicateTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 5278818408044349346L;\n+\n+    /** The closure to wrap */\n+    private final Predicate iPredicate;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param predicate  the predicate to call, not null\n+     * @return the <code>predicate</code> transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static Transformer getInstance(Predicate predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new PredicateTransformer(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call, not null\n+     */\n+    public PredicateTransformer(Predicate predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Call the predicate.\n+     */\n+    public Object transform(Object input) {\n+        return (iPredicate.evaluate(input) ? Boolean.TRUE : Boolean.FALSE);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/StringValueTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/StringValueTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the <code>String.valueof</code>.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class StringValueTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 7511110693171758606L;\n+\n+    /** Singleton predicate instance */    \n+    public static final Transformer INSTANCE = new StringValueTransformer();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    private StringValueTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Return the String.valueOf for the object.\n+     */\n+    public Object transform(Object input) {\n+        return String.valueOf(input);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/SwitchTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/SwitchTransformer.java,v 1.1 2003/11/23 23:25:33 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation calls the transformer whose predicate returns true,\n+ * like a switch statement.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 23:25:33 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SwitchTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+\n+\n+    /** The tests to consider */\n+    private final Predicate[] iPredicates;\n+    /** The matching transformers to call */\n+    private final Transformer[] iTransformers;\n+    /** The default transformer to call if no tests match */\n+    private final Transformer iDefault;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter arrays.\n+     * \n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param transformers  matching array of transformers, cloned, no nulls\n+     * @param defaultTransformer  the transformer to use if no match, null means nop\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    public static Transformer getInstance(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+        FunctorUtils.validate(predicates);\n+        FunctorUtils.validate(transformers);\n+        if (predicates.length != transformers.length) {\n+            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n+        }\n+        if (predicates.length == 0) {\n+            return (defaultTransformer == null ? ConstantTransformer.NULL_INSTANCE : defaultTransformer);\n+        }\n+        predicates = FunctorUtils.copy(predicates);\n+        transformers = FunctorUtils.copy(transformers);\n+        return new SwitchTransformer(predicates, transformers, defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @return the <code>switch</code> transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Transformer getInstance(Map predicatesAndTransformers) {\n+        Transformer[] transformers = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndTransformers == null) {\n+            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n+        }\n+        if (predicatesAndTransformers.size() == 0) {\n+            return ConstantTransformer.NULL_INSTANCE;\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Transformer defaultTransformer = (Transformer) predicatesAndTransformers.remove(null);\n+        int size = predicatesAndTransformers.size();\n+        if (size == 0) {\n+            return (defaultTransformer == null ? ConstantTransformer.NULL_INSTANCE : defaultTransformer);\n+        }\n+        transformers = new Transformer[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndTransformers.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            transformers[i] = (Transformer) entry.getValue();\n+            i++;\n+        }\n+        return new SwitchTransformer(preds, transformers, defaultTransformer);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicates  array of predicates, not cloned, no nulls\n+     * @param transformers  matching array of transformers, not cloned, no nulls\n+     * @param defaultTransformer  the transformer to use if no match, null means nop\n+     */\n+    public SwitchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+        super();\n+        iPredicates = predicates;\n+        iTransformers = transformers;\n+        iDefault = (defaultTransformer == null ? ConstantTransformer.NULL_INSTANCE : defaultTransformer);\n+    }\n+\n+    /**\n+     * Execute the transformer whose predicate returns true.\n+     */\n+    public Object transform(Object input) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(input) == true) {\n+                return iTransformers[i].transform(input);\n+            }\n+        }\n+        return iDefault.transform(input);\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/collections/TestTransformerUtils.java\n+++ b/src/test/org/apache/commons/collections/TestTransformerUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestTransformerUtils.java,v 1.5 2003/11/23 14:41:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestTransformerUtils.java,v 1.6 2003/11/23 23:25:33 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n \n+import org.apache.commons.collections.functors.ConstantTransformer;\n import org.apache.commons.collections.functors.FunctorException;\n+import org.apache.commons.collections.functors.NOPTransformer;\n \n /**\n  * Tests the org.apache.commons.collections.TransformerUtils class.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2003/11/23 14:41:27 $\n+ * @version $Revision: 1.6 $ $Date: 2003/11/23 23:25:33 $\n  *\n  * @author Stephen Colebourne\n  * @author James Carman\n         coll.add(b);\n         coll.add(a);\n         assertEquals(\"A\", TransformerUtils.chainedTransformer(coll).transform(null));\n-    }\n-\n-    public void testChainedTransformerEx1a() {\n+\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(new Transformer[0]));\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.EMPTY_LIST));\n+        \n         try {\n             TransformerUtils.chainedTransformer(null, null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedTransformerEx1b() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.chainedTransformer((Transformer[]) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedTransformerEx1c() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.chainedTransformer((Collection) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedTransformerEx2() {\n-        try {\n-            TransformerUtils.chainedTransformer(new Transformer[0]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedTransformerEx3() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.chainedTransformer(new Transformer[] {null, null});\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedTransformerEx4() {\n-        try {\n-            TransformerUtils.chainedTransformer(Collections.EMPTY_LIST);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedTransformerEx5() {\n-        try {\n-            Collection coll = new ArrayList();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList();\n             coll.add(null);\n             coll.add(null);\n             TransformerUtils.chainedTransformer(coll);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     // switchTransformer\n         assertEquals(\"B\", TransformerUtils.switchTransformer(map).transform(\"THERE\"));\n         map.put(null, c);\n         assertEquals(\"C\", TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n-    }\n-\n-    public void testSwitchTransformerEx1a() {\n+\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap()));\n+        map = new HashMap();\n+        map.put(null, null);\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));\n+            \n         try {\n             TransformerUtils.switchTransformer(null, null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx1b() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx1c() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer((Map) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx2() {\n-        try {\n-            TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx3() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx4() {\n-        try {\n-            TransformerUtils.switchTransformer(new HashMap());\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx5() {\n-        try {\n-            Map map = new HashMap();\n-            map.put(null, null);\n-            map.put(null, null);\n-            TransformerUtils.switchTransformer(map);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchTransformerEx6() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer(new Predicate[2], new Transformer[1]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     // switchMapTransformer\n         assertEquals(\"B\", TransformerUtils.switchMapTransformer(map).transform(\"THERE\"));\n         map.put(null, c);\n         assertEquals(\"C\", TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n-    }\n-\n-    public void testSwitchMapTransformerEx1() {\n+\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap()));\n+        map = new HashMap();\n+        map.put(null, null);\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));\n+        \n         try {\n             TransformerUtils.switchMapTransformer(null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchMapTransformerEx2() {\n-        try {\n-            TransformerUtils.switchMapTransformer(new HashMap());\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     // invokerTransformer\n         list.add(new Object());\n         assertEquals(new Integer(1), TransformerUtils.invokerTransformer(\"size\").transform(list));\n         assertEquals(null, TransformerUtils.invokerTransformer(\"size\").transform(null));\n-    }\n-\n-    public void testInvokerTransformerEx1() {\n+\n         try {\n             TransformerUtils.invokerTransformer(null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testInvokerTransformerEx3() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object());\n-        } catch (FunctorException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (FunctorException ex) {}\n     }\n     \n     // invokerTransformer2\n             \"contains\", new Class[] {Object.class}, new Object[] {cString}).transform(list));\n         assertEquals(null, TransformerUtils.invokerTransformer(\n             \"contains\", new Class[] {Object.class}, new Object[] {cString}).transform(null));\n-    }\n-\n-    public void testInvokerTransformer2Ex1() {\n+\n         try {\n             TransformerUtils.invokerTransformer(null, null, null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testInvokerTransformer2Ex3() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\n                 \"noSuchMethod\", new Class[] {Object.class}, new Object[] {cString}).transform(new Object());\n-        } catch (FunctorException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (FunctorException ex) {}\n     }\n     \n     // stringValueTransformer", "timestamp": 1069629933, "metainfo": ""}