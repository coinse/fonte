{"sha": "007d3e3702b22b1593eafa42856f867b9c92eb37", "log": "Change CursorableLinkedList to use weak references to avoid memory leaks from Simon Kitching   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CursorableLinkedList.java\n+++ b/src/java/org/apache/commons/collections/CursorableLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CursorableLinkedList.java,v 1.17 2003/09/20 14:03:57 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CursorableLinkedList.java,v 1.18 2003/09/27 10:07:14 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.List;\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n+import java.lang.ref.WeakReference;\n \n /**\n  * A doubly-linked list implementation of the {@link List} interface,\n  *\n  * @see java.util.LinkedList\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.17 $ $Date: 2003/09/20 14:03:57 $\n+ * @version $Revision: 1.18 $ $Date: 2003/09/27 10:07:14 $\n  * \n  * @author Rodney Waldhoff\n  * @author Janek Bogucki\n+ * @author Simon Kitching\n  */\n public class CursorableLinkedList implements List, Serializable {\n-    //  TODO: use weak references to cursors in case they aren't closed directly\n-    \n     /** Ensure serialization compatability */    \n     private static final long serialVersionUID = 8836393098519411393L;\n \n      * {@link ListIterator#nextIndex} and {@link ListIterator#previousIndex}\n      * methods (they throw {@link UnsupportedOperationException} when invoked.\n      * <p>\n-     * Clients must close the cursor when they are done using it.\n-     * The returned {@link ListIterator} will be an instance of\n-     * {@link CursorableLinkedList.Cursor}.   To close the cursor,\n-     * cast the {@link ListIterator} to {@link CursorableLinkedList.Cursor}\n-     * and invoke the {@link CursorableLinkedList.Cursor#close} method.\n+     * Historical Note: In previous versions of this class, the object \n+     * returned from this method was required to be explicitly closed. This \n+     * is no longer necessary.\n      *\n      * @see #cursor(int)\n      * @see #listIterator\n      * of changes to this list.\n      */\n     protected void registerCursor(Cursor cur) {\n-        _cursors.add(cur);\n+        // We take this opportunity to clean the _cursors list\n+        // of WeakReference objects to garbage-collected cursors.\n+        for (Iterator it = _cursors.iterator(); it.hasNext(); ) {\n+            WeakReference ref = (WeakReference) it.next();\n+            if (ref.get() == null) {\n+                it.remove();\n+            }\n+        }\n+        \n+        _cursors.add( new WeakReference(cur) );\n     }\n \n     /**\n      * the set of cursors to be notified of changes to this list.\n      */\n     protected void unregisterCursor(Cursor cur) {\n-        _cursors.remove(cur);\n+        for (Iterator it = _cursors.iterator(); it.hasNext(); ) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                // some other unrelated cursor object has been \n+                // garbage-collected; let's take the opportunity to\n+                // clean up the cursors list anyway..\n+                it.remove();\n+                \n+            } else if (cursor == cur) {\n+                ref.clear();\n+                it.remove();\n+                break;\n+            }\n+        }\n     }\n \n     /**\n      */\n     protected void invalidateCursors() {\n         Iterator it = _cursors.iterator();\n-        while(it.hasNext()) {\n-            ((Cursor)it.next()).invalidate();\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor != null) {\n+                // cursor is null if object has been garbage-collected\n+                cursor.invalidate();\n+                ref.clear();\n+            }\n             it.remove();\n         }\n     }\n      */\n     protected void broadcastListableChanged(Listable elt) {\n         Iterator it = _cursors.iterator();\n-        while(it.hasNext()) {\n-            ((Cursor)it.next()).listableChanged(elt);\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.listableChanged(elt);\n+            }\n         }\n     }\n \n      */\n     protected void broadcastListableRemoved(Listable elt) {\n         Iterator it = _cursors.iterator();\n-        while(it.hasNext()) {\n-            ((Cursor)it.next()).listableRemoved(elt);\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.listableRemoved(elt);\n+            }\n         }\n     }\n \n      */\n     protected void broadcastListableInserted(Listable elt) {\n         Iterator it = _cursors.iterator();\n-        while(it.hasNext()) {\n-            ((Cursor)it.next()).listableInserted(elt);\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                it.remove();  // clean up list\n+            } else {\n+                cursor.listableInserted(elt);\n+            }\n         }\n     }\n \n             _valid = false;\n         }\n \n+        /**\n+         * Mark this cursor as no longer being needed. Any resources\n+         * associated with this cursor are immediately released.\n+         * In previous versions of this class, it was mandatory to close\n+         * all cursor objects to avoid memory leaks. It is <i>no longer</i>\n+         * necessary to call this close method; an instance of this class\n+         * can now be treated exactly like a normal iterator.\n+         */\n         public void close() {\n             if(_valid) {\n                 _valid = false;\n--- a/src/test/org/apache/commons/collections/TestCursorableLinkedList.java\n+++ b/src/test/org/apache/commons/collections/TestCursorableLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestCursorableLinkedList.java,v 1.10 2003/09/20 14:03:57 scolebourne Exp $\n- * $Revision: 1.10 $\n- * $Date: 2003/09/20 14:03:57 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestCursorableLinkedList.java,v 1.11 2003/09/27 10:07:14 scolebourne Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/09/27 10:07:14 $\n  *\n  * ====================================================================\n  *\n import junit.framework.Test;\n \n /**\n+ * Test class.\n+ * \n  * @author Rodney Waldhoff\n- * @version $Id: TestCursorableLinkedList.java,v 1.10 2003/09/20 14:03:57 scolebourne Exp $\n+ * @author Simon Kitching\n+ * @version $Id: TestCursorableLinkedList.java,v 1.11 2003/09/27 10:07:14 scolebourne Exp $\n  */\n public class TestCursorableLinkedList extends TestList {\n     public TestCursorableLinkedList(String testName) {\n         it.close();\n     }\n \n+    public void testCursorConcurrentModification() {\n+        // this test verifies that cursors remain valid when the list\n+        // is modified via other means.\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+        list.add(\"7\");\n+        list.add(\"9\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        CursorableLinkedList.Cursor c2 = list.cursor();\n+        ListIterator li = list.listIterator();\n+        \n+        // test cursors remain valid when list modified by std ListIterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\",li.next());\n+        assertEquals(\"2\",li.next());\n+        li.remove();\n+        assertEquals(\"3\",li.next());\n+        assertEquals(\"1\",c1.next());\n+        assertEquals(\"3\",c1.next());\n+        assertEquals(\"1\",c2.next());\n+        \n+        // test cursor c1 can remove elements from previously modified list\n+        // test cursor c2 skips elements removed via different cursor\n+        c1.remove();\n+        assertEquals(\"5\",c2.next());\n+        c2.add(\"6\");\n+        assertEquals(\"5\",c1.next());\n+        assertEquals(\"6\",c1.next());\n+        assertEquals(\"7\",c1.next());\n+        \n+        // test cursors remain valid when list mod via CursorableLinkedList\n+        // test cursor remains valid when elements inserted into list before\n+        // the current position of the cursor.\n+        list.add(0, \"0\");\n+\n+        // test cursor remains valid when element inserted immediately after\n+        // current element of a cursor, and the element is seen on the\n+        // next call to the next method of that cursor.\n+        list.add(5, \"8\");\n+\n+        assertEquals(\"8\",c1.next());\n+        assertEquals(\"9\",c1.next());\n+        c1.add(\"10\");\n+        assertEquals(\"7\",c2.next());\n+        assertEquals(\"8\",c2.next());\n+        assertEquals(\"9\",c2.next());\n+        assertEquals(\"10\",c2.next());\n+        \n+        boolean nosuch = false;\n+        try {\n+            c2.next();\n+        }\n+        catch (java.util.NoSuchElementException nse) {\n+           nosuch = true; // expected\n+        }\n+        assertTrue(nosuch);\n+        \n+        boolean listIteratorInvalid = false;\n+        try {\n+            li.next();\n+        }\n+        catch(java.util.ConcurrentModificationException cme) {\n+            listIteratorInvalid = true; // expected\n+        }\n+        assertTrue(listIteratorInvalid);\n+        \n+        c1.close();  // not necessary\n+        c2.close();  // not necessary\n+    }\n+    \n     public void testEqualsAndHashCode() {\n         assertTrue(list.equals(list));\n         assertEquals(list.hashCode(),list.hashCode());", "timestamp": 1064657234, "metainfo": ""}