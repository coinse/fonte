{"sha": "61173f58aa10b6acf8a352d12b1fcb5b43a15b09", "log": "27691: Adding timeout versions of get() and remove()  ", "commit": "\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n /**\n  * Decorates another <code>Buffer</code> to make {@link #get()} and\n  * {@link #remove()} block when the <code>Buffer</code> is empty.\n- * <p>\n+ * <p/>\n  * If either <code>get</code> or <code>remove</code> is called on an empty\n  * <code>Buffer</code>, the calling thread waits for notification that\n  * an <code>add</code> or <code>addAll</code> operation has completed.\n- * <p>\n+ * <p/>\n  * When one or more entries are added to an empty <code>Buffer</code>,\n  * all threads blocked in <code>get</code> or <code>remove</code> are notified.\n- * There is no guarantee that concurrent blocked <code>get</code> or \n- * <code>remove</code> requests will be \"unblocked\" and receive data in the \n+ * There is no guarantee that concurrent blocked <code>get</code> or\n+ * <code>remove</code> requests will be \"unblocked\" and receive data in the\n  * order that they arrive.\n- * <p>\n+ * <p/>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n- * @since Commons Collections 3.0\n- * @version $Revision$ $Date$\n- * \n  * @author Stephen Colebourne\n  * @author Janek Bogucki\n  * @author Phil Steitz\n+ * @version $Revision$ $Date$\n+ * @since Commons Collections 3.0\n  */\n public class BlockingBuffer extends SynchronizedBuffer {\n-\n-    /** Serialization version */\n+    /**\n+     * Serialization version\n+     */\n     private static final long serialVersionUID = 1719328905017860541L;\n \n     /**\n      * Factory method to create a blocking buffer.\n-     * \n-     * @param buffer  the buffer to decorate, must not be null\n+     *\n+     * @param buffer the buffer to decorate, must not be null\n      * @return a new blocking Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n     //-----------------------------------------------------------------------    \n     /**\n      * Constructor that wraps (not copies).\n-     * \n-     * @param buffer  the buffer to decorate, must not be null\n+     *\n+     * @param buffer the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n     protected BlockingBuffer(Buffer buffer) {\n \n     //-----------------------------------------------------------------------\n     public boolean add(Object o) {\n-        synchronized (lock) {\n+        synchronized(lock) {\n             boolean result = collection.add(o);\n             notifyAll();\n             return result;\n     }\n \n     public boolean addAll(Collection c) {\n-        synchronized (lock) {\n+        synchronized(lock) {\n             boolean result = collection.addAll(c);\n             notifyAll();\n             return result;\n     }\n \n     public Object get() {\n-        synchronized (lock) {\n-            while (collection.isEmpty()) {\n+        synchronized(lock) {\n+            while(collection.isEmpty()) {\n                 try {\n                     wait();\n-                } catch (InterruptedException e) {\n+                }\n+                catch(InterruptedException e) {\n                     PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n         }\n     }\n \n+    public Object get(final long timeout) {\n+        synchronized(lock) {\n+            final long expiration = System.currentTimeMillis() + timeout;\n+            long timeLeft = expiration - System.currentTimeMillis();\n+            while(timeLeft > 0 && collection.isEmpty()) {\n+                try {\n+                    wait(timeLeft);\n+                    timeLeft = expiration - System.currentTimeMillis();\n+                }\n+                catch(InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            if(collection.isEmpty()) {\n+                throw new BufferUnderflowException(\"Timeout expired.\");\n+            }\n+            return getBuffer().get();\n+        }\n+    }\n+\n     public Object remove() {\n-        synchronized (lock) {\n-            while (collection.isEmpty()) {\n+        synchronized(lock) {\n+            while(collection.isEmpty()) {\n                 try {\n                     wait();\n-                } catch (InterruptedException e) {\n+                }\n+                catch(InterruptedException e) {\n                     PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n         }\n     }\n \n+    public Object remove(final long timeout) {\n+        synchronized(lock) {\n+            final long expiration = System.currentTimeMillis() + timeout;\n+            long timeLeft = expiration - System.currentTimeMillis();\n+            while(timeLeft > 0 && collection.isEmpty()) {\n+                try {\n+                    wait(timeLeft);\n+                    timeLeft = expiration - System.currentTimeMillis();\n+                }\n+                catch(InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            if(collection.isEmpty()) {\n+                throw new BufferUnderflowException(\"Timeout expired.\");\n+            }\n+            return getBuffer().remove();\n+        }\n+    }\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n         }\n         \n     }\n-    \n+\n+    public void testTimeoutGet() {\n+        final BlockingBuffer buffer = new BlockingBuffer(new MyBuffer());\n+        try {\n+            buffer.get( 100 );\n+            fail( \"Get should have timed out.\" );\n+        }\n+        catch( BufferUnderflowException e ){\n+        }\n+    }\n+\n+    public void testTimeoutRemove() {\n+        final BlockingBuffer buffer = new BlockingBuffer(new MyBuffer());\n+        try {\n+            buffer.remove( 100 );\n+            fail( \"Get should have timed out.\" );\n+        }\n+        catch( BufferUnderflowException e ){\n+        }\n+    }\n     protected static class DelayedAdd extends Thread {\n \n         Buffer buffer;", "timestamp": 1116428582, "metainfo": ""}