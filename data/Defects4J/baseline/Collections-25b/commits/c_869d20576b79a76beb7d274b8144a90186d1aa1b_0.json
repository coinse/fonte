{"sha": "869d20576b79a76beb7d274b8144a90186d1aa1b", "log": "Add DualTreeBidiMap implementation and tests   ", "commit": "\n--- a/src/java/org/apache/commons/collections/AbstractDualBidiMap.java\n+++ b/src/java/org/apache/commons/collections/AbstractDualBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/AbstractDualBidiMap.java,v 1.4 2003/10/29 00:06:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/AbstractDualBidiMap.java,v 1.5 2003/10/31 01:26:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <code>createMap</code> method.\n  * \n  * @since Commons Collections 3.0\n- * @version $Id: AbstractDualBidiMap.java,v 1.4 2003/10/29 00:06:25 scolebourne Exp $\n+ * @version $Id: AbstractDualBidiMap.java,v 1.5 2003/10/31 01:26:25 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n      * View of the keys.\n      */\n     protected transient Set keySet = null;\n+    /**\n+     * View of the values.\n+     */\n+    protected transient Collection values = null;\n     /**\n      * View of the entries.\n      */\n     }\n \n     public Collection values() {\n-        return inverseBidiMap().keySet();\n+        if (values == null) {\n+            values = new Values(this);\n+        }\n+        return values;\n     }\n \n     public Set entrySet() {\n             }\n             return modified;\n         }\n-\n+        \n         public void clear() {\n             map.clear();\n         }\n     }\n     \n+    //-----------------------------------------------------------------------\n     /**\n      * Inner class KeySet.\n      */\n             return new KeySetIterator(super.iterator(), map);\n         }\n         \n+        public boolean contains(Object key) {\n+            return map.maps[0].containsKey(key);\n+        }\n+\n         public boolean remove(Object key) {\n-            if (contains(key)) {\n+            if (map.maps[0].containsKey(key)) {\n                 Object value = map.maps[0].remove(key);\n                 map.maps[1].remove(value);\n                 return true;\n     protected static class KeySetIterator extends AbstractIteratorDecorator {\n         \n         private final AbstractDualBidiMap map;\n-        private Object last = null;\n+        private Object lastKey = null;\n         private boolean canRemove = false;\n         \n         protected KeySetIterator(Iterator iterator, AbstractDualBidiMap map) {\n         }\n         \n         public Object next() {\n-            last = super.next();\n+            lastKey = super.next();\n             canRemove = true;\n-            return last;\n+            return lastKey;\n         }\n         \n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n-            Object value = map.maps[0].get(last);\n+            Object value = map.maps[0].get(lastKey);\n             super.remove();\n             map.maps[1].remove(value);\n-            last = null;\n+            lastKey = null;\n             canRemove = false;\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Values.\n+     */\n+    protected static class Values extends View implements Set {\n+        \n+        protected Values(AbstractDualBidiMap map) {\n+            super(map.maps[0].values(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new ValuesIterator(super.iterator(), map);\n+        }\n+        \n+        public boolean contains(Object value) {\n+            return map.maps[1].containsKey(value);\n+        }\n+\n+        public boolean remove(Object value) {\n+            if (map.maps[1].containsKey(value)) {\n+                Object key = map.maps[1].remove(value);\n+                map.maps[0].remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Inner class ValuesIterator.\n+     */\n+    protected static class ValuesIterator extends AbstractIteratorDecorator {\n+        \n+        private final AbstractDualBidiMap map;\n+        private Object lastValue = null;\n+        private boolean canRemove = false;\n+        \n+        protected ValuesIterator(Iterator iterator, AbstractDualBidiMap map) {\n+            super(iterator);\n+            this.map = map;\n+        }\n+        \n+        public Object next() {\n+            lastValue = super.next();\n+            canRemove = true;\n+            return lastValue;\n+        }\n+        \n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            super.remove(); // removes from maps[0]\n+            map.maps[1].remove(lastValue);\n+            lastValue = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Inner class EntrySet.\n      */\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/DualTreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/DualTreeBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.decorators.AbstractSortedMapDecorator;\n+\n+/**\n+ * Implementation of <code>BidiMap</code> that uses two <code>TreeMap</code> instances.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Id: DualTreeBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class DualTreeBidiMap extends AbstractDualBidiMap implements SortedBidiMap {\n+\n+    /**\n+     * Creates an empty <code>DualTreeBidiMap</code>\n+     */\n+    public DualTreeBidiMap() {\n+        super();\n+    }\n+\n+    /** \n+     * Constructs a <code>DualTreeBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.  \n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualTreeBidiMap(Map map) {\n+        super();\n+        putAll(map);\n+    }\n+\n+    /** \n+     * Constructs a <code>HashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualTreeBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+    }\n+    \n+    /**\n+     * Creates a new instance of the map used by the subclass to store data.\n+     * \n+     * @return the map to be used for internal storage\n+     */\n+    protected Map createMap() {\n+        return new TreeMap();\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     * \n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    protected BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseMap) {\n+        return new DualTreeBidiMap(normalMap, reverseMap, inverseMap);\n+    }\n+\n+    // SortedBidiMap\n+    //-----------------------------------------------------------------------\n+    public SortedBidiMap inverseSortedBidiMap() {\n+        return (SortedBidiMap) inverseBidiMap();\n+    }\n+\n+    // SortedMap\n+    //-----------------------------------------------------------------------\n+    public Comparator comparator() {\n+        return ((SortedMap) maps[0]).comparator();\n+    }\n+\n+    public Object firstKey() {\n+        return ((SortedMap) maps[0]).firstKey();\n+    }\n+\n+    public Object lastKey() {\n+        return ((SortedMap) maps[0]).lastKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedMap headMap(Object toKey) {\n+        SortedMap sub = ((SortedMap) maps[0]).headMap(toKey);\n+        return new ViewMap(this, sub);\n+    }\n+\n+    public SortedMap tailMap(Object fromKey) {\n+        SortedMap sub = ((SortedMap) maps[0]).tailMap(fromKey);\n+        return new ViewMap(this, sub);\n+    }\n+\n+    public SortedMap subMap(Object fromKey, Object toKey) {\n+        SortedMap sub = ((SortedMap) maps[0]).subMap(fromKey, toKey);\n+        return new ViewMap(this, sub);\n+    }\n+    \n+    protected static class ViewMap extends AbstractSortedMapDecorator {\n+        final DualTreeBidiMap bidi;\n+        \n+        protected ViewMap(DualTreeBidiMap bidi, SortedMap sm) {\n+            super((SortedMap) bidi.createBidiMap(sm, bidi.maps[1], bidi.inverseBidiMap));\n+            this.bidi = (DualTreeBidiMap) map;\n+        }\n+        \n+        public boolean containsValue(Object value) {\n+            // override as default implementation jumps to [1]\n+            return bidi.maps[0].containsValue(value);\n+        }\n+        \n+        public SortedMap headMap(Object toKey) {\n+            return new ViewMap(bidi, super.headMap(toKey));\n+        }\n+\n+        public SortedMap tailMap(Object fromKey) {\n+            return new ViewMap(bidi, super.tailMap(fromKey));\n+        }\n+\n+        public SortedMap subMap(Object fromKey, Object toKey) {\n+            return new ViewMap(bidi, super.subMap(fromKey, toKey));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/AbstractTestSortedBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestSortedBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.pairs.DefaultMapEntry;\n+\n+/**\n+ * Abstract test class for {@link BidiMap} methods and contracts.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/10/31 01:26:25 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestSortedBidiMap extends AbstractTestBidiMap {\n+\n+    protected List sortedKeys = new ArrayList();\n+    protected List sortedValues = new ArrayList();\n+    protected SortedSet sortedNewValues = new TreeSet();\n+\n+    public AbstractTestSortedBidiMap(String testName) {\n+        super(testName);\n+        sortedKeys.addAll(Arrays.asList(getSampleKeys()));\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+        \n+        Map map = new TreeMap();\n+        for (int i = 0; i < getSampleKeys().length; i++) {\n+            map.put(getSampleKeys()[i], getSampleValues()[i]);\n+        }\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+        \n+        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+    }\n+\n+    public AbstractTestSortedBidiMap() {\n+        super();\n+        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+        \n+        Map map = new TreeMap();\n+        for (int i = 0; i < getSampleKeys().length; i++) {\n+            map.put(getSampleValues()[i], getSampleKeys()[i]);\n+        }\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+        \n+        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected boolean isAllowNullKey() {\n+        return false;\n+    }\n+    protected boolean isAllowNullValue() {\n+        return false;\n+    }\n+    protected Map makeConfirmedMap() {\n+        return new TreeMap();\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testFirstKey() {\n+        SortedMap sm = (SortedMap) makeFullMap();\n+        assertSame(sm.keySet().iterator().next(), sm.firstKey());\n+    }\n+    \n+    public void testLastKey() {\n+        SortedMap sm = (SortedMap) makeFullMap();\n+        Object obj = null;\n+        for (Iterator it = sm.keySet().iterator(); it.hasNext();) {\n+            obj = (Object) it.next();\n+        }\n+        assertSame(obj, sm.lastKey());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testBidiHeadMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object toKey = it.next();\n+        Object second = it.next();\n+        Object firstValue = sm.get(first);\n+        Object secondValue = sm.get(second);\n+        \n+        SortedMap head = sm.headMap(toKey);\n+        assertEquals(1, head.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, head.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(false, head.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(false, head.containsValue(secondValue));\n+    }\n+                \n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        SortedMap head = sm.headMap(toKey);\n+        assertEquals(2, head.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, head.containsKey(second));\n+        \n+        Object firstValue = head.remove(first);\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, head.containsKey(first));\n+        assertEquals(false, head.containsValue(firstValue));\n+        assertEquals(1, head.size());\n+        \n+        Object secondValue = head.remove(second);\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, head.containsKey(second));\n+        assertEquals(false, head.containsValue(secondValue));\n+        assertEquals(0, head.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        SortedMap head = sm.headMap(toKey);\n+        Set set = head.entrySet();\n+        Iterator it2 = set.iterator();\n+        Object fromEntry = it2.next();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, head.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, head.containsKey(firstEntry.getKey()));\n+        assertEquals(false, head.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, head.containsKey(secondEntry.getKey()));\n+        assertEquals(false, head.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        \n+        SortedMap tail = sm.tailMap(fromKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, tail.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, tail.containsKey(second));\n+        \n+        Object firstValue = tail.remove(first);\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, tail.containsKey(first));\n+        assertEquals(false, tail.containsValue(firstValue));\n+        \n+        Object secondValue = tail.remove(second);\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, tail.containsKey(second));\n+        assertEquals(false, tail.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        SortedMap tail = sm.tailMap(fromKey);\n+        Set set = tail.entrySet();\n+        Iterator it2 = set.iterator();\n+        Object fromEntry = it2.next();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, tail.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, tail.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, tail.containsKey(firstEntry.getKey()));\n+        assertEquals(false, tail.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, tail.containsKey(secondEntry.getKey()));\n+        assertEquals(false, tail.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        Set set = sub.entrySet();\n+        assertEquals(3, set.size());\n+        Iterator it2 = set.iterator();\n+        Object fromEntry = it2.next();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public BulkTest bulkTestHeadMap() {\n+        return new AbstractTestSortedMap.TestHeadMap(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new AbstractTestSortedMap.TestTailMap(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new AbstractTestSortedMap.TestSubMap(this);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.51 2003/10/28 18:56:12 ggregory Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.52 2003/10/31 01:26:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Entry point for all Collections package tests.\n  * \n- * @version $Revision: 1.51 $ $Date: 2003/10/28 18:56:12 $\n+ * @version $Revision: 1.52 $ $Date: 2003/10/31 01:26:25 $\n  * \n  * @author Rodney Waldhoff\n  * @author Stephen Colebourne\n         suite.addTest(TestCommonsLinkedList.suite());\n         suite.addTest(TestCursorableLinkedList.suite());\n         suite.addTest(TestDoubleOrderedMap.suite());\n+        suite.addTest(TestDualHashBidiMap.suite());\n+        suite.addTest(TestDualTreeBidiMap.suite());\n         suite.addTest(TestExtendedProperties.suite());\n         suite.addTest(TestFastArrayList.suite());\n         suite.addTest(TestFastArrayList1.suite());\n         suite.addTest(TestFastTreeMap.suite());\n         suite.addTest(TestFastTreeMap1.suite());\n         suite.addTest(TestHashBag.suite());\n-        suite.addTest(TestDualHashBidiMap.suite());\n         suite.addTest(TestIteratorUtils.suite());\n         suite.addTest(TestLRUMap.suite());\n         suite.addTest(TestMultiHashMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestDualTreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestDualTreeBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/10/31 01:26:25 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class TestDualTreeBidiMap extends AbstractTestSortedBidiMap {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestDualTreeBidiMap.class);\n+    }\n+\n+    public TestDualTreeBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    protected BidiMap makeEmptyBidiMap() {\n+        return new DualTreeBidiMap();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    protected String[] ignoredTests() {\n+        return new String[] {\"TestDualTreeBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/collections/decorators/TestFixedSizeSortedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestFixedSizeSortedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestFixedSizeSortedMap.java,v 1.5 2003/10/07 22:20:58 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestFixedSizeSortedMap.java,v 1.6 2003/10/31 01:26:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.TreeMap;\n \n import junit.framework.Test;\n-import junit.framework.TestSuite;\n \n import org.apache.commons.collections.AbstractTestSortedMap;\n+import org.apache.commons.collections.BulkTest;\n \n /**\n  * Extension of {@link TestSortedMap} for exercising the {@link FixedSizeSortedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2003/10/07 22:20:58 $\n+ * @version $Revision: 1.6 $ $Date: 2003/10/31 01:26:25 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n \n     public static Test suite() {\n-        return new TestSuite(TestFixedSizeSortedMap.class);\n+        return BulkTest.makeSuite(TestFixedSizeSortedMap.class);\n     }\n \n     public static void main(String args[]) {\n--- a/src/test/org/apache/commons/collections/decorators/TestTransformedSortedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestTransformedSortedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedSortedMap.java,v 1.4 2003/10/06 23:44:23 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedSortedMap.java,v 1.5 2003/10/31 01:26:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.TreeMap;\n \n import junit.framework.Test;\n-import junit.framework.TestSuite;\n \n import org.apache.commons.collections.AbstractTestSortedMap;\n+import org.apache.commons.collections.BulkTest;\n \n /**\n  * Extension of {@link AbstractTestSortedMap} for exercising the {@link TransformedSortedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/10/06 23:44:23 $\n+ * @version $Revision: 1.5 $ $Date: 2003/10/31 01:26:25 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n \n     public static Test suite() {\n-        return new TestSuite(TestTransformedSortedMap.class);\n+        return BulkTest.makeSuite(TestTransformedSortedMap.class);\n     }\n \n     public static void main(String args[]) {", "timestamp": 1067563585, "metainfo": ""}