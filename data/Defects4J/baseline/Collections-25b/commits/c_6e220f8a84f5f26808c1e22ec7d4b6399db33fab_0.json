{"sha": "6e220f8a84f5f26808c1e22ec7d4b6399db33fab", "log": "Changed ReferenceMap to extend AbstractHashedMap, thus gaining a mapIterator() and subclassability   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/ReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceMap.java\n import java.lang.ref.ReferenceQueue;\n import java.lang.ref.SoftReference;\n import java.lang.ref.WeakReference;\n-import java.util.AbstractCollection;\n-import java.util.AbstractMap;\n-import java.util.AbstractSet;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Set;\n \n-import org.apache.commons.collections.KeyValue;\n import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n \n /**\n- * Hash-based <code>Map</code> implementation that allows\n- * mappings to be removed by the garbage collector.\n+ * A <code>Map</code> implementation that allows mappings to be\n+ * removed by the garbage collector.\n  * <p>\n- * When you construct a <code>ReferenceMap</code>, you can \n- * specify what kind of references are used to store the\n- * map's keys and values.  If non-hard references are \n- * used, then the garbage collector can remove mappings\n- * if a key or value becomes unreachable, or if the \n- * JVM's memory is running low.  For information on how\n- * the different reference types behave, see\n- * {@link Reference}.\n+ * When you construct a <code>ReferenceMap</code>, you can specify what kind\n+ * of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n  * <p>\n- * Different types of references can be specified for keys\n- * and values.  The keys can be configured to be weak but\n- * the values hard, in which case this class will behave\n- * like a <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n- * <code>WeakHashMap</code></a>.  However, you\n- * can also specify hard keys and weak values, or any other\n- * combination.  The default constructor uses hard keys\n- * and soft values, providing a memory-sensitive cache.\n+ * Different types of references can be specified for keys and values.\n+ * The keys can be configured to be weak but the values hard,\n+ * in which case this class will behave like a\n+ * <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n+ * <code>WeakHashMap</code></a>. However, you can also specify hard keys and\n+ * weak values, or any other combination. The default constructor uses\n+ * hard keys and soft values, providing a memory-sensitive cache.\n  * <p>\n- * The algorithms used are basically the same as those\n- * in {@link java.util.HashMap}.  In particular, you \n- * can specify a load factor and capacity to suit your\n- * needs.  All optional {@link Map} operations are \n- * supported.\n+ * This {@link Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n  * <p>\n- * However, this {@link Map} implementation does <I>not</I>\n- * allow null elements.  Attempting to add a null key or\n- * or a null value to the map will raise a \n- * <code>NullPointerException</code>.\n+ * As usual, this implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceMap</code>.\n  * <p>\n- * As usual, this implementation is not synchronized.  You\n- * can use {@link java.util.Collections#synchronizedMap} to \n- * provide synchronized access to a <code>ReferenceMap</code>.\n+ * NOTE: As from Commons Collections 3.1 this map extends <code>AbstractHashedMap</code>\n+ * (previously it extended AbstractMap). As a result, the implementation is now\n+ * extensible and provides a <code>MapIterator</code>.\n  *\n  * @see java.lang.ref.Reference\n  * \n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.10 $ $Date: 2004/02/18 01:13:19 $\n+ * @version $Revision: 1.11 $ $Date: 2004/04/01 00:07:48 $\n  * \n  * @author Paul Jack\n+ * @author Stephen Colebourne\n  */\n-public class ReferenceMap extends AbstractMap {\n+public class ReferenceMap extends AbstractHashedMap {\n \n     /**\n      *  For serialization.\n      *  See purge.\n      */\n     private transient ReferenceQueue queue = new ReferenceQueue();\n-\n-    /**\n-     *  The hash table.  Its length is always a power of two.  \n-     */\n-    private transient Entry[] table;\n-\n-    /**\n-     *  Number of mappings in this map.\n-     */\n-    private transient int size;\n-\n-    /**\n-     *  When size reaches threshold, the map is resized.  \n-     *  See resize().\n-     */\n-    private transient int threshold;\n-\n-    /**\n-     *  Number of times this map has been modified.\n-     */\n-    private transient volatile int modCount;\n-\n-    /**\n-     *  Cached key set.  May be null if key set is never accessed.\n-     */\n-    private transient Set keySet;\n-\n-    /**\n-     *  Cached entry set.  May be null if entry set is never accessed.\n-     */\n-    private transient Set entrySet;\n-\n-    /**\n-     *  Cached values.  May be null if values() is never accessed.\n-     */\n-    private transient Collection values;\n \n     /**\n      *  Constructs a new <code>ReferenceMap</code> that will\n      *  @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceMap(\n-                        int keyType, \n-                        int valueType, \n-                        int capacity, \n-                        float loadFactor, \n-                        boolean purgeValues) {\n+    public ReferenceMap(int keyType, int valueType, int capacity, \n+                        float loadFactor, boolean purgeValues) {\n         this(keyType, valueType, capacity, loadFactor);\n         this.purgeValues = purgeValues;\n     }\n      *  @param loadFactor  the load factor for the map\n      */\n     public ReferenceMap(int keyType, int valueType, int capacity, float loadFactor) {\n-        super();\n+        super(capacity, loadFactor);\n \n         verify(\"keyType\", keyType);\n         verify(\"valueType\", valueType);\n-\n-        if (capacity <= 0) {\n-            throw new IllegalArgumentException(\"capacity must be positive\");\n-        }\n-        if ((loadFactor <= 0.0f) || (loadFactor >= 1.0f)) {\n-            throw new IllegalArgumentException(\"Load factor must be greater than 0 and less than 1.\");\n-        }\n-\n         this.keyType = keyType;\n         this.valueType = valueType;\n-\n-        int v = 1;\n-        while (v < capacity) v *= 2;\n-\n-        this.table = new Entry[v];\n-        this.loadFactor = loadFactor;\n-        this.threshold = (int)(v * loadFactor);\n-    }\n-\n-\n-    // used by constructor\n+    }\n+\n+    /**\n+     * Checks the type int is a valid value.\n+     * \n+     * @param name  the name for error messages\n+     * @param type  the type value to check\n+     * @throws IllegalArgumentException if the value if invalid\n+     */\n     private static void verify(String name, int type) {\n         if ((type < HARD) || (type > WEAK)) {\n-            throw new IllegalArgumentException(name + \n-               \" must be HARD, SOFT, WEAK.\");\n-        }\n-    }\n-\n+            throw new IllegalArgumentException(name + \" must be HARD, SOFT, WEAK.\");\n+        }\n+    }\n \n     /**\n      *  Writes this object to the given output stream.\n      */\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n-        out.writeInt(table.length);\n+        out.writeInt(data.length);\n \n         // Have to use null-terminated list because size might shrink\n         // during iteration\n      */\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        table = new Entry[in.readInt()];\n-        threshold = (int)(table.length * loadFactor);\n+        data = new HashEntry[in.readInt()];\n+        threshold = calculateThreshold(data.length, loadFactor);\n         queue = new ReferenceQueue();\n         Object key = in.readObject();\n         while (key != null) {\n         }\n     }\n \n-\n-    /**\n-     *  Constructs a reference of the given type to the given \n-     *  referent.  The reference is registered with the queue\n-     *  for later purging.\n-     *\n-     *  @param type  HARD, SOFT or WEAK\n-     *  @param referent  the object to refer to\n-     *  @param hash  the hash code of the <I>key</I> of the mapping;\n-     *    this number might be different from referent.hashCode() if\n-     *    the referent represents a value and not a key\n-     */\n-    private Object toReference(int type, Object referent, int hash) {\n-        switch (type) {\n-            case HARD: return referent;\n-            case SOFT: return new SoftRef(hash, referent, queue);\n-            case WEAK: return new WeakRef(hash, referent, queue);\n-            default: throw new Error();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Returns the entry associated with the given key.\n-     *\n-     *  @param key  the key of the entry to look up\n-     *  @return  the entry associated with that key, or null\n-     *    if the key is not in this map\n-     */\n-    private Entry getEntry(Object key) {\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the entry, null if no match\n+     * @since Commons Collections 3.1\n+     */\n+    protected HashEntry getEntry(Object key) {\n         if (key == null) {\n             return null;\n-        }\n-        int hash = key.hashCode();\n-        int index = indexFor(hash);\n-        for (Entry entry = table[index]; entry != null; entry = entry.next) {\n-            if ((entry.hash == hash) && key.equals(entry.getKey())) {\n-                return entry;\n-            }\n-        }\n-        return null;\n-    }\n-\n-\n-    /**\n-     *  Converts the given hash code into an index into the\n-     *  hash table.\n-     */\n-    private int indexFor(int hash) {\n-        // mix the bits to avoid bucket collisions...\n-        hash += ~(hash << 15);\n-        hash ^= (hash >>> 10);\n-        hash += (hash << 3);\n-        hash ^= (hash >>> 6);\n-        hash += ~(hash << 11);\n-        hash ^= (hash >>> 16);\n-        return hash & (table.length - 1);\n-    }\n-\n-\n-\n-    /**\n-     *  Resizes this hash table by doubling its capacity.\n-     *  This is an expensive operation, as entries must\n-     *  be copied from the old smaller table to the new \n-     *  bigger table.\n-     */\n-    private void resize() {\n-        Entry[] old = table;\n-        table = new Entry[old.length * 2];\n-\n-        for (int i = 0; i < old.length; i++) {\n-            Entry next = old[i];\n-            while (next != null) {\n-                Entry entry = next;\n-                next = next.next;\n-                int index = indexFor(entry.hash);\n-                entry.next = table[index];\n-                table[index] = entry;\n-            }\n-            old[i] = null;\n-        }\n-        threshold = (int)(table.length * loadFactor);\n-    }\n-\n-\n+        } else {\n+            return super.getEntry(key);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Purges stale mappings from this map before read operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     * \n+     * @since Commons Collections 3.1\n+     */\n+    protected void purgeBeforeRead() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map before write operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     * \n+     * @since Commons Collections 3.1\n+     */\n+    protected void purgeBeforeWrite() {\n+        purge();\n+    }\n \n     /**\n      * Purges stale mappings from this map.\n-     * <p>\n-     * Ordinarily, stale mappings are only removed during\n-     * a write operation, although this method is called for both\n-     * read and write operations to maintain a consistent state.\n      * <p>\n      * Note that this method is not synchronized!  Special\n      * care must be taken if, for instance, you want stale\n      * mappings to be removed on a periodic basis by some\n      * background thread.\n-     */\n-    private void purge() {\n+     * \n+     * @since Commons Collections 3.1\n+     */\n+    protected void purge() {\n         Reference ref = queue.poll();\n         while (ref != null) {\n             purge(ref);\n             ref = queue.poll();\n         }\n     }\n-\n \n     private void purge(Reference ref) {\n         // The hashCode of the reference is the hashCode of the\n         // mapping key, even if the reference refers to the \n         // mapping value...\n         int hash = ref.hashCode();\n-        int index = indexFor(hash);\n-        Entry previous = null;\n-        Entry entry = table[index];\n+        int index = hashIndex(hash, data.length);\n+        HashEntry previous = null;\n+        HashEntry entry = data[index];\n         while (entry != null) {\n-            if (entry.purge(ref)) {\n+            if (((ReferenceEntry) entry).purge(ref)) {\n                 if (previous == null) {\n-                    table[index] = entry.next;\n+                    data[index] = entry.next;\n                 } else {\n                     previous.next = entry.next;\n                 }\n \n     }\n \n-\n-    /**\n-     *  Returns the size of this map.\n-     *\n-     *  @return  the size of this map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of the map.\n+     * \n+     * @return the size\n      */\n     public int size() {\n-        purge();\n-        return size;\n-    }\n-\n-\n-    /**\n-     *  Returns <code>true</code> if this map is empty.\n-     *\n-     *  @return <code>true</code> if this map is empty\n+        purgeBeforeRead();\n+        return super.size();\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     * \n+     * @return true if the map is currently size zero\n      */\n     public boolean isEmpty() {\n-        purge();\n-        return size == 0;\n-    }\n-\n-\n-    /**\n-     *  Returns <code>true</code> if this map contains the given key.\n-     *\n-     *  @return true if the given key is in this map\n+        purgeBeforeRead();\n+        return super.isEmpty();\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n      */\n     public boolean containsKey(Object key) {\n-        purge();\n+        purgeBeforeRead();\n         Entry entry = getEntry(key);\n         if (entry == null) {\n             return false;\n         }\n-        return entry.getValue() != null;\n-    }\n-\n-\n-    /**\n-     *  Returns the value associated with the given key, if any.\n-     *\n-     *  @return the value associated with the given key, or <code>null</code>\n-     *   if the key maps to no value\n+        return (entry.getValue() != null);\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        purgeBeforeRead();\n+        if (value == null) {\n+            return false;\n+        }\n+        return super.containsValue(value);\n+    }\n+\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n      */\n     public Object get(Object key) {\n-        purge();\n+        purgeBeforeRead();\n         Entry entry = getEntry(key);\n         if (entry == null) {\n             return null;\n \n \n     /**\n-     *  Associates the given key with the given value.<p>\n-     *  Neither the key nor the value may be null.\n-     *\n-     *  @param key  the key of the mapping\n-     *  @param value  the value of the mapping\n-     *  @return  the last value associated with that key, or \n-     *   null if no value was associated with the key\n-     *  @throws NullPointerException if either the key or value\n-     *   is null\n+     * Puts a key-value mapping into this map.\n+     * Neither the key nor the value may be null.\n+     * \n+     * @param key  the key to add, must not be null\n+     * @param value  the value to add, must not be null\n+     * @return the value previously mapped to this key, null if none\n+     * @throws NullPointerException if either the key or value is null\n      */\n     public Object put(Object key, Object value) {\n         if (key == null) {\n             throw new NullPointerException(\"null values not allowed\");\n         }\n \n-        purge();\n-        if (size + 1 > threshold) {\n-            resize();\n-        }\n-\n-        int hash = key.hashCode();\n-        int index = indexFor(hash);\n-        Entry entry = table[index];\n-        while (entry != null) {\n-            if ((hash == entry.hash) && key.equals(entry.getKey())) {\n-                Object result = entry.getValue();\n-                entry.setValue(value);\n-                return result;\n-            }\n-            entry = entry.next;\n-        }\n-        this.size++; \n-        modCount++;\n-        key = toReference(keyType, key, hash);\n-        value = toReference(valueType, value, hash);\n-        table[index] = new Entry(key, hash, value, table[index]);\n-        return null;\n-    }\n-\n-\n-    /**\n-     *  Removes the key and its associated value from this map.\n-     *\n-     *  @param key  the key to remove\n-     *  @return the value associated with that key, or null if\n-     *   the key was not in the map\n+        purgeBeforeWrite();\n+        return super.put(key, value);\n+    }\n+    \n+    /**\n+     * Removes the specified mapping from this map.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n      */\n     public Object remove(Object key) {\n         if (key == null) {\n             return null;\n         }\n-        purge();\n-        int hash = key.hashCode();\n-        int index = indexFor(hash);\n-        Entry previous = null;\n-        Entry entry = table[index];\n-        while (entry != null) {\n-            if ((hash == entry.hash) && key.equals(entry.getKey())) {\n-                if (previous == null) {\n-                    table[index] = entry.next;\n-                } else {\n-                    previous.next = entry.next;\n-                }\n-                this.size--;\n-                modCount++;\n-                return entry.getValue();\n-            }\n-            previous = entry;\n-            entry = entry.next;\n-        }\n-        return null;\n-    }\n-\n-\n-    /**\n-     *  Clears this map.\n+        purgeBeforeWrite();\n+        return super.remove(key);\n+    }\n+\n+    /**\n+     * Clears this map.\n      */\n     public void clear() {\n-        Arrays.fill(table, null);\n-        size = 0;\n+        super.clear();\n         while (queue.poll() != null) {} // drain the queue\n     }\n \n-\n-    /**\n-     *  Returns a set view of this map's entries.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison.\n+     * \n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal\n+     * @since Commons Collections 3.1\n+     */\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n+        return (key1 == key2 || key1.equals(key2));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a ReferenceEntry instead of a HashEntry.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     * @since Commons Collections 3.1\n+     */\n+    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n+        return new ReferenceEntry(this, next, hashCode, key, value);\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * \n+     * @return the entrySet iterator\n+     * @since Commons Collections 3.1\n+     */\n+    protected Iterator createEntrySetIterator() {\n+        return new ReferenceEntrySetIterator(this);\n+    }\n+\n+    /**\n+     * Creates an key set iterator.\n+     * \n+     * @return the keySet iterator\n+     * @since Commons Collections 3.1\n+     */\n+    protected Iterator createKeySetIterator() {\n+        return new ReferenceKeySetIterator(this);\n+    }\n+\n+    /**\n+     * Creates an values iterator.\n+     * \n+     * @return the values iterator\n+     * @since Commons Collections 3.1\n+     */\n+    protected Iterator createValuesIterator() {\n+        return new ReferenceValuesIterator(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of this map's entries.\n+     * The <code>setValue()</code> method on the entries has no effect.\n      *\n-     *  @return a set view of this map's entries\n+     * @return a set view of this map's entries\n      */\n     public Set entrySet() {\n-        if (entrySet != null) {\n-            return entrySet;\n-        } \n-        entrySet = new AbstractSet() {\n-            public int size() {\n-                return ReferenceMap.this.size();\n-            }\n-\n-            public void clear() {\n-                ReferenceMap.this.clear();\n-            }\n-\n-            public boolean contains(Object obj) {\n-                if (obj == null) {\n-                    return false;\n-                }\n-                if (obj instanceof Map.Entry == false) {\n-                    return false;\n-                }\n-                Map.Entry e = (Map.Entry) obj;\n-                Entry e2 = getEntry(e.getKey());\n-                return (e2 != null) && e.equals(e2);\n-            }\n-\n-            public boolean remove(Object obj) {\n-                boolean r = contains(obj);\n-                if (r) {\n-                    Map.Entry e = (Map.Entry) obj;\n-                    ReferenceMap.this.remove(e.getKey());\n-                }\n-                return r;\n-            }\n-\n-            public Iterator iterator() {\n-                return new EntryIterator();\n-            }\n-\n-            public Object[] toArray() {\n-                return toArray(new Object[0]);\n-            }\n-\n-            public Object[] toArray(Object[] arr) {\n-                ArrayList list = new ArrayList();\n-                Iterator iterator = iterator();\n-                while (iterator.hasNext()) {\n-                    Entry e = (Entry)iterator.next();\n-                    list.add(new DefaultMapEntry(e.getKey(), e.getValue()));\n-                }\n-                return list.toArray(arr);\n-            }\n-        };\n+        if (entrySet == null) {\n+            entrySet = new ReferenceEntrySet(this);\n+        }\n         return entrySet;\n     }\n-\n-\n-    /**\n-     *  Returns a set view of this map's keys.\n+    \n+    /**\n+     * EntrySet implementation.\n+     */\n+    static class ReferenceEntrySet extends EntrySet {\n+        \n+        protected ReferenceEntrySet(AbstractHashedMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        public Object[] toArray(Object[] arr) {\n+            // special implementation to handle disappearing entries\n+            ArrayList list = new ArrayList();\n+            Iterator iterator = iterator();\n+            while (iterator.hasNext()) {\n+                Entry e = (Entry) iterator.next();\n+                list.add(new DefaultMapEntry(e.getKey(), e.getValue()));\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of this map's keys.\n      *\n-     *  @return a set view of this map's keys\n+     * @return a set view of this map's keys\n      */\n     public Set keySet() {\n-        if (keySet != null) return keySet;\n-        keySet = new AbstractSet() {\n-            public int size() {\n-                return ReferenceMap.this.size();\n-            }\n-\n-            public Iterator iterator() {\n-                return new KeyIterator();\n-            }\n-\n-            public boolean contains(Object obj) {\n-                return containsKey(obj);\n-            }\n-\n-\n-            public boolean remove(Object obj) {\n-                Object r = ReferenceMap.this.remove(obj);\n-                return r != null;\n-            }\n-\n-            public void clear() {\n-                ReferenceMap.this.clear();\n-            }\n-\n-            public Object[] toArray() {\n-                return toArray(new Object[0]);\n-            }\n-\n-            public Object[] toArray(Object[] arr) {\n-                Collection c = new ArrayList(size());\n-                for (Iterator it = iterator(); it.hasNext(); ) {\n-                    c.add(it.next());\n-                }\n-                return c.toArray(arr);\n-            }\n-        };\n+        if (keySet == null) {\n+            keySet = new ReferenceKeySet(this);\n+        }\n         return keySet;\n     }\n-\n-\n-    /**\n-     *  Returns a collection view of this map's values.\n+    \n+    /**\n+     * KeySet implementation.\n+     */\n+    static class ReferenceKeySet extends KeySet {\n+        \n+        protected ReferenceKeySet(AbstractHashedMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        public Object[] toArray(Object[] arr) {\n+            // special implementation to handle disappearing keys\n+            List list = new ArrayList(parent.size());\n+            for (Iterator it = iterator(); it.hasNext(); ) {\n+                list.add(it.next());\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a collection view of this map's values.\n      *\n-     *  @return a collection view of this map's values.\n+     * @return a set view of this map's values\n      */\n     public Collection values() {\n-        if (values != null) return values;\n-        values = new AbstractCollection()  {\n-            public int size() {\n-                return ReferenceMap.this.size();\n-            }\n-\n-            public void clear() {\n-                ReferenceMap.this.clear();\n-            }\n-\n-            public Iterator iterator() {\n-                return new ValueIterator();\n-            }\n-\n-            public Object[] toArray() {\n-                return toArray(new Object[0]);\n-            }\n-\n-            public Object[] toArray(Object[] arr) {\n-                Collection c = new ArrayList(size());\n-                for (Iterator it = iterator(); it.hasNext(); ) {\n-                    c.add(it.next());\n-                }\n-                return c.toArray(arr);\n-            }\n-        };\n+        if (values == null) {\n+            values = new ReferenceValues(this);\n+        }\n         return values;\n+    }\n+    \n+    /**\n+     * Values implementation.\n+     */\n+    static class ReferenceValues extends Values {\n+        \n+        protected ReferenceValues(AbstractHashedMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        public Object[] toArray(Object[] arr) {\n+            // special implementation to handle disappearing values\n+            List list = new ArrayList(parent.size());\n+            for (Iterator it = iterator(); it.hasNext(); ) {\n+                list.add(it.next());\n+            }\n+            return list.toArray(arr);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      * If getKey() or getValue() returns null, it means\n      * the mapping is stale and should be removed.\n      */\n-    private class Entry implements Map.Entry, KeyValue {\n-\n-        Object key;\n-        Object value;\n-        int hash;\n-        Entry next;\n-\n-        public Entry(Object key, int hash, Object value, Entry next) {\n-            this.key = key;\n-            this.hash = hash;\n-            this.value = value;\n-            this.next = next;\n+    protected static class ReferenceEntry extends HashEntry {\n+        /** The parent map */\n+        protected final ReferenceMap parent;\n+\n+        /**\n+         * Creates a new entry object for the ReferenceMap.\n+         * \n+         * @param parent  the parent map\n+         * @param next  the next entry in the hash bucket\n+         * @param hashCode  the hash code of the key\n+         * @param key  the key\n+         * @param value  the value\n+         */\n+        public ReferenceEntry(ReferenceMap parent, HashEntry next, int hashCode, Object key, Object value) {\n+            super(next, hashCode, null, null);\n+            this.parent = parent;\n+            this.key = toReference(parent.keyType, key, hashCode);\n+            this.value = toReference(parent.valueType, value, hashCode);\n         }\n \n         public Object getKey() {\n-            return (keyType > HARD) ? ((Reference)key).get() : key;\n+            return (parent.keyType > HARD) ? ((Reference) key).get() : key;\n         }\n \n         public Object getValue() {\n-            return (valueType > HARD) ? ((Reference)value).get() : value;\n+            return (parent.valueType > HARD) ? ((Reference) value).get() : value;\n         }\n \n         public Object setValue(Object obj) {\n             Object old = getValue();\n-            if (valueType > HARD) {\n+            if (parent.valueType > HARD) {\n                 ((Reference)value).clear();\n             }\n-            value = toReference(valueType, obj, hash);\n+            value = toReference(parent.valueType, obj, hashCode);\n             return old;\n         }\n \n             return key.equals(getKey()) && value.equals(getValue());\n         }\n \n-        public int hashCode() {\n-            Object v = getValue();\n-            return hash ^ ((v == null) ? 0 : v.hashCode());\n-        }\n-\n-        public String toString() {\n-            return getKey() + \"=\" + getValue();\n+        /**\n+         * Constructs a reference of the given type to the given referent.\n+         * The reference is registered with the queue for later purging.\n+         *\n+         * @param type  HARD, SOFT or WEAK\n+         * @param referent  the object to refer to\n+         * @param hash  the hash code of the <i>key</i> of the mapping;\n+         *    this number might be different from referent.hashCode() if\n+         *    the referent represents a value and not a key\n+         * @since Commons Collections 3.1\n+         */\n+        protected Object toReference(int type, Object referent, int hash) {\n+            switch (type) {\n+                case HARD: return referent;\n+                case SOFT: return new SoftRef(hash, referent, parent.queue);\n+                case WEAK: return new WeakRef(hash, referent, parent.queue);\n+                default: throw new Error();\n+            }\n         }\n \n         boolean purge(Reference ref) {\n-            boolean r = (keyType > HARD) && (key == ref);\n-            r = r || ((valueType > HARD) && (value == ref));\n+            boolean r = (parent.keyType > HARD) && (key == ref);\n+            r = r || ((parent.valueType > HARD) && (value == ref));\n             if (r) {\n-                if (keyType > HARD) {\n+                if (parent.keyType > HARD) {\n                     ((Reference)key).clear();\n                 }\n-                if (valueType > HARD) {\n+                if (parent.valueType > HARD) {\n                     ((Reference)value).clear();\n-                } else if (purgeValues) {\n+                } else if (parent.purgeValues) {\n                     value = null;\n                 }\n             }\n             return r;\n         }\n-    }\n-\n+        \n+        ReferenceEntry next() {\n+            return (ReferenceEntry) next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * The EntrySet iterator.\n      */\n-    private class EntryIterator implements Iterator {\n+    static class ReferenceEntrySetIterator implements Iterator {\n+        /** The parent map */\n+        final ReferenceMap parent;\n+        \n         // These fields keep track of where we are in the table.\n         int index;\n-        Entry entry;\n-        Entry previous;\n+        ReferenceEntry entry;\n+        ReferenceEntry previous;\n \n         // These Object fields provide hard references to the\n         // current and next entry; this assures that if hasNext()\n \n         int expectedModCount;\n \n-        public EntryIterator() {\n-            index = (size() != 0 ? table.length : 0);\n+        public ReferenceEntrySetIterator(ReferenceMap parent) {\n+            super();\n+            this.parent = parent;\n+            index = (parent.size() != 0 ? parent.data.length : 0);\n             // have to do this here!  size() invocation above\n             // may have altered the modCount.\n-            expectedModCount = modCount;\n+            expectedModCount = parent.modCount;\n         }\n \n         public boolean hasNext() {\n             checkMod();\n             while (nextNull()) {\n-                Entry e = entry;\n+                ReferenceEntry e = entry;\n                 int i = index;\n                 while ((e == null) && (i > 0)) {\n                     i--;\n-                    e = table[i];\n+                    e = (ReferenceEntry) parent.data[i];\n                 }\n                 entry = e;\n                 index = i;\n                 nextKey = e.getKey();\n                 nextValue = e.getValue();\n                 if (nextNull()) {\n-                    entry = entry.next;\n+                    entry = entry.next();\n                 }\n             }\n             return true;\n         }\n \n         private void checkMod() {\n-            if (modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n         }\n                 throw new NoSuchElementException();\n             }\n             previous = entry;\n-            entry = entry.next;\n+            entry = entry.next();\n             currentKey = nextKey;\n             currentValue = nextValue;\n             nextKey = null;\n             if (previous == null) {\n                 throw new IllegalStateException();\n             }\n-            ReferenceMap.this.remove(currentKey);\n+            parent.remove(currentKey);\n             previous = null;\n             currentKey = null;\n             currentValue = null;\n-            expectedModCount = modCount;\n+            expectedModCount = parent.modCount;\n+        }\n+    }\n+\n+    /**\n+     * The keySet iterator.\n+     */\n+    static class ReferenceKeySetIterator extends ReferenceEntrySetIterator {\n+        \n+        ReferenceKeySetIterator(ReferenceMap parent) {\n+            super(parent);\n+        }\n+        \n+        public Object next() {\n+            return nextEntry().getKey();\n         }\n     }\n \n     /**\n      * The values iterator.\n      */\n-    private class ValueIterator extends EntryIterator {\n+    static class ReferenceValuesIterator extends ReferenceEntrySetIterator {\n+        \n+        ReferenceValuesIterator(ReferenceMap parent) {\n+            super(parent);\n+        }\n+        \n         public Object next() {\n             return nextEntry().getValue();\n-        }\n-    }\n-\n-    /**\n-     * The keySet iterator.\n-     */\n-    private class KeyIterator extends EntryIterator {\n-        public Object next() {\n-            return nextEntry().getKey();\n         }\n     }\n \n     /**\n      * A soft reference holder.\n      */\n-    private static class SoftRef extends SoftReference {\n+    static class SoftRef extends SoftReference {\n         private int hash;\n \n         public SoftRef(int hash, Object r, ReferenceQueue q) {\n     /**\n      * A weak reference holder.\n      */\n-    private static class WeakRef extends WeakReference {\n+    static class WeakRef extends WeakReference {\n         private int hash;\n \n         public WeakRef(int hash, Object r, ReferenceQueue q) {\n--- a/src/test/org/apache/commons/collections/map/TestReferenceMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestReferenceMap.java\n /**\n  * Tests for ReferenceMap. \n  * \n- * @version $Revision: 1.3 $ $Date: 2004/02/18 01:20:38 $\n+ * @version $Revision: 1.4 $ $Date: 2004/04/01 00:07:48 $\n  *\n  * @author Paul Jack\n  */\n-public class TestReferenceMap extends AbstractTestMap {\n+public class TestReferenceMap extends AbstractTestIterableMap {\n \n     public TestReferenceMap(String testName) {\n         super(testName);", "timestamp": 1080778068, "metainfo": ""}