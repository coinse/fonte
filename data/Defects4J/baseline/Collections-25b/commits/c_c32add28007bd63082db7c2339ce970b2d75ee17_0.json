{"sha": "c32add28007bd63082db7c2339ce970b2d75ee17", "log": "Add LRUMap implementation Refactor serialization behaviour in HashedMap hierarchy   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/HashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/HashedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.7 2003/12/06 14:02:11 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.8 2003/12/07 01:23:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.7 $ $Date: 2003/12/06 14:02:11 $\n+ * @version $Revision: 1.8 $ $Date: 2003/12/07 01:23:54 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n     protected static final Object NULL = new Object();\n     \n     /** Load factor, normally 0.75 */\n-    protected final float loadFactor;\n+    protected transient float loadFactor;\n     /** The size of the map */\n     protected transient int size;\n     /** Map entries */\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @throws IllegalArgumentException if the initial capacity is less than one\n-     * @throws IllegalArgumentException if the load factor is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n      */\n     public HashedMap(int initialCapacity, float loadFactor) {\n         super();\n         if (initialCapacity < 1) {\n             throw new IllegalArgumentException(\"Initial capacity must be greater than 0\");\n         }\n-        if (loadFactor <= 0 || Float.isNaN(loadFactor)) {\n+        if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n             throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n         }\n         this.loadFactor = loadFactor;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                 Object oldValue = entry.getValue();\n-                entry.setValue(value);\n+                updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n         \n-        modCount++;\n-        add(hashCode, index, key, value);\n+        addMapping(index, hashCode, key, value);\n         return null;\n     }\n \n         key = convertKey(key);\n         int hashCode = hash(key);\n         int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index]; \n+        HashEntry entry = data[index];\n         HashEntry previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                modCount++;\n-                if (previous == null) {\n-                    data[index] = entry.next;\n-                } else {\n-                    previous.next = entry.next;\n-                }\n-                size--;\n-                return destroyEntry(entry);\n+                Object oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n             }\n             previous = entry;\n             entry = entry.next;\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Gets the entry mapped to the key specified.\n-     * \n-     * @param key  the key\n-     * @return the entry, null if no match\n-     */\n-    protected HashEntry getEntry(Object key) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n-        while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                return entry;\n-            }\n-            entry = entry.next;\n-        }\n-        return null;\n-    }\n-\n     /**\n      * Converts input keys to another object for storage in the map.\n      * This implementation masks nulls.\n         return hashCode & (dataSize - 1);\n     }\n     \n-    /**\n-     * Creates an entry to store the data.\n-     * This implementation creates a HashEntry instance.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     * <p>\n+     * This method exists for subclasses that may need to perform a multi-step\n+     * process accessing the entry. The public methods in this class don't use this\n+     * method to gain a small performance boost.\n+     * \n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    protected HashEntry getEntry(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry;\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates an existing key-value mapping to change the value.\n+     * <p>\n+     * This implementation calls <code>setValue()</code> on the entry.\n+     * Subclasses could override to handle changes to the map.\n+     * \n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     * @return value  the previous value\n+     */\n+    protected void updateEntry(HashEntry entry, Object newValue) {\n+        entry.setValue(newValue);\n+    }\n+    \n+    /**\n+     * Reuses an existing key-value mapping, storing completely new data.\n+     * <p>\n+     * This implementation sets all the data fields on the entry.\n+     * Subclasses could populate additional entry fields.\n+     * \n+     * @param entry  the entry to update, not null\n+     * @param hashIndex  the index in the data array\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void reuseEntry(HashEntry entry, int hashIndex, int hashCode, Object key, Object value) {\n+        entry.next = data[hashIndex];\n+        entry.hashCode = hashCode;\n+        entry.key = key;\n+        entry.value = value;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * <p>\n+     * This implementation calls <code>createEntry()</code>, <code>addEntry()</code>\n+     * and <code>checkCapacity</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control adds to the map.\n+     * \n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n+        modCount++;\n+        HashEntry entry = createEntry(data[hashIndex], hashCode, key, value);\n+        addEntry(entry, hashIndex);\n+        size++;\n+        checkCapacity();\n+    }\n+    \n+    /**\n+     * Creates an entry to store the key-value data.\n+     * <p>\n+     * This implementation creates a new HashEntry instance.\n      * Subclasses can override this to return a different storage class,\n      * or implement caching.\n      * \n     }\n     \n     /**\n-     * Kills an entry ready for the garbage collector.\n-     * This implementation prepares the HashEntry for garbage collection.\n-     * Subclasses can override this to implement caching (override clear as well).\n-     * \n-     * @param entry  the entry to destroy\n-     * @return the value from the entry\n-     */\n-    protected Object destroyEntry(HashEntry entry) {\n-        entry.next = null;\n-        return entry.value;\n-    }\n-    \n-    /**\n-     * Adds a new key-value mapping into this map.\n-     * Subclasses could override to fix the size of the map.\n-     * \n+     * Adds an entry into this map.\n+     * <p>\n+     * This implementation adds the entry to the data storage table.\n+     * Subclasses could override to handle changes to the map.\n+     * \n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n      * @param key  the key to add\n      * @param value  the value to add\n      * @return the value previously mapped to this key, null if none\n      */\n-    protected void add(int hashCode, int hashIndex, Object key, Object value) {\n-        data[hashIndex] = createEntry(data[hashIndex], hashCode, key, value);\n-        if (size++ >= threshold) {\n+    protected void addEntry(HashEntry entry, int hashIndex) {\n+        data[hashIndex] = entry;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes a mapping from the map.\n+     * <p>\n+     * This implementation calls <code>removeEntry()</code> and <code>destroyEntry()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control removals from the map.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeMapping(HashEntry entry, int hashIndex, HashEntry previous) {\n+        modCount++;\n+        removeEntry(entry, hashIndex, previous);\n+        size--;\n+        destroyEntry(entry);\n+    }\n+    \n+    /**\n+     * Removes an entry from the chain stored in a particular index.\n+     * <p>\n+     * This implementation removes the entry from the data storage table.\n+     * The size is not updated.\n+     * Subclasses could override to handle changes to the map.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n+        if (previous == null) {\n+            data[hashIndex] = entry.next;\n+        } else {\n+            previous.next = entry.next;\n+        }\n+    }\n+    \n+    /**\n+     * Kills an entry ready for the garbage collector.\n+     * <p>\n+     * This implementation prepares the HashEntry for garbage collection.\n+     * Subclasses can override this to implement caching (override clear as well).\n+     * \n+     * @param entry  the entry to destroy\n+     */\n+    protected void destroyEntry(HashEntry entry) {\n+        entry.next = null;\n+        entry.key = null;\n+        entry.value = null;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the capacity of the map and enlarges it if necessary.\n+     * <p>\n+     * This implementation uses the threshold to check if the map needs enlarging\n+     */\n+    protected void checkCapacity() {\n+        if (size >= threshold) {\n             ensureCapacity(data.length * 2);\n         }\n     }\n             this.key = key;\n             this.value = value;\n         }\n+        \n         public Object getKey() {\n             return (key == NULL ? null : key);\n         }\n+        \n         public Object getValue() {\n             return value;\n         }\n+        \n         public Object setValue(Object value) {\n             Object old = this.value;\n             this.value = value;\n             return old;\n         }\n+        \n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n                 (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                 (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n         }\n+        \n         public int hashCode() {\n             return (getKey() == null ? 0 : getKey().hashCode()) ^\n                    (getValue() == null ? 0 : getValue().hashCode()); \n         }\n+        \n         public String toString() {\n             return new StringBuffer().append(getKey()).append('=').append(getValue()).toString();\n         }\n     \n     //-----------------------------------------------------------------------\n     /**\n+     * Write the data of subclasses.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * not load subclass fields until this object is setup. In other words the readObject\n+     * on this class is performed before that on the subclass. Unfortunately, data setup in\n+     * the subclass may affect the ability of methods such as put() to work properly.\n+     * <p>\n+     * The solution adopted here is to have a method called by this class as part of the\n+     * serialization and deserialization process. Override this method if the subclass\n+     * stores additional data needed for put() to work.\n+     * A sub-subclass must call super.doWriteObject().\n+     */\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        // do nothing\n+    }\n+\n+    /**\n+     * Read the data of subclasses.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * not load subclass fields until this object is setup. In other words the readObject\n+     * on this class is performed before that on the subclass. Unfortunately, data setup in\n+     * the subclass may affect the ability of methods such as put() to work properly.\n+     * <p>\n+     * The solution adopted here is to have a method called by this class as part of the\n+     * serialization and deserialization process. Override this method if the subclass\n+     * stores additional data needed for put() to work.\n+     * A sub-subclass must call super.doReadObject().\n+     */\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        // do nothing\n+    }\n+    \n+    /**\n      * Write the map out using a custom routine.\n      */\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n+        out.writeFloat(loadFactor);\n         out.writeInt(data.length);\n         out.writeInt(size);\n+        doWriteObject(out);\n         for (MapIterator it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());\n             out.writeObject(it.getValue());\n      */\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n+        loadFactor = in.readFloat();\n         int capacity = in.readInt();\n         int size = in.readInt();\n+        doReadObject(in);\n+        init();\n         data = new HashEntry[capacity];\n-        init();\n         for (int i = 0; i < size; i++) {\n             Object key = in.readObject();\n             Object value = in.readObject();\n             put(key, value);\n         }\n-    }\n+        threshold = calculateThreshold(data.length, loadFactor);\n+    }\n+    \n     //-----------------------------------------------------------------------\n     /**\n      * Clones the map without cloning the keys or values.\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/LRUMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LRUMap.java,v 1.1 2003/12/07 01:23:54 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.OrderedMap;\n+\n+/**\n+ * A <code>Map</code> implementation with a fixed maximum size which removes\n+ * the least recently used entry if an entry is added when full.\n+ * <p>\n+ * The least recently used algorithm works on the get and put operations only.\n+ * Iteration of any kind, including setting the value by iteration, does not\n+ * change the order. Queries such as containsKey and containsValue or access\n+ * via views also do not change the order.\n+ * <p>\n+ * The map implements <code>OrderedMap</code> and entries may be queried using\n+ * the bidirectional <code>OrderedMapIterator</code>. The order returned is\n+ * most recently used to least recently used. Iterators from map views can \n+ * also be cast to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * NOTE: The order of the map has changed from the previous version located\n+ * in the main collections package. The map is now ordered most recently used\n+ * to least recently used.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/07 01:23:54 $\n+ *\n+ * @author James Strachan\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ */\n+public class LRUMap extends LinkedMap implements OrderedMap {\n+    \n+    /** Serialisation version */\n+    static final long serialVersionUID = -2848625157350244215L;\n+    /** Default maximum size */\n+    protected static final int DEFAULT_MAX_SIZE = 100;\n+    \n+    /** Maximum size */\n+    private transient int maxSize;\n+\n+    /**\n+     * Constructs a new empty map with a maximum size of 100.\n+     */\n+    public LRUMap() {\n+        this(DEFAULT_MAX_SIZE, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified maximum size.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     */\n+    public LRUMap(int maxSize) {\n+        this(maxSize, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param maxSize  the maximum size of the map, -1 for no limit,\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public LRUMap(int maxSize, float loadFactor) {\n+        super((maxSize < 1 ? DEFAULT_CAPACITY : maxSize), loadFactor);\n+        if (maxSize < 1) {\n+            throw new IllegalArgumentException(\"LRUMap max size must be greater than 0\");\n+        }\n+        this.maxSize = maxSize;\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p>\n+     * The maximum size is set from the map's size.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     */\n+    public LRUMap(Map map) {\n+        this(map.size(), DEFAULT_LOAD_FACTOR);\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * <p>\n+     * This operation changes the position of the key in the map to the\n+     * most recently used position (first).\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key) {\n+        LinkEntry entry = (LinkEntry) getEntry(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        moveFirst(entry);\n+        return entry.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates an existing key-value mapping.\n+     * This implementation moves the updated entry to the top of the list.\n+     * \n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     * @return value  the previous value\n+     */\n+    protected void moveFirst(LinkEntry entry) {\n+        if (entry.before != header) {\n+            modCount++;\n+            // remove\n+            entry.after.before = entry.before;\n+            entry.before.after = entry.after;\n+            // add first\n+            entry.before = header;\n+            entry.after = header.after;\n+            header.after.before = entry;\n+            header.after = entry;\n+        }\n+    }\n+    \n+    /**\n+     * Updates an existing key-value mapping.\n+     * This implementation moves the updated entry to the top of the list.\n+     * \n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     * @return value  the previous value\n+     */\n+    protected void updateEntry(HashEntry entry, Object newValue) {\n+        moveFirst((LinkEntry) entry);  // handles modCount\n+        entry.setValue(newValue);\n+    }\n+    \n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * This implementation checks the LRU size and determines whether to\n+     * discard an entry or not.\n+     * \n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n+        if (size >= maxSize && removeLRU(header.before)) {\n+            LinkEntry entry = header.before;\n+            // remove from current location\n+            int removeIndex = hashIndex(entry.hashCode, data.length);\n+            HashEntry loop = data[removeIndex];\n+            HashEntry previous = null;\n+            while (loop != entry) {\n+                previous = loop;\n+                loop = loop.next;\n+            }\n+            modCount++;\n+            removeEntry(entry, removeIndex, previous);\n+            reuseEntry(entry, hashIndex, hashCode, key, value);\n+            addEntry(entry, hashIndex);\n+            \n+        } else {\n+            super.addMapping(hashIndex, hashCode, key, value);\n+        }\n+    }\n+    \n+    /**\n+     * Adds a new entry into this map using access order.\n+     * <p>\n+     * This implementation adds the entry to the data storage table and\n+     * to the start of the linked list.\n+     * \n+     * @param entry  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    protected void addEntry(HashEntry entry, int hashIndex) {\n+        LinkEntry link = (LinkEntry) entry;\n+        link.before = header;\n+        link.after = header.after;\n+        header.after.before = link;\n+        header.after = link;\n+        data[hashIndex] = entry;\n+    }\n+    \n+    /**\n+     * Subclass method to control removal of the least recently used entry from the map.\n+     * <p>\n+     * This method exists for subclasses to override. A subclass may wish to\n+     * provide cleanup of resources when an entry is removed. For example:\n+     * <pre>\n+     * protected boolean removeLRU(LinkEntry entry) {\n+     *   releaseResources(entry.getValue());  // release resources held by entry\n+     *   return true;  // actually delete entry\n+     * }\n+     * </pre>\n+     * <p>\n+     * Alternatively, a subclass may choose to not remove the entry or selectively\n+     * keep certain LRU entries. For example:\n+     * <pre>\n+     * protected boolean removeLRU(LinkEntry entry) {\n+     *   if (entry.getKey().toString().startsWith(\"System.\")) {\n+     *     return false;  // entry not removed from LRUMap\n+     *   } else {\n+     *     return true;  // actually delete entry\n+     *   }\n+     * }\n+     * </pre>\n+     * Note that the effect of not removing an LRU is for the Map to exceed the maximum size.\n+     * \n+     * @param entry  the entry to be removed\n+     */\n+    protected boolean removeLRU(LinkEntry entry) {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if this map is full and no new mappings can be added.\n+     *\n+     * @return <code>true</code> if the map is full\n+     */\n+    public boolean isFull() {\n+        return (size >= maxSize);\n+    }\n+\n+    /**\n+     * Gets the maximum size of the map (the bound).\n+     *\n+     * @return the maximum number of elements the map can hold\n+     */\n+    public int maxSize() {\n+        return maxSize;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the data of subclasses.\n+     * A sub-subclass must call super.doWriteObject().\n+     */\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeInt(maxSize);\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the data of subclasses.\n+     * A sub-subclass must call super.doReadObject().\n+     */\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        maxSize = in.readInt();\n+        super.doReadObject(in);\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.2 2003/12/06 14:02:11 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.3 2003/12/07 01:23:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n /**\n  * A <code>Map</code> implementation that maintains the order of the entries.\n- * The order maintained is by insertion.\n+ * In this implementation order is maintained is by original insertion, but\n+ * subclasses may work differently.\n  * <p>\n  * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n  * {@link org.apache.commons.collections.iterators.MapIterator MapIterator}\n  * <p>\n  * All the available iterators can be reset back to the start by casting to\n  * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * The implementation is also designed to be subclassed, with lots of useful\n+ * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/12/06 14:02:11 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/07 01:23:54 $\n  *\n  * @author java util LinkedHashMap\n  * @author Stephen Colebourne\n     static final long serialVersionUID = -1954063410665686469L;\n     \n     /** Header in the linked list */\n-    private transient LinkedEntry header;\n+    protected transient LinkEntry header;\n \n     /**\n      * Constructs a new empty map with default size and load factor.\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @throws IllegalArgumentException if the initial capacity is less than one\n-     * @throws IllegalArgumentException if the load factor is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n      */\n     public LinkedMap(int initialCapacity, float loadFactor) {\n         super(initialCapacity, loadFactor);\n      * Initialise this subclass during construction.\n      */\n     protected void init() {\n-        header = new LinkedEntry(null, -1, null, null);\n+        header = new LinkEntry(null, -1, null, null);\n         header.before = header.after = header;\n     }\n \n     public boolean containsValue(Object value) {\n         // override uses faster iterator\n         if (value == null) {\n-            for (LinkedEntry entry = header.after; entry != header; entry = entry.after) {\n+            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n                 if (entry.getValue() == null) {\n                     return true;\n                 }\n             }\n         } else {\n-            for (LinkedEntry entry = header.after; entry != header; entry = entry.after) {\n+            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n                 if (isEqualValue(value, entry.getValue())) {\n                     return true;\n                 }\n      * @return the next key\n      */\n     public Object nextKey(Object key) {\n-        LinkedEntry entry = (LinkedEntry) getEntry(key);\n+        LinkEntry entry = (LinkEntry) getEntry(key);\n         return (entry == null || entry.after == header ? null : entry.after.getKey());\n     }\n \n      * @return the previous key\n      */\n     public Object previousKey(Object key) {\n-        LinkedEntry entry = (LinkedEntry) getEntry(key);\n+        LinkEntry entry = (LinkEntry) getEntry(key);\n         return (entry == null || entry.before == header ? null : entry.before.getKey());\n     }\n \n     //-----------------------------------------------------------------------    \n     /**\n+     * Adds an entry into this map, maintaining insertion order.\n+     * <p>\n+     * This implementation adds the entry to the data storage table and\n+     * to the end of the linked list.\n+     * \n+     * @param entry  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    protected void addEntry(HashEntry entry, int hashIndex) {\n+        LinkEntry link = (LinkEntry) entry;\n+        link.after  = header;\n+        link.before = header.before;\n+        header.before.after = link;\n+        header.before = link;\n+        data[hashIndex] = entry;\n+    }\n+    \n+    /**\n      * Creates an entry to store the data.\n-     * This implementation creates a LinkEntry instance in the linked list.\n+     * <p>\n+     * This implementation creates a new LinkEntry instance.\n      * \n      * @param next  the next entry in sequence\n      * @param hashCode  the hash code to use\n      * @return the newly created entry\n      */\n     protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        LinkedEntry entry = new LinkedEntry(next, hashCode, key, value);\n-        entry.after  = header;\n-        entry.before = header.before;\n-        header.before.after = entry;\n-        header.before = entry;\n-        return entry;\n-    }\n-    \n-    /**\n-     * Kills an entry ready for the garbage collector.\n-     * This implementation manages the linked list and prepares the\n-     * LinkEntry for garbage collection.\n-     * \n-     * @param entry  the entry to destroy\n-     * @return the value from the entry\n-     */\n-    protected Object destroyEntry(HashEntry entry) {\n-        LinkedEntry link = (LinkedEntry) entry;\n+        return new LinkEntry(next, hashCode, key, value);\n+    }\n+    \n+    /**\n+     * Removes an entry from the map and the linked list.\n+     * <p>\n+     * This implementation removes the entry from the linked list chain, then\n+     * calls the superclass implementation.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n+        LinkEntry link = (LinkEntry) entry;\n         link.before.after = link.after;\n         link.after.before = link.before;\n-        link.next = null;\n         link.after = null;\n         link.before = null;\n-        return entry.value;\n+        super.removeEntry(entry, hashIndex, previous);\n     }\n     \n     //-----------------------------------------------------------------------\n         if (size == 0) {\n             return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n         }\n-        return new LinkedMapIterator(this);\n+        return new LinkMapIterator(this);\n     }\n \n     /**\n         if (size == 0) {\n             return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n         }\n-        return new LinkedMapIterator(this);\n+        return new LinkMapIterator(this);\n     }\n \n     /**\n      * MapIterator\n      */\n-    static class LinkedMapIterator extends LinkedIterator implements OrderedMapIterator {\n-        \n-        LinkedMapIterator(LinkedMap map) {\n+    static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n+        \n+        LinkMapIterator(LinkedMap map) {\n             super(map);\n         }\n \n     /**\n      * EntrySetIterator and MapEntry\n      */\n-    static class EntrySetIterator extends LinkedIterator {\n+    static class EntrySetIterator extends LinkIterator {\n         \n         EntrySetIterator(LinkedMap map) {\n             super(map);\n     /**\n      * ValuesIterator\n      */\n-    static class ValuesIterator extends LinkedIterator {\n+    static class ValuesIterator extends LinkIterator {\n         \n         ValuesIterator(LinkedMap map) {\n             super(map);\n     /**\n      * LinkEntry\n      */\n-    protected static class LinkedEntry extends HashEntry {\n-        \n-        LinkedEntry before;\n-        LinkedEntry after;\n-        \n-        protected LinkedEntry(HashEntry next, int hashCode, Object key, Object value) {\n+    protected static class LinkEntry extends HashEntry {\n+        \n+        protected LinkEntry before;\n+        protected LinkEntry after;\n+        \n+        protected LinkEntry(HashEntry next, int hashCode, Object key, Object value) {\n             super(next, hashCode, key, value);\n         }\n     }\n     /**\n      * Base Iterator\n      */\n-    protected static abstract class LinkedIterator\n+    protected static abstract class LinkIterator\n             implements OrderedIterator, ResettableIterator {\n                 \n-        private final LinkedMap map;\n-        private LinkedEntry current;\n-        private LinkedEntry next;\n-        private int expectedModCount;\n-        \n-        protected LinkedIterator(LinkedMap map) {\n+        protected final LinkedMap map;\n+        protected LinkEntry current;\n+        protected LinkEntry next;\n+        protected int expectedModCount;\n+        \n+        protected LinkIterator(LinkedMap map) {\n             super();\n             this.map = map;\n             this.next = map.header.after;\n             return (next.before != map.header);\n         }\n \n-        protected LinkedEntry nextEntry() {\n+        protected LinkEntry nextEntry() {\n             if (map.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n             return current;\n         }\n \n-        protected LinkedEntry previousEntry() {\n+        protected LinkEntry previousEntry() {\n             if (map.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            LinkedEntry previous = next.before;\n+            LinkEntry previous = next.before;\n             if (previous == map.header)  {\n                 throw new NoSuchElementException(HashedMap.NO_PREVIOUS_ENTRY);\n             }\n             return current;\n         }\n         \n-        protected LinkedEntry currentEntry() {\n+        protected LinkEntry currentEntry() {\n             return current;\n         }\n         \n--- a/src/test/org/apache/commons/collections/map/TestAll.java\n+++ b/src/test/org/apache/commons/collections/map/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.9 2003/12/03 19:04:41 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.10 2003/12/07 01:23:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.9 $ $Date: 2003/12/03 19:04:41 $\n+ * @version $Revision: 1.10 $ $Date: 2003/12/07 01:23:54 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestHashedMap.suite());\n         suite.addTest(TestIdentityMap.suite());\n         suite.addTest(TestLinkedMap.suite());\n+        suite.addTest(TestLRUMap.suite());\n         suite.addTest(TestReferenceMap.suite());\n         suite.addTest(TestStaticBucketMap.suite());\n         \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestLRUMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLRUMap.java,v 1.1 2003/12/07 01:23:54 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/12/07 01:23:54 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestLRUMap extends AbstractTestOrderedMap {\n+\n+    public TestLRUMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestLRUMap.class);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new LRUMap();\n+    }\n+\n+    public boolean isGetStructuralModify() {\n+        return true;\n+    }\n+    \n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLRU() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Iterator it = null;\n+        \n+        LRUMap map = new LRUMap(2);\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        \n+        map.put(keys[0], values[0]);\n+        assertEquals(1, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        \n+        map.put(keys[1], values[1]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        it = map.keySet().iterator();\n+        assertSame(keys[1], it.next());\n+        assertSame(keys[0], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[1], it.next());\n+        assertSame(values[0], it.next());\n+\n+        map.put(keys[2], values[2]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        it = map.keySet().iterator();\n+        assertSame(keys[2], it.next());\n+        assertSame(keys[1], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[2], it.next());\n+        assertSame(values[1], it.next());\n+\n+        map.put(keys[2], values[0]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        it = map.keySet().iterator();\n+        assertSame(keys[2], it.next());\n+        assertSame(keys[1], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[0], it.next());\n+        assertSame(values[1], it.next());\n+\n+        map.put(keys[1], values[3]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        it = map.keySet().iterator();\n+        assertSame(keys[1], it.next());\n+        assertSame(keys[2], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[3], it.next());\n+        assertSame(values[0], it.next());\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap ordered = (OrderedMap) map;\n+        ((ResettableIterator) ordered.mapIterator()).reset();\n+        \n+        resetFull();\n+        ordered = (OrderedMap) map;\n+        List list = new ArrayList(ordered.keySet());\n+        ResettableIterator it = (ResettableIterator) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAccessOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Iterator it = null;\n+        \n+        resetEmpty();\n+        map.put(keys[1], values[1]);\n+        map.put(keys[0], values[0]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[0], it.next());\n+        assertSame(keys[1], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[0], it.next());\n+        assertSame(values[1], it.next());\n+\n+        // change to order\n+        map.put(keys[1], values[1]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[1], it.next());\n+        assertSame(keys[0], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[1], it.next());\n+        assertSame(values[0], it.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[1], it.next());\n+        assertSame(keys[0], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[2], it.next());\n+        assertSame(values[0], it.next());\n+\n+        // change to order\n+        map.put(keys[0], values[3]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[0], it.next());\n+        assertSame(keys[1], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[3], it.next());\n+        assertSame(values[2], it.next());\n+\n+        // change to order\n+        map.get(keys[1]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[1], it.next());\n+        assertSame(keys[0], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[2], it.next());\n+        assertSame(values[3], it.next());\n+\n+        // change to order\n+        map.get(keys[0]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[0], it.next());\n+        assertSame(keys[1], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[3], it.next());\n+        assertSame(values[2], it.next());\n+\n+        // no change to order\n+        map.get(keys[0]);\n+        it = map.keySet().iterator();\n+        assertSame(keys[0], it.next());\n+        assertSame(keys[1], it.next());\n+        it = map.values().iterator();\n+        assertSame(values[3], it.next());\n+        assertSame(values[2], it.next());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {  // override\n+        resetEmpty();\n+        OrderedMap ordered = (OrderedMap) map;\n+        try {\n+            ordered.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        resetFull();\n+        ordered = (OrderedMap) map;\n+        Object confirmedFirst = confirmed.keySet().iterator().next();\n+        ordered.get(confirmedFirst);\n+        assertEquals(confirmedFirst, ordered.firstKey());\n+    }\n+    \n+    public void testLastKey() {  // override\n+        resetEmpty();\n+        OrderedMap ordered = (OrderedMap) map;\n+        try {\n+            ordered.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        resetFull();\n+        ordered = (OrderedMap) map;\n+        Object confirmedFirst = confirmed.keySet().iterator().next();\n+        // access order, thus first in is now in last place\n+        assertEquals(confirmedFirst, ordered.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testNextKey() {  // override\n+        resetEmpty();\n+        OrderedMap ordered = (OrderedMap) map;\n+        assertEquals(null, ordered.nextKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, ordered.nextKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+        \n+        resetFull();\n+        ordered = (OrderedMap) map;\n+        List list = new ArrayList(confirmed.keySet());\n+        Collections.reverse(list);  // first into map is eldest\n+        Iterator it = list.iterator();\n+        Object confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            Object confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.nextKey(confirmedLast));\n+    }\n+    \n+    public void testPreviousKey() {  // override\n+        resetEmpty();\n+        OrderedMap ordered = (OrderedMap) map;\n+        assertEquals(null, ordered.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, ordered.previousKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.previousKey(null));\n+        }\n+        \n+        resetFull();\n+        ordered = (OrderedMap) map;\n+        List list = new ArrayList(confirmed.keySet());\n+        Iterator it = list.iterator();\n+        Object confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            Object confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.previousKey(confirmedLast));\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LRUMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LRUMap.fullCollection.version3.obj\");\n+//    }\n+}", "timestamp": 1070760234, "metainfo": ""}