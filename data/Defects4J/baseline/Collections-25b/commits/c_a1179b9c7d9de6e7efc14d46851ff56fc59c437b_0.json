{"sha": "a1179b9c7d9de6e7efc14d46851ff56fc59c437b", "log": "[COLLECTIONS-432] Add queue decorators.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/QueueUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.queue.PredicatedQueue;\n+import org.apache.commons.collections.queue.TransformedQueue;\n+import org.apache.commons.collections.queue.UnmodifiableQueue;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Queue} instances.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class QueueUtils {\n+\n+    /**\n+     * An empty unmodifiable queue.\n+     */\n+    public static final Queue<Object> EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());\n+\n+    /**\n+     * <code>QueueUtils</code> should not normally be instantiated.\n+     */\n+    private QueueUtils() {}\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns an unmodifiable queue backed by the given queue.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to make unmodifiable, must not be null\n+     * @return an unmodifiable queue backed by that queue\n+     * @throws IllegalArgumentException  if the Queue is null\n+     */\n+    public static <E> Queue<E> unmodifiableQueue(final Queue<E> queue) {\n+        return UnmodifiableQueue.unmodifiableQueue(queue);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) queue backed by the given queue.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the queue.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original queue after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to predicate, must not be null\n+     * @param predicate  the predicate used to evaluate new elements, must not be null\n+     * @return a predicated queue\n+     * @throws IllegalArgumentException  if the Queue or Predicate is null\n+     */\n+    public static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n+        return PredicatedQueue.predicatedQueue(queue, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed queue backed by the given queue.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Queue. It is important not to use the original queue after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified queue will not be transformed.\n+     * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to predicate, must not be null\n+     * @param transformer  the transformer for the queue, must not be null\n+     * @return a transformed queue backed by the given queue\n+     * @throws IllegalArgumentException  if the Queue or Transformer is null\n+     */\n+    public static <E> Queue<E> transformingQueue(final Queue<E> queue,\n+                                                 final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedQueue.transformingQueue(queue, transformer);\n+    }\n+\n+    /**\n+     * Get an empty <code>Queue</code>.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @return an empty {@link Queue}\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK, empty queue is compatible with any type\n+    public static <E> Queue<E> emptyQueue() {\n+        return (Queue<E>) EMPTY_QUEUE;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/queue/AbstractQueueDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another {@link Queue} to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated queue.\n+ *\n+ * @param <E> the type of the elements in the queue\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractQueueDecorator<E> extends AbstractCollectionDecorator<E>\n+        implements Queue<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2629815475789577029L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractQueueDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractQueueDecorator(final Queue<E> queue) {\n+        super(queue);\n+    }\n+\n+    /**\n+     * Gets the queue being decorated.\n+     * \n+     * @return the decorated queue\n+     */\n+    @Override\n+    protected Queue<E> decorated() {\n+        return (Queue<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public boolean offer(E obj) {\n+        return decorated().offer(obj);\n+    }\n+\n+    public E poll() {\n+        return decorated().poll();\n+    }\n+\n+    public E peek() {\n+        return decorated().peek();\n+    }\n+\n+    public E element() {\n+        return decorated().element();\n+    }\n+    \n+    public E remove() {\n+        return decorated().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/queue/PredicatedQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another {@link Queue} to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This queue exists to provide validation for the decorated queue.\n+ * It is normally created to decorate an empty queue.\n+ * If an object cannot be added to the queue, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the queue.\n+ * <pre>Queue queue = PredicatedQueue.predicatedQueue(new UnboundedFifoQueue(), NotNullPredicate.INSTANCE);</pre>\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PredicatedQueue<E> extends PredicatedCollection<E> implements Queue<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2307609000539943581L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) queue.\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * are validated.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param Queue  the queue to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated queue\n+     * @throws IllegalArgumentException if queue or predicate is null\n+     * @throws IllegalArgumentException if the queue contains invalid elements\n+     */\n+    public static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue,\n+                                                          final Predicate<? super E> predicate) {\n+        return new PredicatedQueue<E>(Queue, predicate);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if Queue or predicate is null\n+     * @throws IllegalArgumentException if the Queue contains invalid elements\n+     */\n+    protected PredicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n+        super(queue, predicate);\n+    }\n+\n+    /**\n+     * Gets the queue being decorated.\n+     * \n+     * @return the decorated queue\n+     */\n+    @Override\n+    protected Queue<E> decorated() {\n+        return (Queue<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Override to validate the object being added to ensure it matches\n+     * the predicate.\n+     * \n+     * @param object  the object being added\n+     * @return the result of adding to the underlying queue\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    public boolean offer(E object) {\n+        validate(object);\n+        return decorated().offer(object);\n+    }\n+\n+    public E poll() {\n+        return decorated().poll();\n+    }\n+\n+    public E peek() {\n+        return decorated().peek();\n+    }\n+\n+    public E element() {\n+        return decorated().element();\n+    }\n+\n+    public E remove() {\n+        return decorated().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/queue/TransformedQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+\n+/**\n+ * Decorates another {@link Queue} to transform objects that are added.\n+ * <p>\n+ * The add/offer methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class TransformedQueue<E> extends TransformedCollection<E> implements Queue<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -7901091318986132033L;\n+\n+    /**\n+     * Factory method to create a transforming queue.\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Queue\n+     * @throws IllegalArgumentException if queue or transformer is null\n+     */\n+    public static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue,\n+                                                            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedQueue<E>(queue, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming queue that will transform\n+     * existing contents of the specified queue.\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Queue\n+     * @throws IllegalArgumentException if queue or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue,\n+                                                           final Transformer<? super E, ? extends E> transformer) {\n+        // throws IAE if queue or transformer is null\n+        final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer); \n+        if (queue.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // queue is type <E>\n+            final E[] values = (E[]) queue.toArray();\n+            queue.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if queue or transformer is null\n+     */\n+    protected TransformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n+        super(queue, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated queue.\n+     * \n+     * @return the decorated queue\n+     */\n+    protected Queue<E> getQueue() {\n+        return (Queue<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public boolean offer(E obj) {\n+        return getQueue().offer(transform(obj));\n+    }\n+\n+    public E poll() {\n+        return getQueue().poll();\n+    }\n+\n+    public E peek() {\n+        return getQueue().peek();\n+    }\n+\n+    public E element() {\n+        return getQueue().element();\n+    }\n+    \n+    public E remove() {\n+        return getQueue().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/queue/UnmodifiableQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another {@link Queue} to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableQueue<E>\n+        extends AbstractQueueDecorator<E>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1832948656215393357L;\n+\n+    /**\n+     * Factory method to create an unmodifiable queue.\n+     * <p>\n+     * If the queue passed in is already unmodifiable, it is returned.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to decorate, must not be null\n+     * @return an unmodifiable Queue\n+     * @throws IllegalArgumentException if queue is null\n+     */\n+    public static <E> Queue<E> unmodifiableQueue(final Queue<E> queue) {\n+        if (queue instanceof Unmodifiable) {\n+            return queue;\n+        }\n+        return new UnmodifiableQueue<E>(queue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @throws IllegalArgumentException if queue is null\n+     */\n+    private UnmodifiableQueue(final Queue<E> queue) {\n+        super(queue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException if an I/O error occurs while writing to the output stream\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException if an I/O error occurs while reading from the input stream\n+     * @throws ClassNotFoundException if the class of a serialized object can not be found\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    @Override\n+    public boolean offer(E obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public E poll() {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    @Override\n+    public E remove() {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/queue/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains decorators for the {@link java.util.Queue Queue} interface.\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms elements added to the queue\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ * </ul>\n+ * \n+ * @version $Id$\n+ */\n+package org.apache.commons.collections.queue;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/queue/PredicatedQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollectionTest;\n+\n+/**\n+ * Extension of {@link PredicatedCollectionTest} for exercising the\n+ * {@link PredicatedQueue} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PredicatedQueueTest<E> extends PredicatedCollectionTest<E> {\n+\n+    public PredicatedQueueTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //---------------------------------------------------------------\n+\n+    protected Queue<E> decorateCollection(final Queue<E> queue, final Predicate<E> predicate) {\n+        return PredicatedQueue.predicatedQueue(queue, predicate);\n+    }\n+\n+    @Override\n+    public Queue<E> makeObject() {\n+        return decorateCollection(new LinkedList<E>(), truePredicate);\n+    }\n+    \n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final Queue<E> queue = new LinkedList<E>();\n+        queue.addAll(Arrays.asList(getFullElements()));\n+        return decorateCollection(queue, truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new LinkedList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final List<E> list = new LinkedList<E>();\n+        list.addAll(java.util.Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //------------------------------------------------------------\n+\n+    public Queue<E> makeTestQueue() {\n+        return decorateCollection(new LinkedList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGet() {\n+        final Queue<E> queue = makeTestQueue();\n+\n+        assertNull(queue.peek());\n+\n+        queue.add((E) \"one\");\n+        queue.add((E) \"two\");\n+        queue.add((E) \"three\");\n+        assertEquals(\"Queue get\", \"one\", queue.peek());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        final Queue<E> queue = makeTestQueue();\n+        queue.add((E) \"one\");\n+        assertEquals(\"Queue get\", \"one\", queue.poll());\n+        assertNull(queue.peek());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedQueue.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedQueue.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/queue/TransformedQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link TransformedQueue} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class TransformedQueueTest<E> extends AbstractCollectionTest<E> {\n+    \n+    public TransformedQueueTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Queue<E> makeConfirmedCollection() {\n+        return new LinkedList<E>();\n+    }\n+\n+    @Override\n+    public Queue<E> makeConfirmedFullCollection() {\n+        final Queue<E> list = new LinkedList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Queue<E> makeObject() {\n+        return TransformedQueue.transformingQueue(new LinkedList<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Queue<E> makeFullCollection() {\n+        final Queue<E> list = new LinkedList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedQueue.transformingQueue(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTransformedQueue() {\n+        final Queue<Object> queue = TransformedQueue.transformingQueue(new LinkedList<Object>(),\n+                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, queue.size());\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            queue.add(els[i]);\n+            assertEquals(i + 1, queue.size());\n+            assertEquals(true, queue.contains(new Integer((String) els[i])));\n+            assertEquals(false, queue.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, queue.remove(els[0]));\n+        assertEquals(true, queue.remove(new Integer((String) els[0])));\n+        \n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public void testTransformedQueue_decorateTransform() {\n+        final Queue originalQueue = new LinkedList();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalQueue.add(el);\n+        }\n+        final Queue<?> queue = TransformedQueue.transformedQueue(originalQueue,\n+                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, queue.size());\n+        for (final Object el : els) {\n+            assertEquals(true, queue.contains(new Integer((String) el)));\n+            assertEquals(false, queue.contains(el));\n+        }\n+        \n+        assertEquals(false, queue.remove(els[0]));\n+        assertEquals(true, queue.remove(new Integer((String) els[0])));\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+    \n+//  public void testCreate() throws Exception {\n+//      resetEmpty();\n+//      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.emptyCollection.version4.obj\");\n+//      resetFull();\n+//      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.fullCollection.version4.obj\");\n+//  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/queue/UnmodifiableQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableQueue} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableQueueTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableQueueTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableQueue.unmodifiableQueue(new LinkedList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final Queue<E> queue = new LinkedList<E>();\n+        queue.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableQueue.unmodifiableQueue(queue);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new LinkedList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final LinkedList<E> list = new LinkedList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    public void testQueueRemove() {\n+        resetEmpty();\n+        try {\n+            getCollection().remove();\n+            fail();\n+        } catch (final UnsupportedOperationException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableQueue.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableQueue.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Queue<E> getCollection() {\n+        return (Queue<E>) super.getCollection();\n+    }\n+}", "timestamp": 1363542615, "metainfo": ""}