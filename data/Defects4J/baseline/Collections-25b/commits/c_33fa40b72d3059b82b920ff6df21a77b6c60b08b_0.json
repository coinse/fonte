{"sha": "33fa40b72d3059b82b920ff6df21a77b6c60b08b", "log": "COLLECTIONS-241 added PassiveExpiringMap and tests  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Decorates a <code>Map</code> to evict expired entries once their expiration\n+ * time has been reached.\n+ * <p>\n+ * When putting a key-value pair in the map this decorator uses a\n+ * {@link ExpirationPolicy} to determine how long the entry should remain alive\n+ * as defined by an expiration time value.\n+ * </p>\n+ * <p>\n+ * When accessing the mapped value for a key, its expiration time is checked,\n+ * and if it is a negative value or if it is greater than the current time, the\n+ * mapped value is returned. Otherwise, the key is removed from the decorated\n+ * map, and <code>null</code> is returned.\n+ * </p>\n+ * <p>\n+ * When invoking methods that involve accessing the entire map contents (i.e\n+ * {@link #containsKey(Object)}, {@link #entrySet()}, etc.) this decorator\n+ * removes all expired entries prior to actually completing the invocation.\n+ * </p>\n+ * <p>\n+ * <strong>Note that {@link PassiveExpiringMap} is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. The simplest approach\n+ * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n+ * This class may throw exceptions when accessed by concurrent threads without\n+ * synchronization.\n+ * </p>\n+ * \n+ * @param <K>\n+ *            the type of the keys in the map\n+ * \n+ * @param <V>\n+ *            the type of the values in the map\n+ * \n+ * @since 4.0\n+ * @version $Id: $\n+ */\n+public class PassiveExpiringMap<K, V> extends AbstractMapDecorator<K, V>\n+\t\timplements Serializable {\n+\n+\t/**\n+\t * A {@link ExpirationPolicy} that returns a expiration time that is a\n+\t * constant about of time in the future from the current time.\n+\t * \n+\t * @param <K>\n+\t *            the type of the keys in the map\n+\t * @param <V>\n+\t *            the type of the values in the map\n+\t * \n+\t * @since 4.0\n+\t * @version $Id: $\n+\t */\n+\tpublic static class ConstantTimeToLiveExpirationPolicy<K, V> implements\n+\t\t\tExpirationPolicy<K, V> {\n+\n+\t\t/** Serialization version */\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n+\t\t/** the constant time-to-live value measured in milliseconds. */\n+\t\tprivate final long timeToLiveMillis;\n+\n+\t\t/**\n+\t\t * Default constructor. Constructs a policy using a negative\n+\t\t * time-to-live value that results in entries never expiring.\n+\t\t */\n+\t\tpublic ConstantTimeToLiveExpirationPolicy() {\n+\t\t\tthis(-1L);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Construct a policy with the given time-to-live constant measured in\n+\t\t * milliseconds. A negative time-to-live value indicates entries never\n+\t\t * expire. A zero time-to-live value indicates entries expire (nearly)\n+\t\t * immediately.\n+\t\t * \n+\t\t * @param timeToLiveMillis\n+\t\t *            the constant amount of time (in milliseconds) an entry is\n+\t\t *            available before it expires. A negative value results in\n+\t\t *            entries that NEVER expire. A zero value results in entries\n+\t\t *            that ALWAYS expire.\n+\t\t */\n+\t\tpublic ConstantTimeToLiveExpirationPolicy(long timeToLiveMillis) {\n+\t\t\tsuper();\n+\t\t\tthis.timeToLiveMillis = timeToLiveMillis;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Construct a policy with the given time-to-live constant measured in\n+\t\t * the given time unit of measure.\n+\t\t * \n+\t\t * @param timeToLive\n+\t\t *            the constant amount of time an entry is available before\n+\t\t *            it expires. A negative value results in entries that NEVER\n+\t\t *            expire. A zero value results in entries that ALWAYS\n+\t\t *            expire.\n+\t\t * @param timeUnit\n+\t\t *            the unit of time for the <code>timeToLive</code>\n+\t\t *            parameter, must not be null.\n+\t\t * @throws IllegalArgumentException\n+\t\t *             if the time unit is null.\n+\t\t */\n+\t\tpublic ConstantTimeToLiveExpirationPolicy(long timeToLive,\n+\t\t\t\tTimeUnit timeUnit) {\n+\t\t\tthis(validateAndConvertToMillis(timeToLive, TimeUnit.MILLISECONDS));\n+\t\t}\n+\n+\t\t/**\n+\t\t * Determine the expiration time for the given key-value entry.\n+\t\t * \n+\t\t * @param key\n+\t\t *            the key for the entry (ignored).\n+\t\t * @param value\n+\t\t *            the value for the entry (ignored).\n+\t\t * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n+\t\t *         {@link #timeToLiveMillis} +\n+\t\t *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n+\t\t *         is returned indicating the entry never expires.\n+\t\t */\n+\t\tpublic long expirationTime(K key, V value) {\n+\t\t\tif (timeToLiveMillis >= 0L) {\n+\t\t\t\t// avoid numerical overflow\n+\t\t\t\tlong now = System.currentTimeMillis();\n+\t\t\t\tif (now > Long.MAX_VALUE - timeToLiveMillis) {\n+\t\t\t\t\t// expiration would be greater than Long.MAX_VALUE\n+\t\t\t\t\t// never expire\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\n+\t\t\t\t// timeToLiveMillis in the future\n+\t\t\t\treturn now + timeToLiveMillis;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// never expire\n+\t\t\treturn -1L;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A policy to determine the expiration time for key-value entries.\n+\t * \n+\t * @param <K>\n+\t *            the key object type.\n+\t * @param <V>\n+\t *            the value object type\n+\t * \n+\t * @since 4.0\n+\t * @version $Id: $\n+\t */\n+\tpublic static interface ExpirationPolicy<K, V> extends Serializable {\n+\t\t/**\n+\t\t * Determine the expiration time for the given key-value entry.\n+\t\t * \n+\t\t * @param key\n+\t\t *            the key for the entry.\n+\t\t * @param value\n+\t\t *            the value for the entry.\n+\t\t * @return the expiration time value measured in milliseconds. A\n+\t\t *         negative return value indicates the entry never expires.\n+\t\t */\n+\t\tlong expirationTime(K key, V value);\n+\t}\n+\n+\t/** Serialization version */\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\t/**\n+\t * First validate the input parameters. If the parameters are valid, convert\n+\t * the given time measured in the given units to the same time measured in\n+\t * milliseconds. If the parameters are invalid, an\n+\t * {@link IllegalArgumentException} is thrown.\n+\t * \n+\t * @param timeToLive\n+\t *            the constant amount of time an entry is available before it\n+\t *            expires. A negative value results in entries that NEVER\n+\t *            expire. A zero value results in entries that ALWAYS expire.\n+\t * @param timeUnit\n+\t *            the unit of time for the <code>timeToLive</code> parameter,\n+\t *            must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the time unit is null.\n+\t */\n+\tprivate static long validateAndConvertToMillis(long timeToLive,\n+\t\t\tTimeUnit timeUnit) {\n+\t\tif (timeUnit == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Time unit must not be null\");\n+\t\t}\n+\t\treturn timeUnit.convert(timeToLive, TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t/** map used to manage expiration times for the actual map entries. */\n+\tprivate final Map<Object, Long> expirationMap = new HashMap<Object, Long>();\n+\n+\t/** the policy used to determine time-to-live values for map entries. */\n+\tprivate final ExpirationPolicy<K, V> expiringPolicy;\n+\n+\t/**\n+\t * Default constructor. Constructs a map decorator that results in entries\n+\t * NEVER expiring.\n+\t */\n+\tpublic PassiveExpiringMap() {\n+\t\tthis(-1L);\n+\t}\n+\n+\t/**\n+\t * Construct a map decorator using the given expiration policy to determine\n+\t * expiration times.\n+\t * \n+\t * @param expiringPolicy\n+\t *            the policy used to determine expiration times of entries as\n+\t *            they are added.\n+\t */\n+\tpublic PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy) {\n+\t\tthis(expiringPolicy, new HashMap<K, V>());\n+\t}\n+\n+\t/**\n+\t * Construct a map decorator that decorates the given map and uses the given\n+\t * expiration policy to determine expiration times. If there are any\n+\t * elements already in the map being decorated, they will NEVER expire\n+\t * unless they are replaced.\n+\t * \n+\t * @param expiringPolicy\n+\t *            the policy used to determine expiration times of entries as\n+\t *            they are added.\n+\t * @param map\n+\t *            the map to decorate, must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the map is null.\n+\t */\n+\tpublic PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy,\n+\t\t\tMap<K, V> map) {\n+\t\tsuper(map);\n+\t\tif (expiringPolicy == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Policy must not be null.\");\n+\t\t}\n+\t\tthis.expiringPolicy = expiringPolicy;\n+\t}\n+\n+\t/**\n+\t * Construct a map decorator that decorates the given map using the given\n+\t * time-to-live value measured in milliseconds to create and use a\n+\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n+\t * \n+\t * @param timeToLiveMillis\n+\t *            the constant amount of time (in milliseconds) an entry is\n+\t *            available before it expires. A negative value results in\n+\t *            entries that NEVER expire. A zero value results in entries\n+\t *            that ALWAYS expire.\n+\t */\n+\tpublic PassiveExpiringMap(long timeToLiveMillis) {\n+\t\tthis(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n+\t\t\t\tnew HashMap<K, V>());\n+\t}\n+\n+\t/**\n+\t * Construct a map decorator using the given time-to-live value measured in\n+\t * milliseconds to create and use a\n+\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. If there\n+\t * are any elements already in the map being decorated, they will NEVER\n+\t * expire unless they are replaced.\n+\t * \n+\t * @param timeToLiveMillis\n+\t *            the constant amount of time (in milliseconds) an entry is\n+\t *            available before it expires. A negative value results in\n+\t *            entries that NEVER expire. A zero value results in entries\n+\t *            that ALWAYS expire.\n+\t * @param map\n+\t *            the map to decorate, must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the map is null.\n+\t */\n+\tpublic PassiveExpiringMap(long timeToLiveMillis, Map<K, V> map) {\n+\t\tthis(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n+\t\t\t\tmap);\n+\t}\n+\n+\t/**\n+\t * Construct a map decorator using the given time-to-live value measured in\n+\t * the given time units of measure to create and use a\n+\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n+\t * \n+\t * @param timeToLive\n+\t *            the constant amount of time an entry is available before it\n+\t *            expires. A negative value results in entries that NEVER\n+\t *            expire. A zero value results in entries that ALWAYS expire.\n+\t * @param timeUnit\n+\t *            the unit of time for the <code>timeToLive</code> parameter,\n+\t *            must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the time unit is null.\n+\t */\n+\tpublic PassiveExpiringMap(long timeToLive, TimeUnit timeUnit) {\n+\t\tthis(validateAndConvertToMillis(timeToLive, timeUnit));\n+\t}\n+\n+\t/**\n+\t * Construct a map decorator that decorates the given map using the given\n+\t * time-to-live value measured in the given time units of measure to create\n+\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. This policy\n+\t * is used to determine expiration times. If there are any elements already\n+\t * in the map being decorated, they will NEVER expire unless they are\n+\t * replaced.\n+\t * \n+\t * @param timeToLive\n+\t *            the constant amount of time an entry is available before it\n+\t *            expires. A negative value results in entries that NEVER\n+\t *            expire. A zero value results in entries that ALWAYS expire.\n+\t * @param timeUnit\n+\t *            the unit of time for the <code>timeToLive</code> parameter,\n+\t *            must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the time unit is null.\n+\t * @param map\n+\t *            the map to decorate, must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the map is null.\n+\t */\n+\tpublic PassiveExpiringMap(long timeToLive, TimeUnit timeUnit, Map<K, V> map) {\n+\t\tthis(validateAndConvertToMillis(timeToLive, timeUnit), map);\n+\t}\n+\n+\t/**\n+\t * Constructs a map decorator that decorates the given map and results in\n+\t * entries NEVER expiring. If there are any elements already in the map\n+\t * being decorated, they also will NEVER expire.\n+\t * \n+\t * @param map\n+\t *            the map to decorate, must not be null.\n+\t * @throws IllegalArgumentException\n+\t *             if the map is null.\n+\t */\n+\tpublic PassiveExpiringMap(Map<K, V> map) {\n+\t\tthis(-1L, map);\n+\t}\n+\n+\t/**\n+\t * Normal {@link Map#clear()} behavior with the addition of clearing all\n+\t * expiration entries as well.\n+\t */\n+\t@Override\n+\tpublic void clear() {\n+\t\tsuper.clear();\n+\t\texpirationMap.clear();\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to determining the\n+\t * contains result.\n+\t */\n+\t@Override\n+\tpublic boolean containsKey(Object key) {\n+\t\tremoveIfExpired(key, now());\n+\t\treturn super.containsKey(key);\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to determining the\n+\t * contains result.\n+\t */\n+\t@Override\n+\tpublic boolean containsValue(Object value) {\n+\t\tremoveAllExpired(now());\n+\t\treturn super.containsValue(value);\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to returning the entry\n+\t * set.\n+\t */\n+\t@Override\n+\tpublic Set<Entry<K, V>> entrySet() {\n+\t\tremoveAllExpired(now());\n+\t\treturn super.entrySet();\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to returning the entry\n+\t * value.\n+\t */\n+\t@Override\n+\tpublic V get(Object key) {\n+\t\tremoveIfExpired(key, now());\n+\t\treturn super.get(key);\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to determining if it\n+\t * is empty.\n+\t */\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\tremoveAllExpired(now());\n+\t\treturn super.isEmpty();\n+\t}\n+\n+\t/**\n+\t * Determines if the given expiration time is less than <code>now</code>\n+\t * \n+\t * @param now\n+\t *            the time in milliseconds used to compare against the\n+\t *            expiration time.\n+\t * @param expirationTimeObject\n+\t *            the expiration time value retrieved from\n+\t *            {@link #expirationMap}, can be null.\n+\t * @return <code>true</code> if <code>expirationTimeObject</code> is &ge; 0\n+\t *         and <code>expirationTimeObject</code> &lt; <code>now</code>.\n+\t *         <code>false</code> otherwise.\n+\t */\n+\tprivate boolean isExpired(long now, Long expirationTimeObject) {\n+\t\tif (expirationTimeObject != null) {\n+\t\t\tlong expirationTime = expirationTimeObject.longValue();\n+\t\t\treturn (expirationTime >= 0 && now >= expirationTime);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to returning the key\n+\t * set.\n+\t */\n+\t@Override\n+\tpublic Set<K> keySet() {\n+\t\tremoveAllExpired(now());\n+\t\treturn super.keySet();\n+\t}\n+\n+\t/**\n+\t * The current time in milliseconds.\n+\t */\n+\tprivate long now() {\n+\t\treturn System.currentTimeMillis();\n+\t}\n+\n+\t@Override\n+\tpublic V put(K key, V value) {\n+\t\treturn put(key, value, now());\n+\t}\n+\n+\t/**\n+\t * Add the given key-value pair to this map as well as recording the entry's\n+\t * expiration time based on the current time in milliseconds,\n+\t * <code>now</code> and this map's {@link #expiringPolicy}.\n+\t */\n+\tprivate V put(K key, V value, long now) {\n+\t\t// record expiration time of new entry\n+\t\tlong expirationTime = expiringPolicy.expirationTime(key, value);\n+\t\texpirationMap.put(key, Long.valueOf(expirationTime));\n+\n+\t\treturn super.put(key, value);\n+\t}\n+\n+\t@Override\n+\tpublic void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+\t\tfor (Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+\t\t\tput(entry.getKey(), entry.getValue());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Normal {@link Map#remove(Object)} behavior with the addition of removing\n+\t * any expiration entry as well.\n+\t */\n+\t@Override\n+\tpublic V remove(Object key) {\n+\t\texpirationMap.remove(key);\n+\t\treturn super.remove(key);\n+\t}\n+\n+\t/**\n+\t * Removes all entries in the map whose expiration time is less than\n+\t * <code>now</code>. The exceptions are entries with negative expiration\n+\t * times; those entries are never removed.\n+\t * \n+\t * @see #isExpired(long, Long)\n+\t */\n+\tprivate void removeAllExpired(long now) {\n+\t\tIterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet()\n+\t\t\t\t.iterator();\n+\t\twhile (iter.hasNext()) {\n+\t\t\tMap.Entry<Object, Long> expirationEntry = iter.next();\n+\t\t\tif (isExpired(now, expirationEntry.getValue())) {\n+\t\t\t\t// remove entry from collection\n+\t\t\t\tsuper.remove(expirationEntry.getKey());\n+\t\t\t\t// remove entry from expiration map\n+\t\t\t\titer.remove();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Removes the entry with the given key if the entry's expiration time is\n+\t * less than <code>now</code>. If the entry has a negative expiration time,\n+\t * the entry is never removed.\n+\t */\n+\tprivate void removeIfExpired(Object key, long now) {\n+\t\tLong expirationTimeObject = expirationMap.get(key);\n+\t\tif (isExpired(now, expirationTimeObject)) {\n+\t\t\tremove(key);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to returning the size.\n+\t */\n+\t@Override\n+\tpublic int size() {\n+\t\tremoveAllExpired(now());\n+\t\treturn super.size();\n+\t}\n+\n+\t/**\n+\t * Read the map in using a custom routine.\n+\t * \n+\t * @param in\n+\t *            the input stream\n+\t * @throws IOException\n+\t * @throws ClassNotFoundException\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\t// (1) should only fail if input stream is incorrect\n+\tprivate void readObject(ObjectInputStream in) throws IOException,\n+\t\t\tClassNotFoundException {\n+\t\tin.defaultReadObject();\n+\t\tmap = (Map<K, V>) in.readObject(); // (1)\n+\t}\n+\n+\t/**\n+\t * Write the map out using a custom routine.\n+\t * \n+\t * @param out\n+\t *            the output stream\n+\t * @throws IOException\n+\t */\n+\tprivate void writeObject(ObjectOutputStream out) throws IOException {\n+\t\tout.defaultWriteObject();\n+\t\tout.writeObject(map);\n+\t}\n+\n+\t/**\n+\t * All expired entries are removed from the map prior to returning the value\n+\t * collection.\n+\t */\n+\t@Override\n+\tpublic Collection<V> values() {\n+\t\tremoveAllExpired(now());\n+\t\treturn super.values();\n+\t}\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestPassiveExpiringMap.java\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.map.PassiveExpiringMap.ExpirationPolicy;\n+\n+public class TestPassiveExpiringMap<K, V> extends AbstractTestMap<K, V> {\n+\n+\tprivate static class TestExpirationPolicy implements\n+\t\t\tExpirationPolicy<Integer, String> {\n+\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n+\t\tpublic long expirationTime(Integer key, String value) {\n+\t\t\t// odd keys expire immediately, even keys never expire\n+\t\t\tif (key == null) {\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t\tif (key.intValue() % 2 == 0) {\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n+\tpublic static Test suite() {\n+\t\treturn BulkTest.makeSuite(TestPassiveExpiringMap.class);\n+\t}\n+\n+\tpublic TestPassiveExpiringMap(String testName) {\n+\t\tsuper(testName);\n+\t}\n+\n+\t// public void testCreate() throws Exception {\n+\t// writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+\t// \"PassiveExpiringMap.emptyCollection.version4.obj\");\n+\t//\n+\t// writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+\t// \"PassiveExpiringMap.fullCollection.version4.obj\");\n+\t// }\n+\n+\t@Override\n+\tpublic String getCompatibilityVersion() {\n+\t\treturn \"4\";\n+\t}\n+\n+\tprivate Map<Integer, String> makeDecoratedTestMap() {\n+\t\tMap<Integer, String> m = new HashMap<Integer, String>();\n+\t\tm.put(Integer.valueOf(1), \"one\");\n+\t\tm.put(Integer.valueOf(2), \"two\");\n+\t\tm.put(Integer.valueOf(3), \"three\");\n+\t\tm.put(Integer.valueOf(4), \"four\");\n+\t\tm.put(Integer.valueOf(5), \"five\");\n+\t\tm.put(Integer.valueOf(6), \"six\");\n+\t\treturn new PassiveExpiringMap<Integer, String>(\n+\t\t\t\tnew TestExpirationPolicy(), m);\n+\t}\n+\n+\t@Override\n+\tpublic Map<K, V> makeObject() {\n+\t\treturn new PassiveExpiringMap<K, V>();\n+\t}\n+\n+\tprivate Map<Integer, String> makeTestMap() {\n+\t\tMap<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n+\t\t\t\tnew TestExpirationPolicy());\n+\t\tm.put(Integer.valueOf(1), \"one\");\n+\t\tm.put(Integer.valueOf(2), \"two\");\n+\t\tm.put(Integer.valueOf(3), \"three\");\n+\t\tm.put(Integer.valueOf(4), \"four\");\n+\t\tm.put(Integer.valueOf(5), \"five\");\n+\t\tm.put(Integer.valueOf(6), \"six\");\n+\t\treturn m;\n+\t}\n+\n+\tpublic void testConstructors() {\n+\t\ttry {\n+\t\t\tMap<String, String> map = null;\n+\t\t\tnew PassiveExpiringMap<String, String>(map);\n+\t\t\tfail(\"constructor - exception should have been thrown.\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// success\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tExpirationPolicy<String, String> policy = null;\n+\t\t\tnew PassiveExpiringMap<String, String>(policy);\n+\t\t\tfail(\"constructor - exception should have been thrown.\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// success\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tTimeUnit unit = null;\n+\t\t\tnew PassiveExpiringMap<String, String>(10L, unit);\n+\t\t\tfail(\"constructor - exception should have been thrown.\");\n+\t\t} catch (IllegalArgumentException ex) {\n+\t\t\t// success\n+\t\t}\n+\t}\n+\n+\tpublic void testContainsKey() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertFalse(m.containsKey(Integer.valueOf(1)));\n+\t\tassertFalse(m.containsKey(Integer.valueOf(3)));\n+\t\tassertFalse(m.containsKey(Integer.valueOf(5)));\n+\t\tassertTrue(m.containsKey(Integer.valueOf(2)));\n+\t\tassertTrue(m.containsKey(Integer.valueOf(4)));\n+\t\tassertTrue(m.containsKey(Integer.valueOf(6)));\n+\t}\n+\n+\tpublic void testContainsValue() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertFalse(m.containsValue(\"one\"));\n+\t\tassertFalse(m.containsValue(\"three\"));\n+\t\tassertFalse(m.containsValue(\"five\"));\n+\t\tassertTrue(m.containsValue(\"two\"));\n+\t\tassertTrue(m.containsValue(\"four\"));\n+\t\tassertTrue(m.containsValue(\"six\"));\n+\t}\n+\n+\tpublic void testDecoratedMap() {\n+\t\t// entries shouldn't expire\n+\t\tMap<Integer, String> m = makeDecoratedTestMap();\n+\t\tassertEquals(6, m.size());\n+\t\tassertEquals(\"one\", m.get(Integer.valueOf(1)));\n+\n+\t\t// removing a single item shouldn't affect any other items\n+\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\t\tm.remove(Integer.valueOf(2));\n+\t\tassertEquals(5, m.size());\n+\t\tassertEquals(\"one\", m.get(Integer.valueOf(1)));\n+\t\tassertNull(m.get(Integer.valueOf(2)));\n+\n+\t\t// adding a single, even item shouldn't affect any other items\n+\t\tassertNull(m.get(Integer.valueOf(2)));\n+\t\tm.put(Integer.valueOf(2), \"two\");\n+\t\tassertEquals(6, m.size());\n+\t\tassertEquals(\"one\", m.get(Integer.valueOf(1)));\n+\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\n+\t\t// adding a single, odd item (one that expires) shouldn't affect any\n+\t\t// other items\n+\t\t// put the entry expires immediately\n+\t\tm.put(Integer.valueOf(1), \"one-one\");\n+\t\tassertEquals(5, m.size());\n+\t\tassertNull(m.get(Integer.valueOf(1)));\n+\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\t}\n+\n+\tpublic void testEntrySet() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertEquals(3, m.entrySet().size());\n+\t}\n+\n+\tpublic void testGet() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertNull(m.get(Integer.valueOf(1)));\n+\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\t\tassertNull(m.get(Integer.valueOf(3)));\n+\t\tassertEquals(\"four\", m.get(Integer.valueOf(4)));\n+\t\tassertNull(m.get(Integer.valueOf(5)));\n+\t\tassertEquals(\"six\", m.get(Integer.valueOf(6)));\n+\t}\n+\n+\tpublic void testIsEmpty() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertFalse(m.isEmpty());\n+\n+\t\t// remove just evens\n+\t\tm = makeTestMap();\n+\t\tm.remove(Integer.valueOf(2));\n+\t\tm.remove(Integer.valueOf(4));\n+\t\tm.remove(Integer.valueOf(6));\n+\t\tassertTrue(m.isEmpty());\n+\t}\n+\n+\tpublic void testKeySet() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertEquals(3, m.keySet().size());\n+\t}\n+\n+\tpublic void testSize() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertEquals(3, m.size());\n+\t}\n+\n+\tpublic void testValues() {\n+\t\tMap<Integer, String> m = makeTestMap();\n+\t\tassertEquals(3, m.values().size());\n+\t}\n+\n+\tpublic void testZeroTimeToLive() {\n+\t\t// item should not be available\n+\t\tPassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n+\t\t\t\t0L);\n+\t\tm.put(\"a\", \"b\");\n+\t\tassertNull(m.get(\"a\"));\n+\t}\n+}", "timestamp": 1345784916, "metainfo": ""}