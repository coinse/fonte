{"sha": "ad8bc0e6d9c71bb38324132794b2536789fde78e", "log": "Minor speed improvement Javadoc/copyright   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BoundedFifoBuffer.java,v 1.6 2002/11/24 16:23:21 scolebourne Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/11/24 16:23:21 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BoundedFifoBuffer.java,v 1.7 2003/04/26 15:09:48 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n+\n /**\n  * The BoundedFifoBuffer is a <strong>very</strong> efficient implementation of\n  * Buffer that does not alter the size of the buffer at runtime.\n  * This buffer prevents null objects from being added.\n  *\n  * @since 2.1\n+ * @version $Revision: 1.7 $ $Date: 2003/04/26 15:09:48 $\n+ * \n  * @author Avalon\n  * @author <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  * @author <a href=\"herve.quiroz@esil.univ-mrs.fr\">Herve Quiroz</a>\n- * @version $Id: BoundedFifoBuffer.java,v 1.6 2002/11/24 16:23:21 scolebourne Exp $\n  */\n public class BoundedFifoBuffer extends AbstractCollection implements Buffer, BoundedCollection {\n     private final Object[] m_elements;\n     private int m_start = 0;\n     private int m_end = 0;\n     private boolean m_full = false;\n+    private final int maxElements;\n \n     /**\n      * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n         m_elements = new Object[size];\n+        maxElements = m_elements.length;\n     }\n \n     /**\n      * of the elements in the specified collection. That collection's\n      * elements will also be added to the buffer.\n      *\n-     * @param coll  the collection whose elements to add\n+     * @param coll  the collection whose elements to add, may not be null\n+     * @throws NullPointerException if the collection is null\n      */\n     public BoundedFifoBuffer(Collection coll) {\n         this(coll.size());\n         int size = 0;\n \n         if (m_end < m_start) {\n-            size = m_elements.length - m_start + m_end;\n+            size = maxElements - m_start + m_end;\n         } else if (m_end == m_start) {\n-            size = (m_full ? m_elements.length : 0);\n+            size = (m_full ? maxElements : 0);\n         } else {\n             size = m_end - m_start;\n         }\n      * @return <code>true</code> if the collection is full\n      */\n     public boolean isFull() {\n-        return size() == m_elements.length;\n+        return size() == maxElements;\n     }\n     \n     /**\n      * @return the maximum number of elements the collection can hold\n      */\n     public int maxSize() {\n-        return m_elements.length;\n+        return maxElements;\n     }\n     \n     /**\n         }\n \n         if (m_full) {\n-            throw new BufferOverflowException(\"The buffer cannot hold more than \" + m_elements.length + \" objects.\");\n+            throw new BufferOverflowException(\"The buffer cannot hold more than \" + maxElements + \" objects.\");\n         }\n \n         m_elements[m_end++] = element;\n \n-        if (m_end >= m_elements.length) {\n+        if (m_end >= maxElements) {\n             m_end = 0;\n         }\n \n         if (null != element) {\n             m_elements[m_start++] = null;\n \n-            if (m_start >= m_elements.length) {\n+            if (m_start >= maxElements) {\n                 m_start = 0;\n             }\n \n      */\n     private int increment(int index) {\n         index++; \n-        if (index >= m_elements.length) {\n+        if (index >= maxElements) {\n             index = 0;\n         }\n         return index;\n     private int decrement(int index) {\n         index--;\n         if (index < 0) {\n-            index = m_elements.length - 1;\n+            index = maxElements - 1;\n         }\n         return index;\n     }\n                 // Other elements require us to shift the subsequent elements\n                 int i = lastReturnedIndex + 1;\n                 while (i != m_end) {\n-                    if (i >= m_elements.length) {\n+                    if (i >= maxElements) {\n                         m_elements[i - 1] = m_elements[0];\n                         i = 0;\n                     } else {", "timestamp": 1051369788, "metainfo": ""}