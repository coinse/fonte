{"sha": "e41abcddc68ea014aac8126b2171f9a58c2aa90a", "log": "Fix Map debug output for recursion bug 23041, from Janek Bogucki/Arun Mammen Thomas   ", "commit": "\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.33 2003/09/09 21:05:51 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.34 2003/09/17 19:59:45 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *  </ul>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.33 $ $Date: 2003/09/09 21:05:51 $\n+ * @version $Revision: 1.34 $ $Date: 2003/09/17 19:59:45 $\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n      * @param map  the map to convert to a Properties object, may not be null\n      * @return the properties object\n      */\n-    public static Properties toProperties(Map map) {\n+    public static Properties toProperties(final Map map) {\n         Properties answer = new Properties();\n         if (map != null) {\n             for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {\n      * @return the hashmap containing the data\n      * @throws NullPointerException if the bundle is null\n      */\n-    public static Map toMap(ResourceBundle resourceBundle) {\n+    public static Map toMap(final ResourceBundle resourceBundle) {\n         Enumeration enum = resourceBundle.getKeys();\n         Map map = new HashMap();\n \n         final Map map) {\n \n         indentDepth = 0;\n-        verbosePrintInternal(out, label, map, false);\n+        verbosePrintInternal(out, label, map, new ArrayStack(), false);\n     }\n \n     /**\n         final Map map) {\n \n         indentDepth = 0;\n-        verbosePrintInternal(out, label, map, true);\n+        verbosePrintInternal(out, label, map, new ArrayStack(), true);\n     }\n \n     // Implementation methods\n      *\n      * @param out  the stream to indent\n      */\n-    protected static void printIndent(PrintStream out) {\n+    protected static void printIndent(final PrintStream out) {\n         for (int i = 0; i < indentDepth; i++) {\n             out.print(INDENT_STRING);\n         }\n      *\n      * @param ex  the exception to log\n      */\n-    protected static void logInfo(Exception ex) {\n+    protected static void logInfo(final Exception ex) {\n         System.out.println(\"INFO: Exception: \" + ex);\n     }\n \n      * Implementation providing functionality for {@link #debugPrint} and for \n      * {@link #verbosePrint}.  This prints the given map with nice line breaks.\n      * If the debug flag is true, it additionally prints the type of the object \n-     * value.\n+     * value.  If the contents of a map include the map itself, then the text \n+     * <em>(this Map)</em> is printed out.  If the contents include a \n+     * parent container of the map, the the text <em>(ancestor[i] Map)</em> is \n+     * printed, where i actually indicates the number of levels which must be \n+     * traversed in the sequential list of ancesters (e.g. father, grandfather, \n+     * great-grandfather, etc).  \n      *\n      * @param out  the stream to print to\n-     * @param label  The label to be used, may be <code>null</code>.\n+     * @param label  the label to be used, may be <code>null</code>.\n      *  If <code>null</code>, the label is not output.\n      *  It typically represents the name of the property in a bean or similar.\n-     * @param map  The map to print, may be <code>null</code>.\n-     *  If <code>null</code>, the text 'null' is output.\n+     * @param map  the map to print, may be <code>null</code>.\n+     *  If <code>null</code>, the text 'null' is output\n+     * @param lineage  a stack consisting of any maps in which the previous \n+     *  argument is contained. This is checked to avoid infinite recursion when\n+     *  printing the output\n+     *                   \n      * @param debug flag indicating whether type names should be output.\n      * @throws NullPointerException if the stream is <code>null</code>\n      */\n         final PrintStream out,\n         final Object label,\n         final Map map,\n+        final ArrayStack lineage,\n         final boolean debug) {\n-\n+        \n         printIndent(out);\n \n         if (map == null) {\n \n         printIndent(out);\n         out.println(\"{\");\n+\n         indentDepth++;\n+        lineage.push(map);\n \n         for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n             Map.Entry entry = (Map.Entry) it.next();\n             Object childKey = entry.getKey();\n             Object childValue = entry.getValue();\n-            if (childValue instanceof Map && childValue != map) {\n-                verbosePrintInternal(out, (childKey == null ? \"null\" : childKey), (Map) childValue, debug);\n+            if (childValue instanceof Map && !lineage.contains(childValue)) {\n+                verbosePrintInternal(\n+                    out,\n+                    (childKey == null ? \"null\" : childKey),\n+                    (Map) childValue,\n+                    lineage,\n+                    debug);\n             } else {\n                 printIndent(out);\n                 out.print(childKey);\n                 out.print(\" = \");\n-                out.print(childValue == map ? \"(this Map)\" : childValue);\n+                \n+                final int lineageIndex = lineage.indexOf(childValue);\n+                if (lineageIndex == -1) {\n+                    out.print(childValue);\n+                } else if (lineage.size() - 1 == lineageIndex) {\n+                    out.print(\"(this Map)\");    \n+                } else {\n+                    out.print(\n+                        \"(ancestor[\"\n+                            + (lineage.size() - 1 - lineageIndex - 1)\n+                            + \"] Map)\");\n+                }\n+                \n                 if (debug && childValue != null) {\n                     out.print(' ');\n                     out.println(childValue.getClass().getName());\n             }\n         }\n         \n+        lineage.pop();\n         indentDepth--;\n+\n         printIndent(out);\n         out.println(debug ? \"} \" + map.getClass().getName() : \"}\");\n     }\n--- a/src/test/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.12 2003/09/14 03:30:23 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.13 2003/09/17 19:59:45 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Tests for MapUtils.\n  * \n- * @version $Revision: 1.12 $ $Date: 2003/09/14 03:30:23 $\n+ * @version $Revision: 1.13 $ $Date: 2003/09/17 19:59:45 $\n  * \n  * @author Stephen Colebourne\n  * @author Arun Mammen Thomas\n  * @author Max Rydahl Andersen\n+ * @author Janek Bogucki\n  */\n public class TestMapUtils extends BulkTest {\n \n         final Map map = new TreeMap();  // treeMap guarantees order across JDKs for test\n         map.put( new Integer(2) , \"B\" );\n         map.put( new Integer(3) , \"C\" );\n+        map.put( new Integer(4) , null );\n     \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n         outPrint.println(INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"4 = null\");\n         outPrint.println(\"} \" + TreeMap.class.getName());\n         final String EXPECTED_OUT = out.toString();\n         out.reset();\n         assertEquals(EXPECTED_OUT, out.toString());\n     }\n \n+    public void testVerbosePrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map map = new HashMap();\n+        map.put( null , \"A\" );\n+    \n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+        \n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n     public void testDebugPrintNullKeyToMap1() {\n         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n         final PrintStream outPrint = new PrintStream(out);\n         MapUtils.debugPrint(outPrint, null, map);\n         assertEquals(EXPECTED_OUT, out.toString());\n     }\n+\n+    public void testVerbosePrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map map = new HashMap();\n+        map.put( null , map );\n+    \n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map)\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+        \n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }    \n \n     public void testDebugPrintNullKeyToMap2() {\n         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n         MapUtils.debugPrint(outPrint, null, map);\n         assertEquals(EXPECTED_OUT, out.toString());\n     }\n+\n+    public void testVerbosePrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map map = new HashMap();\n+        final Map map2= new HashMap();\n+        map.put( null , map2 );\n+        map2.put( \"2\", \"B\" );\n+    \n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+        \n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }    \n \n     public void testVerbosePrint() {\n         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n         MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n         assertEquals(EXPECTED_OUT, out.toString());\n     }\n+\n+    public void testVerbosePrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+        \n+\n+        final Map grandfather = new TreeMap();// treeMap guarantees order across JDKs for test\n+        final Map father = new TreeMap();\n+        final Map son    = new TreeMap();\n+        \n+        grandfather.put( new Integer(0), \"A\" );\n+        grandfather.put( new Integer(1), father );\n+        \n+        father.put( new Integer(2), \"B\" );\n+        father.put( new Integer(3), grandfather);\n+        father.put( new Integer(4), son);\n+        \n+        son.put( new Integer(5), \"C\");\n+        son.put( new Integer(6), grandfather);\n+        son.put( new Integer(7), father);\n+        \n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map)\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"}\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", grandfather);\n+\n+        System.out.println(EXPECTED_OUT);\n+        System.out.println(EXPECTED_OUT.length());\n+        System.out.println(out.toString());\n+        System.out.println(out.toString().length());\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+    \n+    public void testDebugPrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+    \n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+        \n+    \n+        final Map grandfather = new TreeMap();// treeMap guarantees order across JDKs for test\n+        final Map father = new TreeMap();\n+        final Map son    = new TreeMap();\n+        \n+        grandfather.put( new Integer(0), \"A\" );\n+        grandfather.put( new Integer(1), father );\n+        \n+        father.put( new Integer(2), \"B\" );\n+        father.put( new Integer(3), grandfather);\n+        father.put( new Integer(4), son);\n+        \n+        son.put( new Integer(5), \"C\");\n+        son.put( new Integer(6), grandfather);\n+        son.put( new Integer(7), father);\n+        \n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+    \n+        final String EXPECTED_OUT = out.toString();\n+    \n+        out.reset();\n+        MapUtils.debugPrint(outPrint, \"Print Map\", grandfather);\n+    \n+        System.out.println(EXPECTED_OUT);\n+        System.out.println(EXPECTED_OUT.length());\n+        System.out.println(out.toString());\n+        System.out.println(out.toString().length());\n+    \n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+    \n }", "timestamp": 1063828785, "metainfo": ""}