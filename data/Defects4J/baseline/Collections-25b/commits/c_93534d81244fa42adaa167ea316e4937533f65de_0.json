{"sha": "93534d81244fa42adaa167ea316e4937533f65de", "log": "Rename Observed to Observable   ", "commit": "\n--- a/src/java/org/apache/commons/collections/observed/ModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/ModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationEvent.java,v 1.2 2003/09/07 10:33:32 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationEvent.java,v 1.3 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * This class can be used as is, but generally it is subclassed.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/07 10:33:32 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n public class ModificationEvent extends EventObject {\n \n     /** The source collection */\n-    protected final ObservedCollection collection;\n+    protected final ObservableCollection collection;\n     /** The handler */\n     protected final ModificationHandler handler;\n     /** The event code */\n      * @param type  the event type\n      */\n     public ModificationEvent(\n-        final ObservedCollection obsCollection,\n+        final ObservableCollection obsCollection,\n         final ModificationHandler handler,\n         final int type) {\n \n      * Gets the collection the event is reporting on.\n      * <p>\n      * Using this collection will bypass any decorators that have been added\n-     * to the <code>ObservedCollection</code>. For example, if a synchronized\n+     * to the <code>ObservableCollection</code>. For example, if a synchronized\n      * decorator was added it will not be called by changes to this collection.\n      * <p>\n      * For the synchronization case, you are normally OK however. If you\n      * \n      * @return the collection\n      */\n-    public ObservedCollection getObservedCollection() {\n+    public ObservableCollection getObservedCollection() {\n         return collection;\n     }\n \n     /**\n-     * Gets the base collection underlying the observed collection.\n+     * Gets the base collection underlying the observable collection.\n      * <p>\n      * Using this collection will bypass the event sending mechanism.\n      * It will also bypass any other decorators, such as synchronization.\n      */\n     public String toString() {\n         StringBuffer buf = new StringBuffer(64);\n-        buf.append(\"ObservedEvent[type=\");\n+        buf.append(\"ModificationEvent[type=\");\n         buf.append(ModificationEventType.toString(type));\n         buf.append(']');\n         return buf.toString();\n--- a/src/java/org/apache/commons/collections/observed/ModificationHandler.java\n+++ b/src/java/org/apache/commons/collections/observed/ModificationHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandler.java,v 1.5 2003/09/07 16:50:59 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandler.java,v 1.6 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * later collections release.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2003/09/07 16:50:59 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n     static final ModificationHandlerFactory FACTORY = new Factory();\n     \n     /** The collection being observed */\n-    private ObservedCollection obsCollection = null;\n+    private ObservableCollection obsCollection = null;\n     /** The underlying base collection being decorated */\n     private Collection baseCollection = null;\n     /** The root handler */\n      * @throws IllegalArgumentException if the collection is null\n      * @throws IllegalStateException if init has already been called\n      */\n-    void init(final ObservedCollection coll, Collection baseColl) {\n+    void init(final ObservableCollection coll, Collection baseColl) {\n         if (coll == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n      * \n      * @return the observed collection\n      */\n-    public ObservedCollection getObservedCollection() {\n+    public ObservableCollection getObservedCollection() {\n         return obsCollection;\n     }\n     \n      */\n     protected boolean preEvent(\n             int type, int index, Object object, int repeat,\n-            Object previous, ObservedCollection range, int rangeOffset) {\n+            Object previous, ObservableCollection range, int rangeOffset) {\n         return true;\n     }\n \n      */\n     protected void postEvent(\n             boolean modified, int type, int index, Object object, int repeat,\n-            Object previous, ObservedCollection range, int rangeOffset) {\n+            Object previous, ObservableCollection range, int rangeOffset) {\n     }\n \n     // Event handling\n          */\n         protected boolean preEvent(\n                 int type, int index, Object object, int repeat,\n-                Object previous, ObservedCollection ignoredRange, int ignoredOffset) {\n+                Object previous, ObservableCollection ignoredRange, int ignoredOffset) {\n \n             return getRootHandler().preEvent(\n                 type, index, object, repeat,\n          */\n         protected void postEvent(\n                 boolean modified, int type, int index, Object object, int repeat,\n-                Object previous, ObservedCollection ignoredRange, int ignoredOffset) {\n+                Object previous, ObservableCollection ignoredRange, int ignoredOffset) {\n \n             getRootHandler().postEvent(\n                 modified, type, index, object, repeat,\n--- a/src/java/org/apache/commons/collections/observed/ModificationHandlerFactory.java\n+++ b/src/java/org/apache/commons/collections/observed/ModificationHandlerFactory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandlerFactory.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandlerFactory.java,v 1.2 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import java.util.Collection;\n \n-\n /**\n  * Defines a factory for creating ModificationHandler instances.\n  * <p>\n  * fully thread-safe. There are two steps:\n  * <ol>\n  * <li>A factory must be created that is an implementation of this class\n- * <li>One of the <code>registerFactory</code> methods must be called on ObservedCollection\n+ * <li>One of the <code>registerFactory</code> methods must be called on ObservableCollection\n  * </ol>\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservableBag.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservableBag.java,v 1.1 2003/09/21 16:00:28 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+\n+/**\n+ * Decorates a <code>Bag</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Bag</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ * <p>\n+ * NOTE: The {@link #uniqueSet()} method returns a <code>Set</code> that is\n+ * NOT observed. This is because the set should be unmodifiable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/21 16:00:28 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservableBag extends ObservableCollection implements Bag {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable bag.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param bag  the bag to decorate, must not be null\n+     * @return the observed Bag\n+     * @throws IllegalArgumentException if the bag is null\n+     */\n+    public static ObservableBag decorate(final Bag bag) {\n+        return new ObservableBag(bag, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable bag using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservableBag</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param bag  the bag to decorate, must not be null\n+     * @param listener  bag listener, may be null\n+     * @return the observed bag\n+     * @throws IllegalArgumentException if the bag is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservableBag decorate(\n+            final Bag bag,\n+            final Object listener) {\n+        \n+        if (bag == null) {\n+            throw new IllegalArgumentException(\"Bag must not be null\");\n+        }\n+        return new ObservableBag(bag, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the bag is null\n+     */\n+    protected ObservableBag(\n+            final Bag bag,\n+            final Object listener) {\n+        super(bag, listener);\n+    }\n+    \n+    /**\n+     * Typecast the collection to a Bag.\n+     * \n+     * @return the wrapped collection as a Bag\n+     */\n+    private Bag getBag() {\n+        return (Bag) getCollection();\n+    }\n+\n+    // Bag API\n+    //-----------------------------------------------------------------------\n+    public int getCount(Object object) {\n+        return getBag().getCount(object);\n+    }\n+\n+    public Set uniqueSet() {\n+        return getBag().uniqueSet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(Object object) {\n+        // override as Bag violates Collection contract\n+        boolean result = false;\n+        if (handler.preAdd(object)) {\n+            result = collection.add(object);\n+            handler.postAdd(object, true);  // true, as result is misleading\n+        }\n+        return result;\n+    }\n+\n+    public boolean add(Object object, int nCopies) {\n+        boolean result = false;\n+        if (handler.preAddNCopies(object, nCopies)) {\n+            result = getBag().add(object, nCopies);\n+            handler.postAddNCopies(object, nCopies, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean remove(Object object, int nCopies) {\n+        boolean result = false;\n+        if (handler.preRemoveNCopies(object, nCopies)) {\n+            result = getBag().remove(object, nCopies);\n+            handler.postRemoveNCopies(object, nCopies, result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservableBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservableBuffer.java,v 1.1 2003/09/21 16:00:28 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import org.apache.commons.collections.Buffer;\n+\n+/**\n+ * Decorates a <code>Buffer</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Buffer</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/21 16:00:28 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservableBuffer extends ObservableCollection implements Buffer {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable buffer.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @return the observed Buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    public static ObservableBuffer decorate(final Buffer buffer) {\n+        return new ObservableBuffer(buffer, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable buffer using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservableBuffer</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param listener  buffer listener, may be null\n+     * @return the observed buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservableBuffer decorate(\n+            final Buffer buffer,\n+            final Object listener) {\n+        \n+        if (buffer == null) {\n+            throw new IllegalArgumentException(\"Buffer must not be null\");\n+        }\n+        return new ObservableBuffer(buffer, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected ObservableBuffer(\n+            final Buffer buffer,\n+            final Object listener) {\n+        super(buffer, listener);\n+    }\n+    \n+    /**\n+     * Typecast the collection to a Buffer.\n+     * \n+     * @return the wrapped collection as a Buffer\n+     */\n+    private Buffer getBuffer() {\n+        return (Buffer) getCollection();\n+    }\n+\n+    // Buffer API\n+    //-----------------------------------------------------------------------\n+    public Object get() {\n+        return getBuffer().get();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Object remove() {\n+        Object result = null;\n+        if (handler.preRemoveNext()) {\n+            result = getBuffer().remove();\n+            handler.postRemoveNext(result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservableCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservableCollection.java,v 1.1 2003/09/21 16:00:28 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.decorators.AbstractCollectionDecorator;\n+import org.apache.commons.collections.decorators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.observed.standard.StandardModificationHandler;\n+\n+/**\n+ * Decorates a <code>Collection</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Collection</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/21 16:00:28 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservableCollection extends AbstractCollectionDecorator {\n+    \n+    /** The list of registered factories, checked in reverse order */\n+    private static ModificationHandlerFactory[] factories = new ModificationHandlerFactory[] {\n+        ModificationHandler.FACTORY,\n+        StandardModificationHandler.FACTORY\n+    };\n+    \n+    /** The handler to delegate event handling to */\n+    protected final ModificationHandler handler;\n+\n+    // ObservableCollection factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable collection.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public static ObservableCollection decorate(final Collection coll) {\n+        return new ObservableCollection(coll, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservableCollection</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @param listener  collection listener, may be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservableCollection decorate(\n+            final Collection coll,\n+            final Object listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        return new ObservableCollection(coll, listener);\n+    }\n+\n+    // Register for ModificationHandlerFactory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Registers a handler factory to be used for looking up a listener to\n+     * a handler.\n+     * <p>\n+     * This method is used to add your own event handler to the supplied ones.\n+     * Registering the factory will enable the {@link #decorate(Collection, Object)}\n+     * method to create your handler.\n+     * <p>\n+     * Each handler added becomes the first in the lookup chain. Thus it is\n+     * possible to override the default setup.\n+     * Obviously this should be done with care in a shared web environment!\n+     * <p>\n+     * This method is not guaranteed to be threadsafe.\n+     * It should only be called during initialization.\n+     * Problems will occur if two threads call this method at the same time.\n+     * \n+     * @param factory  the factory to add, may be null\n+     */\n+    public static void registerFactory(final ModificationHandlerFactory factory) {\n+        if (factory != null) {\n+            // add at end, as checked in reverse order\n+            ModificationHandlerFactory[] array = new ModificationHandlerFactory[factories.length + 1];\n+            System.arraycopy(factories, 0, array, 0, factories.length);\n+            array[factories.length] = factory;\n+            factories = array;  // atomic operation\n+        }\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param handler  the observing handler, may be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected ObservableCollection(\n+            final Collection coll,\n+            final Object listener) {\n+        super(coll);\n+        this.handler = createHandler(coll, listener);\n+        this.handler.init(this, coll);\n+    }\n+\n+    /**\n+     * Constructor used by subclass views, such as subList.\n+     * \n+     * @param handler  the observing handler, may be null\n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected ObservableCollection(\n+            final ModificationHandler handler,\n+            final Collection coll) {\n+        super(coll);\n+        this.handler = handler;\n+    }\n+\n+    /**\n+     * Creates a handler subclass based on the specified listener.\n+     * <p>\n+     * The method is defined in terms of an Object to allow for unusual\n+     * listeners, such as a Swing model object.\n+     * \n+     * @param listener  a listener object to create a handler for\n+     * @return an instantiated handler with the listener attached\n+     * @throws IllegalArgumentException if no suitable handler\n+     */\n+    protected ModificationHandler createHandler(final Collection coll, final Object listener) {\n+        if (listener == null) {\n+            return new StandardModificationHandler();\n+        }\n+        ModificationHandlerFactory[] array = factories;  // atomic operation\n+        for (int i = array.length - 1; i >= 0 ; i--) {\n+            ModificationHandler handler = array[i].createHandler(coll, listener);\n+            if (handler != null) {\n+                return handler;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Unrecognised listener type: \" +\n+            (listener == null ? \"null\" : listener.getClass().getName()));\n+    }\n+\n+    // Handler access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the handler that is observing this collection.\n+     * \n+     * @return the observing handler, never null\n+     */\n+    public ModificationHandler getHandler() {\n+        return handler;\n+    }\n+    \n+    // Collection\n+    //-----------------------------------------------------------------------\n+    public boolean add(Object object) {\n+        boolean result = false;\n+        if (handler.preAdd(object)) {\n+            result = collection.add(object);\n+            handler.postAdd(object, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean addAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preAddAll(coll)) {\n+            result = collection.addAll(coll);\n+            handler.postAddAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public void clear() {\n+        if (handler.preClear()) {\n+            collection.clear();\n+            handler.postClear();\n+        }\n+    }\n+\n+    public Iterator iterator() {\n+        return new ObservableIterator(collection.iterator());\n+    }\n+\n+    public boolean remove(Object object) {\n+        boolean result = false;\n+        if (handler.preRemove(object)) {\n+            result = collection.remove(object);\n+            handler.postRemove(object, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean removeAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preRemoveAll(coll)) {\n+            result = collection.removeAll(coll);\n+            handler.postRemoveAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean retainAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preRetainAll(coll)) {\n+            result = collection.retainAll(coll);\n+            handler.postRetainAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    // Iterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Iterator for the ObservableCollection.\n+     */\n+    protected class ObservableIterator extends AbstractIteratorDecorator {\n+        \n+        protected int lastIndex = -1;\n+        protected Object last;\n+        \n+        protected ObservableIterator(Iterator iterator) {\n+            super(iterator);\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            lastIndex++;\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (handler.preRemoveIterated(lastIndex, last)) {\n+                iterator.remove();\n+                handler.postRemoveIterated(lastIndex, last);\n+                lastIndex--;\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservableList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservableList.java,v 1.1 2003/09/21 16:00:28 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.decorators.AbstractListIteratorDecorator;\n+\n+/**\n+ * Decorates a <code>List</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>List</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ * <p>\n+ * All indices on events returned by <code>subList</code> are relative to the\n+ * base <code>List</code>.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/21 16:00:28 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservableList extends ObservableCollection implements List {\n+\n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable list.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @return the observed List\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    public static ObservableList decorate(final List list) {\n+        return new ObservableList(list, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable list using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservableList</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @param listener  list listener, may be null\n+     * @return the observed list\n+     * @throws IllegalArgumentException if the list is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservableList decorate(\n+            final List list,\n+            final Object listener) {\n+        \n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        return new ObservableList(list, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    protected ObservableList(\n+            final List list,\n+            final Object listener) {\n+        super(list, listener);\n+    }\n+    \n+    /**\n+     * Constructor used by subclass views, such as subList.\n+     * \n+     * @param handler  the handler to use, must not be null\n+     * @param list  the subList to decorate, must not be null\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    protected ObservableList(\n+            final ModificationHandler handler,\n+            final List list) {\n+        super(handler, list);\n+    }\n+    \n+    /**\n+     * Typecast the collection to a List.\n+     * \n+     * @return the wrapped collection as a List\n+     */\n+    private List getList() {\n+        return (List) getCollection();\n+    }\n+\n+    // List API\n+    //-----------------------------------------------------------------------\n+    public Object get(int index) {\n+        return getList().get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return getList().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        return getList().lastIndexOf(object);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, Object object) {\n+        if (handler.preAddIndexed(index, object)) {\n+            getList().add(index, object);\n+            handler.postAddIndexed(index, object);\n+        }\n+    }\n+\n+    public boolean addAll(int index, Collection coll) {\n+        boolean result = false;\n+        if (handler.preAddAllIndexed(index, coll)) {\n+            result = getList().addAll(index, coll);\n+            handler.postAddAllIndexed(index, coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public Object remove(int index) {\n+        Object result = null;\n+        if (handler.preRemoveIndexed(index)) {\n+            result = getList().remove(index);\n+            handler.postRemoveIndexed(index, result);\n+        }\n+        return result;\n+    }\n+\n+    public Object set(int index, Object object) {\n+        Object result = null;\n+        if (handler.preSetIndexed(index, object)) {\n+            result = getList().set(index, object);\n+            handler.postSetIndexed(index, object, result);\n+        }\n+        return result;\n+    }\n+\n+    public ListIterator listIterator() {\n+        return new ObservableListIterator(getList().listIterator());\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        return new ObservableListIterator(getList().listIterator(index));\n+    }\n+\n+    /**\n+     * Returns a subList view on the original base <code>List</code>.\n+     * <p>\n+     * Changes to the subList affect the underlying List. Change events will\n+     * return change indices relative to the underlying List, not the subList.\n+     * \n+     * @param fromIndex  inclusive start index of the range\n+     * @param toIndex  exclusive end index of the range\n+     * @return the subList view\n+     */\n+    public List subList(int fromIndex, int toIndex) {\n+        List subList = getList().subList(fromIndex, toIndex);\n+        return new ObservableList(subList, getHandler().createSubListHandler(fromIndex, toIndex));\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class ListIterator for the ObservableList.\n+     */\n+    protected class ObservableListIterator extends AbstractListIteratorDecorator {\n+        \n+        protected Object last;\n+        \n+        protected ObservableListIterator(ListIterator iterator) {\n+            super(iterator);\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public Object previous() {\n+            last = iterator.previous();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            int index = iterator.previousIndex();\n+            if (handler.preRemoveIterated(index, last)) {\n+                iterator.remove();\n+                handler.postRemoveIterated(index, last);\n+            }\n+        }\n+        \n+        public void add(Object object) {\n+            int index = iterator.nextIndex();\n+            if (handler.preAddIterated(index, object)) {\n+                iterator.add(object);\n+                handler.postAddIterated(index, object);\n+            }\n+        }\n+\n+        public void set(Object object) {\n+            int index = iterator.previousIndex();\n+            if (handler.preSetIterated(index, object, last)) {\n+                iterator.set(object);\n+                handler.postSetIterated(index, object, last);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservableSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservableSet.java,v 1.1 2003/09/21 16:00:28 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Set;\n+\n+\n+/**\n+ * Decorates a <code>Set</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Set</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/21 16:00:28 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservableSet extends ObservableCollection implements Set {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable set.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @return the observed Set\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public static ObservableSet decorate(final Set set) {\n+        return new ObservableSet(set, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservableSet</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param listener  set listener, may be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservableSet decorate(\n+            final Set set,\n+            final Object listener) {\n+        \n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        return new ObservableSet(set, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the set is null\n+     */\n+    protected ObservableSet(\n+            final Set set,\n+            final Object listener) {\n+        super(set, listener);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationEvent.java,v 1.5 2003/09/07 10:33:33 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationEvent.java,v 1.6 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.observed.ModificationEvent;\n import org.apache.commons.collections.observed.ModificationEventType;\n import org.apache.commons.collections.observed.ModificationHandler;\n-import org.apache.commons.collections.observed.ObservedCollection;\n+import org.apache.commons.collections.observed.ObservableCollection;\n \n /**\n  * Event class that encapsulates the event information for a\n  * All objects used are the real objects from the method calls, not clones.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2003/09/07 10:33:33 $\n+ * @version $Revision: 1.6 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n     /** The result of the method call */\n     protected final Object previous;\n     /** The range that the event came from, null if none */\n-    protected final ObservedCollection range;\n+    protected final ObservableCollection range;\n     /** The offset of the range that the event came from, -1 if none */\n     protected final int rangeOffset;\n \n      * @param rangeOffset  the offset of the range, -1 if unknown\n      */\n     public StandardModificationEvent(\n-        final ObservedCollection obsCollection,\n+        final ObservableCollection obsCollection,\n         final ModificationHandler handler,\n         final int type,\n         final int preSize,\n         final Object object,\n         final int repeat,\n         final Object previous,\n-        final ObservedCollection range,\n+        final ObservableCollection range,\n         final int rangeOffset) {\n \n         super(obsCollection, handler, type);\n      * \n      * @return the range\n      */\n-    public ObservedCollection getRange() {\n+    public ObservableCollection getRange() {\n         return range;\n     }\n \n      */\n     public String toString() {\n         StringBuffer buf = new StringBuffer(64);\n-        buf.append(\"ObservedEvent[type=\");\n+        buf.append(\"ModificationEvent[type=\");\n         buf.append(ModificationEventType.toString(type));\n         if (index >= 0) {\n             buf.append(\",index=\");\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardModificationHandler.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationHandler.java,v 1.4 2003/09/07 10:33:33 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationHandler.java,v 1.5 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.observed.ModificationEventType;\n import org.apache.commons.collections.observed.ModificationHandler;\n import org.apache.commons.collections.observed.ModificationHandlerFactory;\n-import org.apache.commons.collections.observed.ObservedCollection;\n+import org.apache.commons.collections.observed.ObservableCollection;\n \n /**\n  * The standard implementation of a <code>ModificationHandler</code> that\n  * modification events.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/09/07 10:33:33 $\n+ * @version $Revision: 1.5 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n     /**\n      * Constructor the creates the handler but leaves it invalid.\n      * <p>\n-     * The handler can only be used after {@link #init(ObservedCollection)} is\n+     * The handler can only be used after {@link #init(ObservableCollection)} is\n      * called. This is normally done automatically by\n-     * {@link ObservedCollection#decorate(Collection, ModificationHandler)}.\n+     * {@link ObservableCollection#decorate(Collection, ModificationHandler)}.\n      */\n     public StandardModificationHandler() {\n         super();\n     /**\n      * Constructor the creates the handler but leaves it invalid.\n      * <p>\n-     * The handler can only be used after {@link #init(ObservedCollection)} is\n+     * The handler can only be used after {@link #init(ObservableCollection)} is\n      * called. This is normally done automatically by\n-     * {@link ObservedCollection#decorate(Collection, ModificationHandler)}.\n+     * {@link ObservableCollection#decorate(Collection, ModificationHandler)}.\n      * \n      * @param pre  the pre listener\n      * @param preMask  the mask for the pre listener\n      */\n     protected boolean preEvent(\n             int type, int index, Object object,\n-            int repeat, Object previous, ObservedCollection range, int rangeOffset) {\n+            int repeat, Object previous, ObservableCollection range, int rangeOffset) {\n \n         preSize = getObservedCollection().size();\n         return firePreEvent(type, index, object, repeat, previous, range, rangeOffset);\n      */\n     protected boolean firePreEvent(\n             int type, int index, Object object, int repeat,\n-            Object previous, ObservedCollection range, int rangeOffset) {\n+            Object previous, ObservableCollection range, int rangeOffset) {\n \n         if ((preMask & type) > 0) {\n             StandardPreModificationEvent event = null;\n      */\n     protected void postEvent(\n             boolean modified, int type, int index, Object object,\n-            int repeat, Object previous, ObservedCollection range, int rangeOffset) {\n+            int repeat, Object previous, ObservableCollection range, int rangeOffset) {\n \n         if (modified) {\n             firePostEvent(type, index, object, repeat, previous, range, rangeOffset);\n      */\n     protected void firePostEvent(\n             int type, int index, Object object, int repeat,\n-            Object previous, ObservedCollection range, int rangeOffset) {\n+            Object previous, ObservableCollection range, int rangeOffset) {\n \n         if ((postMask & type) > 0) {\n             StandardPostModificationEvent event = null;\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardPostModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardPostModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPostModificationEvent.java,v 1.3 2003/09/07 10:33:33 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPostModificationEvent.java,v 1.4 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n package org.apache.commons.collections.observed.standard;\n \n import org.apache.commons.collections.observed.ModificationHandler;\n-import org.apache.commons.collections.observed.ObservedCollection;\n+import org.apache.commons.collections.observed.ObservableCollection;\n \n /**\n  * Event class that encapsulates all the event information for a\n  * All objects used are the real objects from the method calls, not clones.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/09/07 10:33:33 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n      * @param rangeOffset  the offset of the range, -1 if unknown\n      */\n     public StandardPostModificationEvent(\n-        final ObservedCollection obsCollection,\n+        final ObservableCollection obsCollection,\n         final ModificationHandler handler,\n         final int type,\n         final int preSize,\n         final Object object,\n         final int repeat,\n         final Object previous,\n-        final ObservedCollection range,\n+        final ObservableCollection range,\n         final int rangeOffset) {\n \n         super(obsCollection, handler, type, preSize, index,\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardPreModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardPreModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPreModificationEvent.java,v 1.3 2003/09/07 10:33:33 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPreModificationEvent.java,v 1.4 2003/09/21 16:00:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n package org.apache.commons.collections.observed.standard;\n \n import org.apache.commons.collections.observed.ModificationHandler;\n-import org.apache.commons.collections.observed.ObservedCollection;\n+import org.apache.commons.collections.observed.ObservableCollection;\n \n /**\n  * Event class that encapsulates all the event information for a\n  * All objects used are the real objects from the method calls, not clones.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/09/07 10:33:33 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/21 16:00:28 $\n  * \n  * @author Stephen Colebourne\n  */\n      * @param previous  the previous value being removed/replaced\n      */\n     public StandardPreModificationEvent(\n-        final ObservedCollection obsCollection,\n+        final ObservableCollection obsCollection,\n         final ModificationHandler handler,\n         final int type,\n         final int preSize,\n         final Object object,\n         final int repeat,\n         final Object previous,\n-        final ObservedCollection range,\n+        final ObservableCollection range,\n         final int rangeOffset) {\n \n         super(obsCollection, handler, type, preSize, index,\n--- a/src/test/org/apache/commons/collections/observed/ObservedTestHelper.java\n+++ b/src/test/org/apache/commons/collections/observed/ObservedTestHelper.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/ObservedTestHelper.java,v 1.7 2003/09/20 12:13:59 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/ObservedTestHelper.java,v 1.8 2003/09/21 16:00:55 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * {@link ObservedCollection} implementations.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.7 $ $Date: 2003/09/20 12:13:59 $\n+ * @version $Revision: 1.8 $ $Date: 2003/09/21 16:00:55 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n     \n     public static interface ObservedFactory {\n-        ObservedCollection createObservedCollection();\n-        ObservedCollection createObservedCollection(Object listener);\n+        ObservableCollection createObservedCollection();\n+        ObservableCollection createObservedCollection(Object listener);\n     }\n     \n     public static final Listener LISTENER = new Listener();\n     }\n     \n     public static void bulkTestObservedSet(ObservedFactory factory) {\n-        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedSet);\n-        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedSet);\n-        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedSet);\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservableSet);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservableSet);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservableSet);\n         \n         bulkTestObservedCollection(factory);\n     }\n     \n     public static void bulkTestObservedList(ObservedFactory factory) {\n-        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedList);\n-        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedList);\n-        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedList);\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservableList);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservableList);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservableList);\n         \n         bulkTestObservedCollection(factory);\n         doTestAddIndexed(factory);\n     }\n     \n     public static void bulkTestObservedBag(ObservedFactory factory) {\n-        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedBag);\n-        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedBag);\n-        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedBag);\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservableBag);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservableBag);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservableBag);\n         \n         bulkTestObservedCollection(factory);\n         doTestAddNCopies(factory);\n     }\n     \n     public static void bulkTestObservedBuffer(ObservedFactory factory) {\n-        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedBuffer);\n-        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedBuffer);\n-        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedBuffer);\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservableBuffer);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservableBuffer);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservableBuffer);\n         \n         bulkTestObservedCollection(factory);\n         doTestRemoveNext(factory);\n     \n     //-----------------------------------------------------------------------\n     public static void doTestFactoryPlain(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection();\n+        ObservableCollection coll = factory.createObservedCollection();\n         \n         Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n     }\n     \n     public static void doTestFactoryWithPreListener(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(PRE_LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(PRE_LISTENER);\n         \n         Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n     }\n     \n     public static void doTestFactoryWithPostListener(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(POST_LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(POST_LISTENER);\n         \n         Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n     }\n     \n     public static void doTestFactoryWithListener(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n     \n     public static void doTestFactoryWithHandler(ObservedFactory factory) {\n         StandardModificationHandler handler = new StandardModificationHandler();\n-        ObservedCollection coll = factory.createObservedCollection(handler);\n+        ObservableCollection coll = factory.createObservedCollection(handler);\n         \n         Assert.assertNotNull(coll.getHandler());\n         Assert.assertSame(handler, coll.getHandler());\n     }\n     \n     public static void doTestFactoryWithNull(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(null);\n+        ObservableCollection coll = factory.createObservedCollection(null);\n         \n         Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n     \n     //-----------------------------------------------------------------------\n     public static void doTestAddRemoveGetPreListeners(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection();\n+        ObservableCollection coll = factory.createObservedCollection();\n         \n         Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n         coll.getHandler().addPreModificationListener(LISTENER);\n     }\n     \n     public static void doTestAddRemoveGetPostListeners(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection();\n+        ObservableCollection coll = factory.createObservedCollection();\n         \n         Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n         coll.getHandler().addPostModificationListener(LISTENER);\n     \n     //-----------------------------------------------------------------------\n     public static void doTestAdd(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         LISTENER.preEvent = null;\n         LISTENER.postEvent = null;\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeBulk());\n         \n         // this isn't a full test, but...\n-        Assert.assertEquals(false, LISTENER.postEvent.getBaseCollection() instanceof ObservedCollection);\n+        Assert.assertEquals(false, LISTENER.postEvent.getBaseCollection() instanceof ObservableCollection);\n         \n         LISTENER.preEvent = null;\n         LISTENER.postEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestAddIndexed(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestAddNCopies(ObservedFactory factory) {\n-        ObservedBag coll = (ObservedBag) factory.createObservedCollection(LISTENER);\n+        ObservableBag coll = (ObservableBag) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestAddIterated(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestAddAll(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         LISTENER.preEvent = null;\n         LISTENER.postEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestAddAllIndexed(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestClear(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestRemove(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestRemoveIndexed(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestRemoveNCopies(ObservedFactory factory) {\n-        ObservedBag coll = (ObservedBag) factory.createObservedCollection(LISTENER);\n+        ObservableBag coll = (ObservableBag) factory.createObservedCollection(LISTENER);\n         \n         coll.add(SIX, 6);\n         coll.add(SEVEN, 7);\n \n     //-----------------------------------------------------------------------\n     public static void doTestRemoveNext(ObservedFactory factory) {\n-        ObservedBuffer coll = (ObservedBuffer) factory.createObservedCollection(LISTENER);\n+        ObservableBuffer coll = (ObservableBuffer) factory.createObservedCollection(LISTENER);\n         \n         coll.add(SIX);\n         coll.add(SEVEN);\n \n     //-----------------------------------------------------------------------\n     public static void doTestRemoveIterated(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n     }\n \n     public static void doTestRemoveListIterated(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestRemoveAll(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         coll.add(EIGHT);\n         coll.addAll(SIX_SEVEN_LIST);\n \n     //-----------------------------------------------------------------------\n     public static void doTestRetainAll(ObservedFactory factory) {\n-        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        ObservableCollection coll = factory.createObservedCollection(LISTENER);\n         \n         coll.add(EIGHT);\n         coll.addAll(SIX_SEVEN_LIST);\n \n     //-----------------------------------------------------------------------\n     public static void doTestSetIndexed(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestSetIterated(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         LISTENER.preEvent = null;\n \n     //-----------------------------------------------------------------------\n     public static void doTestSubList(ObservedFactory factory) {\n-        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        ObservableList coll = (ObservableList) factory.createObservedCollection(LISTENER);\n         \n         coll.addAll(SIX_SEVEN_LIST);\n         coll.add(EIGHT);\n--- a/src/test/org/apache/commons/collections/observed/TestObservedBag.java\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedBag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedBag.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedBag.java,v 1.2 2003/09/21 16:00:55 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n /**\n  * Extension of {@link TestBag} for exercising the\n- * {@link ObservedBag} implementation.\n+ * {@link ObservableBag} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/21 16:00:55 $\n  * \n  * @author Stephen Colebourne\n  */\n \n     //-----------------------------------------------------------------------\n     public Bag makeBag() {\n-        return ObservedBag.decorate(new HashBag(), ObservedTestHelper.LISTENER);\n+        return ObservableBag.decorate(new HashBag(), ObservedTestHelper.LISTENER);\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public ObservedCollection createObservedCollection() {\n-        return ObservedBag.decorate(new HashBag());\n+    public ObservableCollection createObservedCollection() {\n+        return ObservableBag.decorate(new HashBag());\n     }\n \n-    public ObservedCollection createObservedCollection(Object listener) {\n-        return ObservedBag.decorate(new HashBag(), listener);\n+    public ObservableCollection createObservedCollection(Object listener) {\n+        return ObservableBag.decorate(new HashBag(), listener);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/observed/TestObservedBuffer.java\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedBuffer.java,v 1.1 2003/09/07 16:50:59 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedBuffer.java,v 1.2 2003/09/21 16:00:55 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n /**\n  * Extension of {@link TestCollection} for exercising the\n- * {@link ObservedBuffer} implementation.\n+ * {@link ObservableBuffer} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/07 16:50:59 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/21 16:00:55 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n     \n     public Collection makeCollection() {\n-        return ObservedBuffer.decorate(new ArrayStack(), ObservedTestHelper.LISTENER);\n+        return ObservableBuffer.decorate(new ArrayStack(), ObservedTestHelper.LISTENER);\n     }\n \n     protected Collection makeFullCollection() {\n         List stack = new ArrayStack();\n         stack.addAll(Arrays.asList(getFullElements()));\n-        return ObservedBuffer.decorate(stack, ObservedTestHelper.LISTENER);\n+        return ObservableBuffer.decorate(stack, ObservedTestHelper.LISTENER);\n     }\n     \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public ObservedCollection createObservedCollection() {\n-        return ObservedBuffer.decorate(new ArrayStack());\n+    public ObservableCollection createObservedCollection() {\n+        return ObservableBuffer.decorate(new ArrayStack());\n     }\n \n-    public ObservedCollection createObservedCollection(Object listener) {\n-        return ObservedBuffer.decorate(new ArrayStack(), listener);\n+    public ObservableCollection createObservedCollection(Object listener) {\n+        return ObservableBuffer.decorate(new ArrayStack(), listener);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/observed/TestObservedCollection.java\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedCollection.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedCollection.java,v 1.2 2003/09/21 16:00:56 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * {@link ObservedCollection} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/21 16:00:56 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n     \n     public Collection makeCollection() {\n-        return ObservedCollection.decorate(new ArrayList(), ObservedTestHelper.LISTENER);\n+        return ObservableCollection.decorate(new ArrayList(), ObservedTestHelper.LISTENER);\n     }\n \n     protected Collection makeFullCollection() {\n         List list = new ArrayList();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return ObservedCollection.decorate(list, ObservedTestHelper.LISTENER);\n+        return ObservableCollection.decorate(list, ObservedTestHelper.LISTENER);\n     }\n     \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public ObservedCollection createObservedCollection() {\n-        return ObservedCollection.decorate(new ArrayList());\n+    public ObservableCollection createObservedCollection() {\n+        return ObservableCollection.decorate(new ArrayList());\n     }\n \n-    public ObservedCollection createObservedCollection(Object listener) {\n-        return ObservedCollection.decorate(new ArrayList(), listener);\n+    public ObservableCollection createObservedCollection(Object listener) {\n+        return ObservableCollection.decorate(new ArrayList(), listener);\n     }\n \n //  public void testFactoryWithMasks() {\n--- a/src/test/org/apache/commons/collections/observed/TestObservedList.java\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedList.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedList.java,v 1.2 2003/09/21 16:00:56 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * {@link ObservedList} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/21 16:00:56 $\n  * \n  * @author Stephen Colebourne\n  */\n \n     //-----------------------------------------------------------------------\n     public List makeEmptyList() {\n-        return ObservedList.decorate(new ArrayList(), ObservedTestHelper.LISTENER);\n+        return ObservableList.decorate(new ArrayList(), ObservedTestHelper.LISTENER);\n     }\n \n     protected List makeFullList() {\n         List set = new ArrayList();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return ObservedList.decorate(set, ObservedTestHelper.LISTENER);\n+        return ObservableList.decorate(set, ObservedTestHelper.LISTENER);\n     }\n     \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public ObservedCollection createObservedCollection() {\n-        return ObservedList.decorate(new ArrayList());\n+    public ObservableCollection createObservedCollection() {\n+        return ObservableList.decorate(new ArrayList());\n     }\n \n-    public ObservedCollection createObservedCollection(Object listener) {\n-        return ObservedList.decorate(new ArrayList(), listener);\n+    public ObservableCollection createObservedCollection(Object listener) {\n+        return ObservableList.decorate(new ArrayList(), listener);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/observed/TestObservedSet.java\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedSet.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedSet.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedSet.java,v 1.2 2003/09/21 16:00:56 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * {@link ObservedSet} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/21 16:00:56 $\n  * \n  * @author Stephen Colebourne\n  */\n \n     //-----------------------------------------------------------------------\n     public Set makeEmptySet() {\n-        return ObservedSet.decorate(new HashSet(), ObservedTestHelper.LISTENER);\n+        return ObservableSet.decorate(new HashSet(), ObservedTestHelper.LISTENER);\n     }\n \n     protected Set makeFullSet() {\n         Set set = new HashSet();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return ObservedSet.decorate(set, ObservedTestHelper.LISTENER);\n+        return ObservableSet.decorate(set, ObservedTestHelper.LISTENER);\n     }\n     \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public ObservedCollection createObservedCollection() {\n-        return ObservedSet.decorate(new HashSet());\n+    public ObservableCollection createObservedCollection() {\n+        return ObservableSet.decorate(new HashSet());\n     }\n \n-    public ObservedCollection createObservedCollection(Object listener) {\n-        return ObservedSet.decorate(new HashSet(), listener);\n+    public ObservableCollection createObservedCollection(Object listener) {\n+        return ObservableSet.decorate(new HashSet(), listener);\n     }\n \n }", "timestamp": 1064160056, "metainfo": ""}