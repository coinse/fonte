{"sha": "c301ea06f5f32d76b65bfeb920ce0eadc13cd702", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r753392 | mbenson | 2009-03-13 13:39:53 -0700 (Fri, 13 Mar 2009) | 1 line          revert IteratorUtils stuff; toList() works fine for this--duh     ------------------------------------------------------------------------     r751850 | mbenson | 2009-03-09 14:34:44 -0700 (Mon, 09 Mar 2009) | 1 line          add iterable(Iterator)     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/IteratorUtils.java\n+++ b/src/java/org/apache/commons/collections/IteratorUtils.java\n import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n \n /**\n- * Provides static utility methods and decorators for {@link Iterator} \n+ * Provides static utility methods and decorators for {@link Iterator}\n  * instances. The implementations are provided in the iterators subpackage.\n  * <p>\n  * WARNING: Due to human error certain binary incompatabilities were introduced\n      * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n      * Use <code>EmptyIterator.INSTANCE</code> for compatability with Commons Collections 2.1.1.\n      */\n-    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n+    public static final ResettableIterator<Object> EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n+\n     /**\n      * A list iterator over no elements.\n      * <p>\n      * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n      * Use <code>EmptyListIterator.INSTANCE</code> for compatability with Commons Collections 2.1.1.\n      */\n-    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n+    public static final ResettableListIterator<Object> EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n+\n     /**\n      * An ordered iterator over no elements.\n-     */    \n-    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n+     */\n+    public static final OrderedIterator<Object> EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n+\n     /**\n      * A map iterator over no elements.\n-     */    \n-    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n+     */\n+    public static final MapIterator<Object, Object> EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n+\n     /**\n      * An ordered map iterator over no elements.\n-     */    \n-    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n+     */\n+    public static final OrderedMapIterator<Object, Object> EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n \n     /**\n      * IteratorUtils is not normally instantiated.\n      *\n      * @return  an iterator over nothing\n      */\n-    public static ResettableIterator emptyIterator() {\n-        return EMPTY_ITERATOR;\n+    public static <E> ResettableIterator<E> emptyIterator() {\n+        return EmptyIterator.<E>getResettableInstance();\n     }\n \n     /**\n      * Gets an empty list iterator.\n      * <p>\n-     * This iterator is a valid list iterator object that will iterate \n+     * This iterator is a valid list iterator object that will iterate\n      * over nothing.\n      * <p>\n      * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n      *\n      * @return  a list iterator over nothing\n      */\n-    public static ResettableListIterator emptyListIterator() {\n-        return EMPTY_LIST_ITERATOR;\n+    public static <E> ResettableListIterator<E> emptyListIterator() {\n+        return EmptyListIterator.<E>getResettableInstance();\n     }\n \n     /**\n      * Gets an empty ordered iterator.\n      * <p>\n-     * This iterator is a valid iterator object that will iterate \n+     * This iterator is a valid iterator object that will iterate\n      * over nothing.\n      *\n      * @return  an ordered iterator over nothing\n      */\n-    public static OrderedIterator emptyOrderedIterator() {\n-        return EMPTY_ORDERED_ITERATOR;\n+    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n+        return EmptyOrderedIterator.<E>getInstance();\n     }\n \n     /**\n      * Gets an empty map iterator.\n      * <p>\n-     * This iterator is a valid map iterator object that will iterate \n+     * This iterator is a valid map iterator object that will iterate\n      * over nothing.\n      *\n      * @return  a map iterator over nothing\n      */\n-    public static MapIterator emptyMapIterator() {\n-        return EMPTY_MAP_ITERATOR;\n+    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n+        return EmptyMapIterator.<K, V>getInstance();\n     }\n \n     /**\n      * Gets an empty ordered map iterator.\n      * <p>\n-     * This iterator is a valid map iterator object that will iterate \n+     * This iterator is a valid map iterator object that will iterate\n      * over nothing.\n      *\n      * @return  a map iterator over nothing\n      */\n-    public static OrderedMapIterator emptyOrderedMapIterator() {\n-        return EMPTY_ORDERED_MAP_ITERATOR;\n+    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n+        return EmptyOrderedMapIterator.<K, V>getInstance();\n     }\n \n     // Singleton\n      * @param object  the single object over which to iterate\n      * @return  a singleton iterator over the object\n      */\n-    public static ResettableIterator singletonIterator(Object object) {\n-        return new SingletonIterator(object);\n+    public static <E> ResettableIterator<E> singletonIterator(E object) {\n+        return new SingletonIterator<E>(object);\n     }\n \n     /**\n      * @param object  the single object over which to iterate\n      * @return  a singleton list iterator over the object\n      */\n-    public static ListIterator singletonListIterator(Object object) {\n-        return new SingletonListIterator(object);\n+    public static <E> ListIterator<E> singletonListIterator(E object) {\n+        return new SingletonListIterator<E>(object);\n     }\n \n     // Arrays\n      * @return  an iterator over the array\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableIterator arrayIterator(Object[] array) {\n-        return new ObjectArrayIterator(array);\n+    public static <E> ResettableIterator<E> arrayIterator(E[] array) {\n+        return new ObjectArrayIterator<E>(array);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is not an array\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableIterator arrayIterator(Object array) {\n-        return new ArrayIterator(array);\n+    public static <E> ResettableIterator<E> arrayIterator(Object array) {\n+        return new ArrayIterator<E>(array);\n     }\n \n     /**\n      *  than the length of the array\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableIterator arrayIterator(Object[] array, int start) {\n-        return new ObjectArrayIterator(array, start);\n+    public static <E> ResettableIterator<E> arrayIterator(E[] array, int start) {\n+        return new ObjectArrayIterator<E>(array, start);\n     }\n \n     /**\n      *  than the length of the array\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableIterator arrayIterator(Object array, int start) {\n-        return new ArrayIterator(array, start);\n+    public static <E> ResettableIterator<E> arrayIterator(Object array, int start) {\n+        return new ArrayIterator<E>(array, start);\n     }\n \n     /**\n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableIterator arrayIterator(Object[] array, int start, int end) {\n-        return new ObjectArrayIterator(array, start, end);\n+    public static <E> ResettableIterator<E> arrayIterator(E[] array, int start, int end) {\n+        return new ObjectArrayIterator<E>(array, start, end);\n     }\n \n     /**\n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableIterator arrayIterator(Object array, int start, int end) {\n-        return new ArrayIterator(array, start, end);\n+    public static <E> ResettableIterator<E> arrayIterator(Object array, int start, int end) {\n+        return new ArrayIterator<E>(array, start, end);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return  a list iterator over the array\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableListIterator arrayListIterator(Object[] array) {\n-        return new ObjectArrayListIterator(array);\n+    public static <E> ResettableListIterator<E> arrayListIterator(E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the array is not an array\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableListIterator arrayListIterator(Object array) {\n-        return new ArrayListIterator(array);\n+    public static <E> ResettableListIterator<E> arrayListIterator(Object array) {\n+        return new ArrayListIterator<E>(array);\n     }\n \n     /**\n      * @throws IndexOutOfBoundsException if start is less than zero\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableListIterator arrayListIterator(Object[] array, int start) {\n-        return new ObjectArrayListIterator(array, start);\n+    public static <E> ResettableListIterator<E> arrayListIterator(E[] array, int start) {\n+        return new ObjectArrayListIterator<E>(array, start);\n     }\n \n     /**\n      * @throws IndexOutOfBoundsException if start is less than zero\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableListIterator arrayListIterator(Object array, int start) {\n-        return new ArrayListIterator(array, start);\n+    public static <E> ResettableListIterator<E> arrayListIterator(Object array, int start) {\n+        return new ArrayListIterator<E>(array, start);\n     }\n \n     /**\n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableListIterator arrayListIterator(Object[] array, int start, int end) {\n-        return new ObjectArrayListIterator(array, start, end);\n-    }\n-    \n+    public static <E> ResettableListIterator<E> arrayListIterator(E[] array, int start, int end) {\n+        return new ObjectArrayListIterator<E>(array, start, end);\n+    }\n+\n     /**\n      * Gets a list iterator over part of an object or primitive array.\n      * <p>\n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static ResettableListIterator arrayListIterator(Object array, int start, int end) {\n-        return new ArrayListIterator(array, start, end);\n-    }\n-    \n+    public static <E> ResettableListIterator<E> arrayListIterator(Object array, int start, int end) {\n+        return new ArrayListIterator<E>(array, start, end);\n+    }\n+\n     // Unmodifiable\n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to make immutable\n      * @return an immutable version of the iterator\n      */\n-    public static Iterator unmodifiableIterator(Iterator iterator) {\n+    public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n         return UnmodifiableIterator.decorate(iterator);\n     }\n-    \n+\n     /**\n      * Gets an immutable version of a {@link ListIterator}. The returned object\n      * will always throw an {@link UnsupportedOperationException} for\n      * @param listIterator  the iterator to make immutable\n      * @return an immutable version of the iterator\n      */\n-    public static ListIterator unmodifiableListIterator(ListIterator listIterator) {\n+    public static <E> ListIterator<E> unmodifiableListIterator(ListIterator<E> listIterator) {\n         return UnmodifiableListIterator.decorate(listIterator);\n     }\n \n      * @param mapIterator  the iterator to make immutable\n      * @return an immutable version of the iterator\n      */\n-    public static MapIterator unmodifiableMapIterator(MapIterator mapIterator) {\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> mapIterator) {\n         return UnmodifiableMapIterator.decorate(mapIterator);\n     }\n \n     // Chained\n     //-----------------------------------------------------------------------\n     /**\n-     * Gets an iterator that iterates through two {@link Iterator}s \n+     * Gets an iterator that iterates through two {@link Iterator}s\n      * one after another.\n      *\n      * @param iterator1  the first iterators to use, not null\n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if either iterator is null\n      */\n-    public static Iterator chainedIterator(Iterator iterator1, Iterator iterator2) {\n-        return new IteratorChain(iterator1, iterator2);\n-    }\n-\n-    /**\n-     * Gets an iterator that iterates through an array of {@link Iterator}s \n+    public static <E> Iterator<E> chainedIterator(Iterator<? extends E> iterator1, Iterator<? extends E> iterator2) {\n+        return new IteratorChain<E>(iterator1, iterator2);\n+    }\n+\n+    /**\n+     * Gets an iterator that iterates through an array of {@link Iterator}s\n      * one after another.\n      *\n      * @param iterators  the iterators to use, not null or empty or contain nulls\n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if iterators array is null or contains a null\n      */\n-    public static Iterator chainedIterator(Iterator[] iterators) {\n-        return new IteratorChain(iterators);\n-    }\n-\n-    /**\n-     * Gets an iterator that iterates through a collections of {@link Iterator}s \n+    public static <E> Iterator<E> chainedIterator(Iterator<? extends E>[] iterators) {\n+        return new IteratorChain<E>(iterators);\n+    }\n+\n+    /**\n+     * Gets an iterator that iterates through a collections of {@link Iterator}s\n      * one after another.\n      *\n      * @param iterators  the iterators to use, not null or empty or contain nulls\n      * @throws NullPointerException if iterators collection is null or contains a null\n      * @throws ClassCastException if the iterators collection contains the wrong object type\n      */\n-    public static Iterator chainedIterator(Collection iterators) {\n-        return new IteratorChain(iterators);\n+    public static <E> Iterator<E> chainedIterator(Collection<Iterator<? extends E>> iterators) {\n+        return new IteratorChain<E>(iterators);\n     }\n \n     // Collated\n      * contained in a collection of ordered {@link Iterator}s.\n      * <p>\n      * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n-     * the {@link Iterator#next()} method will return the lesser of \n+     * the {@link Iterator#next()} method will return the lesser of\n      * <code>A.next()</code> and <code>B.next()</code>.\n      * <p>\n      * The comparator is optional. If null is specified then natural order is used.\n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if either iterator is null\n      */\n-    public static Iterator collatedIterator(Comparator comparator, Iterator iterator1, Iterator iterator2) {\n-        return new CollatingIterator(comparator, iterator1, iterator2);\n+    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator, Iterator<? extends E> iterator1, Iterator<? extends E> iterator2) {\n+        return new CollatingIterator<E>(comparator, iterator1, iterator2);\n     }\n \n     /**\n      * contained in an array of {@link Iterator}s.\n      * <p>\n      * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n-     * the {@link Iterator#next()} method will return the lesser of \n+     * the {@link Iterator#next()} method will return the lesser of\n      * <code>A.next()</code> and <code>B.next()</code> and so on.\n      * <p>\n      * The comparator is optional. If null is specified then natural order is used.\n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if iterators array is null or contains a null\n      */\n-    public static Iterator collatedIterator(Comparator comparator, Iterator[] iterators) {\n-        return new CollatingIterator(comparator, iterators);\n+    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator, Iterator<? extends E>[] iterators) {\n+        return new CollatingIterator<E>(comparator, iterators);\n     }\n \n     /**\n      * contained in a collection of {@link Iterator}s.\n      * <p>\n      * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n-     * the {@link Iterator#next()} method will return the lesser of \n+     * the {@link Iterator#next()} method will return the lesser of\n      * <code>A.next()</code> and <code>B.next()</code> and so on.\n      * <p>\n      * The comparator is optional. If null is specified then natural order is used.\n      * @throws NullPointerException if iterators collection is null or contains a null\n      * @throws ClassCastException if the iterators collection contains the wrong object type\n      */\n-    public static Iterator collatedIterator(Comparator comparator, Collection iterators) {\n-        return new CollatingIterator(comparator, iterators);\n-    }\n-    \n+    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator,\n+            Collection<Iterator<? extends E>> iterators) {\n+        return new CollatingIterator<E>(comparator, iterators);\n+    }\n+\n     // Object Graph\n     //-----------------------------------------------------------------------\n     /**\n      * <p>\n      * Under many circumstances, linking Iterators together in this manner is\n      * more efficient (and convenient) than using nested for loops to extract a list.\n-     * \n+     *\n      * @param root  the root object to start iterating from, null results in an empty iterator\n      * @param transformer  the transformer to use, see above, null uses no effect transformer\n      * @return a new object graph iterator\n      * @since Commons Collections 3.1\n      */\n-    public static Iterator objectGraphIterator(Object root, Transformer transformer) {\n-        return new ObjectGraphIterator(root, transformer);\n-    }\n-    \n+    public static <E> Iterator<E> objectGraphIterator(E root, Transformer<? super E, ? extends E> transformer) {\n+        return new ObjectGraphIterator<E>(root, transformer);\n+    }\n+\n     // Transformed\n     //-----------------------------------------------------------------------\n     /**\n      * @return a new transforming iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static Iterator transformedIterator(Iterator iterator, Transformer transform) {\n+    public static <I, O> Iterator<O> transformedIterator(Iterator<? extends I> iterator, Transformer<? super I, ? extends O> transform) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (transform == null) {\n             throw new NullPointerException(\"Transformer must not be null\");\n         }\n-        return new TransformIterator(iterator, transform);\n-    }\n-    \n+        return new TransformIterator<I, O>(iterator, transform);\n+    }\n+\n     // Filtered\n     //-----------------------------------------------------------------------\n     /**\n      * @return a new filtered iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static Iterator filteredIterator(Iterator iterator, Predicate predicate) {\n+    public static <E> Iterator<E> filteredIterator(Iterator<? extends E> iterator, Predicate<? super E> predicate) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (predicate == null) {\n             throw new NullPointerException(\"Predicate must not be null\");\n         }\n-        return new FilterIterator(iterator, predicate);\n-    }\n-    \n+        return new FilterIterator<E>(iterator, predicate);\n+    }\n+\n     /**\n      * Gets a list iterator that filters another list iterator.\n      * <p>\n      * @return a new filtered iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static ListIterator filteredListIterator(ListIterator listIterator, Predicate predicate) {\n+    public static <E> ListIterator<E> filteredListIterator(ListIterator<? extends E> listIterator, Predicate<? super E> predicate) {\n         if (listIterator == null) {\n             throw new NullPointerException(\"ListIterator must not be null\");\n         }\n         if (predicate == null) {\n             throw new NullPointerException(\"Predicate must not be null\");\n         }\n-        return new FilterListIterator(listIterator, predicate);\n-    }\n-    \n+        return new FilterListIterator<E>(listIterator, predicate);\n+    }\n+\n     // Looping\n     //-----------------------------------------------------------------------\n     /**\n      * @return a new looping iterator\n      * @throws NullPointerException if the collection is null\n      */\n-    public static ResettableIterator loopingIterator(Collection coll) {\n+    public static <E> ResettableIterator<E> loopingIterator(Collection<? extends E> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"Collection must not be null\");\n         }\n-        return new LoopingIterator(coll);\n-    }\n-    \n+        return new LoopingIterator<E>(coll);\n+    }\n+\n     /**\n      * Gets an iterator that loops continuously over the supplied list.\n      * <p>\n      * @throws NullPointerException if the list is null\n      * @since Commons Collections 3.2\n      */\n-    public static ResettableListIterator loopingListIterator(List list) {\n+    public static <E> ResettableListIterator<E> loopingListIterator(List<E> list) {\n         if (list == null) {\n             throw new NullPointerException(\"List must not be null\");\n         }\n-        return new LoopingListIterator(list);\n-    }\n-    \n+        return new LoopingListIterator<E>(list);\n+    }\n+\n     // Views\n     //-----------------------------------------------------------------------\n     /**\n      * @param enumeration  the enumeration to use\n      * @return a new iterator\n      */\n-    public static Iterator asIterator(Enumeration enumeration) {\n+    public static <E> Iterator<E> asIterator(Enumeration<? extends E> enumeration) {\n         if (enumeration == null) {\n             throw new NullPointerException(\"Enumeration must not be null\");\n         }\n-        return new EnumerationIterator(enumeration);\n-    }\n-\n-    /**\n-     * Gets an iterator that provides an iterator view of the given enumeration \n+        return new EnumerationIterator<E>(enumeration);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an iterator view of the given enumeration\n      * that will remove elements from the specified collection.\n      *\n      * @param enumeration  the enumeration to use\n      * @param removeCollection  the collection to remove elements from\n      * @return a new iterator\n      */\n-    public static Iterator asIterator(Enumeration enumeration, Collection removeCollection) {\n+    public static <E> Iterator<E> asIterator(Enumeration<? extends E> enumeration, Collection<? super E> removeCollection) {\n         if (enumeration == null) {\n             throw new NullPointerException(\"Enumeration must not be null\");\n         }\n         if (removeCollection == null) {\n             throw new NullPointerException(\"Collection must not be null\");\n         }\n-        return new EnumerationIterator(enumeration, removeCollection);\n-    }\n-    \n+        return new EnumerationIterator<E>(enumeration, removeCollection);\n+    }\n+\n     /**\n      * Gets an enumeration that wraps an iterator.\n      *\n      * @return a new enumeration\n      * @throws NullPointerException if iterator is null\n      */\n-    public static Enumeration asEnumeration(Iterator iterator) {\n+    public static <E> Enumeration<E> asEnumeration(Iterator<? extends E> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n-        return new IteratorEnumeration(iterator);\n-    }\n-    \n+        return new IteratorEnumeration<E>(iterator);\n+    }\n+\n     /**\n      * Gets a list iterator based on a simple iterator.\n      * <p>\n      * @return a new iterator\n      * @throws NullPointerException if iterator parameter is null\n      */\n-    public static ListIterator toListIterator(Iterator iterator) {\n+    public static <E> ListIterator<E> toListIterator(Iterator<? extends E> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n-        return new ListIteratorWrapper(iterator);\n-    }\n-    \n+        return new ListIteratorWrapper<E>(iterator);\n+    }\n+\n     /**\n      * Gets an array based on an iterator.\n      * <p>\n      * @return an array of the iterator contents\n      * @throws NullPointerException if iterator parameter is null\n      */\n-    public static Object[] toArray(Iterator iterator) {\n+    public static Object[] toArray(Iterator<?> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n-        List list = toList(iterator, 100);\n+        List<?> list = toList(iterator, 100);\n         return list.toArray();\n     }\n-    \n+\n     /**\n      * Gets an array based on an iterator.\n      * <p>\n      * @throws NullPointerException if arrayClass is null\n      * @throws ClassCastException if the arrayClass is invalid\n      */\n-    public static Object[] toArray(Iterator iterator, Class arrayClass) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E[] toArray(Iterator<? extends E> iterator, Class<E> arrayClass) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (arrayClass == null) {\n             throw new NullPointerException(\"Array class must not be null\");\n         }\n-        List list = toList(iterator, 100);\n-        return list.toArray((Object[]) Array.newInstance(arrayClass, list.size()));\n-    }\n-    \n+        List<E> list = toList(iterator, 100);\n+        return list.toArray((E[]) Array.newInstance(arrayClass, list.size()));\n+    }\n+\n     /**\n      * Gets a list based on an iterator.\n      * <p>\n      * @return a list of the iterator contents\n      * @throws NullPointerException if iterator parameter is null\n      */\n-    public static List toList(Iterator iterator) {\n+    public static <E> List<E> toList(Iterator<? extends E> iterator) {\n         return toList(iterator, 10);\n     }\n-    \n+\n     /**\n      * Gets a list based on an iterator.\n      * <p>\n      * @throws NullPointerException if iterator parameter is null\n      * @throws IllegalArgumentException if the size is less than 1\n      */\n-    public static List toList(Iterator iterator, int estimatedSize) {\n+    public static <E> List<E> toList(Iterator<? extends E> iterator, int estimatedSize) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (estimatedSize < 1) {\n             throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n         }\n-        List list = new ArrayList(estimatedSize);\n+        List<E> list = new ArrayList<E>(estimatedSize);\n         while (iterator.hasNext()) {\n             list.add(iterator.next());\n         }\n         return list;\n     }\n-    \n-    /** \n+\n+    /**\n      * Gets a suitable Iterator for the given object.\n      * <p>\n-     * This method can handles objects as follows\n+     * This method can handle objects as follows\n      * <ul>\n      * <li>null - empty iterator\n      * <li>Iterator - returned directly\n      * <li>object with iterator() public method accessed by reflection\n      * <li>object - singleton iterator\n      * </ul>\n-     * \n+     *\n      * @param obj  the object to convert to an iterator\n      * @return a suitable iterator, never null\n      */\n-    public static Iterator getIterator(Object obj) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static Iterator<?> getIterator(Object obj) {\n         if (obj == null) {\n             return emptyIterator();\n-            \n-        } else if (obj instanceof Iterator) {\n+        }\n+        if (obj instanceof Iterator) {\n             return (Iterator) obj;\n-            \n-        } else if (obj instanceof Collection) {\n+        }\n+        if (obj instanceof Collection) {\n             return ((Collection) obj).iterator();\n-            \n-        } else if (obj instanceof Object[]) {\n+        }\n+        if (obj instanceof Object[]) {\n             return new ObjectArrayIterator((Object[]) obj);\n-            \n-        } else if (obj instanceof Enumeration) {\n+        }\n+        if (obj instanceof Enumeration) {\n             return new EnumerationIterator((Enumeration) obj);\n-            \n-        } else if (obj instanceof Map) {\n+        }\n+        if (obj instanceof Map) {\n             return ((Map) obj).values().iterator();\n-            \n-        } else if (obj instanceof Dictionary) {\n+        }\n+        if (obj instanceof Dictionary) {\n             return new EnumerationIterator(((Dictionary) obj).elements());\n-            \n         } else if (obj.getClass().isArray()) {\n             return new ArrayIterator(obj);\n-            \n-        } else {\n-            try {\n-                Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n-                if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n-                    Iterator it = (Iterator) method.invoke(obj, (Object[]) null);\n-                    if (it != null) {\n-                        return it;\n-                    }\n+        }\n+        try {\n+            Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n+            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n+                Iterator it = (Iterator) method.invoke(obj, (Object[]) null);\n+                if (it != null) {\n+                    return it;\n                 }\n-            } catch (Exception ex) {\n-                // ignore\n             }\n-            return singletonIterator(obj);\n-        }\n+        } catch (Exception ex) {\n+            // ignore\n+        }\n+        return singletonIterator(obj);\n     }\n \n }", "timestamp": 1252994133, "metainfo": ""}