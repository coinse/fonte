{"sha": "5546efd9f7cb1055d30af938f5bf22b2977a5ffa", "log": "Add javadoc, minor formatting.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/functors/ChainedTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ChainedTransformer.java\n \n     /**\n      * Factory method that performs validation and copies the parameter array.\n-     * \n+     *\n+     * @param <T>  the object type\n      * @param transformers  the transformers to chain, copied, no nulls\n      * @return the <code>chained</code> transformer\n      * @throws IllegalArgumentException if the transformers array is null\n      * Create a new Transformer that calls each transformer in turn, passing the \n      * result into the next transformer. The ordering is that of the iterator()\n      * method on the collection.\n-     * \n+     *\n+     * @param <T>  the object type\n      * @param transformers  a collection of transformers to chain\n      * @return the <code>chained</code> transformer\n      * @throws IllegalArgumentException if the transformers collection is null\n--- a/src/main/java/org/apache/commons/collections/functors/CloneTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/CloneTransformer.java\n \n     /**\n      * Factory returning the singleton instance.\n-     * \n+     *\n+     * @param <T>  the type of the objects to be cloned\n      * @return the singleton instance\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/ClosureTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ClosureTransformer.java\n \n     /**\n      * Factory method that performs validation.\n-     * \n+     *\n+     * @param <T>  the type of the object to transform\n      * @param closure  the closure to call, not null\n      * @return the <code>closure</code> transformer\n      * @throws IllegalArgumentException if the closure is null\n--- a/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if comparator is null of criterion is invalid\n      */\n-    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n+    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator,\n+                                                       final Criterion criterion) {\n         if (comparator == null) {\n             throw new IllegalArgumentException(\"Comparator must not be null.\");\n         }\n      * @see org.apache.commons.collections.Predicate#evaluate(java.lang.Object)\n      * @see java.util.Comparator#compare(java.lang.Object first, java.lang.Object second)\n      * \n+     * @param target  the target object to compare to\n+     * @return {@code true} if the comparison succeeds according to the selected criterion\n      * @throws IllegalStateException if the criterion is invalid (really not possible)\n      */\n     public boolean evaluate(final T target) {\n--- a/src/main/java/org/apache/commons/collections/functors/ConstantFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ConstantFactory.java\n     /**\n      * Factory method that performs validation.\n      *\n+     * @param <T>  the type of the constant\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/ConstantTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ConstantTransformer.java\n \n     /**\n      * Get a typed null instance.\n-     * @param <I>\n-     * @param <O>\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @return Transformer<I, O> that always returns null.\n      */\n     @SuppressWarnings(\"unchecked\")\n     /**\n      * Transformer method that performs validation.\n      *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/DefaultEquator.java\n+++ b/src/main/java/org/apache/commons/collections/functors/DefaultEquator.java\n /**\n  * Default {@link Equator} implementation.\n  * \n- * @param <T>\n+ * @param <T>  the types of object this {@link Equator} can evaluate.\n  * @since 4.0\n  * @version $Id$\n  */\n     /**\n      * Get a typed {@link DefaultEquator} instance.\n      * \n-     * @param <T>\n+     * @param <T>  the object type\n      * @return {@link DefaultEquator#INSTANCE}\n      */\n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/org/apache/commons/collections/functors/ExceptionFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionFactory.java\n     /**\n      * Factory returning the singleton instance.\n      * \n+     * @param <T>  the type the factory creates\n      * @return the singleton instance\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n     /**\n      * Factory returning the singleton instance.\n      *\n+     * @param <T>  the object type\n      * @return the singleton instance\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n     /**\n      * Factory returning the singleton instance.\n      *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @return the singleton instance\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/FactoryTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/FactoryTransformer.java\n     /**\n      * Factory method that performs validation.\n      * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @param factory  the factory to call, not null\n      * @return the <code>factory</code> transformer\n      * @throws IllegalArgumentException if the factory is null\n--- a/src/main/java/org/apache/commons/collections/functors/FunctorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/functors/FunctorUtils.java\n         for (final Predicate<T> predicate : predicates) {\n             preds[i] = predicate;\n             if (preds[i] == null) {\n-                throw new IllegalArgumentException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n+                throw new IllegalArgumentException(\n+                        \"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n             }\n             i++;\n         }\n         }\n         for (int i = 0; i < closures.length; i++) {\n             if (closures[i] == null) {\n-                throw new IllegalArgumentException(\"The closure array must not contain a null closure, index \" + i + \" was null\");\n+                throw new IllegalArgumentException(\n+                        \"The closure array must not contain a null closure, index \" + i + \" was null\");\n             }\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/IfClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/IfClosure.java\n      * @param trueClosure  closure used if true, not null\n      * @param falseClosure  closure used if false, not null\n      */\n-    public IfClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n+    public IfClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure,\n+                     final Closure<? super E> falseClosure) {\n         super();\n         iPredicate = predicate;\n         iTrueClosure = trueClosure;\n--- a/src/main/java/org/apache/commons/collections/functors/InstantiateFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InstantiateFactory.java\n     /**\n      * Factory method that performs validation.\n      * \n+     * @param <T>  the type the factory creates\n      * @param classToInstantiate  the class to instantiate, not null\n      * @param paramTypes  the constructor parameter types\n      * @param args  the constructor arguments\n      * @return a new instantiate factory\n      */\n-    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, Class<?>[] paramTypes,\n+                                                    Object[] args) {\n         if (classToInstantiate == null) {\n             throw new IllegalArgumentException(\"Class to instantiate must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n \n     /**\n      * Get a typed no-arg instance.\n-     * @param <T>\n+     *\n+     * @param <T>  the type of the objects to be created\n      * @return Transformer<Class<? extends T>, T>\n      */\n     public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n     /**\n      * Transformer method that performs validation.\n      *\n+     * @param <T>  the type of the objects to be created\n      * @param paramTypes  the constructor parameter types\n      * @param args  the constructor arguments\n      * @return an instantiate transformer\n--- a/src/main/java/org/apache/commons/collections/functors/InvokerTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InvokerTransformer.java\n     /**\n      * Gets an instance of this transformer calling a specific method with no arguments.\n      * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @param methodName  the method name to call\n      * @return an invoker transformer\n      * @since 3.1\n \n     /**\n      * Gets an instance of this transformer calling a specific method with specific values.\n-     * \n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @param methodName  the method name to call\n      * @param paramTypes  the parameter types of the method\n      * @param args  the arguments to pass to the method\n      * @return an invoker transformer\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, Class<?>[] paramTypes, Object[] args) {\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, Class<?>[] paramTypes,\n+                                                              Object[] args) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/MapTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/MapTransformer.java\n      * <p>\n      * If the map is null, a transformer that always returns null is returned.\n      *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @param map the map, not cloned\n      * @return the transformer\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/NOPTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NOPTransformer.java\n     /**\n      * Factory returning the singleton instance.\n      *\n+     * @param <T>  the input/output type\n      * @return the singleton instance\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/OrPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/OrPredicate.java\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n+                                               final Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/PredicateTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/PredicateTransformer.java\n     /**\n      * Factory method that performs validation.\n      * \n+     * @param <T>  the input type\n      * @param predicate  the predicate to call, not null\n      * @return the <code>predicate</code> transformer\n      * @throws IllegalArgumentException if the predicate is null\n--- a/src/main/java/org/apache/commons/collections/functors/PrototypeFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/PrototypeFactory.java\n      * <li>serialization clone\n      * <ul>\n      *\n+     * @param <T>  the type the factory creates\n      * @param prototype  the object to clone each time in the factory\n      * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n      * the {@code prototype} is {@code null}\n--- a/src/main/java/org/apache/commons/collections/functors/StringValueTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/StringValueTransformer.java\n     /**\n      * Factory returning the singleton instance.\n      *\n+     * @param <T>  the input type\n      * @return the singleton instance\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/functors/SwitchTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/SwitchTransformer.java\n     /**\n      * Factory method that performs validation and copies the parameter arrays.\n      * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n      * @param predicates  array of predicates, cloned, no nulls\n      * @param transformers  matching array of transformers, cloned, no nulls\n      * @param defaultTransformer  the transformer to use if no match, null means return null\n             throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n         }\n         if (predicates.length == 0) {\n-            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() :\n+                                                                     defaultTransformer);\n         }\n         return new SwitchTransformer<I, O>(FunctorUtils.copy(predicates),\n                                            FunctorUtils.copy(transformers),\n      * null key. The ordering is that of the iterator() method on the entryset \n      * collection of the map.\n      * \n-     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param map  a map of predicates to transformers\n      * @return the <code>switch</code> transformer\n      * @throws IllegalArgumentException if the map is null\n      * @throws IllegalArgumentException if any transformer in the map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <I, O> Transformer<I, O> switchTransformer(\n-            final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> predicatesAndTransformers) {\n-        if (predicatesAndTransformers == null) {\n+            final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n+\n+        if (map == null) {\n             throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n         }\n-        if (predicatesAndTransformers.size() == 0) {\n+        if (map.size() == 0) {\n             return ConstantTransformer.<I, O>nullTransformer();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        final Transformer<? super I, ? extends O> defaultTransformer = predicatesAndTransformers.remove(null);\n-        final int size = predicatesAndTransformers.size();\n+        final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n+        final int size = map.size();\n         if (size == 0) {\n-            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() :\n+                                                                     defaultTransformer);\n         }\n         final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n         final Predicate<? super I>[] preds = new Predicate[size];\n         int i = 0;\n-        for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : predicatesAndTransformers.entrySet()) {\n+        for (final Map.Entry<? extends Predicate<? super I>,\n+                             ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n             preds[i] = entry.getKey();\n             transformers[i] = entry.getValue();\n             i++;\n         super();\n         iPredicates = predicates;\n         iTransformers = transformers;\n-        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ?\n+                ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/collections/functors/TransformedPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformedPredicate.java\n      * @param transformer  the transformer to use\n      * @param predicate  the predicate to decorate\n      */\n-    public TransformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n+    public TransformedPredicate(final Transformer<? super T, ? extends T> transformer,\n+                                final Predicate<? super T> predicate) {\n         iTransformer = transformer;\n         iPredicate = predicate;\n     }", "timestamp": 1358716398, "metainfo": ""}