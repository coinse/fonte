{"sha": "dde27ccfcbca5ca433b83af55cb0104bb78096ac", "log": "Added new methods: #retainAll(Collection, Collection) #removeAll(Collection, Collection) #unmodifiableListCopy(Collection)   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n  * Provides utility methods and decorators for {@link List} instances.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.28 $ $Date: 2004/04/01 20:12:00 $\n+ * @version $Revision: 1.29 $ $Date: 2004/12/11 06:22:58 $\n  * \n  * @author Federico Barbieri\n  * @author Peter Donald\n         return UnmodifiableList.decorate(list);\n     }\n \n+    \n+\t/**\n+\t * Returns an unmodifiable list copy of the collection.\n+\t * <p>\n+\t * This method uses the unmodifiable list implementation in the decorators subpackage.\n+\t * @param collection the <code>Collection</code> to copy.\n+\t * @return an unmodifiable <code>List</code>.\n+\t * @throws IllegalArgumentException if collection is null.\n+\t */\n+\tpublic static List unmodifiableListCopy(final Collection collection) {\n+\t\tif (collection == null) throw new IllegalArgumentException(\"null not permitted.\");\n+\t\t\n+\t\tfinal List copy = new ArrayList(collection.size());\n+\t\tcopy.addAll(collection);\n+\t\treturn UnmodifiableList.decorate(copy);\n+\t}\n+    \n     /**\n      * Returns a predicated (validating) list backed by the given list.\n      * <p>\n         return FixedSizeList.decorate(list);\n     }\n \n+    /**\n+\t * Returns a List containing all the elements in <code>collection</code>\n+\t * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+\t * in the returned list is the same as the cardinality of <code>e</code>\n+\t * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+\t * case the cardinality is zero. This method is useful if you do not wish to modify\n+\t * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n+\t * \n+\t * @param collection the collection whose contents are the target of the #retailAll operation\n+\t * @param retain the collection containing the elements to be retained in the returned collection\n+\t * @return a <code>List</code> containing all the elements of <code>c</code>\n+\t * that occur at least once in <code>retain</code>.\n+\t * @throws NullPointerException if either parameter is null\n+\t */\n+\tpublic static List retainAll(final Collection collection, final Collection retain) {\n+\t\tfinal List list = new ArrayList(Math.min(collection.size(), retain.size()));\n+\n+\t\tObject item = null;\n+\t\tfor (final Iterator iter = collection.iterator(); iter.hasNext();)\n+\t\t{\n+\t\t\titem = iter.next();\n+\n+\t\t\tif (retain.contains(item))\n+\t\t\t{\n+\t\t\t\tlist.add(item);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn list;\n+\t}\n+\t\n+\t/**\n+\t * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+\t * method returns a list containing all the elements in <code>c</code>\n+\t * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+\t * in the returned collection is the same as the cardinality of <code>e</code>\n+\t * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+\t * case the cardinality is zero. This method is useful if you do not wish to modify\n+\t * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+\t * \n+\t * @param collection the collection from which items are removed (in the returned collection)\n+\t * @param remove the items to be removed from the returned <code>collection</code>\n+\t * @return a <code>List</code> containing all the elements of <code>c</code> except\n+\t * any elements that also occur in <code>remove</code>.\n+\t * @throws NullPointerException if either parameter is null\n+\t */\n+\tpublic static List removeAll(final Collection collection, final Collection remove) {\n+\t\tfinal List list = new ArrayList();\n+\n+\t\tObject o = null;\n+\t\tfor (final Iterator iter = collection.iterator(); iter.hasNext();)\n+\t\t{\n+\t\t\to = iter.next();\n+\t\t\tif (remove.contains(o) == false)\n+\t\t\t{\n+\t\t\t\tlist.add(o);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn list;\n+\t}\n+    \n }", "timestamp": 1102746178, "metainfo": ""}