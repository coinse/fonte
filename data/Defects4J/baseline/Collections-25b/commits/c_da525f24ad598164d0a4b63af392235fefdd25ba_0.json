{"sha": "da525f24ad598164d0a4b63af392235fefdd25ba", "log": "Renamed unit tests for buffer package.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/BlockingBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+\n+/**\n+ * Extension of {@link AbstractTestObject} for exercising the\n+ * {@link BlockingBuffer} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class BlockingBufferTest<E> extends AbstractTestObject {\n+\n+    public BlockingBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return BlockingBuffer.blockingBuffer(new MyBuffer<E>());\n+    }\n+\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected E makeElement() {\n+        return (E) new Object();\n+    }\n+    \n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#add(Object)}.\n+     */\n+    public void testGetWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    public void testGetWithAddTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj, 100).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)}.\n+     */\n+    public void testGetWithAddAll() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    public void testGetWithAddAllTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj, 100).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#add(Object)}.\n+     */\n+    public void testRemoveWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.remove());\n+    }\n+\n+    public void testRemoveWithAddTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj, 500).start();\n+        try {\n+            blockingBuffer.remove();\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)}.\n+     */\n+    public void testRemoveWithAddAll() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.remove());\n+    }\n+\n+    public void testRemoveWithAddAllTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj, 500).start();\n+        try {\n+            blockingBuffer.remove();\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#add(Object)} using multiple read threads. <p/> Two\n+     * read threads should block on an empty buffer until one object is added\n+     * then both threads should complete.\n+     */\n+    public void testBlockedGetWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will get and compare -- must wait for add\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+\n+        // notifyAll should allow both read threads to complete\n+        blockingBuffer.add(obj);\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * singleton is added then both threads should complete.\n+     */\n+    public void testBlockedGetWithAddAll() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will get and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+\n+        // notifyAll should allow both read threads to complete\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests interrupted {@link BlockingBuffer#get()}.\n+     */\n+    public void testInterruptedGet() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // spawn a read thread to wait on the empty buffer\n+        ArrayList<String> exceptionList = new ArrayList<String>();\n+        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList);\n+        thread.start();\n+\n+        // Interrupting the thread should cause it to throw BufferUnderflowException\n+        thread.interrupt();\n+\n+        // Chill, so thread can throw and add message to exceptionList\n+        delay();\n+        assertTrue(\"Thread interrupt should have led to underflow\", exceptionList\n+                .contains(\"BufferUnderFlow\"));\n+        if (thread.isAlive()) {\n+            fail(\"Read thread has hung.\");\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#add(Object)} using multiple read threads. <p/> Two\n+     * read threads should block on an empty buffer until one object is added\n+     * then one thread should complete. The remaining thread should complete\n+     * after the addition of a second object.\n+     */\n+    public void testBlockedRemoveWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will remove and compare -- must wait for add\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+        blockingBuffer.add(obj);\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should be one thread waiting.\n+        assertTrue(\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+        blockingBuffer.add(obj);\n+\n+        // allow notified thread to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * singleton collection is added then one thread should complete. The\n+     * remaining thread should complete after the addition of a second\n+     * singleton.\n+     */\n+    public void testBlockedRemoveWithAddAll1() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will remove and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should be one thread waiting.\n+        assertTrue(\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+\n+        // allow notified thread to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * collection with two distinct objects is added then both threads should\n+     * complete. Each thread should have read a different object.\n+     */\n+    public void testBlockedRemoveWithAddAll2() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj1 = makeElement();\n+        E obj2 = makeElement();\n+        Set<E> objs = Collections.synchronizedSet(new HashSet<E>());\n+        objs.add(obj1);\n+        objs.add(obj2);\n+\n+        // run methods will remove and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+        blockingBuffer.addAll(objs);\n+\n+        // allow notified threads to complete \n+        delay();\n+        assertEquals(\"Both objects were removed\", 0, objs.size());\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests interrupted remove.\n+     */\n+    public void testInterruptedRemove() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // spawn a read thread to wait on the empty buffer\n+        ArrayList<String> exceptionList = new ArrayList<String>();\n+        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList, \"remove\");\n+        thread.start();\n+\n+        // Interrupting the thread should cause it to throw BufferUnderflowException\n+        thread.interrupt();\n+\n+        // Chill, so thread can throw and add message to exceptionList\n+        delay();\n+        assertTrue(\"Thread interrupt should have led to underflow\", exceptionList\n+                .contains(\"BufferUnderFlow\"));\n+        if (thread.isAlive()) {\n+            fail(\"Read thread has hung.\");\n+        }\n+\n+    }\n+\n+    public void testTimeoutGet() {\n+        final BlockingBuffer<E> buffer = new BlockingBuffer<E>(new MyBuffer<E>());\n+        try {\n+            buffer.get(100);\n+            fail(\"Get should have timed out.\");\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    public void testTimeoutRemove() {\n+        final BlockingBuffer<E> buffer = new BlockingBuffer<E>(new MyBuffer<E>());\n+        try {\n+            buffer.remove(100);\n+            fail(\"Get should have timed out.\");\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    protected static class DelayedAdd<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        E obj;\n+\n+        long delay = 1000;\n+\n+        public DelayedAdd(Buffer<E> buffer, E obj, long delay) {\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.delay = delay;\n+        }\n+\n+        DelayedAdd(Buffer<E> buffer, E obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                // wait for other thread to block on get() or remove()\n+                Thread.sleep(delay);\n+            } catch (InterruptedException e) {\n+            }\n+            buffer.add(obj);\n+        }\n+    }\n+\n+    protected static class DelayedAddAll<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        E obj;\n+\n+        long delay = 100;\n+\n+        public DelayedAddAll(Buffer<E> buffer, E obj, long delay) {\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.delay = delay;\n+        }\n+\n+        DelayedAddAll(Buffer<E> buffer, E obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                // wait for other thread to block on get() or remove()\n+                Thread.sleep(delay);\n+            } catch (InterruptedException e) {\n+            }\n+            buffer.addAll(Collections.singleton(obj));\n+        }\n+    }\n+\n+    protected static class ReadThread<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        Object obj;\n+\n+        ArrayList<String> exceptionList = null;\n+\n+        String action = \"get\";\n+\n+        Set<E> objs;\n+\n+        ReadThread(Buffer<E> buffer, Object obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.exceptionList = exceptionList;\n+        }\n+\n+        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList, String action) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.exceptionList = exceptionList;\n+            this.action = action;\n+        }\n+\n+        ReadThread(Buffer<E> buffer, Set<E> objs, String action) {\n+            super();\n+            this.buffer = buffer;\n+            this.objs = objs;\n+            this.action = action;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (action == \"get\") {\n+                    assertSame(obj, buffer.get());\n+                } else {\n+                    if (null != obj) {\n+                        assertSame(obj, buffer.remove());\n+                    } else {\n+                        assertTrue(objs.remove(buffer.remove()));\n+                    }\n+                }\n+            } catch (BufferUnderflowException ex) {\n+                exceptionList.add(\"BufferUnderFlow\");\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    protected static class MyBuffer<E> extends LinkedList<E> implements Buffer<E> {\n+\n+        public E get() {\n+            if (isEmpty()) {\n+                throw new BufferUnderflowException();\n+            }\n+            return get(0);\n+        }\n+\n+        @Override\n+        public E remove() {\n+            if (isEmpty()) {\n+                throw new BufferUnderflowException();\n+            }\n+            return remove(0);\n+        }\n+    }\n+\n+    private void delay() {\n+        try {\n+            Thread.sleep( 200 );\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    //    public void testCreate() throws Exception {\n+    //        Buffer buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n+    //        writeExternalFormToDisk((java.io.Serializable) buffer,\n+    //        \"D:/dev/collections/data/test/BlockingBuffer.emptyCollection.version3.1.obj\");\n+    //        buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n+    //        buffer.add(\"A\");\n+    //        buffer.add(\"B\");\n+    //        buffer.add(\"C\");\n+    //        writeExternalFormToDisk((java.io.Serializable) buffer,\n+    //        \"D:/dev/collections/data/test/BlockingBuffer.fullCollection.version3.1.obj\");\n+    //    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.BoundedCollection;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+\n+import java.util.Iterator;\n+import java.util.Collections;\n+import java.util.Arrays;\n+\n+public class BoundedBufferTest<E> extends AbstractTestObject {\n+\n+    public BoundedBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMaxSize() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n+        BoundedCollection<?> bc = (BoundedCollection<?>) bounded;\n+        assertEquals(2, bc.maxSize());\n+        assertEquals(false, bc.isFull());\n+        bounded.add((E) \"A\");\n+        assertEquals(false, bc.isFull());\n+        bounded.add((E) \"B\");\n+        assertEquals(true, bc.isFull());\n+        bounded.remove();\n+        assertEquals(false, bc.isFull());\n+        try {\n+            BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddToFullBufferNoTimeout() {\n+        final Buffer<E> bounded = makeObject();\n+        bounded.add((E) \"Hello\");\n+        try {\n+            bounded.add((E) \"World\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToFullBufferNoTimeout() {\n+        final Buffer<E> bounded = makeObject();\n+        bounded.add((E) \"Hello\");\n+        try {\n+            bounded.addAll(Collections.singleton((E) \"World\"));\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToEmptyBufferExceedMaxSizeNoTimeout() {\n+        final Buffer<E> bounded = makeObject();\n+        try {\n+            bounded.addAll(Collections.nCopies(2, (E) \"test\"));\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddToFullBufferRemoveViaIterator() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1, 500);\n+        bounded.add((E) \"Hello\");\n+        new DelayedIteratorRemove(bounded, 200).start();\n+        bounded.add((E) \"World\");\n+        assertEquals(1, bounded.size());\n+        assertEquals(\"World\", bounded.get());\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToFullBufferRemoveViaIterator() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n+        bounded.add((E) \"Hello\");\n+        bounded.add((E) \"World\");\n+        new DelayedIteratorRemove(bounded, 200, 2).start();\n+        bounded.addAll(Arrays.asList((E[]) new String[] { \"Foo\", \"Bar\" }));\n+        assertEquals(2, bounded.size());\n+        assertEquals(\"Foo\", bounded.remove());\n+        assertEquals(\"Bar\", bounded.remove());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddToFullBufferWithTimeout() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1, 500);\n+        bounded.add((E) \"Hello\");\n+        new DelayedRemove(bounded, 200).start();\n+        bounded.add((E) \"World\");\n+        assertEquals(1, bounded.size());\n+        assertEquals(\"World\", bounded.get());\n+        try {\n+            bounded.add((E) \"!\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToFullBufferWithTimeout() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n+        bounded.add((E) \"Hello\");\n+        bounded.add((E) \"World\");\n+        new DelayedRemove(bounded, 200, 2).start();\n+\n+        bounded.addAll(Arrays.asList((E[]) new String[] { \"Foo\", \"Bar\" }));\n+        assertEquals(2, bounded.size());\n+        assertEquals(\"Foo\", bounded.get());\n+        try {\n+            bounded.add((E) \"!\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    private class DelayedIteratorRemove extends Thread {\n+\n+        private final Buffer<?> buffer;\n+\n+        private final long delay;\n+\n+        private final int nToRemove;\n+\n+        public DelayedIteratorRemove(Buffer<?> buffer, long delay, int nToRemove) {\n+            this.buffer = buffer;\n+            this.delay = delay;\n+            this.nToRemove = nToRemove;\n+        }\n+\n+        public DelayedIteratorRemove(Buffer<?> buffer, long delay) {\n+            this(buffer, delay, 1);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Thread.sleep(delay);\n+                Iterator<?> iter = buffer.iterator();\n+                for (int i = 0; i < nToRemove; ++i) {\n+                    iter.next();\n+                    iter.remove();\n+                }\n+\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private class DelayedRemove extends Thread {\n+\n+        private final Buffer<?> buffer;\n+\n+        private final long delay;\n+\n+        private final int nToRemove;\n+\n+        public DelayedRemove(Buffer<?> buffer, long delay, int nToRemove) {\n+            this.buffer = buffer;\n+            this.delay = delay;\n+            this.nToRemove = nToRemove;\n+        }\n+\n+        public DelayedRemove(Buffer<?> buffer, long delay) {\n+            this(buffer, delay, 1);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Thread.sleep(delay);\n+                for (int i = 0; i < nToRemove; ++i) {\n+                    buffer.remove();\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedFifoBuffer2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Runs tests against a full BoundedFifoBuffer, since many of the algorithms\n+ * differ depending on whether the fifo is full or not.\n+ *\n+ * @version $Id$\n+ */\n+public class BoundedFifoBuffer2Test<E> extends BoundedFifoBufferTest<E> {\n+\n+    public BoundedFifoBuffer2Test(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(BoundedFifoBuffer2Test.class);\n+    }\n+\n+    /**\n+     *  Returns a BoundedFifoBuffer that's filled to capacity.\n+     *  Any attempt to add to the returned buffer will result in a \n+     *  BufferOverflowException.\n+     *\n+     *  @return a full BoundedFifoBuffer\n+     */\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        return new BoundedFifoBuffer<E>(Arrays.asList(getFullElements()));\n+    }\n+\n+    /**\n+     *  Overridden to skip the add tests.  All of them would fail with a \n+     *  BufferOverflowException.\n+     *\n+     *  @return false\n+     */\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     *  Overridden because the add operations raise BufferOverflowException\n+     *  instead of UnsupportedOperationException.\n+     */\n+    @Override\n+    public void testUnsupportedAdd() {\n+    }\n+\n+    /**\n+     *  Tests to make sure the add operations raise BufferOverflowException.\n+     */\n+    public void testBufferOverflow() {\n+        resetFull();\n+        try {\n+            getCollection().add(getOtherElements()[0]);\n+            fail(\"add should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n+            fail(\"addAll should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests is full\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsFull() {\n+        resetFull();\n+        assertEquals(true, getCollection().isFull());\n+        getCollection().remove();\n+        assertEquals(false, getCollection().isFull());\n+        getCollection().add((E) \"jj\");\n+        assertEquals(true, getCollection().isFull());\n+    }\n+\n+    /**\n+     * Tests max size\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMaxSize() {\n+        resetFull();\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+        getCollection().remove();\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+        getCollection().add((E) \"jj\");\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedFifoBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Test cases for BoundedFifoBuffer.\n+ *\n+ * @version $Id$\n+ */\n+public class BoundedFifoBufferTest<E> extends AbstractCollectionTest<E> {\n+\n+    public BoundedFifoBufferTest(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(BoundedFifoBufferTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that\n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            E o1 = iterator1.next();\n+            E o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    @Override\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    @Override\n+    public List<E> makeConfirmedFullCollection() {\n+        List<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty BoundedFifoBuffer that won't overflow.\n+     *\n+     *  @return an empty BoundedFifoBuffer\n+     */\n+    @Override\n+    public BoundedFifoBuffer<E> makeObject() {\n+        return new BoundedFifoBuffer<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testBoundedFifoBufferRemove() {\n+        resetFull();\n+        int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            E o1 = getCollection().remove();\n+            E o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            getCollection().remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new BoundedFifoBuffer<E>(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new BoundedFifoBuffer<E>(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new BoundedFifoBuffer<E>(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    /**\n+     * Tests that the get(index) method correctly throws an exception.\n+     */\n+    public void testGetException() {\n+        resetFull();\n+        try {\n+            getCollection().get(-1);\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+            // expected\n+        }\n+        \n+        try {\n+            getCollection().get(getCollection().size());\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testGetIndex() {\n+        resetFull();\n+        \n+        BoundedFifoBuffer<E> buffer = getCollection();\n+        List<E> confirmed = getConfirmed();\n+        for (int i = 0; i < confirmed.size(); i++) {\n+            assertEquals(confirmed.get(i), buffer.get(i));\n+        }\n+\n+        // remove the first two elements and check again\n+        buffer.remove();\n+        buffer.remove();\n+        \n+        for (int i = 0; i < buffer.size(); i++) {\n+            assertEquals(confirmed.get(i + 2), buffer.get(i));\n+        }        \n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    // BZ 33071 -- gets start=end=1 before removal of interior element\n+    @SuppressWarnings(\"unchecked\")\n+    public void testShift() {\n+        BoundedFifoBuffer<E> fifo = new BoundedFifoBuffer<E>(3);\n+        fifo.add((E) \"a\");\n+        fifo.add((E) \"b\");\n+        fifo.add((E) \"c\");\n+        fifo.remove();\n+        fifo.add((E) \"e\");\n+        fifo.remove(\"c\");\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/BoundedFifoBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/BoundedFifoBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public BoundedFifoBuffer<E> getCollection() {\n+        return (BoundedFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/CircularFifoBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Test cases for CircularFifoBuffer.\n+ *\n+ * @version $Id$\n+ */\n+public class CircularFifoBufferTest<E> extends AbstractCollectionTest<E> {\n+\n+    public CircularFifoBufferTest(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(CircularFifoBufferTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that\n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty ArrayList.\n+     *\n+     * @return an empty ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     * Returns a full ArrayList.\n+     *\n+     * @return a full ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Returns an empty BoundedFifoBuffer that won't overflow.\n+     *\n+     * @return an empty BoundedFifoBuffer\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CircularFifoBuffer<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCircularFifoBufferCircular() {\n+        List<E> list = new ArrayList<E>();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        Buffer<E> buf = new CircularFifoBuffer<E>(list);\n+\n+        assertEquals(true, buf.contains(\"A\"));\n+        assertEquals(true, buf.contains(\"B\"));\n+        assertEquals(true, buf.contains(\"C\"));\n+\n+        buf.add((E) \"D\");\n+\n+        assertEquals(false, buf.contains(\"A\"));\n+        assertEquals(true, buf.contains(\"B\"));\n+        assertEquals(true, buf.contains(\"C\"));\n+        assertEquals(true, buf.contains(\"D\"));\n+\n+        assertEquals(\"B\", buf.get());\n+        assertEquals(\"B\", buf.remove());\n+        assertEquals(\"C\", buf.remove());\n+        assertEquals(\"D\", buf.remove());\n+    }\n+\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testCircularFifoBufferRemove() {\n+        resetFull();\n+        int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = getCollection().remove();\n+            Object o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            getCollection().remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new CircularFifoBuffer<E>(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new CircularFifoBuffer<E>(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new CircularFifoBuffer<E>(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError1() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[1, 2, 5]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError2() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+        fifo.add((E) \"6\");\n+\n+        assertEquals(5, fifo.size());\n+        assertEquals(\"[2, 3, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[2, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError3() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.add((E) \"6\");\n+        fifo.add((E) \"7\");\n+        assertEquals(\"[2, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError4() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");  // remove element in middle of array, after start\n+        assertEquals(\"[3, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError5() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"5\");  // remove element at last pos in array\n+        assertEquals(\"[3, 4, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError6() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"6\");  // remove element at position zero in array\n+        assertEquals(\"[3, 4, 5, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError7() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array\n+        assertEquals(\"[3, 4, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError8() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array, need to shift 8\n+        assertEquals(\"[4, 5, 6, 8]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError9() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"8\");  // remove element at position two in array\n+        assertEquals(\"[4, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRepeatedSerialization() throws Exception {\n+        // bug 31433\n+        CircularFifoBuffer<E> b = new CircularFifoBuffer<E>(2);\n+        b.add((E) \"a\");\n+        assertEquals(1, b.size());\n+        assertEquals(true, b.contains(\"a\"));\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b);\n+\n+        CircularFifoBuffer<E> b2 = (CircularFifoBuffer<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(1, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        b2.add((E) \"b\");\n+        assertEquals(2, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        assertEquals(true, b2.contains(\"b\"));\n+\n+        bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b2);\n+\n+        CircularFifoBuffer<E> b3 = (CircularFifoBuffer<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"a\"));\n+        assertEquals(true, b3.contains(\"b\"));\n+        b3.add((E) \"c\");\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"b\"));\n+        assertEquals(true, b3.contains(\"c\"));\n+    }\n+\n+    public void testGetIndex() {\n+        resetFull();\n+        \n+        CircularFifoBuffer<E> buffer = getCollection();\n+        List<E> confirmed = getConfirmed();\n+        for (int i = 0; i < confirmed.size(); i++) {\n+            assertEquals(confirmed.get(i), buffer.get(i));\n+        }\n+\n+        // remove the first two elements and check again\n+        buffer.remove();\n+        buffer.remove();\n+        \n+        for (int i = 0; i < buffer.size(); i++) {\n+            assertEquals(confirmed.get(i + 2), buffer.get(i));\n+        }        \n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/CircularFifoBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/CircularFifoBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CircularFifoBuffer<E> getCollection() {\n+        return (CircularFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/PredicatedBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollectionTest;\n+\n+/**\n+ * Extension of {@link PredicatedCollectionTest} for exercising the\n+ * {@link PredicatedBuffer} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedBufferTest<E> extends PredicatedCollectionTest<E> {\n+\n+    public PredicatedBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //---------------------------------------------------------------\n+\n+    protected Buffer<E> decorateCollection(Buffer<E> buffer, Predicate<E> predicate) {\n+        return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n+    }\n+\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return decorateCollection(new ArrayStack<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n+        list.addAll(java.util.Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //------------------------------------------------------------\n+\n+    public Buffer<E> makeTestBuffer() {\n+        return decorateCollection(new ArrayStack<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGet() {\n+        Buffer<E> buffer = makeTestBuffer();\n+        try {\n+            buffer.get();\n+            fail(\"Expecting BufferUnderflowException\");\n+        } catch (BufferUnderflowException ex) {\n+            // expected\n+        }\n+        buffer.add((E) \"one\");\n+        buffer.add((E) \"two\");\n+        buffer.add((E) \"three\");\n+        assertEquals(\"Buffer get\", \"three\", buffer.get());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        Buffer<E> buffer = makeTestBuffer();\n+        buffer.add((E) \"one\");\n+        assertEquals(\"Buffer get\", \"one\", buffer.remove());\n+        try {\n+            buffer.remove();\n+            fail(\"Expecting BufferUnderflowException\");\n+        } catch (BufferUnderflowException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/PriorityBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Random;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.ComparatorUtils;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * Tests the PriorityBuffer.\n+ *\n+ * @version $Id$ \n+ */\n+@SuppressWarnings(\"boxing\")\n+public class PriorityBufferTest<E> extends AbstractCollectionTest<E> {\n+\n+    public PriorityBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void verify() {\n+        super.verify();\n+        PriorityBuffer<E> heap = getCollection();\n+\n+        Comparator<? super E> c = heap.comparator;\n+        if (c == null) {\n+            c = ComparatorUtils.NATURAL_COMPARATOR;\n+        }\n+        if (!heap.ascendingOrder) {\n+            c = ComparatorUtils.reversedComparator(c);\n+        }\n+\n+        E[] tree = heap.elements;\n+        for (int i = 1; i <= heap.size; i++) {\n+            E parent = tree[i];\n+            if (i * 2 <= heap.size) {\n+                assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n+            }\n+            if (i * 2 + 1 < heap.size) {\n+                assertTrue(\"Parent is less than or equal to its right child\", c.compare(parent, tree[i * 2 + 1]) <= 0);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because BinaryBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Return a new, empty {@link Object} to used for testing.\n+     */\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return new PriorityBuffer<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) getFullNonNullStringElements();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherElements() {\n+        return (E[]) getOtherNonNullStringElements();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBufferEmpty() {\n+        resetEmpty();\n+        Buffer<E> buffer = getCollection();\n+\n+        assertEquals(0, buffer.size());\n+        assertEquals(true, buffer.isEmpty());\n+        try {\n+            buffer.get();\n+            fail();\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            buffer.remove();\n+            fail();\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasicOps() {\n+        PriorityBuffer<E> heap = new PriorityBuffer<E>();\n+        heap.add((E) \"a\");\n+        heap.add((E) \"c\");\n+        heap.add((E) \"e\");\n+        heap.add((E) \"b\");\n+        heap.add((E) \"d\");\n+        heap.add((E) \"n\");\n+        heap.add((E) \"m\");\n+        heap.add((E) \"l\");\n+        heap.add((E) \"k\");\n+        heap.add((E) \"j\");\n+        heap.add((E) \"i\");\n+        heap.add((E) \"h\");\n+        heap.add((E) \"g\");\n+        heap.add((E) \"f\");\n+\n+        assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+            assertEquals(\n+                \"get using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.get());\n+\n+            assertEquals(\n+                \"remove using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.remove());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are removed\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are removed\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasicComparatorOps() {\n+        PriorityBuffer<E> heap = new PriorityBuffer<E>(new ReverseComparator<E>((Comparator<E>) ComparableComparator.INSTANCE));\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called before any elements are added\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called before any elements are added\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        heap.add((E) \"a\");\n+        heap.add((E) \"c\");\n+        heap.add((E) \"e\");\n+        heap.add((E) \"b\");\n+        heap.add((E) \"d\");\n+        heap.add((E) \"n\");\n+        heap.add((E) \"m\");\n+        heap.add((E) \"l\");\n+        heap.add((E) \"k\");\n+        heap.add((E) \"j\");\n+        heap.add((E) \"i\");\n+        heap.add((E) \"h\");\n+        heap.add((E) \"g\");\n+        heap.add((E) \"f\");\n+\n+        assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+\n+            // note: since we're using a comparator that reverses items, the\n+            // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n+\n+            assertEquals(\n+                \"get using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.get());\n+\n+            assertEquals(\n+                \"remove using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.remove());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are removed\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are removed\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    /**\n+     * Illustrates bad internal heap state reported in Bugzilla PR #235818.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddRemove() {\n+        resetEmpty();\n+        PriorityBuffer heap = getCollection();\n+        heap.add(0);\n+        heap.add(2);\n+        heap.add(4);\n+        heap.add(3);\n+        heap.add(8);\n+        heap.add(10);\n+        heap.add(12);\n+        heap.add(3);\n+        getConfirmed().addAll(heap);\n+        // System.out.println(heap);\n+        heap.remove(10);\n+        getConfirmed().remove(10);\n+        // System.out.println(heap);\n+        verify();\n+    }\n+\n+    /**\n+     * Generate heaps staring with Integers from 0 - heapSize - 1.\n+     * Then perform random add / remove operations, checking\n+     * heap order after modifications. Alternates minHeaps, maxHeaps.\n+     *\n+     * Based on code provided by Steve Phelps in PR #25818\n+     *\n+     */\n+    public void testRandom() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        int operations = 20;\n+        Random randGenerator = new Random();\n+        PriorityBuffer<Integer> h = null;\n+        for (int i = 0; i < iterations; i++) {\n+            if (i < iterations / 2) {\n+                h = new PriorityBuffer<Integer>(true);\n+            } else {\n+                h = new PriorityBuffer<Integer>(false);\n+            }\n+            for (int r = 0; r < heapSize; r++) {\n+                h.add(randGenerator.nextInt(heapSize));\n+            }\n+            for (int r = 0; r < operations; r++) {\n+                h.remove(new Integer(r));\n+                h.add(randGenerator.nextInt(heapSize));\n+            }\n+            checkOrder(h);\n+        }\n+    }\n+\n+    /**\n+     * Pops all elements from the heap and verifies that the elements come off\n+     * in the correct order.  NOTE: this method empties the heap.\n+     */\n+    protected void checkOrder(PriorityBuffer<?> h) {\n+        Integer lastNum = null;\n+        Integer num = null;\n+        while (!h.isEmpty()) {\n+            num = (Integer) h.remove();\n+            if (h.ascendingOrder) {\n+                assertTrue(lastNum == null || num.intValue() >= lastNum.intValue());\n+            } else { // max heap\n+                assertTrue(lastNum == null || num.intValue() <= lastNum.intValue());\n+            }\n+            lastNum = num;\n+            num = null;\n+        }\n+    }\n+\n+    /**\n+     * Returns a string showing the contents of the heap formatted as a tree.\n+     * Makes no attempt at padding levels or handling wrapping.\n+     */\n+    protected String showTree(PriorityBuffer<?> h) {\n+        int count = 1;\n+        StringBuilder buffer = new StringBuilder();\n+        for (int offset = 1; count < h.size() + 1; offset *= 2) {\n+            for (int i = offset; i < offset * 2; i++) {\n+                if (i < h.elements.length && h.elements[i] != null)\n+                    buffer.append(h.elements[i] + \" \");\n+                count++;\n+            }\n+            buffer.append('\\n');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Generates 500 randomly initialized heaps of size 100\n+     * and tests that after serializing and restoring them to a byte array\n+     * that the following conditions hold:\n+     *\n+     *  - the size of the restored heap is the same\n+     *      as the size of the orignal heap\n+     *\n+     *  - all elements in the original heap are present in the restored heap\n+     *\n+     *  - the heap order of the restored heap is intact as\n+     *      verified by checkOrder()\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        PriorityBuffer h;\n+        Random randGenerator = new Random();\n+        for (int i = 0; i < iterations; i++) {\n+            if (i < iterations / 2) {\n+                h = new PriorityBuffer<E>(true);\n+            } else {\n+                h = new PriorityBuffer<E>(false);\n+            }\n+            for (int r = 0; r < heapSize; r++) {\n+                h.add(new Integer(randGenerator.nextInt(heapSize)));\n+            }\n+            assertTrue(h.size() == heapSize);\n+            PriorityBuffer<?> h1 = serializeAndRestore(h);\n+            assertTrue(h1.size() == heapSize);\n+            Iterator<?> hit = h.iterator();\n+            while (hit.hasNext()) {\n+                Integer n = (Integer) hit.next();\n+                assertTrue(h1.contains(n));\n+            }\n+            checkOrder(h1);\n+        }\n+    }\n+\n+    public PriorityBuffer<?> serializeAndRestore(PriorityBuffer<E> h) {\n+        PriorityBuffer<?> h1 = null;\n+        try {\n+            byte[] objekt = writeExternalFormToBytes(h);\n+            h1 = (PriorityBuffer<?>) readExternalFormFromBytes(objekt);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            fail(e.toString());\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+            fail(e.toString());\n+        }\n+        return h1;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/PriorityBuffer.emptyCollection.version3.2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/PriorityBuffer.fullCollection.version3.2.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public PriorityBuffer<E> getCollection() {\n+        return (PriorityBuffer<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/SynchronizedBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link SynchronizedBuffer} implementation.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class SynchronizedBufferTest<E> extends AbstractCollectionTest<E> {\n+\n+    public SynchronizedBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return SynchronizedBuffer.synchronizedBuffer(new UnboundedFifoBuffer<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n+        buffer.addAll(Arrays.asList(getFullElements()));\n+        return SynchronizedBuffer.synchronizedBuffer(buffer);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TransformedBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link TestCase} for exercising the {@link TransformedBuffer}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedBufferTest extends TestCase {\n+    \n+    public TransformedBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testTransformedBuffer() {\n+        Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, buffer.size());\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            buffer.add(els[i]);\n+            assertEquals(i + 1, buffer.size());\n+            assertEquals(true, buffer.contains(new Integer((String) els[i])));\n+            assertEquals(false, buffer.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, buffer.remove(els[0]));\n+        assertEquals(true, buffer.remove(new Integer((String) els[0])));\n+        \n+    }\n+\n+    public void testTransformedBuffer_decorateTransform() {\n+        Buffer originalBuffer = new ArrayStack();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalBuffer.add(els[i]);\n+        }\n+        Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, buffer.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, buffer.contains(new Integer((String) els[i])));\n+            assertEquals(false, buffer.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, buffer.remove(els[0]));\n+        assertEquals(true, buffer.remove(new Integer((String) els[0])));\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/UnboundedFifoBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Test cases for UnboundedFifoBuffer.\n+ *\n+ * @version $Id$\n+ */\n+public class UnboundedFifoBufferTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnboundedFifoBufferTest(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnboundedFifoBufferTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that the ArrayList has the same elements in the same \n+     *  sequence as the UnboundedFifoBuffer.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty UnboundedFifoBuffer with a small capacity.\n+     *\n+     *  @return an empty UnboundedFifoBuffer\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new UnboundedFifoBuffer<E>(5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests that UnboundedFifoBuffer removes elements in the right order.\n+     */\n+    public void testUnboundedFifoBufferRemove() {\n+        resetFull();\n+        int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            E o1 = getCollection().remove();\n+            E o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new UnboundedFifoBuffer<E>(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new UnboundedFifoBuffer<E>(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateAdd() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(2);\n+        assertEquals(3, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"A\");\n+        assertEquals(3, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(1, test.tail);\n+        test.add((E) \"B\");\n+        assertEquals(3, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        test.add((E) \"C\");  // forces buffer increase\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(4, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateAddWithWrap() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"A\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(1, test.tail);\n+        test.add((E) \"B\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        test.add((E) \"C\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        test.remove(\"A\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        test.remove(\"B\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(3, test.tail);\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateRemove1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.remove(\"A\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(4, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateRemove2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.remove(\"B\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemove1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        it.next();\n+        it.remove();\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(4, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemove2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        \n+        Iterator<E> it = test.iterator();\n+        it.next();\n+        it.next();\n+        it.remove();\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithTailAtEnd1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"B\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithTailAtEnd2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"B\", it.next());\n+        assertEquals(\"C\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithTailAtEnd3() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"B\", it.next());\n+        assertEquals(\"C\", it.next());\n+        assertEquals(\"D\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithWrap1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.remove(\"B\");\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"C\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(3, test.head);\n+        assertEquals(1, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithWrap2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.remove(\"B\");\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"C\", it.next());\n+        assertEquals(\"D\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithWrap3() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.remove(\"B\");\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"C\", it.next());\n+        assertEquals(\"D\", it.next());\n+        assertEquals(\"E\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCollections220() throws Exception {\n+         UnboundedFifoBuffer<String> buffer = new UnboundedFifoBuffer<String>();\n+         \n+         buffer = (UnboundedFifoBuffer<String>) serializeDeserialize(buffer);\n+\n+         // test size() gets incremented\n+         buffer.add(\"Foo\");\n+         assertEquals(1, buffer.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnboundedFifoBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnboundedFifoBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnboundedFifoBuffer<E> getCollection() {\n+        return (UnboundedFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/UnmodifiableBufferTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableBuffer} implementation.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class UnmodifiableBufferTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableBufferTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableBuffer.unmodifiableBuffer(new UnboundedFifoBuffer<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n+        buffer.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    public void testBufferRemove() {\n+        resetEmpty();\n+        try {\n+            getCollection().remove();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Buffer<E> getCollection() {\n+        return (Buffer<E>) super.getCollection();\n+    }\n+}", "timestamp": 1345227599, "metainfo": ""}