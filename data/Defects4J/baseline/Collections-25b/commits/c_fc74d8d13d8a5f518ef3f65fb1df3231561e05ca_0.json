{"sha": "fc74d8d13d8a5f518ef3f65fb1df3231561e05ca", "log": "Refactor bidimap to interface based subpackage   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.iterators.ResettableIterator;\n+import org.apache.commons.collections.pairs.AbstractMapEntryDecorator;\n+\n+/**\n+ * Abstract <code>BidiMap</code> implemented using two maps.\n+ * <p>\n+ * An implementation can be written simply by implementing the\n+ * <code>createMap</code> method.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Id: AbstractDualBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractDualBidiMap implements BidiMap {\n+\n+    /**\n+     * Delegate map array.  The first map contains standard entries, and the \n+     * second contains inverses.\n+     */\n+    protected transient final Map[] maps = new Map[2];\n+    /**\n+     * Inverse view of this map.\n+     */\n+    protected transient BidiMap inverseBidiMap = null;\n+    /**\n+     * View of the keys.\n+     */\n+    protected transient Set keySet = null;\n+    /**\n+     * View of the values.\n+     */\n+    protected transient Collection values = null;\n+    /**\n+     * View of the entries.\n+     */\n+    protected transient Set entrySet = null;\n+\n+    /**\n+     * Creates an empty map, initialised by <code>createMap</code>.\n+     * <p>\n+     * The map array must be populated by the subclass.\n+     */\n+    protected AbstractDualBidiMap() {\n+        super();\n+        maps[0] = createMap();\n+        maps[1] = createMap();\n+    }\n+\n+    /** \n+     * Constructs a map that decorates the specified maps,\n+     * used by the subclass <code>createBidiMap</code> implementation.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected AbstractDualBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+        super();\n+        maps[0] = normalMap;\n+        maps[1] = reverseMap;\n+        this.inverseBidiMap = inverseBidiMap;\n+    }\n+\n+    /**\n+     * Creates a new instance of the map used by the subclass to store data.\n+     * <p>\n+     * Do not change any instance variables from this method.\n+     * \n+     * @return the map to be used for internal storage\n+     */\n+    protected abstract Map createMap();\n+\n+    /**\n+     * Creates a new instance of the subclass.\n+     * \n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseMap  this map, which is the inverse in the new map\n+     * @return the inverse map\n+     */\n+    protected abstract BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseMap);\n+\n+    // Map delegation\n+    //-----------------------------------------------------------------------\n+    public Object get(Object key) {\n+        return maps[0].get(key);\n+    }\n+\n+    public int size() {\n+        return maps[0].size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return maps[0].isEmpty();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return maps[0].containsKey(key);\n+    }\n+\n+    public boolean equals(Object obj) {\n+        return maps[0].equals(obj);\n+    }\n+\n+    public int hashCode() {\n+        return maps[0].hashCode();\n+    }\n+\n+    public String toString() {\n+        return maps[0].toString();\n+    }\n+\n+    // BidiMap changes\n+    //-----------------------------------------------------------------------\n+    public Object put(Object key, Object value) {\n+        if (maps[0].containsKey(key)) {\n+            maps[1].remove(maps[0].get(key));\n+        }\n+        if (maps[1].containsKey(value)) {\n+            maps[0].remove(maps[1].get(value));\n+        }\n+        final Object obj = maps[0].put(key, value);\n+        maps[1].put(value, key);\n+        return obj;\n+    }\n+    \n+    public void putAll(Map map) {\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Object value = null;\n+        if (maps[0].containsKey(key)) {\n+            value = maps[0].remove(key);\n+            maps[1].remove(value);\n+        }\n+        return value;\n+    }\n+\n+    public void clear() {\n+        maps[0].clear();\n+        maps[1].clear();\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return maps[1].containsKey(value);\n+    }\n+\n+    // BidiMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * The iterator implements <code>ResetableMapIterator</code>.\n+     * This implementation relies on the entrySet iterator.\n+     * <p>\n+     * The setValue() methods only allow a new value to be set.\n+     * If the value being set is already in the map, an IllegalArgumentException\n+     * is thrown (as setValue cannot change the size of the map).\n+     * \n+     * @return a map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        return new BidiMapIterator(this);\n+    }\n+    \n+    public Object getKey(Object value) {\n+        return maps[1].get(value);\n+    }\n+\n+    public Object removeValue(Object value) {\n+        Object key = null;\n+        if (maps[1].containsKey(value)) {\n+            key = maps[1].remove(value);\n+            maps[0].remove(key);\n+        }\n+        return key;\n+    }\n+\n+    public BidiMap inverseBidiMap() {\n+        if (inverseBidiMap == null) {\n+            inverseBidiMap = createBidiMap(maps[1], maps[0], this);\n+        }\n+        return inverseBidiMap;\n+    }\n+    \n+    // Map views\n+    //-----------------------------------------------------------------------\n+    public Set keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet(this);\n+        }\n+        return keySet;\n+    }\n+\n+    public Collection values() {\n+        if (values == null) {\n+            values = new Values(this);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Gets an entrySet view of the map.\n+     * Changes made on the set are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     * <p>\n+     * The Map Entry setValue() method only allow a new value to be set.\n+     * If the value being set is already in the map, an IllegalArgumentException\n+     * is thrown (as setValue cannot change the size of the map).\n+     * \n+     * @return the entrySet view\n+     */\n+    public Set entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet(this);\n+        }\n+        return entrySet;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class View.\n+     */\n+    protected static abstract class View extends AbstractCollectionDecorator {\n+        \n+        protected final AbstractDualBidiMap map;\n+        \n+        protected View(Collection coll, AbstractDualBidiMap map) {\n+            super(coll);\n+            this.map = map;\n+        }\n+\n+        public boolean removeAll(Collection coll) {\n+            if (map.isEmpty() || coll.isEmpty()) {\n+                return false;\n+            }\n+            boolean modified = false;\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next())) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        public boolean retainAll(Collection coll) {\n+            if (map.isEmpty()) {\n+                return false;\n+            }\n+            if (coll.isEmpty()) {\n+                map.clear();\n+                return true;\n+            }\n+            boolean modified = false;\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next()) == false) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+        \n+        public void clear() {\n+            map.clear();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class KeySet.\n+     */\n+    protected static class KeySet extends View implements Set {\n+        \n+        protected KeySet(AbstractDualBidiMap map) {\n+            super(map.maps[0].keySet(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new KeySetIterator(super.iterator(), map);\n+        }\n+        \n+        public boolean contains(Object key) {\n+            return map.maps[0].containsKey(key);\n+        }\n+\n+        public boolean remove(Object key) {\n+            if (map.maps[0].containsKey(key)) {\n+                Object value = map.maps[0].remove(key);\n+                map.maps[1].remove(value);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Inner class KeySetIterator.\n+     */\n+    protected static class KeySetIterator extends AbstractIteratorDecorator {\n+        \n+        private final AbstractDualBidiMap map;\n+        private Object lastKey = null;\n+        private boolean canRemove = false;\n+        \n+        protected KeySetIterator(Iterator iterator, AbstractDualBidiMap map) {\n+            super(iterator);\n+            this.map = map;\n+        }\n+        \n+        public Object next() {\n+            lastKey = super.next();\n+            canRemove = true;\n+            return lastKey;\n+        }\n+        \n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            Object value = map.maps[0].get(lastKey);\n+            super.remove();\n+            map.maps[1].remove(value);\n+            lastKey = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Values.\n+     */\n+    protected static class Values extends View implements Set {\n+        \n+        protected Values(AbstractDualBidiMap map) {\n+            super(map.maps[0].values(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new ValuesIterator(super.iterator(), map);\n+        }\n+        \n+        public boolean contains(Object value) {\n+            return map.maps[1].containsKey(value);\n+        }\n+\n+        public boolean remove(Object value) {\n+            if (map.maps[1].containsKey(value)) {\n+                Object key = map.maps[1].remove(value);\n+                map.maps[0].remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Inner class ValuesIterator.\n+     */\n+    protected static class ValuesIterator extends AbstractIteratorDecorator {\n+        \n+        private final AbstractDualBidiMap map;\n+        private Object lastValue = null;\n+        private boolean canRemove = false;\n+        \n+        protected ValuesIterator(Iterator iterator, AbstractDualBidiMap map) {\n+            super(iterator);\n+            this.map = map;\n+        }\n+        \n+        public Object next() {\n+            lastValue = super.next();\n+            canRemove = true;\n+            return lastValue;\n+        }\n+        \n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            super.remove(); // removes from maps[0]\n+            map.maps[1].remove(lastValue);\n+            lastValue = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class EntrySet.\n+     */\n+    protected static class EntrySet extends View implements Set {\n+        \n+        protected EntrySet(AbstractDualBidiMap map) {\n+            super(map.maps[0].entrySet(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntrySetIterator(super.iterator(), map);\n+        }\n+        \n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            if (map.containsKey(entry.getKey())) {\n+                Object value = map.maps[0].remove(entry.getKey());\n+                map.maps[1].remove(value);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Inner class EntrySetIterator.\n+     */\n+    protected static class EntrySetIterator extends AbstractIteratorDecorator {\n+        \n+        private final AbstractDualBidiMap map;\n+        private Map.Entry last = null;\n+        private boolean canRemove = false;\n+        \n+        protected EntrySetIterator(Iterator iterator, AbstractDualBidiMap map) {\n+            super(iterator);\n+            this.map = map;\n+        }\n+        \n+        public Object next() {\n+            last = new MapEntry((Map.Entry) super.next(), map);\n+            canRemove = true;\n+            return last;\n+        }\n+        \n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            Object value = last.getValue();\n+            super.remove();\n+            map.maps[1].remove(value);\n+            last = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class MapEntry.\n+     */\n+    protected static class MapEntry extends AbstractMapEntryDecorator {\n+        \n+        protected final AbstractDualBidiMap map;\n+        \n+        protected MapEntry(Map.Entry entry, AbstractDualBidiMap map) {\n+            super(entry);\n+            this.map = map;\n+        }\n+        \n+        public Object setValue(Object value) {\n+            Object key = MapEntry.this.getKey();\n+            if (map.maps[1].containsKey(value) &&\n+                map.maps[1].get(value) != key) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            map.put(key, value);\n+            final Object oldValue = super.setValue(value);\n+            return oldValue;\n+        }\n+    }\n+    \n+    /**\n+     * Inner class MapIterator.\n+     */\n+    protected static class BidiMapIterator implements MapIterator, ResettableIterator {\n+        \n+        protected final AbstractDualBidiMap map;\n+        protected Iterator iterator;\n+        private Map.Entry last = null;\n+        private boolean canRemove = false;\n+        \n+        protected BidiMapIterator(AbstractDualBidiMap map) {\n+            super();\n+            this.map = map;\n+            this.iterator = map.maps[0].entrySet().iterator();\n+        }\n+        \n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+        \n+        public Object next() {\n+            last = (Map.Entry) iterator.next();\n+            canRemove = true;\n+            return last.getKey();\n+        }\n+        \n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            Object value = last.getValue();\n+            iterator.remove();\n+            map.maps[1].remove(value);\n+            last = null;\n+            canRemove = false;\n+        }\n+        \n+        public Object getKey() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last.getKey();\n+        }\n+\n+        public Object getValue() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return last.getValue();\n+        }\n+        \n+        public Object setValue(Object value) {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            if (map.maps[1].containsKey(value) &&\n+                map.maps[1].get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            return map.put(last.getKey(), value);\n+        }\n+        \n+        public void reset() {\n+            iterator = map.maps[0].entrySet().iterator();\n+            last = null;\n+            canRemove = false;\n+        }\n+        \n+        public String toString() {\n+            if (last == null) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            } else {\n+                return \"MapIterator[]\";\n+            }\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/BidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/Attic/BidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.iterators.MapIterator;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values.\n+ * <p>\n+ * This extended <code>Map</code> represents a mapping where a key may\n+ * lookup a value and a value may lookup a key with equal ease.\n+ * Th interface extends <code>Map</code> and so may be used anywhere a map\n+ * is required. The interface provides an inverse map view, enabling\n+ * full access to both directions of the <code>BidiMap</code>.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface BidiMap extends Map {\n+    \n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * <p>\n+     * A map iterator is an efficient way of iterating over maps.\n+     * It does not require that the map is stored using Map Entry objects\n+     * which can increase performance.\n+     * <pre>\n+     * BidiMap map = new DualHashBidiMap();\n+     * MapIterator it = map.mapIterator();\n+     * while (it.hasNext()) {\n+     *   Object key = it.next();\n+     *   Object value = it.getValue();\n+     *   it.setValue(\"newValue\");\n+     * }\n+     * </pre>\n+     * \n+     * @return a map iterator\n+     */\n+    MapIterator mapIterator();\n+    \n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new DualHashBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     * \n+     *  BidiMap map2 = new DualHashBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     *\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the previous value mapped to this key\n+     * \n+     * @throws UnsupportedOperationException if the <code>put</code> method is not supported\n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specifed value is inappropriate\n+     * @throws IllegalArgumentException (optional) if the map limits the values\n+     *  in some way and the value was invalid\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     */\n+    Object put(Object key, Object value);\n+    \n+    /**\n+     * Gets the key that is currently mapped to the specified value.\n+     * <p>\n+     * If the value is not contained in the map, <code>null</code> is returned.\n+     * <p>\n+     * Implementations should seek to make this method perform equally as well\n+     * as <code>get(Object)</code>.\n+     *\n+     * @param value  the value to find the key for\n+     * @return the mapped key, or <code>null</code> if not found\n+     * \n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specifed value is inappropriate\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     */\n+    Object getKey(Object value);\n+    \n+    /**\n+     * Removes the key-value pair that is currently mapped to the specified\n+     * value (optional operation).\n+     * <p>\n+     * If the value is not contained in the map, <code>null</code> is returned.\n+     * <p>\n+     * Implementations should seek to make this method perform equally as well\n+     * as <code>remove(Object)</code>.\n+     *\n+     * @param value  the value to find the key-value pair for\n+     * @return the key that was removed, <code>null</code> if nothing removed\n+     * \n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specifed value is inappropriate\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *  by the implementation\n+     */\n+    Object removeValue(Object value);\n+    \n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed as a <code>Map</code>.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    BidiMap inverseBidiMap();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Implementation of <code>BidiMap</code> that uses two <code>HashMap</code> instances.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Id: DualHashBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class DualHashBidiMap extends AbstractDualBidiMap implements Serializable {\n+\n+    /** Ensure serialization compatability */\n+    private static final long serialVersionUID = 721969328361808L;\n+\n+    /**\n+     * Creates an empty <code>HashBidiMap</code>\n+     */\n+    public DualHashBidiMap() {\n+        super();\n+    }\n+\n+    /** \n+     * Constructs a <code>HashBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.  \n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualHashBidiMap(Map map) {\n+        super();\n+        putAll(map);\n+    }\n+    \n+    /** \n+     * Constructs a <code>HashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualHashBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    /**\n+     * Creates a new instance of the map used by the subclass to store data.\n+     * \n+     * @return the map to be used for internal storage\n+     */\n+    protected Map createMap() {\n+        return new HashMap();\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     * \n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    protected BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+        return new DualHashBidiMap(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(maps[0]);\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        Map map = (Map) in.readObject();\n+        putAll(map);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.iterators.ListIteratorWrapper;\n+import org.apache.commons.collections.iterators.OrderedMapIterator;\n+import org.apache.commons.collections.iterators.ResettableIterator;\n+import org.apache.commons.collections.map.AbstractSortedMapDecorator;\n+import org.apache.commons.collections.map.OrderedMap;\n+\n+/**\n+ * Implementation of <code>BidiMap</code> that uses two <code>TreeMap</code> instances.\n+ * <p>\n+ * The setValue() method on iterators will succeed only if the new value being set is\n+ * not already in the bidimap.\n+ * <p>\n+ * When considering whether to use this class, the {@link TreeBidiMap} class should\n+ * also be considered. It implements the interface using a dedicated design, and does\n+ * not store each object twice, which can save on memory use.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Id: DualTreeBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class DualTreeBidiMap extends AbstractDualBidiMap implements SortedBidiMap, Serializable {\n+\n+    /** Ensure serialization compatability */\n+    private static final long serialVersionUID = 721969328361809L;\n+    /** The comparator to use */\n+    protected final Comparator comparator;\n+    \n+    /**\n+     * Creates an empty <code>DualTreeBidiMap</code>\n+     */\n+    public DualTreeBidiMap() {\n+        super();\n+        this.comparator = null;\n+    }\n+\n+    /** \n+     * Constructs a <code>DualTreeBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.  \n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualTreeBidiMap(Map map) {\n+        super();\n+        putAll(map);\n+        this.comparator = null;\n+    }\n+\n+    /** \n+     * Constructs a <code>DualTreeBidiMap</code> using the specified Comparator.\n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualTreeBidiMap(Comparator comparator) {\n+        super();\n+        this.comparator = comparator;\n+    }\n+\n+    /** \n+     * Constructs a <code>HashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualTreeBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+        this.comparator = ((SortedMap) normalMap).comparator();\n+    }\n+    \n+    /**\n+     * Creates a new instance of the map used by the subclass to store data.\n+     * \n+     * @return the map to be used for internal storage\n+     */\n+    protected Map createMap() {\n+        return new TreeMap(comparator);\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     * \n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    protected BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseMap) {\n+        return new DualTreeBidiMap(normalMap, reverseMap, inverseMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator comparator() {\n+        return ((SortedMap) maps[0]).comparator();\n+    }\n+\n+    public Object firstKey() {\n+        return ((SortedMap) maps[0]).firstKey();\n+    }\n+\n+    public Object lastKey() {\n+        return ((SortedMap) maps[0]).lastKey();\n+    }\n+\n+    public Object nextKey(Object key) {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        if (maps[0] instanceof OrderedMap) {\n+            return ((OrderedMap) maps[0]).nextKey(key);\n+        }\n+        SortedMap sm = (SortedMap) maps[0];\n+        Iterator it = sm.tailMap(key).keySet().iterator();\n+        it.next();\n+        if (it.hasNext()) {\n+            return it.next();\n+        }\n+        return null;\n+    }\n+\n+    public Object previousKey(Object key) {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        if (maps[0] instanceof OrderedMap) {\n+            return ((OrderedMap) maps[0]).previousKey(key);\n+        }\n+        SortedMap sm = (SortedMap) maps[0];\n+        SortedMap hm = sm.headMap(key);\n+        if (hm.isEmpty()) {\n+            return null;\n+        }\n+        return hm.lastKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an ordered map iterator.\n+     * <p>\n+     * This implementation copies the elements to an ArrayList in order to\n+     * provide the forward/backward behaviour.\n+     */\n+    public OrderedMapIterator orderedMapIterator() {\n+        return new BidiOrderedMapIterator(this);\n+    }\n+\n+    public SortedBidiMap inverseSortedBidiMap() {\n+        return (SortedBidiMap) inverseBidiMap();\n+    }\n+\n+    public OrderedBidiMap inverseOrderedBidiMap() {\n+        return (OrderedBidiMap) inverseBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedMap headMap(Object toKey) {\n+        SortedMap sub = ((SortedMap) maps[0]).headMap(toKey);\n+        return new ViewMap(this, sub);\n+    }\n+\n+    public SortedMap tailMap(Object fromKey) {\n+        SortedMap sub = ((SortedMap) maps[0]).tailMap(fromKey);\n+        return new ViewMap(this, sub);\n+    }\n+\n+    public SortedMap subMap(Object fromKey, Object toKey) {\n+        SortedMap sub = ((SortedMap) maps[0]).subMap(fromKey, toKey);\n+        return new ViewMap(this, sub);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    protected static class ViewMap extends AbstractSortedMapDecorator {\n+        final DualTreeBidiMap bidi;\n+        \n+        protected ViewMap(DualTreeBidiMap bidi, SortedMap sm) {\n+            // the implementation is not great here...\n+            // use the maps[0] as the filtered map, but maps[1] as the full map\n+            // this forces containsValue and clear to be overridden\n+            super((SortedMap) bidi.createBidiMap(sm, bidi.maps[1], bidi.inverseBidiMap));\n+            this.bidi = (DualTreeBidiMap) map;\n+        }\n+        \n+        public boolean containsValue(Object value) {\n+            // override as default implementation jumps to [1]\n+            return bidi.maps[0].containsValue(value);\n+        }\n+        \n+        public void clear() {\n+            // override as default implementation jumps to [1]\n+            for (Iterator it = keySet().iterator(); it.hasNext();) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+        \n+        public SortedMap headMap(Object toKey) {\n+            return new ViewMap(bidi, super.headMap(toKey));\n+        }\n+\n+        public SortedMap tailMap(Object fromKey) {\n+            return new ViewMap(bidi, super.tailMap(fromKey));\n+        }\n+\n+        public SortedMap subMap(Object fromKey, Object toKey) {\n+            return new ViewMap(bidi, super.subMap(fromKey, toKey));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class MapIterator.\n+     */\n+    protected static class BidiOrderedMapIterator implements OrderedMapIterator, ResettableIterator {\n+        \n+        protected final AbstractDualBidiMap map;\n+        protected ListIterator iterator;\n+        private Map.Entry last = null;\n+        \n+        protected BidiOrderedMapIterator(AbstractDualBidiMap map) {\n+            super();\n+            this.map = map;\n+            iterator = new ListIteratorWrapper(map.entrySet().iterator());\n+        }\n+        \n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+        \n+        public Object next() {\n+            last = (Map.Entry) iterator.next();\n+            return last.getKey();\n+        }\n+        \n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+        \n+        public Object previous() {\n+            last = (Map.Entry) iterator.previous();\n+            return last.getKey();\n+        }\n+        \n+        public void remove() {\n+            iterator.remove();\n+            map.remove(last.getKey());\n+        }\n+        \n+        public Object getKey() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last.getKey();\n+        }\n+\n+        public Object getValue() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return last.getValue();\n+        }\n+        \n+        public Object setValue(Object value) {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            if (map.maps[1].containsKey(value) &&\n+                map.maps[1].get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            return map.put(last.getKey(), value);\n+        }\n+        \n+        public void reset() {\n+            iterator = new ListIteratorWrapper(map.entrySet().iterator());\n+            last = null;\n+        }\n+        \n+        public String toString() {\n+            if (last == null) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            } else {\n+                return \"MapIterator[]\";\n+            }\n+        }\n+    }\n+    \n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(maps[0]);\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        Map map = (Map) in.readObject();\n+        putAll(map);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/OrderedBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/Attic/OrderedBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import org.apache.commons.collections.map.OrderedMap;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values\n+ * and retains and provides access to an ordering.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface OrderedBidiMap extends BidiMap, OrderedMap {\n+    \n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * Implementations must return an <code>OrderedBidiMap</code> instance,\n+     * usually by forwarding to <code>inverseOrderedBidiMap()</code>.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public BidiMap inverseBidiMap();\n+    \n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public OrderedBidiMap inverseOrderedBidiMap();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/SortedBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/Attic/SortedBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.SortedMap;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values\n+ * and retains both keys and values in sorted order.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ *  \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface SortedBidiMap extends OrderedBidiMap, SortedMap {\n+    \n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * Implementations must return a <code>SortedBidiMap</code> instance,\n+     * usually by forwarding to <code>inverseSortedBidiMap()</code>.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public BidiMap inverseBidiMap();\n+    \n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed as a <code>SortedMap</code>.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * The inverse map returned by <code>inverseBidiMap()</code> should be the\n+     * same object as returned by this method.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public SortedBidiMap inverseSortedBidiMap();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.iterators.OrderedIterator;\n+import org.apache.commons.collections.iterators.OrderedMapIterator;\n+import org.apache.commons.collections.pairs.UnmodifiableMapEntry;\n+\n+/**\n+ * Red-Black tree-based implementation of BidiMap.\n+ * <p>\n+ * This class guarantees that the map will be in both ascending key order\n+ * and ascending value order, sorted according to the natural order for\n+ * the key's and value's classes.\n+ * <p>\n+ * This Map is intended for applications that need to be able to look\n+ * up a key-value pairing by either key or value, and need to do so\n+ * with equal efficiency.\n+ * <p>\n+ * While that goal could be accomplished by taking a pair of TreeMaps\n+ * and redirecting requests to the appropriate TreeMap (e.g.,\n+ * containsKey would be directed to the TreeMap that maps values to\n+ * keys, containsValue would be directed to the TreeMap that maps keys\n+ * to values), there are problems with that implementation.\n+ * If the data contained in the TreeMaps is large, the cost of redundant\n+ * storage becomes significant. The {@link DualTreeBidiMap} and\n+ * {@link DualHashBidiMap} implementations use this approach.\n+ * <p>\n+ * This solution keeps minimizes the data storage by holding data only once.\n+ * The red-black algorithm is based on java util TreeMap, but has been modified\n+ * to simultaneously map a tree node by key and by value. This doubles the\n+ * cost of put operations (but so does using two TreeMaps), and nearly doubles\n+ * the cost of remove operations (there is a savings in that the lookup of the\n+ * node to be removed only has to be performed once). And since only one node\n+ * contains the key and value, storage is significantly less than that\n+ * required by two TreeMaps.\n+ * <p>\n+ * The Map.Entry instances returned by the appropriate methods will\n+ * not allow setValue() and will throw an\n+ * UnsupportedOperationException on attempts to call that method.\n+ *\n+ * @since Commons Collections 3.0 (previously DoubleOrderedMap v2.0)\n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Marc Johnson\n+ * @author Stephen Colebourne\n+ */\n+public class TreeBidiMap implements OrderedBidiMap {\n+\n+    private static final int KEY = 0;\n+    private static final int VALUE = 1;\n+    private static final int MAPENTRY = 2;\n+    private static final int INVERSEMAPENTRY = 3;\n+    private static final int SUM_OF_INDICES = KEY + VALUE;\n+    private static final int FIRST_INDEX = 0;\n+    private static final int NUMBER_OF_INDICES = 2;\n+    private static final String[] dataName = new String[] { \"key\", \"value\" };\n+    \n+    private Node[] rootNode = new Node[2];\n+    private int nodeCount = 0;\n+    private int modifications = 0;\n+    private Set keySet;\n+    private Set valuesSet;\n+    private Set entrySet;\n+    private TreeBidiMap.Inverse inverse = null;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty TreeBidiMap.\n+     */\n+    public TreeBidiMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new TreeBidiMap by copying an existing Map.\n+     *\n+     * @param map  the map to copy\n+     * @throws ClassCastException if the keys/values in the map are\n+     *  not Comparable or are not mutually comparable\n+     * @throws NullPointerException if any key or value in the map is null\n+     */\n+    public TreeBidiMap(final Map map) {\n+        super();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of key-value mappings in this map.\n+     *\n+     * @return the number of key-value mappings in this map\n+     */\n+    public int size() {\n+        return nodeCount;\n+    }\n+\n+    /**\n+     * Checks whether the map is empty or not.\n+     *\n+     * @return true if the map is empty\n+     */\n+    public boolean isEmpty() {\n+        return (nodeCount == 0);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified key.\n+     *\n+     * @param key  key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public boolean containsKey(final Object key) {\n+        checkKey(key);\n+        return (lookup((Comparable) key, KEY) != null);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified value.\n+     *\n+     * @param value  value whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified value\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public boolean containsValue(final Object value) {\n+        checkValue(value);\n+        return (lookup((Comparable) value, VALUE) != null);\n+    }\n+\n+    /**\n+     * Gets the value to which this map maps the specified key.\n+     * Returns null if the map contains no mapping for this key.\n+     *\n+     * @param key  key whose associated value is to be returned\n+     * @return the value to which this map maps the specified key,\n+     *  or null if the map contains no mapping for this key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public Object get(final Object key) {\n+        return doGet((Comparable) key, KEY);\n+    }\n+\n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     * \n+     *  BidiMap map2 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     *\n+     * @param key  key with which the specified value is to be  associated\n+     * @param value  value to be associated with the specified key\n+     * @return the previous value for the key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public Object put(final Object key, final Object value) {\n+        return doPut((Comparable) key, (Comparable) value, KEY);\n+    }\n+\n+    /**\n+     * Puts all the mappings from the specified map into this map.\n+     * \n+     * @param map  the map to copy from\n+     */\n+    public void putAll(Map map) {\n+        Iterator it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+        \n+    /**\n+     * Removes the mapping for this key from this map if present.\n+     *\n+     * @param key  key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key,\n+     *  or null if there was no mapping for key.\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public Object remove(final Object key) {\n+        return doRemove((Comparable) key, KEY);\n+    }\n+\n+    /**\n+     * Removes all mappings from this map.\n+     */\n+    public void clear() {\n+        modify();\n+\n+        nodeCount = 0;\n+        rootNode[KEY] = null;\n+        rootNode[VALUE] = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the key to which this map maps the specified value.\n+     * Returns null if the map contains no mapping for this value.\n+     *\n+     * @param value  value whose associated key is to be returned.\n+     * @return the key to which this map maps the specified value,\n+     *  or null if the map contains no mapping for this value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public Object getKey(final Object value) {\n+        return doGet((Comparable) value, VALUE);\n+    }\n+\n+    /**\n+     * Removes the mapping for this value from this map if present\n+     *\n+     * @param value  value whose mapping is to be removed from the map\n+     * @return previous key associated with specified value,\n+     *  or null if there was no mapping for value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public Object removeValue(final Object value) {\n+        return doRemove((Comparable) value, VALUE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first (lowest) key currently in this map.\n+     *\n+     * @return the first (lowest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object firstKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return leastNode(rootNode[KEY], KEY).getKey();\n+    }\n+\n+    /**\n+     * Gets the last (highest) key currently in this map.\n+     *\n+     * @return the last (highest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object lastKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return greatestNode(rootNode[KEY], KEY).getKey();\n+    }\n+    \n+    /**\n+     * Gets the next key after the one specified.\n+     *\n+     * @param the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public Object nextKey(Object key) {\n+        checkKey(key);\n+        Node node = nextGreater(lookup((Comparable) key, KEY), KEY);\n+        return (node == null ? null : node.getKey());\n+    }\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     *\n+     * @param the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public Object previousKey(Object key) {\n+        checkKey(key);\n+        Node node = nextSmaller(lookup((Comparable) key, KEY), KEY);\n+        return (node == null ? null : node.getKey());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the keys contained in this map in key order.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set keySet() {\n+        if (keySet == null) {\n+            keySet = new View(this, KEY, KEY);\n+        }\n+        return keySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the values contained in this map in key order.\n+     * The returned object can be cast to a Set.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Collection values() {\n+        if (valuesSet == null) {\n+            valuesSet = new View(this, KEY, VALUE);\n+        }\n+        return valuesSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the entries contained in this map in key order.\n+     * For simple iteration through the map, the MapIterator is quicker.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     * The returned MapEntry objects do not support setValue.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Set entrySet() {\n+        if (entrySet == null) {\n+            return new EntryView(this, KEY, MAPENTRY);\n+        }\n+        return entrySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map entries.\n+     * <p>\n+     * For this map, this iterator is the fastest way to iterate over the entries.\n+     * \n+     * @return an iterator\n+     */\n+    public MapIterator mapIterator() {\n+        if (isEmpty()) {\n+            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+        }\n+        return new ViewMapIterator(this, KEY);\n+    }\n+\n+    /**\n+     * Gets an ordered iterator over the map entries.\n+     * <p>\n+     * This iterator allows both forward and reverse iteration over the entries.\n+     * \n+     * @return an iterator\n+     */\n+    public OrderedMapIterator orderedMapIterator() {\n+        if (isEmpty()) {\n+            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+        }\n+        return new ViewMapIterator(this, KEY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the inverse map for comparison.\n+     * \n+     * @return the inverse map\n+     */\n+    public BidiMap inverseBidiMap() {\n+        return inverseOrderedBidiMap();\n+    }\n+\n+    /**\n+     * Gets the inverse map for comparison.\n+     * \n+     * @return the inverse map\n+     */\n+    public OrderedBidiMap inverseOrderedBidiMap() {\n+        if (inverse == null) {\n+            inverse = new Inverse(this);\n+        }\n+        return inverse;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @param index  the KEY or VALUE int\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        return this.doEquals(obj, KEY);\n+    }\n+    \n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @return the hash code value for this map\n+     */\n+    public int hashCode() {\n+        return this.doHashCode(KEY);\n+    }\n+    \n+    /**\n+     * Returns a string version of this Map in standard format.\n+     * \n+     * @return a standard format string version of the map\n+     */\n+    public String toString() {\n+        return this.doToString(KEY);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Common get logic, used to get by key or get by value\n+     *\n+     * @param obj  the key or value that we're looking for\n+     * @param index  the KEY or VALUE int\n+     * @return the key (if the value was mapped) or the value (if the\n+     *         key was mapped); null if we couldn't find the specified\n+     *         object\n+     */\n+    private Object doGet(final Comparable obj, final int index) {\n+        checkNonNullComparable(obj, index);\n+        Node node = lookup(obj, index);\n+        return ((node == null) ? null : node.getData(oppositeIndex(index)));\n+    }\n+\n+    /**\n+     * Common put logic, differing only in the return value.\n+     * \n+     * @param key  the key, always the main map key\n+     * @param value  the value, always the main map value\n+     * @param index  the KEY or VALUE int, for the return value only\n+     * @return the previously mapped value\n+     */\n+    private Object doPut(final Comparable key, final Comparable value, final int index) {\n+        checkKeyAndValue(key, value);\n+        \n+        // store previous and remove previous mappings\n+        Object prev = (index == KEY ? doGet(key, KEY) :  doGet(value, VALUE));\n+        doRemove((Comparable) key, KEY);\n+        doRemove((Comparable) value, VALUE);\n+        \n+        Node node = rootNode[KEY];\n+        if (node == null) {\n+            // map is empty\n+            Node root = new Node(key, value);\n+            rootNode[KEY] = root;\n+            rootNode[VALUE] = root;\n+            grow();\n+            \n+        } else {\n+            // add new mapping\n+            while (true) {\n+                int cmp = compare(key, node.getData(KEY));\n+        \n+                if (cmp == 0) {\n+                    // shouldn't happen\n+                    throw new IllegalArgumentException(\"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\");\n+                } else if (cmp < 0) {\n+                    if (node.getLeft(KEY) != null) {\n+                        node = node.getLeft(KEY);\n+                    } else {\n+                        Node newNode = new Node(key, value);\n+        \n+                        insertValue(newNode);\n+                        node.setLeft(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+        \n+                        break;\n+                    }\n+                } else { // cmp > 0\n+                    if (node.getRight(KEY) != null) {\n+                        node = node.getRight(KEY);\n+                    } else {\n+                        Node newNode = new Node(key, value);\n+        \n+                        insertValue(newNode);\n+                        node.setRight(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+        \n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return prev;\n+    }\n+\n+    /**\n+     * Remove by object (remove by key or remove by value)\n+     *\n+     * @param o the key, or value, that we're looking for\n+     * @param index  the KEY or VALUE int\n+     *\n+     * @return the key, if remove by value, or the value, if remove by\n+     *         key. null if the specified key or value could not be\n+     *         found\n+     */\n+    private Object doRemove(final Comparable o, final int index) {\n+        Node node = lookup(o, index);\n+        Object rval = null;\n+        if (node != null) {\n+            rval = node.getData(oppositeIndex(index));\n+            doRedBlackDelete(node);\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * do the actual lookup of a piece of data\n+     *\n+     * @param data the key or value to be looked up\n+     * @param index  the KEY or VALUE int\n+     * @return the desired Node, or null if there is no mapping of the\n+     *         specified data\n+     */\n+    private Node lookup(final Comparable data, final int index) {\n+        Node rval = null;\n+        Node node = rootNode[index];\n+\n+        while (node != null) {\n+            int cmp = compare(data, node.getData(index));\n+            if (cmp == 0) {\n+                rval = node;\n+                break;\n+            } else {\n+                node = (cmp < 0) ? node.getLeft(index) : node.getRight(index);\n+            }\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node nextGreater(final Node node, final int index) {\n+        Node rval = null;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getRight(index) != null) {\n+            // everything to the node's right is larger. The least of\n+            // the right node's descendants is the next larger node\n+            rval = leastNode(node.getRight(index), index);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose left child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's left\n+            // ... and that ancestor is the next greatest node\n+            Node parent = node.getParent(index);\n+            Node child = node;\n+\n+            while ((parent != null) && (child == parent.getRight(index))) {\n+                child = parent;\n+                parent = parent.getParent(index);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node nextSmaller(final Node node, final int index) {\n+        Node rval = null;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getLeft(index) != null) {\n+            // everything to the node's left is smaller. The greatest of\n+            // the left node's descendants is the next smaller node\n+            rval = greatestNode(node.getLeft(index), index);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose right child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's right\n+            // ... and that ancestor is the next greatest node\n+            Node parent = node.getParent(index);\n+            Node child = node;\n+\n+            while ((parent != null) && (child == parent.getLeft(index))) {\n+                child = parent;\n+                parent = parent.getParent(index);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the opposite index of the specified index\n+     *\n+     * @param index  the KEY or VALUE int\n+     * @return VALUE (if KEY was specified), else KEY\n+     */\n+    private static int oppositeIndex(final int index) {\n+        // old trick ... to find the opposite of a value, m or n,\n+        // subtract the value from the sum of the two possible\n+        // values. (m + n) - m = n; (m + n) - n = m\n+        return SUM_OF_INDICES - index;\n+    }\n+\n+    /**\n+     * Compare two objects\n+     *\n+     * @param o1  the first object\n+     * @param o2  the second object\n+     *\n+     * @return negative value if o1 < o2; 0 if o1 == o2; positive\n+     *         value if o1 > o2\n+     */\n+    private static int compare(final Comparable o1, final Comparable o2) {\n+        return ((Comparable) o1).compareTo(o2);\n+    }\n+\n+    /**\n+     * Find the least node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the smallest node, from the specified node, in the\n+     *         specified mapping\n+     */\n+    private static Node leastNode(final Node node, final int index) {\n+        Node rval = node;\n+        if (rval != null) {\n+            while (rval.getLeft(index) != null) {\n+                rval = rval.getLeft(index);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * Find the greatest node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the greatest node, from the specified node\n+     */\n+    private static Node greatestNode(final Node node, final int index) {\n+        Node rval = node;\n+        if (rval != null) {\n+            while (rval.getRight(index) != null) {\n+                rval = rval.getRight(index);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * copy the color from one node to another, dealing with the fact\n+     * that one or both nodes may, in fact, be null\n+     *\n+     * @param from the node whose color we're copying; may be null\n+     * @param to the node whose color we're changing; may be null\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void copyColor(final Node from, final Node to, final int index) {\n+        if (to != null) {\n+            if (from == null) {\n+                // by default, make it black\n+                to.setBlack(index);\n+            } else {\n+                to.copyColor(from, index);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * is the specified node red? if the node does not exist, no, it's\n+     * black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isRed(final Node node, final int index) {\n+        return ((node == null) ? false : node.isRed(index));\n+    }\n+\n+    /**\n+     * is the specified black red? if the node does not exist, sure,\n+     * it's black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isBlack(final Node node, final int index) {\n+        return ((node == null) ? true : node.isBlack(index));\n+    }\n+\n+    /**\n+     * force a node (if it exists) red\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeRed(final Node node, final int index) {\n+        if (node != null) {\n+            node.setRed(index);\n+        }\n+    }\n+\n+    /**\n+     * force a node (if it exists) black\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeBlack(final Node node, final int index) {\n+        if (node != null) {\n+            node.setBlack(index);\n+        }\n+    }\n+\n+    /**\n+     * get a node's grandparent. mind you, the node, its parent, or\n+     * its grandparent may not exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getGrandParent(final Node node, final int index) {\n+        return getParent(getParent(node, index), index);\n+    }\n+\n+    /**\n+     * get a node's parent. mind you, the node, or its parent, may not\n+     * exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getParent(final Node node, final int index) {\n+        return ((node == null) ? null : node.getParent(index));\n+    }\n+\n+    /**\n+     * get a node's right child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getRightChild(final Node node, final int index) {\n+        return (node == null) ? null : node.getRight(index);\n+    }\n+\n+    /**\n+     * get a node's left child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getLeftChild(final Node node, final int index) {\n+        return (node == null) ? null : node.getLeft(index);\n+    }\n+\n+    /**\n+     * is this node its parent's left child? mind you, the node, or\n+     * its parent, may not exist. no problem. if the node doesn't\n+     * exist ... it's its non-existent parent's left child. If the\n+     * node does exist but has no parent ... no, we're not the\n+     * non-existent parent's left child. Otherwise (both the specified\n+     * node AND its parent exist), check.\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isLeftChild(final Node node, final int index) {\n+        return (node == null)\n+            ? true\n+            : ((node.getParent(index) == null) ?\n+                false : (node == node.getParent(index).getLeft(index)));\n+    }\n+\n+    /**\n+     * is this node its parent's right child? mind you, the node, or\n+     * its parent, may not exist. no problem. if the node doesn't\n+     * exist ... it's its non-existent parent's right child. If the\n+     * node does exist but has no parent ... no, we're not the\n+     * non-existent parent's right child. Otherwise (both the\n+     * specified node AND its parent exist), check.\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isRightChild(final Node node, final int index) {\n+        return (node == null)\n+            ? true\n+            : ((node.getParent(index) == null) ? \n+                false : (node == node.getParent(index).getRight(index)));\n+    }\n+\n+    /**\n+     * do a rotate left. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateLeft(final Node node, final int index) {\n+        Node rightChild = node.getRight(index);\n+        node.setRight(rightChild.getLeft(index), index);\n+\n+        if (rightChild.getLeft(index) != null) {\n+            rightChild.getLeft(index).setParent(node, index);\n+        }\n+        rightChild.setParent(node.getParent(index), index);\n+        \n+        if (node.getParent(index) == null) {\n+            // node was the root ... now its right child is the root\n+            rootNode[index] = rightChild;\n+        } else if (node.getParent(index).getLeft(index) == node) {\n+            node.getParent(index).setLeft(rightChild, index);\n+        } else {\n+            node.getParent(index).setRight(rightChild, index);\n+        }\n+\n+        rightChild.setLeft(node, index);\n+        node.setParent(rightChild, index);\n+    }\n+\n+    /**\n+     * do a rotate right. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateRight(final Node node, final int index) {\n+        Node leftChild = node.getLeft(index);\n+        node.setLeft(leftChild.getRight(index), index);\n+        if (leftChild.getRight(index) != null) {\n+            leftChild.getRight(index).setParent(node, index);\n+        }\n+        leftChild.setParent(node.getParent(index), index);\n+\n+        if (node.getParent(index) == null) {\n+            // node was the root ... now its left child is the root\n+            rootNode[index] = leftChild;\n+        } else if (node.getParent(index).getRight(index) == node) {\n+            node.getParent(index).setRight(leftChild, index);\n+        } else {\n+            node.getParent(index).setLeft(leftChild, index);\n+        }\n+\n+        leftChild.setRight(node, index);\n+        node.setParent(leftChild, index);\n+    }\n+\n+    /**\n+     * complicated red-black insert stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param insertedNode the node to be inserted\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void doRedBlackInsert(final Node insertedNode, final int index) {\n+        Node currentNode = insertedNode;\n+        makeRed(currentNode, index);\n+\n+        while ((currentNode != null)\n+            && (currentNode != rootNode[index])\n+            && (isRed(currentNode.getParent(index), index))) {\n+            if (isLeftChild(getParent(currentNode, index), index)) {\n+                Node y = getRightChild(getGrandParent(currentNode, index), index);\n+\n+                if (isRed(y, index)) {\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(y, index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    currentNode = getGrandParent(currentNode, index);\n+                } else {\n+                    if (isRightChild(currentNode, index)) {\n+                        currentNode = getParent(currentNode, index);\n+\n+                        rotateLeft(currentNode, index);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    if (getGrandParent(currentNode, index) != null) {\n+                        rotateRight(getGrandParent(currentNode, index), index);\n+                    }\n+                }\n+            } else {\n+\n+                // just like clause above, except swap left for right\n+                Node y = getLeftChild(getGrandParent(currentNode, index), index);\n+\n+                if (isRed(y, index)) {\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(y, index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    currentNode = getGrandParent(currentNode, index);\n+                } else {\n+                    if (isLeftChild(currentNode, index)) {\n+                        currentNode = getParent(currentNode, index);\n+\n+                        rotateRight(currentNode, index);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    if (getGrandParent(currentNode, index) != null) {\n+                        rotateLeft(getGrandParent(currentNode, index), index);\n+                    }\n+                }\n+            }\n+        }\n+\n+        makeBlack(rootNode[index], index);\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param deletedNode the node to be deleted\n+     */\n+    private void doRedBlackDelete(final Node deletedNode) {\n+        for (int index = FIRST_INDEX; index < NUMBER_OF_INDICES; index++) {\n+            // if deleted node has both left and children, swap with\n+            // the next greater node\n+            if ((deletedNode.getLeft(index) != null) && (deletedNode.getRight(index) != null)) {\n+                swapPosition(nextGreater(deletedNode, index), deletedNode, index);\n+            }\n+\n+            Node replacement =\n+                ((deletedNode.getLeft(index) != null) ? deletedNode.getLeft(index) : deletedNode.getRight(index));\n+\n+            if (replacement != null) {\n+                replacement.setParent(deletedNode.getParent(index), index);\n+\n+                if (deletedNode.getParent(index) == null) {\n+                    rootNode[index] = replacement;\n+                } else if (deletedNode == deletedNode.getParent(index).getLeft(index)) {\n+                    deletedNode.getParent(index).setLeft(replacement, index);\n+                } else {\n+                    deletedNode.getParent(index).setRight(replacement, index);\n+                }\n+\n+                deletedNode.setLeft(null, index);\n+                deletedNode.setRight(null, index);\n+                deletedNode.setParent(null, index);\n+\n+                if (isBlack(deletedNode, index)) {\n+                    doRedBlackDeleteFixup(replacement, index);\n+                }\n+            } else {\n+\n+                // replacement is null\n+                if (deletedNode.getParent(index) == null) {\n+\n+                    // empty tree\n+                    rootNode[index] = null;\n+                } else {\n+\n+                    // deleted node had no children\n+                    if (isBlack(deletedNode, index)) {\n+                        doRedBlackDeleteFixup(deletedNode, index);\n+                    }\n+\n+                    if (deletedNode.getParent(index) != null) {\n+                        if (deletedNode == deletedNode.getParent(index).getLeft(index)) {\n+                            deletedNode.getParent(index).setLeft(null, index);\n+                        } else {\n+                            deletedNode.getParent(index).setRight(null, index);\n+                        }\n+\n+                        deletedNode.setParent(null, index);\n+                    }\n+                }\n+            }\n+        }\n+        shrink();\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more. This\n+     * rebalances the tree (somewhat, as red-black trees are not\n+     * perfectly balanced -- perfect balancing takes longer)\n+     *\n+     * @param replacementNode the node being replaced\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void doRedBlackDeleteFixup(final Node replacementNode, final int index) {\n+        Node currentNode = replacementNode;\n+\n+        while ((currentNode != rootNode[index]) && (isBlack(currentNode, index))) {\n+            if (isLeftChild(currentNode, index)) {\n+                Node siblingNode = getRightChild(getParent(currentNode, index), index);\n+\n+                if (isRed(siblingNode, index)) {\n+                    makeBlack(siblingNode, index);\n+                    makeRed(getParent(currentNode, index), index);\n+                    rotateLeft(getParent(currentNode, index), index);\n+\n+                    siblingNode = getRightChild(getParent(currentNode, index), index);\n+                }\n+\n+                if (isBlack(getLeftChild(siblingNode, index), index)\n+                    && isBlack(getRightChild(siblingNode, index), index)) {\n+                    makeRed(siblingNode, index);\n+\n+                    currentNode = getParent(currentNode, index);\n+                } else {\n+                    if (isBlack(getRightChild(siblingNode, index), index)) {\n+                        makeBlack(getLeftChild(siblingNode, index), index);\n+                        makeRed(siblingNode, index);\n+                        rotateRight(siblingNode, index);\n+\n+                        siblingNode = getRightChild(getParent(currentNode, index), index);\n+                    }\n+\n+                    copyColor(getParent(currentNode, index), siblingNode, index);\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(getRightChild(siblingNode, index), index);\n+                    rotateLeft(getParent(currentNode, index), index);\n+\n+                    currentNode = rootNode[index];\n+                }\n+            } else {\n+                Node siblingNode = getLeftChild(getParent(currentNode, index), index);\n+\n+                if (isRed(siblingNode, index)) {\n+                    makeBlack(siblingNode, index);\n+                    makeRed(getParent(currentNode, index), index);\n+                    rotateRight(getParent(currentNode, index), index);\n+\n+                    siblingNode = getLeftChild(getParent(currentNode, index), index);\n+                }\n+\n+                if (isBlack(getRightChild(siblingNode, index), index)\n+                    && isBlack(getLeftChild(siblingNode, index), index)) {\n+                    makeRed(siblingNode, index);\n+\n+                    currentNode = getParent(currentNode, index);\n+                } else {\n+                    if (isBlack(getLeftChild(siblingNode, index), index)) {\n+                        makeBlack(getRightChild(siblingNode, index), index);\n+                        makeRed(siblingNode, index);\n+                        rotateLeft(siblingNode, index);\n+\n+                        siblingNode = getLeftChild(getParent(currentNode, index), index);\n+                    }\n+\n+                    copyColor(getParent(currentNode, index), siblingNode, index);\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(getLeftChild(siblingNode, index), index);\n+                    rotateRight(getParent(currentNode, index), index);\n+\n+                    currentNode = rootNode[index];\n+                }\n+            }\n+        }\n+\n+        makeBlack(currentNode, index);\n+    }\n+\n+    /**\n+     * swap two nodes (except for their content), taking care of\n+     * special cases where one is the other's parent ... hey, it\n+     * happens.\n+     *\n+     * @param x one node\n+     * @param y another node\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void swapPosition(final Node x, final Node y, final int index) {\n+        // Save initial values.\n+        Node xFormerParent = x.getParent(index);\n+        Node xFormerLeftChild = x.getLeft(index);\n+        Node xFormerRightChild = x.getRight(index);\n+        Node yFormerParent = y.getParent(index);\n+        Node yFormerLeftChild = y.getLeft(index);\n+        Node yFormerRightChild = y.getRight(index);\n+        boolean xWasLeftChild = (x.getParent(index) != null) && (x == x.getParent(index).getLeft(index));\n+        boolean yWasLeftChild = (y.getParent(index) != null) && (y == y.getParent(index).getLeft(index));\n+\n+        // Swap, handling special cases of one being the other's parent.\n+        if (x == yFormerParent) { // x was y's parent\n+            x.setParent(y, index);\n+\n+            if (yWasLeftChild) {\n+                y.setLeft(x, index);\n+                y.setRight(xFormerRightChild, index);\n+            } else {\n+                y.setRight(x, index);\n+                y.setLeft(xFormerLeftChild, index);\n+            }\n+        } else {\n+            x.setParent(yFormerParent, index);\n+\n+            if (yFormerParent != null) {\n+                if (yWasLeftChild) {\n+                    yFormerParent.setLeft(x, index);\n+                } else {\n+                    yFormerParent.setRight(x, index);\n+                }\n+            }\n+\n+            y.setLeft(xFormerLeftChild, index);\n+            y.setRight(xFormerRightChild, index);\n+        }\n+\n+        if (y == xFormerParent) { // y was x's parent\n+            y.setParent(x, index);\n+\n+            if (xWasLeftChild) {\n+                x.setLeft(y, index);\n+                x.setRight(yFormerRightChild, index);\n+            } else {\n+                x.setRight(y, index);\n+                x.setLeft(yFormerLeftChild, index);\n+            }\n+        } else {\n+            y.setParent(xFormerParent, index);\n+\n+            if (xFormerParent != null) {\n+                if (xWasLeftChild) {\n+                    xFormerParent.setLeft(y, index);\n+                } else {\n+                    xFormerParent.setRight(y, index);\n+                }\n+            }\n+\n+            x.setLeft(yFormerLeftChild, index);\n+            x.setRight(yFormerRightChild, index);\n+        }\n+\n+        // Fix children's parent pointers\n+        if (x.getLeft(index) != null) {\n+            x.getLeft(index).setParent(x, index);\n+        }\n+\n+        if (x.getRight(index) != null) {\n+            x.getRight(index).setParent(x, index);\n+        }\n+\n+        if (y.getLeft(index) != null) {\n+            y.getLeft(index).setParent(y, index);\n+        }\n+\n+        if (y.getRight(index) != null) {\n+            y.getRight(index).setParent(y, index);\n+        }\n+\n+        x.swapColors(y, index);\n+\n+        // Check if root changed\n+        if (rootNode[index] == x) {\n+            rootNode[index] = y;\n+        } else if (rootNode[index] == y) {\n+            rootNode[index] = x;\n+        }\n+    }\n+\n+    /**\n+     * check if an object is fit to be proper input ... has to be\n+     * Comparable and non-null\n+     *\n+     * @param o the object being checked\n+     * @param index  the KEY or VALUE int (used to put the right word in the\n+     *              exception message)\n+     *\n+     * @throws NullPointerException if o is null\n+     * @throws ClassCastException if o is not Comparable\n+     */\n+    private static void checkNonNullComparable(final Object o, final int index) {\n+        if (o == null) {\n+            throw new NullPointerException(dataName[index] + \" cannot be null\");\n+        }\n+        if (!(o instanceof Comparable)) {\n+            throw new ClassCastException(dataName[index] + \" must be Comparable\");\n+        }\n+    }\n+\n+    /**\n+     * check a key for validity (non-null and implements Comparable)\n+     *\n+     * @param key the key to be checked\n+     *\n+     * @throws NullPointerException if key is null\n+     * @throws ClassCastException if key is not Comparable\n+     */\n+    private static void checkKey(final Object key) {\n+        checkNonNullComparable(key, KEY);\n+    }\n+\n+    /**\n+     * check a value for validity (non-null and implements Comparable)\n+     *\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if value is null\n+     * @throws ClassCastException if value is not Comparable\n+     */\n+    private static void checkValue(final Object value) {\n+        checkNonNullComparable(value, VALUE);\n+    }\n+\n+    /**\n+     * check a key and a value for validity (non-null and implements\n+     * Comparable)\n+     *\n+     * @param key the key to be checked\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if key or value is null\n+     * @throws ClassCastException if key or value is not Comparable\n+     */\n+    private static void checkKeyAndValue(final Object key, final Object value) {\n+        checkKey(key);\n+        checkValue(value);\n+    }\n+\n+    /**\n+     * increment the modification count -- used to check for\n+     * concurrent modification of the map through the map and through\n+     * an Iterator from one of its Set or Collection views\n+     */\n+    private void modify() {\n+        modifications++;\n+    }\n+\n+    /**\n+     * bump up the size and note that the map has changed\n+     */\n+    private void grow() {\n+        modify();\n+        nodeCount++;\n+    }\n+\n+    /**\n+     * decrement the size and note that the map has changed\n+     */\n+    private void shrink() {\n+        modify();\n+        nodeCount--;\n+    }\n+\n+    /**\n+     * insert a node by its value\n+     *\n+     * @param newNode the node to be inserted\n+     *\n+     * @throws IllegalArgumentException if the node already exists\n+     *                                     in the value mapping\n+     */\n+    private void insertValue(final Node newNode) throws IllegalArgumentException {\n+        Node node = rootNode[VALUE];\n+\n+        while (true) {\n+            int cmp = compare(newNode.getData(VALUE), node.getData(VALUE));\n+\n+            if (cmp == 0) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot store a duplicate value (\\\"\" + newNode.getData(VALUE) + \"\\\") in this Map\");\n+            } else if (cmp < 0) {\n+                if (node.getLeft(VALUE) != null) {\n+                    node = node.getLeft(VALUE);\n+                } else {\n+                    node.setLeft(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            } else { // cmp > 0\n+                if (node.getRight(VALUE) != null) {\n+                    node = node.getRight(VALUE);\n+                } else {\n+                    node.setRight(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @param index  the KEY or VALUE int\n+     * @return true if equal\n+     */\n+    private boolean doEquals(Object obj, final int type) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map other = (Map) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+\n+        if (nodeCount > 0) {\n+            try {\n+                for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {\n+                    Object key = it.next();\n+                    Object value = it.getValue();\n+                    if (value.equals(other.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            } catch (ClassCastException ex) {\n+                return false;\n+            } catch (NullPointerException ex) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @param index  the KEY or VALUE int\n+     * @return the hash code value for this map\n+     */\n+    private int doHashCode(final int type) {\n+        int total = 0;\n+        if (nodeCount > 0) {\n+            for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {\n+                Object key = it.next();\n+                Object value = it.getValue();\n+                total += (key.hashCode() ^ value.hashCode());\n+            }\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Gets the string form of this map as per AbstractMap.\n+     *\n+     * @param index  the KEY or VALUE int\n+     * @return the string form of this map\n+     */\n+    private String doToString(final int type) {\n+        if (nodeCount == 0) {\n+            return \"{}\";\n+        }\n+        StringBuffer buf = new StringBuffer(nodeCount * 32);\n+        buf.append('{');\n+        MapIterator it = new ViewMapIterator(this, type);\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            Object key = it.next();\n+            Object value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A view of this map.\n+     */\n+    static class View extends AbstractSet {\n+        \n+        protected final TreeBidiMap main;\n+        protected final int orderType;\n+        protected final int dataType;\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int\n+         */\n+        View(final TreeBidiMap main, final int orderType, final int dataType) {\n+            super();\n+            this.main = main;\n+            this.orderType = orderType;\n+            this.dataType = dataType;\n+        }\n+        \n+        public Iterator iterator() {\n+            return new ViewIterator(main, orderType, dataType);\n+        }\n+\n+        public int size() {\n+            return main.size();\n+        }\n+\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, dataType);\n+            return (main.lookup((Comparable) obj, dataType) != null);\n+        }\n+\n+        public boolean remove(final Object obj) {\n+            return (main.doRemove((Comparable) obj, dataType) != null);\n+        }\n+\n+        public void clear() {\n+            main.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    static class ViewIterator implements OrderedIterator {\n+\n+        protected final TreeBidiMap main;\n+        protected final int orderType;\n+        protected final int dataType;\n+        protected Node lastReturnedNode;\n+        protected Node nextNode;\n+        protected Node previousNode;\n+        private int expectedModifications;\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int\n+         */\n+        ViewIterator(final TreeBidiMap main, final int orderType, final int dataType) {\n+            super();\n+            this.main = main;\n+            this.orderType = orderType;\n+            this.dataType = dataType;\n+            expectedModifications = main.modifications;\n+            nextNode = leastNode(main.rootNode[orderType], orderType);\n+            lastReturnedNode = null;\n+            previousNode = null;\n+        }\n+\n+        public final boolean hasNext() {\n+            return (nextNode != null);\n+        }\n+\n+        public final Object next() {\n+            if (nextNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (main.modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            lastReturnedNode = nextNode;\n+            previousNode = nextNode;\n+            nextNode = main.nextGreater(nextNode, orderType);\n+            return doGetData();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (previousNode != null);\n+        }\n+\n+        public Object previous() {\n+            if (previousNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (main.modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            nextNode = lastReturnedNode;\n+            if (nextNode == null) {\n+                nextNode = main.nextGreater(previousNode, orderType);\n+            }\n+            lastReturnedNode = previousNode;\n+            previousNode = main.nextSmaller(previousNode, orderType);\n+            return doGetData();\n+        }\n+\n+        protected Object doGetData() {\n+            switch (dataType) {\n+                case KEY:\n+                    return lastReturnedNode.getKey();\n+                case VALUE:\n+                    return lastReturnedNode.getValue();\n+                case MAPENTRY:\n+                    return lastReturnedNode;\n+                case INVERSEMAPENTRY:\n+                    return new UnmodifiableMapEntry(lastReturnedNode.getValue(), lastReturnedNode.getKey());\n+            }\n+            return null;\n+        }\n+\n+        public final void remove() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException();\n+            }\n+            if (main.modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            main.doRedBlackDelete(lastReturnedNode);\n+            expectedModifications++;\n+            lastReturnedNode = null;\n+            if (nextNode == null) {\n+                previousNode = main.greatestNode(main.rootNode[orderType], orderType);\n+            } else {\n+                previousNode = main.nextSmaller(nextNode, orderType);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    static class ViewMapIterator extends ViewIterator implements OrderedMapIterator {\n+\n+        private final int oppositeType;\n+        \n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         */\n+        ViewMapIterator(final TreeBidiMap main, final int orderType) {\n+            super(main, orderType, orderType);\n+            this.oppositeType = oppositeIndex(dataType);\n+        }\n+        \n+        public Object getKey() {\n+            return lastReturnedNode.getData(dataType);\n+        }\n+\n+        public Object getValue() {\n+            return lastReturnedNode.getData(oppositeType);\n+        }\n+\n+        public Object setValue(final Object obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A view of this map.\n+     */\n+    static class EntryView extends View {\n+        \n+        private final int oppositeType;\n+        \n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param dataType  the MAPENTRY or INVERSEMAPENTRY int for the returned data\n+         */\n+        EntryView(final TreeBidiMap main, final int orderType, final int dataType) {\n+            super(main, orderType, dataType);\n+            this.oppositeType = main.oppositeIndex(orderType);\n+        }\n+        \n+        public boolean contains(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            Object value = entry.getValue();\n+            Node node = main.lookup((Comparable) entry.getKey(), orderType);\n+            return (node != null && node.getData(oppositeType).equals(value));\n+        }\n+\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            Object value = entry.getValue();\n+            Node node = main.lookup((Comparable) entry.getKey(), orderType);\n+            if (node != null && node.getData(oppositeType).equals(value)) {\n+                main.doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node used to store the data.\n+     */\n+    static class Node implements Map.Entry {\n+\n+        private Comparable[] data;\n+        private Node[] leftNode;\n+        private Node[] rightNode;\n+        private Node[] parentNode;\n+        private boolean[] blackColor;\n+        private int hashcodeValue;\n+        private boolean calculatedHashCode;\n+\n+        /**\n+         * Make a new cell with given key and value, and with null\n+         * links, and black (true) colors.\n+         *\n+         * @param key\n+         * @param value\n+         */\n+        Node(final Comparable key, final Comparable value) {\n+            super();\n+            data = new Comparable[] { key, value };\n+            leftNode = new Node[2];\n+            rightNode = new Node[2];\n+            parentNode = new Node[2];\n+            blackColor = new boolean[] { true, true };\n+            calculatedHashCode = false;\n+        }\n+\n+        /**\n+         * Get the specified data.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the key or value\n+         */\n+        private Comparable getData(final int index) {\n+            return data[index];\n+        }\n+\n+        /**\n+         * Set this node's left node.\n+         *\n+         * @param node  the new left node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setLeft(final Node node, final int index) {\n+            leftNode[index] = node;\n+        }\n+\n+        /**\n+         * Get the left node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the left node, may be null\n+         */\n+        private Node getLeft(final int index) {\n+            return leftNode[index];\n+        }\n+\n+        /**\n+         * Set this node's right node.\n+         *\n+         * @param node  the new right node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setRight(final Node node, final int index) {\n+            rightNode[index] = node;\n+        }\n+\n+        /**\n+         * Get the right node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the right node, may be null\n+         */\n+        private Node getRight(final int index) {\n+            return rightNode[index];\n+        }\n+\n+        /**\n+         * Set this node's parent node.\n+         *\n+         * @param node  the new parent node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setParent(final Node node, final int index) {\n+            parentNode[index] = node;\n+        }\n+\n+        /**\n+         * Get the parent node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the parent node, may be null\n+         */\n+        private Node getParent(final int index) {\n+            return parentNode[index];\n+        }\n+\n+        /**\n+         * Exchange colors with another node.\n+         *\n+         * @param node  the node to swap with\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void swapColors(final Node node, final int index) {\n+            // Swap colors -- old hacker's trick\n+            blackColor[index]      ^= node.blackColor[index];\n+            node.blackColor[index] ^= blackColor[index];\n+            blackColor[index]      ^= node.blackColor[index];\n+        }\n+\n+        /**\n+         * Is this node black?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if black (which is represented as a true boolean)\n+         */\n+        private boolean isBlack(final int index) {\n+            return blackColor[index];\n+        }\n+\n+        /**\n+         * Is this node red?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if non-black\n+         */\n+        private boolean isRed(final int index) {\n+            return !blackColor[index];\n+        }\n+\n+        /**\n+         * Make this node black.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setBlack(final int index) {\n+            blackColor[index] = true;\n+        }\n+\n+        /**\n+         * Make this node red.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setRed(final int index) {\n+            blackColor[index] = false;\n+        }\n+\n+        /**\n+         * Make this node the same color as another\n+         *\n+         * @param node  the node whose color we're adopting\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void copyColor(final Node node, final int index) {\n+            blackColor[index] = node.blackColor[index];\n+        }\n+\n+        //-------------------------------------------------------------------\n+        /**\n+         * Gets the key.\n+         * \n+         * @return the key corresponding to this entry.\n+         */\n+        public Object getKey() {\n+            return data[KEY];\n+        }\n+\n+        /**\n+         * Gets the value.\n+         * \n+         * @return the value corresponding to this entry.\n+         */\n+        public Object getValue() {\n+            return data[VALUE];\n+        }\n+\n+        /**\n+         * Optional operation that is not permitted in this implementation\n+         *\n+         * @param ignored\n+         * @return does not return\n+         * @throws UnsupportedOperationException always\n+         */\n+        public Object setValue(final Object ignored)\n+                throws UnsupportedOperationException {\n+            throw new UnsupportedOperationException(\n+                \"Map.Entry.setValue is not supported\");\n+        }\n+\n+        /**\n+         * Compares the specified object with this entry for equality.\n+         * Returns true if the given object is also a map entry and\n+         * the two entries represent the same mapping.\n+         *\n+         * @param o object to be compared for equality with this map\n+         *          entry.\n+         * @return true if the specified object is equal to this map\n+         *         entry.\n+         */\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (!(obj instanceof Map.Entry)) {\n+                return false;\n+            }\n+            Map.Entry e = (Map.Entry) obj;\n+            return data[KEY].equals(e.getKey()) && data[VALUE].equals(e.getValue());\n+        }\n+\n+        /**\n+         * @return the hash code value for this map entry.\n+         */\n+        public int hashCode() {\n+            if (!calculatedHashCode) {\n+                hashcodeValue = data[KEY].hashCode() ^ data[VALUE].hashCode();\n+                calculatedHashCode = true;\n+            }\n+            return hashcodeValue;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node used to store the data.\n+     */\n+    static class Inverse implements OrderedBidiMap {\n+        \n+        private final TreeBidiMap main;\n+        private Set keySet;\n+        private Set valuesSet;\n+        private Set entrySet;\n+        \n+        Inverse(final TreeBidiMap main) {\n+            super();\n+            this.main = main;\n+        }\n+\n+        public int size() {\n+            return main.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return main.isEmpty();\n+        }\n+\n+        public Object get(final Object key) {\n+            return main.getKey(key);\n+        }\n+\n+        public Object getKey(final Object value) {\n+            return main.get(value);\n+        }\n+\n+        public boolean containsKey(final Object key) {\n+            return main.containsValue(key);\n+        }\n+\n+        public boolean containsValue(final Object value) {\n+            return main.containsKey(value);\n+        }\n+\n+        public Object firstKey() {\n+            if (main.nodeCount == 0) {\n+                throw new NoSuchElementException(\"Map is empty\");\n+            }\n+            return main.leastNode(main.rootNode[VALUE], VALUE).getValue();\n+        }\n+\n+        public Object lastKey() {\n+            if (main.nodeCount == 0) {\n+                throw new NoSuchElementException(\"Map is empty\");\n+            }\n+            return main.greatestNode(main.rootNode[VALUE], VALUE).getValue();\n+        }\n+    \n+        public Object nextKey(Object key) {\n+            checkKey(key);\n+            Node node = main.nextGreater(main.lookup((Comparable) key, VALUE), VALUE);\n+            return (node == null ? null : node.getValue());\n+        }\n+\n+        public Object previousKey(Object key) {\n+            checkKey(key);\n+            Node node = main.nextSmaller(main.lookup((Comparable) key, VALUE), VALUE);\n+            return (node == null ? null : node.getValue());\n+        }\n+\n+        public Object put(final Object key, final Object value) {\n+            return main.doPut((Comparable) value, (Comparable) key, VALUE);\n+        }\n+\n+        public void putAll(Map map) {\n+            Iterator it = map.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        \n+        public Object remove(final Object key) {\n+            return main.removeValue(key);\n+        }\n+\n+        public Object removeValue(final Object value) {\n+            return main.remove(value);\n+        }\n+\n+        public void clear() {\n+            main.clear();\n+        }\n+\n+        public Set keySet() {\n+            if (keySet == null) {\n+                keySet = new View(main, VALUE, VALUE);\n+            }\n+            return keySet;\n+        }\n+\n+        public Collection values() {\n+            if (valuesSet == null) {\n+                valuesSet = new View(main, VALUE, KEY);\n+            }\n+            return valuesSet;\n+        }\n+\n+        public Set entrySet() {\n+            if (entrySet == null) {\n+                return new EntryView(main, VALUE, INVERSEMAPENTRY);\n+            }\n+            return entrySet;\n+        }\n+        \n+        public MapIterator mapIterator() {\n+            if (isEmpty()) {\n+                return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+            }\n+            return new ViewMapIterator(main, VALUE);\n+        }\n+\n+        public OrderedMapIterator orderedMapIterator() {\n+            if (isEmpty()) {\n+                return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+            }\n+            return new ViewMapIterator(main, VALUE);\n+        }\n+\n+        public BidiMap inverseBidiMap() {\n+            return main;\n+        }\n+        \n+        public OrderedBidiMap inverseOrderedBidiMap() {\n+            return main;\n+        }\n+        \n+        public boolean equals(Object obj) {\n+            return main.doEquals(obj, VALUE);\n+        }\n+    \n+        public int hashCode() {\n+            return main.doHashCode(VALUE);\n+        }\n+    \n+        public String toString() {\n+            return main.doToString(VALUE);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/OrderedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Attic/OrderedMap.java,v 1.1 2003/11/16 20:35:47 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.iterators.OrderedMapIterator;\n+\n+/**\n+ * Defines a map that maintains order and allows both forward and backward\n+ * iteration through that order.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:47 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface OrderedMap extends Map {\n+    \n+    /**\n+     * Obtains an <code>OrderedMapIterator</code> over the map.\n+     * <p>\n+     * A ordered map iterator is an efficient way of iterating over maps\n+     * in both directions.\n+     * <pre>\n+     * BidiMap map = new TreeBidiMap();\n+     * MapIterator it = map.mapIterator();\n+     * while (it.hasNext()) {\n+     *   Object key = it.next();\n+     *   Object value = it.getValue();\n+     *   it.setValue(\"newValue\");\n+     *   Object previousKey = it.previous();\n+     * }\n+     * </pre>\n+     * \n+     * @return a map iterator\n+     */\n+    OrderedMapIterator orderedMapIterator();\n+    \n+    /**\n+     * Gets the first key currently in this map.\n+     *\n+     * @return the first key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object firstKey();\n+\n+    /**\n+     * Gets the last key currently in this map.\n+     *\n+     * @return the last key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object lastKey();\n+    \n+    /**\n+     * Gets the next key after the one specified.\n+     *\n+     * @param key  the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public Object nextKey(Object key);\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     *\n+     * @param key  the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public Object previousKey(Object key);\n+    \n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.53 2003/11/08 18:52:51 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.54 2003/11/16 20:35:46 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Entry point for all Collections package tests.\n  * \n- * @version $Revision: 1.53 $ $Date: 2003/11/08 18:52:51 $\n+ * @version $Revision: 1.54 $ $Date: 2003/11/16 20:35:46 $\n  * \n  * @author Rodney Waldhoff\n  * @author Stephen Colebourne\n         suite.addTest(TestCommonsLinkedList.suite());\n         suite.addTest(TestCursorableLinkedList.suite());\n         suite.addTest(TestDoubleOrderedMap.suite());\n-        suite.addTest(TestDualHashBidiMap.suite());\n-        suite.addTest(TestDualTreeBidiMap.suite());\n         suite.addTest(TestExtendedProperties.suite());\n         suite.addTest(TestFastArrayList.suite());\n         suite.addTest(TestFastArrayList1.suite());\n         suite.addTest(TestSequencedHashMap.suite());\n         suite.addTest(TestStaticBucketMap.suite());\n         suite.addTest(TestTreeBag.suite());\n-        suite.addTest(TestTreeBidiMap.suite());\n         suite.addTest(TestUnboundedFifoBuffer.suite());\n         suite.addTest(TestEnumerationUtils.suite());\n         return suite;\n--- a/src/test/org/apache/commons/collections/TestAllPackages.java\n+++ b/src/test/org/apache/commons/collections/TestAllPackages.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAllPackages.java,v 1.6 2003/11/16 00:05:47 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAllPackages.java,v 1.7 2003/11/16 20:35:46 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Entry point for all Collections project tests.\n  * \n- * @version $Revision: 1.6 $ $Date: 2003/11/16 00:05:47 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/16 20:35:46 $\n  * \n  * @author Stephen Colebourne\n  */\n         TestSuite suite = new TestSuite();\n         suite.addTest(org.apache.commons.collections.TestAll.suite());\n         suite.addTest(org.apache.commons.collections.bag.TestAll.suite());\n+        suite.addTest(org.apache.commons.collections.bidimap.TestAll.suite());\n         suite.addTest(org.apache.commons.collections.buffer.TestAll.suite());\n         suite.addTest(org.apache.commons.collections.comparators.TestAll.suite());\n         suite.addTest(org.apache.commons.collections.collection.TestAll.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/AbstractTestBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/AbstractTestBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.AbstractTestMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+import org.apache.commons.collections.iterators.MapIterator;\n+\n+/**\n+ * Abstract test class for {@link BidiMap} methods and contracts.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestBidiMap extends AbstractTestMap {\n+\n+    // Test data.\n+    private static final Object[][] entriesKV =\n+        new Object[][] {\n+            new Object[] { \"key1\", \"value1\" },\n+            new Object[] { \"key2\", \"value2\" },\n+            new Object[] { \"key3\", \"value3\" }\n+    };\n+    private static final Object[][] entriesVK =\n+        new Object[][] {\n+            new Object[] { \"value1\", \"key1\" },\n+            new Object[] { \"value2\", \"key2\" },\n+            new Object[] { \"value3\", \"key3\" }\n+    };\n+    private final Object[][] entries;\n+\n+    public AbstractTestBidiMap(String testName) {\n+        super(testName);\n+        entries = entriesKV;\n+    }\n+\n+    public AbstractTestBidiMap() {\n+        super(\"Inverse\");\n+        entries = entriesVK;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement to create an empty <code>BidiMap</code>.\n+     * \n+     * @return an empty <code>BidiMap</code> implementation.\n+     */\n+    protected abstract BidiMap makeEmptyBidiMap();\n+\n+    /**\n+     * Override to create a full <code>BidiMap</code> other than the default.\n+     * \n+     * @return a full <code>BidiMap</code> implementation.\n+     */\n+    protected BidiMap makeFullBidiMap() {\n+        final BidiMap map = makeEmptyBidiMap();\n+        for (int i = 0; i < entries.length; i++) {\n+            map.put(entries[i][0], entries[i][1]);\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * Override to return the empty BidiMap.\n+     */\n+    protected final  Map makeEmptyMap() {\n+        return makeEmptyBidiMap();\n+    }\n+\n+    /**\n+     * Override to indicate to AbstractTestMap this is a BidiMap.\n+     */\n+    protected boolean isAllowDuplicateValues() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Override as DualHashBidiMap didn't exist until version 3.\n+     */\n+    protected String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    // BidiPut\n+    //-----------------------------------------------------------------------\n+    public void testBidiPut() {\n+        BidiMap map = makeEmptyBidiMap();\n+        BidiMap inverse = map.inverseBidiMap();\n+        assertEquals(0, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        \n+        map.put(\"A\", \"B\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"B\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"B\"));\n+        \n+        map.put(\"A\", \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"C\"));\n+        \n+        map.put(\"B\", \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"B\"));\n+        assertEquals(\"B\", inverse.get(\"C\"));\n+        \n+        map.put(\"E\", \"F\");\n+        assertEquals(2, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"F\", map.get(\"E\"));\n+        assertEquals(\"E\", inverse.get(\"F\"));\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * <p>\n+     * This implementation checks the inverse map as well.\n+     */\n+    protected void verify() {\n+        verifyInverse();\n+        super.verify();\n+    }\n+\n+    protected void verifyInverse() {\n+        assertEquals(map.size(), ((BidiMap) map).inverseBidiMap().size());\n+        Map map1 = new HashMap(map);\n+        Map map2 = new HashMap(((BidiMap) map).inverseBidiMap());\n+        Set keys1 = map1.keySet();\n+        Set keys2 = map2.keySet();\n+        Collection values1 = map1.values();\n+        Collection values2 = map2.values();\n+        assertEquals(true, keys1.containsAll(values2));\n+        assertEquals(true, values2.containsAll(keys1));\n+        assertEquals(true, values1.containsAll(keys2));\n+        assertEquals(true, keys2.containsAll(values1));\n+    }\n+    \n+    // testGetKey\n+    //-----------------------------------------------------------------------\n+    public void testBidiGetKey() {\n+        doTestGetKey(makeFullBidiMap(), entries[0][0], entries[0][1]);\n+    }\n+\n+    public void testBidiGetKeyInverse() {\n+        doTestGetKey(\n+            makeFullBidiMap().inverseBidiMap(),\n+            entries[0][1],\n+            entries[0][0]);\n+    }\n+\n+    private final void doTestGetKey(BidiMap map, Object key, Object value) {\n+        assertEquals(\"Value not found for key.\", value, map.get(key));\n+        assertEquals(\"Key not found for value.\", key, map.getKey(value));\n+    }\n+\n+    // testInverse\n+    //-----------------------------------------------------------------------\n+    public void testBidiInverse() {\n+        final BidiMap map = makeFullBidiMap();\n+        final BidiMap inverseMap = map.inverseBidiMap();\n+\n+        assertSame(\n+            \"Inverse of inverse is not equal to original.\",\n+            map,\n+            inverseMap.inverseBidiMap());\n+\n+        assertEquals(\n+            \"Value not found for key.\",\n+            entries[0][0],\n+            inverseMap.get(entries[0][1]));\n+\n+        assertEquals(\n+            \"Key not found for value.\",\n+            entries[0][1],\n+            inverseMap.getKey(entries[0][0]));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiModifyEntrySet() {\n+        if (isSetValueSupported() == false) return;\n+        \n+        modifyEntrySet(makeFullBidiMap());\n+        modifyEntrySet(makeFullBidiMap().inverseBidiMap());\n+    }\n+\n+    private final void modifyEntrySet(BidiMap map) {\n+        // Gets first entry\n+        final Map.Entry entry = (Map.Entry)map.entrySet().iterator().next();\n+\n+        // Gets key and value\n+        final Object key = entry.getKey();\n+        final Object oldValue = entry.getValue();\n+\n+        // Sets new value\n+        final Object newValue = \"newValue\";\n+        entry.setValue(newValue);\n+\n+        assertEquals(\n+            \"Modifying entrySet did not affect underlying Map.\",\n+            newValue,\n+            map.get(key));\n+\n+        assertNull(\n+            \"Modifying entrySet did not affect inverse Map.\",\n+            map.getKey(oldValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClear() {\n+        BidiMap map = makeFullBidiMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+        // Tests clear on inverse\n+        map = makeFullBidiMap().inverseBidiMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemove() {\n+        remove(makeFullBidiMap(), entries[0][0]);\n+        remove(makeFullBidiMap().inverseBidiMap(), entries[0][1]);\n+\n+        removeValue(makeFullBidiMap(), entries[0][1]);\n+        removeValue(makeFullBidiMap().inverseBidiMap(), entries[0][0]);\n+    }\n+\n+    private final void remove(BidiMap map, Object key) {\n+        final Object value = map.remove(key);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    private final void removeValue(BidiMap map, Object value) {\n+        final Object key = map.removeValue(value);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiKeySetValuesOrder() {\n+        resetFull();\n+        Iterator keys = map.keySet().iterator();\n+        Iterator values = map.values().iterator();\n+        for (; keys.hasNext() && values.hasNext();) {\n+            Object key = keys.next();\n+            Object value = values.next();\n+            assertSame(map.get(key), value);\n+        }\n+        assertEquals(false, keys.hasNext());\n+        assertEquals(false, values.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByKeySet() {\n+        removeByKeySet(makeFullBidiMap(), entries[0][0], entries[0][1]);\n+        removeByKeySet(makeFullBidiMap().inverseBidiMap(), entries[0][1], entries[0][0]);\n+    }\n+\n+    private final void removeByKeySet(BidiMap map, Object key, Object value) {\n+        map.keySet().remove(key);\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByEntrySet() {\n+        removeByEntrySet(makeFullBidiMap(), entries[0][0], entries[0][1]);\n+        removeByEntrySet(makeFullBidiMap().inverseBidiMap(), entries[0][1], entries[0][0]);\n+    }\n+\n+    private final void removeByEntrySet(BidiMap map, Object key, Object value) {\n+        Map temp = new HashMap();\n+        temp.put(key, value);\n+        map.entrySet().remove(temp.entrySet().iterator().next());\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestBidiMapEntrySet();\n+    }\n+\n+    public class TestBidiMapEntrySet extends TestMapEntrySet {\n+        public TestBidiMapEntrySet() {\n+            super();\n+        }\n+        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n+            Object key1 = getSampleKeys()[0];\n+            Object key2 = getSampleKeys()[1];\n+            Object newValue1 = getNewSampleValues()[0];\n+            Object newValue2 = getNewSampleValues()[1];\n+                \n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator it = TestBidiMapEntrySet.this.collection.iterator();\n+            Map.Entry entry1 = getEntry(it, key1);\n+            it = TestBidiMapEntrySet.this.collection.iterator();\n+            Map.Entry entry2 = getEntry(it, key2);\n+            Iterator itConfirmed = TestBidiMapEntrySet.this.confirmed.iterator();\n+            Map.Entry entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestBidiMapEntrySet.this.confirmed.iterator();\n+            Map.Entry entryConfirmed2 = getEntry(itConfirmed, key2);\n+            TestBidiMapEntrySet.this.verify();\n+                \n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            // these checked in superclass                \n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+            \n+            // at this point\n+            // key1=newValue1, key2=newValue2\n+            try {\n+                entry2.setValue(newValue1);  // should remove key1\n+            } catch (IllegalArgumentException ex) {\n+                return;  // simplest way of dealing with tricky situation\n+            }\n+            entryConfirmed2.setValue(newValue1);\n+            AbstractTestBidiMap.this.confirmed.remove(key1);\n+            assertEquals(newValue1, entry2.getValue());\n+            assertEquals(true, AbstractTestBidiMap.this.map.containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractTestBidiMap.this.map.containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestBidiMap.this.map.get(entry2.getKey()));\n+            assertEquals(false, AbstractTestBidiMap.this.map.containsKey(key1));\n+            assertEquals(false, AbstractTestBidiMap.this.map.containsValue(newValue2));\n+            TestBidiMapEntrySet.this.verify();\n+            \n+            // check for ConcurrentModification\n+            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+            if (isRemoveSupported()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+        \n+    public BulkTest bulkTestInverseMap() {\n+        return new TestInverseBidiMap(this);\n+    }\n+\n+    public class TestInverseBidiMap extends AbstractTestBidiMap {\n+        final AbstractTestBidiMap main;\n+        \n+        public TestInverseBidiMap(AbstractTestBidiMap main) {\n+            super();\n+            this.main = main;\n+        }\n+        protected BidiMap makeEmptyBidiMap() {\n+            return main.makeEmptyBidiMap().inverseBidiMap();\n+        }\n+        protected BidiMap makeFullBidiMap() {\n+            return main.makeFullBidiMap().inverseBidiMap();\n+        }\n+        protected Object[] getSampleKeys() {\n+            return main.getSampleValues();\n+        }\n+        protected Object[] getSampleValues() {\n+            return main.getSampleKeys();\n+        }\n+        \n+        protected String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion();\n+        }\n+        protected boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+        protected boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+        protected boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+        protected boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+        protected boolean isSetValueSupported() {\n+            return main.isSetValueSupported();\n+        }\n+        protected boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestBidiMapIterator() {\n+        return new TestBidiMapIterator();\n+    }\n+    \n+    public class TestBidiMapIterator extends AbstractTestMapIterator {\n+        public TestBidiMapIterator() {\n+            super(\"TestBidiMapIterator\");\n+        }\n+        \n+        protected Object[] addSetValues() {\n+            return AbstractTestBidiMap.this.getNewSampleValues();\n+        }\n+        \n+        protected boolean supportsRemove() {\n+            return AbstractTestBidiMap.this.isRemoveSupported();\n+        }\n+\n+        protected boolean supportsSetValue() {\n+            return AbstractTestBidiMap.this.isSetValueSupported();\n+        }\n+\n+        protected MapIterator makeEmptyMapIterator() {\n+            resetEmpty();\n+            return ((BidiMap) AbstractTestBidiMap.this.map).mapIterator();\n+        }\n+\n+        protected MapIterator makeFullMapIterator() {\n+            resetFull();\n+            return ((BidiMap) AbstractTestBidiMap.this.map).mapIterator();\n+        }\n+        \n+        protected Map getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestBidiMap.this.map;\n+        }\n+        \n+        protected Map getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestBidiMap.this.confirmed;\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            AbstractTestBidiMap.this.verify();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testBidiMapIteratorSet() {\n+        Object newValue1 = getOtherValues()[0];\n+        Object newValue2 = getOtherValues()[1];\n+        \n+        resetFull();\n+        BidiMap bidi = (BidiMap) map;\n+        MapIterator it = bidi.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key1 = it.next();\n+        \n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+        \n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+        \n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+        \n+        Object key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, bidi.containsKey(key2));\n+        assertEquals(true, bidi.containsValue(newValue2));\n+        assertEquals(newValue2, bidi.get(key2));\n+        verify();\n+        \n+        // at this point\n+        // key1=newValue1, key2=newValue2\n+        try {\n+            it.setValue(newValue1);  // should remove key1\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            return;  // simplest way of dealing with tricky situation\n+        }\n+        confirmed.put(key2, newValue1);\n+        AbstractTestBidiMap.this.confirmed.remove(key1);\n+        assertEquals(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(it.getKey()));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(it.getKey()));\n+        assertEquals(false, bidi.containsKey(key1));\n+        assertEquals(false, bidi.containsValue(newValue2));\n+        verify();\n+            \n+        // check for ConcurrentModification\n+        it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+        if (isRemoveSupported()) {\n+            it.remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/AbstractTestOrderedBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/AbstractTestOrderedBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.iterators.OrderedMapIterator;\n+\n+/**\n+ * Abstract test class for {@link OrderedBidiMap} methods and contracts.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestOrderedBidiMap extends AbstractTestBidiMap {\n+\n+    public AbstractTestOrderedBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractTestOrderedBidiMap() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        try {\n+            bidi.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        resetFull();\n+        bidi = (OrderedBidiMap) map;\n+        Object confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, bidi.firstKey());\n+    }\n+    \n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        try {\n+            bidi.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        resetFull();\n+        bidi = (OrderedBidiMap) map;\n+        Object confirmedLast = null;\n+        for (Iterator it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, bidi.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        assertEquals(null, bidi.nextKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.nextKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+        \n+        resetFull();\n+        bidi = (OrderedBidiMap) map;\n+        Iterator it = confirmed.keySet().iterator();\n+        Object confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            Object confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.nextKey(confirmedLast));\n+        \n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.nextKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+    }\n+    \n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        assertEquals(null, bidi.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.previousKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+        \n+        resetFull();\n+        bidi = (OrderedBidiMap) map;\n+        List list = new ArrayList(confirmed.keySet());\n+        Collections.reverse(list);\n+        Iterator it = list.iterator();\n+        Object confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            Object confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.previousKey(confirmedLast));\n+        \n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.previousKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorOrder() {\n+        resetFull();\n+        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        List ordered = new ArrayList(map.keySet());\n+        List ordered2 = new ArrayList(map.keySet());\n+        assertEquals(\"KeySet iterator is not consistent\", ordered, ordered2);\n+        \n+        int i = 0;\n+        for (MapIterator it = bidi.mapIterator(); it.hasNext(); i++) {\n+            Object key = (Object) it.next();\n+            assertEquals(\"Inconsistent order\", ordered.get(i), key);\n+            assertEquals(\"Incorrect value for key\", bidi.get(key), it.getValue());\n+        }\n+        i = 0;\n+        OrderedMapIterator it = bidi.orderedMapIterator();\n+        for (; it.hasNext(); i++) {\n+            Object key = (Object) it.next();\n+            assertEquals(\"Inconsistent order\", ordered.get(i), key);\n+            assertEquals(\"Incorrect value for key\", bidi.get(key), it.getValue());\n+            assertEquals(true, it.hasPrevious());\n+        }\n+        i--;\n+        for (; it.hasPrevious(); i--) {\n+            Object key = (Object) it.previous();\n+            assertEquals(\"Inconsistent order\", ordered.get(i), key);\n+            assertEquals(\"Incorrect value for key\", bidi.get(key), it.getValue());\n+            assertEquals(true, it.hasNext());\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/AbstractTestSortedBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/AbstractTestSortedBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.AbstractTestSortedMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.pairs.DefaultMapEntry;\n+\n+/**\n+ * Abstract test class for {@link BidiMap} methods and contracts.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestSortedBidiMap extends AbstractTestOrderedBidiMap {\n+\n+    protected List sortedKeys = new ArrayList();\n+    protected List sortedValues = new ArrayList();\n+    protected SortedSet sortedNewValues = new TreeSet();\n+\n+    public AbstractTestSortedBidiMap(String testName) {\n+        super(testName);\n+        sortedKeys.addAll(Arrays.asList(getSampleKeys()));\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+        \n+        Map map = new TreeMap();\n+        for (int i = 0; i < getSampleKeys().length; i++) {\n+            map.put(getSampleKeys()[i], getSampleValues()[i]);\n+        }\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+        \n+        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+    }\n+\n+    public AbstractTestSortedBidiMap() {\n+        super();\n+        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+        \n+        Map map = new TreeMap();\n+        for (int i = 0; i < getSampleKeys().length; i++) {\n+            map.put(getSampleValues()[i], getSampleKeys()[i]);\n+        }\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+        \n+        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected boolean isAllowNullKey() {\n+        return false;\n+    }\n+    protected boolean isAllowNullValue() {\n+        return false;\n+    }\n+    protected Map makeConfirmedMap() {\n+        return new TreeMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiHeadMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object toKey = it.next();\n+        Object second = it.next();\n+        Object firstValue = sm.get(first);\n+        Object secondValue = sm.get(second);\n+        \n+        SortedMap head = sm.headMap(toKey);\n+        assertEquals(1, head.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, head.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(false, head.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(false, head.containsValue(secondValue));\n+    }\n+                \n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByHeadMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        Object firstValue = sm.get(first);\n+        Object secondValue = sm.get(second);\n+        Object toKeyValue = sm.get(toKey);\n+        \n+        SortedMap sub = sm.headMap(toKey);\n+        int size = sm.size();\n+        assertEquals(2, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        \n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+        \n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.headMap(toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.headMap(toKey);\n+        Set set = sub.entrySet();\n+        assertEquals(2, sub.size());\n+        assertEquals(2, set.size());\n+        \n+        Iterator it2 = set.iterator();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiTailMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object fromKey = it.next();\n+        Object second = it.next();\n+        Object firstValue = sm.get(first);\n+        Object fromKeyValue = sm.get(fromKey);\n+        Object secondValue = sm.get(second);\n+        \n+        SortedMap sub = sm.tailMap(fromKey);\n+        assertEquals(sm.size() - 1, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByTailMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object first = it.next();\n+        Object fromKey = it.next();\n+        Object second = it.next();\n+        \n+        Object firstValue = sm.get(first);\n+        Object fromKeyValue = sm.get(fromKey);\n+        Object secondValue = sm.get(second);\n+        \n+        SortedMap sub = sm.tailMap(fromKey);\n+        int size = sm.size();\n+        assertEquals(size - 3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(3, sm.size());\n+        assertEquals(3, sm.inverseBidiMap().size());\n+        \n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+        \n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------                \n+    public void testBidiRemoveByTailMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.tailMap(fromKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.tailMap(fromKey);\n+        Set set = sub.entrySet();\n+        Iterator it2 = set.iterator();\n+        Object fromEntry = it2.next();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiSubMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object fromKey = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        Object third = it.next();\n+        Object firstValue = sm.get(first);\n+        Object fromKeyValue = sm.get(fromKey);\n+        Object secondValue = sm.get(second);\n+        Object thirdValue = sm.get(third);\n+        \n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+        assertEquals(true, sm.containsKey(third));\n+        assertEquals(false, sub.containsKey(third));\n+        assertEquals(true, sm.containsValue(thirdValue));\n+        assertEquals(false, sub.containsValue(thirdValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearBySubMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        Object fromKeyValue = sm.get(fromKey);\n+        Object firstValue = sm.get(first);\n+        Object secondValue = sm.get(second);\n+        Object toKeyValue = sm.get(toKey);\n+        \n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        int size = sm.size();\n+        assertEquals(3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 3, sm.size());\n+        assertEquals(size - 3, sm.inverseBidiMap().size());\n+        \n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+        \n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+        \n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        Set set = sub.entrySet();\n+        assertEquals(3, set.size());\n+        Iterator it2 = set.iterator();\n+        Object fromEntry = it2.next();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public BulkTest bulkTestHeadMap() {\n+        return new AbstractTestSortedMap.TestHeadMap(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new AbstractTestSortedMap.TestTailMap(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new AbstractTestSortedMap.TestSubMap(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/TestAll.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/TestAll.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Entry point for tests.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestAll extends TestCase {\n+    \n+    public TestAll(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestAll.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        \n+        suite.addTest(TestDualHashBidiMap.suite());\n+        suite.addTest(TestDualTreeBidiMap.suite());\n+        suite.addTest(TestTreeBidiMap.suite());\n+        \n+        return suite;\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/TestDualHashBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/TestDualHashBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class TestDualHashBidiMap extends AbstractTestBidiMap {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestDualHashBidiMap.class);\n+    }\n+\n+    public TestDualHashBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    protected BidiMap makeEmptyBidiMap() {\n+        return new DualHashBidiMap();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    protected String[] ignoredTests() {\n+        return new String[] {\"TestDualHashBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualHashBidiMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualHashBidiMap.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class TestDualTreeBidiMap extends AbstractTestSortedBidiMap {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestDualTreeBidiMap.class);\n+    }\n+\n+    public TestDualTreeBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    protected BidiMap makeEmptyBidiMap() {\n+        return new DualTreeBidiMap();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    protected String[] ignoredTests() {\n+        return new String[] {\"TestDualTreeBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/bidimap/TestTreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/bidimap/TestTreeBidiMap.java,v 1.1 2003/11/16 20:35:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/16 20:35:46 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestTreeBidiMap extends AbstractTestBidiMap {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTreeBidiMap.class);\n+    }\n+\n+    public TestTreeBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    protected BidiMap makeEmptyBidiMap() {\n+        return new TreeBidiMap();\n+    }\n+    \n+    protected Map makeConfirmedMap() {\n+        return new TreeMap();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    protected String[] ignoredTests() {\n+        return new String[] {\"TestTreeBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+    protected boolean isAllowNullKey() {\n+        return false;\n+    }\n+    \n+    protected boolean isAllowNullValue() {\n+        return false;\n+    }\n+    \n+    protected boolean isSetValueSupported() {\n+        return false;\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java,v 1.2 2003/11/08 18:46:57 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java,v 1.3 2003/11/16 20:35:47 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.BidiMap;\n-import org.apache.commons.collections.DualHashBidiMap;\n import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.bidimap.BidiMap;\n+import org.apache.commons.collections.bidimap.DualHashBidiMap;\n \n /**\n  * Tests the UnmodifiableMapIterator.\n  * \n- * @version $Revision: 1.2 $ $Date: 2003/11/08 18:46:57 $\n+ * @version $Revision: 1.3 $ $Date: 2003/11/16 20:35:47 $\n  * \n  * @author Stephen Colebourne\n  */", "timestamp": 1069014947, "metainfo": ""}