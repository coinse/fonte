{"sha": "de0d3728b0cecfa96ab688b2c1484ee95a12db69", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified in r738956, r471214 and/or r471578.    ", "commit": "\n--- a/src/java/org/apache/commons/collections/BidiMap.java\n+++ b/src/java/org/apache/commons/collections/BidiMap.java\n  * This is required so that \"inverting\" the map results in a map without \n  * duplicate keys. See the {@link #put} method description for more information.\n  *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface BidiMap extends IterableMap {\n+public interface BidiMap<K, V> extends IterableMap<K, V> {\n \n-    /**\n-     * Obtains a <code>MapIterator</code> over the map.\n-     * <p>\n-     * A map iterator is an efficient way of iterating over maps.\n-     * It does not require that the map is stored using Map Entry objects\n-     * which can increase performance.\n-     * <pre>\n-     * BidiMap map = new DualHashBidiMap();\n-     * MapIterator it = map.mapIterator();\n-     * while (it.hasNext()) {\n-     *   Object key = it.next();\n-     *   Object value = it.getValue();\n-     *   it.setValue(\"newValue\");\n-     * }\n-     * </pre>\n-     * \n-     * @return a map iterator\n-     */\n-    MapIterator mapIterator();\n-    \n     /**\n      * Puts the key-value pair into the map, replacing any previous pair.\n      * <p>\n      * @throws NullPointerException (optional) if the map limits the values to\n      *  non-null and null was specified\n      */\n-    Object put(Object key, Object value);\n-    \n+    V put(K key, V value);\n+\n     /**\n      * Gets the key that is currently mapped to the specified value.\n      * <p>\n      * @throws NullPointerException (optional) if the map limits the values to\n      *  non-null and null was specified\n      */\n-    Object getKey(Object value);\n-    \n+    K getKey(Object value);\n+\n     /**\n      * Removes the key-value pair that is currently mapped to the specified\n      * value (optional operation).\n      * @throws UnsupportedOperationException if this method is not supported\n      *  by the implementation\n      */\n-    Object removeValue(Object value);\n-    \n+    K removeValue(Object value);\n+\n     /**\n      * Gets a view of this map where the keys and values are reversed.\n      * <p>\n      *\n      * @return an inverted bidirectional map\n      */\n-    BidiMap inverseBidiMap();\n-    \n+    BidiMap<V, K> inverseBidiMap();\n+\n }\n--- a/src/java/org/apache/commons/collections/Buffer.java\n+++ b/src/java/org/apache/commons/collections/Buffer.java\n  * also implement {@link java.util.List}, {@link java.util.Set} or \n  * {@link Bag}.\n  *\n+ * @param <E> the type of the elements in the buffer\n  * @since Commons Collections 2.1\n  * @version $Revision$ $Date$\n  *\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  */\n-public interface Buffer extends Collection {\n+public interface Buffer<E> extends Collection<E> {\n \n     /**\n      * Gets and removes the next object from the buffer.\n      * @return the next object in the buffer, which is also removed\n      * @throws BufferUnderflowException if the buffer is already empty\n      */\n-    Object remove();\n+    E remove();\n \n     /**\n      * Gets the next object from the buffer without removing it.\n      * @return the next object in the buffer, which is not removed\n      * @throws BufferUnderflowException if the buffer is empty\n      */\n-    Object get();\n+    E get();\n \n }\n--- a/src/java/org/apache/commons/collections/KeyValue.java\n+++ b/src/java/org/apache/commons/collections/KeyValue.java\n  * key-value pair. This interface defines the minimum key value, with just the\n  * two get methods.\n  *\n+ * @param <K> the type of the key\n+ * @param <V> the type of the value\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface KeyValue {\n+public interface KeyValue<K, V> {\n \n     /**\n      * Gets the key from the pair.\n      *\n      * @return the key \n      */\n-    Object getKey();\n+    K getKey();\n \n     /**\n      * Gets the value from the pair.\n      *\n      * @return the value\n      */\n-    Object getValue();\n+    V getValue();\n \n }\n--- a/src/java/org/apache/commons/collections/OrderedBidiMap.java\n+++ b/src/java/org/apache/commons/collections/OrderedBidiMap.java\n  * Implementations should allow a value to be looked up from a key and\n  * a key to be looked up from a value with equal performance.\n  *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface OrderedBidiMap extends BidiMap, OrderedMap {\n+public interface OrderedBidiMap<K, V> extends BidiMap<K, V>, OrderedMap<K, V> {\n \n     /**\n      * Gets a view of this map where the keys and values are reversed.\n      *\n      * @return an inverted bidirectional map\n      */\n-    public BidiMap inverseBidiMap();\n-    \n-    /**\n-     * Gets a view of this map where the keys and values are reversed.\n-     * <p>\n-     * Changes to one map will be visible in the other and vice versa.\n-     * This enables both directions of the map to be accessed equally.\n-     * <p>\n-     * Implementations should seek to avoid creating a new object every time this\n-     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n-     * method on the inverse map should return the original.\n-     *\n-     * @return an inverted bidirectional map\n-     */\n-    public OrderedBidiMap inverseOrderedBidiMap();\n-    \n+    public OrderedBidiMap<V, K> inverseBidiMap();\n+\n }\n--- a/src/java/org/apache/commons/collections/OrderedMap.java\n+++ b/src/java/org/apache/commons/collections/OrderedMap.java\n  * Defines a map that maintains order and allows both forward and backward\n  * iteration through that order.\n  *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface OrderedMap extends IterableMap {\n-    \n+public interface OrderedMap<K, V> extends IterableMap<K, V> {\n+\n     /**\n      * Obtains an <code>OrderedMapIterator</code> over the map.\n      * <p>\n      * A ordered map iterator is an efficient way of iterating over maps\n      * in both directions.\n-     * <pre>\n-     * BidiMap map = new TreeBidiMap();\n-     * MapIterator it = map.mapIterator();\n-     * while (it.hasNext()) {\n-     *   Object key = it.next();\n-     *   Object value = it.getValue();\n-     *   it.setValue(\"newValue\");\n-     *   Object previousKey = it.previous();\n-     * }\n-     * </pre>\n      * \n      * @return a map iterator\n      */\n-    OrderedMapIterator orderedMapIterator();\n-    \n+    OrderedMapIterator<K, V> mapIterator();\n+\n     /**\n      * Gets the first key currently in this map.\n      *\n      * @return the first key currently in this map\n      * @throws java.util.NoSuchElementException if this map is empty\n      */\n-    public Object firstKey();\n+    public K firstKey();\n \n     /**\n      * Gets the last key currently in this map.\n      * @return the last key currently in this map\n      * @throws java.util.NoSuchElementException if this map is empty\n      */\n-    public Object lastKey();\n-    \n+    public K lastKey();\n+\n     /**\n      * Gets the next key after the one specified.\n      *\n      * @param key  the key to search for next from\n      * @return the next key, null if no match or at end\n      */\n-    public Object nextKey(Object key);\n+    public K nextKey(K key);\n \n     /**\n      * Gets the previous key before the one specified.\n      * @param key  the key to search for previous from\n      * @return the previous key, null if no match or at start\n      */\n-    public Object previousKey(Object key);\n-    \n+    public K previousKey(K key);\n+\n }\n--- a/src/java/org/apache/commons/collections/OrderedMapIterator.java\n+++ b/src/java/org/apache/commons/collections/OrderedMapIterator.java\n  */\n package org.apache.commons.collections;\n \n+import java.util.NoSuchElementException;\n+\n /**\n  * Defines an iterator that operates over an ordered <code>Map</code>.\n  * <p>\n  * This iterator allows both forward and reverse iteration through the map.\n- *  \n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface OrderedMapIterator extends MapIterator, OrderedIterator {\n-    \n+public interface OrderedMapIterator<K, V> extends MapIterator<K, V>, OrderedIterator<K> {\n+\n     /**\n      * Checks to see if there is a previous entry that can be iterated to.\n      *\n      * Gets the previous <em>key</em> from the <code>Map</code>.\n      *\n      * @return the previous key in the iteration\n-     * @throws java.util.NoSuchElementException if the iteration is finished\n+     * @throws NoSuchElementException if the iteration is finished\n      */\n-    Object previous();\n+    K previous();\n \n }\n--- a/src/java/org/apache/commons/collections/ResettableIterator.java\n+++ b/src/java/org/apache/commons/collections/ResettableIterator.java\n  * <p>\n  * This interface allows an iterator to be repeatedly reused.\n  *\n+ * @param <E> the type to iterate over\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface ResettableIterator extends Iterator {\n+public interface ResettableIterator<E> extends Iterator<E> {\n \n     /**\n      * Resets the iterator back to the position at which the iterator\n--- a/src/java/org/apache/commons/collections/SortedBag.java\n+++ b/src/java/org/apache/commons/collections/SortedBag.java\n  * Defines a type of <code>Bag</code> that maintains a sorted order among\n  * its unique representative members.\n  *\n+ * @param <E> the type to iterate over\n  * @since Commons Collections 2.0\n  * @version $Revision$ $Date$\n  *\n  * @author Chuck Burdick\n  */\n-public interface SortedBag extends Bag {\n+public interface SortedBag<E> extends Bag<E> {\n \n     /**\n      * Returns the comparator associated with this sorted set, or null\n      * \n      * @return the comparator in use, or null if natural ordering\n      */\n-    public Comparator comparator();\n+    public Comparator<? super E> comparator();\n \n     /**\n      * Returns the first (lowest) member.\n      * \n      * @return the first element in the sorted bag\n      */\n-    public Object first();\n+    public E first();\n \n     /**\n      * Returns the last (highest) member.\n      * \n      * @return the last element in the sorted bag\n      */\n-    public Object last();\n-    \n+    public E last();\n+\n }\n--- a/src/java/org/apache/commons/collections/SortedBidiMap.java\n+++ b/src/java/org/apache/commons/collections/SortedBidiMap.java\n  */\n package org.apache.commons.collections;\n \n+import java.util.Comparator;\n import java.util.SortedMap;\n \n /**\n  * Implementations should allow a value to be looked up from a key and\n  * a key to be looked up from a value with equal performance.\n  *  \n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public interface SortedBidiMap extends OrderedBidiMap, SortedMap {\n+public interface SortedBidiMap<K, V> extends OrderedBidiMap<K, V>, SortedMap<K, V> {\n \n     /**\n      * Gets a view of this map where the keys and values are reversed.\n      *\n      * @return an inverted bidirectional map\n      */\n-    public BidiMap inverseBidiMap();\n-    \n+    public SortedBidiMap<V, K> inverseBidiMap();\n+\n     /**\n-     * Gets a view of this map where the keys and values are reversed.\n-     * <p>\n-     * Changes to one map will be visible in the other and vice versa.\n-     * This enables both directions of the map to be accessed as a <code>SortedMap</code>.\n-     * <p>\n-     * Implementations should seek to avoid creating a new object every time this\n-     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n-     * method on the inverse map should return the original.\n-     * <p>\n-     * The inverse map returned by <code>inverseBidiMap()</code> should be the\n-     * same object as returned by this method.\n-     *\n-     * @return an inverted bidirectional map\n+     * Get the comparator used for the values in the value-to-key map aspect.\n+     * @return Comparator<? super V>\n      */\n-    public SortedBidiMap inverseSortedBidiMap();\n-    \n+    public Comparator<? super V> valueComparator();\n }\n--- a/src/test/org/apache/commons/collections/collection/AbstractTestCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/AbstractTestCollection.java\n  * Abstract test class for {@link java.util.Collection} methods and contracts.\n  * <p>\n  * You should create a concrete subclass of this class to test any custom\n- * {@link Collection} implementation.  At minimum, you'll have to \n- * implement the {@link #makeCollection()} method.  You might want to \n+ * {@link Collection} implementation.  At minimum, you'll have to\n+ * implement the {@link #makeCollection()} method.  You might want to\n  * override some of the additional public methods as well:\n  * <p>\n  * <b>Element Population Methods</b>\n  * <p>\n  * The {@link #collection} field holds an instance of your collection\n  * implementation; the {@link #confirmed} field holds an instance of the\n- * confirmed collection implementation.  The {@link #resetEmpty()} and \n+ * confirmed collection implementation.  The {@link #resetEmpty()} and\n  * {@link #resetFull()} methods set these fields to empty or full collections,\n  * so that tests can proceed from a known state.\n  * <p>\n  * views of a map, {@link AbstractTestMap} would override {@link #verify()} to make\n  * sure the map is changed after the collection view is changed.\n  * <p>\n- * If you're extending this class directly, you will have to provide \n+ * If you're extending this class directly, you will have to provide\n  * implementations for the following:\n  * <ul>\n  * <li>{@link #makeConfirmedCollection()}\n  * <li>{@link #makeConfirmedFullCollection()}\n  * </ul>\n  * <p>\n- * Those methods should provide a confirmed collection implementation \n+ * Those methods should provide a confirmed collection implementation\n  * that's compatible with your collection implementation.\n  * <p>\n  * If you're extending {@link AbstractTestList}, {@link AbstractTestSet},\n  * @author Neil O'Toole\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestCollection extends AbstractTestObject {\n+public abstract class AbstractTestCollection<E> extends AbstractTestObject {\n \n     //\n-    // NOTE: \n+    // NOTE:\n     //\n     // Collection doesn't define any semantics for equals, and recommends you\n     // use reference-based default behavior of Object.equals.  (And a test for\n     // tests on Collection.equals nor any for Collection.hashCode.\n     //\n \n-\n     // These fields are used by reset() and verify(), and any test\n     // method that tests a modification.\n \n-    /** \n+    /**\n      *  A collection instance that will be used for testing.\n      */\n-    public Collection collection;\n-\n-    /** \n+    private Collection<E> collection;\n+\n+    /**\n      *  Confirmed collection.  This is an instance of a collection that is\n      *  confirmed to conform exactly to the java.util.Collection contract.\n-     *  Modification operations are tested by performing a mod on your \n+     *  Modification operations are tested by performing a mod on your\n      *  collection, performing the exact same mod on an equivalent confirmed\n      *  collection, and then calling verify() to make sure your collection\n      *  still matches the confirmed collection.\n      */\n-    public Collection confirmed;\n+    private Collection<E> confirmed;\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractTestCollection(String testName) {\n      *  distinguishable with information not readily available.  That is, if a\n      *  particular value is to be removed from the collection, then there is\n      *  one and only one value that can be removed, even if there are other\n-     *  elements which are equal to it.  \n+     *  elements which are equal to it.\n      *\n      *  <P>In most collection cases, elements are not distinguishable (equal is\n      *  equal), thus this method defaults to return false.  In some cases,\n     }\n \n     /**\n-     *  Returns true if the collections produced by \n+     *  Returns true if the collections produced by\n      *  {@link #makeCollection()} and {@link #makeFullCollection()}\n      *  support the <code>add</code> and <code>addAll</code>\n      *  operations.<P>\n     }\n \n     /**\n-     *  Returns true if the collections produced by \n+     *  Returns true if the collections produced by\n      *  {@link #makeCollection()} and {@link #makeFullCollection()}\n      *  support the <code>remove</code>, <code>removeAll</code>,\n      *  <code>retainAll</code>, <code>clear</code> and\n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Verifies that {@link #collection} and {@link #confirmed} have \n+     *  Verifies that {@link #collection} and {@link #confirmed} have\n      *  identical state.\n      */\n     public void verify() {\n-        int confirmedSize = confirmed.size();\n-        assertEquals(\"Collection size should match confirmed collection's\",\n-                     confirmedSize, collection.size());\n-        assertEquals(\"Collection isEmpty() result should match confirmed \" +\n-                     \" collection's\", \n-                     confirmed.isEmpty(), collection.isEmpty());\n+        int confirmedSize = getConfirmed().size();\n+        assertEquals(\"Collection size should match confirmed collection's\", confirmedSize,\n+                getCollection().size());\n+        assertEquals(\"Collection isEmpty() result should match confirmed collection's\",\n+                getConfirmed().isEmpty(), getCollection().isEmpty());\n \n         // verify the collections are the same by attempting to match each\n         // object in the collection and confirmed collection.  To account for\n         // copy each collection value into an array\n         Object[] confirmedValues = new Object[confirmedSize];\n \n-        Iterator iter;\n-\n-        iter = confirmed.iterator(); \n+        Iterator<E> iter;\n+\n+        iter = getConfirmed().iterator();\n         int pos = 0;\n-        while(iter.hasNext()) {\n+        while (iter.hasNext()) {\n             confirmedValues[pos++] = iter.next();\n         }\n \n         // allocate an array of boolean flags for tracking values that have\n         // been matched once and only once.\n         boolean[] matched = new boolean[confirmedSize];\n-        \n+\n         // now iterate through the values of the collection and try to match\n         // the value with one in the confirmed array.\n-        iter = collection.iterator();\n-        while(iter.hasNext()) {\n+        iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n             Object o = iter.next();\n             boolean match = false;\n-            for(int i = 0; i < confirmedSize; i++) {\n-                if(matched[i]) {\n+            for (int i = 0; i < confirmedSize; i++) {\n+                if (matched[i]) {\n                     // skip values already matched\n                     continue;\n                 }\n-                if(o == confirmedValues[i] ||\n-                   (o != null && o.equals(confirmedValues[i]))) {\n+                if (o == confirmedValues[i] || (o != null && o.equals(confirmedValues[i]))) {\n                     // values matched\n                     matched[i] = true;\n                     match = true;\n                 }\n             }\n             // no match found!\n-            if(!match) {\n-                fail(\"Collection should not contain a value that the \" +\n-                     \"confirmed collection does not have: \" + o +\n-                     \"\\nTest: \" + collection + \"\\nReal: \" + confirmed);\n+            if (!match) {\n+                fail(\"Collection should not contain a value that the \"\n+                        + \"confirmed collection does not have: \" + o + \"\\nTest: \" + getCollection()\n+                        + \"\\nReal: \" + getConfirmed());\n             }\n         }\n-        \n+\n         // make sure there aren't any unmatched values\n-        for(int i = 0; i < confirmedSize; i++) {\n-            if(!matched[i]) {\n+        for (int i = 0; i < confirmedSize; i++) {\n+            if (!matched[i]) {\n                 // the collection didn't match all the confirmed values\n-                fail(\"Collection should contain all values that are in the confirmed collection\" +\n-                     \"\\nTest: \" + collection + \"\\nReal: \" + confirmed);\n+                fail(\"Collection should contain all values that are in the confirmed collection\"\n+                        + \"\\nTest: \" + getCollection() + \"\\nReal: \" + getConfirmed());\n             }\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n      *  test.\n      */\n     public void resetEmpty() {\n-        this.collection = makeCollection();\n-        this.confirmed = makeConfirmedCollection();\n+        this.setCollection(makeObject());\n+        this.setConfirmed(makeConfirmedCollection());\n     }\n \n     /**\n      *  test.\n      */\n     public void resetFull() {\n-        this.collection = makeFullCollection();\n-        this.confirmed = makeConfirmedFullCollection();\n+        this.setCollection(makeFullCollection());\n+        this.setConfirmed(makeConfirmedFullCollection());\n     }\n \n     //-----------------------------------------------------------------------\n      *\n      *  @return a confirmed empty collection\n      */\n-    public abstract Collection makeConfirmedCollection();\n+    public abstract Collection<E> makeConfirmedCollection();\n \n     /**\n      *  Returns a confirmed full collection.\n      *\n      *  @return a confirmed full collection\n      */\n-    public abstract Collection makeConfirmedFullCollection();\n+    public abstract Collection<E> makeConfirmedFullCollection();\n \n     /**\n      * Return a new, empty {@link Collection} to be used for testing.\n      */\n-    public abstract Collection makeCollection();\n+    public abstract Collection<E> makeObject();\n \n     /**\n      *  Returns a full collection to be used for testing.  The collection\n      *  the results of {@link #getFullElements()}.  Override this default\n      *  if your collection doesn't support addAll.\n      */\n-    public Collection makeFullCollection() {\n-        Collection c = makeCollection();\n+    public Collection<E> makeFullCollection() {\n+        Collection<E> c = makeObject();\n         c.addAll(Arrays.asList(getFullElements()));\n         return c;\n     }\n \n     /**\n-     *  Returns an empty collection for Object tests.\n-     */\n-    public Object makeObject() {\n-        return makeCollection();\n-    }\n-\n-    /**\n      * Creates a new Map Entry that is independent of the first and the map.\n      */\n-    public Map.Entry cloneMapEntry(Map.Entry entry) {\n-        HashMap map = new HashMap();\n+    public Map.Entry<E, E> cloneMapEntry(Map.Entry<E, E> entry) {\n+        HashMap<E, E> map = new HashMap<E, E>();\n         map.put(entry.getKey(), entry.getValue());\n-        return (Map.Entry) map.entrySet().iterator().next();\n+        return map.entrySet().iterator().next();\n     }\n \n     //-----------------------------------------------------------------------\n      *  Returns an array of objects that are contained in a collection\n      *  produced by {@link #makeFullCollection()}.  Every element in the\n      *  returned array <I>must</I> be an element in a full collection.<P>\n-     *  The default implementation returns a heterogenous array of \n+     *  The default implementation returns a heterogenous array of\n      *  objects with some duplicates. null is added if allowed.\n      *  Override if you require specific testing elements.  Note that if you\n      *  override {@link #makeFullCollection()}, you <I>must</I> override\n      *  this method to reflect the contents of a full collection.\n      */\n-    public Object[] getFullElements() {\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n         if (isNullSupported()) {\n-            ArrayList list = new ArrayList();\n+            ArrayList<E> list = new ArrayList<E>();\n             list.addAll(Arrays.asList(getFullNonNullElements()));\n             list.add(4, null);\n-            return list.toArray();\n-        } else {\n-            return (Object[]) getFullNonNullElements().clone();\n-        }\n+            return (E[]) list.toArray();\n+        }\n+        return getFullNonNullElements().clone();\n     }\n \n     /**\n      *  Returns an array of elements that are <I>not</I> contained in a\n-     *  full collection.  Every element in the returned array must \n+     *  full collection.  Every element in the returned array must\n      *  not exist in a collection returned by {@link #makeFullCollection()}.\n      *  The default implementation returns a heterogenous array of elements\n      *  without null.  Note that some of the tests add these elements\n      *  to an empty or full collection, so if your collection restricts\n      *  certain kinds of elements, you should override this method.\n      */\n-    public Object[] getOtherElements() {\n+    public E[] getOtherElements() {\n         return getOtherNonNullElements();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      *  Returns a list of elements suitable for return by\n      *  {@link #getFullElements()}.  The array returned by this method\n-     *  does not include null, but does include a variety of objects \n+     *  does not include null, but does include a variety of objects\n      *  of different types.  Override getFullElements to return\n      *  the results of this method if your collection does not support\n      *  the null element.\n      */\n-    public Object[] getFullNonNullElements() {\n-        return new Object[] {\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        return (E[]) new Object[] {\n             new String(\"\"),\n             new String(\"One\"),\n             new Integer(2),\n     }\n \n     /**\n-     *  Returns the default list of objects returned by \n+     *  Returns the default list of objects returned by\n      *  {@link #getOtherElements()}.  Includes many objects\n      *  of different types.\n      */\n-    public Object[] getOtherNonNullElements() {\n-        return new Object[] {\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        return (E[]) new Object[] {\n             new Integer(0),\n             new Float(0),\n             new Double(0),\n      */\n     public Object[] getFullNonNullStringElements() {\n         return new Object[] {\n-            \"If\",\"the\",\"dull\",\"substance\",\"of\",\"my\",\"flesh\",\"were\",\"thought\",\n-            \"Injurious\",\"distance\",\"could\",\"not\",\"stop\",\"my\",\"way\",\n+            \"If\", \"the\", \"dull\", \"substance\", \"of\", \"my\", \"flesh\", \"were\",\n+                \"thought\", \"Injurious\", \"distance\", \"could\", \"not\", \"stop\", \"my\", \"way\",\n         };\n     }\n \n      */\n     public Object[] getOtherNonNullStringElements() {\n         return new Object[] {\n-            \"For\",\"then\",\"despite\",/* of */\"space\",\"I\",\"would\",\"be\",\"brought\",\n-            \"From\",\"limits\",\"far\",\"remote\",\"where\",\"thou\",\"dost\",\"stay\"\n+            \"For\", \"then\", \"despite\",/* of */\"space\", \"I\", \"would\", \"be\",\n+                \"brought\", \"From\", \"limits\", \"far\", \"remote\", \"where\", \"thou\", \"dost\", \"stay\"\n         };\n     }\n \n-    // Tests    \n+    // Tests\n     //-----------------------------------------------------------------------\n     /**\n      *  Tests {@link Collection#add(Object)}.\n      */\n     public void testCollectionAdd() {\n         if (!isAddSupported()) return;\n-        \n-        Object[] elements = getFullElements();\n+\n+        E[] elements = getFullElements();\n         for (int i = 0; i < elements.length; i++) {\n             resetEmpty();\n-            boolean r = collection.add(elements[i]);\n-            confirmed.add(elements[i]);\n+            boolean r = getCollection().add(elements[i]);\n+            getConfirmed().add(elements[i]);\n             verify();\n             assertTrue(\"Empty collection changed after add\", r);\n-            assertEquals(\"Collection size is 1 after first add\", 1, collection.size());\n-        }\n-        \n+            assertEquals(\"Collection size is 1 after first add\", 1, getCollection().size());\n+        }\n+\n         resetEmpty();\n         int size = 0;\n         for (int i = 0; i < elements.length; i++) {\n-            boolean r = collection.add(elements[i]);\n-            confirmed.add(elements[i]);\n+            boolean r = getCollection().add(elements[i]);\n+            getConfirmed().add(elements[i]);\n             verify();\n             if (r) size++;\n-            assertEquals(\"Collection size should grow after add\", \n-                         size, collection.size());\n-            assertTrue(\"Collection should contain added element\",\n-                       collection.contains(elements[i]));\n-        }\n-    }\n-    \n-    \n+            assertEquals(\"Collection size should grow after add\", size, getCollection().size());\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(elements[i]));\n+        }\n+    }\n+\n     /**\n      *  Tests {@link Collection#addAll(Collection)}.\n      */\n         if (!isAddSupported()) return;\n \n         resetEmpty();\n-        Object[] elements = getFullElements();\n-        boolean r = collection.addAll(Arrays.asList(elements));\n-        confirmed.addAll(Arrays.asList(elements));\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Empty collection should change after addAll\", r);\n         for (int i = 0; i < elements.length; i++) {\n-            assertTrue(\"Collection should contain added element\",\n-                       collection.contains(elements[i]));\n-        }\n-\n-        resetFull();\n-        int size = collection.size();\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(elements[i]));\n+        }\n+\n+        resetFull();\n+        int size = getCollection().size();\n         elements = getOtherElements();\n-        r = collection.addAll(Arrays.asList(elements));\n-        confirmed.addAll(Arrays.asList(elements));\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Full collection should change after addAll\", r);\n         for (int i = 0; i < elements.length; i++) {\n             assertTrue(\"Full collection should contain added element\",\n-                       collection.contains(elements[i]));\n-        }\n-        assertEquals(\"Size should increase after addAll\", \n-                     size + elements.length, collection.size());\n-        \n-        resetFull();\n-        size = collection.size();\n-        r = collection.addAll(Arrays.asList(getFullElements()));\n-        confirmed.addAll(Arrays.asList(getFullElements()));\n+                    getCollection().contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\", size + elements.length, getCollection().size());\n+\n+        resetFull();\n+        size = getCollection().size();\n+        r = getCollection().addAll(Arrays.asList(getFullElements()));\n+        getConfirmed().addAll(Arrays.asList(getFullElements()));\n         verify();\n         if (r) {\n-            assertTrue(\"Size should increase if addAll returns true\", \n-                       size < collection.size());\n+            assertTrue(\"Size should increase if addAll returns true\", size < getCollection().size());\n         } else {\n-            assertEquals(\"Size should not change if addAll returns false\",\n-                         size, collection.size());\n-        } \n-    }\n-\n+            assertEquals(\"Size should not change if addAll returns false\", size, getCollection().size());\n+        }\n+    }\n \n     /**\n      *  If {@link #isAddSupported()} returns false, tests that add operations\n      */\n     public void testUnsupportedAdd() {\n         if (isAddSupported()) return;\n-        \n-        resetEmpty();\n-        try {\n-            collection.add(new Object());\n-            fail(\"Emtpy collection should not support add.\");\n+\n+        resetEmpty();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Empty collection should not support add.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n         verify();\n \n         try {\n-            collection.addAll(Arrays.asList(getFullElements()));\n-            fail(\"Emtpy collection should not support addAll.\");\n+            getCollection().addAll(Arrays.asList(getFullElements()));\n+            fail(\"Empty collection should not support addAll.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n \n         resetFull();\n         try {\n-            collection.add(new Object());\n+            getCollection().add(getFullNonNullElements()[0]);\n             fail(\"Full collection should not support add.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         // make sure things didn't change even if the expected exception was\n         // thrown.\n         verify();\n-        \n-        try {\n-            collection.addAll(Arrays.asList(getOtherElements()));\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n             fail(\"Full collection should not support addAll.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         verify();\n     }\n \n-\n     /**\n      *  Test {@link Collection#clear()}.\n      */\n         if (!isRemoveSupported()) return;\n \n         resetEmpty();\n-        collection.clear(); // just to make sure it doesn't raise anything\n-        verify();\n-\n-        resetFull();\n-        collection.clear();\n-        confirmed.clear();\n-        verify();\n-    }    \n-\n-    \n+        getCollection().clear(); // just to make sure it doesn't raise anything\n+        verify();\n+\n+        resetFull();\n+        getCollection().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n     /**\n      *  Tests {@link Collection#contains(Object)}.\n      */\n \n         resetEmpty();\n         elements = getFullElements();\n-        for(int i = 0; i < elements.length; i++) {\n+        for (int i = 0; i < elements.length; i++) {\n             assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n-                       !collection.contains(elements[i]));\n+                    !getCollection().contains(elements[i]));\n         }\n         // make sure calls to \"contains\" don't change anything\n         verify();\n \n         elements = getOtherElements();\n-        for(int i = 0; i < elements.length; i++) {\n+        for (int i = 0; i < elements.length; i++) {\n             assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n-                       !collection.contains(elements[i]));\n+                    !getCollection().contains(elements[i]));\n         }\n         // make sure calls to \"contains\" don't change anything\n         verify();\n \n         resetFull();\n         elements = getFullElements();\n-        for(int i = 0; i < elements.length; i++) {\n-            assertTrue(\"Full collection should contain element[\" + i + \"]\", \n-                       collection.contains(elements[i]));\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain element[\" + i + \"]\",\n+                    getCollection().contains(elements[i]));\n         }\n         // make sure calls to \"contains\" don't change anything\n         verify();\n \n         resetFull();\n         elements = getOtherElements();\n-        for(int i = 0; i < elements.length; i++) {\n-            assertTrue(\"Full collection shouldn't contain element\", \n-                       !collection.contains(elements[i]));\n-        }\n-    }\n-\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection shouldn't contain element\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+    }\n \n     /**\n      *  Tests {@link Collection#containsAll(Collection)}.\n      */\n     public void testCollectionContainsAll() {\n         resetEmpty();\n-        Collection col = new HashSet();\n+        Collection<E> col = new HashSet<E>();\n         assertTrue(\"Every Collection should contain all elements of an \" +\n-                   \"empty Collection.\", collection.containsAll(col));\n+                \"empty Collection.\", getCollection().containsAll(col));\n         col.addAll(Arrays.asList(getOtherElements()));\n         assertTrue(\"Empty Collection shouldn't contain all elements of \" +\n-                   \"a non-empty Collection.\", !collection.containsAll(col));\n+                \"a non-empty Collection.\", !getCollection().containsAll(col));\n         // make sure calls to \"containsAll\" don't change anything\n         verify();\n \n         resetFull();\n-        assertTrue(\"Full collection shouldn't contain other elements\", \n-                   !collection.containsAll(col));\n-        \n+        assertTrue(\"Full collection shouldn't contain other elements\",\n+                !getCollection().containsAll(col));\n+\n         col.clear();\n         col.addAll(Arrays.asList(getFullElements()));\n         assertTrue(\"Full collection should containAll full elements\",\n-                   collection.containsAll(col));\n+                getCollection().containsAll(col));\n         // make sure calls to \"containsAll\" don't change anything\n         verify();\n \n         int min = (getFullElements().length < 2 ? 0 : 2);\n-        int max = (getFullElements().length == 1 ? 1 : \n-                    (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n+        int max = (getFullElements().length == 1 ? 1 :\n+                (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n         col = Arrays.asList(getFullElements()).subList(min, max);\n-        assertTrue(\"Full collection should containAll partial full \" +\n-                   \"elements\", collection.containsAll(col));\n-        assertTrue(\"Full collection should containAll itself\", \n-                   collection.containsAll(collection));\n+        assertTrue(\"Full collection should containAll partial full elements\",\n+                getCollection().containsAll(col));\n+        assertTrue(\"Full collection should containAll itself\", getCollection().containsAll(getCollection()));\n         // make sure calls to \"containsAll\" don't change anything\n         verify();\n-        \n-        col = new ArrayList();\n+\n+        col = new ArrayList<E>();\n         col.addAll(Arrays.asList(getFullElements()));\n         col.addAll(Arrays.asList(getFullElements()));\n-        assertTrue(\"Full collection should containAll duplicate full \" +\n-                   \"elements\", collection.containsAll(col));\n+        assertTrue(\"Full collection should containAll duplicate full elements\",\n+                getCollection().containsAll(col));\n \n         // make sure calls to \"containsAll\" don't change anything\n         verify();\n      */\n     public void testCollectionIsEmpty() {\n         resetEmpty();\n-        assertEquals(\"New Collection should be empty.\", \n-                     true, collection.isEmpty());\n+        assertEquals(\"New Collection should be empty.\", true, getCollection().isEmpty());\n         // make sure calls to \"isEmpty() don't change anything\n         verify();\n \n         resetFull();\n-        assertEquals(\"Full collection shouldn't be empty\", \n-                     false, collection.isEmpty());\n+        assertEquals(\"Full collection shouldn't be empty\", false, getCollection().isEmpty());\n         // make sure calls to \"isEmpty() don't change anything\n         verify();\n     }\n \n-\n     /**\n      *  Tests the read-only functionality of {@link Collection#iterator()}.\n      */\n     public void testCollectionIterator() {\n         resetEmpty();\n-        Iterator it1 = collection.iterator();\n-        assertEquals(\"Iterator for empty Collection shouldn't have next.\",\n-                     false, it1.hasNext());\n+        Iterator<E> it1 = getCollection().iterator();\n+        assertEquals(\"Iterator for empty Collection shouldn't have next.\", false, it1.hasNext());\n         try {\n             it1.next();\n-            fail(\"Iterator at end of Collection should throw \" +\n-                 \"NoSuchElementException when next is called.\");\n-        } catch(NoSuchElementException e) {\n-            // expected\n-        } \n+            fail(\"Iterator at end of Collection should throw \"\n+                    + \"NoSuchElementException when next is called.\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n         // make sure nothing has changed after non-modification\n         verify();\n \n         resetFull();\n-        it1 = collection.iterator();\n-        for (int i = 0; i < collection.size(); i++) {\n-            assertTrue(\"Iterator for full collection should haveNext\", \n-                       it1.hasNext());\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            assertTrue(\"Iterator for full collection should haveNext\", it1.hasNext());\n             it1.next();\n         }\n         assertTrue(\"Iterator should be finished\", !it1.hasNext());\n-        \n-        ArrayList list = new ArrayList();\n-        it1 = collection.iterator();\n-        for (int i = 0; i < collection.size(); i++) {\n-            Object next = it1.next();\n-            assertTrue(\"Collection should contain element returned by \" +\n-                       \"its iterator\", collection.contains(next));\n+\n+        ArrayList<E> list = new ArrayList<E>();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            E next = it1.next();\n+            assertTrue(\"Collection should contain element returned by its iterator\",\n+                    getCollection().contains(next));\n             list.add(next);\n         }\n         try {\n             it1.next();\n-            fail(\"iterator.next() should raise NoSuchElementException \" +\n-                 \"after it finishes\");\n+            fail(\"iterator.next() should raise NoSuchElementException after it finishes\");\n         } catch (NoSuchElementException e) {\n             // expected\n         }\n         verify();\n     }\n \n-\n     /**\n      *  Tests removals from {@link Collection#iterator()}.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testCollectionIteratorRemove() {\n         if (!isRemoveSupported()) return;\n \n         resetEmpty();\n         try {\n-            collection.iterator().remove();\n+            getCollection().iterator().remove();\n             fail(\"New iterator.remove should raise IllegalState\");\n         } catch (IllegalStateException e) {\n             // expected\n         verify();\n \n         try {\n-            Iterator iter = collection.iterator();\n+            Iterator<E> iter = getCollection().iterator();\n             iter.hasNext();\n             iter.remove();\n-            fail(\"New iterator.remove should raise IllegalState \" +\n-                 \"even after hasNext\");\n+            fail(\"New iterator.remove should raise IllegalState even after hasNext\");\n         } catch (IllegalStateException e) {\n             // expected\n         }\n         verify();\n \n         resetFull();\n-        int size = collection.size();\n-        Iterator iter = collection.iterator();\n+        int size = getCollection().size();\n+        Iterator<E> iter = getCollection().iterator();\n         while (iter.hasNext()) {\n             Object o = iter.next();\n             // TreeMap reuses the Map Entry, so the verify below fails\n             // Clone it here if necessary\n             if (o instanceof Map.Entry) {\n-                o = cloneMapEntry((Map.Entry) o);\n+                o = cloneMapEntry((Map.Entry<E, E>) o);\n             }\n             iter.remove();\n \n             // contents are still the same.  Otherwise, we don't have the\n             // ability to distinguish the elements and determine which to\n             // remove from the confirmed collection (in which case, we don't\n-            // verify because we don't know how). \n+            // verify because we don't know how).\n             //\n             // see areEqualElementsDistinguishable()\n-            if(!areEqualElementsDistinguishable()) {\n-                confirmed.remove(o);\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(o);\n                 verify();\n             }\n \n             size--;\n-            assertEquals(\"Collection should shrink by one after \" +\n-                         \"iterator.remove\", size, collection.size());\n-        }\n-        assertTrue(\"Collection should be empty after iterator purge\",\n-                   collection.isEmpty());\n-        \n-        resetFull();\n-        iter = collection.iterator();\n+            assertEquals(\"Collection should shrink by one after iterator.remove\", size,\n+                    getCollection().size());\n+        }\n+        assertTrue(\"Collection should be empty after iterator purge\", getCollection().isEmpty());\n+\n+        resetFull();\n+        iter = getCollection().iterator();\n         iter.next();\n         iter.remove();\n         try {\n         }\n     }\n \n-\n     /**\n      *  Tests {@link Collection#remove(Object)}.\n      */\n         if (!isRemoveSupported()) return;\n \n         resetEmpty();\n-        Object[] elements = getFullElements();\n+        E[] elements = getFullElements();\n         for (int i = 0; i < elements.length; i++) {\n-            assertTrue(\"Shouldn't remove nonexistent element\", \n-                       !collection.remove(elements[i]));\n+            assertTrue(\"Shouldn't remove nonexistent element\", !getCollection().remove(elements[i]));\n             verify();\n         }\n-        \n-        Object[] other = getOtherElements();\n-        \n+\n+        E[] other = getOtherElements();\n+\n         resetFull();\n         for (int i = 0; i < other.length; i++) {\n-            assertTrue(\"Shouldn't remove nonexistent other element\", \n-                       !collection.remove(other[i]));\n+            assertTrue(\"Shouldn't remove nonexistent other element\", !getCollection().remove(other[i]));\n             verify();\n         }\n-        \n-        int size = collection.size();\n+\n+        int size = getCollection().size();\n         for (int i = 0; i < elements.length; i++) {\n             resetFull();\n             assertTrue(\"Collection should remove extant element: \" + elements[i],\n-                       collection.remove(elements[i]));\n+                    getCollection().remove(elements[i]));\n \n             // if the elements aren't distinguishable, we can just remove a\n             // matching element from the confirmed collection and verify\n             // contents are still the same.  Otherwise, we don't have the\n             // ability to distinguish the elements and determine which to\n             // remove from the confirmed collection (in which case, we don't\n-            // verify because we don't know how). \n+            // verify because we don't know how).\n             //\n             // see areEqualElementsDistinguishable()\n-            if(!areEqualElementsDistinguishable()) {\n-                confirmed.remove(elements[i]);\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(elements[i]);\n                 verify();\n             }\n \n-            assertEquals(\"Collection should shrink after remove\", \n-                         size - 1, collection.size());\n-        }\n-    }\n-    \n+            assertEquals(\"Collection should shrink after remove\", size - 1, getCollection().size());\n+        }\n+    }\n \n     /**\n      *  Tests {@link Collection#removeAll(Collection)}.\n         if (!isRemoveSupported()) return;\n \n         resetEmpty();\n-        assertTrue(\"Emtpy collection removeAll should return false for \" +\n-                   \"empty input\", \n-                   !collection.removeAll(Collections.EMPTY_SET));\n-        verify();\n-        \n-        assertTrue(\"Emtpy collection removeAll should return false for \" +\n-                   \"nonempty input\", \n-                   !collection.removeAll(new ArrayList(collection)));\n-        verify();\n-        \n-        resetFull();\n-        assertTrue(\"Full collection removeAll should return false for \" + \n-                   \"empty input\", \n-                   !collection.removeAll(Collections.EMPTY_SET));\n-        verify();\n-        \n-        assertTrue(\"Full collection removeAll should return false for other elements\", \n-                   !collection.removeAll(Arrays.asList(getOtherElements())));\n-        verify();\n-        \n-        assertTrue(\"Full collection removeAll should return true for full elements\", \n-                    collection.removeAll(new HashSet(collection)));\n-        confirmed.removeAll(new HashSet(confirmed));\n-        verify();\n-        \n-        resetFull();\n-        int size = collection.size();\n+        assertTrue(\"Empty collection removeAll should return false for empty input\",\n+                !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty collection removeAll should return false for nonempty input\",\n+                   !getCollection().removeAll(new ArrayList<E>(getCollection())));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection removeAll should return false for empty input\",\n+                   !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return false for other elements\",\n+                   !getCollection().removeAll(Arrays.asList(getOtherElements())));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return true for full elements\",\n+                getCollection().removeAll(new HashSet<E>(getCollection())));\n+        getConfirmed().removeAll(new HashSet<E>(getConfirmed()));\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n         int min = (getFullElements().length < 2 ? 0 : 2);\n-        int max = (getFullElements().length == 1 ? 1 : \n-                    (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n-        Collection all = Arrays.asList(getFullElements()).subList(min, max);\n-        assertTrue(\"Full collection removeAll should work\", \n-                   collection.removeAll(all));\n-        confirmed.removeAll(all);\n-        verify();\n-        \n-        assertTrue(\"Collection should shrink after removeAll\", \n-                   collection.size() < size);\n-        Iterator iter = all.iterator();\n+        int max = (getFullElements().length == 1 ? 1 :\n+                (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n+        Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection removeAll should work\", getCollection().removeAll(all));\n+        getConfirmed().removeAll(all);\n+        verify();\n+\n+        assertTrue(\"Collection should shrink after removeAll\", getCollection().size() < size);\n+        Iterator<E> iter = all.iterator();\n         while (iter.hasNext()) {\n             assertTrue(\"Collection shouldn't contain removed element\",\n-                       !collection.contains(iter.next()));\n-        }\n-    }\n-\n+                    !getCollection().contains(iter.next()));\n+        }\n+    }\n \n     /**\n      *  Tests {@link Collection#retainAll(Collection)}.\n         if (!isRemoveSupported()) return;\n \n         resetEmpty();\n-        List elements = Arrays.asList(getFullElements());\n-        List other = Arrays.asList(getOtherElements());\n-\n-        assertTrue(\"Empty retainAll() should return false\", \n-                   !collection.retainAll(Collections.EMPTY_SET));\n-        verify();\n-        \n-        assertTrue(\"Empty retainAll() should return false\", \n-                   !collection.retainAll(elements));\n-        verify();\n-        \n-        resetFull();\n-        assertTrue(\"Collection should change from retainAll empty\", \n-                   collection.retainAll(Collections.EMPTY_SET));\n-        confirmed.retainAll(Collections.EMPTY_SET);\n-        verify();\n-        \n-        resetFull();\n-        assertTrue(\"Collection changed from retainAll other\", \n-                   collection.retainAll(other));\n-        confirmed.retainAll(other);\n-        verify();\n-        \n-        resetFull();\n-        int size = collection.size();\n+        List<E> elements = Arrays.asList(getFullElements());\n+        List<E> other = Arrays.asList(getOtherElements());\n+\n+        assertTrue(\"Empty retainAll() should return false\",\n+                !getCollection().retainAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty retainAll() should return false\", !getCollection().retainAll(elements));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection should change from retainAll empty\",\n+                getCollection().retainAll(Collections.EMPTY_SET));\n+        getConfirmed().retainAll(Collections.EMPTY_SET);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection changed from retainAll other\", getCollection().retainAll(other));\n+        getConfirmed().retainAll(other);\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n         assertTrue(\"Collection shouldn't change from retainAll elements\",\n-                   !collection.retainAll(elements));\n-        verify();\n-        assertEquals(\"Collection size shouldn't change\", size, \n-                     collection.size());\n-        \n+                   !getCollection().retainAll(elements));\n+        verify();\n+        assertEquals(\"Collection size shouldn't change\", size, getCollection().size());\n+\n         if (getFullElements().length > 1) {\n             resetFull();\n-            size = collection.size();\n+            size = getCollection().size();\n             int min = (getFullElements().length < 2 ? 0 : 2);\n             int max = (getFullElements().length <= 5 ? getFullElements().length - 1 : 5);\n             assertTrue(\"Collection should changed by partial retainAll\",\n-                       collection.retainAll(elements.subList(min, max)));\n-            confirmed.retainAll(elements.subList(min, max));\n+                    getCollection().retainAll(elements.subList(min, max)));\n+            getConfirmed().retainAll(elements.subList(min, max));\n             verify();\n-        \n-            Iterator iter = collection.iterator();\n+\n+            Iterator<E> iter = getCollection().iterator();\n             while (iter.hasNext()) {\n-                assertTrue(\"Collection only contains retained element\", \n-                           elements.subList(min, max).contains(iter.next()));\n+                assertTrue(\"Collection only contains retained element\",\n+                        elements.subList(min, max).contains(iter.next()));\n             }\n         }\n-        \n-        resetFull();\n-        HashSet set = new HashSet(elements);\n-        size = collection.size();\n+\n+        resetFull();\n+        HashSet<E> set = new HashSet<E>(elements);\n+        size = getCollection().size();\n         assertTrue(\"Collection shouldn't change from retainAll without \" +\n-                   \"duplicate elements\", !collection.retainAll(set));\n+                   \"duplicate elements\", !getCollection().retainAll(set));\n         verify();\n         assertEquals(\"Collection size didn't change from nonduplicate \" +\n-                     \"retainAll\", size, collection.size());\n-    }\n-    \n-    \n+                     \"retainAll\", size, getCollection().size());\n+    }\n+\n     /**\n      *  Tests {@link Collection#size()}.\n      */\n     public void testCollectionSize() {\n         resetEmpty();\n-        assertEquals(\"Size of new Collection is 0.\", 0, collection.size());\n-\n-        resetFull();\n-        assertTrue(\"Size of full collection should be greater than zero\", \n-                   collection.size() > 0);\n-    }\n-\n+        assertEquals(\"Size of new Collection is 0.\", 0, getCollection().size());\n+\n+        resetFull();\n+        assertTrue(\"Size of full collection should be greater than zero\", getCollection().size() > 0);\n+    }\n \n     /**\n      *  Tests {@link Collection#toArray()}.\n     public void testCollectionToArray() {\n         resetEmpty();\n         assertEquals(\"Empty Collection should return empty array for toArray\",\n-                     0, collection.toArray().length);\n-\n-        resetFull();\n-        Object[] array = collection.toArray();\n-        assertEquals(\"Full collection toArray should be same size as \" +\n-                     \"collection\", array.length, collection.size());\n-        Object[] confirmedArray = confirmed.toArray();\n-        assertEquals(\"length of array from confirmed collection should \" +\n-                     \"match the length of the collection's array\", \n-                     confirmedArray.length, array.length);\n+                     0, getCollection().toArray().length);\n+\n+        resetFull();\n+        Object[] array = getCollection().toArray();\n+        assertEquals(\"Full collection toArray should be same size as collection\",\n+                array.length, getCollection().size());\n+        Object[] confirmedArray = getConfirmed().toArray();\n+        assertEquals(\"length of array from confirmed collection should \"\n+                + \"match the length of the collection's array\", confirmedArray.length, array.length);\n         boolean[] matched = new boolean[array.length];\n \n         for (int i = 0; i < array.length; i++) {\n             assertTrue(\"Collection should contain element in toArray\",\n-                       collection.contains(array[i]));\n+                    getCollection().contains(array[i]));\n \n             boolean match = false;\n             // find a match in the confirmed array\n-            for(int j = 0; j < array.length; j++) {\n+            for (int j = 0; j < array.length; j++) {\n                 // skip already matched\n-                if(matched[j]) continue;\n-                if(array[i] == confirmedArray[j] ||\n-                   (array[i] != null && array[i].equals(confirmedArray[j]))) {\n+                if (matched[j])\n+                    continue;\n+                if (array[i] == confirmedArray[j]\n+                        || (array[i] != null && array[i].equals(confirmedArray[j]))) {\n                     matched[j] = true;\n                     match = true;\n                     break;\n                 }\n             }\n-            if(!match) {\n-                fail(\"element \" + i + \" in returned array should be found \" +\n-                     \"in the confirmed collection's array\");\n+            if (!match) {\n+                fail(\"element \" + i + \" in returned array should be found \"\n+                        + \"in the confirmed collection's array\");\n             }\n         }\n-        for(int i = 0; i < matched.length; i++) {\n-            assertEquals(\"Collection should return all its elements in \" +\n-                         \"toArray\", true, matched[i]);\n-        }\n-    }\n-\n+        for (int i = 0; i < matched.length; i++) {\n+            assertEquals(\"Collection should return all its elements in \" + \"toArray\", true,\n+                    matched[i]);\n+        }\n+    }\n \n     /**\n      *  Tests {@link Collection#toArray(Object[])}.\n     public void testCollectionToArray2() {\n         resetEmpty();\n         Object[] a = new Object[] { new Object(), null, null };\n-        Object[] array = collection.toArray(a);\n+        Object[] array = getCollection().toArray(a);\n         assertEquals(\"Given array shouldn't shrink\", array, a);\n         assertNull(\"Last element should be set to null\", a[0]);\n         verify();\n \n         resetFull();\n         try {\n-            array = collection.toArray(new Void[0]);\n+            array = getCollection().toArray(new Void[0]);\n             fail(\"toArray(new Void[0]) should raise ArrayStore\");\n         } catch (ArrayStoreException e) {\n             // expected\n         verify();\n \n         try {\n-            array = collection.toArray(null);\n+            array = getCollection().toArray(null);\n             fail(\"toArray(null) should raise NPE\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n         verify();\n-        \n-        array = collection.toArray(new Object[0]);\n-        a = collection.toArray();\n-        assertEquals(\"toArrays should be equal\", \n+\n+        array = getCollection().toArray(new Object[0]);\n+        a = getCollection().toArray();\n+        assertEquals(\"toArrays should be equal\",\n                      Arrays.asList(array), Arrays.asList(a));\n \n         // Figure out if they're all the same class\n         // TODO: It'd be nicer to detect a common superclass\n-        HashSet classes = new HashSet();\n+        HashSet<Class<?>> classes = new HashSet<Class<?>>();\n         for (int i = 0; i < array.length; i++) {\n             classes.add((array[i] == null) ? null : array[i].getClass());\n         }\n         if (classes.size() > 1) return;\n-        \n-        Class cl = (Class)classes.iterator().next();\n+\n+        Class<?> cl = classes.iterator().next();\n         if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet\n             cl = Map.Entry.class;\n         }\n-        a = (Object[])Array.newInstance(cl, 0);\n-        array = collection.toArray(a);\n+        a = (Object[]) Array.newInstance(cl, 0);\n+        array = getCollection().toArray(a);\n         assertEquals(\"toArray(Object[]) should return correct array type\",\n-                     a.getClass(), array.getClass());\n-        assertEquals(\"type-specific toArrays should be equal\", \n-                     Arrays.asList(array), \n-                     Arrays.asList(collection.toArray()));\n-        verify();\n-    }\n-\n+                a.getClass(), array.getClass());\n+        assertEquals(\"type-specific toArrays should be equal\",\n+                Arrays.asList(array),\n+                Arrays.asList(getCollection().toArray()));\n+        verify();\n+    }\n \n     /**\n      *  Tests <code>toString</code> on a collection.\n      */\n     public void testCollectionToString() {\n         resetEmpty();\n-        assertTrue(\"toString shouldn't return null\", \n-                   collection.toString() != null);\n-\n-        resetFull();\n-        assertTrue(\"toString shouldn't return null\", \n-                   collection.toString() != null);\n-    }\n-\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+\n+        resetFull();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+    }\n \n     /**\n      *  If isRemoveSupported() returns false, tests to see that remove\n \n         resetEmpty();\n         try {\n-            collection.clear();\n+            getCollection().clear();\n             fail(\"clear should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         verify();\n \n         try {\n-            collection.remove(null);\n+            getCollection().remove(null);\n             fail(\"remove should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         verify();\n \n         try {\n-            collection.removeAll(null);\n+            getCollection().removeAll(null);\n             fail(\"removeAll should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         verify();\n \n         try {\n-            collection.retainAll(null);\n+            getCollection().retainAll(null);\n             fail(\"removeAll should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n \n         resetFull();\n         try {\n-            Iterator iterator = collection.iterator();\n+            Iterator<E> iterator = getCollection().iterator();\n             iterator.next();\n             iterator.remove();\n             fail(\"iterator.remove should raise UnsupportedOperationException\");\n \n     }\n \n-\n-    /**\n-     *  Tests that the collection's iterator is fail-fast.  \n+    /**\n+     *  Tests that the collection's iterator is fail-fast.\n      */\n     public void testCollectionIteratorFailFast() {\n         if (!isFailFastSupported()) return;\n-        \n+\n         if (isAddSupported()) {\n             resetFull();\n             try {\n-                Iterator iter = collection.iterator();\n-                Object o = getOtherElements()[0];\n-                collection.add(o);\n-                confirmed.add(o);\n+                Iterator<E> iter = getCollection().iterator();\n+                E o = getOtherElements()[0];\n+                getCollection().add(o);\n+                getConfirmed().add(o);\n                 iter.next();\n                 fail(\"next after add should raise ConcurrentModification\");\n             } catch (ConcurrentModificationException e) {\n                 // expected\n             }\n             verify();\n-            \n+\n             resetFull();\n             try {\n-                Iterator iter = collection.iterator();\n-                collection.addAll(Arrays.asList(getOtherElements()));\n-                confirmed.addAll(Arrays.asList(getOtherElements()));\n+                Iterator<E> iter = getCollection().iterator();\n+                getCollection().addAll(Arrays.asList(getOtherElements()));\n+                getConfirmed().addAll(Arrays.asList(getOtherElements()));\n                 iter.next();\n                 fail(\"next after addAll should raise ConcurrentModification\");\n             } catch (ConcurrentModificationException e) {\n \n         resetFull();\n         try {\n-            Iterator iter = collection.iterator();\n-            collection.clear();\n+            Iterator<E> iter = getCollection().iterator();\n+            getCollection().clear();\n             iter.next();\n             fail(\"next after clear should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n         } catch (NoSuchElementException e) {\n             // (also legal given spec)\n         }\n-        \n-        resetFull();\n-        try {\n-            Iterator iter = collection.iterator();\n-            collection.remove(getFullElements()[0]);\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            getCollection().remove(getFullElements()[0]);\n             iter.next();\n             fail(\"next after remove should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n \n         resetFull();\n         try {\n-            Iterator iter = collection.iterator();\n-            List sublist = Arrays.asList(getFullElements()).subList(2,5);\n-            collection.removeAll(sublist);\n+            Iterator<E> iter = getCollection().iterator();\n+            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().removeAll(sublist);\n             iter.next();\n             fail(\"next after removeAll should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n \n         resetFull();\n         try {\n-            Iterator iter = collection.iterator();\n-            List sublist = Arrays.asList(getFullElements()).subList(2,5);\n-            collection.retainAll(sublist);\n+            Iterator<E> iter = getCollection().iterator();\n+            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().retainAll(sublist);\n             iter.next();\n             fail(\"next after retainAll should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n     }\n \n     public void testSerializeDeserializeThenCompare() throws Exception {\n-        Object obj = makeCollection();\n+        Object obj = makeObject();\n         if (obj instanceof Serializable && isTestSerialization()) {\n             ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n             ObjectOutputStream out = new ObjectOutputStream(buffer);\n             }\n         }\n     }\n-    \n+\n+    public Collection<E> getCollection() {\n+        return collection;\n+    }\n+\n+    /**\n+     * Set the collection.\n+     * @param collection the Collection<E> to set\n+     */\n+    public void setCollection(Collection<E> collection) {\n+        this.collection = collection;\n+    }\n+\n+    public Collection<E> getConfirmed() {\n+        return confirmed;\n+    }\n+\n+    /**\n+     * Set the confirmed.\n+     * @param confirmed the Collection<E> to set\n+     */\n+    public void setConfirmed(Collection<E> confirmed) {\n+        this.confirmed = confirmed;\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#contains(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotCollectionContains(Collection<?> coll, Object element) {\n+        try {\n+            assertFalse(coll.contains(element));\n+        } catch (ClassCastException e) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotCollectionContainsAll(Collection<?> coll, Collection<?> sub) {\n+        try {\n+            assertFalse(coll.containsAll(sub));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#remove(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotRemoveFromCollection(Collection<?> coll, Object element) {\n+        try {\n+            assertFalse(coll.remove(element));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#removeAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotRemoveAllFromCollection(Collection<?> coll, Collection<?> sub) {\n+        try {\n+            assertFalse(coll.removeAll(sub));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n }\n--- a/src/test/org/apache/commons/collections/collection/TestPredicatedCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestPredicatedCollection.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.PredicateUtils;\n+import org.apache.commons.collections.functors.TruePredicate;\n \n /**\n  * Extension of {@link AbstractTestCollection} for exercising the \n  *\n  * @author Phil Steitz\n  */\n-public class TestPredicatedCollection extends AbstractTestCollection {\n+public class TestPredicatedCollection<E> extends AbstractTestCollection<E> {\n \n     public TestPredicatedCollection(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestPredicatedCollection.class);\n     }\n         String[] testCaseName = { TestPredicatedCollection.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n- \n+\n    //------------------------------------------------------------------------\n-        \n-    protected Predicate truePredicate = PredicateUtils.truePredicate();\n-    \n-    protected Collection decorateCollection(Collection collection, \n-        Predicate predicate) {\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected Collection<E> decorateCollection(\n+                Collection<E> collection, Predicate<E> predicate) {\n         return PredicatedCollection.decorate(collection, predicate);\n     }\n-    \n-    public Collection makeCollection() {\n-        return decorateCollection(new ArrayList(), truePredicate);\n+\n+    public Collection<E> makeObject() {\n+        return decorateCollection(new ArrayList<E>(), truePredicate);\n     }\n-    \n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n-    \n-    public Object[] getFullElements() {\n-        return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n     }\n-    \n-    public Collection makeFullCollection() {\n-        List list = new ArrayList();\n+\n+    public Collection<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return decorateCollection(list, truePredicate);\n     }\n-    \n-    public Collection makeConfirmedFullCollection() {\n-        List list = new ArrayList();\n+\n+    public Collection<E> makeConfirmedFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n \n- //-----------------------------------------------------------------\n-    protected Predicate testPredicate =  \n-        new Predicate() {\n-            public boolean evaluate(Object o) {\n+    //-----------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n                 return o instanceof String;\n             }\n         };\n-    \n-    public Collection makeTestCollection() {\n-        return decorateCollection(new ArrayList(), testPredicate);\n+\n+    public Collection<E> makeTestCollection() {\n+        return decorateCollection(new ArrayList<E>(), testPredicate);\n     }\n-     \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Collection c = makeTestCollection();\n+        Collection<E> c = makeTestCollection();\n         Integer i = new Integer(3);\n         try {\n-            c.add(i);\n+            c.add((E) i);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !c.contains(i));   \n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !c.contains(i));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        Collection c = makeTestCollection();\n-        List elements = new ArrayList();\n-        elements.add(\"one\");\n-        elements.add(\"two\");\n-        elements.add(new Integer(3));\n-        elements.add(\"four\");\n+        Collection<E> c = makeTestCollection();\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n         try {\n             c.addAll(elements);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !c.contains(\"one\"));   \n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !c.contains(\"two\"));   \n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !c.contains(new Integer(3)));   \n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !c.contains(\"four\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"one\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"two\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(new Integer(3)));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"four\"));\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/collection/TestSynchronizedCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestSynchronizedCollection.java\n import junit.framework.TestSuite;\n \n /**\n- * Extension of {@link AbstractTestCollection} for exercising the \n+ * Extension of {@link AbstractTestCollection} for exercising the\n  * {@link SynchronizedCollection} implementation.\n  *\n  * @since Commons Collections 3.1\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class TestSynchronizedCollection extends AbstractTestCollection {\n-    \n+public class TestSynchronizedCollection<E> extends AbstractTestCollection<E> {\n+\n     public TestSynchronizedCollection(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestSynchronizedCollection.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestSynchronizedCollection.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    //-----------------------------------------------------------------------    \n-    public Collection makeCollection() {\n-        return SynchronizedCollection.decorate(new ArrayList());\n-    }\n-    \n-    public Collection makeConfirmedCollection() {\n-        ArrayList list = new ArrayList();\n-        return list;\n+    //-----------------------------------------------------------------------\n+    public Collection<E> makeObject() {\n+        return SynchronizedCollection.decorate(new ArrayList<E>());\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        ArrayList list = new ArrayList();\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/org/apache/commons/collections/collection/TestTransformedCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestTransformedCollection.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedCollection extends AbstractTestCollection {\n+public class TestTransformedCollection extends AbstractTestCollection<Object> {\n     \n-    private static class StringToInteger implements Transformer {\n+    private static class StringToInteger implements Transformer<Object, Object> {\n         public Object transform(Object input) {\n             return new Integer((String) input);\n         }\n     }\n     \n-    public static final Transformer NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n-    public static final Transformer STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n+    public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n+    public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n \n     public TestTransformedCollection(String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+    public Collection<Object> makeConfirmedCollection() {\n+        return new ArrayList<Object>();\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        List list = new ArrayList();\n+    public Collection<Object> makeConfirmedFullCollection() {\n+        List<Object> list = new ArrayList<Object>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     \n-    public Collection makeCollection() {\n-        return TransformedCollection.decorate(new ArrayList(), NOOP_TRANSFORMER);\n+    public Collection<Object> makeObject() {\n+        return TransformedCollection.decorate(new ArrayList<Object>(), NOOP_TRANSFORMER);\n     }\n \n-    public Collection makeFullCollection() {\n-        List list = new ArrayList();\n+    public Collection<Object> makeFullCollection() {\n+        List<Object> list = new ArrayList<Object>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return TransformedCollection.decorate(list, NOOP_TRANSFORMER);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testTransformedCollection() {\n-        Collection coll = TransformedCollection.decorate(new ArrayList(), STRING_TO_INTEGER_TRANSFORMER);\n+        Collection<Object> coll = TransformedCollection.decorate(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, coll.size());\n         Object[] els = getFullElements();\n         for (int i = 0; i < els.length; i++) {\n--- a/src/test/org/apache/commons/collections/collection/TestUnmodifiableCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestUnmodifiableCollection.java\n import junit.framework.TestSuite;\n \n /**\n- * Extension of {@link AbstractTestCollection} for exercising the \n+ * Extension of {@link AbstractTestCollection} for exercising the\n  * {@link UnmodifiableCollection} implementation.\n  *\n  * @since Commons Collections 3.0\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableCollection extends AbstractTestCollection {\n-    \n+public class TestUnmodifiableCollection<E> extends AbstractTestCollection<E> {\n+\n     public TestUnmodifiableCollection(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableCollection.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableCollection.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    //-----------------------------------------------------------------------    \n-    public Collection makeCollection() {\n-        return UnmodifiableCollection.decorate(new ArrayList());\n+    //-----------------------------------------------------------------------\n+    public Collection<E> makeObject() {\n+        return UnmodifiableCollection.decorate(new ArrayList<E>());\n     }\n-    \n-    public Collection makeFullCollection() {\n-        List list = new ArrayList();\n+\n+    public Collection<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return UnmodifiableCollection.decorate(list);\n     }\n-    \n-    public Collection makeConfirmedCollection() {\n-        ArrayList list = new ArrayList();\n-        return list;\n+\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        ArrayList list = new ArrayList();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     public boolean isAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }", "timestamp": 1252993476, "metainfo": ""}