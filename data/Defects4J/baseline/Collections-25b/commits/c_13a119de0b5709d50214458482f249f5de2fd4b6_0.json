{"sha": "13a119de0b5709d50214458482f249f5de2fd4b6", "log": "Initial revision   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/CursorableLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CursorableLinkedList.java,v 1.1 2001/04/14 15:39:24 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/14 15:39:24 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+// to do: use weak references to cursors in case they aren't closed directly\n+\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.ConcurrentModificationException;\n+import java.util.NoSuchElementException;\n+import java.io.Serializable;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+\n+/**\n+ * A doubly-linked list implementation of the {@link List} interface,\n+ * supporting a {@link ListIterator} that allows concurrent modifications\n+ * to the underlying list.\n+ * <p>\n+ * Implements all of the optional {@link List} operations, the\n+ * stack/queue/dequeue operations available in {@link java.util.LinkedList}\n+ * and supports a {@link ListIterator} that allows concurrent modifications\n+ * to the underlying list (see {@link #cursor}).\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n+ *\n+ * @author Rodney Waldhoff\n+ * @version $Id: CursorableLinkedList.java,v 1.1 2001/04/14 15:39:24 rwaldhoff Exp $\n+ * @see java.util.LinkedList\n+ */\n+public class CursorableLinkedList implements List, Serializable {\n+\n+    //--- public methods ---------------------------------------------\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param o element to be appended to this list.\n+     * @return <tt>true</tt>\n+     */\n+    public boolean add(Object o) {\n+        insertListable(_head.prev(),null,o);\n+        return true;\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position in this list.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     *  elements to the right (adds one to their indices).\n+     *\n+     * @param index index at which the specified element is to be inserted.\n+     * @param element element to be inserted.\n+     *\n+     * @throws ClassCastException if the class of the specified element\n+     * \t\t  prevents it from being added to this list.\n+     * @throws IllegalArgumentException if some aspect of the specified\n+     *\t\t     element prevents it from being added to this list.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     *\t\t     (index &lt; 0 || index &gt; size()).\n+     */\n+    public void add(int index, Object element) {\n+        if(index == _size) {\n+            add(element);\n+        } else {\n+            Listable succ = (isEmpty() ? null : getListableAt(index));\n+            Listable pred = (null == succ ? null : succ.prev());\n+            insertListable(pred,succ,element);\n+        }\n+    }\n+\n+    /**\n+     * Appends all of the elements in the specified collection to the end of\n+     * this list, in the order that they are returned by the specified\n+     * {@link Collection}'s {@link Iterator}.  The behavior of this operation is\n+     * unspecified if the specified collection is modified while\n+     * the operation is in progress.  (Note that this will occur if the\n+     * specified collection is this list, and it's nonempty.)\n+     *\n+     * @param c collection whose elements are to be added to this list.\n+     * @return <tt>true</tt> if this list changed as a result of the call.\n+     *\n+     * @throws ClassCastException if the class of an element in the specified\n+     * \t     collection prevents it from being added to this list.\n+     * @throws IllegalArgumentException if some aspect of an element in the\n+     *         specified collection prevents it from being added to this\n+     *         list.\n+     */\n+    public boolean addAll(Collection c) {\n+        if(c.isEmpty()) {\n+            return false;\n+        }\n+        Iterator it = c.iterator();\n+        while(it.hasNext()) {\n+            insertListable(_head.prev(),null,it.next());\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Inserts all of the elements in the specified collection into this\n+     * list at the specified position.  Shifts the element currently at\n+     * that position (if any) and any subsequent elements to the right\n+     * (increases their indices).  The new elements will appear in this\n+     * list in the order that they are returned by the specified\n+     * {@link Collection}'s {@link Iterator}.  The behavior of this operation is\n+     * unspecified if the specified collection is modified while the\n+     * operation is in progress.  (Note that this will occur if the specified\n+     * collection is this list, and it's nonempty.)\n+     *\n+     * @param index index at which to insert first element from the specified\n+     *\t            collection.\n+     * @param c elements to be inserted into this list.\n+     * @return <tt>true</tt> if this list changed as a result of the call.\n+     *\n+     * @throws ClassCastException if the class of one of elements of the\n+     * \t\t   specified collection prevents it from being added to this\n+     * \t\t   list.\n+     * @throws IllegalArgumentException if some aspect of one of elements of\n+     *         the specified collection prevents it from being added to\n+     *         this list.\n+     * @throws IndexOutOfBoundsException if the index is out of range (index\n+     *\t      &lt; 0 || index &gt; size()).\n+     */\n+    public boolean addAll(int index, Collection c) {\n+        if(c.isEmpty()) {\n+            return false;\n+        } else if(_size == index || _size == 0) {\n+            return addAll(c);\n+        } else {\n+            Listable succ = getListableAt(index);\n+            Listable pred = (null == succ) ? null : succ.prev();\n+            Iterator it = c.iterator();\n+            while(it.hasNext()) {\n+                pred = insertListable(pred,succ,it.next());\n+            }\n+            return true;\n+        }\n+    }\n+\n+    /**\n+     * Inserts the specified element at the beginning of this list.\n+     * (Equivalent to {@link #add(int,java.lang.Object) <tt>add(0,o)</tt>}).\n+     *\n+     * @param o element to be prepended to this list.\n+     * @return <tt>true</tt>\n+     */\n+    public boolean addFirst(Object o) {\n+        insertListable(null,_head.next(),o);\n+        return true;\n+    }\n+\n+    /**\n+     * Inserts the specified element at the end of this list.\n+     * (Equivalent to {@link #add(java.lang.Object)}).\n+     *\n+     * @param o element to be appended to this list.\n+     * @return <tt>true</tt>\n+     */\n+    public boolean addLast(Object o) {\n+        insertListable(_head.prev(),null,o);\n+        return true;\n+    }\n+\n+    /**\n+     * Removes all of the elements from this list.  This\n+     * list will be empty after this call returns (unless\n+     * it throws an exception).\n+     */\n+    public void clear() {\n+        /*\n+        // this is the quick way, but would force us\n+        // to break all the cursors\n+        _modCount++;\n+        _head.setNext(null);\n+        _head.setPrev(null);\n+        _size = 0;\n+        */\n+        Iterator it = iterator();\n+        while(it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this list contains the specified element.\n+     * More formally, returns <tt>true</tt> if and only if this list contains\n+     * at least one element <tt>e</tt> such that\n+     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n+     *\n+     * @param o element whose presence in this list is to be tested.\n+     * @return <tt>true</tt> if this list contains the specified element.\n+     */\n+    public boolean contains(Object o) {\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            if((null == o && null == elt.value()) || (o.equals(elt.value()))) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this list contains all of the elements of the\n+     * specified collection.\n+     *\n+     * @param c collection to be checked for containment in this list.\n+     * @return <tt>true</tt> if this list contains all of the elements of the\n+     *         specified collection.\n+     */\n+    public boolean containsAll(Collection c) {\n+        Iterator it = c.iterator();\n+        while(it.hasNext()) {\n+            if(!this.contains(it.next())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a {@link ListIterator} for iterating through the\n+     * elements of this list. Unlike {@link #iterator}, a cursor\n+     * is not bothered by concurrent modifications to the\n+     * underlying list.\n+     * <p>\n+     * Specifically, when elements are added to the list before or\n+     * after the cursor, the cursor simply picks them up automatically.\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value--i.e., it cannot be removed).\n+     * <p>\n+     * Note that the returned {@link ListIterator} does not support the\n+     * {@link ListIterator#nextIndex} and {@link ListIterator#previousIndex}\n+     * methods (they throw {@link UnsupportedOperationException} when invoked.\n+     * <p>\n+     * Clients must close the cursor when they are done using it.\n+     * The returned {@link ListIterator} will be an instance of\n+     * {@link CursorableLinkedList.Cursor}.   To close the cursor,\n+     * cast the {@link ListIterator} to {@link CursorableLinkedList.Cursor}\n+     * and invoke the {@link CursorableLinkedList.Cursor#close} method.\n+     *\n+     * @see #cursor(int)\n+     * @see #listIterator\n+     * @see CursorableLinkedList.Cursor\n+     */\n+    public CursorableLinkedList.Cursor cursor() {\n+        return new Cursor(0);\n+    }\n+\n+    /**\n+     * Returns a {@link ListIterator} for iterating through the\n+     * elements of this list, initialized such that\n+     * {@link ListIterator#next} will return the element at\n+     * the specified index (if any) and {@link ListIterator#previous}\n+     * will return the element immediately preceeding it (if any).\n+     * Unlike {@link #iterator}, a cursor\n+     * is not bothered by concurrent modifications to the\n+     * underlying list.\n+     *\n+     * @see #cursor\n+     * @see #listIterator(int)\n+     * @see CursorableLinkedList.Cursor\n+     * @throws IndexOutOfBoundsException if the index is out of range (index\n+     *\t        &lt; 0 || index &gt; size()).\n+     */\n+    public CursorableLinkedList.Cursor cursor(int i) {\n+        return new Cursor(i);\n+    }\n+\n+    /**\n+     * Compares the specified object with this list for equality.  Returns\n+     * <tt>true</tt> if and only if the specified object is also a list, both\n+     * lists have the same size, and all corresponding pairs of elements in\n+     * the two lists are <i>equal</i>.  (Two elements <tt>e1</tt> and\n+     * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :\n+     * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n+     * equal if they contain the same elements in the same order.  This\n+     * definition ensures that the equals method works properly across\n+     * different implementations of the <tt>List</tt> interface.\n+     *\n+     * @param o the object to be compared for equality with this list.\n+     * @return <tt>true</tt> if the specified object is equal to this list.\n+     */\n+    public boolean equals(Object o) {\n+        if(o == this) {\n+            return true;\n+        } else if(!(o instanceof List)) {\n+            return false;\n+        }\n+        Iterator it = ((List)o).listIterator();\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            if(!it.hasNext() || (null == elt.value() ? null != it.next() : !(elt.value().equals(it.next()))) ) {\n+                return false;\n+            }\n+        }\n+        return !it.hasNext();\n+    }\n+\n+    /**\n+     * Returns the element at the specified position in this list.\n+     *\n+     * @param index index of element to return.\n+     * @return the element at the specified position in this list.\n+     *\n+     * @throws IndexOutOfBoundsException if the index is out of range (index\n+     * \t\t  &lt; 0 || index &gt;= size()).\n+     */\n+    public Object get(int index) {\n+        return getListableAt(index).value();\n+    }\n+\n+    /**\n+     * Returns the element at the beginning of this list.\n+     */\n+    public Object getFirst() {\n+        try {\n+            return _head.next().value();\n+        } catch(NullPointerException e) {\n+            throw new NoSuchElementException();\n+        }\n+    }\n+\n+    /**\n+     * Returns the element at the end of this list.\n+     */\n+    public Object getLast() {\n+        try {\n+            return _head.prev().value();\n+        } catch(NullPointerException e) {\n+            throw new NoSuchElementException();\n+        }\n+    }\n+\n+    /**\n+     * Returns the hash code value for this list.  The hash code of a list\n+     * is defined to be the result of the following calculation:\n+     * <pre>\n+     *  hashCode = 1;\n+     *  Iterator i = list.iterator();\n+     *  while (i.hasNext()) {\n+     *      Object obj = i.next();\n+     *      hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode());\n+     *  }\n+     * </pre>\n+     * This ensures that <tt>list1.equals(list2)</tt> implies that\n+     * <tt>list1.hashCode()==list2.hashCode()</tt> for any two lists,\n+     * <tt>list1</tt> and <tt>list2</tt>, as required by the general\n+     * contract of <tt>Object.hashCode</tt>.\n+     *\n+     * @return the hash code value for this list.\n+     * @see Object#hashCode()\n+     * @see Object#equals(Object)\n+     * @see #equals(Object)\n+     */\n+    public int hashCode() {\n+        int hash = 1;\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            hash = 31*hash + (null == elt.value() ? 0 : elt.value().hashCode());\n+        }\n+        return hash;\n+    }\n+\n+    /**\n+     * Returns the index in this list of the first occurrence of the specified\n+     * element, or -1 if this list does not contain this element.\n+     * More formally, returns the lowest index <tt>i</tt> such that\n+     * <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param o element to search for.\n+     * @return the index in this list of the first occurrence of the specified\n+     *         element, or -1 if this list does not contain this element.\n+     */\n+    public int indexOf(Object o) {\n+        int ndx = 0;\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            if(null == o && null == elt.value()) {\n+                return ndx;\n+            } else if(o.equals(elt.value())) {\n+                return ndx;\n+            }\n+            ndx++;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this list contains no elements.\n+     * @return <tt>true</tt> if this list contains no elements.\n+     */\n+    public boolean isEmpty() {\n+        return(0 == _size);\n+    }\n+\n+    /**\n+     * Returns a fail-fast iterator.\n+     * @see List#iterator\n+     */\n+    public Iterator iterator() {\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Returns the index in this list of the last occurrence of the specified\n+     * element, or -1 if this list does not contain this element.\n+     * More formally, returns the highest index <tt>i</tt> such that\n+     * <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param o element to search for.\n+     * @return the index in this list of the last occurrence of the specified\n+     * \t       element, or -1 if this list does not contain this element.\n+     */\n+    public int lastIndexOf(Object o) {\n+        int ndx = _size-1;\n+        for(Listable elt = _head.prev(), past = null; null != elt && past != _head.next(); elt = (past = elt).prev()) {\n+            if(null == o && null == elt.value()) {\n+                return ndx;\n+            } else if(o.equals(elt.value())) {\n+                return ndx;\n+            }\n+            ndx--;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns a fail-fast ListIterator.\n+     * @see List#listIterator\n+     */\n+    public ListIterator listIterator() {\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Returns a fail-fast ListIterator.\n+     * @see List#listIterator(int)\n+     */\n+    public ListIterator listIterator(int index) {\n+        if(index<0 || index > _size) {\n+            throw new IndexOutOfBoundsException(index + \" < 0 or > \" + _size);\n+        }\n+        return new ListIter(index);\n+    }\n+\n+    /**\n+     * Removes the first occurrence in this list of the specified element.\n+     * If this list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index i\n+     * such that <tt>(o==null ? get(i)==null : o.equals(get(i)))</tt> (if\n+     * such an element exists).\n+     *\n+     * @param o element to be removed from this list, if present.\n+     * @return <tt>true</tt> if this list contained the specified element.\n+     */\n+    public boolean remove(Object o) {\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            if(null == o && null == elt.value()) {\n+                removeListable(elt);\n+                return true;\n+            } else if(o.equals(elt.value())) {\n+                removeListable(elt);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this list (optional\n+     * operation).  Shifts any subsequent elements to the left (subtracts one\n+     * from their indices).  Returns the element that was removed from the\n+     * list.\n+     *\n+     * @param index the index of the element to removed.\n+     * @return the element previously at the specified position.\n+     *\n+     * @throws IndexOutOfBoundsException if the index is out of range (index\n+     *            &lt; 0 || index &gt;= size()).\n+     */\n+    public Object remove(int index) {\n+        Listable elt = getListableAt(index);\n+        Object ret = elt.value();\n+        removeListable(elt);\n+        return ret;\n+    }\n+\n+    /**\n+     * Removes from this list all the elements that are contained in the\n+     * specified collection.\n+     *\n+     * @param c collection that defines which elements will be removed from\n+     *          this list.\n+     * @return <tt>true</tt> if this list changed as a result of the call.\n+     */\n+    public boolean removeAll(Collection c) {\n+        if(0 == c.size() || 0 == _size) {\n+            return false;\n+        } else {\n+            boolean changed = false;\n+            Iterator it = iterator();\n+            while(it.hasNext()) {\n+                if(c.contains(it.next())) {\n+                    it.remove();\n+                    changed = true;\n+                }\n+            }\n+            return changed;\n+        }\n+    }\n+\n+    /**\n+     * Removes the first element of this list, if any.\n+     */\n+    public Object removeFirst() {\n+        if(_head.next() != null) {\n+            Object val = _head.next().value();\n+            removeListable(_head.next());\n+            return val;\n+        } else {\n+            throw new NoSuchElementException();\n+        }\n+    }\n+\n+    /**\n+     * Removes the last element of this list, if any.\n+     */\n+    public Object removeLast() {\n+        if(_head.prev() != null) {\n+            Object val = _head.prev().value();\n+            removeListable(_head.prev());\n+            return val;\n+        } else {\n+            throw new NoSuchElementException();\n+        }\n+    }\n+\n+    /**\n+     * Retains only the elements in this list that are contained in the\n+     * specified collection.  In other words, removes\n+     * from this list all the elements that are not contained in the specified\n+     * collection.\n+     *\n+     * @param c collection that defines which elements this set will retain.\n+     *\n+     * @return <tt>true</tt> if this list changed as a result of the call.\n+     */\n+    public boolean retainAll(Collection c) {\n+        boolean changed = false;\n+        Iterator it = iterator();\n+        while(it.hasNext()) {\n+            if(!c.contains(it.next())) {\n+                it.remove();\n+                changed = true;\n+            }\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Replaces the element at the specified position in this list with the\n+     * specified element.\n+     *\n+     * @param index index of element to replace.\n+     * @param element element to be stored at the specified position.\n+     * @return the element previously at the specified position.\n+     *\n+     * @throws ClassCastException if the class of the specified element\n+     * \t\t  prevents it from being added to this list.\n+     * @throws IllegalArgumentException if some aspect of the specified\n+     *\t        element prevents it from being added to this list.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     *\t\t     (index &lt; 0 || index &gt;= size()).\n+     */\n+    public Object set(int index, Object element) {\n+        Listable elt = getListableAt(index);\n+        Object val = elt.setValue(element);\n+        broadcastListableChanged(elt);\n+        return val;\n+    }\n+\n+    /**\n+     * Returns the number of elements in this list.\n+     * @return the number of elements in this list.\n+     */\n+    public int size() {\n+        return _size;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in proper\n+     * sequence.  Obeys the general contract of the {@link Collection#toArray} method.\n+     *\n+     * @return an array containing all of the elements in this list in proper\n+     *         sequence.\n+     */\n+    public Object[] toArray() {\n+        Object[] array = new Object[_size];\n+        int i = 0;\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            array[i++] = elt.value();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in proper\n+     * sequence; the runtime type of the returned array is that of the\n+     * specified array. Obeys the general contract of the\n+     * {@link Collection#toArray} method.\n+     *\n+     * @param a      the array into which the elements of this list are to\n+     *               be stored, if it is big enough; otherwise, a new array of the\n+     *               same runtime type is allocated for this purpose.\n+     * @return an array containing the elements of this list.\n+     * @exception ArrayStoreException\n+     *                   if the runtime type of the specified array\n+     *                   is not a supertype of the runtime type of every element in\n+     *                   this list.\n+     */\n+    public Object[] toArray(Object a[]) {\n+        if(a.length < _size) {\n+            a = (Object[])Array.newInstance(a.getClass().getComponentType(), _size);\n+        }\n+        int i = 0;\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            a[i++] = elt.value();\n+        }\n+        if(a.length > _size) {\n+            a[_size] = null; // should we null out the rest of the array also? java.util.LinkedList doesn't\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * Returns a {@link String} representation of this list, suitable for debugging.\n+     * @return a {@link String} representation of this list, suitable for debugging.\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"[\");\n+        for(Listable elt = _head.next(), past = null; null != elt && past != _head.prev(); elt = (past = elt).next()) {\n+            if(_head.next() != elt) {\n+                buf.append(\", \");\n+            }\n+            buf.append(elt.value());\n+        }\n+        buf.append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Returns a fail-fast sublist.\n+     * @see List#subList(int,int)\n+     */\n+    public List subList(int i, int j) {\n+        if(i < 0 || j > _size || i > j) {\n+            throw new IndexOutOfBoundsException();\n+        } else if(i == 0 && j == _size) {\n+            return this;\n+        } else {\n+            return new CursorableSubList(this,i,j);\n+        }\n+    }\n+\n+    //--- protected methods ------------------------------------------\n+\n+    /**\n+     * Inserts a new <i>value</i> into my\n+     * list, after the specified <i>before</i> element, and before the\n+     * specified <i>after</i> element\n+     *\n+     * @returns the newly created {@link CursorableLinkedList.Listable}\n+     */\n+    protected Listable insertListable(Listable before, Listable after, Object value) {\n+        _modCount++;\n+        _size++;\n+        Listable elt = new Listable(before,after,value);\n+        if(null != before) {\n+            before.setNext(elt);\n+        } else {\n+            _head.setNext(elt);\n+        }\n+\n+        if(null != after) {\n+            after.setPrev(elt);\n+        } else {\n+            _head.setPrev(elt);\n+        }\n+        broadcastListableInserted(elt);\n+        return elt;\n+    }\n+\n+    /**\n+     * Removes the given {@link CursorableLinkedList.Listable} from my list.\n+     */\n+    protected void removeListable(Listable elt) {\n+        _modCount++;\n+        _size--;\n+        if(_head.next() == elt) {\n+            _head.setNext(elt.next());\n+        }\n+        if(null != elt.next()) {\n+            elt.next().setPrev(elt.prev());\n+        }\n+        if(_head.prev() == elt) {\n+            _head.setPrev(elt.prev());\n+        }\n+        if(null != elt.prev()) {\n+            elt.prev().setNext(elt.next());\n+        }\n+        broadcastListableRemoved(elt);\n+    }\n+\n+    /**\n+     * Returns the {@link CursorableLinkedList.Listable} at the specified\n+     * index.\n+     * @throws IndexOutOfBoundsException if index is less than zero or\n+     *         greater than or equal to the size of this list.\n+     */\n+    protected Listable getListableAt(int index) {\n+        if(index < 0 || index >= _size) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+        if(index <=_size/2) {\n+            Listable elt = _head.next();\n+            for(int i = 0; i < index; i++) {\n+                elt = elt.next();\n+            }\n+            return elt;\n+        } else {\n+            Listable elt = _head.prev();\n+            for(int i = (_size-1); i > index; i--) {\n+                elt = elt.prev();\n+            }\n+            return elt;\n+        }\n+    }\n+\n+    /**\n+     * Registers a {@link CursorableLinkedList.Cursor} to be notified\n+     * of changes to this list.\n+     */\n+    protected void registerCursor(Cursor cur) {\n+        _cursors.add(cur);\n+    }\n+\n+    /**\n+     * Removes a {@link CursorableLinkedList.Cursor} from\n+     * the set of cursors to be notified of changes to this list.\n+     */\n+    protected void unregisterCursor(Cursor cur) {\n+        _cursors.remove(cur);\n+    }\n+\n+    /**\n+     * Informs all of my registerd cursors that they are now\n+     * invalid.\n+     */\n+    protected void invalidateCursors() {\n+        Iterator it = _cursors.iterator();\n+        while(it.hasNext()) {\n+            ((Cursor)it.next()).invalidate();\n+            it.remove();\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registerd cursors that the specified\n+     * element was changed.\n+     * @see #set(int,java.lang.Object)\n+     */\n+    protected void broadcastListableChanged(Listable elt) {\n+        Iterator it = _cursors.iterator();\n+        while(it.hasNext()) {\n+            ((Cursor)it.next()).listableChanged(elt);\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors tha the specifed\n+     * element was just removed from my list.\n+     */\n+    protected void broadcastListableRemoved(Listable elt) {\n+        Iterator it = _cursors.iterator();\n+        while(it.hasNext()) {\n+            ((Cursor)it.next()).listableRemoved(elt);\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors tha the specifed\n+     * element was just added to my list.\n+     */\n+    protected void broadcastListableInserted(Listable elt) {\n+        Iterator it = _cursors.iterator();\n+        while(it.hasNext()) {\n+            ((Cursor)it.next()).listableInserted(elt);\n+        }\n+    }\n+\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(_size);\n+        Listable cur = _head.next();\n+        while(cur != null) {\n+            out.writeObject(cur.value());\n+            cur = cur.next();\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        _size = 0;\n+        _head = new Listable(null,null,null);\n+        int size = in.readInt();\n+        for(int i=0;i<size;i++) {\n+            this.add(in.readObject());\n+        }\n+    }\n+\n+    //--- protected attributes ---------------------------------------\n+\n+    /** The number of elements in me. */\n+    transient protected int _size = 0;\n+\n+    /**\n+     * A sentry node.\n+     * <p>\n+     * <tt>_head.next()</tt> points to the first element in the list,\n+     * <tt>_head.prev()</tt> to the last. Note that it is possible for\n+     * <tt>_head.next().prev()</tt> and <tt>_head.prev().next()</tt> to be\n+     * non-null, as when I am a sublist for some larger list.\n+     * Use <tt>== _head.next()</tt> and <tt>== _head.prev()</tt> to determine\n+     * if a given {@link Listable} is the first or last element in the list.\n+     */\n+    transient protected Listable _head = new Listable(null,null,null);\n+\n+    /** Tracks the number of structural modifications to me. */\n+    protected int _modCount = 0;\n+\n+    /**\n+     * A list of the currently {@link CursorableLinkedList.Cursor}s currently\n+     * open in this list.\n+     */\n+    protected List _cursors = new ArrayList();\n+\n+    //--- inner classes ----------------------------------------------\n+\n+    class Listable implements Serializable {\n+        private Listable _prev = null;\n+        private Listable _next = null;\n+        private Object _val = null;\n+\n+        Listable(Listable prev, Listable next, Object val) {\n+            _prev = prev;\n+            _next = next;\n+            _val = val;\n+        }\n+\n+        Listable next() {\n+            return _next;\n+        }\n+\n+        Listable prev() {\n+            return _prev;\n+        }\n+\n+        Object value() {\n+            return _val;\n+        }\n+\n+        void setNext(Listable next) {\n+            _next = next;\n+        }\n+\n+        void setPrev(Listable prev) {\n+            _prev = prev;\n+        }\n+\n+        Object setValue(Object val) {\n+            Object temp = _val;\n+            _val = val;\n+            return temp;\n+        }\n+    }\n+\n+    class ListIter implements ListIterator {\n+        Listable _cur = null;\n+        Listable _lastReturned = null;\n+        int _expectedModCount = _modCount;\n+        int _nextIndex = 0;\n+\n+        ListIter(int index) {\n+            if(index == 0) {\n+                _cur = new Listable(null,_head.next(),null);\n+                _nextIndex = 0;\n+            } else if(index == _size) {\n+                _cur = new Listable(_head.prev(),null,null);\n+                _nextIndex = _size;\n+            } else {\n+                Listable temp = getListableAt(index);\n+                _cur = new Listable(temp.prev(),temp,null);\n+                _nextIndex = index;\n+            }\n+        }\n+\n+        public Object previous() {\n+            checkForComod();\n+            if(!hasPrevious()) {\n+                throw new NoSuchElementException();\n+            } else {\n+                Object ret = _cur.prev().value();\n+                _lastReturned = _cur.prev();\n+                _cur.setNext(_cur.prev());\n+                _cur.setPrev(_cur.prev().prev());\n+                _nextIndex--;\n+                return ret;\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            checkForComod();\n+            return(null != _cur.next() && _cur.prev() != _head.prev());\n+        }\n+\n+        public Object next() {\n+            checkForComod();\n+            if(!hasNext()) {\n+                throw new NoSuchElementException();\n+            } else {\n+                Object ret = _cur.next().value();\n+                _lastReturned = _cur.next();\n+                _cur.setPrev(_cur.next());\n+                _cur.setNext(_cur.next().next());\n+                _nextIndex++;\n+                return ret;\n+            }\n+        }\n+\n+        public int previousIndex() {\n+            checkForComod();\n+            if(!hasPrevious()) {\n+                return -1;\n+            }\n+            return _nextIndex-1;\n+        }\n+\n+        public boolean hasPrevious() {\n+            checkForComod();\n+            return(null != _cur.prev() && _cur.next() != _head.next());\n+        }\n+\n+        public void set(Object o) {\n+            checkForComod();\n+            try {\n+                _lastReturned.setValue(o);\n+            } catch(NullPointerException e) {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        public int nextIndex() {\n+            checkForComod();\n+            if(!hasNext()) {\n+                return size();\n+            }\n+            return _nextIndex;\n+        }\n+\n+        public void remove() {\n+            checkForComod();\n+            if(null == _lastReturned) {\n+                throw new IllegalStateException();\n+            } else {\n+                _cur.setNext(_lastReturned == _head.prev() ? null : _lastReturned.next());\n+                _cur.setPrev(_lastReturned == _head.next() ? null : _lastReturned.prev());\n+                removeListable(_lastReturned);\n+                _lastReturned = null;\n+                _nextIndex--;\n+                _expectedModCount++;\n+            }\n+        }\n+\n+        public void add(Object o) {\n+            checkForComod();\n+            _cur.setPrev(insertListable(_cur.prev(),_cur.next(),o));\n+            _lastReturned = null;\n+            _nextIndex++;\n+            _expectedModCount++;\n+        }\n+\n+        protected void checkForComod() {\n+            if(_expectedModCount != _modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+    }\n+\n+    public class Cursor extends ListIter implements ListIterator {\n+        boolean _valid = false;\n+\n+        Cursor(int index) {\n+            super(index);\n+            _valid = true;\n+            registerCursor(this);\n+        }\n+\n+        public int previousIndex() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int nextIndex() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void add(Object o) {\n+            checkForComod();\n+            Listable elt = insertListable(_cur.prev(),_cur.next(),o);\n+            _cur.setPrev(elt);\n+            _cur.setNext(elt.next());\n+            _lastReturned = null;\n+            _nextIndex++;\n+            _expectedModCount++;\n+        }\n+\n+        protected void listableRemoved(Listable elt) {\n+            if(null == _head.prev()) {\n+                _cur.setNext(null);\n+            } else if(_cur.next() == elt) {\n+                _cur.setNext(elt.next());\n+            }\n+            if(null == _head.next()) {\n+                _cur.setPrev(null);\n+            } else if(_cur.prev() == elt) {\n+                _cur.setPrev(elt.prev());\n+            }\n+            if(_lastReturned == elt) {\n+                _lastReturned = null;\n+            }\n+        }\n+\n+        protected void listableInserted(Listable elt) {\n+            if(null == _cur.next() && null == _cur.prev()) {\n+                _cur.setNext(elt);\n+            } else if(_cur.prev() == elt.prev()) {\n+                _cur.setNext(elt);\n+            }\n+            if(_cur.next() == elt.next()) {\n+                _cur.setPrev(elt);\n+            }\n+            if(_lastReturned == elt) {\n+                _lastReturned = null;\n+            }\n+        }\n+\n+        protected void listableChanged(Listable elt) {\n+            if(_lastReturned == elt) {\n+                _lastReturned = null;\n+            }\n+        }\n+\n+        protected void checkForComod() {\n+            if(!_valid) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        protected void invalidate() {\n+            _valid = false;\n+        }\n+\n+        public void close() {\n+            if(_valid) {\n+                _valid = false;\n+                unregisterCursor(this);\n+            }\n+        }\n+    }\n+\n+}\n+\n+class CursorableSubList extends CursorableLinkedList implements List {\n+\n+    //--- constructors -----------------------------------------------\n+\n+    CursorableSubList(CursorableLinkedList list, int from, int to) {\n+        if(0 > from || list.size() < to) {\n+            throw new IndexOutOfBoundsException();\n+        } else if(from > to) {\n+            throw new IllegalArgumentException();\n+        }\n+        _list = list;\n+        if(from < list.size()) {\n+            _head.setNext(_list.getListableAt(from));\n+            _pre = (null == _head.next()) ? null : _head.next().prev();\n+        } else {\n+            _pre = _list.getListableAt(from-1);\n+        }\n+        if(from == to) {\n+            _head.setNext(null);\n+            _head.setPrev(null);\n+            if(to < list.size()) {\n+                _post = _list.getListableAt(to);\n+            } else {\n+                _post = null;\n+            }\n+        } else {\n+            _head.setPrev(_list.getListableAt(to-1));\n+            _post = _head.prev().next();\n+        }\n+        _size = to - from;\n+        _modCount = _list._modCount;\n+    }\n+\n+    //--- public methods ------------------------------------------\n+\n+    public void clear() {\n+        checkForComod();\n+        Iterator it = iterator();\n+        while(it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+    }\n+\n+    public Iterator iterator() {\n+        checkForComod();\n+        return super.iterator();\n+    }\n+\n+    public int size() {\n+        checkForComod();\n+        return super.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        checkForComod();\n+        return super.isEmpty();\n+    }\n+\n+    public Object[] toArray() {\n+        checkForComod();\n+        return super.toArray();\n+    }\n+\n+    public Object[] toArray(Object a[]) {\n+        checkForComod();\n+        return super.toArray(a);\n+    }\n+\n+    public boolean contains(Object o) {\n+        checkForComod();\n+        return super.contains(o);\n+    }\n+\n+    public boolean remove(Object o) {\n+        checkForComod();\n+        return super.remove(o);\n+    }\n+\n+    public Object removeFirst() {\n+        checkForComod();\n+        return super.removeFirst();\n+    }\n+\n+    public Object removeLast() {\n+        checkForComod();\n+        return super.removeLast();\n+    }\n+\n+    public boolean addAll(Collection c) {\n+        checkForComod();\n+        return super.addAll(c);\n+    }\n+\n+    public boolean add(Object o) {\n+        checkForComod();\n+        return super.add(o);\n+    }\n+\n+    public boolean addFirst(Object o) {\n+        checkForComod();\n+        return super.addFirst(o);\n+    }\n+\n+    public boolean addLast(Object o) {\n+        checkForComod();\n+        return super.addLast(o);\n+    }\n+\n+    public boolean removeAll(Collection c) {\n+        checkForComod();\n+        return super.removeAll(c);\n+    }\n+\n+    public boolean containsAll(Collection c) {\n+        checkForComod();\n+        return super.containsAll(c);\n+    }\n+\n+    public boolean addAll(int index, Collection c) {\n+        checkForComod();\n+        return super.addAll(index,c);\n+    }\n+\n+    public int hashCode() {\n+        checkForComod();\n+        return super.hashCode();\n+    }\n+\n+    public boolean retainAll(Collection c) {\n+        checkForComod();\n+        return super.retainAll(c);\n+    }\n+\n+    public Object set(int index, Object element) {\n+        checkForComod();\n+        return super.set(index,element);\n+    }\n+\n+    public boolean equals(Object o) {\n+        checkForComod();\n+        return super.equals(o);\n+    }\n+\n+    public Object get(int index) {\n+        checkForComod();\n+        return super.get(index);\n+    }\n+\n+    public Object getFirst() {\n+        checkForComod();\n+        return super.getFirst();\n+    }\n+\n+    public Object getLast() {\n+        checkForComod();\n+        return super.getLast();\n+    }\n+\n+    public void add(int index, Object element) {\n+        checkForComod();\n+        super.add(index,element);\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        checkForComod();\n+        return super.listIterator(index);\n+    }\n+\n+    public Object remove(int index) {\n+        checkForComod();\n+        return super.remove(index);\n+    }\n+\n+    public int indexOf(Object o) {\n+        checkForComod();\n+        return super.indexOf(o);\n+    }\n+\n+    public int lastIndexOf(Object o) {\n+        checkForComod();\n+        return super.lastIndexOf(o);\n+    }\n+\n+    public ListIterator listIterator() {\n+        checkForComod();\n+        return super.listIterator();\n+    }\n+\n+    public List subList(int fromIndex, int toIndex) {\n+        checkForComod();\n+        return super.subList(fromIndex,toIndex);\n+    }\n+\n+    //--- protected methods ------------------------------------------\n+\n+    /**\n+     * Inserts a new <i>value</i> into my\n+     * list, after the specified <i>before</i> element, and before the\n+     * specified <i>after</i> element\n+     *\n+     * @returns the newly created {@link CursorableLinkedList.Listable}\n+     */\n+    protected Listable insertListable(Listable before, Listable after, Object value) {\n+        _modCount++;\n+        _size++;\n+        Listable elt = _list.insertListable((null == before ? _pre : before), (null == after ? _post : after),value);\n+        if(null == _head.next()) {\n+            _head.setNext(elt);\n+            _head.setPrev(elt);\n+        }\n+        if(before == _head.prev()) {\n+            _head.setPrev(elt);\n+        }\n+        if(after == _head.next()) {\n+            _head.setNext(elt);\n+        }\n+        broadcastListableInserted(elt);\n+        return elt;\n+    }\n+\n+    /**\n+     * Removes the given {@link CursorableLinkedList.Listable} from my list.\n+     */\n+    protected void removeListable(Listable elt) {\n+        _modCount++;\n+        _size--;\n+        if(_head.next() == elt && _head.prev() == elt) {\n+            _head.setNext(null);\n+            _head.setPrev(null);\n+        }\n+        if(_head.next() == elt) {\n+            _head.setNext(elt.next());\n+        }\n+        if(_head.prev() == elt) {\n+            _head.setPrev(elt.prev());\n+        }\n+        _list.removeListable(elt);\n+        broadcastListableRemoved(elt);\n+    }\n+\n+    /**\n+     * Test to see if my underlying list has been modified\n+     * by some other process.  If it has, throws a\n+     * {@link ConcurrentModificationException}, otherwise\n+     * quietly returns.\n+     *\n+     * @throws ConcurrentModificationException\n+     */\n+    protected void checkForComod() throws ConcurrentModificationException {\n+        if(_modCount != _list._modCount) {\n+            throw new ConcurrentModificationException();\n+        }\n+    }\n+\n+    //--- protected attributes ---------------------------------------\n+\n+    /** My underlying list */\n+    protected CursorableLinkedList _list = null;\n+\n+    /** The element in my underlying list preceding the first element in my list. */\n+    protected Listable _pre = null;\n+\n+    /** The element in my underlying list following the last element in my list. */\n+    protected Listable _post = null;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.1 2001/04/14 15:39:25 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/14 15:39:25 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.*;\n+\n+/**\n+ * @author Rodney Waldhoff\n+ * @version $Id: TestAll.java,v 1.1 2001/04/14 15:39:25 rwaldhoff Exp $\n+ */\n+public class TestAll extends TestCase {\n+    public TestAll(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.addTest(TestCursorableLinkedList.suite());\n+        return suite;\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestAll.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.1 2001/04/14 15:39:51 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/14 15:39:51 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.*;\n+import java.util.Collection;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * @author Rodney Waldhoff\n+ * @version $Id: TestCollection.java,v 1.1 2001/04/14 15:39:51 rwaldhoff Exp $\n+ */\n+public abstract class TestCollection extends TestCase {\n+    public TestCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    private Collection _collection = null;\n+\n+    protected void setCollection(Collection c) {\n+        _collection = c;\n+    }\n+\n+    // optional operation\n+    public void testCollectionAdd() {\n+        boolean added1 = false;\n+        try {\n+            added1 = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+\n+        boolean added2 = false;\n+        try {\n+            added2 = _collection.add(\"element2\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+    }\n+\n+    // optional operation\n+    public void testCollectionAddAll() {\n+        Collection col = new ArrayList();\n+        col.add(\"element1\");\n+        col.add(\"element2\");\n+        col.add(\"element3\");\n+        boolean added = false;\n+        try {\n+            added = _collection.addAll(col);\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.addAll should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+    }\n+\n+    // optional operation\n+    public void testCollectionClear() {\n+        boolean cleared = false;\n+        try {\n+            _collection.clear();\n+            cleared = true;\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.clear should only throw UnsupportedOperationException. Found \" + t.toString());\n+        }\n+\n+        if(cleared) {\n+            assert(\"After Collection.clear(), Collection.isEmpty() should be true.\",_collection.isEmpty());\n+        }\n+\n+        boolean added = false;\n+        try {\n+            added = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+\n+        if(added) {\n+            assert(\"After element is added, Collection.isEmpty() should be false.\",!_collection.isEmpty());\n+            boolean cleared2 = false;\n+            try {\n+                _collection.clear();\n+                cleared2 = true;\n+            } catch(UnsupportedOperationException e) {\n+                // ignored, must not be supported\n+            } catch(Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Collection.clear should only throw UnsupportedOperationException. Found \" + t.toString());\n+            }\n+            if(cleared2) {\n+                assert(\"After Collection.clear(), Collection.isEmpty() should be true.\",_collection.isEmpty());\n+            }\n+        }\n+    }\n+\n+    public void testCollectionContains() {\n+        boolean added1 = false;\n+        try {\n+            added1 = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        assert(\"If an element was added, it should be contained.\",added1 == _collection.contains(\"element1\"));\n+\n+        boolean added2 = false;\n+        try {\n+            added2 = _collection.add(\"element2\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        assert(\"If an element was added, it should be contained.\",added1 == _collection.contains(\"element1\"));\n+        assert(\"If an element was added, it should be contained.\",added2 == _collection.contains(\"element2\"));\n+    }\n+\n+    public void testCollectionContainsAll() {\n+        Collection col = new ArrayList();\n+        assert(\"Every Collection should contain all elements of an empty Collection.\",_collection.containsAll(col));\n+        col.add(\"element1\");\n+        assert(\"Empty Collection shouldn't contain all elements of a non-empty Collection.\",!_collection.containsAll(col));\n+\n+        boolean added1 = false;\n+        try {\n+            added1 = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        if(added1) {\n+            assert(\"Should contain all.\",_collection.containsAll(col));\n+        }\n+\n+        col.add(\"element2\");\n+        assert(\"Shouldn't contain all.\",!_collection.containsAll(col));\n+\n+        boolean added2 = false;\n+        try {\n+            added2 = _collection.add(\"element2\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        if(added1 && added2) {\n+            assert(\"Should contain all.\",_collection.containsAll(col));\n+        }\n+    }\n+\n+    public void testCollectionEquals() {\n+        assertEquals(\"A Collection should equal itself\",_collection,_collection);\n+        try {\n+            _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        assertEquals(\"A Collection should equal itself\",_collection,_collection);\n+        try {\n+            _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        assertEquals(\"A Collection should equal itself\",_collection,_collection);\n+    }\n+\n+    public void testCollectionHashCode() {\n+        assertEquals(\"A Collection's hashCode should equal itself\",_collection.hashCode(),_collection.hashCode());\n+    }\n+\n+    public void testCollectionIsEmpty() {\n+        assert(\"New Collection should be empty.\",_collection.isEmpty());\n+        boolean added = false;\n+        try {\n+            added = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        if(added) {\n+            assert(\"If an element was added, the Collection.isEmpty() should return false.\",!_collection.isEmpty());\n+        }\n+    }\n+\n+    public void testCollectionIterator() {\n+        Iterator it1 = _collection.iterator();\n+        assert(\"Iterator for empty Collection shouldn't have next.\",!it1.hasNext());\n+        try {\n+            it1.next();\n+            fail(\"Iterator at end of Collection should throw NoSuchElementException when next is called.\");\n+        } catch(NoSuchElementException e) {\n+            // expected\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.iterator.next() should only throw NoSuchElementException. Found \" + t.toString());\n+        }\n+\n+        boolean added = false;\n+        try {\n+            added = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        if(added) {\n+            Iterator it2 = _collection.iterator();\n+            assert(\"Iterator for non-empty Collection should have next.\",it2.hasNext());\n+            assertEquals(\"element1\",it2.next());\n+            assert(\"Iterator at end of Collection shouldn't have next.\",!it2.hasNext());\n+            try {\n+                it2.next();\n+                fail(\"Iterator at end of Collection should throw NoSuchElementException when next is called.\");\n+            } catch(NoSuchElementException e) {\n+                // expected\n+            } catch(Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Collection.iterator.next() should only throw NoSuchElementException. Found \" + t.toString());\n+            }\n+        }\n+    }\n+\n+    // optional operation\n+    public void testCollectionRemove() {\n+        boolean added = false;\n+        try {\n+            added = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+\n+        try {\n+            assert(\"Shouldn't be able to remove an element that wasn't added.\",!_collection.remove(\"element2\"));\n+        } catch(UnsupportedOperationException e) {\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.remove should only throw UnsupportedOperationException. Found \" + t.toString());\n+        }\n+\n+        try {\n+            assert(\"If added, should be removed by call to remove.\",added == _collection.remove(\"element1\"));\n+            assert(\"If removed, shouldn't be contained.\",!_collection.contains(\"element1\"));\n+        } catch(UnsupportedOperationException e) {\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.remove should only throw UnsupportedOperationException. Found \" + t.toString());\n+        }\n+    }\n+\n+    // optional operation\n+    public void testCollectionRemoveAll() {\n+        assert(\"Initial Collection is empty.\",_collection.isEmpty());\n+        try {\n+            _collection.removeAll(_collection);\n+        } catch(UnsupportedOperationException e) {\n+            // expected\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.removeAll should only throw UnsupportedOperationException. Found \" + t.toString());\n+        }\n+        assert(\"Collection is still empty.\",_collection.isEmpty());\n+\n+        boolean added = false;\n+        try {\n+            added = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        if(added) {\n+            assert(\"Collection is not empty.\",!_collection.isEmpty());\n+            try {\n+                _collection.removeAll(_collection);\n+                assert(\"Collection is empty.\",_collection.isEmpty());\n+            } catch(UnsupportedOperationException e) {\n+                // expected\n+            } catch(Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Collection.removeAll should only throw UnsupportedOperationException. Found \" + t.toString());\n+            }\n+        }\n+    }\n+\n+    // optional operation\n+    public void testCollectionRemoveAll2() {\n+        Collection col = new ArrayList();\n+        col.add(\"element1\");\n+        col.add(\"element2\");\n+        col.add(\"element3\");\n+        boolean added = false;\n+        try {\n+            added = _collection.addAll(col);\n+            if(added) {\n+                added = _collection.add(\"element0\");\n+            }\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.addAll should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        col.add(\"element4\");\n+        if(added) {\n+            assert(\"Collection is not empty.\",!_collection.isEmpty());\n+            try {\n+                assert(\"Should be changed\",_collection.removeAll(col));\n+                assert(\"Collection is not empty.\",!_collection.isEmpty());\n+                assert(\"Collection should contain element\",_collection.contains(\"element0\"));\n+                assert(\"Collection shouldn't contain removed element\",!_collection.contains(\"element1\"));\n+                assert(\"Collection shouldn't contain removed element\",!_collection.contains(\"element2\"));\n+                assert(\"Collection shouldn't contain removed element\",!_collection.contains(\"element3\"));\n+                assert(\"Collection shouldn't contain removed element\",!_collection.contains(\"element4\"));\n+            } catch(UnsupportedOperationException e) {\n+                // expected\n+            } catch(Throwable t) {\n+                t.printStackTrace();\n+                fail(\"Collection.removeAll should only throw UnsupportedOperationException. Found \" + t.toString());\n+            }\n+        }\n+    }\n+\n+    // optional operation\n+    public void testCollectionRetainAll() {\n+    }\n+\n+    public void testCollectionSize() {\n+        assertEquals(\"Size of new Collection is 0.\",0,_collection.size());\n+        boolean added = false;\n+        try {\n+            added = _collection.add(\"element1\");\n+        } catch(UnsupportedOperationException e) {\n+            // ignored, must not be supported\n+        } catch(ClassCastException e) {\n+            // ignored, type must not be supported\n+        } catch(IllegalArgumentException e) {\n+            // ignored, element must not be supported\n+        } catch(Throwable t) {\n+            t.printStackTrace();\n+            fail(\"Collection.add should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n+        }\n+        if(added) {\n+            assertEquals(\"If one element was added, the Collection.size() should be 1.\",1,_collection.size());\n+        }\n+    }\n+\n+    public void testCollectionToArray() {\n+    }\n+\n+    public void testCollectionToArray2() {\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestCursorableLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestCursorableLinkedList.java,v 1.1 2001/04/14 15:39:44 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/14 15:39:44 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.*;\n+import java.util.*;\n+\n+/**\n+ * @author Rodney Waldhoff\n+ * @version $Id: TestCursorableLinkedList.java,v 1.1 2001/04/14 15:39:44 rwaldhoff Exp $\n+ */\n+public class TestCursorableLinkedList extends TestList {\n+    public TestCursorableLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestCursorableLinkedList.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestCursorableLinkedList.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    private CursorableLinkedList list = null;\n+\n+    public void setUp() {\n+        list = new CursorableLinkedList();\n+        setList(list);\n+    }\n+\n+    public void testAdd() {\n+        assertEquals(\"[]\",list.toString());\n+        assert(list.add(new Integer(1)));\n+        assertEquals(\"[1]\",list.toString());\n+        assert(list.add(new Integer(2)));\n+        assertEquals(\"[1, 2]\",list.toString());\n+        assert(list.add(new Integer(3)));\n+        assertEquals(\"[1, 2, 3]\",list.toString());\n+        assert(list.addFirst(new Integer(0)));\n+        assertEquals(\"[0, 1, 2, 3]\",list.toString());\n+        assert(list.addLast(new Integer(4)));\n+        assertEquals(\"[0, 1, 2, 3, 4]\",list.toString());\n+        list.add(0,new Integer(-2));\n+        assertEquals(\"[-2, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(1,new Integer(-1));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(7,new Integer(5));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5]\",list.toString());\n+\n+        java.util.List list2 = new java.util.LinkedList();\n+        list2.add(\"A\");\n+        list2.add(\"B\");\n+        list2.add(\"C\");\n+\n+        assert(list.addAll(list2));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+        assert(list.addAll(3,list2));\n+        assertEquals(\"[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+    }\n+\n+    public void testClear() {\n+        assertEquals(0,list.size());\n+        assert(list.isEmpty());\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assert(list.isEmpty());\n+\n+        list.add(\"element\");\n+        assertEquals(1,list.size());\n+        assert(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assert(list.isEmpty());\n+\n+        list.add(\"element1\");\n+        list.add(\"element2\");\n+        assertEquals(2,list.size());\n+        assert(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assert(list.isEmpty());\n+\n+        for(int i=0;i<1000;i++) {\n+            list.add(new Integer(i));\n+        }\n+        assertEquals(1000,list.size());\n+        assert(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assert(list.isEmpty());\n+    }\n+\n+    public void testContains() {\n+        assert(!list.contains(\"A\"));\n+        assert(list.add(\"A\"));\n+        assert(list.contains(\"A\"));\n+        assert(list.add(\"B\"));\n+        assert(list.contains(\"A\"));\n+        assert(list.addFirst(\"a\"));\n+        assert(list.contains(\"A\"));\n+        assert(list.remove(\"a\"));\n+        assert(list.contains(\"A\"));\n+        assert(list.remove(\"A\"));\n+        assert(!list.contains(\"A\"));\n+    }\n+\n+    public void testContainsAll() {\n+        assert(list.containsAll(list));\n+        java.util.List list2 = new java.util.LinkedList();\n+        assert(list.containsAll(list2));\n+        list2.add(\"A\");\n+        assert(!list.containsAll(list2));\n+        list.add(\"B\");\n+        list.add(\"A\");\n+        assert(list.containsAll(list2));\n+        list2.add(\"B\");\n+        assert(list.containsAll(list2));\n+        list2.add(\"C\");\n+        assert(!list.containsAll(list2));\n+        list.add(\"C\");\n+        assert(list.containsAll(list2));\n+        list2.add(\"C\");\n+        assert(list.containsAll(list2));\n+        assert(list.containsAll(list));\n+    }\n+\n+    public void testCursorNavigation() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        assert(it.hasNext());\n+        assert(!it.hasPrevious());\n+        assertEquals(\"1\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"1\",it.previous());\n+        assert(it.hasNext());\n+        assert(!it.hasPrevious());\n+        assertEquals(\"1\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"2\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"2\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"2\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"4\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"5\",it.next());\n+        assert(!it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"5\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"4\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"3\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"2\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(\"1\",it.previous());\n+        assert(it.hasNext());\n+        assert(!it.hasPrevious());\n+        it.close();\n+    }\n+\n+    public void testCursorSet() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        assertEquals(\"1\",it.next());\n+        it.set(\"a\");\n+        assertEquals(\"a\",it.previous());\n+        it.set(\"A\");\n+        assertEquals(\"A\",it.next());\n+        assertEquals(\"2\",it.next());\n+        it.set(\"B\");\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"4\",it.next());\n+        it.set(\"D\");\n+        assertEquals(\"5\",it.next());\n+        it.set(\"E\");\n+        assertEquals(\"[A, B, 3, D, E]\",list.toString());\n+        it.close();\n+    }\n+\n+    public void testCursorRemove() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\",it.next());\n+        assertEquals(\"2\",it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"3\",it.previous());\n+        assertEquals(\"1\",it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assert(!it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\",it.next());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[4]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+        it.close();\n+    }\n+\n+    public void testCursorAdd() {\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        it.add(\"1\");\n+        assertEquals(\"[1]\",list.toString());\n+        it.add(\"3\");\n+        assertEquals(\"[1, 3]\",list.toString());\n+        it.add(\"5\");\n+        assertEquals(\"[1, 3, 5]\",list.toString());\n+        assertEquals(\"5\",it.previous());\n+        it.add(\"4\");\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        assertEquals(\"3\",it.previous());\n+        it.add(\"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.close();\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        assert(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+        list.add(\"A\");\n+        assert(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+\n+        CursorableLinkedList list2 = new CursorableLinkedList();\n+        assert(!list.equals(list2));\n+        assert(!list2.equals(list));\n+\n+        java.util.List list3 = new java.util.LinkedList();\n+        assert(!list.equals(list3));\n+        assert(!list3.equals(list));\n+        assert(list2.equals(list3));\n+        assert(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list2.add(\"A\");\n+        assert(list.equals(list2));\n+        assert(list2.equals(list));\n+        assert(!list2.equals(list3));\n+        assert(!list3.equals(list2));\n+\n+        list3.add(\"A\");\n+        assert(list2.equals(list3));\n+        assert(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add(\"B\");\n+        assert(list.equals(list));\n+        assert(!list.equals(list2));\n+        assert(!list2.equals(list));\n+        assert(!list.equals(list3));\n+        assert(!list3.equals(list));\n+\n+        list2.add(\"B\");\n+        list3.add(\"B\");\n+        assert(list.equals(list));\n+        assert(list.equals(list2));\n+        assert(list2.equals(list));\n+        assert(list2.equals(list3));\n+        assert(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add(\"C\");\n+        list2.add(\"C\");\n+        list3.add(\"C\");\n+        assert(list.equals(list));\n+        assert(list.equals(list2));\n+        assert(list2.equals(list));\n+        assert(list2.equals(list3));\n+        assert(list3.equals(list2));\n+        assertEquals(list.hashCode(),list2.hashCode());\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add(\"D\");\n+        list2.addFirst(\"D\");\n+        assert(list.equals(list));\n+        assert(!list.equals(list2));\n+        assert(!list2.equals(list));\n+    }\n+\n+    public void testGet() {\n+        try {\n+            list.get(0);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        assert(list.add(\"A\"));\n+        assertEquals(\"A\",list.get(0));\n+        assert(list.add(\"B\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertEquals(\"B\",list.get(1));\n+\n+        try {\n+            list.get(-1);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(2);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        assertEquals(-1,list.indexOf(\"A\"));\n+        assertEquals(-1,list.lastIndexOf(\"A\"));\n+        list.add(\"A\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(-1,list.indexOf(\"B\"));\n+        assertEquals(-1,list.lastIndexOf(\"B\"));\n+        list.add(\"B\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(1,list.indexOf(\"B\"));\n+        assertEquals(1,list.lastIndexOf(\"B\"));\n+        list.addFirst(\"B\");\n+        assertEquals(1,list.indexOf(\"A\"));\n+        assertEquals(1,list.lastIndexOf(\"A\"));\n+        assertEquals(0,list.indexOf(\"B\"));\n+        assertEquals(2,list.lastIndexOf(\"B\"));\n+    }\n+\n+    public void testIsEmpty() {\n+        assert(list.isEmpty());\n+        list.add(\"element\");\n+        assert(!list.isEmpty());\n+        list.remove(\"element\");\n+        assert(list.isEmpty());\n+        list.add(\"element\");\n+        assert(!list.isEmpty());\n+        list.clear();\n+        assert(list.isEmpty());\n+    }\n+\n+    public void testIterator() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        Iterator it = list.iterator();\n+        assert(it.hasNext());\n+        assertEquals(\"1\",it.next());\n+        assert(it.hasNext());\n+        assertEquals(\"2\",it.next());\n+        assert(it.hasNext());\n+        assertEquals(\"3\",it.next());\n+        assert(it.hasNext());\n+        assertEquals(\"4\",it.next());\n+        assert(it.hasNext());\n+        assertEquals(\"5\",it.next());\n+        assert(!it.hasNext());\n+\n+        it = list.iterator();\n+        assert(it.hasNext());\n+        assertEquals(\"1\",it.next());\n+        it.remove();\n+        assertEquals(\"[2, 3, 4, 5]\",list.toString());\n+        assert(it.hasNext());\n+        assertEquals(\"2\",it.next());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assert(it.hasNext());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        assert(it.hasNext());\n+        assertEquals(\"4\",it.next());\n+        it.remove();\n+        assertEquals(\"[5]\",list.toString());\n+        assert(it.hasNext());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+        assert(!it.hasNext());\n+    }\n+\n+    public void testListIteratorNavigation() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        ListIterator it = list.listIterator();\n+        assert(it.hasNext());\n+        assert(!it.hasPrevious());\n+        assertEquals(-1,it.previousIndex());\n+        assertEquals(0,it.nextIndex());\n+        assertEquals(\"1\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"1\",it.previous());\n+        assert(it.hasNext());\n+        assert(!it.hasPrevious());\n+        assertEquals(-1,it.previousIndex());\n+        assertEquals(0,it.nextIndex());\n+        assertEquals(\"1\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"2\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(1,it.previousIndex());\n+        assertEquals(2,it.nextIndex());\n+        assertEquals(\"2\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"2\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(1,it.previousIndex());\n+        assertEquals(2,it.nextIndex());\n+        assertEquals(\"3\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(2,it.previousIndex());\n+        assertEquals(3,it.nextIndex());\n+        assertEquals(\"4\",it.next());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(3,it.previousIndex());\n+        assertEquals(4,it.nextIndex());\n+        assertEquals(\"5\",it.next());\n+        assert(!it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(4,it.previousIndex());\n+        assertEquals(5,it.nextIndex());\n+        assertEquals(\"5\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(3,it.previousIndex());\n+        assertEquals(4,it.nextIndex());\n+        assertEquals(\"4\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(2,it.previousIndex());\n+        assertEquals(3,it.nextIndex());\n+        assertEquals(\"3\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(1,it.previousIndex());\n+        assertEquals(2,it.nextIndex());\n+        assertEquals(\"2\",it.previous());\n+        assert(it.hasNext());\n+        assert(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"1\",it.previous());\n+        assert(it.hasNext());\n+        assert(!it.hasPrevious());\n+        assertEquals(-1,it.previousIndex());\n+        assertEquals(0,it.nextIndex());\n+    }\n+\n+    public void testListIteratorSet() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        ListIterator it = list.listIterator();\n+        assertEquals(\"1\",it.next());\n+        it.set(\"a\");\n+        assertEquals(\"a\",it.previous());\n+        it.set(\"A\");\n+        assertEquals(\"A\",it.next());\n+        assertEquals(\"2\",it.next());\n+        it.set(\"B\");\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"4\",it.next());\n+        it.set(\"D\");\n+        assertEquals(\"5\",it.next());\n+        it.set(\"E\");\n+        assertEquals(\"[A, B, 3, D, E]\",list.toString());\n+    }\n+\n+    public void testListIteratorRemove() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        ListIterator it = list.listIterator();\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\",it.next());\n+        assertEquals(\"2\",it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"3\",it.previous());\n+        assertEquals(\"1\",it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assert(!it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\",it.next());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[4]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    public void testListIteratorAdd() {\n+        ListIterator it = list.listIterator();\n+        it.add(\"1\");\n+        assertEquals(\"[1]\",list.toString());\n+        it.add(\"3\");\n+        assertEquals(\"[1, 3]\",list.toString());\n+        it.add(\"5\");\n+        assertEquals(\"[1, 3, 5]\",list.toString());\n+        assertEquals(\"5\",it.previous());\n+        it.add(\"4\");\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        assertEquals(\"3\",it.previous());\n+        it.add(\"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+    }\n+\n+    public void testRemoveAll() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        HashSet set = new HashSet();\n+        set.add(\"A\");\n+        set.add(\"2\");\n+        set.add(\"C\");\n+        set.add(\"4\");\n+        set.add(\"D\");\n+\n+        assert(list.removeAll(set));\n+        assertEquals(\"[1, 3, 5]\",list.toString());\n+        assert(!list.removeAll(set));\n+    }\n+\n+    public void testRemoveByIndex() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        assertEquals(\"1\",list.remove(0));\n+        assertEquals(\"[2, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",list.remove(1));\n+        assertEquals(\"[2, 4, 5]\",list.toString());\n+        assertEquals(\"4\",list.remove(1));\n+        assertEquals(\"[2, 5]\",list.toString());\n+        assertEquals(\"5\",list.remove(1));\n+        assertEquals(\"[2]\",list.toString());\n+        assertEquals(\"2\",list.remove(0));\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    public void testRemove() {\n+        list.add(\"1\");\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        assertEquals(\"[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]\",list.toString());\n+        assert(!list.remove(\"6\"));\n+        assert(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4, 5]\",list.toString());\n+        assert(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4]\",list.toString());\n+        assert(!list.remove(\"5\"));\n+        assert(list.remove(\"1\"));\n+        assertEquals(\"[1, 2, 3, 4, 2, 3, 4]\",list.toString());\n+        assert(list.remove(\"1\"));\n+        assertEquals(\"[2, 3, 4, 2, 3, 4]\",list.toString());\n+        assert(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 2, 3, 4]\",list.toString());\n+        assert(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 3, 4]\",list.toString());\n+        assert(list.remove(\"3\"));\n+        assertEquals(\"[4, 3, 4]\",list.toString());\n+        assert(list.remove(\"3\"));\n+        assertEquals(\"[4, 4]\",list.toString());\n+        assert(list.remove(\"4\"));\n+        assertEquals(\"[4]\",list.toString());\n+        assert(list.remove(\"4\"));\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    public void testRetainAll() {\n+        list.add(\"1\");\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        list.add(\"5\");\n+\n+        HashSet set = new HashSet();\n+        set.add(\"A\");\n+        set.add(\"2\");\n+        set.add(\"C\");\n+        set.add(\"4\");\n+        set.add(\"D\");\n+\n+        assert(list.retainAll(set));\n+        assertEquals(\"[2, 2, 4, 4]\",list.toString());\n+        assert(!list.retainAll(set));\n+    }\n+\n+    public void testSet() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        list.set(0,\"A\");\n+        assertEquals(\"[A, 2, 3, 4, 5]\",list.toString());\n+        list.set(1,\"B\");\n+        assertEquals(\"[A, B, 3, 4, 5]\",list.toString());\n+        list.set(2,\"C\");\n+        assertEquals(\"[A, B, C, 4, 5]\",list.toString());\n+        list.set(3,\"D\");\n+        assertEquals(\"[A, B, C, D, 5]\",list.toString());\n+        list.set(4,\"E\");\n+        assertEquals(\"[A, B, C, D, E]\",list.toString());\n+    }\n+\n+    public void testSubList() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        assertEquals(\"[A, B, C, D, E]\",list.toString());\n+        assertEquals(\"[A, B, C, D, E]\",list.subList(0,5).toString());\n+        assertEquals(\"[B, C, D, E]\",list.subList(1,5).toString());\n+        assertEquals(\"[C, D, E]\",list.subList(2,5).toString());\n+        assertEquals(\"[D, E]\",list.subList(3,5).toString());\n+        assertEquals(\"[E]\",list.subList(4,5).toString());\n+        assertEquals(\"[]\",list.subList(5,5).toString());\n+    }\n+\n+    public void testSubListAddEnd() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(5,5);\n+        sublist.add(\"F\");\n+        assertEquals(\"[A, B, C, D, E, F]\",list.toString());\n+        assertEquals(\"[F]\",sublist.toString());\n+        sublist.add(\"G\");\n+        assertEquals(\"[A, B, C, D, E, F, G]\",list.toString());\n+        assertEquals(\"[F, G]\",sublist.toString());\n+    }\n+\n+    public void testSubListAddBegin() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(0,0);\n+        sublist.add(\"a\");\n+        assertEquals(\"[a, A, B, C, D, E]\",list.toString());\n+        assertEquals(\"[a]\",sublist.toString());\n+        sublist.add(\"b\");\n+        assertEquals(\"[a, b, A, B, C, D, E]\",list.toString());\n+        assertEquals(\"[a, b]\",sublist.toString());\n+    }\n+\n+    public void testSubListAddMiddle() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(1,3);\n+        sublist.add(\"a\");\n+        assertEquals(\"[A, B, C, a, D, E]\",list.toString());\n+        assertEquals(\"[B, C, a]\",sublist.toString());\n+        sublist.add(\"b\");\n+        assertEquals(\"[A, B, C, a, b, D, E]\",list.toString());\n+        assertEquals(\"[B, C, a, b]\",sublist.toString());\n+    }\n+\n+    public void testSubListRemove() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(1,4);\n+        assertEquals(\"[B, C, D]\",sublist.toString());\n+        assertEquals(\"[A, B, C, D, E]\",list.toString());\n+        sublist.remove(\"C\");\n+        assertEquals(\"[B, D]\",sublist.toString());\n+        assertEquals(\"[A, B, D, E]\",list.toString());\n+        sublist.remove(1);\n+        assertEquals(\"[B]\",sublist.toString());\n+        assertEquals(\"[A, B, E]\",list.toString());\n+        sublist.clear();\n+        assertEquals(\"[]\",sublist.toString());\n+        assertEquals(\"[A, E]\",list.toString());\n+    }\n+\n+    public void testToArray() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        Object[] elts = list.toArray();\n+        assertEquals(\"1\",elts[0]);\n+        assertEquals(\"2\",elts[1]);\n+        assertEquals(\"3\",elts[2]);\n+        assertEquals(\"4\",elts[3]);\n+        assertEquals(\"5\",elts[4]);\n+        assertEquals(5,elts.length);\n+\n+        String[] elts2 = (String[])(list.toArray(new String[0]));\n+        assertEquals(\"1\",elts2[0]);\n+        assertEquals(\"2\",elts2[1]);\n+        assertEquals(\"3\",elts2[2]);\n+        assertEquals(\"4\",elts2[3]);\n+        assertEquals(\"5\",elts2[4]);\n+        assertEquals(5,elts2.length);\n+\n+        String[] elts3 = new String[5];\n+        assertSame(elts3,list.toArray(elts3));\n+        assertEquals(\"1\",elts3[0]);\n+        assertEquals(\"2\",elts3[1]);\n+        assertEquals(\"3\",elts3[2]);\n+        assertEquals(\"4\",elts3[3]);\n+        assertEquals(\"5\",elts3[4]);\n+        assertEquals(5,elts3.length);\n+\n+        String[] elts4 = new String[3];\n+        String[] elts4b = (String[])(list.toArray(elts4));\n+        assert(elts4 != elts4b);\n+        assertEquals(\"1\",elts4b[0]);\n+        assertEquals(\"2\",elts4b[1]);\n+        assertEquals(\"3\",elts4b[2]);\n+        assertEquals(\"4\",elts4b[3]);\n+        assertEquals(\"5\",elts4b[4]);\n+        assertEquals(5,elts4b.length);\n+    }\n+\n+    public void testSerialization() throws Exception {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assert(list != list2);\n+        assert(list2.equals(list));\n+        assert(list.equals(list2));\n+    }\n+\n+    public void testLongSerialization() throws Exception {\n+        // recursive serialization will cause a stack\n+        // overflow exception with long lists\n+        for(int i=0;i<10000;i++) {\n+            list.add(new Integer(i));\n+        }\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assert(list != list2);\n+        assert(list2.equals(list));\n+        assert(list.equals(list2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.1 2001/04/14 15:39:53 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/14 15:39:53 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.*;\n+import java.util.List;\n+\n+/**\n+ * @author Rodney Waldhoff\n+ * @version $Id: TestList.java,v 1.1 2001/04/14 15:39:53 rwaldhoff Exp $\n+ */\n+public abstract class TestList extends TestCollection {\n+    public TestList(String testName) {\n+        super(testName);\n+    }\n+\n+    private List _list = null;\n+\n+    protected void setList(List l) {\n+        _list = l;\n+        setCollection(_list);\n+    }\n+\n+    // placeholder.  add list contract tests here\n+}", "timestamp": 987262738, "metainfo": ""}