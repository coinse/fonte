{"sha": "61fe60ef9db30f810b7afc743a6a2a3cf45a7dcf", "log": "[COLLECTION-383] Added overriden CollectionUtils#forAllDo method which takes an Iterator as input, thanks to Adrian Cumiskey for report and patch.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections/CollectionUtils.java\n         if (collection != null && closure != null) {\n             for (T element : collection) {\n                 closure.execute(element);\n+            }\n+        }\n+        return closure;\n+    }\n+\n+    /**\n+     * Executes the given closure on each element in the collection.\n+     * <p>\n+     * If the input collection or closure is null, there is no change made.\n+     *\n+     * @param iterator\n+     *            the iterator to get the input from, may be null\n+     * @param closure\n+     *            the closure to perform, may be null\n+     * @return closure\n+     * @since 4.0\n+     */\n+    public static <T, C extends Closure<? super T>> C forAllDo(Iterator<T> iterator, C closure) {\n+        if (iterator != null && closure != null) {\n+            while (iterator.hasNext()) {\n+                closure.execute(iterator.next());\n             }\n         }\n         return closure;\n--- a/src/test/java/org/apache/commons/collections/TestCollectionUtils.java\n+++ b/src/test/java/org/apache/commons/collections/TestCollectionUtils.java\n         assertNull(CollectionUtils.find(collectionA, null));\n     }\n \n-    @Test\n-    public void forAllDo() {\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void forAllDoCollection() {\n         Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n         Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n         col.add(collectionA);\n         Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n         assertSame(testClosure, resultClosure);\n         assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n-        resultClosure = CollectionUtils.<List<? extends Number>,Closure<List<? extends Number>>>forAllDo(col, null);\n+        resultClosure = CollectionUtils.forAllDo(col, null);\n         assertNull(resultClosure);\n         assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n-        resultClosure = CollectionUtils.forAllDo(null, testClosure);\n+        resultClosure = CollectionUtils.forAllDo((Collection) null, testClosure);\n         col.add(null);\n         // null should be OK\n         CollectionUtils.forAllDo(col, testClosure);\n     }\n \n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void forAllDoIterator() {\n+        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        col.add(collectionA);\n+        col.add(collectionB);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);\n+        assertSame(testClosure, resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo(col.iterator(), null);\n+        assertNull(resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo((Iterator) null, testClosure);\n+        col.add(null);\n+        // null should be OK\n+        CollectionUtils.forAllDo(col.iterator(), testClosure);\n+    }\n+    \n     @Test(expected = FunctorException.class)\n     public void forAllDoFailure() {\n         Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");", "timestamp": 1343761373, "metainfo": ""}