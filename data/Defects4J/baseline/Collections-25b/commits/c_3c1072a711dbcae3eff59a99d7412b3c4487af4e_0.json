{"sha": "3c1072a711dbcae3eff59a99d7412b3c4487af4e", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r751869 | mbenson | 2009-03-09 15:10:00 -0700 (Mon, 09 Mar 2009) | 1 line          return type narrowing     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/set/ListOrderedSet.java\n+++ b/src/java/org/apache/commons/collections/set/ListOrderedSet.java\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Set;\n \n+import org.apache.commons.collections.OrderedIterator;\n import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n import org.apache.commons.collections.list.UnmodifiableList;\n \n  * <p>\n  * The ListOrderedSet also has various useful direct methods. These include many\n  * from <code>List</code>, such as <code>get(int)</code>, <code>remove(int)</code>\n- * and <code>indexOf(int)</code>. An unmodifiable <code>List</code> view of \n+ * and <code>indexOf(int)</code>. An unmodifiable <code>List</code> view of\n  * the set can be obtained via <code>asList()</code>.\n  * <p>\n  * This class cannot implement the <code>List</code> interface directly as\n  * @author Stephen Colebourne\n  * @author Henning P. Schmiedehausen\n  */\n-public class ListOrderedSet extends AbstractSerializableSetDecorator implements Set {\n+public class ListOrderedSet<E> extends AbstractSerializableSetDecorator<E> implements Set<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -228664372470420141L;\n \n     /** Internal list to hold the sequence of objects */\n-    protected final List setOrder;\n+    protected final List<E> setOrder;\n \n     /**\n      * Factory method to create an ordered set specifying the list and set to use.\n      * <p>\n      * The list and set must both be empty.\n-     * \n+     *\n      * @param set  the set to decorate, must be empty and not null\n      * @param list  the list to decorate, must be empty and not null\n      * @throws IllegalArgumentException if set or list is null\n      * @throws IllegalArgumentException if either the set or list is not empty\n      * @since Commons Collections 3.1\n      */\n-    public static ListOrderedSet decorate(Set set, List list) {\n+    public static <E> ListOrderedSet<E> decorate(Set<E> set, List<E> list) {\n         if (set == null) {\n             throw new IllegalArgumentException(\"Set must not be null\");\n         }\n         if (set.size() > 0 || list.size() > 0) {\n             throw new IllegalArgumentException(\"Set and List must be empty\");\n         }\n-        return new ListOrderedSet(set, list);\n+        return new ListOrderedSet<E>(set, list);\n     }\n \n     /**\n      * Factory method to create an ordered set.\n      * <p>\n      * An <code>ArrayList</code> is used to retain order.\n-     * \n+     *\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static ListOrderedSet decorate(Set set) {\n-        return new ListOrderedSet(set);\n+    public static <E> ListOrderedSet<E> decorate(Set<E> set) {\n+        return new ListOrderedSet<E>(set);\n     }\n \n     /**\n      * <p>\n      * NOTE: If the list contains duplicates, the duplicates are removed,\n      * altering the specified list.\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static ListOrderedSet decorate(List list) {\n+    public static <E> ListOrderedSet<E> decorate(List<E> list) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n-        Set set = new HashSet(list);\n+        Set<E> set = new HashSet<E>(list);\n         list.retainAll(set);\n-        \n-        return new ListOrderedSet(set, list);\n+\n+        return new ListOrderedSet<E>(set, list);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Constructs a new empty <code>ListOrderedSet</code> using\n      * a <code>HashSet</code> and an <code>ArrayList</code> internally.\n-     * \n+     *\n      * @since Commons Collections 3.1\n      */\n     public ListOrderedSet() {\n-        super(new HashSet());\n-        setOrder = new ArrayList();\n+        super(new HashSet<E>());\n+        setOrder = new ArrayList<E>();\n     }\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected ListOrderedSet(Set set) {\n+    protected ListOrderedSet(Set<E> set) {\n         super(set);\n-        setOrder = new ArrayList(set);\n+        setOrder = new ArrayList<E>(set);\n     }\n \n     /**\n      * Constructor that wraps (not copies) the Set and specifies the list to use.\n      * <p>\n      * The set and list must both be correctly initialised to the same elements.\n-     * \n+     *\n      * @param set  the set to decorate, must not be null\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if set or list is null\n      */\n-    protected ListOrderedSet(Set set, List list) {\n+    protected ListOrderedSet(Set<E> set, List<E> list) {\n         super(set);\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n     //-----------------------------------------------------------------------\n     /**\n      * Gets an unmodifiable view of the order of the Set.\n-     * \n+     *\n      * @return an unmodifiable list view\n      */\n-    public List asList() {\n+    public List<E> asList() {\n         return UnmodifiableList.decorate(setOrder);\n     }\n \n         setOrder.clear();\n     }\n \n-    public Iterator iterator() {\n-        return new OrderedSetIterator(setOrder.iterator(), collection);\n-    }\n-\n-    public boolean add(Object object) {\n-        if (collection.contains(object)) {\n-            // re-adding doesn't change order\n-            return collection.add(object);\n-        } else {\n-            // first add, so add to both set and list\n-            boolean result = collection.add(object);\n+    public OrderedIterator<E> iterator() {\n+        return new OrderedSetIterator<E>(setOrder.listIterator(), collection);\n+    }\n+\n+    public boolean add(E object) {\n+        if (collection.add(object)) {\n             setOrder.add(object);\n-            return result;\n-        }\n-    }\n-\n-    public boolean addAll(Collection coll) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean addAll(Collection<? extends E> coll) {\n         boolean result = false;\n-        for (Iterator it = coll.iterator(); it.hasNext();) {\n-            Object object = it.next();\n-            result = result | add(object);\n+        for (E e : coll) {\n+            result |= add(e);\n         }\n         return result;\n     }\n         return result;\n     }\n \n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         boolean result = false;\n-        for (Iterator it = coll.iterator(); it.hasNext();) {\n-            Object object = it.next();\n-            result = result | remove(object);\n+        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n+            result |= remove(it.next());\n         }\n         return result;\n     }\n \n-    public boolean retainAll(Collection coll) {\n+    public boolean retainAll(Collection<?> coll) {\n         boolean result = collection.retainAll(coll);\n         if (result == false) {\n             return false;\n-        } else if (collection.size() == 0) {\n+        }\n+        if (collection.size() == 0) {\n             setOrder.clear();\n         } else {\n-            for (Iterator it = setOrder.iterator(); it.hasNext();) {\n-                Object object = it.next();\n-                if (collection.contains(object) == false) {\n+            for (Iterator<E> it = setOrder.iterator(); it.hasNext();) {\n+                if (!collection.contains(it.next())) {\n                     it.remove();\n                 }\n             }\n         return setOrder.toArray();\n     }\n \n-    public Object[] toArray(Object a[]) {\n+    public <T> T[] toArray(T a[]) {\n         return setOrder.toArray(a);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object get(int index) {\n+    public E get(int index) {\n         return setOrder.get(index);\n     }\n \n         return setOrder.indexOf(object);\n     }\n \n-    public void add(int index, Object object) {\n-        if (contains(object) == false) {\n+    public void add(int index, E object) {\n+        if (!contains(object)) {\n             collection.add(object);\n             setOrder.add(index, object);\n         }\n     }\n \n-    public boolean addAll(int index, Collection coll) {\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n         boolean changed = false;\n-        for (Iterator it = coll.iterator(); it.hasNext();) {\n-            Object object = it.next();\n-            if (contains(object) == false) {\n-                collection.add(object);\n-                setOrder.add(index, object);\n-                index++;\n-                changed = true;\n+        for (E e : coll) {\n+            if (contains(e)) {\n+                continue;\n             }\n+            collection.add(e);\n+            setOrder.add(index++, e);\n+            changed = true;\n         }\n         return changed;\n     }\n     }\n \n     /**\n-     * Uses the underlying List's toString so that order is achieved. \n-     * This means that the decorated Set's toString is not used, so \n-     * any custom toStrings will be ignored. \n+     * Uses the underlying List's toString so that order is achieved.\n+     * This means that the decorated Set's toString is not used, so\n+     * any custom toStrings will be ignored.\n      */\n     // Fortunately List.toString and Set.toString look the same\n     public String toString() {\n     /**\n      * Internal iterator handle remove.\n      */\n-    static class OrderedSetIterator extends AbstractIteratorDecorator {\n-        \n+    static class OrderedSetIterator<E> extends AbstractIteratorDecorator<E> implements OrderedIterator<E> {\n+\n         /** Object we iterate on */\n-        protected final Collection set;\n+        protected final Collection<E> set;\n+\n         /** Last object retrieved */\n-        protected Object last;\n-\n-        private OrderedSetIterator(Iterator iterator, Collection set) {\n+        protected E last;\n+\n+        private OrderedSetIterator(ListIterator<E> iterator, Collection<E> set) {\n             super(iterator);\n             this.set = set;\n         }\n \n-        public Object next() {\n+        public E next() {\n             last = iterator.next();\n             return last;\n         }\n             iterator.remove();\n             last = null;\n         }\n+\n+        public boolean hasPrevious() {\n+            return ((ListIterator<E>) iterator).hasPrevious();\n+        }\n+\n+        public E previous() {\n+            last = ((ListIterator<E>) iterator).previous();\n+            return last;\n+        }\n     }\n \n }", "timestamp": 1252994532, "metainfo": ""}