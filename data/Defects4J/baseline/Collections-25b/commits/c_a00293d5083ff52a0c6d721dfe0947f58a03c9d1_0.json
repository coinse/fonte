{"sha": "a00293d5083ff52a0c6d721dfe0947f58a03c9d1", "log": "Ensure that the keySet and values views handle removed elements bug 25551, from Joe Raysa   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/ReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ReferenceMap.java,v 1.4 2003/12/28 16:36:48 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ReferenceMap.java,v 1.5 2003/12/29 14:54:58 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * @see java.lang.ref.Reference\n  * \n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.4 $ $Date: 2003/12/28 16:36:48 $\n+ * @version $Revision: 1.5 $ $Date: 2003/12/29 14:54:58 $\n  * \n  * @author Paul Jack\n  */\n         if (keySet != null) return keySet;\n         keySet = new AbstractSet() {\n             public int size() {\n-                return size;\n+                return ReferenceMap.this.size();\n             }\n \n             public Iterator iterator() {\n                 ReferenceMap.this.clear();\n             }\n \n+            public Object[] toArray() {\n+                return toArray(new Object[0]);\n+            }\n+\n+            public Object[] toArray(Object[] arr) {\n+                Collection c = new ArrayList(size());\n+                for (Iterator it = iterator(); it.hasNext(); ) {\n+                    c.add(it.next());\n+                }\n+                return c.toArray(arr);\n+            }\n         };\n         return keySet;\n     }\n         if (values != null) return values;\n         values = new AbstractCollection()  {\n             public int size() {\n-                return size;\n+                return ReferenceMap.this.size();\n             }\n \n             public void clear() {\n             public Iterator iterator() {\n                 return new ValueIterator();\n             }\n+\n+            public Object[] toArray() {\n+                return toArray(new Object[0]);\n+            }\n+\n+            public Object[] toArray(Object[] arr) {\n+                Collection c = new ArrayList(size());\n+                for (Iterator it = iterator(); it.hasNext(); ) {\n+                    c.add(it.next());\n+                }\n+                return c.toArray(arr);\n+            }\n         };\n         return values;\n     }\n \n-\n-    // If getKey() or getValue() returns null, it means\n-    // the mapping is stale and should be removed.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A MapEntry implementation for the map.\n+     * <p>\n+     * If getKey() or getValue() returns null, it means\n+     * the mapping is stale and should be removed.\n+     */\n     private class Entry implements Map.Entry, KeyValue {\n \n         Object key;\n         Object value;\n         int hash;\n         Entry next;\n-\n \n         public Entry(Object key, int hash, Object value, Entry next) {\n             this.key = key;\n             this.next = next;\n         }\n \n-\n         public Object getKey() {\n             return (keyType > HARD) ? ((Reference)key).get() : key;\n         }\n \n-\n         public Object getValue() {\n             return (valueType > HARD) ? ((Reference)value).get() : value;\n         }\n \n-\n-        public Object setValue(Object object) {\n+        public Object setValue(Object obj) {\n             Object old = getValue();\n-            if (valueType > HARD) ((Reference)value).clear();\n-            value = toReference(valueType, object, hash);\n+            if (valueType > HARD) {\n+                ((Reference)value).clear();\n+            }\n+            value = toReference(valueType, obj, hash);\n             return old;\n         }\n \n-\n-        public boolean equals(Object o) {\n-            if (o == null) return false;\n-            if (o == this) return true;\n-            if (!(o instanceof Map.Entry)) return false;\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n             \n-            Map.Entry entry = (Map.Entry)o;\n+            Map.Entry entry = (Map.Entry)obj;\n             Object key = entry.getKey();\n             Object value = entry.getValue();\n-            if ((key == null) || (value == null)) return false;\n+            if ((key == null) || (value == null)) {\n+                return false;\n+            }\n             return key.equals(getKey()) && value.equals(getValue());\n         }\n-\n \n         public int hashCode() {\n             Object v = getValue();\n             return hash ^ ((v == null) ? 0 : v.hashCode());\n         }\n \n-\n         public String toString() {\n             return getKey() + \"=\" + getValue();\n         }\n-\n \n         boolean purge(Reference ref) {\n             boolean r = (keyType > HARD) && (key == ref);\n             r = r || ((valueType > HARD) && (value == ref));\n             if (r) {\n-                if (keyType > HARD) ((Reference)key).clear();\n+                if (keyType > HARD) {\n+                    ((Reference)key).clear();\n+                }\n                 if (valueType > HARD) {\n                     ((Reference)value).clear();\n                 } else if (purgeValues) {\n         }\n     }\n \n-\n+    /**\n+     * The EntrySet iterator.\n+     */\n     private class EntryIterator implements Iterator {\n         // These fields keep track of where we are in the table.\n         int index;\n \n         int expectedModCount;\n \n-\n         public EntryIterator() {\n             index = (size() != 0 ? table.length : 0);\n             // have to do this here!  size() invocation above\n             // may have altered the modCount.\n             expectedModCount = modCount;\n         }\n-\n \n         public boolean hasNext() {\n             checkMod();\n                 }\n                 nextKey = e.getKey();\n                 nextValue = e.getValue();\n-                if (nextNull()) entry = entry.next;\n+                if (nextNull()) {\n+                    entry = entry.next;\n+                }\n             }\n             return true;\n         }\n-\n \n         private void checkMod() {\n             if (modCount != expectedModCount) {\n             }\n         }\n \n-\n         private boolean nextNull() {\n             return (nextKey == null) || (nextValue == null);\n         }\n \n         protected Entry nextEntry() {    \n             checkMod();\n-            if (nextNull() && !hasNext()) throw new NoSuchElementException();\n+            if (nextNull() && !hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n             previous = entry;\n             entry = entry.next;\n             currentKey = nextKey;\n             return previous;\n         }\n \n-\n         public Object next() {\n             return nextEntry();\n         }\n \n-\n         public void remove() {\n             checkMod();\n-            if (previous == null) throw new IllegalStateException();\n+            if (previous == null) {\n+                throw new IllegalStateException();\n+            }\n             ReferenceMap.this.remove(currentKey);\n             previous = null;\n             currentKey = null;\n             currentValue = null;\n             expectedModCount = modCount;\n         }\n-\n-    }\n-\n-\n+    }\n+\n+    /**\n+     * The values iterator.\n+     */\n     private class ValueIterator extends EntryIterator {\n         public Object next() {\n             return nextEntry().getValue();\n         }\n     }\n \n-\n+    /**\n+     * The keySet iterator.\n+     */\n     private class KeyIterator extends EntryIterator {\n         public Object next() {\n             return nextEntry().getKey();\n         }\n     }\n \n-\n-\n+    //-----------------------------------------------------------------------\n     // These two classes store the hashCode of the key of\n     // of the mapping, so that after they're dequeued a quick\n     // lookup of the bucket in the table can occur.\n \n-\n+    /**\n+     * A soft reference holder.\n+     */\n     private static class SoftRef extends SoftReference {\n         private int hash;\n-\n \n         public SoftRef(int hash, Object r, ReferenceQueue q) {\n             super(r, q);\n             this.hash = hash;\n         }\n \n-\n         public int hashCode() {\n             return hash;\n         }\n     }\n \n-\n+    /**\n+     * A weak reference holder.\n+     */\n     private static class WeakRef extends WeakReference {\n         private int hash;\n-\n \n         public WeakRef(int hash, Object r, ReferenceQueue q) {\n             super(r, q);\n             this.hash = hash;\n         }\n \n-\n         public int hashCode() {\n             return hash;\n         }", "timestamp": 1072709781, "metainfo": ""}