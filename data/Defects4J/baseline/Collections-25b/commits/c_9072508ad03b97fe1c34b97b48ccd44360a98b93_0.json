{"sha": "9072508ad03b97fe1c34b97b48ccd44360a98b93", "log": "Fix put methods, optimize clear method, fix formatting bug 29440  ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiValueMap.java\n  */\n package org.apache.commons.collections.map;\n \n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n import org.apache.commons.collections.Factory;\n import org.apache.commons.collections.MultiMap;\n import org.apache.commons.collections.iterators.EmptyIterator;\n import org.apache.commons.collections.iterators.IteratorChain;\n \n-import java.util.AbstractCollection;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n /**\n  * A MultiValueMap decorates another map, allowing it to have\n- * more than one value for a key.  The values of the map will be\n- * Collection objects.  The types of which can be specified using\n- * either a Class object or a Factory which creates Collection\n- * objects.\n+ * more than one value for a key.\n+ * <p>\n+ * A <code>MultiMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that key.\n+ * <p>\n+ * This implementation is a decorator, allowing any Map implementation\n+ * to be used as the base.\n+ * <p>\n+ * In addition, this implementation allows the type of collection used\n+ * for the values to be controlled. By default, an <code>ArrayList</code>\n+ * is used, however a <code>Class</code> to instantiate may be specified,\n+ * or a factory that returns a <code>Collection</code> instance.\n  *\n- * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n+ * @author James Carman\n+ * @author Christopher Berry\n+ * @author James Strachan\n+ * @author Steve Downey\n+ * @author Stephen Colebourne\n+ * @author Julien Buret\n+ * @author Serhiy Yevtushenko\n+ * @version $Revision: $ $Date: $\n  * @since Commons Collections 3.2\n  */\n public class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n+\n+    /** The factory for creating value collections. */\n     private final Factory collectionFactory;\n-    private Collection values;\n+    /** The cached values. */\n+    private transient Collection values;\n \n     /**\n      * Creates a map which wraps the given map and\n      * maps keys to ArrayLists.\n      *\n-     * @param map the map to wrap\n-     */\n-    public static Map decorate(Map map) {\n-        return new MultiValueMap(map);\n+     * @param map  the map to wrap\n+     */\n+    public static MultiValueMap decorate(Map map) {\n+        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n     }\n \n     /**\n      * Creates a map which decorates the given <code>map</code> and\n      * maps keys to collections of type <code>collectionClass</code>.\n      *\n-     * @param map             the map to wrap\n-     * @param collectionClass the type of the collection class\n-     */\n-    public static Map decorate(Map map, Class collectionClass) {\n-        return new MultiValueMap(map, collectionClass);\n+     * @param map  the map to wrap\n+     * @param collectionClass  the type of the collection class\n+     */\n+    public static MultiValueMap decorate(Map map, Class collectionClass) {\n+        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n     }\n \n     /**\n      * Creates a map which decorates the given <code>map</code> and\n      * creates the value collections using the supplied <code>collectionFactory</code>.\n      *\n-     * @param map               the map to decorate\n-     * @param collectionFactory the collection factory (must return a Collection object).\n-     */\n-    public static Map decorate(Map map, Factory collectionFactory) {\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory (must return a Collection object).\n+     */\n+    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n         return new MultiValueMap(map, collectionFactory);\n     }\n \n-    /**\n-     * Creates a MultiValueMap which wraps the given map and\n-     * maps keys to ArrayLists.\n-     *\n-     * @param map the map to wrap\n-     */\n-    protected MultiValueMap(Map map) {\n-        this(map, ArrayList.class);\n-    }\n-\n-    /**\n-     * Creates a MultiValueMap which decorates the given <code>map</code> and\n-     * maps keys to collections of type <code>collectionClass</code>.\n-     *\n-     * @param map             the map to wrap\n-     * @param collectionClass the type of the collection class\n-     */\n-    protected MultiValueMap(Map map, Class collectionClass) {\n-        this(map, new ReflectionFactory(collectionClass));\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> and\n+     * storing the multiple values in an <code>ArrayList</code>.\n+     */\n+    public MultiValueMap() {\n+        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n     }\n \n     /**\n      * Creates a MultiValueMap which decorates the given <code>map</code> and\n      * creates the value collections using the supplied <code>collectionFactory</code>.\n      *\n-     * @param map               the map to decorate\n-     * @param collectionFactory the collection factory (must return a Collection object).\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory which must return a Collection instance\n      */\n     protected MultiValueMap(Map map, Factory collectionFactory) {\n         super(map);\n+        if (collectionFactory == null) {\n+            throw new IllegalArgumentException(\"The factory must not be null\");\n+        }\n         this.collectionFactory = collectionFactory;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Clear the map.\n-     * <p>\n-     * This clears each collection in the map, and so may be slow.\n      */\n     public void clear() {\n-        Set pairs = getMap().entrySet();\n-        Iterator pairsIterator = pairs.iterator();\n-        while(pairsIterator.hasNext()) {\n-            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n-            Collection coll = (Collection) keyValuePair.getValue();\n-            coll.clear();\n-        }\n+        // If you believe that you have GC issues here, try uncommenting this code\n+//        Set pairs = getMap().entrySet();\n+//        Iterator pairsIterator = pairs.iterator();\n+//        while (pairsIterator.hasNext()) {\n+//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+//            Collection coll = (Collection) keyValuePair.getValue();\n+//            coll.clear();\n+//        }\n         getMap().clear();\n     }\n \n      */\n     public Object remove(Object key, Object value) {\n         Collection valuesForKey = getCollection(key);\n-        if(valuesForKey == null) {\n+        if (valuesForKey == null) {\n             return null;\n         }\n         boolean removed = valuesForKey.remove(value);\n-        if(removed == false) {\n+        if (removed == false) {\n             return null;\n         }\n-        if(valuesForKey.isEmpty()) {\n+        if (valuesForKey.isEmpty()) {\n             remove(key);\n         }\n         return value;\n      */\n     public boolean containsValue(Object value) {\n         Set pairs = getMap().entrySet();\n-        if(pairs == null) {\n+        if (pairs == null) {\n             return false;\n         }\n         Iterator pairsIterator = pairs.iterator();\n-        while(pairsIterator.hasNext()) {\n+        while (pairsIterator.hasNext()) {\n             Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n             Collection coll = (Collection) keyValuePair.getValue();\n-            if(coll.contains(value)) {\n+            if (coll.contains(value)) {\n                 return true;\n             }\n         }\n     }\n \n     /**\n-     * Removes a specific value from map.\n-     * <p>\n-     * The item is removed from the collection mapped to the specified key.\n-     * Other values attached to that key are unaffected.\n-     * <p>\n-     * If the last value for a key is removed, <code>null</code> will be returned\n-     * from a subsequant <code>get(key)</code>.\n-     *\n-     * @param key  the key to remove from\n-     * @param value  the value to remove\n-     * @return the value removed (which was passed in), null if nothing removed\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     *\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return the value added if the map changed and null if the map did not change\n      */\n     public Object put(Object key, Object value) {\n-        Collection c = getCollection(key);\n-        if(c == null) {\n-            c = (Collection) collectionFactory.create();\n-            getMap().put(key, c);\n-        }\n-        boolean results = c.add(value);\n-        return (results ? value : null);\n+        boolean result = false;\n+        Collection coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(1);\n+            result = coll.add(value);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                getMap().put(key, coll);\n+                result = false;\n+            }\n+        } else {\n+            result = coll.add(value);\n+        }\n+        return (result ? value : null);\n     }\n \n     /**\n      */\n     public boolean containsValue(Object key, Object value) {\n         Collection coll = getCollection(key);\n-        if(coll == null) {\n+        if (coll == null) {\n             return false;\n         }\n         return coll.contains(value);\n      */\n     public int size(Object key) {\n         Collection coll = getCollection(key);\n-        if(coll == null) {\n+        if (coll == null) {\n             return 0;\n         }\n         return coll.size();\n     }\n \n     /**\n-     * Adds a collection of values to the collection associated with the specified key.\n+     * Adds a collection of values to the collection associated with\n+     * the specified key.\n      *\n      * @param key  the key to store against\n      * @param values  the values to add to the collection at the key, null ignored\n      * @return true if this map changed\n      */\n     public boolean putAll(Object key, Collection values) {\n-        if(values == null || values.size() == 0) {\n+        if (values == null || values.size() == 0) {\n             return false;\n         }\n         Collection coll = getCollection(key);\n-        if(coll == null) {\n-            coll = (Collection) collectionFactory.create();\n-            getMap().put(key, coll);\n-        }\n-        return coll.addAll(values);\n+        if (coll == null) {\n+            coll = createCollection(values.size());\n+            boolean result = coll.addAll(values);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                getMap().put(key, coll);\n+                result = false;\n+            }\n+            return result;\n+        } else {\n+            return coll.addAll(values);\n+        }\n     }\n \n     /**\n      * @return the iterator of the collection at the key, empty iterator if key not in map\n      */\n     public Iterator iterator(Object key) {\n-        if(!containsKey(key)) {\n+        if (!containsKey(key)) {\n             return EmptyIterator.INSTANCE;\n-        }\n-        else {\n+        } else {\n             return new ValuesIterator(key);\n         }\n     }\n     public int totalSize() {\n         int total = 0;\n         Collection values = getMap().values();\n-        for(Iterator it = values.iterator(); it.hasNext();) {\n+        for (Iterator it = values.iterator(); it.hasNext();) {\n             Collection coll = (Collection) it.next();\n             total += coll.size();\n         }\n         return total;\n     }\n \n+    /**\n+     * Creates a new instance of the map value Collection container\n+     * using the factory.\n+     * <p>\n+     * This method can be overridden to perform your own processing\n+     * instead of using the factory.\n+     *\n+     * @param size  the collection size that is about to be added\n+     * @return the new collection\n+     */\n+    protected Collection createCollection(int size) {\n+        return (Collection) collectionFactory.create();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class that provides the values view.\n+     */\n     private class Values extends AbstractCollection {\n         public Iterator iterator() {\n             final IteratorChain chain = new IteratorChain();\n-            for(Iterator i = keySet().iterator(); i.hasNext();) {\n-                chain.addIterator(new ValuesIterator(i.next()));\n+            for (Iterator it = keySet().iterator(); it.hasNext();) {\n+                chain.addIterator(new ValuesIterator(it.next()));\n             }\n             return chain;\n         }\n         }\n     }\n \n+    /**\n+     * Inner class that provides the values iterator.\n+     */\n     private class ValuesIterator implements Iterator {\n         private final Object key;\n         private final Collection values;\n \n         public void remove() {\n             iterator.remove();\n-            if(values.isEmpty()) {\n+            if (values.isEmpty()) {\n                 MultiValueMap.this.remove(key);\n             }\n         }\n         }\n     }\n \n+    /**\n+     * Inner class that provides a simple reflection factory.\n+     */\n     private static class ReflectionFactory implements Factory {\n         private final Class clazz;\n \n         public Object create() {\n             try {\n                 return clazz.newInstance();\n-            }\n-            catch(Exception e) {\n-                throw new RuntimeException(\"Cannot instantiate class \" + clazz + \".\", e);\n-            }\n-        }\n-    }\n+            } catch (Exception ex) {\n+                throw new RuntimeException(\"Cannot instantiate class: \" + clazz, ex);\n+            }\n+        }\n+    }\n+\n }\n--- a/src/test/org/apache/commons/collections/map/TestMultiValueMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestMultiValueMap.java\n /*\n- *  Copyright 2001-2005 The Apache Software Foundation\n+ *  Copyright 2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.apache.commons.collections.IteratorUtils;\n \n /**\n- * TestMultiValueMap\n+ * TestMultiValueMap.\n  *\n  * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n  * @since Commons Collections 3.2\n     }\n \n     private MultiValueMap createTestMap(Class collectionClass) {\n-        final MultiValueMap map = new MultiValueMap(new HashMap(), collectionClass);\n+        final MultiValueMap map = MultiValueMap.decorate(new HashMap(), collectionClass);\n         map.put(\"one\", \"uno\");\n         map.put(\"one\", \"un\");\n         map.put(\"two\", \"dos\");", "timestamp": 1116545146, "metainfo": ""}