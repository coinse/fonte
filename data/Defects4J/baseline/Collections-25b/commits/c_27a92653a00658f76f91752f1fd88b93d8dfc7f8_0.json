{"sha": "27a92653a00658f76f91752f1fd88b93d8dfc7f8", "log": "[COLLECTIONS-464] Add first version of a FluentIterable implementation, cleanup recently toString methods in IterableUtils, add SkippingIterator and additional methods to IteratorUtils and IterableUtils.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n      * @return the object at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @throws IllegalArgumentException if the object type is invalid\n-     */\n+     * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n+     */\n+    @Deprecated\n     public static <T> T get(final Iterator<T> iterator, final int index) {\n-        int i = index;\n-        checkIndexBounds(i);\n-        while (iterator.hasNext()) {\n-            i--;\n-            if (i == -1) {\n-                return iterator.next();\n-            }\n-            iterator.next();\n-        }\n-        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+        return IteratorUtils.get(iterator, index);\n     }\n \n     /**\n      * @param index the index to check.\n      * @throws IndexOutOfBoundsException if the index is negative.\n      */\n-    private static void checkIndexBounds(final int index) {\n+    static void checkIndexBounds(final int index) {\n         if (index < 0) {\n             throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n         }\n      * @param <T> the type of object in the {@link Iterable}.\n      * @return the object at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n-     */\n+     * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n+     */\n+    @Deprecated\n     public static <T> T get(final Iterable<T> iterable, final int index) {\n-        checkIndexBounds(index);\n-        if (iterable instanceof List<?>) {\n-            return ((List<T>) iterable).get(index);\n-        }\n-        return get(iterable.iterator(), index);\n+        return IterableUtils.get(iterable, index);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/FluentIterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A FluentIterable provides a powerful yet simple API for manipulating Iterable instances in a fluent manner.\n+ * <p>\n+ * A FluentIterable can be created either from an Iterable or from a set of elements.\n+ * The following types of methods are provided:\n+ * <ul>\n+ *   <li>fluent methods which return a new {@code FluentIterable} instance\n+ *   <li>conversion methods which copy the FluentIterable's contents into a new collection or array (e.g. toList())\n+ *   <li>utility methods which answer questions about the FluentIterable's contents (e.g. size(), anyMatch(Predicate))\n+ *   <li> \n+ * </ul>\n+ * <p>\n+ * The following example outputs the first 3 even numbers in the range [1, 10] into a list:\n+ * <pre>\n+ *   FluentIterable\n+ *       .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n+ *       .filter(new Predicate<Integer>() {\n+ *                   public boolean evaluate(Integer number) {\n+ *                        return number % 2 == 0;\n+ *                   }\n+ *              )\n+ *       .transform(TransformerUtils.stringValueTransformer())\n+ *       .limit(3)\n+ *       .toList();\n+ * </pre>\n+ *\n+ * @param <E>  the element type\n+ * @since 4.1\n+ * @version $Id: $\n+ */\n+public class FluentIterable<E> implements Iterable<E> {\n+\n+    private final Iterable<E> iterable;\n+\n+    // Static factory methods\n+    // ----------------------------------------------------------------------\n+\n+    public static <T> FluentIterable<T> of(T... elements) {\n+        return of(Arrays.asList(elements));\n+    }\n+    \n+    public static <T> FluentIterable<T> of(Iterable<T> iterable) {\n+        if (iterable == null) {\n+            throw new NullPointerException(\"Iterable must not be null\");\n+        }\n+        if (iterable instanceof FluentIterable<?>) {\n+            return (FluentIterable<T>) iterable;\n+        } else {\n+            return new FluentIterable<T>(iterable);\n+        }\n+    }\n+\n+    // Constructor\n+    // ----------------------------------------------------------------------\n+\n+    private FluentIterable(final Iterable<E> iterable) {\n+        this.iterable = iterable;\n+    }\n+\n+    // fluent construction methods\n+    // ----------------------------------------------------------------------\n+\n+    public FluentIterable<E> append(final E... elements) {\n+        return append(Arrays.asList(elements));\n+    }\n+\n+    public FluentIterable<E> append(final Iterable<E> other) {\n+        return of(IterableUtils.chainedIterable(iterable, other));\n+    }\n+    \n+    public FluentIterable<E> eval() {\n+        return of(toList());\n+    }\n+\n+    public FluentIterable<E> filter(final Predicate<E> predicate) {\n+        return of(IterableUtils.filteredIterable(iterable, predicate));\n+    }\n+\n+    public FluentIterable<E> limit(final int maxSize) {\n+        return of(IterableUtils.boundedIterable(iterable, maxSize));\n+    }\n+\n+    public FluentIterable<E> loop() {\n+        return of(IterableUtils.loopingIterable(iterable));\n+    }\n+\n+    public FluentIterable<E> skip(int elementsToSkip) {\n+        return of(IterableUtils.skippingIterable(iterable, elementsToSkip));\n+    }\n+\n+    public <O> FluentIterable<O> transform(final Transformer<? super E, ? extends O> transformer) {\n+        return of(IterableUtils.transformedIterable(iterable, transformer));\n+    }\n+\n+    public FluentIterable<E> unique() {\n+        return of(IterableUtils.uniqueIterable(iterable));\n+    }\n+    \n+    // convenience methods\n+    // ----------------------------------------------------------------------\n+\n+    public Iterator<E> iterator() {\n+        return iterable.iterator();\n+    }\n+\n+    public Enumeration<E> asEnumeration() {\n+        return IteratorUtils.asEnumeration(iterator());\n+    }\n+\n+    public boolean allMatch(final Predicate<? super E> predicate) {\n+        return IterableUtils.matchesAll(iterable, predicate);\n+    }\n+\n+    public boolean anyMatch(final Predicate<? super E> predicate) {\n+        return IterableUtils.matchesAny(iterable, predicate);\n+    }\n+\n+    public boolean isEmpty() {\n+        return IterableUtils.isEmpty(iterable);\n+    }\n+\n+    public boolean contains(final Object object) {\n+        return IterableUtils.contains(iterable, object);\n+    }\n+\n+    public E get(int position) {\n+        return IterableUtils.get(iterable, position);\n+    }\n+\n+    public int size() {\n+        return IterableUtils.size(iterable);\n+    }\n+\n+    public void copyInto(final Collection<? super E> collection) {\n+        if (collection == null) {\n+            throw new NullPointerException(\"Collection must not be null\");\n+        }\n+\n+        for (final E element : iterable) {\n+            collection.add(element);\n+        }\n+    }\n+\n+    public E[] toArray(final Class<E> arrayClass) {\n+        return IteratorUtils.toArray(iterator(), arrayClass);\n+    }\n+\n+    public List<E> toList() {\n+        return IteratorUtils.toList(iterator());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return IterableUtils.toString(iterable);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/IterableUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IterableUtils.java\n  */\n package org.apache.commons.collections4;\n \n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.iterators.LazyIteratorChain;\n+import org.apache.commons.collections4.iterators.UniqueFilterIterator;\n+\n /**\n  * Provides utility methods and decorators for {@link Iterable} instances.\n  *\n  */\n public class IterableUtils {\n \n-    /**\n-     * Default prefix used while converting an Iterable to its String representation.\n-     */\n-    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n-\n-    /**\n-     * Default suffix used while converting an Iterable to its String representation.\n-     */\n-    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n-\n-    /**\n-     * Default delimiter used to delimit elements while converting an Iterable\n-     * to its String representation.\n-     */\n-    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n+    // Chained\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Combines two iterables into a single iterable.\n+     * <p>\n+     * The returned iterable has an iterator that traverses the elements in {@code a},\n+     * followed by the elements in {@code b}. The source iterators are not polled until\n+     * necessary.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param a  the first iterable\n+     * @param b  the second iterable\n+     * @return a new iterable, combining the provided iterables\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a, final Iterable<? extends E> b) {\n+        return chainedIterable(new Iterable[] {a, b});\n+    }\n+\n+    /**\n+     * Combines three iterables into a single iterable.\n+     * <p>\n+     * The returned iterable has an iterator that traverses the elements in {@code a},\n+     * followed by the elements in {@code b} and {@code c}. The source iterators are\n+     * not polled until necessary.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param a  the first iterable\n+     * @param b  the second iterable\n+     * @param c  the third iterable\n+     * @return a new iterable, combining the provided iterables\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n+                                                  final Iterable<? extends E> b,\n+                                                  final Iterable<? extends E> c) {\n+        return chainedIterable(new Iterable[] {a, b, c});\n+    }\n+\n+    /**\n+     * Combines four iterables into a single iterable.\n+     * <p>\n+     * The returned iterable has an iterator that traverses the elements in {@code a},\n+     * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n+     * iterators are not polled until necessary.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param a  the first iterable\n+     * @param b  the second iterable\n+     * @param c  the third iterable\n+     * @param d  the fourth iterable\n+     * @return a new iterable, combining the provided iterables\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n+                                                  final Iterable<? extends E> b,\n+                                                  final Iterable<? extends E> c,\n+                                                  final Iterable<? extends E> d) {\n+        return chainedIterable(new Iterable[] {a, b, c, d});\n+    }\n+\n+    /**\n+     * Combines the provided iterables into a single iterable.\n+     * <p>\n+     * The returned iterable has an iterator that traverses the elements in the order\n+     * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n+     * are not polled until necessary.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param iterables  the iterables to combine\n+     * @return a new iterable, combining the provided iterables\n+     */\n+    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n+        return new AbstractIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return new LazyIteratorChain<E>() {\n+\n+                    @Override\n+                    protected Iterator<? extends E> nextIterator(int count) {\n+                        if (count > iterables.length) {\n+                            return null;\n+                        } else {\n+                            return emptyIteratorIfNull(iterables[count - 1]);\n+                        }\n+                    }\n+                    \n+                };\n+            }\n+        };\n+    }\n+\n+    // Filtered\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a view of the given iterable that only contains elements matching\n+     * the provided predicate.\n+     * <p>\n+     * The returned iterable's iterator does not supports {@code remove()}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to filter, may be null\n+     * @param predicate  the predicate used to filter elements, must not be null\n+     * @return a filtered view on the specified iterable\n+     * @throws NullPointerException if predicate is null\n+     */\n+    public static <E> Iterable<E> filteredIterable(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n+        if (predicate == null) {\n+            throw new NullPointerException(\"predicate must not be null.\");\n+        }\n+\n+        return new AbstractIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n+            }\n+        };\n+    }\n+\n+    // Bounded\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a view of the given iterable that contains at most the given number\n+     * of elements.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to limit, may be null\n+     * @param maxSize  the maximum number of elements, must not be negative\n+     * @return a bounded view on the specified iterable\n+     * @throws IllegalArgumentException if maxSize is negative\n+     */\n+    public static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final int maxSize) {\n+        if (maxSize < 0) {\n+            throw new IllegalArgumentException(\"maxSize parameter must not be negative.\");\n+        }\n+\n+        return new AbstractIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return IteratorUtils.boundedIterator(emptyIteratorIfNull(iterable), maxSize);\n+            }            \n+        };\n+    }\n+\n+    // Looping\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a view of the given iterable which will cycle infinitely over\n+     * its elements.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} if\n+     * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n+     * cycles omit the removed element, which is no longer in {@code iterable}. The\n+     * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n+     * is empty.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to loop, may be null\n+     * @return a view of the iterable, providing an infinite loop over its elements\n+     */\n+    public static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n+        return new AbstractIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return new LazyIteratorChain<E>() {\n+                    @Override\n+                    protected Iterator<? extends E> nextIterator(int count) {\n+                        if (iterable != null) {\n+                            if (isEmpty(iterable)) {\n+                                return null;\n+                            } else {\n+                                return iterable.iterator();\n+                            }\n+                        } else {\n+                            return null;\n+                        }\n+                    }\n+                };\n+            }\n+        };\n+    }\n+\n+    // Skipping\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a view of the given iterable that skips the first N elements.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to use, may be null\n+     * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n+     * @return a view of the specified iterable, skipping the first N elements\n+     * @throws IllegalArgumentException if elementsToSkip is negative\n+     */\n+    public static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final int elementsToSkip) {\n+        if (elementsToSkip < 0) {\n+            throw new IllegalArgumentException(\"elementsToSkip parameter must not be negative.\");\n+        }\n+\n+        return new AbstractIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return IteratorUtils.skippingIterator(emptyIteratorIfNull(iterable), elementsToSkip);\n+            }            \n+        };\n+    }\n+\n+    // Transformed\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a transformed view of the given iterable where all of its elements\n+     * have been transformed by the provided transformer.\n+     * <p>\n+     * The returned iterable's iterator supports {@code remove()} when the corresponding\n+     * input iterator supports it.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to transform, may be null\n+     * @param transformer  the transformer , must not be null\n+     * @return a transformed view of the specified iterable\n+     * @throws NullPointerException if transformer is null\n+     */\n+    public static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable, final Transformer<? super I, ? extends O> transformer) {\n+        if (transformer == null) {\n+            throw new NullPointerException(\"transformer must not be null.\");\n+        }\n+\n+        return new AbstractIterable<O>() {\n+            @Override\n+            public Iterator<O> iterator() {\n+                return IteratorUtils.transformedIterator(emptyIteratorIfNull(iterable), transformer);\n+            }            \n+        };\n+    }\n+\n+    // Unique\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a unique view of the given iterable.\n+     * <p>\n+     * The returned iterable's iterator does not supports {@code remove()}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to transform, may be null\n+     * @return a unique view of the specified iterable\n+     */\n+    public static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n+        return new AbstractIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return new UniqueFilterIterator<E>(emptyIteratorIfNull(iterable));\n+            }            \n+        };\n+    }\n+\n+    // Utility methods\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns an empty iterator if the argument is <code>null</code>,\n+     * or returns {@code iterable.iterator()} otherwise.\n+     *\n+     * @param <E> the element type\n+     * @param iterable  the iterable, possibly <code>null</code>\n+     * @return an empty collection if the argument is <code>null</code>\n+     */\n+    public static <E> Iterator<E> emptyIteratorIfNull(final Iterable<E> iterable) {\n+        return iterable != null ? iterable.iterator() : IteratorUtils.<E>emptyIterator();\n+    }\n+\n+    /**\n+     * Answers true if a predicate is true for every element of an iterable.\n+     * <p>\n+     * A <code>null</code> or empty iterable returns true.\n+     *\n+     * @param <E>  the type of object the {@link Iterable} contains\n+     * @param input  the {@link Iterable} to use, may be null\n+     * @param predicate  the predicate to use, may not be null\n+     * @return true if every element of the collection matches the predicate or if the\n+     *   collection is empty, false otherwise\n+     * @throws NullPointerException if predicate is null\n+     */\n+    public static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n+        return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n+    }\n+\n+    /**\n+     * Answers true if a predicate is true for any element of the iterable.\n+     * <p>\n+     * A <code>null</code> or empty iterable returns false.\n+     *\n+     * @param <E>  the type of object the {@link Iterable} contains\n+     * @param input  the {@link Iterable} to use, may be null\n+     * @param predicate  the predicate to use, may not be null\n+     * @return true if any element of the collection matches the predicate, false otherwise\n+     * @throws NullPointerException if predicate is null\n+     */\n+    public static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n+        return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n+    }\n+\n+    /**\n+     * Answers true if the provided iterable is empty.\n+     * <p>\n+     * A <code>null</code> iterable returns true.\n+     *\n+     * @param iterable  the {@link Iterable to use}, may be null \n+     * @return true if the iterable is null or empty, false otherwise\n+     */\n+    public static boolean isEmpty(final Iterable<?> iterable) {\n+        if (iterable instanceof Collection<?>) {\n+            return ((Collection<?>) iterable).isEmpty();\n+        } else {\n+            return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n+        }\n+    }\n+\n+    /**\n+     * Checks if the object is contained in the given iterable.\n+     * <p>\n+     * A <code>null</code> or empty iterable returns false.\n+     *\n+     * @param <E>  the type of object the {@link Iterable} contains\n+     * @param iterator  the iterable to check, may be null\n+     * @param object  the object to check\n+     * @return true if the object is contained in the iterable, false otherwise\n+     */\n+    public static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n+        if (iterable instanceof Collection<?>) {\n+            return ((Collection<E>) iterable).contains(object);\n+        } else {\n+            return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n+        }\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * <p>\n+     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n+     *\n+     * @param <T> the type of object in the {@link Iterable}.\n+     * @param iterable  the {@link Iterable} to get a value from, may be null\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <T> T get(final Iterable<T> iterable, final int index) {\n+        CollectionUtils.checkIndexBounds(index);\n+        if (iterable instanceof List<?>) {\n+            return ((List<T>) iterable).get(index);\n+        }\n+        return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n+    }\n+\n+    /**\n+     * Returns the number of elements contained in the given iterator.\n+     * <p>\n+     * A <code>null</code> or empty iterator returns {@code 0}.\n+     *\n+     * @param iterable  the iterable to check, may be null\n+     * @return the number of elements contained in the iterable\n+     */\n+    public static int size(final Iterable<?> iterable) {\n+        if (iterable instanceof Collection<?>) {\n+            return ((Collection<?>) iterable).size();\n+        } else {\n+            return IteratorUtils.size(emptyIteratorIfNull(iterable));\n+        }\n+    }\n \n     /**\n      * Returns a string representation of the elements of the specified iterable.\n+     * <p>\n      * The string representation consists of a list of the iterable's elements,\n      * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n      * by the characters {@code \", \"} (a comma followed by a space). Elements are\n      * converted to strings as by {@code String.valueOf(Object)}.\n      *\n-     * @param <C>  the element type\n-     * @param iterable  the iterable to convert to a string\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to convert to a string, may be null\n      * @return a string representation of {@code iterable}\n-     * @throws IllegalArgumentException if {@code iterable} is null\n-     */\n-    public static <C> String toString(Iterable<C> iterable) {\n-        return toString(iterable, new Transformer<C, String>() {\n-            public String transform(C input) {\n-                return String.valueOf(input);\n-            }\n-        }, DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n+     */\n+    public static <E> String toString(final Iterable<E> iterable) {\n+        return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n     }\n \n     /**\n      * Returns a string representation of the elements of the specified iterable.\n+     * <p>\n      * The string representation consists of a list of the iterable's elements,\n      * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n      * by the characters {@code \", \"} (a comma followed by a space). Elements are\n      * converted to strings as by using the provided {@code transformer}.\n      *\n-     * @param <C>  the element type\n-     * @param iterable  the iterable to convert to a string\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to convert to a string, may be null\n      * @param transformer  the transformer used to get a string representation of an element\n      * @return a string representation of {@code iterable}\n-     * @throws IllegalArgumentException if {@code iterable} or {@code transformer} is null\n-     */\n-    public static <C> String toString(Iterable<C> iterable, Transformer<? super C, String> transformer) {\n-        return toString(iterable, transformer, DEFAULT_TOSTRING_DELIMITER,\n-                        DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n+     * @throws NullPointerException if {@code transformer} is null\n+     */\n+    public static <E> String toString(final Iterable<E> iterable,\n+                                      final Transformer<? super E, String> transformer) {\n+        if (transformer == null) {\n+            throw new NullPointerException(\"transformer may not be null\");\n+        }\n+        return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n     }\n \n     /**\n      * Returns a string representation of the elements of the specified iterable.\n+     * <p>\n      * The string representation consists of a list of the iterable's elements,\n      * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n      * are separated by the provided {@code delimiter}. Elements are converted to\n      * strings as by using the provided {@code transformer}.\n      *\n-     * @param <C>  the element type\n-     * @param iterable  the iterable to convert to a string\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to convert to a string, may be null\n      * @param transformer  the transformer used to get a string representation of an element\n      * @param delimiter  the string to delimit elements\n      * @param prefix  the prefix, prepended to the string representation\n      * @param suffix  the suffix, appended to the string representation\n      * @return a string representation of {@code iterable}\n-     * @throws IllegalArgumentException if any argument is null\n-     */\n-    public static <C> String toString(Iterable<C> iterable,\n-                                      Transformer<? super C, String> transformer,\n-                                      String delimiter,\n-                                      String prefix,\n-                                      String suffix) {\n-        if (iterable == null) {\n-            throw new IllegalArgumentException(\"iterable may not be null\");\n-        }\n-        if (transformer == null) {\n-            throw new IllegalArgumentException(\"transformer may not be null\");\n-        }\n-        if (delimiter == null) {\n-            throw new IllegalArgumentException(\"delimiter may not be null\");\n-        }\n-        if (prefix == null) {\n-            throw new IllegalArgumentException(\"prefix may not be null\");\n-        }\n-        if (suffix == null) {\n-            throw new IllegalArgumentException(\"suffix may not be null\");\n-        }\n-        final StringBuilder stringBuilder = new StringBuilder(prefix);\n-        for(final C element : iterable) {\n-            stringBuilder.append(transformer.transform(element));\n-            stringBuilder.append(delimiter);\n-        }\n-        if(stringBuilder.length() > prefix.length()) {\n-            stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n-        }\n-        stringBuilder.append(suffix);\n-        return stringBuilder.toString();\n+     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n+     */\n+    public static <E> String toString(final Iterable<E> iterable,\n+                                      final Transformer<? super E, String> transformer,\n+                                      final String delimiter,\n+                                      final String prefix,\n+                                      final String suffix) {\n+        return IteratorUtils.toString(emptyIteratorIfNull(iterable),\n+                                      transformer, delimiter, prefix, suffix);\n+    }\n+\n+    // Inner classes\n+    // ----------------------------------------------------------------------\n+\n+    private static abstract class AbstractIterable<E> implements Iterable<E> {\n+        @Override\n+        public String toString() {\n+            return IterableUtils.toString(this);\n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n import java.util.ListIterator;\n import java.util.Map;\n \n+import org.apache.commons.collections4.functors.EqualPredicate;\n import org.apache.commons.collections4.iterators.ArrayIterator;\n import org.apache.commons.collections4.iterators.ArrayListIterator;\n import org.apache.commons.collections4.iterators.BoundedIterator;\n import org.apache.commons.collections4.iterators.PushbackIterator;\n import org.apache.commons.collections4.iterators.SingletonIterator;\n import org.apache.commons.collections4.iterators.SingletonListIterator;\n+import org.apache.commons.collections4.iterators.SkippingIterator;\n import org.apache.commons.collections4.iterators.TransformIterator;\n import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n import org.apache.commons.collections4.iterators.UnmodifiableListIterator;\n     public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n \n     /**\n+     * Default prefix used while converting an Iterator to its String representation.\n+     */\n+    private static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n+\n+    /**\n+     * Default suffix used while converting an Iterator to its String representation.\n+     */\n+    private static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n+\n+    /**\n+     * Default delimiter used to delimit elements while converting an Iterator\n+     * to its String representation.\n+     */\n+    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n+\n+    /**\n      * IteratorUtils is not normally instantiated.\n      */\n-    private IteratorUtils() {}\n+    private IteratorUtils() {}    \n \n     // Empty\n     //-----------------------------------------------------------------------\n      * @param iterator  the iterator to decorate\n      * @param max  the maximum number of elements returned by this iterator\n      * @return a new bounded iterator\n-     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n+     * @throws IllegalArgumentException if the iterator is null or max is negative\n      * @since 4.1\n      */\n     public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n     public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n                                                          long offset, long max) {\n         return new BoundedIterator<E>(iterator, offset, max);\n+    }\n+\n+    // Skipping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator to skip the first N elements.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @param offset  the first number of elements to skip\n+     * @return a new skipping iterator\n+     * @throws IllegalArgumentException if the iterator is null or offset is negative\n+     * @since 4.1\n+     */\n+    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, long offset) {\n+        return new SkippingIterator<E>(iterator, offset);\n     }\n \n     // Unmodifiable\n         return singletonIterator(obj);\n     }\n \n+    // Utility methods\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Answers true if a predicate is true for any element of the iterator.\n+     * <p>\n+     * A <code>null</code> or empty iterator returns false.\n+     *\n+     * @param <E>  the type of object the {@link Iterator} contains\n+     * @param input  the {@link Iterator} to use, may be null\n+     * @param predicate  the predicate to use, may not be null\n+     * @return true if any element of the collection matches the predicate, false otherwise\n+     * @throws NullPointerException if predicate is null\n+     * @since 4.1\n+     */\n+    public static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n+        if (predicate == null) {\n+            throw new NullPointerException(\"Predicate must not be null\");\n+        }\n+\n+        if (iterator != null) {\n+            while (iterator.hasNext()) {\n+                final E element = iterator.next();\n+                if (predicate.evaluate(element)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Answers true if a predicate is true for every element of an iterator.\n+     * <p>\n+     * A <code>null</code> or empty iterator returns true.\n+     *\n+     * @param <E>  the type of object the {@link Iterator} contains\n+     * @param input  the {@link Iterator} to use, may be null\n+     * @param predicate  the predicate to use, may not be null\n+     * @return true if every element of the collection matches the predicate or if the\n+     *   collection is empty, false otherwise\n+     * @throws NullPointerException if predicate is null\n+     * @since 4.1\n+     */\n+    public static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n+        if (predicate == null) {\n+            throw new NullPointerException(\"Predicate must not be null\");\n+        }\n+\n+        if (iterator != null) {\n+            while (iterator.hasNext()) {\n+                final E element = iterator.next();\n+                if (!predicate.evaluate(element)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if the given iterator is empty.\n+     * <p>\n+     * A <code>null</code> or empty iterator returns true.\n+     *\n+     * @param iterator  the {@link Iterator} to use, may be null\n+     * @return true if the iterator is exhausted or null, false otherwise\n+     * @since 4.1\n+     */\n+    public static boolean isEmpty(final Iterator<?> iterator) {\n+        return iterator == null || !iterator.hasNext();\n+    }\n+\n+    /**\n+     * Checks if the object is contained in the given iterator.\n+     * <p>\n+     * A <code>null</code> or empty iterator returns false.\n+     *\n+     * @param <E>  the type of object the {@link Iterator} contains\n+     * @param iterator  the iterator to check, may be null\n+     * @param object  the object to check\n+     * @return true if the object is contained in the iterator, false otherwise\n+     * @since 4.1\n+     */\n+    public static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n+        return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * <p>\n+     * The Iterator is advanced to <code>index</code> (or to the end, if\n+     * <code>index</code> exceeds the number of entries) as a side effect of this method.\n+     *\n+     * @param <E>  the type of object in the {@link Iterator}\n+     * @param iterator  the iterator to get a value from\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @throws IllegalArgumentException if the object type is invalid\n+     * @since 4.1\n+     */\n+    public static <E> E get(final Iterator<E> iterator, final int index) {\n+        int i = index;\n+        CollectionUtils.checkIndexBounds(i);\n+        while (iterator.hasNext()) {\n+            i--;\n+            if (i == -1) {\n+                return iterator.next();\n+            }\n+            iterator.next();\n+        }\n+        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+    }\n+\n+    /**\n+     * Returns the number of elements contained in the given iterator.\n+     * <p>\n+     * A <code>null</code> or empty iterator returns {@code 0}.\n+     *\n+     * @param iterator  the iterator to check, may be null\n+     * @return the number of elements contained in the iterator\n+     * @since 4.1\n+     */\n+    public static int size(final Iterator<?> iterator) {\n+        int size = 0;\n+        if (iterator != null) {\n+            while (iterator.hasNext()) {\n+                iterator.next();\n+                size++;\n+            }\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Returns a string representation of the elements of the specified iterator.\n+     * <p>\n+     * The string representation consists of a list of the iterator's elements,\n+     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n+     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n+     * converted to strings as by {@code String.valueOf(Object)}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterator to convert to a string\n+     * @return a string representation of {@code iterator}\n+     * @since 4.1\n+     */\n+    public static <E> String toString(final Iterator<E> iterator) {\n+        return toString(iterator, TransformerUtils.stringValueTransformer(),\n+                        DEFAULT_TOSTRING_DELIMITER, DEFAULT_TOSTRING_PREFIX,\n+                        DEFAULT_TOSTRING_SUFFIX);\n+    }\n+\n+    /**\n+     * Returns a string representation of the elements of the specified iterator.\n+     * <p>\n+     * The string representation consists of a list of the iterable's elements,\n+     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n+     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n+     * converted to strings as by using the provided {@code transformer}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterator to convert to a string, may be null\n+     * @param transformer  the transformer used to get a string representation of an element\n+     * @return a string representation of {@code iterator}\n+     * @throws NullPointerException if {@code transformer} is null\n+     * @since 4.1\n+     */\n+    public static <E> String toString(final Iterator<E> iterator,\n+                                      final Transformer<? super E, String> transformer) {\n+        return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER,\n+                        DEFAULT_TOSTRING_PREFIX, DEFAULT_TOSTRING_SUFFIX);\n+    }\n+\n+    /**\n+     * Returns a string representation of the elements of the specified iterator.\n+     * <p>\n+     * The string representation consists of a list of the iterator's elements,\n+     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n+     * are separated by the provided {@code delimiter}. Elements are converted to\n+     * strings as by using the provided {@code transformer}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to convert to a string, may be null\n+     * @param transformer  the transformer used to get a string representation of an element\n+     * @param delimiter  the string to delimit elements\n+     * @param prefix  the prefix, prepended to the string representation\n+     * @param suffix  the suffix, appended to the string representation\n+     * @return a string representation of {@code iterator}\n+     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n+     * @since 4.1\n+     */\n+    public static <E> String toString(final Iterator<E> iterator,\n+                                      final Transformer<? super E, String> transformer,\n+                                      final String delimiter,\n+                                      final String prefix,\n+                                      final String suffix) {\n+        if (transformer == null) {\n+            throw new NullPointerException(\"transformer may not be null\");\n+        }\n+        if (delimiter == null) {\n+            throw new NullPointerException(\"delimiter may not be null\");\n+        }\n+        if (prefix == null) {\n+            throw new NullPointerException(\"prefix may not be null\");\n+        }\n+        if (suffix == null) {\n+            throw new NullPointerException(\"suffix may not be null\");\n+        }\n+        final StringBuilder stringBuilder = new StringBuilder(prefix);\n+        if (iterator != null) {\n+            while (iterator.hasNext()) {\n+                final E element = iterator.next();\n+                stringBuilder.append(transformer.transform(element));\n+                stringBuilder.append(delimiter);\n+            }\n+            if(stringBuilder.length() > prefix.length()) {\n+                stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n+            }\n+        }\n+        stringBuilder.append(suffix);\n+        return stringBuilder.toString();\n+    }\n+\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Decorates another iterator to skip the first N elements.\n+ * <p>\n+ * In case an offset parameter other than 0 is provided, the decorated\n+ * iterator is immediately advanced to this position, skipping all elements\n+ * before that position.\n+ *\n+ * @since 4.1\n+ * @version $Id: $\n+ */\n+public class SkippingIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+    /** The offset to bound the first element return */\n+    private final long offset;\n+\n+    /** The position of the current element */\n+    private long pos;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Decorates the specified iterator to skip all elements until the iterator\n+     * reaches the position at {@code offset}.\n+     * <p>\n+     * The iterator is immediately advanced until it reaches the position at {@code offset},\n+     * incurring O(n) time.\n+     *\n+     * @param iterator  the iterator to be decorated\n+     * @param offset  the index of the first element of the decorated iterator to return\n+     * @throws IllegalArgumentException if iterator is null, or offset is negative\n+     */\n+    public SkippingIterator(final Iterator<E> iterator, final long offset) {\n+        super(iterator);\n+\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Offset parameter must not be negative.\");\n+        }\n+\n+        this.offset = offset;\n+        this.pos = 0;\n+        init();\n+    }\n+\n+    /**\n+     * Skips the given number of elements.\n+     */\n+    private void init() {\n+        while (pos < offset && hasNext()) {\n+            next();\n+            pos++;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public E next() {\n+        final E next = super.next();\n+        pos++;\n+        return next;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * In case an offset other than 0 was specified, the underlying iterator will be advanced\n+     * to this position upon creation. A call to {@link #remove()} will still result in an\n+     * {@link IllegalStateException} if no explicit call to {@link #next()} has been made prior\n+     * to calling {@link #remove()}.\n+     */\n+    @Override\n+    public void remove() {\n+        if (pos <= offset) {\n+            throw new IllegalStateException(\"remove() can not be called before calling next()\");\n+        }\n+        super.remove();\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n         result = IterableUtils.toString(new ArrayList<Integer>());\n         assertEquals(\"[]\", result);\n \n-        try {\n-            IterableUtils.toString(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n-            // expected\n-        }\n+        result = IterableUtils.toString(null);\n+        assertEquals(\"[]\", result);\n \n         result = IterableUtils.toString(iterableA, new Transformer<Integer, String>() {\n             public String transform(Integer input) {\n         });\n         assertEquals(\"[]\", result);\n \n-        try {\n-            IterableUtils.toString(null, new Transformer<Integer, String>() {\n-                public String transform(Integer input) {\n-                    fail(\"not supposed to reach here\");\n-                    return \"\";\n-                }\n-            });\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n-            // expected\n-        }\n+        result = IterableUtils.toString(null, new Transformer<Integer, String>() {\n+            public String transform(Integer input) {\n+                fail(\"not supposed to reach here\");\n+                return \"\";\n+            }\n+        });\n+        assertEquals(\"[]\", result);\n     }\n     \n     public void testToStringDelimiter() {\n     }\n     \n     public void testToStringWithNullArguments() {\n-        try {\n-            IterableUtils.toString(null, new Transformer<Integer, String>() {\n-                public String transform(Integer input) {\n-                    fail(\"not supposed to reach here\");\n-                    return \"\";\n-                }\n-            }, \"\", \"(\", \")\");\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n-            // expected\n-        }\n+        String result = IterableUtils.toString(null, new Transformer<Integer, String>() {\n+            public String transform(Integer input) {\n+                fail(\"not supposed to reach here\");\n+                return \"\";\n+            }\n+        }, \"\", \"(\", \")\");\n+        assertEquals(\"()\", result);\n \n         try {\n             IterableUtils.toString(new ArrayList<Integer>(), null, \"\", \"(\", \")\");\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n+            fail(\"expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n \n                     return \"\";\n                 }\n             }, null, \"(\", \")\");\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n+            fail(\"expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n \n                     return \"\";\n                 }\n             }, \"\", null, \")\");\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n+            fail(\"expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n \n                     return \"\";\n                 }\n             }, \"\", \"(\", null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (final IllegalArgumentException iae) {\n+            fail(\"expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }", "timestamp": 1432655649, "metainfo": ""}