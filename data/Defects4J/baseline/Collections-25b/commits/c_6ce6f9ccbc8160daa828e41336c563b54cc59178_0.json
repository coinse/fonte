{"sha": "6ce6f9ccbc8160daa828e41336c563b54cc59178", "log": "* add ArrayIntList, AbstractRandomAccessIntList * add missing addAll(int,IntCollection) method to IntList * add tests   ", "commit": "\n--- a/src/java/org/apache/commons/collections/primitives/AbstractIntCollection.java\n+++ b/src/java/org/apache/commons/collections/primitives/AbstractIntCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/primitives/Attic/AbstractIntCollection.java,v 1.1 2003/01/05 03:03:14 rwaldhoff Exp $\n- * $Revision: 1.1 $\n- * $Date: 2003/01/05 03:03:14 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/primitives/Attic/AbstractIntCollection.java,v 1.2 2003/01/06 03:59:12 rwaldhoff Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/06 03:59:12 $\n  *\n  * ====================================================================\n  *\n package org.apache.commons.collections.primitives;\n \n /**\n- * @version $Revision: 1.1 $ $Date: 2003/01/05 03:03:14 $\n+ * @version $Revision: 1.2 $ $Date: 2003/01/06 03:59:12 $\n  * @author Rodney Waldhoff \n  */\n abstract class AbstractIntCollection implements IntCollection {\n     public abstract IntIterator iterator();\n     public abstract int size();\n           \n-    \n     protected AbstractIntCollection() { }\n               \n     /** Unsupported in this base implementation. */\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/primitives/AbstractRandomAccessIntList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/primitives/Attic/AbstractRandomAccessIntList.java,v 1.1 2003/01/06 03:59:12 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/01/06 03:59:12 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections.primitives;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public abstract class AbstractRandomAccessIntList extends AbstractIntCollection implements IntList {\n+\n+    // constructors\n+    //-------------------------------------------------------------------------\n+\n+    protected AbstractRandomAccessIntList() { }    \n+\n+    // fully abstract methods\n+    //-------------------------------------------------------------------------\n+    \n+    public abstract int get(int index);\n+    public abstract int size();\n+\n+    // unsupported in base\n+    //-------------------------------------------------------------------------\n+    \n+    public int removeElementAt(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    public int set(int index, int element) {\n+        throw new UnsupportedOperationException();\n+    }\n+        \n+    public void add(int index, int element) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    public boolean add(int element) {\n+        add(size(),element);\n+        return true;\n+    }\n+\n+    public boolean addAll(int index, IntCollection collection) {\n+        boolean modified = false;\n+        for(IntIterator iter = collection.iterator(); iter.hasNext(); ) {\n+            add(index++,iter.next());\n+            modified = true;\n+        }\n+        return modified;\n+    }\n+\n+    public int indexOf(int element) {\n+        int i = 0;\n+        for(IntIterator iter = iterator(); iter.hasNext(); ) {\n+            if(iter.next() == element) { \n+                return i;\n+            } else {\n+                i++;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public int lastIndexOf(int element) {\n+        for(IntListIterator iter = listIterator(size()); iter.hasPrevious(); ) {\n+            if(iter.previous() == element) {\n+                return iter.nextIndex();\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public IntIterator iterator() {\n+        return listIterator();\n+    }\n+\n+    public IntListIterator listIterator() {\n+        return listIterator(0);\n+    }\n+\n+    public IntListIterator listIterator(int index) {\n+        return new RandomAccessIntListIterator(this,index);            \n+    }\n+\n+    public IntList subList(int fromIndex, int toIndex) {\n+        return new RandomAccessIntSubList(this,fromIndex,toIndex);\n+    }\n+\n+    public boolean equals(Object that) {\n+        // handle an easy and somewhat frequent case via a shortcut\n+        if(this == that) { return true; } \n+\n+        // otherwise, try to get an IntIterator from that object\n+        IntIterator thatIter = null;        \n+        if(that instanceof IntList) {\n+            if(size() != ((IntList)that).size()) { return false; } // another quick check\n+            thatIter = ((IntList)that).iterator();\n+        } else if(that instanceof List) {\n+            if(size() != ((List)that).size()) { return false; } // another quick check\n+            thatIter = IteratorIntIterator.wrap(((List)that).iterator());\n+        }\n+        \n+        if(null == thatIter) { return false; }\n+        \n+        // walk thru thisIter and thatIter, checking for any differences\n+        for(IntIterator thisIter = iterator(); thisIter.hasNext();) {\n+            if(!thatIter.hasNext()) { return false; } // thatIter has a different length\n+            if(thisIter.next() != thatIter.next()) { \n+                return false; \n+            }\n+        }\n+        \n+        if(thatIter.hasNext()) { return false; } // thatIter has a different length\n+        \n+        return true;\n+    }\n+    \n+    public int hashCode() {\n+        int hash = 1;\n+        for(IntIterator iter = iterator(); iter.hasNext(); ) {\n+            hash = 31*hash + iter.next();\n+        }\n+        return hash;\n+    }\n+    \n+    // protected utilities\n+    //-------------------------------------------------------------------------\n+    \n+    protected int getModCount() {\n+        return _modCount;\n+    }\n+\n+    protected void incrModCount() {\n+        _modCount++;\n+    }\n+\n+    // attributes\n+    //-------------------------------------------------------------------------\n+    \n+    private int _modCount = 0;\n+\n+    // inner classes\n+    //-------------------------------------------------------------------------\n+    \n+    protected static class ComodChecker {\n+        ComodChecker(AbstractRandomAccessIntList source) {\n+            _source = source;  \n+            resyncModCount();             \n+        }\n+        \n+        protected AbstractRandomAccessIntList getList() {\n+            return _source;\n+        }\n+        \n+        protected void assertNotComodified() throws ConcurrentModificationException {\n+            if(_expectedModCount != getList().getModCount()) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+            \n+        protected void resyncModCount() {\n+            _expectedModCount = getList().getModCount();\n+        }\n+        \n+        private AbstractRandomAccessIntList _source = null;\n+        private int _expectedModCount = -1;\n+    }\n+    \n+    protected static class RandomAccessIntListIterator extends ComodChecker implements IntListIterator {\n+        RandomAccessIntListIterator(AbstractRandomAccessIntList list) {\n+            this(list,0);\n+        }\n+            \n+        RandomAccessIntListIterator(AbstractRandomAccessIntList list, int index) {\n+            super(list);\n+            if(index < 0 || index > getList().size()) {\n+                throw new IllegalArgumentException(\"Index \" + index + \" not in [0,\" + getList().size() + \")\");\n+            } else {\n+                _nextIndex = index;\n+                resyncModCount();\n+            }\n+        }\n+            \n+        public boolean hasNext() {\n+            assertNotComodified();\n+            return _nextIndex < getList().size();\n+        }\n+        \n+        public boolean hasPrevious() {\n+            assertNotComodified();\n+            return _nextIndex > 0;\n+        }\n+        \n+        public int nextIndex() {\n+            assertNotComodified();\n+            return _nextIndex;\n+        }\n+        \n+        public int previousIndex() {\n+            assertNotComodified();\n+            return _nextIndex - 1;\n+        }\n+        \n+        public int next() {\n+            assertNotComodified();\n+            if(!hasNext()) {\n+                throw new NoSuchElementException();\n+            } else {\n+                int val = getList().get(_nextIndex);\n+                _lastReturnedIndex = _nextIndex;\n+                _nextIndex++;\n+                return val;\n+            }\n+        }\n+        \n+        public int previous() {\n+            assertNotComodified();\n+            if(!hasPrevious()) {\n+                throw new NoSuchElementException();\n+            } else {\n+                int val = getList().get(_nextIndex-1);\n+                _lastReturnedIndex = _nextIndex-1;\n+                _nextIndex--;\n+                return val;\n+            }\n+        }\n+        \n+        public void add(int value) {\n+            assertNotComodified();\n+            getList().add(_nextIndex,value);\n+            _nextIndex++;\n+            _lastReturnedIndex = -1;\n+            resyncModCount();\n+        }\n+    \n+        public void remove() {\n+            assertNotComodified();\n+            if(-1 == _lastReturnedIndex) {\n+                throw new IllegalStateException();\n+            } else {\n+                getList().removeElementAt(_lastReturnedIndex);\n+                _lastReturnedIndex = -1;\n+                _nextIndex--;\n+                resyncModCount();\n+            }\n+        }\n+        \n+        public void set(int value) {\n+            assertNotComodified();\n+            if(-1 == _lastReturnedIndex) {\n+                throw new IllegalStateException();\n+            } else {\n+                getList().set(_lastReturnedIndex,value);\n+                resyncModCount();\n+            }\n+        }\n+        \n+        private int _nextIndex = 0;\n+        private int _lastReturnedIndex = -1;        \n+    }   \n+\n+    protected static class RandomAccessIntSubList extends AbstractRandomAccessIntList implements IntList {\n+        RandomAccessIntSubList(AbstractRandomAccessIntList list, int fromIndex, int toIndex) {\n+            if(fromIndex < 0 || toIndex > list.size() || fromIndex > toIndex) {\n+                throw new IllegalArgumentException();\n+            } else {\n+                _list = list;\n+                _offset = fromIndex;\n+                _limit = toIndex - fromIndex;\n+                _comod = new ComodChecker(list);\n+                _comod.resyncModCount();\n+            }            \n+        }\n+    \n+        public int get(int index) {\n+            checkRange(index);\n+            _comod.assertNotComodified();\n+            return _list.get(toUnderlyingIndex(index));\n+        }\n+    \n+        public int removeElementAt(int index) {\n+            checkRange(index);\n+            _comod.assertNotComodified();\n+            int val = _list.removeElementAt(toUnderlyingIndex(index));\n+            _limit--;\n+            _comod.resyncModCount();\n+            incrModCount();\n+            return val;\n+        }\n+    \n+        public int set(int index, int element) {\n+            checkRange(index);\n+            _comod.assertNotComodified();\n+            int val = _list.set(toUnderlyingIndex(index),element);\n+            incrModCount();\n+            _comod.resyncModCount();\n+            return val;\n+        }\n+    \n+        public void add(int index, int element) {\n+            checkRangeIncludingEndpoint(index);\n+            _comod.assertNotComodified();\n+             _list.add(toUnderlyingIndex(index),element);\n+            _limit++;\n+            _comod.resyncModCount();\n+            incrModCount();\n+        }\n+    \n+        public int size() {\n+            _comod.assertNotComodified();\n+            return _limit;\n+        }\n+    \n+        private void checkRange(int index) {\n+            if(index < 0 || index >= size()) {\n+                throw new IllegalArgumentException(\"index \" + index + \" not in [0,\" + size() + \")\");\n+            }\n+        }\n+          \n+        private void checkRangeIncludingEndpoint(int index) {\n+            if(index < 0 || index > size()) {\n+                throw new IllegalArgumentException(\"index \" + index + \" not in [0,\" + size() + \"]\");\n+            }\n+        }\n+          \n+        private int toUnderlyingIndex(int index) {\n+            return (index + _offset);\n+        }\n+        \n+        private int _offset = 0;        \n+        private int _limit = 0; \n+        private AbstractRandomAccessIntList _list = null;\n+        private ComodChecker _comod = null;\n+    \n+    }\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/primitives/ArrayIntList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/primitives/Attic/ArrayIntList.java,v 1.1 2003/01/06 03:59:12 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/01/06 03:59:12 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections.primitives;\n+\n+public class ArrayIntList extends AbstractRandomAccessIntList implements IntList {\n+\n+    // constructors\n+    //-------------------------------------------------------------------------\n+\n+    protected ArrayIntList() {\n+        this(8);\n+    }    \n+\n+    protected ArrayIntList(int initialCapacity) {\n+        if(initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"capacity \" + initialCapacity);\n+        }\n+        _data = new int[initialCapacity];\n+        _size = 0;\n+    }    \n+\n+    // IntList methods\n+    //-------------------------------------------------------------------------\n+\n+    public int get(int index) {\n+        checkRange(index);\n+        return _data[index];\n+    }\n+    \n+    public int size() {\n+        return _size;\n+    }\n+    \n+    public int removeElementAt(int index) {\n+        checkRange(index);\n+        incrModCount();\n+        int oldval = _data[index];\n+        int numtomove = _size - index - 1;\n+        if(numtomove > 0) {\n+            System.arraycopy(_data,index+1,_data,index,numtomove);\n+        }\n+        _size--;\n+        return oldval;\n+    }\n+    \n+    public int set(int index, int element) {\n+        checkRange(index);\n+        incrModCount();\n+        int oldval = _data[index];\n+        _data[index] = element;\n+        return oldval;\n+    }\n+        \n+    public void add(int index, int element) {\n+        checkRangeIncludingEndpoint(index);\n+        incrModCount();\n+        ensureCapacity(_size+1);\n+        int numtomove = _size-index;\n+        System.arraycopy(_data,index,_data,index+1,numtomove);\n+        _data[index] = element;\n+        _size++;\n+    }\n+\n+    // capacity methods\n+    //-------------------------------------------------------------------------\n+\n+    public void ensureCapacity(int mincap) {\n+        incrModCount();\n+        if(mincap > _data.length) {\n+            int newcap = (_data.length * 3)/2 + 1;\n+            int[] olddata = _data;\n+            _data = new int[newcap < mincap ? mincap : newcap];\n+            System.arraycopy(olddata,0,_data,0,_size);\n+        }\n+    }\n+\n+    public void trimToSize() {\n+        incrModCount();\n+        if(_size < _data.length) {\n+            int[] olddata = _data;\n+            _data = new int[_size];\n+            System.arraycopy(olddata,0,_data,0,_size);\n+        }\n+    }\n+\n+    // private methods\n+    //-------------------------------------------------------------------------\n+    private final void checkRange(int index) {\n+        if(index < 0 || index >= _size) {\n+            throw new IndexOutOfBoundsException(\"Should be at least 0 and less than \" + _size + \", found \" + index);\n+        }\n+    }\n+\n+    private final void checkRangeIncludingEndpoint(int index) {\n+        if(index < 0 || index > _size) {\n+            throw new IndexOutOfBoundsException(\"Should be at least 0 and at most \" + _size + \", found \" + index);\n+        }\n+    }\n+\n+    // attributes\n+    //-------------------------------------------------------------------------\n+    \n+    private transient int[] _data = null;\n+    private int _size = 0;\n+\n+}\n--- a/src/java/org/apache/commons/collections/primitives/IntList.java\n+++ b/src/java/org/apache/commons/collections/primitives/IntList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/primitives/Attic/IntList.java,v 1.2 2003/01/04 23:16:29 rwaldhoff Exp $\n- * $Revision: 1.2 $\n- * $Date: 2003/01/04 23:16:29 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/primitives/Attic/IntList.java,v 1.3 2003/01/06 03:59:12 rwaldhoff Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/06 03:59:12 $\n  *\n  * ====================================================================\n  *\n /**\n  * An ordered collection (a {@link java.util.List}) of int values.\n  *\n- * @version $Revision: 1.2 $ $Date: 2003/01/04 23:16:29 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/06 03:59:12 $\n  * @author Rodney Waldhoff \n  */\n-public interface IntList {\n+public interface IntList extends IntCollection {\n     /** \n      * Inserts the specified element at the specified position \n      * within me (optional operation). \n      */\n     void add(int index, int element);\n           \n+    boolean addAll(int index, IntCollection collection);\n+    \n     /** \n      * Returns the element at the specified position within \n      * me. \n--- a/src/test/org/apache/commons/collections/primitives/TestAll.java\n+++ b/src/test/org/apache/commons/collections/primitives/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/primitives/Attic/TestAll.java,v 1.2 2002/06/04 16:50:09 rwaldhoff Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/04 16:50:09 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/primitives/Attic/TestAll.java,v 1.3 2003/01/06 03:59:12 rwaldhoff Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/01/06 03:59:12 $\n  *\n  * ====================================================================\n  *\n import junit.framework.TestSuite;\n \n /**\n- * @version $Revision: 1.2 $ $Date: 2002/06/04 16:50:09 $\n+ * @version $Revision: 1.3 $ $Date: 2003/01/06 03:59:12 $\n  * @author Rodney Waldhoff\n  */\n public class TestAll extends TestCase {\n \n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n+        suite.addTest(TestArrayIntList.suite());\n         suite.addTest(TestUnsignedByteArrayList.suite());\n         suite.addTest(TestShortArrayList.suite());\n         suite.addTest(TestUnsignedShortArrayList.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/primitives/TestArrayIntList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/primitives/Attic/TestArrayIntList.java,v 1.1 2003/01/06 03:59:12 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/01/06 03:59:12 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections.primitives;\n+\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.TestList;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2003/01/06 03:59:12 $\n+ * @author Rodney Waldhoff\n+ */\n+public class TestArrayIntList extends TestList {\n+\n+    //------------------------------------------------------------ Conventional\n+\n+    public TestArrayIntList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = BulkTest.makeSuite(TestArrayIntList.class);\n+        return suite;\n+    }\n+\n+\n+    //------------------------------------------------------- TestList interface\n+\n+    public List makeEmptyList() {\n+        return new IntListList(new ArrayIntList());\n+    }\n+\n+    /**\n+     *  Returns small Integer objects for testing.\n+     */\n+    protected Object[] getFullElements() {\n+        Integer[] result = new Integer[19];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = new Integer(i + 19);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     *  Returns small Integer objects for testing.\n+     */\n+    protected Object[] getOtherElements() {\n+        Integer[] result = new Integer[16];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = new Integer(i + 48);\n+        }\n+        return result;\n+    }\n+\n+    // TODO:  Create canonical collections in CVS\n+\n+    public void testCanonicalEmptyCollectionExists() {\n+    }\n+\n+    public void testCanonicalFullCollectionExists() {\n+    }\n+\n+    public void testEmptyListCompatibility() {\n+    }\n+\n+    public void testFullListCompatibility() {\n+    }\n+\n+    //------------------------------------------------------------------- Tests\n+\n+    public void testClearAndSize() {\n+        IntList list = new ArrayIntList();\n+        assertEquals(0, list.size());\n+        for (int i = 0; i < 100; i++) {\n+            list.add(i);\n+        }\n+        assertEquals(100, list.size());\n+        list.clear();\n+        assertEquals(0, list.size());\n+    }\n+\n+    public void testAddGet() {\n+        IntList list = new ArrayIntList();\n+        for (int i = 0; i < 1000; i++) {\n+            list.add(i);\n+        }\n+        for (int i = 0; i < 1000; i++) {\n+            assertEquals(i, list.get(i));\n+        }\n+    }\n+\n+    public void testAddGetLargeValues() {\n+        IntList list = new ArrayIntList();\n+        for (int i = 0; i < 1000; i++) {\n+            int value = ((int) (Short.MAX_VALUE));\n+            value += i;\n+            list.add(value);\n+        }\n+        for (int i = 0; i < 1000; i++) {\n+            int value = ((int) (Short.MAX_VALUE));\n+            value += i;\n+            assertEquals(value, list.get(i));\n+        }\n+    }\n+\n+    public void testAddAndShift() {\n+        IntList list = new ArrayIntList();\n+        list.add(0, 1);\n+        assertEquals(\"Should have one entry\", 1, list.size());\n+        list.add(3);\n+        list.add(4);\n+        list.add(1, 2);\n+        for(int i = 0; i < 4; i++) {\n+            assertEquals(\"Should get entry back\", i + 1, list.get(i));\n+        }\n+        list.add(0, 0);\n+        for (int i = 0; i < 5; i++) {\n+            assertEquals(\"Should get entry back\", i, list.get(i));\n+        }\n+    }\n+}", "timestamp": 1041825552, "metainfo": ""}