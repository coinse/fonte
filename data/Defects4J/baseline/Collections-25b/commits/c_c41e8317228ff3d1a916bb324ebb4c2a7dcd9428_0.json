{"sha": "c41e8317228ff3d1a916bb324ebb4c2a7dcd9428", "log": "[COLLECTIONS-456] Added additional overrides for providing an Equator, as well as for CharSequences.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java\n import java.util.List;\n \n import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.functors.DefaultEquator;\n+import org.apache.commons.collections4.functors.Equator;\n import org.apache.commons.collections4.list.FixedSizeList;\n import org.apache.commons.collections4.list.LazyList;\n import org.apache.commons.collections4.list.PredicatedList;\n     /**\n      * Returns the longest common subsequence (LCS) of two sequences (lists).\n      * \n-     * @param <T>  the element type\n+     * @param <E>  the element type\n      * @param a  the first list\n      * @param b  the second list\n      * @return the longest common subsequence\n      * @throws IllegalArgumentException if either list is {@code null}\n      * @since 4.0\n      */\n-    public static <T> List<T> longestCommonSubsequence(final List<T> a, final List<T> b) {\n+    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n+      return longestCommonSubsequence( a, b, DefaultEquator.defaultEquator() );\n+    }\n+\n+    /**\n+     * Returns the longest common subsequence (LCS) of two sequences (lists).\n+     * \n+     * @param <E>  the element type\n+     * @param a  the first list\n+     * @param b  the second list\n+     * @return the longest common subsequence\n+     * @throws IllegalArgumentException if either list or the equator is {@code null}\n+     * @since 4.0\n+     */\n+    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n         if (a == null || b == null) {\n             throw new IllegalArgumentException(\"List must not be null\");          \n         }\n-\n-        final SequencesComparator<T> comparator = new SequencesComparator<T>(a, b);\n-        final EditScript<T> script = comparator.getScript();\n-        final LcsVisitor<T> visitor = new LcsVisitor<T>();\n+        if (equator == null) {\n+          throw new IllegalArgumentException(\"Equator must not be null\");\n+        }\n+\n+        final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n+        final EditScript<E> script = comparator.getScript();\n+        final LcsVisitor<E> visitor = new LcsVisitor<E>();\n         script.visit(visitor);\n         return visitor.getSubSequence();\n     }\n \n     /**\n+     * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n+     * <p>\n+     * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n+     * with {@link CharSequence} instances. \n+     * \n+     * @param a  the first sequence\n+     * @param b  the second sequence\n+     * @return the longest common subsequence as {@link String}\n+     * @throws IllegalArgumentException if either sequence is {@code null}\n+     * @since 4.0\n+     */\n+    public static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n+        if (a == null || b == null) {\n+            throw new IllegalArgumentException(\"CharSequence must not be null\");          \n+        }\n+        final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList( a ), new CharSequenceAsList( b ));\n+        final StringBuilder sb = new StringBuilder();\n+        for ( Character ch : lcs ) {\n+          sb.append(ch);\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n      * A helper class used to construct the longest common subsequence.\n      */\n     private static final class LcsVisitor<E> implements CommandVisitor<E> {\n         }\n     }\n \n+    /**\n+     * A simple wrapper to use a CharSequence as List.\n+     */\n+    private static final class CharSequenceAsList extends AbstractList<Character> {\n+\n+      private final CharSequence sequence;\n+      \n+      public CharSequenceAsList(final CharSequence sequence) {\n+        this.sequence = sequence;\n+      }\n+      \n+      @Override\n+      public Character get( int index ) {\n+        return sequence.charAt( index );\n+      }\n+\n+      @Override\n+      public int size() {\n+        return sequence.length();\n+      }\n+      \n+    }\n+        \n     //-----------------------------------------------------------------------\n     /**\n      * Returns consecutive {@link List#subList(int, int) sublists} of a\n--- a/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n import org.apache.commons.collections4.Predicate;\n import org.apache.commons.collections4.functors.EqualPredicate;\n import org.apache.commons.collections4.list.PredicatedList;\n-import org.junit.Assert;\n \n /**\n  * Tests for ListUtils.\n     public void testLongestCommonSubsequence() {\n         \n         try {\n-            ListUtils.longestCommonSubsequence(null, null);\n+            ListUtils.longestCommonSubsequence((List<?>) null, null);\n             fail(\"failed to check for null argument\");\n         } catch (final IllegalArgumentException e) {}\n \n         \n         assertTrue(lcs.isEmpty());\n     }\n-    \n+\n+    public void testLongestCommonSubsequenceWithString() {\n+      \n+      try {\n+          ListUtils.longestCommonSubsequence((String) null, null);\n+          fail(\"failed to check for null argument\");\n+      } catch (final IllegalArgumentException e) {}\n+\n+      try {\n+          ListUtils.longestCommonSubsequence(\"A\", null);\n+          fail(\"failed to check for null argument\");\n+      } catch (final IllegalArgumentException e) {}\n+\n+      try {\n+          ListUtils.longestCommonSubsequence(null, \"A\");\n+          fail(\"failed to check for null argument\");\n+      } catch (final IllegalArgumentException e) {}\n+\n+      String lcs = ListUtils.longestCommonSubsequence(\"\", \"\");\n+      assertTrue(lcs.isEmpty());\n+\n+      String banana = \"BANANA\";\n+      String ananas = \"ANANAS\";\n+      lcs = ListUtils.longestCommonSubsequence(banana, ananas);\n+      \n+      assertEquals(\"ANANA\", lcs);\n+\n+      String atana = \"ATANA\";\n+      lcs = ListUtils.longestCommonSubsequence(banana, atana);\n+      \n+      assertEquals(\"AANA\", lcs);\n+\n+      String zorro = \"ZORRO\";\n+      lcs = ListUtils.longestCommonSubsequence(banana, zorro);\n+      \n+      assertTrue(lcs.isEmpty());\n+  }\n+\n     public void testPartition() {\n         final List<Integer> strings = new ArrayList<Integer>();\n         for (int i = 0; i <= 6; i++) {", "timestamp": 1367312743, "metainfo": ""}