{"sha": "73dcea01b19ed9fc9c0d5a8c38e752bfe071c801", "log": "[COLLECTIONS-462] Added PeekingIterator. Thanks to Andy Seaborne  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n import org.apache.commons.collections4.iterators.ObjectArrayIterator;\n import org.apache.commons.collections4.iterators.ObjectArrayListIterator;\n import org.apache.commons.collections4.iterators.ObjectGraphIterator;\n+import org.apache.commons.collections4.iterators.PeekingIterator;\n import org.apache.commons.collections4.iterators.SingletonIterator;\n import org.apache.commons.collections4.iterators.SingletonListIterator;\n import org.apache.commons.collections4.iterators.TransformIterator;\n         return new NodeListIterator(node);\n     }\n \n+    // Peeking\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Gets an iterator that supports one-element lookahead.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate, not null\n+     * @return a peeking iterator\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n+        return PeekingIterator.peekingIterator(iterator);\n+    }\n+\n     // Views\n     //-----------------------------------------------------------------------\n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Decorates an iterator to support one-element lookahead while iterating.\n+ * <p>\n+ * The decorator supports the removal operation, but an {@link IllegalStateException}\n+ * will be thrown if {@link #remove()} is called directly after a call to\n+ * {@link #peek()} or {@link #element()}.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PeekingIterator<E> implements Iterator<E> {\n+\n+    /** The iterator being decorated. */\n+    private final Iterator<? extends E> iterator;\n+\n+    /** Indicates that the decorated iterator is exhausted. */\n+    private boolean exhausted = false;\n+\n+    /** Indicates if the lookahead slot is filled. */\n+    private boolean slotFilled = false;\n+\n+    /** The current slot for lookahead. */\n+    private E slot;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator to support one-element lookahead.\n+     * <p>\n+     * If the iterator is already a {@link PeekingIterator} it is returned directly.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @return a new peeking iterator\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"Iterator must not be null\");\n+        }\n+        if (iterator instanceof PeekingIterator<?>) {\n+            @SuppressWarnings(\"unchecked\") // safe cast\n+            final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n+            return it;\n+        }\n+        return new PeekingIterator<E>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    public PeekingIterator(final Iterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    private void fill() {\n+        if (exhausted || slotFilled) {\n+            return;\n+        }\n+        if (iterator.hasNext()) {\n+            slot = iterator.next();\n+            slotFilled = true;\n+        } else {\n+            exhausted = true;\n+            slot = null;\n+            slotFilled = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        if (exhausted) {\n+            return false;\n+        }\n+        return slotFilled ? true : iterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next element in iteration without advancing the underlying iterator.\n+     * If the iterator is already exhausted, null will be returned.\n+     * <p>\n+     * Note: this method does not throw a {@link NoSuchElementException} if the iterator\n+     * is already exhausted. If you want such a behavior, use {@link #element()} instead.\n+     * <p>\n+     * The rationale behind this is to follow the {@link java.util.Queue} interface\n+     * which uses the same terminology.\n+     *\n+     * @return the next element from the iterator\n+     */\n+    public E peek() {\n+        fill();\n+        return exhausted ? null : slot;\n+    }\n+\n+    /**\n+     * Returns the next element in iteration without advancing the underlying iterator.\n+     * If the iterator is already exhausted, null will be returned.\n+     *\n+     * @return the next element from the iterator\n+     * @throws NoSuchElementException if the iterator is already exhausted according to {@link #hasNext()}\n+     */\n+    public E element() {\n+        fill();\n+        if (exhausted) {\n+            throw new NoSuchElementException();\n+        }\n+        return slot;\n+    }\n+\n+    public E next() {\n+        if (!hasNext()) {\n+            throw new NoSuchElementException();\n+        }\n+        final E x = slotFilled ? slot : iterator.next();\n+        // reset the lookahead slot\n+        slot = null;\n+        slotFilled = false;\n+        return x;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IllegalStateException if {@link #peek()} or {@link #element()} has been called\n+     *   prior to the call to {@link #remove()}\n+     */\n+    public void remove() {\n+        if (slotFilled) {\n+            throw new IllegalStateException();\n+        } else {\n+            iterator.remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests the PeekingIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class PeekingIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    private String[] testArray = { \"a\", \"b\", \"c\" };\n+\n+    private List<E> testList;\n+    \n+    public PeekingIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+    }\n+\n+    @Override\n+    public Iterator<E> makeEmptyIterator() {\n+        return PeekingIterator.peekingIterator(Collections.<E>emptyList().iterator());\n+    }\n+\n+    @Override\n+    public PeekingIterator<E> makeObject() {\n+        return PeekingIterator.peekingIterator(testList.iterator());\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    @Test\n+    public void testEmpty() {\n+        Iterator<E> it = makeEmptyIterator();\n+        assertFalse(it.hasNext());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSinglePeek() {\n+        PeekingIterator<E> it = makeObject();\n+        assertEquals(\"a\", it.peek());\n+        assertEquals(\"a\", it.element());\n+        validate(it, (E[]) testArray);\n+    }\n+\n+    @Test\n+    public void testMultiplePeek() {\n+        PeekingIterator<E> it = makeObject();\n+        assertEquals(\"a\", it.peek());\n+        assertEquals(\"a\", it.peek());\n+        assertEquals(\"a\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"b\", it.peek());\n+        assertEquals(\"b\", it.peek());\n+        assertEquals(\"b\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"c\", it.peek());\n+        assertEquals(\"c\", it.peek());\n+        assertEquals(\"c\", it.next());\n+        assertFalse(it.hasNext());\n+    }\n+    \n+    @Test\n+    public void testIteratorExhausted() {\n+        PeekingIterator<E> it = makeObject();\n+        it.next();\n+        it.next();\n+        it.next();\n+        assertFalse(it.hasNext());\n+        assertNull(it.peek());\n+        \n+        try {\n+            it.element();\n+            fail();\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testIllegalRemove() {\n+        PeekingIterator<E> it = makeObject();\n+        it.next();\n+        it.remove(); // supported\n+        \n+        assertTrue(it.hasNext());\n+        assertEquals(\"b\", it.peek());\n+        \n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+    }\n+\n+    private void validate(Iterator<E> iter, E... items) {\n+        for (E x : items) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(x, iter.next());\n+        }\n+        assertFalse(iter.hasNext());\n+    }\n+\n+}", "timestamp": 1367903526, "metainfo": ""}