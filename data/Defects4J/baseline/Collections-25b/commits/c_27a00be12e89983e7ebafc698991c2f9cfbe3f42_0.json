{"sha": "27a00be12e89983e7ebafc698991c2f9cfbe3f42", "log": "Add a lot of tests   ", "commit": "\n--- a/src/test/org/apache/commons/collections/AbstractTestSortedMap.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestSortedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestSortedMap.java,v 1.3 2003/10/07 22:20:57 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestSortedMap.java,v 1.4 2003/10/31 01:25:45 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n import java.util.SortedMap;\n+import java.util.TreeMap;\n \n /**\n  * Abstract test class for {@link java.util.SortedMap} methods and contracts.\n  *\n- * @version $Revision: 1.3 $ $Date: 2003/10/07 22:20:57 $\n+ * @version $Revision: 1.4 $ $Date: 2003/10/31 01:25:45 $\n  * \n  * @author Stephen Colebourne\n  */\n         return false;\n     }\n \n-    // TODO: Add the SortedMap tests!\n-    \n+    /**\n+     * SortedMap uses TreeMap as its known comparison.\n+     * \n+     * @return a map that is known to be valid\n+     */\n+    protected Map makeConfirmedMap() {\n+        return new TreeMap();\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testComparator() {\n         SortedMap sm = (SortedMap) makeFullMap();\n         assertSame(obj, sm.lastKey());\n     }\n     \n+    //-----------------------------------------------------------------------    \n+    public BulkTest bulkTestHeadMap() {\n+        return new TestHeadMap(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new TestTailMap(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new TestSubMap(this);\n+    }\n+\n+    public static abstract class TestViewMap extends AbstractTestSortedMap {\n+        protected final AbstractTestMap main;\n+        protected final List subSortedKeys = new ArrayList();\n+        protected final List subSortedValues = new ArrayList();\n+        protected final List subSortedNewValues = new ArrayList();\n+        \n+        public TestViewMap(String name, AbstractTestMap main) {\n+            super(name);\n+            this.main = main;\n+        }\n+        protected void resetEmpty() {\n+            // needed to init verify correctly\n+            main.resetEmpty();\n+            super.resetEmpty();\n+        }\n+        protected void resetFull() {\n+            // needed to init verify correctly\n+            main.resetFull();\n+            super.resetFull();\n+        }\n+        protected void verify() {\n+            // cross verify changes on view with changes on main map\n+            super.verify();\n+            main.verify();\n+        }\n+        public BulkTest bulkTestHeadMap() {\n+            return null;  // block infinite recursion\n+        }\n+        public BulkTest bulkTestTailMap() {\n+            return null;  // block infinite recursion\n+        }\n+        public BulkTest bulkTestSubMap() {\n+            return null;  // block infinite recursion\n+        }\n+        \n+        protected Object[] getSampleKeys() {\n+            return subSortedKeys.toArray();\n+        }\n+        protected Object[] getSampleValues() {\n+            return subSortedValues.toArray();\n+        }\n+        protected Object[] getNewSampleValues() {\n+            return subSortedNewValues.toArray();\n+        }\n+        \n+        protected String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion();\n+        }\n+        protected boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+        protected boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+        protected boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+        protected boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+        protected boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+        protected boolean supportsEmptyCollections() {\n+            return false;\n+        }\n+        protected boolean supportsFullCollections() {\n+            return false;\n+        }\n+    }\n+    \n+    public static class TestHeadMap extends TestViewMap {\n+        static final int SUBSIZE = 6;\n+        final Object toKey;\n+        \n+        public TestHeadMap(AbstractTestMap main) {\n+            super(\"SortedMap.HeadMap\", main);\n+            SortedMap sm = (SortedMap) main.makeFullMap();\n+            for (Iterator it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.toKey = this.subSortedKeys.get(SUBSIZE);\n+            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n+            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        protected Map makeEmptyMap() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap) main.makeEmptyMap()).headMap(toKey);\n+        }\n+        protected Map makeFullMap() {\n+            return ((SortedMap) main.makeFullMap()).headMap(toKey);\n+        }\n+        public void testHeadMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                ((SortedMap) map).put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+    }\n+    \n+    public static class TestTailMap extends TestViewMap {\n+        static final int SUBSIZE = 6;\n+        final Object fromKey;\n+        final Object invalidKey;\n+        \n+        public TestTailMap(AbstractTestMap main) {\n+            super(\"SortedMap.TailMap\", main);\n+            SortedMap sm = (SortedMap) main.makeFullMap();\n+            for (Iterator it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n+            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n+            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        protected Map makeEmptyMap() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap) main.makeEmptyMap()).tailMap(fromKey);\n+        }\n+        protected Map makeFullMap() {\n+            return ((SortedMap) main.makeFullMap()).tailMap(fromKey);\n+        }\n+        public void testTailMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                ((SortedMap) map).put(invalidKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+    }\n+    \n+    public static class TestSubMap extends TestViewMap {\n+        static final int SUBSIZE = 3;\n+        final Object fromKey;\n+        final Object toKey;\n+        \n+        public TestSubMap(AbstractTestMap main) {\n+            super(\"SortedMap.SubMap\", main);\n+            SortedMap sm = (SortedMap) main.makeFullMap();\n+            for (Iterator it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n+            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+            \n+            this.subSortedKeys.subList(0, SUBSIZE).clear();\n+            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n+            \n+            this.subSortedValues.subList(0, SUBSIZE).clear();\n+            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n+            \n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n+                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n+        }\n+        \n+        protected Map makeEmptyMap() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap) main.makeEmptyMap()).subMap(fromKey, toKey);\n+        }\n+        protected Map makeFullMap() {\n+            return ((SortedMap) main.makeFullMap()).subMap(fromKey, toKey);\n+        }\n+        public void testSubMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                ((SortedMap) map).put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+    }\n+    \n }", "timestamp": 1067563545, "metainfo": ""}