{"sha": "61c237e3118d563a5761db13f36e6f681868064c", "log": "Apply collection coding standards   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n+++ b/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/StaticBucketMap.java,v 1.6 2003/12/29 15:26:39 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/StaticBucketMap.java,v 1.7 2004/01/02 02:13:07 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * operations will affect the map.<p>\n  *\n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.6 $ $Date: 2003/12/29 15:26:39 $\n+ * @version $Revision: 1.7 $ $Date: 2004/01/02 02:13:07 $\n  * \n  * @author Berin Loritsch\n  * @author Gerhard Froehlich\n public final class StaticBucketMap implements Map {\n \n     private static final int DEFAULT_BUCKETS = 255;\n-    private Node[] m_buckets;\n-    private Lock[] m_locks;\n+    private Node[] buckets;\n+    private Lock[] locks;\n \n     /**\n      * Initializes the map with the default number of buckets (255).\n             size--;\n         }\n \n-        m_buckets = new Node[size];\n-        m_locks = new Lock[size];\n+        buckets = new Node[size];\n+        locks = new Lock[size];\n \n         for (int i = 0; i < size; i++) {\n-            m_locks[i] = new Lock();\n+            locks[i] = new Lock();\n         }\n     }\n \n         hash ^= (hash >>> 6);\n         hash += ~(hash << 11);\n         hash ^= (hash >>> 16);\n-        hash %= m_buckets.length;\n+        hash %= buckets.length;\n         return (hash < 0) ? hash * -1 : hash;\n     }\n \n     public int size() {\n         int cnt = 0;\n \n-        for (int i = 0; i < m_buckets.length; i++) {\n-            cnt += m_locks[i].size;\n+        for (int i = 0; i < buckets.length; i++) {\n+            cnt += locks[i].size;\n         }\n         return cnt;\n     }\n     public Object get(final Object key) {\n         int hash = getHash(key);\n \n-        synchronized (m_locks[hash]) {\n-            Node n = m_buckets[hash];\n+        synchronized (locks[hash]) {\n+            Node n = buckets[hash];\n \n             while (n != null) {\n                 if (n.key == key || (n.key != null && n.key.equals(key))) {\n     public boolean containsKey(final Object key) {\n         int hash = getHash(key);\n \n-        synchronized (m_locks[hash]) {\n-            Node n = m_buckets[hash];\n+        synchronized (locks[hash]) {\n+            Node n = buckets[hash];\n \n             while (n != null) {\n                 if (n.key == null || (n.key != null && n.key.equals(key))) {\n      * @return true if found\n      */\n     public boolean containsValue(final Object value) {\n-        for (int i = 0; i < m_buckets.length; i++) {\n-            synchronized (m_locks[i]) {\n-                Node n = m_buckets[i];\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized (locks[i]) {\n+                Node n = buckets[i];\n \n                 while (n != null) {\n                     if (n.value == value || (n.value != null && n.value.equals(value))) {\n     public Object put(final Object key, final Object value) {\n         int hash = getHash(key);\n \n-        synchronized (m_locks[hash]) {\n-            Node n = m_buckets[hash];\n+        synchronized (locks[hash]) {\n+            Node n = buckets[hash];\n \n             if (n == null) {\n                 n = new Node();\n                 n.key = key;\n                 n.value = value;\n-                m_buckets[hash] = n;\n-                m_locks[hash].size++;\n+                buckets[hash] = n;\n+                locks[hash].size++;\n                 return null;\n             }\n \n             newNode.key = key;\n             newNode.value = value;\n             n.next = newNode;\n-            m_locks[hash].size++;\n+            locks[hash].size++;\n         }\n         return null;\n     }\n     public Object remove(Object key) {\n         int hash = getHash(key);\n \n-        synchronized (m_locks[hash]) {\n-            Node n = m_buckets[hash];\n+        synchronized (locks[hash]) {\n+            Node n = buckets[hash];\n             Node prev = null;\n \n             while (n != null) {\n                     // Remove this node from the linked list of nodes.\n                     if (null == prev) {\n                         // This node was the head, set the next node to be the new head.\n-                        m_buckets[hash] = n.next;\n+                        buckets[hash] = n.next;\n                     } else {\n                         // Set the next node of the previous node to be the node after this one.\n                         prev.next = n.next;\n                     }\n-                    m_locks[hash].size--;\n+                    locks[hash].size--;\n                     return n.value;\n                 }\n \n      * Clears the map of all entries.\n      */\n     public void clear() {\n-        for (int i = 0; i < m_buckets.length; i++) {\n-            Lock lock = m_locks[i];\n+        for (int i = 0; i < buckets.length; i++) {\n+            Lock lock = locks[i];\n             synchronized (lock) {\n-                m_buckets[i] = null;\n+                buckets[i] = null;\n                 lock.size = 0;\n             }\n         }\n     public int hashCode() {\n         int hashCode = 0;\n \n-        for (int i = 0; i < m_buckets.length; i++) {\n-            synchronized (m_locks[i]) {\n-                Node n = m_buckets[i];\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized (locks[i]) {\n+                Node n = buckets[i];\n \n                 while (n != null) {\n                     hashCode += n.hashCode();\n \n         public boolean hasNext() {\n             if (current.size() > 0) return true;\n-            while (bucket < m_buckets.length) {\n-                synchronized (m_locks[bucket]) {\n-                    Node n = m_buckets[bucket];\n+            while (bucket < buckets.length) {\n+                synchronized (locks[bucket]) {\n+                    Node n = buckets[bucket];\n                     while (n != null) {\n                         current.add(n);\n                         n = n.next;\n         public boolean contains(Object obj) {\n             Map.Entry entry = (Map.Entry) obj;\n             int hash = getHash(entry.getKey());\n-            synchronized (m_locks[hash]) {\n-                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+            synchronized (locks[hash]) {\n+                for (Node n = buckets[hash]; n != null; n = n.next) {\n                     if (n.equals(entry)) return true;\n                 }\n             }\n             }\n             Map.Entry entry = (Map.Entry) obj;\n             int hash = getHash(entry.getKey());\n-            synchronized (m_locks[hash]) {\n-                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+            synchronized (locks[hash]) {\n+                for (Node n = buckets[hash]; n != null; n = n.next) {\n                     if (n.equals(entry)) {\n                         StaticBucketMap.this.remove(n.getKey());\n                         return true;\n \n         public boolean remove(Object obj) {\n             int hash = getHash(obj);\n-            synchronized (m_locks[hash]) {\n-                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+            synchronized (locks[hash]) {\n+                for (Node n = buckets[hash]; n != null; n = n.next) {\n                     Object k = n.getKey();\n                     if ((k == obj) || ((k != null) && k.equals(obj))) {\n                         StaticBucketMap.this.remove(k);\n     }\n \n     private void atomic(Runnable r, int bucket) {\n-        if (bucket >= m_buckets.length) {\n+        if (bucket >= buckets.length) {\n             r.run();\n             return;\n         }\n-        synchronized (m_locks[bucket]) {\n+        synchronized (locks[bucket]) {\n             atomic(r, bucket + 1);\n         }\n     }\n \n-\n }", "timestamp": 1073009587, "metainfo": ""}