{"sha": "5dcb6c91bd5b7b9c579d104f16d47863a0615cca", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r814063 | sebb | 2009-09-11 15:25:29 -0700 (Fri, 11 Sep 2009) | 1 line          Javadoc typos; fix internal raw types     ------------------------------------------------------------------------     r814050 | sebb | 2009-09-11 15:01:25 -0700 (Fri, 11 Sep 2009) | 1 line          Some minor Javadoc fixes     ------------------------------------------------------------------------     r813951 | mbenson | 2009-09-11 10:48:55 -0700 (Fri, 11 Sep 2009) | 1 line          [COLLECTIONS-286] CollectionsUtils.extractSingleton     ------------------------------------------------------------------------     r813925 | mbenson | 2009-09-11 10:05:31 -0700 (Fri, 11 Sep 2009) | 1 line          [COLLECTIONS-182] return Closure from CollectionUtils.forAllDo     ------------------------------------------------------------------------     r648113 | skestle | 2008-04-14 21:32:39 -0700 (Mon, 14 Apr 2008) | 1 line          Updated CollectionUtils to return the same type of Collection that is passed into select(), reject() and collect()     ------------------------------------------------------------------------     r593968 | skestle | 2007-11-11 13:59:08 -0800 (Sun, 11 Nov 2007) | 1 line          Missed 1 variable rename causing test to fail for COLLECTIONS-245     ------------------------------------------------------------------------     r593964 | skestle | 2007-11-11 13:44:41 -0800 (Sun, 11 Nov 2007) | 2 lines          Applied (most of) Brian Egge's clean up patch of previous commit for COLLECTIONS-245 - thanks! (And we're at 100%)          ------------------------------------------------------------------------     r593144 | skestle | 2007-11-08 04:21:55 -0800 (Thu, 08 Nov 2007) | 3 lines          Updated CollectionUtils and test.  Probably 80-90% complete for generics.  Very open to review / patches.          Jira: COLLECTIONS-245     ------------------------------------------------------------------------     r562381 | skestle | 2007-08-03 01:15:35 -0700 (Fri, 03 Aug 2007) | 1 line          Extracted private CollectionUtils.CardinalityHelper classes to allow easier generic refactoring/maintenance and code readability.     ------------------------------------------------------------------------     r561846 | niallp | 2007-08-01 08:53:19 -0700 (Wed, 01 Aug 2007) | 1 line          Test commit (just remove a trailing space) on Collections JDK5 Branch     ------------------------------------------------------------------------     r471166 | scolebourne | 2006-11-04 03:33:22 -0800 (Sat, 04 Nov 2006) | 1 line          Removed Typed* containers such as TypedList and TypedMap as generics now provides type safety     ------------------------------------------------------------------------     r468690 | scolebourne | 2006-10-28 06:03:11 -0700 (Sat, 28 Oct 2006) | 1 line          COLLECTIONS-229 - Remove deprecated classes and code     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n import org.apache.commons.collections.collection.PredicatedCollection;\n import org.apache.commons.collections.collection.SynchronizedCollection;\n import org.apache.commons.collections.collection.TransformedCollection;\n-import org.apache.commons.collections.collection.TypedCollection;\n import org.apache.commons.collections.collection.UnmodifiableBoundedCollection;\n import org.apache.commons.collections.collection.UnmodifiableCollection;\n \n /**\n  * Provides utility methods and decorators for {@link Collection} instances.\n+ * Method parameters will take {@link Iterable} objects when possible.\n  *\n  * @since Commons Collections 1.0\n  * @version $Revision$ $Date$\n  * @author Jon Schewe\n  * @author Neil O'Toole\n  * @author Stephen Smith\n+ * @author Stephen Kestle\n  */\n+//TODO - note generic types for review in wiki - especially <?> ones\n+//TODO - doc Cardinality Helpers\n public class CollectionUtils {\n \n-    /** Constant to avoid repeated object creation */\n-    private static final Integer INTEGER_ONE = new Integer(1);\n+    private static class CardinalityHelper<O> {\n+        final Map<O, Integer> cardinalityA, cardinalityB;\n+\n+        public CardinalityHelper(Iterable<? extends O> a, Iterable<? extends O> b) {\n+            cardinalityA = CollectionUtils.<O>getCardinalityMap(a);\n+            cardinalityB = CollectionUtils.<O>getCardinalityMap(b);\n+        }\n+\n+        public final int max(Object obj) {\n+            return Math.max(freqA(obj), freqB(obj));\n+        }\n+\n+        public final int min(Object obj) {\n+            return Math.min(freqA(obj), freqB(obj));\n+        }\n+\n+        public int freqA(Object obj) {\n+            return getFreq(obj, cardinalityA);\n+        }\n+\n+        public int freqB(Object obj) {\n+            return getFreq(obj, cardinalityB);\n+        }\n+\n+        private final int getFreq(final Object obj, final Map<?, Integer> freqMap) {\n+            Integer count = freqMap.get(obj);\n+            if (count != null) {\n+                return count;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n+        private final Set<O> elements;\n+        private final List<O> newList;\n+\n+        public SetOperationCardinalityHelper(Iterable<? extends O> a, Iterable<? extends O> b) {\n+            super(a, b);\n+            elements = new HashSet<O>();\n+            addAll(elements, a);\n+            addAll(elements, b);\n+            newList = new ArrayList<O>();\n+        }\n+\n+        public Iterator<O> iterator() {\n+            return elements.iterator();\n+        }\n+\n+        public void setCardinality(O obj, int count) {\n+            for (int i = 0; i < count; i++) {\n+                newList.add(obj);\n+            }\n+        }\n+\n+        public Collection<O> list() {\n+            return newList;\n+        }\n+\n+    }\n \n     /**\n      * An empty unmodifiable collection.\n      * this purpose. However they could be cast to Set or List which might be\n      * undesirable. This implementation only implements Collection.\n      */\n-    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList());\n+    @SuppressWarnings(\"unchecked\")\n+    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList<Object>());\n \n     /**\n      * <code>CollectionUtils</code> should not normally be instantiated.\n     }\n \n     /**\n-     * Returns a {@link Collection} containing the union\n-     * of the given {@link Collection}s.\n-     * <p>\n-     * The cardinality of each element in the returned {@link Collection}\n-     * will be equal to the maximum of the cardinality of that element\n-     * in the two given {@link Collection}s.\n-     *\n-     * @param a  the first collection, must not be null\n-     * @param b  the second collection, must not be null\n-     * @return  the union of the two collections\n+     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n+     *\n+     * @see #EMPTY_COLLECTION\n+     * @since 4.0\n+     * @return immutable empty collection\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Collection<T> emptyCollection() {\n+        return EMPTY_COLLECTION;\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the union of the given\n+     * {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection} will\n+     * be equal to the maximum of the cardinality of that element in the two\n+     * given {@link Collection}s.\n+     *\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the union of the two collections\n      * @see Collection#addAll\n      */\n-    public static Collection union(final Collection a, final Collection b) {\n-        ArrayList list = new ArrayList();\n-        Map mapa = getCardinalityMap(a);\n-        Map mapb = getCardinalityMap(b);\n-        Set elts = new HashSet(a);\n-        elts.addAll(b);\n-        Iterator it = elts.iterator();\n-        while(it.hasNext()) {\n-            Object obj = it.next();\n-            for(int i=0,m=Math.max(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n-                list.add(obj);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Returns a {@link Collection} containing the intersection\n-     * of the given {@link Collection}s.\n-     * <p>\n-     * The cardinality of each element in the returned {@link Collection}\n-     * will be equal to the minimum of the cardinality of that element\n-     * in the two given {@link Collection}s.\n-     *\n-     * @param a  the first collection, must not be null\n-     * @param b  the second collection, must not be null\n+    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (O obj : helper) {\n+            helper.setCardinality(obj, helper.max(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the intersection of the given\n+     * {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection} will\n+     * be equal to the minimum of the cardinality of that element in the two\n+     * given {@link Collection}s.\n+     *\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n      * @return the intersection of the two collections\n      * @see Collection#retainAll\n      * @see #containsAny\n      */\n-    public static Collection intersection(final Collection a, final Collection b) {\n-        ArrayList list = new ArrayList();\n-        Map mapa = getCardinalityMap(a);\n-        Map mapb = getCardinalityMap(b);\n-        Set elts = new HashSet(a);\n-        elts.addAll(b);\n-        Iterator it = elts.iterator();\n-        while(it.hasNext()) {\n-            Object obj = it.next();\n-            for(int i=0,m=Math.min(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n-                list.add(obj);\n-            }\n-        }\n-        return list;\n+    public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (O obj : helper) {\n+            helper.setCardinality(obj, helper.min(obj));\n+        }\n+        return helper.list();\n     }\n \n     /**\n      * Returns a {@link Collection} containing the exclusive disjunction\n      * (symmetric difference) of the given {@link Collection}s.\n      * <p>\n-     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n-     * will be equal to\n+     * The cardinality of each element <i>e</i> in the returned\n+     * {@link Collection} will be equal to\n      * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>))</tt>.\n      * <p>\n      * This is equivalent to\n      * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n      * or\n      * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n-     *\n-     * @param a  the first collection, must not be null\n-     * @param b  the second collection, must not be null\n+\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n      * @return the symmetric difference of the two collections\n      */\n-    public static Collection disjunction(final Collection a, final Collection b) {\n-        ArrayList list = new ArrayList();\n-        Map mapa = getCardinalityMap(a);\n-        Map mapb = getCardinalityMap(b);\n-        Set elts = new HashSet(a);\n-        elts.addAll(b);\n-        Iterator it = elts.iterator();\n-        while(it.hasNext()) {\n-            Object obj = it.next();\n-            for(int i=0,m=((Math.max(getFreq(obj,mapa),getFreq(obj,mapb)))-(Math.min(getFreq(obj,mapa),getFreq(obj,mapb))));i<m;i++) {\n-                list.add(obj);\n-            }\n-        }\n-        return list;\n+    public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (O obj : helper) {\n+            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n+        }\n+        return helper.list();\n     }\n \n     /**\n      *\n      * @param a  the collection to subtract from, must not be null\n      * @param b  the collection to subtract, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n      * @return a new collection with the results\n      * @see Collection#removeAll\n      */\n-    public static Collection subtract(final Collection a, final Collection b) {\n-        ArrayList list = new ArrayList( a );\n-        for (Iterator it = b.iterator(); it.hasNext();) {\n-            list.remove(it.next());\n+    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        ArrayList<O> list = new ArrayList<O>();\n+        addAll(list, a);\n+        for (O element : b) {\n+            list.remove(element);\n         }\n         return list;\n     }\n      * <p>\n      * In other words, this method returns <code>true</code> iff the\n      * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n-     * \n+     *\n      * @param coll1  the first collection, must not be null\n      * @param coll2  the first collection, must not be null\n      * @return <code>true</code> iff the intersection of the collections is non-empty\n      * @since 2.1\n      * @see #intersection\n      */\n-    public static boolean containsAny(final Collection coll1, final Collection coll2) {\n+    public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n         if (coll1.size() < coll2.size()) {\n-            for (Iterator it = coll1.iterator(); it.hasNext();) {\n-                if (coll2.contains(it.next())) {\n+            for (Object aColl1 : coll1) {\n+                if (coll2.contains(aColl1)) {\n                     return true;\n                 }\n             }\n         } else {\n-            for (Iterator it = coll2.iterator(); it.hasNext();) {\n-                if (coll1.contains(it.next())) {\n+            for (Object aColl2 : coll2) {\n+                if (coll1.contains(aColl2)) {\n                     return true;\n                 }\n             }\n      * <p>\n      * Only those elements present in the collection will appear as\n      * keys in the map.\n-     * \n-     * @param coll  the collection to get the cardinality map for, must not be null\n+     *\n+     * @param coll\n+     *            the collection to get the cardinality map for, must not be\n+     *            null\n+     * @param <O>\n+     *            the type of object in the returned {@link Map}. This is a\n+     *            super type of <I>.\n      * @return the populated cardinality map\n      */\n-    public static Map getCardinalityMap(final Collection coll) {\n-        Map count = new HashMap();\n-        for (Iterator it = coll.iterator(); it.hasNext();) {\n-            Object obj = it.next();\n-            Integer c = (Integer) (count.get(obj));\n+    public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n+        Map<O, Integer> count = new HashMap<O, Integer>();\n+        for (O obj : coll) {\n+            Integer c = count.get(obj);\n             if (c == null) {\n-                count.put(obj,INTEGER_ONE);\n+                count.put(obj, 1);\n             } else {\n-                count.put(obj,new Integer(c.intValue() + 1));\n+                count.put(obj, c + 1);\n             }\n         }\n         return count;\n \n     /**\n      * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n-     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n-     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n-     * for each element <i>e</i> in <i>a</i>.\n-     *\n-     * @param a  the first (sub?) collection, must not be null\n-     * @param b  the second (super?) collection, must not be null\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n+     * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n+     * in <i>a</i>.\n+     *\n+     * @param a the first (sub?) collection, must not be null\n+     * @param b the second (super?) collection, must not be null\n      * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n      * @see #isProperSubCollection\n      * @see Collection#containsAll\n      */\n-    public static boolean isSubCollection(final Collection a, final Collection b) {\n-        Map mapa = getCardinalityMap(a);\n-        Map mapb = getCardinalityMap(b);\n-        Iterator it = a.iterator();\n-        while (it.hasNext()) {\n-            Object obj = it.next();\n-            if (getFreq(obj, mapa) > getFreq(obj, mapb)) {\n+    public static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n+        CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        for (Object obj : a) {\n+            if (helper.freqA(obj) > helper.freqB(obj)) {\n                 return false;\n             }\n         }\n      * <p>\n      * The implementation assumes\n      * <ul>\n-     *    <li><code>a.size()</code> and <code>b.size()</code> represent the \n+     *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n      *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n      *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n      * </ul>\n      * @see #isSubCollection\n      * @see Collection#containsAll\n      */\n-    public static boolean isProperSubCollection(final Collection a, final Collection b) {\n-        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a,b);\n+    public static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n+        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a, b);\n     }\n \n     /**\n      * @param b  the second collection, must not be null\n      * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n      */\n-    public static boolean isEqualCollection(final Collection a, final Collection b) {\n+    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n         if(a.size() != b.size()) {\n             return false;\n-        } else {\n-            Map mapa = getCardinalityMap(a);\n-            Map mapb = getCardinalityMap(b);\n-            if(mapa.size() != mapb.size()) {\n+        }\n+        final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        if(helper.cardinalityA.size() != helper.cardinalityB.size()) {\n+            return false;\n+        }\n+        for( Object obj : helper.cardinalityA.keySet()) {\n+            if(helper.freqA(obj) != helper.freqB(obj)) {\n                 return false;\n-            } else {\n-                Iterator it = mapa.keySet().iterator();\n-                while(it.hasNext()) {\n-                    Object obj = it.next();\n-                    if(getFreq(obj,mapa) != getFreq(obj,mapb)) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-        }\n+            }\n+        }\n+        return true;\n     }\n \n     /**\n      * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n      *\n-     * @param obj  the object to find the cardinality of\n-     * @param coll  the collection to search\n+     * @param obj the object to find the cardinality of\n+     * @param coll the {@link Iterable} to search\n+     * @param <O> the type of object that the {@link Iterable} may contain.\n      * @return the the number of occurrences of obj in coll\n      */\n-    public static int cardinality(Object obj, final Collection coll) {\n-        if (coll instanceof Set) {\n-            return (coll.contains(obj) ? 1 : 0);\n-        }\n-        if (coll instanceof Bag) {\n-            return ((Bag) coll).getCount(obj);\n+    public static <O> int cardinality(O obj, final Iterable<? super O> coll) {\n+        if (coll instanceof Set<?>) {\n+            return (((Set<? super O>) coll).contains(obj) ? 1 : 0);\n+        }\n+        if (coll instanceof Bag<?>) {\n+            return ((Bag<? super O>) coll).getCount(obj);\n         }\n         int count = 0;\n         if (obj == null) {\n-            for (Iterator it = coll.iterator();it.hasNext();) {\n-                if (it.next() == null) {\n+            for (Object element : coll) {\n+                if (element == null) {\n                     count++;\n                 }\n             }\n         } else {\n-            for (Iterator it = coll.iterator();it.hasNext();) {\n-                if (obj.equals(it.next())) {\n+            for (Object element : coll) {\n+                if (obj.equals(element)) {\n                     count++;\n                 }\n             }\n         return count;\n     }\n \n-    /** \n+    /**\n      * Finds the first element in the given collection which matches the given predicate.\n      * <p>\n-     * If the input collection or predicate is null, or no element of the collection \n+     * If the input collection or predicate is null, or no element of the collection\n      * matches the predicate, null is returned.\n      *\n      * @param collection  the collection to search, may be null\n      * @param predicate  the predicate to use, may be null\n      * @return the first element of the collection which matches the predicate or null if none could be found\n      */\n-    public static Object find(Collection collection, Predicate predicate) {\n+    public static <T> T find(Collection<T> collection, Predicate<? super T> predicate) {\n         if (collection != null && predicate != null) {\n-            for (Iterator iter = collection.iterator(); iter.hasNext();) {\n-                Object item = iter.next();\n+            for (T item : collection) {\n                 if (predicate.evaluate(item)) {\n                     return item;\n                 }\n         }\n         return null;\n     }\n-    \n-    /** \n+\n+    /**\n      * Executes the given closure on each element in the collection.\n      * <p>\n      * If the input collection or closure is null, there is no change made.\n-     * \n-     * @param collection  the collection to get the input from, may be null\n-     * @param closure  the closure to perform, may be null\n-     */\n-    public static void forAllDo(Collection collection, Closure closure) {\n+     *\n+     * @param collection\n+     *            the collection to get the input from, may be null\n+     * @param closure\n+     *            the closure to perform, may be null\n+     * @return closure\n+     */\n+    public static <T, C extends Closure<? super T>> C forAllDo(Collection<T> collection, C closure) {\n         if (collection != null && closure != null) {\n-            for (Iterator it = collection.iterator(); it.hasNext();) {\n-                closure.execute(it.next());\n-            }\n-        }\n-    }\n-\n-    /** \n+            for (T element : collection) {\n+                closure.execute(element);\n+            }\n+        }\n+        return closure;\n+    }\n+\n+    /**\n      * Filter the collection by applying a Predicate to each element. If the\n      * predicate returns false, remove the element.\n      * <p>\n      * If the input collection or predicate is null, there is no change made.\n-     * \n-     * @param collection  the collection to get the input from, may be null\n-     * @param predicate  the predicate to use as a filter, may be null\n-     */\n-    public static void filter(Collection collection, Predicate predicate) {\n+     *\n+     * @param collection\n+     *            the collection to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use as a filter, may be null\n+     */\n+    public static <T> void filter(Iterable<T> collection, Predicate<? super T> predicate) {\n         if (collection != null && predicate != null) {\n-            for (Iterator it = collection.iterator(); it.hasNext();) {\n-                if (predicate.evaluate(it.next()) == false) {\n+            for (Iterator<T> it = collection.iterator(); it.hasNext();) {\n+                if (!predicate.evaluate(it.next())) {\n                     it.remove();\n                 }\n             }\n         }\n     }\n \n-    /** \n+    /**\n      * Transform the collection by applying a Transformer to each element.\n      * <p>\n      * If the input collection or transformer is null, there is no change made.\n      * <p>\n-     * This routine is best for Lists, for which set() is used to do the \n-     * transformations \"in place.\"  For other Collections, clear() and addAll()\n-     * are used to replace elements.  \n+     * This routine is best for Lists, for which set() is used to do the\n+     * transformations \"in place.\" For other Collections, clear() and addAll()\n+     * are used to replace elements.\n      * <p>\n      * If the input collection controls its input, such as a Set, and the\n-     * Transformer creates duplicates (or are otherwise invalid), the \n-     * collection may reduce in size due to calling this method.\n-     * \n-     * @param collection  the collection to get the input from, may be null\n-     * @param transformer  the transformer to perform, may be null\n-     */\n-    public static void transform(Collection collection, Transformer transformer) {\n+     * Transformer creates duplicates (or are otherwise invalid), the collection\n+     * may reduce in size due to calling this method.\n+     *\n+     * @param collection\n+     *            the {@link Iterable} to get the input from, may be null\n+     * @param transformer\n+     *            the transformer to perform, may be null\n+     */\n+    public static <C> void transform(Collection<C> collection,\n+            Transformer<? super C, ? extends C> transformer) {\n         if (collection != null && transformer != null) {\n-            if (collection instanceof List) {\n-                List list = (List) collection;\n-                for (ListIterator it = list.listIterator(); it.hasNext();) {\n+            if (collection instanceof List<?>) {\n+                List<C> list = (List<C>) collection;\n+                for (ListIterator<C> it = list.listIterator(); it.hasNext();) {\n                     it.set(transformer.transform(it.next()));\n                 }\n             } else {\n-                Collection resultCollection = collect(collection, transformer);\n+                Collection<C> resultCollection = collect(collection, transformer);\n                 collection.clear();\n                 collection.addAll(resultCollection);\n             }\n         }\n     }\n \n-    /** \n-     * Counts the number of elements in the input collection that match the predicate.\n+    /**\n+     * Counts the number of elements in the input collection that match the\n+     * predicate.\n      * <p>\n      * A <code>null</code> collection or predicate matches no elements.\n-     * \n-     * @param inputCollection  the collection to get the input from, may be null\n-     * @param predicate  the predicate to use, may be null\n+     *\n+     * @param input\n+     *            the {@link Iterable} to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n      * @return the number of matches for the predicate in the collection\n      */\n-    public static int countMatches(Collection inputCollection, Predicate predicate) {\n+    public static <C> int countMatches(Iterable<C> input, Predicate<? super C> predicate) {\n         int count = 0;\n-        if (inputCollection != null && predicate != null) {\n-            for (Iterator it = inputCollection.iterator(); it.hasNext();) {\n-                if (predicate.evaluate(it.next())) {\n+        if (input != null && predicate != null) {\n+            for (C o : input) {\n+                if (predicate.evaluate(o)) {\n                     count++;\n                 }\n             }\n         return count;\n     }\n \n-    /** \n-     * Answers true if a predicate is true for at least one element of a collection.\n+    /**\n+     * Answers true if a predicate is true for at least one element of a\n+     * collection.\n      * <p>\n      * A <code>null</code> collection or predicate returns false.\n-     * \n-     * @param collection the collection to get the input from, may be null\n-     * @param predicate the predicate to use, may be null\n-     * @return true if at least one element of the collection matches the predicate\n-     */\n-    public static boolean exists(Collection collection, Predicate predicate) {\n-        if (collection != null && predicate != null) {\n-            for (Iterator it = collection.iterator(); it.hasNext();) {\n-                if (predicate.evaluate(it.next())) {\n+     *\n+     * @param input\n+     *            the {@link Iterable} to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return true if at least one element of the collection matches the\n+     *         predicate\n+     */\n+    public static <C> boolean exists(Iterable<C> input, Predicate<? super C> predicate) {\n+        if (input != null && predicate != null) {\n+            for (C o : input) {\n+                if (predicate.evaluate(o)) {\n                     return true;\n                 }\n             }\n         return false;\n     }\n \n-    /** \n-     * Selects all elements from input collection which match the given predicate\n-     * into an output collection.\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate into an output collection.\n      * <p>\n      * A <code>null</code> predicate matches no elements.\n-     * \n-     * @param inputCollection  the collection to get the input from, may not be null\n-     * @param predicate  the predicate to use, may be null\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n      * @return the elements matching the predicate (new list)\n-     * @throws NullPointerException if the input collection is null\n-     */\n-    public static Collection select(Collection inputCollection, Predicate predicate) {\n-        ArrayList answer = new ArrayList(inputCollection.size());\n-        select(inputCollection, predicate, answer);\n-        return answer;\n-    }\n-\n-    /** \n-     * Selects all elements from input collection which match the given predicate\n-     * and adds them to outputCollection.\n-     * <p>\n-     * If the input collection or predicate is null, there is no change to the \n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     */\n+    public static <O> Collection<O> select(Collection<? extends O> inputCollection,\n+            Predicate<? super O> predicate) {\n+        return select(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate and adds them to outputCollection.\n+     * <p>\n+     * If the input collection or predicate is null, there is no change to the\n      * output collection.\n-     * \n-     * @param inputCollection  the collection to get the input from, may be null\n-     * @param predicate  the predicate to use, may be null\n-     * @param outputCollection  the collection to output into, may not be null\n-     */\n-    public static void select(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @param outputCollection\n+     *            the collection to output into, may not be null\n+     * @return outputCollection\n+     */\n+    public static <O, R extends Collection<? super O>> R select(Collection<? extends O> inputCollection,\n+            Predicate<? super O> predicate, R outputCollection) {\n         if (inputCollection != null && predicate != null) {\n-            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n-                Object item = iter.next();\n+            for (O item : inputCollection) {\n                 if (predicate.evaluate(item)) {\n                     outputCollection.add(item);\n                 }\n             }\n         }\n-    }\n-    \n-    /**\n-     * Selects all elements from inputCollection which don't match the given predicate\n-     * into an output collection.\n-     * <p>\n-     * If the input predicate is <code>null</code>, the result is an empty list.\n-     * \n-     * @param inputCollection  the collection to get the input from, may not be null\n-     * @param predicate  the predicate to use, may be null\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate into an output collection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, the result is an empty\n+     * list.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n      * @return the elements <b>not</b> matching the predicate (new list)\n-     * @throws NullPointerException if the input collection is null\n-     */\n-    public static Collection selectRejected(Collection inputCollection, Predicate predicate) {\n-        ArrayList answer = new ArrayList(inputCollection.size());\n-        selectRejected(inputCollection, predicate, answer);\n-        return answer;\n-    }\n-    \n-    /** \n-     * Selects all elements from inputCollection which don't match the given predicate\n-     * and adds them to outputCollection.\n-     * <p>\n-     * If the input predicate is <code>null</code>, no elements are added to <code>outputCollection</code>.\n-     * \n-     * @param inputCollection  the collection to get the input from, may be null\n-     * @param predicate  the predicate to use, may be null\n-     * @param outputCollection  the collection to output into, may not be null\n-     */\n-    public static void selectRejected(Collection inputCollection, Predicate predicate, Collection outputCollection) {\n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     */\n+    public static <O> Collection<O> selectRejected(Collection<? extends O> inputCollection,\n+            Predicate<? super O> predicate) {\n+        return selectRejected(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate and adds them to outputCollection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, no elements are added to\n+     * <code>outputCollection</code>.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @param outputCollection\n+     *            the collection to output into, may not be null\n+     * @return outputCollection\n+     */\n+    public static <O, R extends Collection<? super O>> R selectRejected(\n+            Collection<? extends O> inputCollection, Predicate<? super O> predicate, R outputCollection) {\n         if (inputCollection != null && predicate != null) {\n-            for (Iterator iter = inputCollection.iterator(); iter.hasNext();) {\n-                Object item = iter.next();\n-                if (predicate.evaluate(item) == false) {\n+            for (O item : inputCollection) {\n+                if (!predicate.evaluate(item)) {\n                     outputCollection.add(item);\n                 }\n             }\n         }\n-    }\n-    \n-    /** \n-     * Returns a new Collection consisting of the elements of inputCollection transformed\n-     * by the given transformer.\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Returns a new Collection consisting of the elements of inputCollection\n+     * transformed by the given transformer.\n      * <p>\n      * If the input transformer is null, the result is an empty list.\n-     * \n-     * @param inputCollection  the collection to get the input from, may not be null\n-     * @param transformer  the transformer to use, may be null\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param transformer\n+     *            the transformer to use, may be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n      * @return the transformed result (new list)\n-     * @throws NullPointerException if the input collection is null\n-     */\n-    public static Collection collect(Collection inputCollection, Transformer transformer) {\n-        ArrayList answer = new ArrayList(inputCollection.size());\n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     */\n+    public static <I, O> Collection<O> collect(Iterable<I> inputCollection,\n+            Transformer<? super I, ? extends O> transformer) {\n+        ArrayList<O> answer = new ArrayList<O>();\n         collect(inputCollection, transformer, answer);\n         return answer;\n     }\n-    \n-    /** \n-     * Transforms all elements from the inputIterator with the given transformer \n+\n+    /**\n+     * Transforms all elements from the inputIterator with the given transformer\n      * and adds them to the outputCollection.\n      * <p>\n-     * If the input iterator or transformer is null, the result is an empty list.\n-     * \n-     * @param inputIterator  the iterator to get the input from, may be null\n-     * @param transformer  the transformer to use, may be null\n+     * If the input iterator or transformer is null, the result is an empty\n+     * list.\n+     *\n+     * @param inputIterator\n+     *            the iterator to get the input from, may be null\n+     * @param transformer\n+     *            the transformer to use, may be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n      * @return the transformed result (new list)\n      */\n-    public static Collection collect(Iterator inputIterator, Transformer transformer) {\n-        ArrayList answer = new ArrayList();\n+    public static <I, O> Collection<O> collect(Iterator<I> inputIterator,\n+            Transformer<? super I, ? extends O> transformer) {\n+        ArrayList<O> answer = new ArrayList<O>();\n         collect(inputIterator, transformer, answer);\n         return answer;\n     }\n-    \n-    /** \n-     * Transforms all elements from inputCollection with the given transformer \n+\n+    /**\n+     * Transforms all elements from inputCollection with the given transformer\n      * and adds them to the outputCollection.\n      * <p>\n-     * If the input collection or transformer is null, there is no change to the \n+     * If the input collection or transformer is null, there is no change to the\n      * output collection.\n      *\n      * @param inputCollection  the collection to get the input from, may be null\n      * @param transformer  the transformer to use, may be null\n      * @param outputCollection  the collection to output into, may not be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n      * @return the outputCollection with the transformed input added\n      * @throws NullPointerException if the output collection is null\n      */\n-    public static Collection collect(Collection inputCollection, final Transformer transformer, final Collection outputCollection) {\n+    public static <I, O, R extends Collection<? super O>> R collect(Iterable<? extends I> inputCollection,\n+            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n         if (inputCollection != null) {\n             return collect(inputCollection.iterator(), transformer, outputCollection);\n         }\n         return outputCollection;\n     }\n \n-    /** \n-     * Transforms all elements from the inputIterator with the given transformer \n+    /**\n+     * Transforms all elements from the inputIterator with the given transformer\n      * and adds them to the outputCollection.\n      * <p>\n-     * If the input iterator or transformer is null, there is no change to the \n+     * If the input iterator or transformer is null, there is no change to the\n      * output collection.\n      *\n      * @param inputIterator  the iterator to get the input from, may be null\n      * @param transformer  the transformer to use, may be null\n      * @param outputCollection  the collection to output into, may not be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n      * @return the outputCollection with the transformed input added\n      * @throws NullPointerException if the output collection is null\n      */\n-    public static Collection collect(Iterator inputIterator, final Transformer transformer, final Collection outputCollection) {\n+    //TODO - deprecate and replace with IteratorIterable\n+    public static <I, O, R extends Collection<? super O>> R collect(Iterator<? extends I> inputIterator,\n+            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n         if (inputIterator != null && transformer != null) {\n             while (inputIterator.hasNext()) {\n-                Object item = inputIterator.next();\n-                Object value = transformer.transform(item);\n+                I item = inputIterator.next();\n+                O value = transformer.transform(item);\n                 outputCollection.add(value);\n             }\n         }\n     //-----------------------------------------------------------------------\n     /**\n      * Adds an element to the collection unless the element is null.\n-     * \n+     *\n      * @param collection  the collection to add to, must not be null\n      * @param object  the object to add, if null it will not be added\n      * @return true if the collection changed\n      * @throws NullPointerException if the collection is null\n      * @since Commons Collections 3.2\n      */\n-    public static boolean addIgnoreNull(Collection collection, Object object) {\n+    public static <T> boolean addIgnoreNull(Collection<T> collection, T object) {\n         return (object == null ? false : collection.add(object));\n     }\n-    \n+\n+    /**\n+     * Adds all elements in the {@link Iterable} to the given collection. If the\n+     * {@link Iterable} is a {@link Collection} then it is cast and will be\n+     * added using {@link Collection#addAll(Collection)} instead of iterating.\n+     *\n+     * @param collection\n+     *            the collection to add to, must not be null\n+     * @param iterable\n+     *            the iterable of elements to add, must not be null\n+     * @return a boolean indicating whether the collection has changed or not.\n+     * @throws NullPointerException\n+     *             if the collection or iterator is null\n+     */\n+    public static <C> boolean addAll(Collection<C> collection, Iterable<? extends C> iterable) {\n+        if (iterable instanceof Collection<?>) {\n+            return collection.addAll((Collection<? extends C>) iterable);\n+        }\n+        return addAll(collection, iterable.iterator());\n+    }\n+\n     /**\n      * Adds all elements in the iteration to the given collection.\n-     * \n-     * @param collection  the collection to add to, must not be null\n-     * @param iterator  the iterator of elements to add, must not be null\n-     * @throws NullPointerException if the collection or iterator is null\n-     */\n-    public static void addAll(Collection collection, Iterator iterator) {\n+     *\n+     * @param collection\n+     *            the collection to add to, must not be null\n+     * @param iterator\n+     *            the iterator of elements to add, must not be null\n+     * @return a boolean indicating whether the collection has changed or not.\n+     * @throws NullPointerException\n+     *             if the collection or iterator is null\n+     */\n+    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {\n+        boolean changed = false;\n         while (iterator.hasNext()) {\n-            collection.add(iterator.next());\n-        }\n-    }\n-    \n+            changed |= collection.add(iterator.next());\n+        }\n+        return changed;\n+    }\n+\n     /**\n      * Adds all elements in the enumeration to the given collection.\n-     * \n+     *\n      * @param collection  the collection to add to, must not be null\n      * @param enumeration  the enumeration of elements to add, must not be null\n      * @throws NullPointerException if the collection or enumeration is null\n      */\n-    public static void addAll(Collection collection, Enumeration enumeration) {\n+     //TODO return boolean or collection - check other add() methods too.\n+    public static <C> void addAll(Collection<C> collection, Enumeration<? extends C> enumeration) {\n         while (enumeration.hasMoreElements()) {\n             collection.add(enumeration.nextElement());\n         }\n-    }    \n-    \n-    /** \n+    }\n+\n+    /**\n      * Adds all elements in the array to the given collection.\n-     * \n-     * @param collection  the collection to add to, must not be null\n-     * @param elements  the array of elements to add, must not be null\n-     * @throws NullPointerException if the collection or array is null\n-     */\n-    public static void addAll(Collection collection, Object[] elements) {\n+     *\n+     * @param collection\n+     *            the collection to add to, must not be null\n+     * @param elements\n+     *            the array of elements to add, must not be null\n+     * @throws NullPointerException\n+     *             if the collection or array is null\n+     */\n+    public static <C> void addAll(Collection<C> collection, C[] elements) {\n         for (int i = 0, size = elements.length; i < size; i++) {\n             collection.add(elements[i]);\n         }\n-    }    \n-    \n-    /**\n-     * Given an Object, and an index, returns the nth value in the\n-     * object.\n-     * <ul>\n-     * <li>If obj is a Map, returns the nth value from the <b>keySet</b> iterator, unless \n-     *     the Map contains an Integer key with integer value = idx, in which case the\n-     *     corresponding map entry value is returned.  If idx exceeds the number of entries in\n-     *     the map, an empty Iterator is returned.\n-     * <li>If obj is a List or an array, returns the nth value, throwing IndexOutOfBoundsException,\n-     *     ArrayIndexOutOfBoundsException, resp. if the nth value does not exist.\n-     * <li>If obj is an iterator, enumeration or Collection, returns the nth value from the iterator,\n-     *     returning an empty Iterator (resp. Enumeration) if the nth value does not exist.\n-     * <li>Returns the original obj if it is null or not a Collection or Iterator.\n-     * </ul>\n-     * \n-     * @param obj  the object to get an index of, may be null\n-     * @param idx  the index to get\n-     * @throws IndexOutOfBoundsException\n-     * @throws ArrayIndexOutOfBoundsException\n-     *\n-     * @deprecated use {@link #get(Object, int)} instead. Will be removed in v4.0\n-     */\n-    public static Object index(Object obj, int idx) {\n-        return index(obj, new Integer(idx));\n-    }\n-    \n-    /**\n-     * Given an Object, and a key (index), returns the value associated with\n-     * that key in the Object. The following checks are made:\n-     * <ul>\n-     * <li>If obj is a Map, use the index as a key to get a value. If no match continue.\n-     * <li>Check key is an Integer. If not, return the object passed in.\n-     * <li>If obj is a Map, get the nth value from the <b>keySet</b> iterator.\n-     *     If the Map has fewer than n entries, return an empty Iterator.\n-     * <li>If obj is a List or an array, get the nth value, throwing IndexOutOfBoundsException,\n-     *     ArrayIndexOutOfBoundsException, resp. if the nth value does not exist.\n-     * <li>If obj is an iterator, enumeration or Collection, get the nth value from the iterator,\n-     *     returning an empty Iterator (resp. Enumeration) if the nth value does not exist.\n-     * <li>Return the original obj.\n-     * </ul>\n-     * \n-     * @param obj  the object to get an index of\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * The Iterator is advanced to\n+     *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n+     *      number of entries) as a side effect of this method.</li>\n+     *\n+     * @param iterator  the iterator to get a value from\n      * @param index  the index to get\n+     * @param <T> the type of object in the {@link Iterator}\n      * @return the object at the specified index\n-     * @throws IndexOutOfBoundsException\n-     * @throws ArrayIndexOutOfBoundsException\n-     *\n-     * @deprecated use {@link #get(Object, int)} instead. Will be removed in v4.0\n-     */\n-    public static Object index(Object obj, Object index) {\n-        if(obj instanceof Map) {\n-            Map map = (Map)obj;\n-            if(map.containsKey(index)) {\n-                return map.get(index);\n-            }\n-        }\n-        int idx = -1;\n-        if(index instanceof Integer) {\n-            idx = ((Integer)index).intValue();\n-        }\n-        if(idx < 0) {\n-            return obj;\n-        } \n-        else if(obj instanceof Map) {\n-            Map map = (Map)obj;\n-            Iterator iterator = map.keySet().iterator();\n-            return index(iterator, idx);\n-        } \n-        else if(obj instanceof List) {\n-            return ((List)obj).get(idx);\n-        } \n-        else if(obj instanceof Object[]) {\n-            return ((Object[])obj)[idx];\n-        } \n-        else if(obj instanceof Enumeration) {\n-            Enumeration it = (Enumeration)obj;\n-            while(it.hasMoreElements()) {\n-                idx--;\n-                if(idx == -1) {\n-                    return it.nextElement();\n-                } else {\n-                    it.nextElement();\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @throws IllegalArgumentException if the object type is invalid\n+     */\n+    public static <T> T get(Iterator<T> iterator, int index) {\n+        int i = index;\n+        checkIndexBounds(i);\n+            while (iterator.hasNext()) {\n+                i--;\n+                if (i == -1) {\n+                    return iterator.next();\n                 }\n-            }\n-        } \n-        else if(obj instanceof Iterator) {\n-            return index((Iterator)obj, idx);\n-        }\n-        else if(obj instanceof Collection) {\n-            Iterator iterator = ((Collection)obj).iterator();\n-            return index(iterator, idx);\n-        }\n-        return obj;\n-    }\n-\n-    private static Object index(Iterator iterator, int idx) {\n-        while(iterator.hasNext()) {\n-            idx--;\n-            if(idx == -1) {\n-                return iterator.next();\n-            } else {\n                 iterator.next();\n             }\n-        }\n-        return iterator;\n-    }\n-    \n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+    }\n+\n+    /**\n+     * Ensures an index is not negative.\n+     * @param index the index to check.\n+     * @throws IndexOutOfBoundsException if the index is negative.\n+     */\n+    private static void checkIndexBounds(int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * <p>\n+     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n+     *\n+     * @param iterable  the {@link Iterable} to get a value from\n+     * @param index  the index to get\n+     * @param <T> the type of object in the {@link Iterable}.\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <T> T get(Iterable<T> iterable, int index) {\n+        checkIndexBounds(index);\n+        if (iterable instanceof List<?>) {\n+            return ((List<T>) iterable).get(index);\n+        }\n+        return get(iterable.iterator(), index);\n+    }\n+\n     /**\n      * Returns the <code>index</code>-th value in <code>object</code>, throwing\n-     * <code>IndexOutOfBoundsException</code> if there is no such element or \n-     * <code>IllegalArgumentException</code> if <code>object</code> is not an \n+     * <code>IndexOutOfBoundsException</code> if there is no such element or\n+     * <code>IllegalArgumentException</code> if <code>object</code> is not an\n      * instance of one of the supported types.\n      * <p>\n      * The supported types, and associated semantics are:\n      * <ul>\n-     * <li> Map -- the value returned is the <code>Map.Entry</code> in position \n-     *      <code>index</code> in the map's <code>entrySet</code> iterator, \n+     * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n+     *      <code>index</code> in the map's <code>entrySet</code> iterator,\n      *      if there is such an entry.</li>\n      * <li> List -- this method is equivalent to the list's get method.</li>\n-     * <li> Array -- the <code>index</code>-th array entry is returned, \n+     * <li> Array -- the <code>index</code>-th array entry is returned,\n      *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n      *      is thrown.</li>\n-     * <li> Collection -- the value returned is the <code>index</code>-th object \n+     * <li> Collection -- the value returned is the <code>index</code>-th object\n      *      returned by the collection's default iterator, if there is such an element.</li>\n      * <li> Iterator or Enumeration -- the value returned is the\n      *      <code>index</code>-th object in the Iterator/Enumeration, if there\n-     *      is such an element.  The Iterator/Enumeration is advanced to \n-     *      <code>index</code> (or to the end, if <code>index</code> exceeds the \n+     *      is such an element.  The Iterator/Enumeration is advanced to\n+     *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n      *      number of entries) as a side effect of this method.</li>\n      * </ul>\n-     * \n+     *\n      * @param object  the object to get a value from\n      * @param index  the index to get\n      * @return the object at the specified index\n      * @throws IllegalArgumentException if the object type is invalid\n      */\n     public static Object get(Object object, int index) {\n-        if (index < 0) {\n-            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n-        }\n-        if (object instanceof Map) {\n-            Map map = (Map) object;\n-            Iterator iterator = map.entrySet().iterator();\n-            return get(iterator, index);\n-        } else if (object instanceof List) {\n-            return ((List) object).get(index);\n+        int i = index;\n+        if (i < 0) {\n+            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n+        }\n+        if (object instanceof Map<?,?>) {\n+            Map<?, ?> map = (Map<?, ?>) object;\n+            Iterator<?> iterator = map.entrySet().iterator();\n+            return get(iterator, i);\n         } else if (object instanceof Object[]) {\n-            return ((Object[]) object)[index];\n-        } else if (object instanceof Iterator) {\n-            Iterator it = (Iterator) object;\n+            return ((Object[]) object)[i];\n+        } else if (object instanceof Iterator<?>) {\n+            Iterator<?> it = (Iterator<?>) object;\n             while (it.hasNext()) {\n-                index--;\n-                if (index == -1) {\n+                i--;\n+                if (i == -1) {\n                     return it.next();\n-                } else {\n-                    it.next();\n                 }\n-            }\n-            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n-        } else if (object instanceof Collection) {\n-            Iterator iterator = ((Collection) object).iterator();\n-            return get(iterator, index);\n-        } else if (object instanceof Enumeration) {\n-            Enumeration it = (Enumeration) object;\n+                it.next();\n+            }\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+        } else if (object instanceof Collection<?>) {\n+            Iterator<?> iterator = ((Collection<?>) object).iterator();\n+            return get(iterator, i);\n+        } else if (object instanceof Enumeration<?>) {\n+            Enumeration<?> it = (Enumeration<?>) object;\n             while (it.hasMoreElements()) {\n-                index--;\n-                if (index == -1) {\n+                i--;\n+                if (i == -1) {\n                     return it.nextElement();\n                 } else {\n                     it.nextElement();\n                 }\n             }\n-            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + index);\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n         } else if (object == null) {\n             throw new IllegalArgumentException(\"Unsupported object type: null\");\n         } else {\n             try {\n-                return Array.get(object, index);\n+                return Array.get(object, i);\n             } catch (IllegalArgumentException ex) {\n                 throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n             }\n         }\n     }\n-    \n-    /** \n+\n+    /**\n+     * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     *\n+     * @param map  the object to get a value from\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <K,V> Map.Entry<K, V> get(Map<K,V> map, int index) {\n+        checkIndexBounds(index);\n+        return get(map.entrySet(), index);\n+    }\n+\n+    /**\n      * Gets the size of the collection/iterator specified.\n      * <p>\n      * This method can handles objects as follows\n      * <li>Iterator - the number of elements remaining in the iterator\n      * <li>Enumeration - the number of elements remaining in the enumeration\n      * </ul>\n-     * \n+     *\n      * @param object  the object to get the size of, may be null\n      * @return the size of the specified collection or 0 if the object was null\n      * @throws IllegalArgumentException thrown if object is not recognised\n             return 0;\n         }\n         int total = 0;\n-        if (object instanceof Map) {\n-            total = ((Map) object).size();\n-        } else if (object instanceof Collection) {\n-            total = ((Collection) object).size();\n+        if (object instanceof Map<?,?>) {\n+            total = ((Map<?, ?>) object).size();\n+        } else if (object instanceof Collection<?>) {\n+            total = ((Collection<?>) object).size();\n         } else if (object instanceof Object[]) {\n             total = ((Object[]) object).length;\n-        } else if (object instanceof Iterator) {\n-            Iterator it = (Iterator) object;\n+        } else if (object instanceof Iterator<?>) {\n+            Iterator<?> it = (Iterator<?>) object;\n             while (it.hasNext()) {\n                 total++;\n                 it.next();\n             }\n-        } else if (object instanceof Enumeration) {\n-            Enumeration it = (Enumeration) object;\n+        } else if (object instanceof Enumeration<?>) {\n+            Enumeration<?> it = (Enumeration<?>) object;\n             while (it.hasMoreElements()) {\n                 total++;\n                 it.nextElement();\n         }\n         return total;\n     }\n-    \n+\n     /**\n      * Checks if the specified collection/array/iterator is empty.\n      * <p>\n      * <p>\n      * Note: This method is named to avoid clashing with\n      * {@link #isEmpty(Collection)}.\n-     * \n+     *\n      * @param object  the object to get the size of, may be null\n      * @return true if empty or null\n      * @throws IllegalArgumentException thrown if object is not recognised\n     public static boolean sizeIsEmpty(Object object) {\n         if (object == null) {\n             return true;\n-        } else if (object instanceof Collection) {\n-            return ((Collection) object).isEmpty();\n-        } else if (object instanceof Map) {\n-            return ((Map) object).isEmpty();\n+        } else if (object instanceof Collection<?>) {\n+            return ((Collection<?>) object).isEmpty();\n+        } else if (object instanceof Map<?, ?>) {\n+            return ((Map<?, ?>) object).isEmpty();\n         } else if (object instanceof Object[]) {\n             return ((Object[]) object).length == 0;\n-        } else if (object instanceof Iterator) {\n-            return ((Iterator) object).hasNext() == false;\n-        } else if (object instanceof Enumeration) {\n-            return ((Enumeration) object).hasMoreElements() == false;\n+        } else if (object instanceof Iterator<?>) {\n+            return ((Iterator<?>) object).hasNext() == false;\n+        } else if (object instanceof Enumeration<?>) {\n+            return ((Enumeration<?>) object).hasMoreElements() == false;\n         } else {\n             try {\n                 return Array.getLength(object) == 0;\n      * Null-safe check if the specified collection is empty.\n      * <p>\n      * Null returns true.\n-     * \n+     *\n      * @param coll  the collection to check, may be null\n      * @return true if empty or null\n      * @since Commons Collections 3.2\n      */\n-    public static boolean isEmpty(Collection coll) {\n+    public static boolean isEmpty(Collection<?> coll) {\n         return (coll == null || coll.isEmpty());\n     }\n \n      * Null-safe check if the specified collection is not empty.\n      * <p>\n      * Null returns false.\n-     * \n+     *\n      * @param coll  the collection to check, may be null\n      * @return true if non-null and non-empty\n      * @since Commons Collections 3.2\n      */\n-    public static boolean isNotEmpty(Collection coll) {\n-        return !CollectionUtils.isEmpty(coll);\n+    public static boolean isNotEmpty(Collection<?> coll) {\n+        return !isEmpty(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Reverses the order of the given array.\n-     * \n+     *\n      * @param array  the array to reverse\n      */\n     public static void reverseArray(Object[] array) {\n         }\n     }\n \n-    private static final int getFreq(final Object obj, final Map freqMap) {\n-        Integer count = (Integer) freqMap.get(obj);\n-        if (count != null) {\n-            return count.intValue();\n-        }\n-        return 0;\n-    }\n-\n     /**\n      * Returns true if no more elements can be added to the Collection.\n      * <p>\n      * @return true if the BoundedCollection is full\n      * @throws NullPointerException if the collection is null\n      */\n-    public static boolean isFull(Collection coll) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static boolean isFull(Collection<?> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n         if (coll instanceof BoundedCollection) {\n-            return ((BoundedCollection) coll).isFull();\n+            return ((BoundedCollection<?>) coll).isFull();\n         }\n         try {\n-            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n+            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.decorateUsing((Collection<Object>) coll);\n             return bcoll.isFull();\n-            \n         } catch (IllegalArgumentException ex) {\n             return false;\n         }\n      * @return the maximum size of the BoundedCollection, -1 if no maximum size\n      * @throws NullPointerException if the collection is null\n      */\n-    public static int maxSize(Collection coll) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static int maxSize(Collection<?> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n         if (coll instanceof BoundedCollection) {\n-            return ((BoundedCollection) coll).maxSize();\n+            return ((BoundedCollection<?>) coll).maxSize();\n         }\n         try {\n-            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n+            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.decorateUsing((Collection<Object>) coll);\n             return bcoll.maxSize();\n-            \n         } catch (IllegalArgumentException ex) {\n             return -1;\n         }\n      * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n      * case the cardinality is zero. This method is useful if you do not wish to modify\n      * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n-     * \n+     *\n      * @param collection  the collection whose contents are the target of the #retailAll operation\n      * @param retain  the collection containing the elements to be retained in the returned collection\n      * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n      * @throws NullPointerException if either parameter is null\n      * @since Commons Collections 3.2\n      */\n-    public static Collection retainAll(Collection collection, Collection retain) {\n+    public static <C> Collection<C> retainAll(Collection<C> collection, Collection<?> retain) {\n         return ListUtils.retainAll(collection, retain);\n     }\n \n      * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n      * case the cardinality is zero. This method is useful if you do not wish to modify\n      * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n-     * \n+     *\n      * @param collection  the collection from which items are removed (in the returned collection)\n      * @param remove  the items to be removed from the returned <code>collection</code>\n      * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n      * @throws NullPointerException if either parameter is null\n      * @since Commons Collections 3.3 (method existed in 3.2 but was completely broken)\n      */\n-    public static Collection removeAll(Collection collection, Collection remove) {\n+    public static <E> Collection<E> removeAll(Collection<E> collection, Collection<?> remove) {\n         return ListUtils.removeAll(collection, remove);\n     }\n \n     /**\n      * Returns a synchronized collection backed by the given collection.\n      * <p>\n-     * You must manually synchronize on the returned buffer's iterator to \n+     * You must manually synchronize on the returned buffer's iterator to\n      * avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n      * synchronized (c) {\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * This method uses the implementation in the decorators subpackage.\n-     * \n+     *\n      * @param collection  the collection to synchronize, must not be null\n      * @return a synchronized collection backed by the given collection\n      * @throws IllegalArgumentException  if the collection is null\n      */\n-    public static Collection synchronizedCollection(Collection collection) {\n+    public static <C> Collection<C> synchronizedCollection(Collection<C> collection) {\n         return SynchronizedCollection.decorate(collection);\n     }\n \n      * @return an unmodifiable collection backed by the given collection\n      * @throws IllegalArgumentException  if the collection is null\n      */\n-    public static Collection unmodifiableCollection(Collection collection) {\n+    public static <C> Collection<C> unmodifiableCollection(Collection<C> collection) {\n         return UnmodifiableCollection.decorate(collection);\n     }\n \n      *\n      * @param collection  the collection to predicate, must not be null\n      * @param predicate  the predicate for the collection, must not be null\n+     * @param <C> the type of objects in the Collection.\n      * @return a predicated collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection is null\n      */\n-    public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n+    public static <C> Collection<C> predicatedCollection(Collection<C> collection, Predicate<? super C> predicate) {\n         return PredicatedCollection.decorate(collection, predicate);\n     }\n \n     /**\n-     * Returns a typed collection backed by the given collection.\n-     * <p>\n-     * Only objects of the specified type can be added to the collection.\n-     * \n-     * @param collection  the collection to limit to a specific type, must not be null\n-     * @param type  the type of objects which may be added to the collection\n-     * @return a typed collection backed by the specified collection\n-     */\n-    public static Collection typedCollection(Collection collection, Class type) {\n-        return TypedCollection.decorate(collection, type);\n-    }\n-    \n-    /**\n      * Returns a transformed bag backed by the given collection.\n      * <p>\n      * Each object is passed through the transformer as it is added to the\n-     * Collection. It is important not to use the original collection after invoking this \n+     * Collection. It is important not to use the original collection after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified collection will not be transformed.\n      * @return a transformed collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection or Transformer is null\n      */\n-    public static Collection transformedCollection(Collection collection, Transformer transformer) {\n+    public static <E> Collection<E> transformedCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n         return TransformedCollection.decorate(collection, transformer);\n     }\n \n+    /**\n+     * Extract the lone element of the specified Collection.\n+     * @param <E> collection type\n+     * @param collection to read\n+     * @return sole member of collection\n+     * @throws IllegalArgumentException if collection is null/empty or contains more than one element\n+     */\n+    public static <E> E extractSingleton(Collection<E> collection) {\n+        if (collection == null || collection.size() != 1) {\n+            throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n+        }\n+        return collection.iterator().next();\n+    }\n }", "timestamp": 1252994094, "metainfo": ""}