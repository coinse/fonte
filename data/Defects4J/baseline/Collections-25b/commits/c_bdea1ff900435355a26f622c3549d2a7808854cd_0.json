{"sha": "bdea1ff900435355a26f622c3549d2a7808854cd", "log": "Renamed collection tests.  ", "commit": "\n--- a/src/test/java/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/java/org/apache/commons/collections/TestMapUtils.java\n import org.apache.commons.collections.map.HashedMap;\n import org.apache.commons.collections.map.LazyMap;\n import org.apache.commons.collections.map.PredicatedMap;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Tests for MapUtils.\n \n         // Now test key transform population\n         Map<Object, Object> map = new HashMap<Object, Object>();\n-        MapUtils.populateMap(map, list, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(list.size(), map.size());\n \n         for (int i = 0; i < list.size(); i++) {\n \n         // Now test both Key-Value transform population\n         map = new HashMap<Object, Object>();\n-        MapUtils.populateMap(map, list, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n \n         assertEquals(list.size(), map.size());\n         for (int i = 0; i < list.size(); i++) {\n--- a/src/test/java/org/apache/commons/collections/bag/TransformedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/TransformedBagTest.java\n \n import org.apache.commons.collections.Bag;\n import org.apache.commons.collections.Transformer;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractBagTest} for exercising the {@link TransformedBag}\n     @SuppressWarnings(\"unchecked\")\n     public Bag<T> makeObject() {\n         return TransformedBag.transformingBag(new HashBag<T>(),\n-                (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n+                (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n         //T had better be Object!\n         Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(),\n-                (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n             originalBag.add((T) els[i]);\n         }\n         Bag<T> bag = TransformedBag.transformedBag(originalBag,\n-                (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, bag.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, bag.contains(new Integer((String) els[i])));\n--- a/src/test/java/org/apache/commons/collections/bag/TransformedSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/TransformedSortedBagTest.java\n import org.apache.commons.collections.Bag;\n import org.apache.commons.collections.SortedBag;\n import org.apache.commons.collections.Transformer;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractSortedBagTest} for exercising the {@link TransformedSortedBag}\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SortedBag<T> makeObject() {\n-        return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n-        SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalBag.add(els[i]);\n         }\n-        Bag<?> bag = TransformedBag.transformedBag(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Bag<?> bag = TransformedBag.transformedBag(originalBag, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, bag.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, bag.contains(new Integer((String) els[i])));\n--- a/src/test/java/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java\n \n import org.apache.commons.collections.BufferUnderflowException;\n import org.apache.commons.collections.BulkTest;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n \n /**\n  * Test cases for BoundedFifoBuffer.\n  *\n  * @author Paul Jack\n  */\n-public class TestBoundedFifoBuffer<E> extends AbstractTestCollection<E> {\n+public class TestBoundedFifoBuffer<E> extends AbstractCollectionTest<E> {\n \n     public TestBoundedFifoBuffer(String n) {\n         super(n);\n--- a/src/test/java/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java\n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferUnderflowException;\n import org.apache.commons.collections.BulkTest;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n \n /**\n  * Test cases for CircularFifoBuffer.\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestCircularFifoBuffer<E> extends AbstractTestCollection<E> {\n+public class TestCircularFifoBuffer<E> extends AbstractCollectionTest<E> {\n \n     public TestCircularFifoBuffer(String n) {\n         super(n);\n--- a/src/test/java/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferUnderflowException;\n import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.collection.TestPredicatedCollection;\n+import org.apache.commons.collections.collection.PredicatedCollectionTest;\n \n /**\n- * Extension of {@link TestPredicatedCollection} for exercising the\n+ * Extension of {@link PredicatedCollectionTest} for exercising the\n  * {@link PredicatedBuffer} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestPredicatedBuffer<E> extends TestPredicatedCollection<E> {\n+public class TestPredicatedBuffer<E> extends PredicatedCollectionTest<E> {\n \n     public TestPredicatedBuffer(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/buffer/TestPriorityBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestPriorityBuffer.java\n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferUnderflowException;\n import org.apache.commons.collections.ComparatorUtils;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n import org.apache.commons.collections.comparators.ComparableComparator;\n import org.apache.commons.collections.comparators.ReverseComparator;\n \n  * @author Steve Phelps\n  */\n @SuppressWarnings(\"boxing\")\n-public class TestPriorityBuffer<E> extends AbstractTestCollection<E> {\n+public class TestPriorityBuffer<E> extends AbstractCollectionTest<E> {\n \n     public TestPriorityBuffer(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n \n import org.apache.commons.collections.ArrayStack;\n import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n \n /**\n- * Extension of {@link AbstractTestCollection} for exercising the\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n  * {@link SynchronizedBuffer} implementation.\n  *\n  * @since Commons Collections 3.1\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class TestSynchronizedBuffer<E> extends AbstractTestCollection<E> {\n+public class TestSynchronizedBuffer<E> extends AbstractCollectionTest<E> {\n \n     public TestSynchronizedBuffer(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n import junit.framework.TestCase;\n import org.apache.commons.collections.ArrayStack;\n import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link TestCase} for exercising the {@link TransformedBuffer}\n     }\n \n     public void testTransformedBuffer() {\n-        Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, buffer.size());\n         Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalBuffer.add(els[i]);\n         }\n-        Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, buffer.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, buffer.contains(new Integer((String) els[i])));\n--- a/src/test/java/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java\n import junit.framework.Test;\n \n import org.apache.commons.collections.BulkTest;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n \n /**\n  * Test cases for UnboundedFifoBuffer.\n  *\n  * @author Unknown\n  */\n-public class TestUnboundedFifoBuffer<E> extends AbstractTestCollection<E> {\n+public class TestUnboundedFifoBuffer<E> extends AbstractCollectionTest<E> {\n \n     public TestUnboundedFifoBuffer(String n) {\n         super(n);\n--- a/src/test/java/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n \n import org.apache.commons.collections.ArrayStack;\n import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n \n /**\n- * Extension of {@link AbstractTestCollection} for exercising the\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n  * {@link UnmodifiableBuffer} implementation.\n  *\n  * @since Commons Collections 3.1\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableBuffer<E> extends AbstractTestCollection<E> {\n+public class TestUnmodifiableBuffer<E> extends AbstractCollectionTest<E> {\n \n     public TestUnmodifiableBuffer(String testName) {\n         super(testName);\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+\n+/**\n+ * Abstract test class for {@link java.util.Collection} methods and contracts.\n+ * <p>\n+ * You should create a concrete subclass of this class to test any custom\n+ * {@link Collection} implementation.  At minimum, you'll have to\n+ * implement the @{@link #makeObject()}, {@link #makeConfirmedCollection()}\n+ * and {@link #makeConfirmedFullCollection()} methods.\n+ * You might want to override some of the additional public methods as well:\n+ * <p>\n+ * <b>Element Population Methods</b>\n+ * <p>\n+ * Override these if your collection restricts what kind of elements are\n+ * allowed (for instance, if <code>null</code> is not permitted):\n+ * <ul>\n+ * <li>{@link #getFullElements()}\n+ * <li>{@link #getOtherElements()}\n+ * </ul>\n+ * <p>\n+ * <b>Supported Operation Methods</b>\n+ * <p>\n+ * Override these if your collection doesn't support certain operations:\n+ * <ul>\n+ * <li>{@link #isAddSupported()}\n+ * <li>{@link #isRemoveSupported()}\n+ * <li>{@link #areEqualElementsDistinguishable()}\n+ * <li>{@link #isNullSupported()}\n+ * <li>{@link #isFailFastSupported()}\n+ * </ul>\n+ * <p>\n+ * <b>Fixture Methods</b>\n+ * <p>\n+ * Fixtures are used to verify that the the operation results in correct state\n+ * for the collection.  Basically, the operation is performed against your\n+ * collection implementation, and an identical operation is performed against a\n+ * <i>confirmed</i> collection implementation.  A confirmed collection\n+ * implementation is something like <code>java.util.ArrayList</code>, which is\n+ * known to conform exactly to its collection interface's contract.  After the\n+ * operation takes place on both your collection implementation and the\n+ * confirmed collection implementation, the two collections are compared to see\n+ * if their state is identical.  The comparison is usually much more involved\n+ * than a simple <code>equals</code> test.  This verification is used to ensure\n+ * proper modifications are made along with ensuring that the collection does\n+ * not change when read-only modifications are made.\n+ * <p>\n+ * The {@link #collection} field holds an instance of your collection\n+ * implementation; the {@link #confirmed} field holds an instance of the\n+ * confirmed collection implementation.  The {@link #resetEmpty()} and\n+ * {@link #resetFull()} methods set these fields to empty or full collections,\n+ * so that tests can proceed from a known state.\n+ * <p>\n+ * After a modification operation to both {@link #collection} and\n+ * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n+ * the results.  You may want to override {@link #verify()} to perform\n+ * additional verifications.  For instance, when testing the collection\n+ * views of a map, {@link org.apache.commons.collections.map.AbstractTestMap AbstractTestMap} \n+ * would override {@link #verify()} to make\n+ * sure the map is changed after the collection view is changed.\n+ * <p>\n+ * If you're extending this class directly, you will have to provide\n+ * implementations for the following:\n+ * <ul>\n+ * <li>{@link #makeConfirmedCollection()}\n+ * <li>{@link #makeConfirmedFullCollection()}\n+ * </ul>\n+ * <p>\n+ * Those methods should provide a confirmed collection implementation\n+ * that's compatible with your collection implementation.\n+ * <p>\n+ * If you're extending {@link org.apache.commons.collections.list.AbstractTestList AbstractTestList},\n+ * {@link org.apache.commons.collections.set.AbstractTestSet AbstractTestSet},\n+ * or {@link org.apache.commons.collections.bag.AbstractBagTest AbstractTestBag}, \n+ * you probably don't have to worry about the\n+ * above methods, because those three classes already override the methods\n+ * to provide standard JDK confirmed collections.<P>\n+ * <p>\n+ * <b>Other notes</b>\n+ * <p>\n+ * If your {@link Collection} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Collection} fails.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractCollectionTest<E> extends AbstractTestObject {\n+\n+    //\n+    // NOTE:\n+    //\n+    // Collection doesn't define any semantics for equals, and recommends you\n+    // use reference-based default behavior of Object.equals.  (And a test for\n+    // that already exists in AbstractTestObject).  Tests for equality of lists, sets\n+    // and bags will have to be written in test subclasses.  Thus, there is no\n+    // tests on Collection.equals nor any for Collection.hashCode.\n+    //\n+\n+    // These fields are used by reset() and verify(), and any test\n+    // method that tests a modification.\n+\n+    /**\n+     *  A collection instance that will be used for testing.\n+     */\n+    private Collection<E> collection;\n+\n+    /**\n+     *  Confirmed collection.  This is an instance of a collection that is\n+     *  confirmed to conform exactly to the java.util.Collection contract.\n+     *  Modification operations are tested by performing a mod on your\n+     *  collection, performing the exact same mod on an equivalent confirmed\n+     *  collection, and then calling verify() to make sure your collection\n+     *  still matches the confirmed collection.\n+     */\n+    private Collection<E> confirmed;\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractCollectionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Specifies whether equal elements in the collection are, in fact,\n+     *  distinguishable with information not readily available.  That is, if a\n+     *  particular value is to be removed from the collection, then there is\n+     *  one and only one value that can be removed, even if there are other\n+     *  elements which are equal to it.\n+     *\n+     *  <P>In most collection cases, elements are not distinguishable (equal is\n+     *  equal), thus this method defaults to return false.  In some cases,\n+     *  however, they are.  For example, the collection returned from the map's\n+     *  values() collection view are backed by the map, so while there may be\n+     *  two values that are equal, their associated keys are not.  Since the\n+     *  keys are distinguishable, the values are.\n+     *\n+     *  <P>This flag is used to skip some verifications for iterator.remove()\n+     *  where it is impossible to perform an equivalent modification on the\n+     *  confirmed collection because it is not possible to determine which\n+     *  value in the confirmed collection to actually remove.  Tests that\n+     *  override the default (i.e. where equal elements are distinguishable),\n+     *  should provide additional tests on iterator.remove() to make sure the\n+     *  proper elements are removed when remove() is called on the iterator.\n+     **/\n+    public boolean areEqualElementsDistinguishable() {\n+        return false;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>add</code> and <code>addAll</code>\n+     *  operations.<P>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support add or addAll.\n+     */\n+    public boolean isAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>remove</code>, <code>removeAll</code>,\n+     *  <code>retainAll</code>, <code>clear</code> and\n+     *  <code>iterator().remove()</code> methods.\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports holding null.\n+     * The default implementation returns true;\n+     */\n+    public boolean isNullSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports fail fast iterators.\n+     * The default implementation returns true;\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns false;\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that {@link #collection} and {@link #confirmed} have\n+     *  identical state.\n+     */\n+    public void verify() {\n+        int confirmedSize = getConfirmed().size();\n+        assertEquals(\"Collection size should match confirmed collection's\", confirmedSize,\n+                getCollection().size());\n+        assertEquals(\"Collection isEmpty() result should match confirmed collection's\",\n+                getConfirmed().isEmpty(), getCollection().isEmpty());\n+\n+        // verify the collections are the same by attempting to match each\n+        // object in the collection and confirmed collection.  To account for\n+        // duplicates and differing orders, each confirmed element is copied\n+        // into an array and a flag is maintained for each element to determine\n+        // whether it has been matched once and only once.  If all elements in\n+        // the confirmed collection are matched once and only once and there\n+        // aren't any elements left to be matched in the collection,\n+        // verification is a success.\n+\n+        // copy each collection value into an array\n+        Object[] confirmedValues = new Object[confirmedSize];\n+\n+        Iterator<E> iter;\n+\n+        iter = getConfirmed().iterator();\n+        int pos = 0;\n+        while (iter.hasNext()) {\n+            confirmedValues[pos++] = iter.next();\n+        }\n+\n+        // allocate an array of boolean flags for tracking values that have\n+        // been matched once and only once.\n+        boolean[] matched = new boolean[confirmedSize];\n+\n+        // now iterate through the values of the collection and try to match\n+        // the value with one in the confirmed array.\n+        iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            boolean match = false;\n+            for (int i = 0; i < confirmedSize; i++) {\n+                if (matched[i]) {\n+                    // skip values already matched\n+                    continue;\n+                }\n+                if (o == confirmedValues[i] || (o != null && o.equals(confirmedValues[i]))) {\n+                    // values matched\n+                    matched[i] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            // no match found!\n+            if (!match) {\n+                fail(\"Collection should not contain a value that the \"\n+                        + \"confirmed collection does not have: \" + o + \"\\nTest: \" + getCollection()\n+                        + \"\\nReal: \" + getConfirmed());\n+            }\n+        }\n+\n+        // make sure there aren't any unmatched values\n+        for (int i = 0; i < confirmedSize; i++) {\n+            if (!matched[i]) {\n+                // the collection didn't match all the confirmed values\n+                fail(\"Collection should contain all values that are in the confirmed collection\"\n+                        + \"\\nTest: \" + getCollection() + \"\\nReal: \" + getConfirmed());\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    public void resetEmpty() {\n+        this.setCollection(makeObject());\n+        this.setConfirmed(makeConfirmedCollection());\n+    }\n+\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    public void resetFull() {\n+        this.setCollection(makeFullCollection());\n+        this.setConfirmed(makeConfirmedFullCollection());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a confirmed empty collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.\n+     *\n+     *  @return a confirmed empty collection\n+     */\n+    public abstract Collection<E> makeConfirmedCollection();\n+\n+    /**\n+     *  Returns a confirmed full collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.  The returned collection\n+     *  should contain the elements returned by {@link #getFullElements()}.\n+     *\n+     *  @return a confirmed full collection\n+     */\n+    public abstract Collection<E> makeConfirmedFullCollection();\n+\n+    /**\n+     * Return a new, empty {@link Collection} to be used for testing.\n+     */\n+    @Override\n+    public abstract Collection<E> makeObject();\n+\n+    /**\n+     *  Returns a full collection to be used for testing.  The collection\n+     *  returned by this method should contain every element returned by\n+     *  {@link #getFullElements()}.  The default implementation, in fact,\n+     *  simply invokes <code>addAll</code> on an empty collection with\n+     *  the results of {@link #getFullElements()}.  Override this default\n+     *  if your collection doesn't support addAll.\n+     */\n+    public Collection<E> makeFullCollection() {\n+        Collection<E> c = makeObject();\n+        c.addAll(Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Creates a new Map Entry that is independent of the first and the map.\n+     */\n+    public Map.Entry<E, E> cloneMapEntry(Map.Entry<E, E> entry) {\n+        HashMap<E, E> map = new HashMap<E, E>();\n+        map.put(entry.getKey(), entry.getValue());\n+        return map.entrySet().iterator().next();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an array of objects that are contained in a collection\n+     *  produced by {@link #makeFullCollection()}.  Every element in the\n+     *  returned array <I>must</I> be an element in a full collection.<P>\n+     *  The default implementation returns a heterogenous array of\n+     *  objects with some duplicates. null is added if allowed.\n+     *  Override if you require specific testing elements.  Note that if you\n+     *  override {@link #makeFullCollection()}, you <I>must</I> override\n+     *  this method to reflect the contents of a full collection.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        if (isNullSupported()) {\n+            ArrayList<E> list = new ArrayList<E>();\n+            list.addAll(Arrays.asList(getFullNonNullElements()));\n+            list.add(4, null);\n+            return (E[]) list.toArray();\n+        }\n+        return getFullNonNullElements().clone();\n+    }\n+\n+    /**\n+     *  Returns an array of elements that are <I>not</I> contained in a\n+     *  full collection.  Every element in the returned array must\n+     *  not exist in a collection returned by {@link #makeFullCollection()}.\n+     *  The default implementation returns a heterogenous array of elements\n+     *  without null.  Note that some of the tests add these elements\n+     *  to an empty or full collection, so if your collection restricts\n+     *  certain kinds of elements, you should override this method.\n+     */\n+    public E[] getOtherElements() {\n+        return getOtherNonNullElements();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a list of elements suitable for return by\n+     *  {@link #getFullElements()}.  The array returned by this method\n+     *  does not include null, but does include a variety of objects\n+     *  of different types.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  the null element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        return (E[]) new Object[] {\n+            new String(\"\"),\n+            new String(\"One\"),\n+            new Integer(2),\n+            \"Three\",\n+            new Integer(4),\n+            \"One\",\n+            new Double(5),\n+            new Float(6),\n+            \"Seven\",\n+            \"Eight\",\n+            new String(\"Nine\"),\n+            new Integer(10),\n+            new Short((short)11),\n+            new Long(12),\n+            \"Thirteen\",\n+            \"14\",\n+            \"15\",\n+            new Byte((byte)16)\n+        };\n+    }\n+\n+    /**\n+     *  Returns the default list of objects returned by\n+     *  {@link #getOtherElements()}.  Includes many objects\n+     *  of different types.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        return (E[]) new Object[] {\n+            new Integer(0),\n+            new Float(0),\n+            new Double(0),\n+            \"Zero\",\n+            new Short((short)0),\n+            new Byte((byte)0),\n+            new Long(0),\n+            new Character('\\u0000'),\n+            \"0\"\n+        };\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link #getFullElements()}.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public Object[] getFullNonNullStringElements() {\n+        return new Object[] {\n+            \"If\", \"the\", \"dull\", \"substance\", \"of\", \"my\", \"flesh\", \"were\",\n+                \"thought\", \"Injurious\", \"distance\", \"could\", \"not\", \"stop\", \"my\", \"way\",\n+        };\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link #getOtherElements()}.  Override getOtherElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\", \"then\", \"despite\",/* of */\"space\", \"I\", \"would\", \"be\",\n+                \"brought\", \"From\", \"limits\", \"far\", \"remote\", \"where\", \"thou\", \"dost\", \"stay\"\n+        };\n+    }\n+\n+    // Tests\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link Collection#add(Object)}.\n+     */\n+    public void testCollectionAdd() {\n+        if (!isAddSupported()) return;\n+\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            resetEmpty();\n+            boolean r = getCollection().add(elements[i]);\n+            getConfirmed().add(elements[i]);\n+            verify();\n+            assertTrue(\"Empty collection changed after add\", r);\n+            assertEquals(\"Collection size is 1 after first add\", 1, getCollection().size());\n+        }\n+\n+        resetEmpty();\n+        int size = 0;\n+        for (int i = 0; i < elements.length; i++) {\n+            boolean r = getCollection().add(elements[i]);\n+            getConfirmed().add(elements[i]);\n+            verify();\n+            if (r) size++;\n+            assertEquals(\"Collection size should grow after add\", size, getCollection().size());\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(elements[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#addAll(Collection)}.\n+     */\n+    public void testCollectionAddAll() {\n+        if (!isAddSupported()) return;\n+\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(elements[i]));\n+        }\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        elements = getOtherElements();\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain added element\",\n+                    getCollection().contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\", size + elements.length, getCollection().size());\n+\n+        resetFull();\n+        size = getCollection().size();\n+        r = getCollection().addAll(Arrays.asList(getFullElements()));\n+        getConfirmed().addAll(Arrays.asList(getFullElements()));\n+        verify();\n+        if (r) {\n+            assertTrue(\"Size should increase if addAll returns true\", size < getCollection().size());\n+        } else {\n+            assertEquals(\"Size should not change if addAll returns false\", size, getCollection().size());\n+        }\n+    }\n+\n+    /**\n+     *  If {@link #isAddSupported()} returns false, tests that add operations\n+     *  raise <code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedAdd() {\n+        if (isAddSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Empty collection should not support add.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getFullElements()));\n+            fail(\"Empty collection should not support addAll.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        resetFull();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Full collection should not support add.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n+            fail(\"Full collection should not support addAll.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+\n+    /**\n+     *  Test {@link Collection#clear()}.\n+     */\n+    public void testCollectionClear() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        getCollection().clear(); // just to make sure it doesn't raise anything\n+        verify();\n+\n+        resetFull();\n+        getCollection().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#contains(Object)}.\n+     */\n+    public void testCollectionContains() {\n+        Object[] elements;\n+\n+        resetEmpty();\n+        elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        elements = getOtherElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain element[\" + i + \"]\",\n+                    getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getOtherElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection shouldn't contain element\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#containsAll(Collection)}.\n+     */\n+    public void testCollectionContainsAll() {\n+        resetEmpty();\n+        Collection<E> col = new HashSet<E>();\n+        assertTrue(\"Every Collection should contain all elements of an \" +\n+                \"empty Collection.\", getCollection().containsAll(col));\n+        col.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Empty Collection shouldn't contain all elements of \" +\n+                \"a non-empty Collection.\", !getCollection().containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection shouldn't contain other elements\",\n+                !getCollection().containsAll(col));\n+\n+        col.clear();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll full elements\",\n+                getCollection().containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        int min = (getFullElements().length < 2 ? 0 : 2);\n+        int max = (getFullElements().length == 1 ? 1 :\n+                (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n+        col = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection should containAll partial full elements\",\n+                getCollection().containsAll(col));\n+        assertTrue(\"Full collection should containAll itself\", getCollection().containsAll(getCollection()));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        col = new ArrayList<E>();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll duplicate full elements\",\n+                getCollection().containsAll(col));\n+\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#isEmpty()}.\n+     */\n+    public void testCollectionIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"New Collection should be empty.\", true, getCollection().isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Full collection shouldn't be empty\", false, getCollection().isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests the read-only functionality of {@link Collection#iterator()}.\n+     */\n+    public void testCollectionIterator() {\n+        resetEmpty();\n+        Iterator<E> it1 = getCollection().iterator();\n+        assertEquals(\"Iterator for empty Collection shouldn't have next.\", false, it1.hasNext());\n+        try {\n+            it1.next();\n+            fail(\"Iterator at end of Collection should throw \"\n+                    + \"NoSuchElementException when next is called.\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+        // make sure nothing has changed after non-modification\n+        verify();\n+\n+        resetFull();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            assertTrue(\"Iterator for full collection should haveNext\", it1.hasNext());\n+            it1.next();\n+        }\n+        assertTrue(\"Iterator should be finished\", !it1.hasNext());\n+\n+        ArrayList<E> list = new ArrayList<E>();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            E next = it1.next();\n+            assertTrue(\"Collection should contain element returned by its iterator\",\n+                    getCollection().contains(next));\n+            list.add(next);\n+        }\n+        try {\n+            it1.next();\n+            fail(\"iterator.next() should raise NoSuchElementException after it finishes\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+        // make sure nothing has changed after non-modification\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests removals from {@link Collection#iterator()}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCollectionIteratorRemove() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().iterator().remove();\n+            fail(\"New iterator.remove should raise IllegalState\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            iter.hasNext();\n+            iter.remove();\n+            fail(\"New iterator.remove should raise IllegalState even after hasNext\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        Iterator<E> iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            // TreeMap reuses the Map Entry, so the verify below fails\n+            // Clone it here if necessary\n+            if (o instanceof Map.Entry) {\n+                o = cloneMapEntry((Map.Entry<E, E>) o);\n+            }\n+            iter.remove();\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how).\n+            //\n+            // see areEqualElementsDistinguishable()\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(o);\n+                verify();\n+            }\n+\n+            size--;\n+            assertEquals(\"Collection should shrink by one after iterator.remove\", size,\n+                    getCollection().size());\n+        }\n+        assertTrue(\"Collection should be empty after iterator purge\", getCollection().isEmpty());\n+\n+        resetFull();\n+        iter = getCollection().iterator();\n+        iter.next();\n+        iter.remove();\n+        try {\n+            iter.remove();\n+            fail(\"Second iter.remove should raise IllegalState\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#remove(Object)}.\n+     */\n+    public void testCollectionRemove() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent element\", !getCollection().remove(elements[i]));\n+            verify();\n+        }\n+\n+        E[] other = getOtherElements();\n+\n+        resetFull();\n+        for (int i = 0; i < other.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent other element\", !getCollection().remove(other[i]));\n+            verify();\n+        }\n+\n+        int size = getCollection().size();\n+        for (int i = 0; i < elements.length; i++) {\n+            resetFull();\n+            assertTrue(\"Collection should remove extant element: \" + elements[i],\n+                    getCollection().remove(elements[i]));\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how).\n+            //\n+            // see areEqualElementsDistinguishable()\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(elements[i]);\n+                verify();\n+            }\n+\n+            assertEquals(\"Collection should shrink after remove\", size - 1, getCollection().size());\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#removeAll(Collection)}.\n+     */\n+    public void testCollectionRemoveAll() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        assertTrue(\"Empty collection removeAll should return false for empty input\",\n+                !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty collection removeAll should return false for nonempty input\",\n+                   !getCollection().removeAll(new ArrayList<E>(getCollection())));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection removeAll should return false for empty input\",\n+                   !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return false for other elements\",\n+                   !getCollection().removeAll(Arrays.asList(getOtherElements())));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return true for full elements\",\n+                getCollection().removeAll(new HashSet<E>(getCollection())));\n+        getConfirmed().removeAll(new HashSet<E>(getConfirmed()));\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        int min = (getFullElements().length < 2 ? 0 : 2);\n+        int max = (getFullElements().length == 1 ? 1 :\n+                (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n+        Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection removeAll should work\", getCollection().removeAll(all));\n+        getConfirmed().removeAll(all);\n+        verify();\n+\n+        assertTrue(\"Collection should shrink after removeAll\", getCollection().size() < size);\n+        Iterator<E> iter = all.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Collection shouldn't contain removed element\",\n+                    !getCollection().contains(iter.next()));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#retainAll(Collection)}.\n+     */\n+    public void testCollectionRetainAll() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        List<E> elements = Arrays.asList(getFullElements());\n+        List<E> other = Arrays.asList(getOtherElements());\n+\n+        assertTrue(\"Empty retainAll() should return false\",\n+                !getCollection().retainAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty retainAll() should return false\", !getCollection().retainAll(elements));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection should change from retainAll empty\",\n+                getCollection().retainAll(Collections.EMPTY_SET));\n+        getConfirmed().retainAll(Collections.EMPTY_SET);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection changed from retainAll other\", getCollection().retainAll(other));\n+        getConfirmed().retainAll(other);\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        assertTrue(\"Collection shouldn't change from retainAll elements\",\n+                   !getCollection().retainAll(elements));\n+        verify();\n+        assertEquals(\"Collection size shouldn't change\", size, getCollection().size());\n+\n+        if (getFullElements().length > 1) {\n+            resetFull();\n+            size = getCollection().size();\n+            int min = (getFullElements().length < 2 ? 0 : 2);\n+            int max = (getFullElements().length <= 5 ? getFullElements().length - 1 : 5);\n+            assertTrue(\"Collection should changed by partial retainAll\",\n+                    getCollection().retainAll(elements.subList(min, max)));\n+            getConfirmed().retainAll(elements.subList(min, max));\n+            verify();\n+\n+            Iterator<E> iter = getCollection().iterator();\n+            while (iter.hasNext()) {\n+                assertTrue(\"Collection only contains retained element\",\n+                        elements.subList(min, max).contains(iter.next()));\n+            }\n+        }\n+\n+        resetFull();\n+        HashSet<E> set = new HashSet<E>(elements);\n+        size = getCollection().size();\n+        assertTrue(\"Collection shouldn't change from retainAll without \" +\n+                   \"duplicate elements\", !getCollection().retainAll(set));\n+        verify();\n+        assertEquals(\"Collection size didn't change from nonduplicate \" +\n+                     \"retainAll\", size, getCollection().size());\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#size()}.\n+     */\n+    public void testCollectionSize() {\n+        resetEmpty();\n+        assertEquals(\"Size of new Collection is 0.\", 0, getCollection().size());\n+\n+        resetFull();\n+        assertTrue(\"Size of full collection should be greater than zero\", getCollection().size() > 0);\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#toArray()}.\n+     */\n+    public void testCollectionToArray() {\n+        resetEmpty();\n+        assertEquals(\"Empty Collection should return empty array for toArray\",\n+                     0, getCollection().toArray().length);\n+\n+        resetFull();\n+        Object[] array = getCollection().toArray();\n+        assertEquals(\"Full collection toArray should be same size as collection\",\n+                array.length, getCollection().size());\n+        Object[] confirmedArray = getConfirmed().toArray();\n+        assertEquals(\"length of array from confirmed collection should \"\n+                + \"match the length of the collection's array\", confirmedArray.length, array.length);\n+        boolean[] matched = new boolean[array.length];\n+\n+        for (int i = 0; i < array.length; i++) {\n+            assertTrue(\"Collection should contain element in toArray\",\n+                    getCollection().contains(array[i]));\n+\n+            boolean match = false;\n+            // find a match in the confirmed array\n+            for (int j = 0; j < array.length; j++) {\n+                // skip already matched\n+                if (matched[j])\n+                    continue;\n+                if (array[i] == confirmedArray[j]\n+                        || (array[i] != null && array[i].equals(confirmedArray[j]))) {\n+                    matched[j] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            if (!match) {\n+                fail(\"element \" + i + \" in returned array should be found \"\n+                        + \"in the confirmed collection's array\");\n+            }\n+        }\n+        for (int i = 0; i < matched.length; i++) {\n+            assertEquals(\"Collection should return all its elements in \" + \"toArray\", true,\n+                    matched[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#toArray(Object[])}.\n+     */\n+    public void testCollectionToArray2() {\n+        resetEmpty();\n+        Object[] a = new Object[] { new Object(), null, null };\n+        Object[] array = getCollection().toArray(a);\n+        assertEquals(\"Given array shouldn't shrink\", array, a);\n+        assertNull(\"Last element should be set to null\", a[0]);\n+        verify();\n+\n+        resetFull();\n+        try {\n+            array = getCollection().toArray(new Void[0]);\n+            fail(\"toArray(new Void[0]) should raise ArrayStore\");\n+        } catch (ArrayStoreException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            array = getCollection().toArray(null);\n+            fail(\"toArray(null) should raise NPE\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        array = getCollection().toArray(new Object[0]);\n+        a = getCollection().toArray();\n+        assertEquals(\"toArrays should be equal\",\n+                     Arrays.asList(array), Arrays.asList(a));\n+\n+        // Figure out if they're all the same class\n+        // TODO: It'd be nicer to detect a common superclass\n+        HashSet<Class<?>> classes = new HashSet<Class<?>>();\n+        for (int i = 0; i < array.length; i++) {\n+            classes.add((array[i] == null) ? null : array[i].getClass());\n+        }\n+        if (classes.size() > 1) return;\n+\n+        Class<?> cl = classes.iterator().next();\n+        if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet\n+            cl = Map.Entry.class;\n+        }\n+        a = (Object[]) Array.newInstance(cl, 0);\n+        array = getCollection().toArray(a);\n+        assertEquals(\"toArray(Object[]) should return correct array type\",\n+                a.getClass(), array.getClass());\n+        assertEquals(\"type-specific toArrays should be equal\",\n+                Arrays.asList(array),\n+                Arrays.asList(getCollection().toArray()));\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests <code>toString</code> on a collection.\n+     */\n+    public void testCollectionToString() {\n+        resetEmpty();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+\n+        resetFull();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+    }\n+\n+    /**\n+     *  If isRemoveSupported() returns false, tests to see that remove\n+     *  operations raise an UnsupportedOperationException.\n+     */\n+    public void testUnsupportedRemove() {\n+        if (isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().clear();\n+            fail(\"clear should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().removeAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().retainAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iterator = getCollection().iterator();\n+            iterator.next();\n+            iterator.remove();\n+            fail(\"iterator.remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+    }\n+\n+    /**\n+     *  Tests that the collection's iterator is fail-fast.\n+     */\n+    public void testCollectionIteratorFailFast() {\n+        if (!isFailFastSupported()) return;\n+\n+        if (isAddSupported()) {\n+            resetFull();\n+            try {\n+                Iterator<E> iter = getCollection().iterator();\n+                E o = getOtherElements()[0];\n+                getCollection().add(o);\n+                getConfirmed().add(o);\n+                iter.next();\n+                fail(\"next after add should raise ConcurrentModification\");\n+            } catch (ConcurrentModificationException e) {\n+                // expected\n+            }\n+            verify();\n+\n+            resetFull();\n+            try {\n+                Iterator<E> iter = getCollection().iterator();\n+                getCollection().addAll(Arrays.asList(getOtherElements()));\n+                getConfirmed().addAll(Arrays.asList(getOtherElements()));\n+                iter.next();\n+                fail(\"next after addAll should raise ConcurrentModification\");\n+            } catch (ConcurrentModificationException e) {\n+                // expected\n+            }\n+            verify();\n+        }\n+\n+        if (!isRemoveSupported()) return;\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            getCollection().clear();\n+            iter.next();\n+            fail(\"next after clear should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        } catch (NoSuchElementException e) {\n+            // (also legal given spec)\n+        }\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            getCollection().remove(getFullElements()[0]);\n+            iter.next();\n+            fail(\"next after remove should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().removeAll(sublist);\n+            iter.next();\n+            fail(\"next after removeAll should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().retainAll(sublist);\n+            iter.next();\n+            fail(\"next after retainAll should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            Object dest = in.readObject();\n+            in.close();\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj)) - EMPTY Collection\", obj, dest);\n+            }\n+        }\n+        obj = makeFullCollection();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            Object dest = in.readObject();\n+            in.close();\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj)) - FULL Collection\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    public Collection<E> getCollection() {\n+        return collection;\n+    }\n+\n+    /**\n+     * Set the collection.\n+     * @param collection the Collection<E> to set\n+     */\n+    public void setCollection(Collection<E> collection) {\n+        this.collection = collection;\n+    }\n+\n+    public Collection<E> getConfirmed() {\n+        return confirmed;\n+    }\n+\n+    /**\n+     * Set the confirmed.\n+     * @param confirmed the Collection<E> to set\n+     */\n+    public void setConfirmed(Collection<E> confirmed) {\n+        this.confirmed = confirmed;\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#contains(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotCollectionContains(Collection<?> coll, Object element) {\n+        try {\n+            assertFalse(coll.contains(element));\n+        } catch (ClassCastException e) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotCollectionContainsAll(Collection<?> coll, Collection<?> sub) {\n+        try {\n+            assertFalse(coll.containsAll(sub));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#remove(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotRemoveFromCollection(Collection<?> coll, Object element) {\n+        try {\n+            assertFalse(coll.remove(element));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#removeAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotRemoveAllFromCollection(Collection<?> coll, Collection<?> sub) {\n+        try {\n+            assertFalse(coll.removeAll(sub));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/CompositeCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link CompositeCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Brian McCallister\n+ * @author Phil Steitz\n+ */\n+public class CompositeCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public CompositeCollectionTest(String name) {\n+        super(name);\n+    }\n+\n+ //-----------------------------------------------------------------------------\n+    /**\n+     * Run stock collection tests without Mutator, so turn off add, remove\n+     */\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Empty collection is empty composite\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CompositeCollection<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"2\", \"3\", \"4\" };\n+    }\n+\n+    /**\n+     * Full collection consists of 4 collections, each with one element\n+     */\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        CompositeCollection<E> compositeCollection = new CompositeCollection<E>();\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            Collection<E> summand = new HashSet<E>();\n+            summand.add(elements[i]);\n+            compositeCollection.addComposited(summand);\n+        }\n+        return compositeCollection;\n+    }\n+\n+    /**\n+     * Full collection should look like a collection with 4 elements\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> collection = new HashSet<E>();\n+        collection.addAll(Arrays.asList(getFullElements()));\n+        return collection;\n+    }\n+\n+    /**\n+     * Override testUnsupportedRemove, since the default impl expects removeAll,\n+     * retainAll and iterator().remove to throw\n+     */\n+    @Override\n+    public void testUnsupportedRemove() {\n+        resetFull();\n+        try {\n+            getCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected CompositeCollection<E> c;\n+    protected Collection<E> one;\n+    protected Collection<E> two;\n+\n+    protected void setUpTest() {\n+        c = new CompositeCollection<E>();\n+        one = new HashSet<E>();\n+        two = new HashSet<E>();\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    protected void setUpMutatorTest() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                for (Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.remove(obj);\n+                }\n+                return true;\n+            }\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        setUpTest();\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"a\");\n+        set.add((E) \"b\");\n+        c.addComposited(set);\n+        assertEquals(set.size(), c.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMultipleCollectionsSize() {\n+        setUpTest();\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"a\");\n+        set.add((E) \"b\");\n+        c.addComposited(set);\n+        HashSet<E> other = new HashSet<E>();\n+        other.add((E) \"c\");\n+        c.addComposited(other);\n+        assertEquals(set.size() + other.size(), c.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsEmpty() {\n+        setUpTest();\n+        assertTrue(c.isEmpty());\n+        HashSet<E> empty = new HashSet<E>();\n+        c.addComposited(empty);\n+        assertTrue(c.isEmpty());\n+        empty.add((E) \"a\");\n+        assertTrue(!c.isEmpty());\n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one);\n+        c.addComposited(two);\n+        Iterator<E> i = c.iterator();\n+        E next = i.next();\n+        assertTrue(c.contains(next));\n+        assertTrue(one.contains(next));\n+        next = i.next();\n+        i.remove();\n+        assertTrue(!c.contains(next));\n+        assertTrue(!two.contains(next));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClear() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        c.clear();\n+        assertTrue(one.isEmpty());\n+        assertTrue(two.isEmpty());\n+        assertTrue(c.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"1\");\n+        c.addComposited(one);\n+        assertTrue(c.containsAll(two));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        one.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one);\n+        c.retainAll(two);\n+        assertTrue(!c.contains(\"2\"));\n+        assertTrue(!one.contains(\"2\"));\n+        assertTrue(c.contains(\"1\"));\n+        assertTrue(one.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"serial\" })\n+    public void testAddAllMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                for (Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                return false;\n+            }\n+        });\n+\n+        c.addComposited(one);\n+        two.add((E) \"foo\");\n+        c.addAll(two);\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"serial\" })\n+    public void testAddMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                for (Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                return false;\n+            }\n+        });\n+\n+        c.addComposited(one);\n+        c.add((E) \"foo\");\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToCollection() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        Collection<E> foo = c.toCollection();\n+        assertTrue(foo.containsAll(c));\n+        assertEquals(c.size(), foo.size());\n+        one.add((E) \"3\");\n+        assertTrue(!foo.containsAll(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToCollection() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        Collection<E> toCollection = new HashSet<E>();\n+        toCollection.addAll(c);\n+        assertTrue(toCollection.containsAll(c));\n+        assertEquals(c.size(), toCollection.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one, two);\n+        c.remove(\"1\");\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        // need separate list to remove, as otherwise one clears itself\n+        Collection<E> removing = new ArrayList<E>(one);\n+        c.addComposited(one, two);\n+        c.removeAll(removing);\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one, two);\n+        c.removeComposited(one);\n+        assertTrue(c.contains(\"1\"));\n+        assertEquals(2, c.size());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"/tmp/CompositeCollection.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"/tmp/CompositeCollection.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/PredicatedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the \n+ * {@link PredicatedCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class PredicatedCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public PredicatedCollectionTest(String name) {\n+        super(name);\n+    }\n+\n+   //------------------------------------------------------------------------\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected Collection<E> decorateCollection(\n+                Collection<E> collection, Predicate<E> predicate) {\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeObject() {\n+        return decorateCollection(new ArrayList<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return decorateCollection(list, truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    public Collection<E> makeTestCollection() {\n+        return decorateCollection(new ArrayList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        Collection<E> c = makeTestCollection();\n+        Integer i = new Integer(3);\n+        try {\n+            c.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !c.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        Collection<E> c = makeTestCollection();\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            c.addAll(elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"one\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"two\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(new Integer(3)));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"four\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/SynchronizedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link SynchronizedCollection} implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public SynchronizedCollectionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return SynchronizedCollection.synchronizedCollection(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/TransformedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the {@link TransformedCollection}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedCollectionTest extends AbstractCollectionTest<Object> {\n+    \n+    private static class StringToInteger implements Transformer<Object, Object> {\n+        public Object transform(Object input) {\n+            return new Integer((String) input);\n+        }\n+    }\n+    \n+    public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n+    public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n+\n+    public TransformedCollectionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<Object> makeConfirmedCollection() {\n+        return new ArrayList<Object>();\n+    }\n+\n+    @Override\n+    public Collection<Object> makeConfirmedFullCollection() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+    \n+    @Override\n+    public Collection<Object> makeObject() {\n+        return TransformedCollection.transformingCollection(new ArrayList<Object>(), NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    public Collection<Object> makeFullCollection() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Object[] getFullElements() {\n+        return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+    }\n+\n+    @Override\n+    public Object[] getOtherElements() {\n+        return new Object[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTransformedCollection() {\n+        Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, coll.size());\n+        Object[] els = getFullElements();\n+        for (int i = 0; i < els.length; i++) {\n+            coll.add(els[i]);\n+            assertEquals(i + 1, coll.size());\n+            assertEquals(true, coll.contains(new Integer((String) els[i])));\n+            assertEquals(false, coll.contains(els[i]));\n+        }\n+        \n+        assertEquals(true, coll.remove(new Integer((String) els[0])));\n+    }\n+\n+    public void testTransformedCollection_decorateTransform() {\n+        Collection originalCollection = new ArrayList();\n+        Object[] els = getFullElements();\n+        for (int i = 0; i < els.length; i++) {\n+            originalCollection.add(els[i]);\n+        }\n+        Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, collection.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, collection.contains(new Integer((String) els[i])));\n+            assertEquals(false, collection.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, collection.remove(els[0]));\n+        assertEquals(true, collection.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUtils;\n+import org.apache.commons.collections.buffer.BoundedBuffer;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableBoundedCollection} implementation.\n+ */\n+public class UnmodifiableBoundedCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableBoundedCollectionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        BoundedBuffer<E> buffer = BoundedBuffer.<E>boundedBuffer(new ArrayStack<E>(), 10);\n+        return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(buffer);\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        E[] allElements = getFullElements();\n+        Buffer<E> buffer = BufferUtils.boundedBuffer(new ArrayStack<E>(), allElements.length);\n+        buffer.addAll(Arrays.asList(allElements));\n+        return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(buffer);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/UnmodifiableCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class UnmodifiableCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableCollectionTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableCollection.unmodifiableCollection(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableCollection.unmodifiableCollection(list);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections/list/AbstractTestList.java\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractTestList.java\n import java.util.NoSuchElementException;\n \n import org.apache.commons.collections.BulkTest;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n import org.apache.commons.collections.iterators.AbstractTestListIterator;\n \n /**\n  * @author Stephen Colebourne\n  * @author Neil O'Toole\n  */\n-public abstract class AbstractTestList<E> extends AbstractTestCollection<E> {\n+public abstract class AbstractTestList<E> extends AbstractCollectionTest<E> {\n \n     /**\n      * JUnit constructor.\n--- a/src/test/java/org/apache/commons/collections/list/TestTransformedList.java\n+++ b/src/test/java/org/apache/commons/collections/list/TestTransformedList.java\n import java.util.ListIterator;\n \n import org.apache.commons.collections.Transformer;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractTestList} for exercising the {@link TransformedList}\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public List<E> makeObject() {\n-        return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @Override\n     public List<E> makeFullCollection() {\n         List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return TransformedList.transformingList(list, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedList.transformingList(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedList() {\n-        List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, list.size());\n         E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalList.add(els[i]);\n         }\n-        List<?> list = TransformedList.transformedList(originalList, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, list.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, list.contains(new Integer((String) els[i])));\n--- a/src/test/java/org/apache/commons/collections/map/AbstractTestMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractTestMap.java\n import org.apache.commons.collections.AbstractTestObject;\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.CollectionUtils;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n import org.apache.commons.collections.set.AbstractTestSet;\n \n /**\n  * Abstract test class for {@link java.util.Map} methods and contracts.\n  * <p>\n- * The forces at work here are similar to those in {@link AbstractTestCollection}.\n+ * The forces at work here are similar to those in {@link AbstractCollectionTest}.\n  * If your class implements the full Map interface, including optional\n  * operations, simply extend this class, and implement the\n  * {@link #makeObject()} method.\n \n     /**\n      * Bulk test {@link Map#values()}.  This method runs through all of\n-     * the tests in {@link AbstractTestCollection}.\n+     * the tests in {@link AbstractCollectionTest}.\n      * After modification operations, {@link #verify()} is invoked to ensure\n      * that the map and the other collection views are still valid.\n      *\n-     * @return a {@link AbstractTestCollection} instance for testing the map's\n+     * @return a {@link AbstractCollectionTest} instance for testing the map's\n      *    values collection\n      */\n     public BulkTest bulkTestMapValues() {\n         return new TestMapValues();\n     }\n \n-    public class TestMapValues extends AbstractTestCollection<V> {\n+    public class TestMapValues extends AbstractCollectionTest<V> {\n         public TestMapValues() {\n             super(\"\");\n         }\n--- a/src/test/java/org/apache/commons/collections/map/TestTransformedMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/TestTransformedMap.java\n import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.TransformerUtils;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractTestMap} for exercising the {@link TransformedMap}\n         Map<K, V> map = TransformedMap\n                 .transformingMap(\n                         new HashMap<K, V>(),\n-                        (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n+                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n                         null);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n         assertEquals(null, map.remove(els[0]));\n         assertEquals(els[0], map.remove(new Integer((String) els[0])));\n \n-        map = TransformedMap.transformingMap(new HashMap(), null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        map = TransformedMap.transformingMap(new HashMap(), null, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n             map.put((K) els[i], (V) els[i]);\n                 .transformingMap(\n                         base,\n                         null,\n-                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n         assertEquals(\"1\", trans.get(\"A\"));\n         assertEquals(\"2\", trans.get(\"B\"));\n                 .transformedMap(\n                         base,\n                         null,\n-                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n         assertEquals(new Integer(1), trans.get(\"A\"));\n         assertEquals(new Integer(2), trans.get(\"B\"));\n--- a/src/test/java/org/apache/commons/collections/map/TestTransformedSortedMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/TestTransformedSortedMap.java\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.TransformerUtils;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractTestSortedMap} for exercising the {@link TransformedSortedMap}\n         SortedMap<K, V> map = TransformedSortedMap\n                 .transformingSortedMap(\n                         new TreeMap<K, V>(),\n-                        (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n+                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n                         null);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n                 .transformingSortedMap(\n                         new TreeMap<K, V>(),\n                         null,\n-                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n             map.put((K) els[i], (V) els[i]);\n                 .transformingSortedMap(\n                         base,\n                         null,\n-                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n         assertEquals(\"1\", trans.get(\"A\"));\n         assertEquals(\"2\", trans.get(\"B\"));\n                 .transformedSortedMap(\n                         base,\n                         null,\n-                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n         assertEquals(new Integer(1), trans.get(\"A\"));\n         assertEquals(new Integer(2), trans.get(\"B\"));\n--- a/src/test/java/org/apache/commons/collections/set/AbstractTestSet.java\n+++ b/src/test/java/org/apache/commons/collections/set/AbstractTestSet.java\n import java.util.Iterator;\n import java.util.Set;\n \n-import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n \n /**\n  * Abstract test class for {@link Set} methods and contracts.\n  * To use, subclass and override the {@link #makeObject()}\n  * method.  You may have to override other protected methods if your\n  * set is not modifiable, or if your set restricts what kinds of\n- * elements may be added; see {@link AbstractTestCollection} for more details.\n+ * elements may be added; see {@link AbstractCollectionTest} for more details.\n  *\n  * @since Commons Collections 3.0\n  * @version $Revision$\n  *\n  * @author Paul Jack\n  */\n-public abstract class AbstractTestSet<E> extends AbstractTestCollection<E> {\n+public abstract class AbstractTestSet<E> extends AbstractCollectionTest<E> {\n \n     /**\n      * JUnit constructor.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Return the {@link AbstractTestCollection#collection} fixture, but cast as a Set.  \n+     * Return the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.  \n      */\n     @Override\n     public Set<E> getCollection() {\n     }\n \n     /**\n-     * Return the {@link AbstractTestCollection#confirmed} fixture, but cast as a Set.\n+     * Return the {@link AbstractCollectionTest#confirmed} fixture, but cast as a Set.\n      */\n     @Override\n     public Set<E> getConfirmed() {\n--- a/src/test/java/org/apache/commons/collections/set/TestTransformedSet.java\n+++ b/src/test/java/org/apache/commons/collections/set/TestTransformedSet.java\n import java.util.Set;\n \n import org.apache.commons.collections.Transformer;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractTestSet} for exercising the {@link TransformedSet}\n     @SuppressWarnings(\"unchecked\")\n     public Set<E> makeObject() {\n         return TransformedSet.transformingSet(new HashSet<E>(),\n-                (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @Override\n         Set<E> list = new HashSet<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return TransformedSet.transformingSet(list,\n-                (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n         Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),\n-                (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n         E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalSet.add(els[i]);\n         }\n-        Set<?> set = TransformedSet.transformedSet(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, set.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, set.contains(new Integer((String) els[i])));\n--- a/src/test/java/org/apache/commons/collections/set/TestTransformedSortedSet.java\n+++ b/src/test/java/org/apache/commons/collections/set/TestTransformedSortedSet.java\n \n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.Transformer;\n-import org.apache.commons.collections.collection.TestTransformedCollection;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n \n /**\n  * Extension of {@link AbstractTestSortedSet} for exercising the {@link TransformedSortedSet}\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SortedSet<E> makeObject() {\n-        return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @Override\n     public SortedSet<E> makeFullCollection() {\n         SortedSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n         SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),\n-                (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n         E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalSet.add(els[i]);\n         }\n-        Set<?> set = TransformedSortedSet.transformedSet(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Set<?> set = TransformedSortedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, set.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, set.contains(new Integer((String) els[i])));", "timestamp": 1344285282, "metainfo": ""}