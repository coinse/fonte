{"sha": "715e28309f18027ace98eacd272f2de9909ec676", "log": "Added CompositeCollection and tests.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/decorators/CompositeCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/CompositeCollection.java,v 1.1 2003/11/07 02:10:13 psteitz Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+\n+\n+/**\n+ * A <code>Collection</code> implementation that decorates other collections\n+ * to provide a single unified view.\n+ * <p>\n+ * Changes made to this collection will actually be made on the decorated collection.\n+ * Add and remove operations require the use of a pluggable strategy. If no \n+ * strategy is provided then add and remove are unsupported.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/07 02:10:13 $\n+ *\n+ * @author Brian McCallister\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ */\n+public class CompositeCollection implements Collection {\n+    \n+    /** CollectionMutator to handle changes to the collection */\n+    protected CollectionMutator mutator;\n+    \n+    /** Collections in the composite */\n+    protected Collection[] all;\n+    \n+    /**\n+     * Create an empty CompositeCollection\n+     */\n+    public CompositeCollection() {\n+        this.all = new Collection[0];\n+    }\n+    \n+    /**\n+     * Create a Composite Collection with only c composited\n+     */\n+    public CompositeCollection(Collection c) {\n+        super();\n+        this.addComposited(c);\n+    }\n+    \n+    /**\n+     * Create a CompositeCollection with c as the initial list of\n+     * composited collections.\n+     */\n+    public CompositeCollection(Collection[] c) {\n+        this.addComposited(c);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of this composite collection.\n+     * <p>\n+     * This implementation calls <code>size()</code> on each collection.\n+     *\n+     * @return total number of elements in all contained containers\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (int i = this.all.length - 1; i >= 0; i--) {\n+            size += this.all[i].size();\n+        }\n+        return size;\n+    }\n+    \n+    /**\n+     * Checks whether this composite collection is empty.\n+     * <p>\n+     * This implementation calls <code>isEmpty()</code> on each collection.\n+     *\n+     * @return true if all of the contained collections are empty\n+     */\n+    public boolean isEmpty() {\n+        for (int i = this.all.length - 1; i >= 0; i--) {\n+            if (this.all[i].isEmpty() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Checks whether this composite collection contains the object.\n+     * <p>\n+     * This implementation calls <code>contains()</code> on each collection.\n+     *\n+     * @return true if obj is contained in any of the contained collections\n+     */\n+    public boolean contains(Object obj) {\n+        for (int i = this.all.length - 1; i >= 0; i--) {\n+            if (this.all[i].contains(obj)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Gets an iterator over all the collections in this composite.\n+     * <p>\n+     * This implementation uses an <code>IteratorChain</code>.\n+     *\n+     * @return an <code>IteratorChain</code> instance which supports\n+     *  <code>remove()</code>. Iteration occurs over contained collections in\n+     *  the order they were added, but this behavior should not be relied upon.\n+     * @see IteratorChain\n+     */\n+    public Iterator iterator() {\n+        if (this.all.length == 0) {\n+            return IteratorUtils.EMPTY_ITERATOR;\n+        }\n+        IteratorChain chain = new IteratorChain();\n+        for (int i = 0; i < this.all.length; ++i) {\n+            chain.addIterator(this.all[i].iterator());\n+        }\n+        return chain;\n+    }\n+    \n+    /**\n+     * Returns an array containing all of the elements in this composite.\n+     *\n+     * @return an object array of all the elements in the collection\n+     */\n+    public Object[] toArray() {\n+        final Object[] result = new Object[this.size()];\n+        int i = 0;\n+        for (Iterator it = this.iterator(); it.hasNext(); i++) {\n+            result[i] = it.next();\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns an object array, populating the supplied array if possible.\n+     * See <code>Collection</code> interface for full details.\n+     *\n+     * @return an array of all the elements in the collection\n+     */\n+    public Object[] toArray(Object array[]) {\n+        int size = this.size();\n+        Object[] result = null;\n+        if (array.length >= size) {\n+            result = array;\n+        }\n+        else {\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n+        }\n+        \n+        int offset = 0;\n+        for (int i = 0; i < this.all.length; ++i) {\n+            for (Iterator it = this.all[i].iterator(); it.hasNext();) {\n+                result[offset++] = it.next();\n+            }\n+        }\n+        if (result.length > size) {\n+            result[size] = null;\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Adds an object to the collection, throwing UnsupportedOperationException\n+     * unless a CollectionMutator strategy is specified.\n+     *\n+     * @param obj  the object to add\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n+     * @throws UnsupportedOperationException if add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean add(Object obj) {\n+        if (this.mutator == null) {\n+           throw new UnsupportedOperationException(\n+           \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return this.mutator.add(this, this.all, obj);\n+    }\n+    \n+    /**\n+     * Removes an object from the collection, throwing UnsupportedOperationException\n+     * unless a CollectionMutator strategy is specified.\n+     *\n+     * @param obj  the object being removed\n+     * @return true if the collection is changed\n+     * @throws UnsupportedOperationException if removed is unsupported\n+     * @throws ClassCastException if the object cannot be removed due to its type\n+     * @throws NullPointerException if the object cannot be removed because its null\n+     * @throws IllegalArgumentException if the object cannot be removed\n+     */\n+    public boolean remove(Object obj) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\n+            \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return this.mutator.remove(this, this.all, obj);\n+    }\n+    \n+    /**\n+     * Checks whether this composite contains all the elements in the specified collection.\n+     * <p>\n+     * This implementation calls <code>contains()</code> for each element in the\n+     * specified collection.\n+     *\n+     * @param coll  the collection to check for\n+     * @return true if all elements contained\n+     */\n+    public boolean containsAll(Collection coll) {\n+        for (Iterator it = coll.iterator(); it.hasNext();) {\n+            if (this.contains(it.next()) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Adds a collection of elements to this collection, throwing\n+     * UnsupportedOperationException unless a CollectionMutator strategy is specified.\n+     *\n+     * @param coll  the collection to add\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n+     * @throws UnsupportedOperationException if add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean addAll(Collection coll) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\n+            \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return this.mutator.addAll(this, this.all, coll);\n+    }\n+    \n+    /**\n+     * Removes the elements in the specified collection from this composite collection.\n+     * <p>\n+     * This implementation calls <code>removeAll</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if removeAll is unsupported\n+     */\n+    public boolean removeAll(Collection coll) {\n+        if (coll.size() == 0) {\n+            return false;\n+        }\n+        boolean changed = false;\n+        for (int i = this.all.length - 1; i >= 0; i--) {\n+            changed = (this.all[i].removeAll(coll) || changed);\n+        }\n+        return changed;\n+    }\n+    \n+    /**\n+     * Retains all the elements in the specified collection in this composite collection,\n+     * removing all others.\n+     * <p>\n+     * This implementation calls <code>retainAll()</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if retainAll is unsupported\n+     */\n+    public boolean retainAll(final Collection coll) {\n+        boolean changed = false;\n+        for (int i = this.all.length - 1; i >= 0; i--) {\n+            changed = (this.all[i].retainAll(coll) || changed);\n+        }\n+        return changed;\n+    }\n+    \n+    /**\n+     * Removes all of the elements from this collection .\n+     * <p>\n+     * This implementation calls <code>clear()</code> on each collection.\n+     *\n+     * @throws UnsupportedOperationException if clear is unsupported\n+     */\n+    public void clear() {\n+        for (int i = 0; i < this.all.length; ++i) {\n+            this.all[i].clear();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify a CollectionMutator strategy instance to handle changes.\n+     *\n+     * @param mutator  the mutator to use\n+     */\n+    public void setMutator(CollectionMutator mutator) {\n+        this.mutator = mutator;\n+    }\n+    \n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param comps Collections to be appended to the composite\n+     */\n+    public void addComposited(Collection[] comps) {\n+        ArrayList list = new ArrayList(Arrays.asList(this.all));\n+        list.addAll(Arrays.asList(comps));\n+        all = (Collection[]) list.toArray(new Collection[list.size()]);\n+    }\n+    \n+    /**\n+     * Add an additional collection to this composite.\n+     */\n+    public void addComposited(Collection c) {\n+        this.addComposited(new Collection[]{c});\n+    }\n+    \n+    /**\n+     * Add two additional collection to this composite.\n+     */\n+    public void addComposited(Collection c, Collection d) {\n+        this.addComposited(new Collection[]{c, d});\n+    }\n+    \n+    /**\n+     * Removes a collection from the those being decorated in this composite.\n+     *\n+     * @param coll  collection to be removed\n+     */\n+    public void removeComposited(Collection coll) {\n+        ArrayList list = new ArrayList(this.all.length);\n+        list.addAll(Arrays.asList(this.all));\n+        list.remove(coll);\n+        this.all = (Collection[]) list.toArray(new Collection[list.size()]);\n+    }\n+    \n+    /**\n+     * Returns a new collection containing all of the elements\n+     *\n+     * @return A new ArrayList containing all of the elements in this composite.\n+     *         The new collection is <i>not</i> backed by this composite.\n+     */\n+    public Collection toCollection() {\n+        return new ArrayList(this);\n+    }\n+    \n+    /**\n+     * Gets the collections being decorated.\n+     *\n+     * @return Unmodifiable collection of all collections in this composite.\n+     */\n+    public Collection getCollections() {\n+        return Collections.unmodifiableList(Arrays.asList(this.all));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Pluggable strategy to handle changes to the composite.\n+     */\n+    public interface CollectionMutator {\n+        \n+        /**\n+         * Called when an object is to be added to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param obj  the object being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean add(CompositeCollection composite, Collection[] collections, Object obj);\n+        \n+        /**\n+         * Called when a collection is to be added to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param coll  the collection being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean addAll(CompositeCollection composite, Collection[] collections, Collection coll);\n+        \n+        /**\n+         * Called when an object is to be removed to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param obj  the object being removed\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if removed is unsupported\n+         * @throws ClassCastException if the object cannot be removed due to its type\n+         * @throws NullPointerException if the object cannot be removed because its null\n+         * @throws IllegalArgumentException if the object cannot be removed\n+         */\n+        public boolean remove(CompositeCollection composite, Collection[] collections, Object obj);\n+        \n+    }\n+    \n+}\n+\n--- a/src/test/org/apache/commons/collections/decorators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.20 2003/10/13 02:48:16 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.21 2003/11/07 02:10:13 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for all collections decorators tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.20 $ $Date: 2003/10/13 02:48:16 $\n+ * @version $Revision: 1.21 $ $Date: 2003/11/07 02:10:13 $\n  * \n  * @author Stephen Colebourne\n  */\n         TestSuite suite = new TestSuite();\n         \n         suite.addTest(TestBlockingBuffer.suite());\n+        \n+        suite.addTest(TestCompositeCollection.suite());\n         \n         suite.addTest(TestFixedSizeList.suite());\n         suite.addTest(TestFixedSizeMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/TestCompositeCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestCompositeCollection.java,v 1.1 2003/11/07 02:10:13 psteitz Exp $\n+ * ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Turbine\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Turbine\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.AbstractTestCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the \n+ * {@link CompositeCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/07 02:10:13 $\n+ * \n+ * @author Brian McCallister\n+ * @author Phil Steitz\n+ */\n+public class TestCompositeCollection extends AbstractTestCollection {\n+    \n+    public TestCompositeCollection(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        return new TestSuite(TestCompositeCollection.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestCompositeCollection.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+ \n+ //-----------------------------------------------------------------------------\n+    /**\n+     * Run stock collection tests without Mutator, so turn off add, remove\n+     */\n+    protected boolean isAddSupported() {\n+        return false;\n+    }\n+    \n+    protected boolean isRemoveSupported() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Empty collection is empty composite\n+     */\n+    public Collection makeCollection() {\n+        return new CompositeCollection();\n+    }\n+    \n+    public Collection makeConfirmedCollection() {\n+        return new HashSet();\n+    }\n+    \n+    protected Object[] getFullElements() {\n+        return new Object[] {\"1\", \"2\", \"3\", \"4\"};\n+    }\n+    \n+    /**\n+     * Full collection consists of 5 collections, each with one element\n+     */\n+    protected Collection makeFullCollection() {\n+        CompositeCollection compositeCollection = new CompositeCollection();\n+        Object[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            Collection summand = new HashSet();\n+            summand.add(elements[i]);\n+            compositeCollection.addComposited(summand);\n+        }\n+        return compositeCollection;\n+    }\n+    \n+    /**\n+     * Full collection should look like a collection with 5 elements\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        Collection collection = new HashSet();\n+        collection.addAll(Arrays.asList(getFullElements()));\n+        return collection;\n+    }\n+    \n+    /**\n+     * Override testUnsupportedRemove, since the default impl expects removeAll,\n+     * retainAll and iterator().remove to throw\n+     */\n+    public void testUnsupportedRemove() {    \n+        resetFull();\n+        try {\n+            collection.remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    \n+    protected CompositeCollection c;\n+    protected Collection one;\n+    protected Collection two;\n+    \n+    protected void setUpTest() {\n+        c = new CompositeCollection();\n+        one = new HashSet();\n+        two = new HashSet();\n+    }\n+    \n+    protected void setUpMutatorTest() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator() {\n+            public boolean add(CompositeCollection composite, \n+            Collection[] collections, Object obj) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].add(obj);\n+                }\n+                return true;\n+            }\n+            \n+            public boolean addAll(CompositeCollection composite, \n+            Collection[] collections, Collection coll) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].addAll(coll);\n+                }\n+                return true;\n+            }\n+            \n+            public boolean remove(CompositeCollection composite, \n+            Collection[] collections, Object obj) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].remove(obj);\n+                }\n+                return true;\n+            }\n+        });\n+    }\n+            \n+    public void testSize() {\n+        setUpTest();\n+        HashSet set = new HashSet();\n+        set.add(\"a\");\n+        set.add(\"b\");\n+        c.addComposited(set);\n+        assertEquals(set.size(), c.size());\n+    }\n+    \n+    public void testMultipleCollectionsSize() {\n+        setUpTest();\n+        HashSet set = new HashSet();\n+        set.add(\"a\");\n+        set.add(\"b\");\n+        c.addComposited(set);\n+        HashSet other = new HashSet();\n+        other.add(\"c\");\n+        c.addComposited(other);\n+        assertEquals(set.size() + other.size(), c.size());\n+    }\n+    \n+    public void testIsEmpty() {\n+        setUpTest();\n+        assertTrue(c.isEmpty());\n+        HashSet empty = new HashSet();\n+        c.addComposited(empty);\n+        assertTrue(c.isEmpty());\n+        empty.add(\"a\");\n+        assertTrue(!c.isEmpty());\n+    }\n+    \n+    \n+    public void testIterator() {\n+        setUpTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        c.addComposited(one);\n+        c.addComposited(two);\n+        Iterator i = c.iterator();\n+        Object next = i.next();\n+        assertTrue(c.contains(next));\n+        assertTrue(one.contains(next));\n+        next = i.next();\n+        i.remove();\n+        assertTrue(!c.contains(next));\n+        assertTrue(!two.contains(next));\n+    }\n+    \n+    public void testClear() {\n+        setUpTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        c.addComposited(one, two);\n+        c.clear();\n+        assertTrue(one.isEmpty());\n+        assertTrue(two.isEmpty());\n+        assertTrue(c.isEmpty());\n+    }\n+    \n+    public void testContainsAll() {\n+        setUpTest();\n+        one.add(\"1\");\n+        two.add(\"1\");\n+        c.addComposited(one);\n+        assertTrue(c.containsAll(two));\n+    }\n+    \n+    public void testRetainAll() {\n+        setUpTest();\n+        one.add(\"1\");\n+        one.add(\"2\");\n+        two.add(\"1\");\n+        c.addComposited(one);\n+        c.retainAll(two);\n+        assertTrue(!c.contains(\"2\"));\n+        assertTrue(!one.contains(\"2\"));\n+        assertTrue(c.contains(\"1\"));\n+        assertTrue(one.contains(\"1\"));\n+    }\n+    \n+    public void testAddAllMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator() {\n+            public boolean add(CompositeCollection composite, \n+            Collection[] collections, Object obj) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].add(obj);\n+                }\n+                return true;\n+            }\n+            \n+            public boolean addAll(CompositeCollection composite, \n+            Collection[] collections, Collection coll) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].addAll(coll);\n+                }\n+                return true;\n+            }\n+            \n+            public boolean remove(CompositeCollection composite, \n+            Collection[] collections, Object obj) {\n+                return false;\n+            }\n+        });\n+        \n+        c.addComposited(one);\n+        two.add(\"foo\");\n+        c.addAll(two);\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+    \n+    public void testAddMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator() {\n+            public boolean add(CompositeCollection composite, \n+            Collection[] collections, Object obj) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].add(obj);\n+                }\n+                return true;\n+            }\n+            \n+            public boolean addAll(CompositeCollection composite, \n+            Collection[] collections, Collection coll) {\n+                for (int i = 0; i < collections.length; i++) {\n+                    collections[i].addAll(coll);\n+                }\n+                return true;\n+            }\n+            \n+            public boolean remove(CompositeCollection composite, \n+            Collection[] collections, Object obj) {\n+                return false;\n+            }\n+        });\n+        \n+        c.addComposited(one);\n+        c.add(\"foo\");\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+    \n+    public void testToCollection() {\n+        setUpTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        c.addComposited(one, two);\n+        Collection foo = c.toCollection();\n+        assertTrue(foo.containsAll(c));\n+        assertEquals(c.size(), foo.size());\n+        one.add(\"3\");\n+        assertTrue(!foo.containsAll(c));\n+    }\n+    \n+    public void testAddAllToCollection() {\n+        setUpTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        c.addComposited(one, two);\n+        Collection toCollection = new HashSet();\n+        toCollection.addAll(c);\n+        assertTrue(toCollection.containsAll(c));\n+        assertEquals(c.size(), toCollection.size());\n+    }   \n+    \n+    public void testRemove() {\n+        setUpMutatorTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        two.add(\"1\");\n+        c.addComposited(one, two);\n+        c.remove(\"1\");\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+    \n+    public void testRemoveAll() {\n+        setUpMutatorTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        two.add(\"1\");\n+        c.addComposited(one, two);\n+        c.removeAll(one);\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+    \n+    public void testRemoveComposited() {\n+        setUpMutatorTest();\n+        one.add(\"1\");\n+        two.add(\"2\");\n+        two.add(\"1\");\n+        c.addComposited(one, two);    \n+        c.removeComposited(one);\n+        assertTrue(c.contains(\"1\"));\n+        assertEquals(c.size(), 2);\n+    }\n+}", "timestamp": 1068171013, "metainfo": ""}