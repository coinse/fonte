{"sha": "40bdd8fe80d882b1b76c2d26d26bb69b032e86a3", "log": "Added Daniel Rall's SequencedHashMap patch and ported the JUnit test case over to use assertTrue() rather than assert().   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/SequencedHashMap.java\n+package org.apache.commons.collections;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Turbine\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Turbine\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>A {@link java.util.HashMap} whose keys are sequenced.  The\n+ * sequencing of the keys allow easy access to the values in the order\n+ * which they were added in.  This class is thread safe.</p>\n+ *\n+ * <p>Implementing the List interface is not possible due to a instance\n+ * method name clash between the Collection and the List interface:\n+ *\n+ * <table>\n+ * <tr><td>Collections</td><td>boolean remove(Object o)</td></tr>\n+ * <tr><td>Lists</td><td>Object remove(Object o)</td></tr>\n+ * </table>\n+ * </p>\n+ *\n+ * <p>So one cannot implement both interfaces at the same, which is\n+ * unfortunate because the List interface would be very nice in\n+ * conjuction with <a\n+ * href=\"http://jakarta.apache.org/velocity/\">Velocity</a>.</p>\n+ *\n+ * <p>A slightly more complex implementation and interface could involve\n+ * the use of a list of <code>Map.Entry</code> objects.</p>\n+ *\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ */\n+public class SequencedHashMap extends HashMap\n+{\n+    /**\n+     * The index of the eldest element in the collection.\n+     */\n+    protected static final int ELDEST_INDEX = 0;\n+\n+    /**\n+     * Indicator for an unknown index.\n+     */\n+    private static final int UNKNOWN_INDEX = -1;\n+\n+    /**\n+     * The sequence used to keep track of the hash keys.  Younger objects are\n+     * kept towards the end of the list.  Does not allow duplicates.\n+     */\n+    private LinkedList keySequence;\n+\n+    /**\n+     * Creates a new instance with default storage.\n+     */\n+    public SequencedHashMap ()\n+    {\n+        keySequence = new LinkedList();\n+    }\n+\n+    /**\n+     * Creates a new instance with the specified storage.\n+     *\n+     * @param size The storage to allocate up front.\n+     */\n+    public SequencedHashMap (int size)\n+    {\n+        super(size);\n+        keySequence = new LinkedList();\n+    }\n+\n+    /**\n+     * Clears all elements.\n+     */\n+    public void clear ()\n+    {\n+        super.clear();\n+        keySequence.clear();\n+    }\n+\n+    /**\n+     * Creates a shallow copy of this object, preserving the internal\n+     * structure by copying only references.  The keys, values, and\n+     * sequence are not <code>clone()</code>'d.\n+     *\n+     * @return A clone of this instance.\n+     */\n+    public Object clone ()\n+    {\n+        SequencedHashMap seqHash = (SequencedHashMap) super.clone();\n+        seqHash.keySequence = (LinkedList) keySequence.clone();\n+        return seqHash;\n+    }\n+\n+    /**\n+     * Returns the key at the specified index.\n+     */\n+    public Object get (int index)\n+    {\n+        return keySequence.get(index);\n+    }\n+\n+    /**\n+     * Returns the value at the specified index.\n+     */\n+    public Object getValue (int index)\n+    {\n+        return get(get(index));\n+    }\n+\n+    /**\n+     * Returns the index of the specified key.\n+     */\n+    public int indexOf (Object key)\n+    {\n+        return keySequence.indexOf(key);\n+    }\n+\n+    /**\n+     * Returns a key iterator.\n+     */\n+    public Iterator iterator ()\n+    {\n+        return keySequence.iterator();\n+    }\n+\n+    /**\n+     * Returns the last index of the specified key.\n+     */\n+    public int lastIndexOf (Object key)\n+    {\n+        return keySequence.lastIndexOf(key);\n+    }\n+\n+    /**\n+     * Returns the ordered sequence of keys.\n+     *\n+     * This method is meant to be used for retrieval of Key / Value pairs\n+     * in e.g. Velocity:\n+     * <PRE>\n+     * ## $table contains a sequenced hashtable\n+     * #foreach ($key in $table.sequence())\n+     * &lt;TR&gt;\n+     * &lt;TD&gt;Key: $key&lt;/TD&gt;\n+     * &lt;/TD&gt;Value: $table.get($key)&lt;/TD&gt;\n+     * &lt;/TR&gt;\n+     * #end\n+     * </PRE>\n+     *\n+     * @return The ordered list of keys.\n+     */\n+    public List sequence()\n+    {\n+        return keySequence;\n+    }\n+\n+    /**\n+     * Stores the provided key/value pair.  Freshens the sequence of existing\n+     * elements.\n+     *\n+     * @param key   The key to the provided value.\n+     * @param value The value to store.\n+     * @return      The previous value for the specified key, or\n+     *              <code>null</code> if none.\n+     */\n+    public Object put (Object key, Object value)\n+    {\n+        Object prevValue = super.put(key, value);\n+        freshenSequence(key, prevValue);\n+        return prevValue;\n+    }\n+\n+    /**\n+     * Freshens the sequence of the element <code>value</code> if\n+     * <code>value</code> is not <code>null</code>.\n+     *\n+     * @param key   The key whose sequence to freshen.\n+     * @param value The value whose existance to check before removing the old\n+     *              key sequence.\n+     */\n+    protected void freshenSequence(Object key, Object value)\n+    {\n+        if (value != null)\n+        {\n+            // Freshening existing element's sequence.\n+            keySequence.remove(key);\n+        }\n+        keySequence.add(key);\n+    }\n+\n+    /**\n+     * Stores the provided key/value pairs.\n+     *\n+     * @param t The key/value pairs to store.\n+     */\n+    public void putAll (Map t)\n+    {\n+        Set set = t.entrySet();\n+        for (Iterator iter = set.iterator(); iter.hasNext(); )\n+        {\n+            Map.Entry e = (Map.Entry)iter.next();\n+            put(e.getKey(), e.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index The index of the object to remove.\n+     * @return      The previous value coressponding the <code>key</code>, or\n+     *              <code>null</code> if none existed.\n+     */\n+    public Object remove (int index)\n+    {\n+        return remove(index, null);\n+    }\n+\n+    /**\n+     * Removes the element with the specified key.\n+     *\n+     * @param key   The <code>Map</code> key of the object to remove.\n+     * @return      The previous value coressponding the <code>key</code>, or\n+     *              <code>null</code> if none existed.\n+     */\n+    public Object remove (Object key)\n+    {\n+        return remove(UNKNOWN_INDEX, key);\n+    }\n+\n+    /**\n+     * Removes the element with the specified key or index.\n+     *\n+     * @param index The index of the object to remove, or\n+     *              <code>UNKNOWN_INDEX</code> if not known.\n+     * @param key   The <code>Map</code> key of the object to remove.\n+     * @return      The previous value coressponding the <code>key</code>, or\n+     *              <code>null</code> if none existed.\n+     */\n+    private final Object remove (int index, Object key)\n+    {\n+        if (index == UNKNOWN_INDEX)\n+        {\n+            index = indexOf(key);\n+        }\n+        if (key == null)\n+        {\n+            key = get(index);\n+        }\n+        if (index != UNKNOWN_INDEX)\n+        {\n+            keySequence.remove(index);\n+        }\n+        return super.remove(key);\n+    }\n+}\n+\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.11 2001/08/29 15:28:07 jstrachan Exp $\n- * $Revision: 1.11 $\n- * $Date: 2001/08/29 15:28:07 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.12 2001/09/17 16:43:49 jstrachan Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2001/09/17 16:43:49 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.11 2001/08/29 15:28:07 jstrachan Exp $\n+ * @version $Id: TestAll.java,v 1.12 2001/09/17 16:43:49 jstrachan Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestFastTreeMap1.suite());\n         suite.addTest(TestHashBag.suite());\n         suite.addTest(TestHashMap.suite());\n+        suite.addTest(TestSequencedHashMap.suite());\n         suite.addTest(TestSingletonIterator.suite());\n         suite.addTest(TestTreeBag.suite());\n         suite.addTest(TestTreeMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+package org.apache.commons.collections;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Turbine\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Turbine\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.util.Iterator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.collections.SequencedHashMap}.\n+ *\n+ * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ */\n+public class TestSequencedHashMap extends TestHashMap\n+{\n+    /**\n+     * The instance to experiment on.\n+     */\n+    protected SequencedHashMap labRat;\n+\n+    public TestSequencedHashMap(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestSequencedHashMap.class);\n+    }\n+\n+    public static void main(String[] args[]) {\n+        String[] testCaseName = { TestSequencedHashMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public void setUp() {\n+        super.setUp();\n+        labRat = new SequencedHashMap();\n+    }\n+\n+    public Map makeMap() {\n+        return new SequencedHashMap();\n+    }\n+\n+    protected Object[] getKeys() {\n+        return new Object[] { \"foo\", \"baz\", \"eek\" };\n+    }\n+\n+    protected Object[] getValues() {\n+        return new Object[] { \"bar\", \"frob\", new Object() };\n+    }\n+\n+    public void testSequenceMap() throws Throwable {\n+        Object[] keys = getKeys();\n+        int expectedSize = keys.length;\n+        Object[] values = getValues();\n+        for (int i = 0; i < expectedSize; i++) {\n+            labRat.put(keys[i], values[i]);\n+        }\n+\n+        // Test size().\n+        assertEquals(\"size() does not match expected size\",\n+                     expectedSize, labRat.size());\n+\n+        // Test clone(), iterator(), and get(Object).\n+        SequencedHashMap clone = (SequencedHashMap) labRat.clone();\n+        assertEquals(\"Size of clone does not match original\",\n+                     labRat.size(), clone.size());\n+        Iterator origKeys = labRat.keySet().iterator();\n+        Iterator copiedKeys = clone.keySet().iterator();\n+        while (origKeys.hasNext()) {\n+            Object origKey = origKeys.next();\n+            Object copiedKey = copiedKeys.next();\n+            assertEquals(\"Cloned key does not match orginal\",\n+                         origKey, copiedKey);\n+            assertEquals(\"Cloned value does not match original\",\n+                         labRat.get(origKey), clone.get(copiedKey));\n+        }\n+        assertTrue(\"iterator() returned different number of elements than keys()\",\n+               !copiedKeys.hasNext());\n+\n+        // Test sequence()\n+        List seq = labRat.sequence();\n+        assertEquals(\"sequence() returns more keys than in the Map\",\n+                     expectedSize, seq.size());\n+\n+        for (int i = 0; i < seq.size(); i++) {\n+            assertEquals(\"Key \" + i + \" is not the same as the key in the Map\",\n+                         keys[i], seq.get(i));\n+        }\n+    }\n+\n+    protected void tearDown() {\n+        labRat = null;\n+    }\n+}", "timestamp": 1000745029, "metainfo": ""}