{"sha": "e297d23839647ba6c236af5d694610a35b2e7b8f", "log": "29440: Generic MultiMap Implementation  ", "commit": "\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n import org.apache.commons.collections.map.TypedSortedMap;\n import org.apache.commons.collections.map.UnmodifiableMap;\n import org.apache.commons.collections.map.UnmodifiableSortedMap;\n+import org.apache.commons.collections.map.MultiValueMap;\n \n /** \n  * Provides utility methods and decorators for\n  *  <li>{@link #transformedSortedMap(SortedMap, Transformer, Transformer)}\n  *  <li>{@link #typedMap(Map, Class, Class)}\n  *  <li>{@link #typedSortedMap(SortedMap, Class, Class)}\n+ *  <li>{@link #multiValueMap( Map )}\n+ *  <li>{@link #multiValueMap( Map, Class )}\n+ *  <li>{@link #multiValueMap( Map, Factory )}\n  *  </ul>\n  *\n  * @since Commons Collections 1.0\n  * @author Janek Bogucki\n  * @author Max Rydahl Andersen\n  * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n  * @author Neil O'Toole\n  */\n public class MapUtils {\n         return LazySortedMap.decorate(map, transformerFactory);\n     }\n \n+    /**\n+     * Creates a mult-value map backed by the given map which returns ArrayLists.\n+     * @param map the map to decorate\n+     * @return a multi-value map backed by the given map which returns ArrayLists of values.\n+     * @see MultiValueMap\n+     * @since Commons Collections 3.2\n+     */\n+    public static Map multiValueMap( Map map ) {\n+        return MultiValueMap.decorate( map );\n+    }\n+\n+    /**\n+     * Creates a multi-value map backed by the given map which returns collections of\n+     * the specified type.\n+     * @param map the map to decorate\n+     * @param collectionClass the type of collections to return from the map (must contain public no-arg constructor\n+     * and extend Collection).\n+     * @return a multi-value map backed by the given map which returns collections of the specified type\n+     * @see MultiValueMap\n+     * @since Commons Collections 3.2\n+     */\n+    public static Map multiValueMap( Map map, Class collectionClass ) {\n+        return MultiValueMap.decorate( map, collectionClass );\n+    }\n+\n+    /**\n+     * Creates a multi-value map backed by the given map which returns collections\n+     * created by the specified collection factory.\n+     * @param map the map to decorate\n+     * @param collectionFactory a factor which creates collection objects\n+     * @return a multi-value map backed by the given map which returns collections\n+     * created by the specified collection factory\n+     * @see MultiValueMap\n+     * @since Commons Collections 3.2\n+     */\n+    public static Map multiValueMap( Map map, Factory collectionFactory ) {\n+        return MultiValueMap.decorate( map, collectionFactory );\n+    }\n+\n+\n+\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/MultiValueMap.java\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.MultiMap;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A MultiValueMap decorates another map, allowing it to have\n+ * more than one value for a key.  The values of the map will be\n+ * Collection objects.  The types of which can be specified using\n+ * either a Class object or a Factory which creates Collection\n+ * objects.\n+ *\n+ * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n+ * @since Commons Collections 3.2\n+ */\n+public class MultiValueMap extends AbstractMapDecorator implements MultiMap {\n+    private final Factory collectionFactory;\n+    private Collection values;\n+\n+    /**\n+     * Creates a map which wraps the given map and\n+     * maps keys to ArrayLists.\n+     *\n+     * @param map the map to wrap\n+     */\n+    public static Map decorate(Map map) {\n+        return new MultiValueMap(map);\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * maps keys to collections of type <code>collectionClass</code>.\n+     *\n+     * @param map             the map to wrap\n+     * @param collectionClass the type of the collection class\n+     */\n+    public static Map decorate(Map map, Class collectionClass) {\n+        return new MultiValueMap(map, collectionClass);\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param map               the map to decorate\n+     * @param collectionFactory the collection factory (must return a Collection object).\n+     */\n+    public static Map decorate(Map map, Factory collectionFactory) {\n+        return new MultiValueMap(map, collectionFactory);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap which wraps the given map and\n+     * maps keys to ArrayLists.\n+     *\n+     * @param map the map to wrap\n+     */\n+    protected MultiValueMap(Map map) {\n+        this(map, ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap which decorates the given <code>map</code> and\n+     * maps keys to collections of type <code>collectionClass</code>.\n+     *\n+     * @param map             the map to wrap\n+     * @param collectionClass the type of the collection class\n+     */\n+    protected MultiValueMap(Map map, Class collectionClass) {\n+        this(map, new ReflectionFactory(collectionClass));\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param map               the map to decorate\n+     * @param collectionFactory the collection factory (must return a Collection object).\n+     */\n+    protected MultiValueMap(Map map, Factory collectionFactory) {\n+        super(map);\n+        this.collectionFactory = collectionFactory;\n+    }\n+\n+    /**\n+     * Clear the map.\n+     * <p>\n+     * This clears each collection in the map, and so may be slow.\n+     */\n+    public void clear() {\n+        Set pairs = getMap().entrySet();\n+        Iterator pairsIterator = pairs.iterator();\n+        while(pairsIterator.hasNext()) {\n+            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+            Collection coll = (Collection) keyValuePair.getValue();\n+            coll.clear();\n+        }\n+        getMap().clear();\n+    }\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, <code>null</code> will be returned\n+     * from a subsequant <code>get(key)</code>.\n+     *\n+     * @param key  the key to remove from\n+     * @param value the value to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     */\n+    public Object remove(Object key, Object value) {\n+        Collection valuesForKey = getCollection(key);\n+        if(valuesForKey == null) {\n+            return null;\n+        }\n+        boolean removed = valuesForKey.remove(value);\n+        if(removed == false) {\n+            return null;\n+        }\n+        if(valuesForKey.isEmpty()) {\n+            remove(key);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the value specified.\n+     * <p>\n+     * This checks all collections against all keys for the value, and thus could be slow.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        Set pairs = getMap().entrySet();\n+        if(pairs == null) {\n+            return false;\n+        }\n+        Iterator pairsIterator = pairs.iterator();\n+        while(pairsIterator.hasNext()) {\n+            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+            Collection coll = (Collection) keyValuePair.getValue();\n+            if(coll.contains(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, <code>null</code> will be returned\n+     * from a subsequant <code>get(key)</code>.\n+     *\n+     * @param key  the key to remove from\n+     * @param value  the value to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     */\n+    public Object put(Object key, Object value) {\n+        Collection c = getCollection(key);\n+        if(c == null) {\n+            c = (Collection) collectionFactory.create();\n+            getMap().put(key, c);\n+        }\n+        boolean results = c.add(value);\n+        return (results ? value : null);\n+    }\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * This returns a collection containing the combination of values from all keys.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    public Collection values() {\n+        Collection vs = values;\n+        return (vs != null ? vs : (values = new Values()));\n+    }\n+\n+    /**\n+     * Checks whether the collection at the specified key contains the value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object key, Object value) {\n+        Collection coll = getCollection(key);\n+        if(coll == null) {\n+            return false;\n+        }\n+        return coll.contains(value);\n+    }\n+\n+    /**\n+     * Gets the collection mapped to the specified key.\n+     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the collection mapped to the key, null if no mapping\n+     */\n+    public Collection getCollection(Object key) {\n+        return (Collection) getMap().get(key);\n+    }\n+\n+    /**\n+     * Gets the size of the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get size for\n+     * @return the size of the collection at the key, zero if key not in map\n+     */\n+    public int size(Object key) {\n+        Collection coll = getCollection(key);\n+        if(coll == null) {\n+            return 0;\n+        }\n+        return coll.size();\n+    }\n+\n+    /**\n+     * Adds a collection of values to the collection associated with the specified key.\n+     *\n+     * @param key  the key to store against\n+     * @param values  the values to add to the collection at the key, null ignored\n+     * @return true if this map changed\n+     */\n+    public boolean putAll(Object key, Collection values) {\n+        if(values == null || values.size() == 0) {\n+            return false;\n+        }\n+        Collection coll = getCollection(key);\n+        if(coll == null) {\n+            coll = (Collection) collectionFactory.create();\n+            getMap().put(key, coll);\n+        }\n+        return coll.addAll(values);\n+    }\n+\n+    /**\n+     * Gets an iterator for the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get an iterator for\n+     * @return the iterator of the collection at the key, empty iterator if key not in map\n+     */\n+    public Iterator iterator(Object key) {\n+        if(!containsKey(key)) {\n+            return EmptyIterator.INSTANCE;\n+        }\n+        else {\n+            return new ValuesIterator(key);\n+        }\n+    }\n+\n+    /**\n+     * Gets the total size of the map by counting all the values.\n+     *\n+     * @return the total size of the map counting all values\n+     */\n+    public int totalSize() {\n+        int total = 0;\n+        Collection values = getMap().values();\n+        for(Iterator it = values.iterator(); it.hasNext();) {\n+            Collection coll = (Collection) it.next();\n+            total += coll.size();\n+        }\n+        return total;\n+    }\n+\n+    private class Values extends AbstractCollection {\n+        public Iterator iterator() {\n+            final IteratorChain chain = new IteratorChain();\n+            for(Iterator i = keySet().iterator(); i.hasNext();) {\n+                chain.addIterator(new ValuesIterator(i.next()));\n+            }\n+            return chain;\n+        }\n+\n+        public int size() {\n+            return totalSize();\n+        }\n+\n+        public void clear() {\n+            MultiValueMap.this.clear();\n+        }\n+    }\n+\n+    private class ValuesIterator implements Iterator {\n+        private final Object key;\n+        private final Collection values;\n+        private final Iterator iterator;\n+\n+        public ValuesIterator(Object key) {\n+            this.key = key;\n+            this.values = getCollection(key);\n+            this.iterator = values.iterator();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            if(values.isEmpty()) {\n+                MultiValueMap.this.remove(key);\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public Object next() {\n+            return iterator.next();\n+        }\n+    }\n+\n+    private static class ReflectionFactory implements Factory {\n+        private final Class clazz;\n+\n+        public ReflectionFactory(Class clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        public Object create() {\n+            try {\n+                return clazz.newInstance();\n+            }\n+            catch(Exception e) {\n+                throw new RuntimeException(\"Cannot instantiate class \" + clazz + \".\", e);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestMultiValueMap.java\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.HashSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+\n+/**\n+ * TestMultiValueMap\n+ *\n+ * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n+ * @since Commons Collections 3.2\n+ */\n+public class TestMultiValueMap extends TestCase {\n+    public void testNoMappingReturnsNull() {\n+        final MultiValueMap map = createTestMap();\n+        assertNull(map.get(\"whatever\"));\n+    }\n+\n+    public void testValueCollectionType() {\n+        final MultiValueMap map = createTestMap(LinkedList.class);\n+        assertTrue(map.get(\"one\") instanceof LinkedList);\n+    }\n+\n+    public void testMultipleValues() {\n+        final MultiValueMap map = createTestMap(HashSet.class);\n+        final HashSet expected = new HashSet();\n+        expected.add(\"uno\");\n+        expected.add(\"un\");\n+        assertEquals(expected, map.get(\"one\"));\n+    }\n+\n+    public void testContainsValue() {\n+        final MultiValueMap map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue(\"uno\"));\n+        assertTrue(map.containsValue(\"un\"));\n+        assertTrue(map.containsValue(\"dos\"));\n+        assertTrue(map.containsValue(\"deux\"));\n+        assertTrue(map.containsValue(\"tres\"));\n+        assertTrue(map.containsValue(\"trois\"));\n+        assertFalse(map.containsValue(\"quatro\"));\n+    }\n+\n+    public void testKeyContainsValue() {\n+        final MultiValueMap map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue(\"one\", \"uno\"));\n+        assertTrue(map.containsValue(\"one\", \"un\"));\n+        assertTrue(map.containsValue(\"two\", \"dos\"));\n+        assertTrue(map.containsValue(\"two\", \"deux\"));\n+        assertTrue(map.containsValue(\"three\", \"tres\"));\n+        assertTrue(map.containsValue(\"three\", \"trois\"));\n+        assertFalse(map.containsValue(\"four\", \"quatro\"));\n+    }\n+\n+    public void testValues() {\n+        final MultiValueMap map = createTestMap(HashSet.class);\n+        final HashSet expected = new HashSet();\n+        expected.add(\"uno\");\n+        expected.add(\"dos\");\n+        expected.add(\"tres\");\n+        expected.add(\"un\");\n+        expected.add(\"deux\");\n+        expected.add(\"trois\");\n+        final Collection c = map.values();\n+        assertEquals(6, c.size());\n+        assertEquals(expected, new HashSet(c));\n+    }\n+\n+    private MultiValueMap createTestMap() {\n+        return createTestMap(ArrayList.class);\n+    }\n+\n+    private MultiValueMap createTestMap(Class collectionClass) {\n+        final MultiValueMap map = new MultiValueMap(new HashMap(), collectionClass);\n+        map.put(\"one\", \"uno\");\n+        map.put(\"one\", \"un\");\n+        map.put(\"two\", \"dos\");\n+        map.put(\"two\", \"deux\");\n+        map.put(\"three\", \"tres\");\n+        map.put(\"three\", \"trois\");\n+        return map;\n+    }\n+\n+    public void testKeyedIterator() {\n+        final MultiValueMap map = createTestMap();\n+        final ArrayList actual = new ArrayList(IteratorUtils.toList(map.iterator(\"one\")));\n+        final ArrayList expected = new ArrayList(Arrays.asList(new String[]{\"uno\", \"un\"}));\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testRemoveAllViaIterator() {\n+        final MultiValueMap map = createTestMap();\n+        for(Iterator i = map.values().iterator(); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    public void testRemoveAllViaKeyedIterator() {\n+        final MultiValueMap map = createTestMap();\n+        for(Iterator i = map.iterator(\"one\"); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertEquals(4, map.totalSize());\n+    }\n+\n+    public void testTotalSize() {\n+        assertEquals(6, createTestMap().totalSize());\n+    }\n+}", "timestamp": 1116428437, "metainfo": ""}