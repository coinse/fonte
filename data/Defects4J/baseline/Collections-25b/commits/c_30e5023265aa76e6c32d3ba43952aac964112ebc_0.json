{"sha": "30e5023265aa76e6c32d3ba43952aac964112ebc", "log": "[COLLECTIONS-543] AbstractCollectionDecorator does not forward equals and hashCode anymore to the backing collection.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n         return (Bag<E>) super.decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public int getCount(final Object object) {\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n         return (Bag<E>) super.decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public boolean add(final E object, final int count) {\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n         return (Bag<E>) decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        synchronized (lock) {\n+            return getBag().equals(object);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        synchronized (lock) {\n+            return getBag().hashCode();\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public boolean add(final E object, final int count) {\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n \n import java.util.Set;\n \n-import org.apache.commons.collections4.set.TransformedSet;\n import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.Transformer;\n import org.apache.commons.collections4.collection.TransformedCollection;\n+import org.apache.commons.collections4.set.TransformedSet;\n \n /**\n  * Decorates another {@link Bag} to transform objects that are added.\n         return (Bag<E>) decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public int getCount(final Object object) {\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n         }\n \n         @Override\n+        public boolean equals(final Object object) {\n+            return object == this || decorated().equals(object);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return decorated().hashCode();\n+        }\n+\n+        @Override\n         public boolean removeAll(final Collection<?> coll) {\n             if (parent.isEmpty() || coll.isEmpty()) {\n                 return false;\n--- a/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n  * {@link #iterator()}. Instead it simply returns the value from the\n  * wrapped collection. This may be undesirable, for example if you are trying\n  * to write an unmodifiable implementation it might provide a loophole.\n+ * <p>\n+ * This implementation does not forward the hashCode and equals methods through\n+ * to the backing object, but relies on Object's implementation. This is necessary\n+ * to preserve the symmetry of equals. Custom definitions of equality are usually\n+ * based on an interface, such as Set or List, so that the implementation of equals\n+ * can cast the object being tested for equality to the custom interface.\n+ * AbstractCollectionDecorator does not implement such custom interfaces directly;\n+ * they are implemented only in subclasses. Therefore, forwarding equals would break\n+ * symmetry, as the forwarding object might consider itself equal to the object being\n+ * tested, but the reverse could not be true. This behavior is consistent with the\n+ * JDK's collection wrappers, such as {@link java.util.Collections#unmodifiableCollection(Collection)}.\n+ * Use an interface-specific subclass of AbstractCollectionDecorator, such as\n+ * AbstractListDecorator, to preserve equality behavior, or override equals directly.\n  *\n  * @param <E> the type of the elements in the collection\n  * @since 3.0\n     }\n \n     @Override\n-    public boolean equals(final Object object) {\n-        return object == this || decorated().equals(object);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return decorated().hashCode();\n-    }\n-\n-    @Override\n     public String toString() {\n         return decorated().toString();\n     }\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n         return (List<E>) super.decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public void add(final int index, final E object) {\n--- a/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n         return (List<E>) super.decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public E get(final int index) {\n--- a/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n         return (List<E>) decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n     //-----------------------------------------------------------------------\n \n     public E get(final int index) {\n--- a/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java\n  * Decorates another {@link Queue} to provide additional behaviour.\n  * <p>\n  * Methods are forwarded directly to the decorated queue.\n+ * <p>\n+ * This implementation does not forward the hashCode and equals methods through\n+ * to the backing object, but relies on Object's implementation. This is\n+ * necessary as some Queue implementations, e.g. LinkedList, have custom a\n+ * equals implementation for which symmetry can not be preserved.\n+ * See class javadoc of AbstractCollectionDecorator for more information.\n  *\n  * @param <E> the type of the elements in the queue\n  * @since 4.0\n--- a/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java\n         return (Set<E>) super.decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java\n         return (Set<E>) super.decorated();\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/collections4/set/TransformedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSet.java\n         super(set, transformer);\n     }\n \n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n import org.apache.commons.collections4.AbstractObjectTest;\n import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.bag.AbstractBagTest;\n                 (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n         assertEquals(\"Map is the right size\", map.size(), map2.size());\n         for (final Object key : map.keySet()) {\n-            assertEquals(\"Map had inequal elements\", map.get(key), map2.get(key));\n+            assertTrue(\"Map had inequal elements\", CollectionUtils.isEqualCollection(map.get(key), map2.get(key)));\n             if (isRemoveSupported()) {\n                 map2.remove(key);\n             }\n             return AbstractMultiValuedMapTest.this.makeObject().asMap();\n         }\n \n+        @Override\n         public Map<K, Collection<V>> makeFullMap() {\n             return AbstractMultiValuedMapTest.this.makeFullMap().asMap();\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public K[] getSampleKeys() {\n             K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();\n             return (K[]) finalKeys;\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public Collection<V>[] getSampleValues() {\n             V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();\n             return colArr;\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public Collection<V>[] getNewSampleValues() {\n             Object[] sampleValues = { \"ein\", \"ek\", \"zwei\", \"duey\", \"drei\", \"teen\" };", "timestamp": 1421076078, "metainfo": ""}