{"sha": "68ca4c2cb8edb1083bede992848977f90b636100", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r813951 | mbenson | 2009-09-11 10:48:55 -0700 (Fri, 11 Sep 2009) | 1 line          [COLLECTIONS-286] CollectionsUtils.extractSingleton     ------------------------------------------------------------------------     r813925 | mbenson | 2009-09-11 10:05:31 -0700 (Fri, 11 Sep 2009) | 1 line          [COLLECTIONS-182] return Closure from CollectionUtils.forAllDo     ------------------------------------------------------------------------     r648113 | skestle | 2008-04-14 21:32:39 -0700 (Mon, 14 Apr 2008) | 1 line          Updated CollectionUtils to return the same type of Collection that is passed into select(), reject() and collect()     ------------------------------------------------------------------------     r644140 | skestle | 2008-04-02 19:42:30 -0700 (Wed, 02 Apr 2008) | 1 line          Fixed javac complier generic issues     ------------------------------------------------------------------------     r644138 | skestle | 2008-04-02 19:34:09 -0700 (Wed, 02 Apr 2008) | 1 line          Fixed javac complier generic issues     ------------------------------------------------------------------------     r643795 | skestle | 2008-04-02 01:49:57 -0700 (Wed, 02 Apr 2008) | 5 lines          Generified EqualPredicate and created individual test class moved from TestPredicateUtils          Added assertFalse() and assertTrue to BasicPredicateTestBase with (Predicate, Object) parameters          Issues: COLLECTIONS-243, COLLECTIONS-253, COLLECTIONS-293     ------------------------------------------------------------------------     r593964 | skestle | 2007-11-11 13:44:41 -0800 (Sun, 11 Nov 2007) | 2 lines          Applied (most of) Brian Egge's clean up patch of previous commit for COLLECTIONS-245 - thanks! (And we're at 100%)          ------------------------------------------------------------------------     r593381 | skestle | 2007-11-08 17:35:22 -0800 (Thu, 08 Nov 2007) | 1 line          Fixed ambiguous method call error due to auto-boxing.  (Seems to be introduced in jdk 1.5.0_07 on Windows)     ------------------------------------------------------------------------     r593144 | skestle | 2007-11-08 04:21:55 -0800 (Thu, 08 Nov 2007) | 3 lines          Updated CollectionUtils and test.  Probably 80-90% complete for generics.  Very open to review / patches.          Jira: COLLECTIONS-245     ------------------------------------------------------------------------     r471166 | scolebourne | 2006-11-04 03:33:22 -0800 (Sat, 04 Nov 2006) | 1 line          Removed Typed* containers such as TypedList and TypedMap as generics now provides type safety     ------------------------------------------------------------------------     r468690 | scolebourne | 2006-10-28 06:03:11 -0700 (Sat, 28 Oct 2006) | 1 line          COLLECTIONS-229 - Remove deprecated classes and code     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestCollectionUtils.java\n+++ b/src/test/org/apache/commons/collections/TestCollectionUtils.java\n  */\n package org.apache.commons.collections;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n-import java.util.Vector;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n+import static junit.framework.Assert.assertFalse;\n+import static org.apache.commons.collections.functors.EqualPredicate.equalPredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import java.util.*;\n \n import org.apache.commons.collections.bag.HashBag;\n import org.apache.commons.collections.buffer.BoundedFifoBuffer;\n-import org.apache.commons.collections.collection.AbstractTestCollection;\n import org.apache.commons.collections.collection.PredicatedCollection;\n import org.apache.commons.collections.collection.SynchronizedCollection;\n import org.apache.commons.collections.collection.TransformedCollection;\n import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.junit.Before;\n+import org.junit.Test;\n \n /**\n  * Tests for CollectionUtils.\n  * @author Steven Melzer\n  * @author Neil O'Toole\n  * @author Stephen Smith\n+ * @author Stephen Kestle\n  *\n  * @version $Revision$ $Date$\n  */\n-public class TestCollectionUtils extends TestCase {\n-    \n-    public TestCollectionUtils(String testName) {\n-        super(testName);\n-    }\n-\n-    public static Test suite() {\n-        return new TestSuite(TestCollectionUtils.class);\n-    }\n-\n+public class TestCollectionUtils extends MockTestCase {\n     public static void main(String args[]) {\n         String[] testCaseName = { TestCollectionUtils.class.getName() };\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    private Collection collectionA = null;\n-    private Collection collectionB = null;\n-\n+    /**\n+     * Collection of {@link Integer}s\n+     */\n+    private List<Integer> collectionA = null;\n+\n+    /**\n+     * Collection of {@link Long}s\n+     */\n+    private List<Long> collectionB = null;\n+\n+    /**\n+     * Collection of {@link Integer}s that are equivalent to the Longs in\n+     * collectionB.\n+     */\n+    private Collection<Integer> collectionC = null;\n+\n+    /**\n+     * Collection of {@link Integer}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionA2 = null;\n+\n+    /**\n+     * Collection of {@link Long}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionB2 = null;\n+\n+    /**\n+     * Collection of {@link Integer}s (cast as {@link Number}s) that are\n+     * equivalent to the Longs in collectionB.\n+     */\n+    private Collection<Number> collectionC2 = null;\n+\n+    private Iterable<Integer> iterableA = null;\n+\n+    private Iterable<Long> iterableB = null;\n+\n+    private Iterable<Integer> iterableC = null;\n+\n+    private Iterable<Number> iterableA2 = null;\n+\n+    private Iterable<Number> iterableB2 = null;\n+\n+    @Before\n     public void setUp() {\n-        collectionA = new ArrayList();\n-        collectionA.add(\"a\");\n-        collectionA.add(\"b\");\n-        collectionA.add(\"b\");\n-        collectionA.add(\"c\");\n-        collectionA.add(\"c\");\n-        collectionA.add(\"c\");\n-        collectionA.add(\"d\");\n-        collectionA.add(\"d\");\n-        collectionA.add(\"d\");\n-        collectionA.add(\"d\");\n-        collectionB = new LinkedList();\n-        collectionB.add(\"e\");\n-        collectionB.add(\"d\");\n-        collectionB.add(\"d\");\n-        collectionB.add(\"c\");\n-        collectionB.add(\"c\");\n-        collectionB.add(\"c\");\n-        collectionB.add(\"b\");\n-        collectionB.add(\"b\");\n-        collectionB.add(\"b\");\n-        collectionB.add(\"b\");\n-\n-    }\n-\n-    public void testGetCardinalityMap() {\n-        Map freq = CollectionUtils.getCardinalityMap(collectionA);\n-        assertEquals(new Integer(1),freq.get(\"a\"));\n-        assertEquals(new Integer(2),freq.get(\"b\"));\n-        assertEquals(new Integer(3),freq.get(\"c\"));\n-        assertEquals(new Integer(4),freq.get(\"d\"));\n-        assertNull(freq.get(\"e\"));\n-\n-        freq = CollectionUtils.getCardinalityMap(collectionB);\n-        assertNull(freq.get(\"a\"));\n-        assertEquals(new Integer(4),freq.get(\"b\"));\n-        assertEquals(new Integer(3),freq.get(\"c\"));\n-        assertEquals(new Integer(2),freq.get(\"d\"));\n-        assertEquals(new Integer(1),freq.get(\"e\"));\n-    }\n-\n-    public void testCardinality() {\n-        assertEquals(1, CollectionUtils.cardinality(\"a\", collectionA));\n-        assertEquals(2, CollectionUtils.cardinality(\"b\", collectionA));\n-        assertEquals(3, CollectionUtils.cardinality(\"c\", collectionA));\n-        assertEquals(4, CollectionUtils.cardinality(\"d\", collectionA));\n-        assertEquals(0, CollectionUtils.cardinality(\"e\", collectionA));\n-\n-        assertEquals(0, CollectionUtils.cardinality(\"a\", collectionB));\n-        assertEquals(4, CollectionUtils.cardinality(\"b\", collectionB));\n-        assertEquals(3, CollectionUtils.cardinality(\"c\", collectionB));\n-        assertEquals(2, CollectionUtils.cardinality(\"d\", collectionB));\n-        assertEquals(1, CollectionUtils.cardinality(\"e\", collectionB));\n-\n-        Set set = new HashSet();\n+        collectionA = new ArrayList<Integer>();\n+        collectionA.add(1);\n+        collectionA.add(2);\n+        collectionA.add(2);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionB = new LinkedList<Long>();\n+        collectionB.add(5L);\n+        collectionB.add(4L);\n+        collectionB.add(4L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+\n+        collectionC = new ArrayList<Integer>();\n+        for (Long l : collectionB) {\n+            collectionC.add(l.intValue());\n+        }\n+\n+        iterableA = collectionA;\n+        iterableB = collectionB;\n+        iterableC = collectionC;\n+        collectionA2 = new ArrayList<Number>(collectionA);\n+        collectionB2 = new LinkedList<Number>(collectionB);\n+        collectionC2 = new LinkedList<Number>(collectionC);\n+        iterableA2 = collectionA2;\n+        iterableB2 = collectionB2;\n+    }\n+\n+    @Test\n+    public void getCardinalityMap() {\n+        Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n+        assertEquals(1, (int) freqA.get(1));\n+        assertEquals(2, (int) freqA.get(2));\n+        assertEquals(3, (int) freqA.get(3));\n+        assertEquals(4, (int) freqA.get(4));\n+        assertNull(freqA.get(5));\n+\n+        Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n+        assertNull(freqB.get(1L));\n+        assertEquals(4, (int) freqB.get(2L));\n+        assertEquals(3, (int) freqB.get(3L));\n+        assertEquals(2, (int) freqB.get(4L));\n+        assertEquals(1, (int) freqB.get(5L));\n+    }\n+\n+    @Test\n+    public void cardinality() {\n+        assertEquals(1, CollectionUtils.cardinality(1, iterableA));\n+        assertEquals(2, CollectionUtils.cardinality(2, iterableA));\n+        assertEquals(3, CollectionUtils.cardinality(3, iterableA));\n+        assertEquals(4, CollectionUtils.cardinality(4, iterableA));\n+        assertEquals(0, CollectionUtils.cardinality(5, iterableA));\n+\n+        assertEquals(0, CollectionUtils.cardinality(1L, iterableB));\n+        assertEquals(4, CollectionUtils.cardinality(2L, iterableB));\n+        assertEquals(3, CollectionUtils.cardinality(3L, iterableB));\n+        assertEquals(2, CollectionUtils.cardinality(4L, iterableB));\n+        assertEquals(1, CollectionUtils.cardinality(5L, iterableB));\n+\n+        // Ensure that generic bounds accept valid parameters, but return\n+        // expected results\n+        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n+        assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));\n+        assertEquals(0, CollectionUtils.cardinality(2, iterableB2));\n+\n+        Set<String> set = new HashSet<String>();\n         set.add(\"A\");\n         set.add(\"C\");\n         set.add(\"E\");\n         assertEquals(0, CollectionUtils.cardinality(\"D\", set));\n         assertEquals(1, CollectionUtils.cardinality(\"E\", set));\n \n-        Bag bag = new HashBag();\n+        Bag<String> bag = new HashBag<String>();\n         bag.add(\"A\", 3);\n         bag.add(\"C\");\n         bag.add(\"E\");\n         assertEquals(0, CollectionUtils.cardinality(\"D\", bag));\n         assertEquals(2, CollectionUtils.cardinality(\"E\", bag));\n     }\n-    \n-    public void testCardinalityOfNull() {\n-        List list = new ArrayList();\n-        assertEquals(0,CollectionUtils.cardinality(null,list));\n+\n+    @Test\n+    public void cardinalityOfNull() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertNull(freq.get(null));\n         }\n         list.add(\"A\");\n-        assertEquals(0,CollectionUtils.cardinality(null,list));\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertNull(freq.get(null));\n         }\n         list.add(null);\n-        assertEquals(1,CollectionUtils.cardinality(null,list));\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n-            assertEquals(new Integer(1),freq.get(null));\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(1, freq.get(null));\n         }\n         list.add(\"B\");\n-        assertEquals(1,CollectionUtils.cardinality(null,list));\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n-            assertEquals(new Integer(1),freq.get(null));\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(1, freq.get(null));\n         }\n         list.add(null);\n-        assertEquals(2,CollectionUtils.cardinality(null,list));\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n-            assertEquals(new Integer(2),freq.get(null));\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(2, freq.get(null));\n         }\n         list.add(\"B\");\n-        assertEquals(2,CollectionUtils.cardinality(null,list));\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n-            assertEquals(new Integer(2),freq.get(null));\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(2, freq.get(null));\n         }\n         list.add(null);\n-        assertEquals(3,CollectionUtils.cardinality(null,list));\n+        assertEquals(3, CollectionUtils.cardinality(null, list));\n         {\n-            Map freq = CollectionUtils.getCardinalityMap(list);\n-            assertEquals(new Integer(3),freq.get(null));\n-        }\n-    }\n-\n-    public void testContainsAny() {\n-        Collection empty = new ArrayList(0);\n-        Collection one = new ArrayList(1);\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(3, freq.get(null));\n+        }\n+    }\n+\n+    @Test\n+    public void containsAny() {\n+        Collection<String> empty = new ArrayList<String>(0);\n+        Collection<String> one = new ArrayList<String>(1);\n         one.add(\"1\");\n-        Collection two = new ArrayList(1);\n+        Collection<String> two = new ArrayList<String>(1);\n         two.add(\"2\");\n-        Collection three = new ArrayList(1);\n+        Collection<String> three = new ArrayList<String>(1);\n         three.add(\"3\");\n-        Collection odds = new ArrayList(2);\n+        Collection<String> odds = new ArrayList<String>(2);\n         odds.add(\"1\");\n         odds.add(\"3\");\n-        \n-        assertTrue(\"containsAny({1},{1,3}) should return true.\",\n-            CollectionUtils.containsAny(one,odds));\n-        assertTrue(\"containsAny({1,3},{1}) should return true.\",\n-            CollectionUtils.containsAny(odds,one));\n-        assertTrue(\"containsAny({3},{1,3}) should return true.\",\n-            CollectionUtils.containsAny(three,odds));\n-        assertTrue(\"containsAny({1,3},{3}) should return true.\",\n-            CollectionUtils.containsAny(odds,three));\n-        assertTrue(\"containsAny({2},{2}) should return true.\",\n-            CollectionUtils.containsAny(two,two));\n-        assertTrue(\"containsAny({1,3},{1,3}) should return true.\",\n-            CollectionUtils.containsAny(odds,odds));\n-        \n-        assertTrue(\"containsAny({2},{1,3}) should return false.\",\n-            !CollectionUtils.containsAny(two,odds));\n-        assertTrue(\"containsAny({1,3},{2}) should return false.\",\n-            !CollectionUtils.containsAny(odds,two));\n-        assertTrue(\"containsAny({1},{3}) should return false.\",\n-            !CollectionUtils.containsAny(one,three));\n-        assertTrue(\"containsAny({3},{1}) should return false.\",\n-            !CollectionUtils.containsAny(three,one));\n-        assertTrue(\"containsAny({1,3},{}) should return false.\",\n-            !CollectionUtils.containsAny(odds,empty));\n-        assertTrue(\"containsAny({},{1,3}) should return false.\",\n-            !CollectionUtils.containsAny(empty,odds));\n-        assertTrue(\"containsAny({},{}) should return false.\",\n-            !CollectionUtils.containsAny(empty,empty));\n-    }\n-\n-    public void testUnion() {\n-        Collection col = CollectionUtils.union(collectionA,collectionB);\n-        Map freq = CollectionUtils.getCardinalityMap(col);\n-        assertEquals(new Integer(1),freq.get(\"a\"));\n-        assertEquals(new Integer(4),freq.get(\"b\"));\n-        assertEquals(new Integer(3),freq.get(\"c\"));\n-        assertEquals(new Integer(4),freq.get(\"d\"));\n-        assertEquals(new Integer(1),freq.get(\"e\"));\n-\n-        Collection col2 = CollectionUtils.union(collectionB,collectionA);\n-        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n-        assertEquals(new Integer(1),freq2.get(\"a\"));\n-        assertEquals(new Integer(4),freq2.get(\"b\"));\n-        assertEquals(new Integer(3),freq2.get(\"c\"));\n-        assertEquals(new Integer(4),freq2.get(\"d\"));\n-        assertEquals(new Integer(1),freq2.get(\"e\"));        \n-    }\n-\n-    public void testIntersection() {\n-        Collection col = CollectionUtils.intersection(collectionA,collectionB);\n-        Map freq = CollectionUtils.getCardinalityMap(col);\n-        assertNull(freq.get(\"a\"));\n-        assertEquals(new Integer(2),freq.get(\"b\"));\n-        assertEquals(new Integer(3),freq.get(\"c\"));\n-        assertEquals(new Integer(2),freq.get(\"d\"));\n-        assertNull(freq.get(\"e\"));\n-\n-        Collection col2 = CollectionUtils.intersection(collectionB,collectionA);\n-        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n-        assertNull(freq2.get(\"a\"));\n-        assertEquals(new Integer(2),freq2.get(\"b\"));\n-        assertEquals(new Integer(3),freq2.get(\"c\"));\n-        assertEquals(new Integer(2),freq2.get(\"d\"));\n-        assertNull(freq2.get(\"e\"));      \n-    }\n-\n-    public void testDisjunction() {\n-        Collection col = CollectionUtils.disjunction(collectionA,collectionB);\n-        Map freq = CollectionUtils.getCardinalityMap(col);\n-        assertEquals(new Integer(1),freq.get(\"a\"));\n-        assertEquals(new Integer(2),freq.get(\"b\"));\n-        assertNull(freq.get(\"c\"));\n-        assertEquals(new Integer(2),freq.get(\"d\"));\n-        assertEquals(new Integer(1),freq.get(\"e\"));\n-\n-        Collection col2 = CollectionUtils.disjunction(collectionB,collectionA);\n-        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n-        assertEquals(new Integer(1),freq2.get(\"a\"));\n-        assertEquals(new Integer(2),freq2.get(\"b\"));\n-        assertNull(freq2.get(\"c\"));\n-        assertEquals(new Integer(2),freq2.get(\"d\"));\n-        assertEquals(new Integer(1),freq2.get(\"e\"));\n-    }\n-\n+\n+        assertTrue(\"containsAny({1},{1,3}) should return true.\", CollectionUtils.containsAny(one, odds));\n+        assertTrue(\"containsAny({1,3},{1}) should return true.\", CollectionUtils.containsAny(odds, one));\n+        assertTrue(\"containsAny({3},{1,3}) should return true.\", CollectionUtils.containsAny(three, odds));\n+        assertTrue(\"containsAny({1,3},{3}) should return true.\", CollectionUtils.containsAny(odds, three));\n+        assertTrue(\"containsAny({2},{2}) should return true.\", CollectionUtils.containsAny(two, two));\n+        assertTrue(\"containsAny({1,3},{1,3}) should return true.\", CollectionUtils.containsAny(odds, odds));\n+\n+        assertTrue(\"containsAny({2},{1,3}) should return false.\", !CollectionUtils.containsAny(two, odds));\n+        assertTrue(\"containsAny({1,3},{2}) should return false.\", !CollectionUtils.containsAny(odds, two));\n+        assertTrue(\"containsAny({1},{3}) should return false.\", !CollectionUtils.containsAny(one, three));\n+        assertTrue(\"containsAny({3},{1}) should return false.\", !CollectionUtils.containsAny(three, one));\n+        assertTrue(\"containsAny({1,3},{}) should return false.\", !CollectionUtils.containsAny(odds, empty));\n+        assertTrue(\"containsAny({},{1,3}) should return false.\", !CollectionUtils.containsAny(empty, odds));\n+        assertTrue(\"containsAny({},{}) should return false.\", !CollectionUtils.containsAny(empty, empty));\n+    }\n+\n+    @Test\n+    public void union() {\n+        Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(1, freq.get(1));\n+        assertEquals(4, freq.get(2));\n+        assertEquals(3, freq.get(3));\n+        assertEquals(4, freq.get(4));\n+        assertEquals(1, freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(1, freq2.get(1));\n+        assertEquals(4, freq2.get(2));\n+        assertEquals(3, freq2.get(3));\n+        assertEquals(4, freq2.get(4));\n+        assertEquals(1, freq2.get(5));\n+    }\n+\n+    @Test\n+    public void intersection() {\n+        Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertNull(freq.get(1));\n+        assertEquals(2, freq.get(2));\n+        assertEquals(3, freq.get(3));\n+        assertEquals(2, freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertNull(freq2.get(1));\n+        assertEquals(2, freq2.get(2));\n+        assertEquals(3, freq2.get(3));\n+        assertEquals(2, freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void disjunction() {\n+        Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(1, freq.get(1));\n+        assertEquals(2, freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(2, freq.get(4));\n+        assertEquals(1, freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(1, freq2.get(1));\n+        assertEquals(2, freq2.get(2));\n+        assertNull(freq2.get(3));\n+        assertEquals(2, freq2.get(4));\n+        assertEquals(1, freq2.get(5));\n+    }\n+\n+    @Test\n     public void testDisjunctionAsUnionMinusIntersection() {\n-        Collection dis = CollectionUtils.disjunction(collectionA,collectionB);\n-        Collection un = CollectionUtils.union(collectionA,collectionB);\n-        Collection inter = CollectionUtils.intersection(collectionA,collectionB);\n-        assertTrue(CollectionUtils.isEqualCollection(dis,CollectionUtils.subtract(un,inter)));\n-    }\n-\n+        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n+        Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));\n+    }\n+\n+    @Test\n     public void testDisjunctionAsSymmetricDifference() {\n-        Collection dis = CollectionUtils.disjunction(collectionA,collectionB);\n-        Collection amb = CollectionUtils.subtract(collectionA,collectionB);\n-        Collection bma = CollectionUtils.subtract(collectionB,collectionA);\n-        assertTrue(CollectionUtils.isEqualCollection(dis,CollectionUtils.union(amb,bma)));\n-    }\n-\n+        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n+        Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));\n+    }\n+\n+    @Test\n     public void testSubtract() {\n-        Collection col = CollectionUtils.subtract(collectionA,collectionB);\n-        Map freq = CollectionUtils.getCardinalityMap(col);\n-        assertEquals(new Integer(1),freq.get(\"a\"));\n-        assertNull(freq.get(\"b\"));\n-        assertNull(freq.get(\"c\"));\n-        assertEquals(new Integer(2),freq.get(\"d\"));\n-        assertNull(freq.get(\"e\"));\n-\n-        Collection col2 = CollectionUtils.subtract(collectionB,collectionA);\n-        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n-        assertEquals(new Integer(1),freq2.get(\"e\"));\n-        assertNull(freq2.get(\"d\"));\n-        assertNull(freq2.get(\"c\"));\n-        assertEquals(new Integer(2),freq2.get(\"b\"));\n-        assertNull(freq2.get(\"a\"));\n-    }\n-\n+        Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(1, freq.get(1));\n+        assertNull(freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(2, freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(1, freq2.get(5));\n+        assertNull(freq2.get(4));\n+        assertNull(freq2.get(3));\n+        assertEquals(2, freq2.get(2));\n+        assertNull(freq2.get(1));\n+    }\n+\n+    @Test\n     public void testIsSubCollectionOfSelf() {\n-        assertTrue(CollectionUtils.isSubCollection(collectionA,collectionA));\n-        assertTrue(CollectionUtils.isSubCollection(collectionB,collectionB));\n-    }\n-\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n     public void testIsSubCollection() {\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,collectionB));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionB,collectionA));\n-    }\n-\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n     public void testIsSubCollection2() {\n-        Collection c = new ArrayList();\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"a\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"b\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"b\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"c\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"c\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"c\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"d\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"d\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"d\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(!CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"d\");\n-        assertTrue(CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(CollectionUtils.isSubCollection(collectionA,c));\n-        c.add(\"e\");\n-        assertTrue(!CollectionUtils.isSubCollection(c,collectionA));\n-        assertTrue(CollectionUtils.isSubCollection(collectionA,c));\n-    }\n-\n+        Collection<Integer> c = new ArrayList<Integer>();\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(1);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(5);\n+        assertTrue(!CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+    }\n+\n+    @Test\n     public void testIsEqualCollectionToSelf() {\n-        assertTrue(CollectionUtils.isEqualCollection(collectionA,collectionA));\n-        assertTrue(CollectionUtils.isEqualCollection(collectionB,collectionB));\n-    }\n-\n+        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n     public void testIsEqualCollection() {\n-        assertTrue(!CollectionUtils.isEqualCollection(collectionA,collectionB));\n-        assertTrue(!CollectionUtils.isEqualCollection(collectionB,collectionA));\n-    }\n-\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionReturnsFalse() {\n+        List<Integer> b = new ArrayList<Integer>(collectionA);\n+        // remove an extra '2', and add a 5.  This will increase the size of the cardinality\n+        b.remove(1);\n+        b.add(5);\n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, b));\n+        assertFalse(CollectionUtils.isEqualCollection(b, collectionA));\n+    }\n+\n+    @Test\n     public void testIsEqualCollection2() {\n-        Collection a = new ArrayList();\n-        Collection b = new ArrayList();\n-        assertTrue(CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(CollectionUtils.isEqualCollection(b,a));\n+        Collection<String> a = new ArrayList<String>();\n+        Collection<String> b = new ArrayList<String>();\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n         a.add(\"1\");\n-        assertTrue(!CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(!CollectionUtils.isEqualCollection(b,a));\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n         b.add(\"1\");\n-        assertTrue(CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(CollectionUtils.isEqualCollection(b,a));\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n         a.add(\"2\");\n-        assertTrue(!CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(!CollectionUtils.isEqualCollection(b,a));\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n         b.add(\"2\");\n-        assertTrue(CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(CollectionUtils.isEqualCollection(b,a));\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n         a.add(\"1\");\n-        assertTrue(!CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(!CollectionUtils.isEqualCollection(b,a));\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n         b.add(\"1\");\n-        assertTrue(CollectionUtils.isEqualCollection(a,b));\n-        assertTrue(CollectionUtils.isEqualCollection(b,a));\n-    }\n-    \n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+    }\n+\n+    @Test\n     public void testIsProperSubCollection() {\n-        Collection a = new ArrayList();\n-        Collection b = new ArrayList();\n-        assertTrue(!CollectionUtils.isProperSubCollection(a,b));\n+        Collection<String> a = new ArrayList<String>();\n+        Collection<String> b = new ArrayList<String>();\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n         b.add(\"1\");\n-        assertTrue(CollectionUtils.isProperSubCollection(a,b));\n-        assertTrue(!CollectionUtils.isProperSubCollection(b,a));\n-        assertTrue(!CollectionUtils.isProperSubCollection(b,b));\n-        assertTrue(!CollectionUtils.isProperSubCollection(a,a));\n+        assertTrue(CollectionUtils.isProperSubCollection(a, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, a));\n         a.add(\"1\");\n         a.add(\"2\");\n         b.add(\"2\");\n-        assertTrue(!CollectionUtils.isProperSubCollection(b,a));\n-        assertTrue(!CollectionUtils.isProperSubCollection(a,b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n         a.add(\"1\");\n-        assertTrue(CollectionUtils.isProperSubCollection(b,a));\n-        assertTrue(CollectionUtils.isProperSubCollection(\n-            CollectionUtils.intersection(collectionA, collectionB), collectionA));\n-        assertTrue(CollectionUtils.isProperSubCollection(\n-            CollectionUtils.subtract(a, b), a));\n-        assertTrue(!CollectionUtils.isProperSubCollection(\n-            a, CollectionUtils.subtract(a, b)));\n-    }\n-    \n-    public void testFind() {\n-        Predicate testPredicate = PredicateUtils.equalPredicate(\"d\");\n-        Object test = CollectionUtils.find(collectionA, testPredicate);\n-        assertTrue(test.equals(\"d\"));\n-        testPredicate = PredicateUtils.equalPredicate(\"de\");\n+        assertTrue(CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));\n+    }\n+\n+    @Test\n+    public void find() {\n+        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n+        Integer test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test.equals(4));\n+        testPredicate = equalPredicate((Number) 45);\n         test = CollectionUtils.find(collectionA, testPredicate);\n         assertTrue(test == null);\n         assertNull(CollectionUtils.find(null,testPredicate));\n         assertNull(CollectionUtils.find(collectionA, null));\n     }\n-    \n-    public void testForAllDo() {\n-        Closure testClosure = ClosureUtils.invokerClosure(\"clear\");\n-        Collection col = new ArrayList();\n+\n+    @Test\n+    public void forAllDo() {\n+        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n         col.add(collectionA);\n         col.add(collectionB);\n-        CollectionUtils.forAllDo(col, testClosure);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n+        assertSame(testClosure, resultClosure);\n         assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n-        CollectionUtils.forAllDo(col, null);\n+        resultClosure = CollectionUtils.forAllDo(col, null);\n+        assertNull(resultClosure);\n         assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n-        CollectionUtils.forAllDo(null, testClosure);\n+        resultClosure = CollectionUtils.forAllDo(null, testClosure);\n         col.add(null);\n         // null should be OK\n         CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @Test(expected = FunctorException.class)\n+    public void forAllDoFailure() {\n+        Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<String> col = new ArrayList<String>();\n         col.add(\"x\");\n-        // This will lead to FunctorException\n-        try {\n-            CollectionUtils.forAllDo(col, testClosure);\n-            fail(\"Expecting FunctorException\");\n-        } catch (FunctorException ex) {\n-            // expected from invoker -- method not found\n-        }\n-    }\n-\n-    public void testIndex() {     \n-        // normal map behavior when index is an Integer and a key\n-        Map map = new HashMap();\n-        map.put(new Integer(0), \"zero\");\n-        map.put(new Integer(-1), \"minusOne\");\n-        Object test = CollectionUtils.index(map, 0);\n-        assertTrue(test.equals(\"zero\"));\n-        test = CollectionUtils.index(map, new Integer(-1));\n-        assertTrue(test.equals(\"minusOne\"));\n-        \n-        // map, non-integer key that does not exist -- map returned\n-        test = CollectionUtils.index(map, \"missing\");\n-        assertTrue(test.equals(map));\n-        \n-        // map, integer not a key, valid index -- \"some\" element of keyset returned\n-        test = CollectionUtils.index(map, new Integer(1));   \n-        assertTrue(map.keySet().contains(test)); \n-        \n-        // map, integer not a key, not valid index -- \"dead\" keyset iterator returned\n-        test = CollectionUtils.index(map, new Integer(4));         \n-        assertTrue((test instanceof Iterator) && !((Iterator) test).hasNext());  \n-\n-        // sorted map, integer not a key, valid index -- ith key returned\n-        SortedMap map2 = new TreeMap();\n-        map2.put(new Integer(23), \"u\");\n-        map2.put(new Integer(21), \"x\");\n-        map2.put(new Integer(17), \"v\");\n-        map2.put(new Integer(42), \"w\");\n-        Integer val = (Integer) CollectionUtils.index(map2, 0);\n-        assertTrue(val.intValue() == 17);\n-        val = (Integer) CollectionUtils.index(map2, 1);\n-        assertTrue(val.intValue() == 21);\n-        val = (Integer) CollectionUtils.index(map2, 2);\n-        assertTrue(val.intValue() == 23);\n-        val = (Integer) CollectionUtils.index(map2, 3);\n-        assertTrue(val.intValue() == 42);   \n-                \n-        // list, entry exists\n-        List list = new ArrayList();\n-        list.add(\"zero\");\n-        list.add(\"one\");\n-        test = CollectionUtils.index(list, 0);\n-        assertTrue(test.equals(\"zero\"));\n-        test = CollectionUtils.index(list, 1);\n-        assertTrue(test.equals(\"one\"));\n-        \n-        // list, non-existent entry -- IndexOutOfBoundsException\n-        try {\n-            test = CollectionUtils.index(list, 2);\n-            fail(\"Expecting IndexOutOfBoundsException\");\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @Test\n+    public void getFromMap() {\n+        // Unordered map, entries exist\n+        Map<String, String> expected = new HashMap<String, String>();\n+        expected.put(\"zeroKey\", \"zero\");\n+        expected.put(\"oneKey\", \"one\");\n+\n+        Map<String, String> found = new HashMap<String, String>();\n+        Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n+        found.put(entry.getKey(), entry.getValue());\n+        entry = CollectionUtils.get(expected, 1);\n+        found.put(entry.getKey(), entry.getValue());\n+        assertEquals(expected, found);\n+\n+        // Map index out of range\n+        try {\n+            CollectionUtils.get(expected, 2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n         } catch (IndexOutOfBoundsException e) {\n             // expected\n         }\n-        \n-        // iterator, entry exists\n-        Iterator iterator = list.iterator();\n-        test = CollectionUtils.index(iterator,0);\n-        assertTrue(test.equals(\"zero\"));\n-        iterator = list.iterator();\n-        test = CollectionUtils.index(iterator,1);\n-        assertTrue(test.equals(\"one\"));\n-        \n-        // iterator, non-existent entry -- \"dead\" iterator returned\n-        test = CollectionUtils.index(iterator,3);\n-        assertTrue(test.equals(iterator) && !iterator.hasNext());\n-        \n+        try {\n+            CollectionUtils.get(expected, -2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        // Sorted map, entries exist, should respect order\n+        SortedMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"zeroKey\", \"zero\");\n+        map.put(\"oneKey\", \"one\");\n+        Map.Entry<String, String> test = CollectionUtils.get(map, 1);\n+        assertEquals(\"zeroKey\", test.getKey());\n+        assertEquals(\"zero\", test.getValue());\n+        test = CollectionUtils.get(map, 0);\n+        assertEquals(\"oneKey\", test.getKey());\n+        assertEquals(\"one\", test.getValue());\n+    }\n+\n+    /**\n+     * Tests that {@link List}s are handled correctly - e.g. using\n+     * {@link List#get(int)}.\n+     */\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getFromList() throws Exception {\n+        // List, entry exists\n+        List<String> list = createMock(List.class);\n+        expect(list.get(0)).andReturn(\"zero\");\n+        expect(list.get(1)).andReturn(\"one\");\n+        replay();\n+        String string = CollectionUtils.get(list, 0);\n+        assertEquals(\"zero\", string);\n+        assertEquals(\"one\", CollectionUtils.get(list, 1));\n+        // list, non-existent entry -- IndexOutOfBoundsException\n+        CollectionUtils.get(new ArrayList<Object>(), 2);\n+    }\n+\n+    @Test\n+    public void getFromIterator() throws Exception {\n+        // Iterator, entry exists\n+        Iterator<Integer> iterator = iterableA.iterator();\n+        assertEquals(1, (int) CollectionUtils.get(iterator, 0));\n+        iterator = iterableA.iterator();\n+        assertEquals(2, (int) CollectionUtils.get(iterator, 1));\n+\n+        // Iterator, non-existent entry\n+        try {\n+            CollectionUtils.get(iterator, 10);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    @Test\n+    public void getFromEnumeration() throws Exception {\n         // Enumeration, entry exists\n-        Vector vector = new Vector(list);\n-        Enumeration en = vector.elements();\n-        test = CollectionUtils.index(en,0);\n-        assertTrue(test.equals(\"zero\"));\n+        Vector<String> vector = new Vector<String>();\n+        vector.addElement(\"zero\");\n+        vector.addElement(\"one\");\n+        Enumeration<String> en = vector.elements();\n+        assertEquals(\"zero\", CollectionUtils.get(en, 0));\n         en = vector.elements();\n-        test = CollectionUtils.index(en,1);\n-        assertTrue(test.equals(\"one\"));\n-        \n-        // Enumeration, non-existent entry -- \"dead\" enumerator returned\n-        test = CollectionUtils.index(en,3);\n-        assertTrue(test.equals(en) && !en.hasMoreElements());\n-        \n+        assertEquals(\"one\", CollectionUtils.get(en, 1));\n+\n+        // Enumerator, non-existent entry\n+        try {\n+            CollectionUtils.get(en, 3);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!en.hasMoreElements());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromIterable() throws Exception {\n         // Collection, entry exists\n-        Bag bag = new HashBag();\n+        Bag<String> bag = new HashBag<String>();\n         bag.add(\"element\", 1);\n-        test = CollectionUtils.index(bag, 0);\n-        assertTrue(test.equals(\"element\"));\n-        \n-        // Collection, non-existent entry -- \"dead\" iterator returned\n-        test = CollectionUtils.index(bag, 2);\n-        assertTrue((test instanceof Iterator) && !((Iterator) test).hasNext()); \n-        \n+        assertEquals(\"element\", CollectionUtils.get(bag, 0));\n+\n+        // Collection, non-existent entry\n+        CollectionUtils.get(bag, 1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromObjectArray() throws Exception {\n         // Object array, entry exists\n         Object[] objArray = new Object[2];\n         objArray[0] = \"zero\";\n         objArray[1] = \"one\";\n-        test = CollectionUtils.index(objArray,0);\n-        assertTrue(test.equals(\"zero\"));\n-        test = CollectionUtils.index(objArray,1);\n-        assertTrue(test.equals(\"one\"));\n-        \n-        // Object array, non-existent entry -- ArrayIndexOutOfBoundsException\n-        try {\n-            test = CollectionUtils.index(objArray,2);\n-            fail(\"Expecting ArrayIndexOutOfBoundsException.\");\n-        } catch (ArrayIndexOutOfBoundsException ex) {\n-            // expected\n-        }\n-        \n-        // Non-collection object -- returned unchanged\n+        assertEquals(\"zero\", CollectionUtils.get(objArray, 0));\n+        assertEquals(\"one\", CollectionUtils.get(objArray, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(objArray, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromPrimativeArray() throws Exception {\n+        // Primitive array, entry exists\n+        int[] array = new int[2];\n+        array[0] = 10;\n+        array[1] = 20;\n+        assertEquals(10, CollectionUtils.get(array, 0));\n+        assertEquals(20, CollectionUtils.get(array, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(array, 2);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void getFromObject() throws Exception {\n+        // Invalid object\n         Object obj = new Object();\n-        test = CollectionUtils.index(obj, obj);\n-        assertTrue(test.equals(obj));\n-    }\n-    \n-    public void testGet() {     \n-        {\n-            // Unordered map, entries exist\n-            Map expected = new HashMap();\n-            expected.put(\"zeroKey\", \"zero\");\n-            expected.put(\"oneKey\", \"one\");\n-        \n-            Map found = new HashMap();\n-            Map.Entry entry = (Map.Entry)(CollectionUtils.get(expected, 0));\n-            found.put(entry.getKey(),entry.getValue());\n-            entry = (Map.Entry)(CollectionUtils.get(expected, 1));\n-            found.put(entry.getKey(),entry.getValue());\n-            assertEquals(expected,found);\n-        \n-            // Map index out of range\n-            try {\n-                CollectionUtils.get(expected,  2);\n-                fail(\"Expecting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException e) {\n-                // expected\n-            }\n-            try {\n-                CollectionUtils.get(expected,  -2);\n-                fail(\"Expecting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException e) {\n-                // expected\n-            }\n-        }\n-\n-        {\n-            // Sorted map, entries exist, should respect order\n-            SortedMap map = new TreeMap();\n-            map.put(\"zeroKey\", \"zero\");\n-            map.put(\"oneKey\", \"one\");\n-            Object test = CollectionUtils.get(map, 1);\n-            assertEquals(\"zeroKey\",((Map.Entry) test).getKey());\n-            assertEquals(\"zero\",((Map.Entry) test).getValue());\n-            test = CollectionUtils.get(map, 0);\n-            assertEquals(\"oneKey\",((Map.Entry) test).getKey());\n-            assertEquals(\"one\",((Map.Entry) test).getValue());\n-        }\n-                \n-        {\n-            // List, entry exists\n-            List list = new ArrayList();\n-            list.add(\"zero\");\n-            list.add(\"one\");\n-            assertEquals(\"zero\",CollectionUtils.get(list, 0));\n-            assertEquals(\"one\",CollectionUtils.get(list, 1));\n-            // list, non-existent entry -- IndexOutOfBoundsException\n-            try {\n-                CollectionUtils.get(list, 2);\n-                fail(\"Expecting IndexOutOfBoundsException\");\n-            } catch (IndexOutOfBoundsException e) {\n-                // expected\n-            }\n-\n-            // Iterator, entry exists\n-            Iterator iterator = list.iterator();\n-            assertEquals(\"zero\",CollectionUtils.get(iterator,0));\n-            iterator = list.iterator();\n-            assertEquals(\"one\",CollectionUtils.get(iterator,1));\n-        \n-            // Iterator, non-existent entry \n-            try {\n-                CollectionUtils.get(iterator,3);\n-                fail(\"Expecting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException e) {\n-                // expected\n-            }\n-            assertTrue(!iterator.hasNext());\n-        }\n-        \n-        {\n-            // Enumeration, entry exists\n-            Vector vector = new Vector();\n-            vector.addElement(\"zero\");\n-            vector.addElement(\"one\");\n-            Enumeration en = vector.elements();\n-            assertEquals(\"zero\",CollectionUtils.get(en,0));\n-            en = vector.elements();\n-            assertEquals(\"one\",CollectionUtils.get(en,1));\n-        \n-            // Enumerator, non-existent entry \n-            try {\n-                CollectionUtils.get(en,3);\n-                fail(\"Expecting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException e) {\n-                // expected\n-            }\n-            assertTrue(!en.hasMoreElements());\n-        }\n-        \n-        {\n-            // Collection, entry exists\n-            Bag bag = new HashBag();\n-            bag.add(\"element\", 1);\n-            assertEquals(\"element\",CollectionUtils.get(bag, 0));\n-        \n-            // Collection, non-existent entry\n-            try {\n-                CollectionUtils.get(bag, 1);\n-                fail(\"Expceting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException e) {\n-                // expected\n-            }\n-        }\n-        \n-        {\n-            // Object array, entry exists\n-            Object[] objArray = new Object[2];\n-            objArray[0] = \"zero\";\n-            objArray[1] = \"one\";\n-            assertEquals(\"zero\",CollectionUtils.get(objArray,0));\n-            assertEquals(\"one\",CollectionUtils.get(objArray,1));\n-        \n-            // Object array, non-existent entry -- ArrayIndexOutOfBoundsException\n-            try {\n-                CollectionUtils.get(objArray,2);\n-                fail(\"Expecting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException ex) {\n-                // expected\n-            }\n-        }\n-        \n-        {\n-            // Primitive array, entry exists\n-            int[] array = new int[2];\n-            array[0] = 10;\n-            array[1] = 20;\n-            assertEquals(new Integer(10), CollectionUtils.get(array,0));\n-            assertEquals(new Integer(20), CollectionUtils.get(array,1));\n-        \n-            // Object array, non-existent entry -- ArrayIndexOutOfBoundsException\n-            try {\n-                CollectionUtils.get(array,2);\n-                fail(\"Expecting IndexOutOfBoundsException.\");\n-            } catch (IndexOutOfBoundsException ex) {\n-                // expected\n-            }\n-        }\n-        \n-        {\n-            // Invalid object\n-            Object obj = new Object();\n-            try {\n-                CollectionUtils.get(obj, 0);\n-                fail(\"Expecting IllegalArgumentException.\");\n-            } catch (IllegalArgumentException e) {\n-                // expected\n-            }\n-            try {\n-                CollectionUtils.get(null, 0);\n-                fail(\"Expecting IllegalArgumentException.\");\n-            } catch (IllegalArgumentException e) {\n-                // expected\n-            }\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        CollectionUtils.get(obj, 0);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n     public void testSize_List() {\n         List list = null;\n         assertEquals(0, CollectionUtils.size(list));\n         list.add(\"b\");\n         assertEquals(2, CollectionUtils.size(list));\n     }\n+\n+    @Test\n     public void testSize_Map() {\n-        Map map = new HashMap();\n+        Map<String, String> map = new HashMap<String, String>();\n         assertEquals(0, CollectionUtils.size(map));\n         map.put(\"1\", \"a\");\n         assertEquals(1, CollectionUtils.size(map));\n         map.put(\"2\", \"b\");\n         assertEquals(2, CollectionUtils.size(map));\n     }\n+\n+    @Test\n     public void testSize_Array() {\n         Object[] objectArray = new Object[0];\n         assertEquals(0, CollectionUtils.size(objectArray));\n-        \n+\n         String[] stringArray = new String[3];\n         assertEquals(3, CollectionUtils.size(stringArray));\n         stringArray[0] = \"a\";\n         stringArray[2] = \"c\";\n         assertEquals(3, CollectionUtils.size(stringArray));\n     }\n+\n+    @Test\n     public void testSize_PrimitiveArray() {\n         int[] intArray = new int[0];\n         assertEquals(0, CollectionUtils.size(intArray));\n-        \n+\n         double[] doubleArray = new double[3];\n         assertEquals(3, CollectionUtils.size(doubleArray));\n         doubleArray[0] = 0.0d;\n         doubleArray[2] = 2.5d;\n         assertEquals(3, CollectionUtils.size(doubleArray));\n     }\n+\n+    @Test\n     public void testSize_Enumeration() {\n-        Vector list = new Vector();\n+        Vector<String> list = new Vector<String>();\n         assertEquals(0, CollectionUtils.size(list.elements()));\n         list.add(\"a\");\n         assertEquals(1, CollectionUtils.size(list.elements()));\n         list.add(\"b\");\n         assertEquals(2, CollectionUtils.size(list.elements()));\n     }\n+\n+    @Test\n     public void testSize_Iterator() {\n-        List list = new ArrayList();\n+        List<String> list = new ArrayList<String>();\n         assertEquals(0, CollectionUtils.size(list.iterator()));\n         list.add(\"a\");\n         assertEquals(1, CollectionUtils.size(list.iterator()));\n         list.add(\"b\");\n         assertEquals(2, CollectionUtils.size(list.iterator()));\n     }\n+\n+    @Test\n     public void testSize_Other() {\n         try {\n             CollectionUtils.size(\"not a list\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {}\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n     public void testSizeIsEmpty_Null() {\n         assertEquals(true, CollectionUtils.sizeIsEmpty(null));\n     }\n     public void testSizeIsEmpty_List() {\n-        List list = new ArrayList();\n+        List<String> list = new ArrayList<String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(list));\n         list.add(\"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(list));\n     }\n+\n+    @Test\n     public void testSizeIsEmpty_Map() {\n-        Map map = new HashMap();\n+        Map<String, String> map = new HashMap<String, String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(map));\n         map.put(\"1\", \"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(map));\n     }\n+\n+    @Test\n     public void testSizeIsEmpty_Array() {\n         Object[] objectArray = new Object[0];\n         assertEquals(true, CollectionUtils.sizeIsEmpty(objectArray));\n-        \n+\n         String[] stringArray = new String[3];\n         assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n         stringArray[0] = \"a\";\n         stringArray[2] = \"c\";\n         assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n     }\n+\n+    @Test\n     public void testSizeIsEmpty_PrimitiveArray() {\n         int[] intArray = new int[0];\n         assertEquals(true, CollectionUtils.sizeIsEmpty(intArray));\n-        \n+\n         double[] doubleArray = new double[3];\n         assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n         doubleArray[0] = 0.0d;\n         doubleArray[2] = 2.5d;\n         assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n     }\n+\n+    @Test\n     public void testSizeIsEmpty_Enumeration() {\n-        Vector list = new Vector();\n+        Vector<String> list = new Vector<String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(list.elements()));\n         list.add(\"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(list.elements()));\n-        Enumeration en = list.elements();\n+        Enumeration<String> en = list.elements();\n         en.nextElement();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(en));\n     }\n+\n+    @Test\n     public void testSizeIsEmpty_Iterator() {\n-        List list = new ArrayList();\n+        List<String> list = new ArrayList<String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(list.iterator()));\n         list.add(\"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(list.iterator()));\n-        Iterator it = list.iterator();\n+        Iterator<String> it = list.iterator();\n         it.next();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(it));\n     }\n+\n+    @Test\n     public void testSizeIsEmpty_Other() {\n         try {\n             CollectionUtils.sizeIsEmpty(\"not a list\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n     public void testIsEmptyWithEmptyCollection() {\n-        Collection coll = new ArrayList();\n+        Collection<Object> coll = new ArrayList<Object>();\n         assertEquals(true, CollectionUtils.isEmpty(coll));\n     }\n \n+    @Test\n     public void testIsEmptyWithNonEmptyCollection() {\n-        Collection coll = new ArrayList();\n+        Collection<String> coll = new ArrayList<String>();\n         coll.add(\"item\");\n         assertEquals(false, CollectionUtils.isEmpty(coll));\n     }\n \n+    @Test\n     public void testIsEmptyWithNull() {\n-        Collection coll = null;\n+        Collection<?> coll = null;\n         assertEquals(true, CollectionUtils.isEmpty(coll));\n     }\n \n+    @Test\n     public void testIsNotEmptyWithEmptyCollection() {\n-        Collection coll = new ArrayList();\n+        Collection<Object> coll = new ArrayList<Object>();\n         assertEquals(false, CollectionUtils.isNotEmpty(coll));\n     }\n \n+    @Test\n     public void testIsNotEmptyWithNonEmptyCollection() {\n-        Collection coll = new ArrayList();\n+        Collection<String> coll = new ArrayList<String>();\n         coll.add(\"item\");\n         assertEquals(true, CollectionUtils.isNotEmpty(coll));\n     }\n \n+    @Test\n     public void testIsNotEmptyWithNull() {\n-        Collection coll = null;\n+        Collection<?> coll = null;\n         assertEquals(false, CollectionUtils.isNotEmpty(coll));\n     }\n \n-    //-----------------------------------------------------------------------\n-    private static Predicate EQUALS_TWO = new Predicate() {\n-        public boolean evaluate(Object input) {\n-            return (input.equals(\"Two\"));\n+    // -----------------------------------------------------------------------\n+    private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n+        public boolean evaluate(Number input) {\n+            return (input.intValue() == 2);\n         }\n     };\n-    \n-    public void testFilter() {\n-        List list = new ArrayList();\n-        list.add(\"One\");\n-        list.add(\"Two\");\n-        list.add(\"Three\");\n-        list.add(\"Four\");\n-        CollectionUtils.filter(list, EQUALS_TWO);\n-        assertEquals(1, list.size());\n-        assertEquals(\"Two\", list.get(0));\n-        \n-        list = new ArrayList();\n-        list.add(\"One\");\n-        list.add(\"Two\");\n-        list.add(\"Three\");\n-        list.add(\"Four\");\n-        CollectionUtils.filter(list, null);\n-        assertEquals(4, list.size());\n+\n+//Up to here\n+    @SuppressWarnings(\"cast\")\n+    @Test\n+    public void filter() {\n+        List<Integer> ints = new ArrayList<Integer>();\n+        ints.add(1);\n+        ints.add(2);\n+        ints.add(3);\n+        ints.add(3);\n+        Iterable<Integer> iterable = ints;\n+        CollectionUtils.filter(iterable, EQUALS_TWO);\n+        assertEquals(1, (int) ints.size());\n+        assertEquals(2, (int) ints.get(0));\n+    }\n+\n+    @Test\n+    public void filterNullParameters() throws Exception {\n+        List<Long> longs = Collections.nCopies(4, 10L);\n+        CollectionUtils.filter(longs, null);\n+        assertEquals(4, longs.size());\n         CollectionUtils.filter(null, EQUALS_TWO);\n-        assertEquals(4, list.size());\n+        assertEquals(4, longs.size());\n         CollectionUtils.filter(null, null);\n-        assertEquals(4, list.size());\n-    }\n-\n-    public void testCountMatches() {\n-        List list = new ArrayList();\n-        list.add(\"One\");\n-        list.add(\"Two\");\n-        list.add(\"Three\");\n-        list.add(\"Four\");\n-        int count = CollectionUtils.countMatches(list, EQUALS_TWO);\n-        assertEquals(4, list.size());\n-        assertEquals(1, count);\n-        assertEquals(0, CollectionUtils.countMatches(list, null));\n+        assertEquals(4, longs.size());\n+    }\n+\n+    @Test\n+    public void countMatches() {\n+        assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(iterableA, null));\n         assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));\n         assertEquals(0, CollectionUtils.countMatches(null, null));\n     }\n \n-    public void testExists() {\n-        List list = new ArrayList();\n-        assertEquals(false, CollectionUtils.exists(null, null));\n-        assertEquals(false, CollectionUtils.exists(list, null));\n-        assertEquals(false, CollectionUtils.exists(null, EQUALS_TWO));\n-        assertEquals(false, CollectionUtils.exists(list, EQUALS_TWO));\n-        list.add(\"One\");\n-        list.add(\"Three\");\n-        list.add(\"Four\");\n-        assertEquals(false, CollectionUtils.exists(list, EQUALS_TWO));\n-\n-        list.add(\"Two\");\n+    @Test\n+    public void exists() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        assertFalse(CollectionUtils.exists(null, null));\n+        assertFalse(CollectionUtils.exists(list, null));\n+        assertFalse(CollectionUtils.exists(null, EQUALS_TWO));\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+        list.add(1);\n+        list.add(3);\n+        list.add(4);\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+\n+        list.add(2);\n         assertEquals(true, CollectionUtils.exists(list, EQUALS_TWO));\n     }\n-    \n-    public void testSelect() {\n-        List list = new ArrayList();\n-        list.add(\"One\");\n-        list.add(\"Two\");\n-        list.add(\"Three\");\n-        list.add(\"Four\");\n-        Collection output = CollectionUtils.select(list, EQUALS_TWO);\n+\n+    @Test\n+    public void select() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        // Ensure that the collection is the input type or a super type\n+        Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n+        Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n+        HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n         assertEquals(4, list.size());\n-        assertEquals(1, output.size());\n-        assertEquals(\"Two\", output.iterator().next());\n-    }\n-\n-    public void testSelectRejected() {\n-        List list = new ArrayList();\n-        list.add(\"One\");\n-        list.add(\"Two\");\n-        list.add(\"Three\");\n-        list.add(\"Four\");\n-        Collection output = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        assertEquals(1, output1.size());\n+        assertEquals(2, output2.iterator().next());\n+    }\n+\n+    @Test\n+    public void selectRejected() {\n+        List<Long> list = new ArrayList<Long>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        list.add(4L);\n+        Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n         assertEquals(4, list.size());\n-        assertEquals(3, output.size());\n-        assertTrue(output.contains(\"One\"));\n-        assertTrue(output.contains(\"Three\"));\n-        assertTrue(output.contains(\"Four\"));\n-    }\n-    \n-    public void testCollect() {\n-        Transformer transformer = TransformerUtils.constantTransformer(\"z\");\n-        Collection collection = CollectionUtils.collect(collectionA, transformer);\n+        assertEquals(3, output1.size());\n+        assertTrue(output1.contains(1L));\n+        assertTrue(output1.contains(3L));\n+        assertTrue(output1.contains(4L));\n+    }\n+\n+    @Test\n+    public void collect() {\n+        Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n+        Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);\n         assertTrue(collection.size() == collectionA.size());\n-        assertTrue(collectionA.contains(\"a\") && ! collectionA.contains(\"z\"));\n-        assertTrue(collection.contains(\"z\") && !collection.contains(\"a\"));\n-        \n-        collection = new ArrayList();\n-        CollectionUtils.collect(collectionA, transformer, collection);\n+        assertCollectResult(collection);\n+\n+        ArrayList<Number> list;\n+        list = CollectionUtils.collect(collectionA, transformer, new ArrayList<Number>());\n+        assertTrue(list.size() == collectionA.size());\n+        assertCollectResult(list);\n+\n+        Iterator<Integer> iterator = null;\n+        list = CollectionUtils.collect(iterator, transformer, new ArrayList<Number>());\n+\n+        iterator = iterableA.iterator();\n+        list = CollectionUtils.collect(iterator, transformer, list);\n         assertTrue(collection.size() == collectionA.size());\n-        assertTrue(collectionA.contains(\"a\") && ! collectionA.contains(\"z\"));\n-        assertTrue(collection.contains(\"z\") && !collection.contains(\"a\"));\n-        \n-        Iterator iterator = null;\n-        collection = new ArrayList();\n-        CollectionUtils.collect(iterator, transformer, collection);\n-        \n+        assertCollectResult(collection);\n+\n         iterator = collectionA.iterator();\n-        CollectionUtils.collect(iterator, transformer, collection);\n+        collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);\n         assertTrue(collection.size() == collectionA.size());\n-        assertTrue(collectionA.contains(\"a\") && ! collectionA.contains(\"z\"));\n-        assertTrue(collection.contains(\"z\") && !collection.contains(\"a\")); \n-        \n-        iterator = collectionA.iterator();\n-        collection = CollectionUtils.collect(iterator, transformer);\n-        assertTrue(collection.size() == collectionA.size());\n-        assertTrue(collection.contains(\"z\") && !collection.contains(\"a\")); \n-        collection = CollectionUtils.collect((Iterator) null, (Transformer) null);\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+        collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);\n         assertTrue(collection.size() == 0);\n-           \n+\n         int size = collectionA.size();\n-        CollectionUtils.collect((Collection) null, transformer, collectionA);\n-        assertTrue(collectionA.size() == size && collectionA.contains(\"a\"));\n+        collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n         CollectionUtils.collect(collectionB, null, collectionA);\n-        assertTrue(collectionA.size() == size && collectionA.contains(\"a\"));\n-        \n-    }\n-\n-    Transformer TRANSFORM_TO_INTEGER = new Transformer() {\n-        public Object transform(Object input) {\n-            return new Integer((String) input);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+\n+    }\n+\n+    private void assertCollectResult(Collection<Number> collection) {\n+        assertTrue(collectionA.contains(1) && !collectionA.contains(2L));\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+    }\n+\n+    Transformer<Object, Integer> TRANSFORM_TO_INTEGER = new Transformer<Object, Integer>() {\n+        public Integer transform(Object input) {\n+            return new Integer(((Long)input).intValue());\n         }\n     };\n-    \n-    public void testTransform1() {\n-        List list = new ArrayList();\n-        list.add(\"1\");\n-        list.add(\"2\");\n-        list.add(\"3\");\n+\n+    @Test\n+    public void transform1() {\n+        List<Number> list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n         CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);\n         assertEquals(3, list.size());\n-        assertEquals(new Integer(1), list.get(0));\n-        assertEquals(new Integer(2), list.get(1));\n-        assertEquals(new Integer(3), list.get(2));\n-        \n-        list = new ArrayList();\n-        list.add(\"1\");\n-        list.add(\"2\");\n-        list.add(\"3\");\n+        assertEquals(1, list.get(0));\n+        assertEquals(2, list.get(1));\n+        assertEquals(3, list.get(2));\n+\n+        list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n         CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);\n         assertEquals(3, list.size());\n         CollectionUtils.transform(list, null);\n         CollectionUtils.transform(null, null);\n         assertEquals(3, list.size());\n     }\n-    \n-    public void testTransform2() {\n-        Set set = new HashSet();\n+\n+    @Test\n+    public void transform2() {\n+        Set<Number> set = new HashSet<Number>();\n+        set.add(1L);\n+        set.add(2L);\n+        set.add(3L);\n+        CollectionUtils.transform(set, new Transformer<Object, Integer>() {\n+            public Integer transform(Object input) {\n+                return 4;\n+            }\n+        });\n+        assertEquals(1, set.size());\n+        assertEquals(4, set.iterator().next());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void addIgnoreNull() {\n+        Set<String> set = new HashSet<String>();\n         set.add(\"1\");\n         set.add(\"2\");\n         set.add(\"3\");\n-        CollectionUtils.transform(set, new Transformer() {\n-            public Object transform(Object input) {\n-                return new Integer(4);\n-            }\n-        });\n-        assertEquals(1, set.size());\n-        assertEquals(new Integer(4), set.iterator().next());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testAddIgnoreNull() {\n-        Set set = new HashSet();\n-        set.add(\"1\");\n-        set.add(\"2\");\n-        set.add(\"3\");\n-        assertEquals(false, CollectionUtils.addIgnoreNull(set, null));\n+        assertFalse(CollectionUtils.addIgnoreNull(set, null));\n         assertEquals(3, set.size());\n-        assertEquals(false, CollectionUtils.addIgnoreNull(set, \"1\"));\n+        assertFalse(CollectionUtils.addIgnoreNull(set, \"1\"));\n         assertEquals(3, set.size());\n         assertEquals(true, CollectionUtils.addIgnoreNull(set, \"4\"));\n         assertEquals(4, set.size());\n         assertEquals(true, set.contains(\"4\"));\n     }\n \n-    //-----------------------------------------------------------------------\n-    public void testPredicatedCollection() {\n-        Predicate predicate = new Predicate() {\n-            public boolean evaluate(Object o) {\n-                return o instanceof String;\n-            }\n-        };\n-        Collection collection = \n-            CollectionUtils.predicatedCollection(new ArrayList(), predicate);\n-        assertTrue(\"returned object should be a PredicatedCollection\",\n-            collection instanceof PredicatedCollection);\n-        try { \n-           collection = \n-                CollectionUtils.predicatedCollection(new ArrayList(), null); \n-           fail(\"Expecting IllegalArgumentException for null predicate.\");\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void predicatedCollection() {\n+        Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n+        Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection);\n+        try {\n+            collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        try { \n-           collection = \n-                CollectionUtils.predicatedCollection(null, predicate); \n-           fail(\"Expecting IllegalArgumentException for null collection.\");\n+        try {\n+            CollectionUtils.predicatedCollection(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }             \n-    }\n-        \n-   \n-\n-    public BulkTest bulkTestTypedCollection() {\n-        return new TestTypedCollection(\"\") {\n-            public Collection typedCollection() {\n-                return CollectionUtils.typedCollection(\n-                    new ArrayList(),\n-                    super.getType());\n-            }\n- \n-            public BulkTest bulkTestAll() {\n-                return new AbstractTestCollection(\"\") {\n-                    public Collection makeCollection() {\n-                        return typedCollection();\n-                    }\n- \n-                    public Collection makeConfirmedCollection() {\n-                        return new ArrayList();\n-                    }\n- \n-                    public Collection makeConfirmedFullCollection() {\n-                        ArrayList list = new ArrayList();\n-                        list.addAll(java.util.Arrays.asList(getFullElements()));\n-                        return list;\n-                    }\n- \n-                    public Object[] getFullElements() {\n-                        return getFullNonNullStringElements();\n-                    }\n- \n-                    public Object[] getOtherElements() {\n-                        return getOtherNonNullStringElements();\n-                    }\n- \n-                };\n-            }\n-        };\n-    }\n-    \n-    public void testIsFull() {\n-        Set set = new HashSet();\n+        }\n+    }\n+\n+    @Test\n+    public void isFull() {\n+        Set<String> set = new HashSet<String>();\n         set.add(\"1\");\n         set.add(\"2\");\n         set.add(\"3\");\n         try {\n             CollectionUtils.isFull(null);\n             fail();\n-        } catch (NullPointerException ex) {}\n-        assertEquals(false, CollectionUtils.isFull(set));\n-        \n-        BoundedFifoBuffer buf = new BoundedFifoBuffer(set);\n+        } catch (NullPointerException ex) {\n+        }\n+        assertFalse(CollectionUtils.isFull(set));\n+\n+        BoundedFifoBuffer<String> buf = new BoundedFifoBuffer<String>(set);\n         assertEquals(true, CollectionUtils.isFull(buf));\n         buf.remove(\"2\");\n-        assertEquals(false, CollectionUtils.isFull(buf));\n+        assertFalse(CollectionUtils.isFull(buf));\n         buf.add(\"2\");\n         assertEquals(true, CollectionUtils.isFull(buf));\n-        \n-        Buffer buf2 = BufferUtils.synchronizedBuffer(buf);\n+\n+        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n         assertEquals(true, CollectionUtils.isFull(buf2));\n         buf2.remove(\"2\");\n-        assertEquals(false, CollectionUtils.isFull(buf2));\n+        assertFalse(CollectionUtils.isFull(buf2));\n         buf2.add(\"2\");\n         assertEquals(true, CollectionUtils.isFull(buf2));\n     }\n \n-    public void testMaxSize() {\n-        Set set = new HashSet();\n+    @Test\n+    public void isEmpty() {\n+        assertFalse(CollectionUtils.isNotEmpty(null));\n+        assertTrue(CollectionUtils.isNotEmpty(collectionA));\n+    }\n+\n+    @Test\n+    public void maxSize() {\n+        Set<String> set = new HashSet<String>();\n         set.add(\"1\");\n         set.add(\"2\");\n         set.add(\"3\");\n         try {\n             CollectionUtils.maxSize(null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (NullPointerException ex) {\n+        }\n         assertEquals(-1, CollectionUtils.maxSize(set));\n-        \n-        BoundedFifoBuffer buf = new BoundedFifoBuffer(set);\n+\n+        Buffer<String> buf = new BoundedFifoBuffer<String>(set);\n         assertEquals(3, CollectionUtils.maxSize(buf));\n         buf.remove(\"2\");\n         assertEquals(3, CollectionUtils.maxSize(buf));\n         buf.add(\"2\");\n         assertEquals(3, CollectionUtils.maxSize(buf));\n-        \n-        Buffer buf2 = BufferUtils.synchronizedBuffer(buf);\n+\n+        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n         assertEquals(3, CollectionUtils.maxSize(buf2));\n         buf2.remove(\"2\");\n         assertEquals(3, CollectionUtils.maxSize(buf2));\n         assertEquals(3, CollectionUtils.maxSize(buf2));\n     }\n \n-    public void testIntersectionUsesMethodEquals() {\n+    @Test\n+    public void intersectionUsesMethodEquals() {\n         // Let elta and eltb be objects...\n-        Object elta = new Integer(17);\n-        Object eltb = new Integer(17);\n-        \n+        Integer elta = new Integer(17);\n+        Integer eltb = new Integer(17);\n+\n         // ...which are equal...\n-        assertEquals(elta,eltb);\n-        assertEquals(eltb,elta);\n-        \n+        assertEquals(elta, eltb);\n+        assertEquals(eltb, elta);\n+\n         // ...but not the same (==).\n         assertTrue(elta != eltb);\n-        \n+\n         // Let cola and colb be collections...\n-        Collection cola = new ArrayList();\n-        Collection colb = new ArrayList();\n-        \n-        // ...which contain elta and eltb, \n+        Collection<Number> cola = new ArrayList<Number>();\n+        Collection<Integer> colb = new ArrayList<Integer>();\n+\n+        // ...which contain elta and eltb,\n         // respectively.\n         cola.add(elta);\n         colb.add(eltb);\n-        \n+\n         // Then the intersection of the two\n         // should contain one element.\n-        Collection intersection = CollectionUtils.intersection(cola,colb);\n-        assertEquals(1,intersection.size());\n-        \n+        Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n+        assertEquals(1, intersection.size());\n+\n         // In practice, this element will be the same (==) as elta\n         // or eltb, although this isn't strictly part of the\n         // contract.\n         Object eltc = intersection.iterator().next();\n-        assertTrue((eltc == elta  && eltc != eltb) || (eltc != elta  && eltc == eltb));\n-        \n+        assertTrue((eltc == elta && eltc != eltb) || (eltc != elta && eltc == eltb));\n+\n         // In any event, this element remains equal,\n         // to both elta and eltb.\n-        assertEquals(elta,eltc);\n-        assertEquals(eltc,elta);\n-        assertEquals(eltb,eltc);\n-        assertEquals(eltc,eltb);\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        assertEquals(elta, eltc);\n+        assertEquals(eltc, elta);\n+        assertEquals(eltb, eltc);\n+        assertEquals(eltc, eltb);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    //Up to here\n+    @Test\n     public void testRetainAll() {\n-        List base = new ArrayList();\n+        List<String> base = new ArrayList<String>();\n         base.add(\"A\");\n         base.add(\"B\");\n         base.add(\"C\");\n-        List sub = new ArrayList();\n+        List<Object> sub = new ArrayList<Object>();\n         sub.add(\"A\");\n         sub.add(\"C\");\n         sub.add(\"X\");\n-        \n-        Collection result = CollectionUtils.retainAll(base, sub);\n+\n+        Collection<String> result = CollectionUtils.retainAll(base, sub);\n         assertEquals(2, result.size());\n         assertEquals(true, result.contains(\"A\"));\n-        assertEquals(false, result.contains(\"B\"));\n+        assertFalse(result.contains(\"B\"));\n         assertEquals(true, result.contains(\"C\"));\n         assertEquals(3, base.size());\n         assertEquals(true, base.contains(\"A\"));\n         assertEquals(true, sub.contains(\"A\"));\n         assertEquals(true, sub.contains(\"C\"));\n         assertEquals(true, sub.contains(\"X\"));\n-        \n+\n         try {\n             CollectionUtils.retainAll(null, null);\n             fail(\"expecting NullPointerException\");\n-        } catch(NullPointerException npe){} // this is what we want\n-    }\n-\n+        } catch (NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    @Test\n     public void testRemoveAll() {\n-        List base = new ArrayList();\n+        List<String> base = new ArrayList<String>();\n         base.add(\"A\");\n         base.add(\"B\");\n         base.add(\"C\");\n-        List sub = new ArrayList();\n+        List<String> sub = new ArrayList<String>();\n         sub.add(\"A\");\n         sub.add(\"C\");\n         sub.add(\"X\");\n-        \n-        Collection result = CollectionUtils.removeAll(base, sub);\n+\n+        Collection<String> result = CollectionUtils.removeAll(base, sub);\n         assertEquals(1, result.size());\n-        assertEquals(false, result.contains(\"A\"));\n+        assertFalse(result.contains(\"A\"));\n         assertEquals(true, result.contains(\"B\"));\n-        assertEquals(false, result.contains(\"C\"));\n+        assertFalse(result.contains(\"C\"));\n         assertEquals(3, base.size());\n         assertEquals(true, base.contains(\"A\"));\n         assertEquals(true, base.contains(\"B\"));\n         assertEquals(true, sub.contains(\"A\"));\n         assertEquals(true, sub.contains(\"C\"));\n         assertEquals(true, sub.contains(\"X\"));\n-        \n+\n         try {\n             CollectionUtils.removeAll(null, null);\n             fail(\"expecting NullPointerException\");\n-        } catch(NullPointerException npe){} // this is what we want\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        } catch (NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n     public void testTransformedCollection() {\n-        Transformer transformer = TransformerUtils.nopTransformer();\n-        Collection collection = \n-            CollectionUtils.transformedCollection(new ArrayList(), transformer);\n-        assertTrue(\"returned object should be a TransformedCollection\",\n-            collection instanceof TransformedCollection);\n-        try { \n-           collection = \n-                CollectionUtils.transformedCollection(new ArrayList(), null); \n-           fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n+        Collection<Object> collection = CollectionUtils.transformedCollection(new ArrayList<Object>(), transformer);\n+        assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n+        try {\n+            collection = CollectionUtils.transformedCollection(new ArrayList<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        try { \n-           collection = \n-                CollectionUtils.transformedCollection(null, transformer); \n-           fail(\"Expecting IllegalArgumentException for null collection.\");\n+        try {\n+            collection = CollectionUtils.transformedCollection(null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }             \n-    }\n-\n+        }\n+    }\n+\n+    @Test\n     public void testTransformedCollection_2() {\n-        List list = new ArrayList();\n+        List<Object> list = new ArrayList<Object>();\n         list.add(\"1\");\n         list.add(\"2\");\n         list.add(\"3\");\n-        Collection result = CollectionUtils.transformedCollection(list, TRANSFORM_TO_INTEGER);\n-        assertEquals(true, result.contains(\"1\"));  // untransformed\n-        assertEquals(true, result.contains(\"2\"));  // untransformed\n-        assertEquals(true, result.contains(\"3\"));  // untransformed\n-    }\n-\n+        Collection<Object> result = CollectionUtils.transformedCollection(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(true, result.contains(\"1\")); // untransformed\n+        assertEquals(true, result.contains(\"2\")); // untransformed\n+        assertEquals(true, result.contains(\"3\")); // untransformed\n+    }\n+\n+    @Test\n     public void testSynchronizedCollection() {\n-        Collection col = CollectionUtils.synchronizedCollection(new ArrayList());\n-        assertTrue(\"Returned object should be a SynchronizedCollection.\",\n-            col instanceof SynchronizedCollection);\n+        Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedCollection.\", col instanceof SynchronizedCollection);\n         try {\n             col = CollectionUtils.synchronizedCollection(null);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-    }\n-    \n+        }\n+    }\n+\n+    @Test\n     public void testUnmodifiableCollection() {\n-        Collection col = CollectionUtils.unmodifiableCollection(new ArrayList());\n-        assertTrue(\"Returned object should be a UnmodifiableCollection.\",\n-            col instanceof UnmodifiableCollection);\n+        Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a UnmodifiableCollection.\", col instanceof UnmodifiableCollection);\n         try {\n             col = CollectionUtils.unmodifiableCollection(null);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-    }\n-    \n+        }\n+    }\n+\n+    @Test\n+    public void emptyCollection() throws Exception {\n+        Collection<Number> coll = CollectionUtils.emptyCollection();\n+        assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);\n+    }\n+\n+    /**\n+     * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n+     * Specifically, it uses mocks to ensure that if the passed in\n+     * {@link Iterable} is a {@link Collection} then\n+     * {@link Collection#addAll(Collection)} is called instead of iterating.\n+     */\n+    @Test\n+    public void addAllForIterable() {\n+        Collection<Integer> inputCollection = createMock(Collection.class);\n+        Iterable<Integer> inputIterable = inputCollection;\n+        Iterable<Long> iterable = createMock(Iterable.class);\n+        Iterator<Long> iterator = createMock(Iterator.class);\n+        Collection<Number> c = createMock(Collection.class);\n+\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        next(iterator, 2L);\n+        next(iterator, 3L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(true);\n+        expect(c.add(2L)).andReturn(true);\n+        expect(c.add(3L)).andReturn(true);\n+        // Check that the collection is added using\n+        // Collection.addAll(Collection)\n+        expect(c.addAll(inputCollection)).andReturn(true);\n+\n+        // Ensure the method returns false if nothing is added\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(false);\n+        expect(c.addAll(inputCollection)).andReturn(false);\n+\n+        replay();\n+        assertTrue(CollectionUtils.addAll(c, iterable));\n+        assertTrue(CollectionUtils.addAll(c, inputIterable));\n+\n+        assertFalse(CollectionUtils.addAll(c, iterable));\n+        assertFalse(CollectionUtils.addAll(c, inputIterable));\n+        verify();\n+    }\n+\n+    @Test\n+    public void addAllForEnumeration() {\n+        Hashtable<Integer, Integer> h = new Hashtable<Integer, Integer>();\n+        h.put(5, 5);\n+        Enumeration<? extends Integer> enumeration = h.keys();\n+        CollectionUtils.addAll(collectionA, enumeration);\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test\n+    public void addAllForElements() {\n+        CollectionUtils.addAll(collectionA, new Integer[]{5});\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test\n+    public void get() {\n+        try {\n+            CollectionUtils.get((Object)collectionA, -3);\n+            fail();\n+        } catch(IndexOutOfBoundsException e) {\n+            ;\n+        }\n+        try {\n+            CollectionUtils.get((Object)collectionA.iterator(), 30);\n+            fail();\n+        } catch(IndexOutOfBoundsException e) {\n+            ;\n+        }\n+        try {\n+            CollectionUtils.get((Object)null, 0);\n+            fail();\n+        } catch(IllegalArgumentException e) {\n+            ;\n+        }\n+        assertEquals(2, CollectionUtils.get((Object)collectionA, 2));\n+        assertEquals(2, CollectionUtils.get((Object)collectionA.iterator(), 2));\n+        Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n+        assertEquals(map.entrySet().iterator().next(), CollectionUtils.get(\n+                (Object)map, 0));\n+    }\n+\n+    /**\n+     * TODO: Should {@link CollectionUtils} be able to be extended? If it is extended, subclasses must 'override' the static methods with\n+     * call-throughs anyhow, otherwise java compiler warnings will result\n+     */\n+    @Test\n+    public void ensureCollectionUtilsCanBeExtended() {\n+        new CollectionUtils() {};\n+    }\n+\n+    @Test\n+    public void reverse() {\n+        CollectionUtils.reverseArray(new Object[] {});\n+        Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);\n+        CollectionUtils.reverseArray(a);\n+        // assume our implementation is correct if it returns the same order as the Java function\n+        Collections.reverse(collectionA);\n+        assertEquals(collectionA, Arrays.asList(a));\n+    }\n+\n+    @Test\n+    public void extractSingleton() {\n+        ArrayList<String> coll = null;\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(null)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        coll = new ArrayList<String>();\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(empty)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        coll.add(\"foo\");\n+        assertEquals(\"foo\", CollectionUtils.extractSingleton(coll));\n+        coll.add(\"bar\");\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(size == 2)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    /**\n+     * Records the next object returned for a mock iterator\n+     */\n+    private <T> void next(Iterator<T> iterator, T t) {\n+        expect(iterator.hasNext()).andReturn(true);\n+        expect(iterator.next()).andReturn(t);\n+    }\n }", "timestamp": 1252994279, "metainfo": ""}