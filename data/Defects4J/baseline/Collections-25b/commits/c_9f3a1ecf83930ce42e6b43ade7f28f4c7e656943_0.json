{"sha": "9f3a1ecf83930ce42e6b43ade7f28f4c7e656943", "log": "Modified BlockingBuffer add method to notifyAll instead of notify. Added tests to verify blocking behavior. Patch submitted by: Janek Bogucki Reviewed by: Phil Steitz Pr #23232, 23159   ", "commit": "\n--- a/src/java/org/apache/commons/collections/decorators/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/decorators/BlockingBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/BlockingBuffer.java,v 1.2 2003/08/31 17:24:46 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/BlockingBuffer.java,v 1.3 2003/09/18 03:28:28 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n /**\n  * <code>BlockingBuffer</code> decorates another <code>Buffer</code>\n- * to block on calls to the get method to wait until entries are\n+ * to block on calls to the get and remove methods to wait until entries are\n  * added to the buffer.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:24:46 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/18 03:28:28 $\n  * \n  * @author Stephen Colebourne\n+ * @author Janek Bogucki\n  */\n public class BlockingBuffer extends SynchronizedBuffer {\n     \n     public boolean add(Object o) {\n         synchronized (lock) {\n             boolean result = collection.add(o);\n-            notify();\n+            notifyAll();\n             return result;\n         }\n     }\n--- a/src/test/org/apache/commons/collections/decorators/TestBlockingBuffer.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestBlockingBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestBlockingBuffer.java,v 1.1 2003/09/15 03:50:41 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestBlockingBuffer.java,v 1.2 2003/09/18 03:28:28 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.decorators;\n \n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.LinkedList;\n-import java.util.ArrayList;\n+import java.util.Set;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.ArrayStack;\n import org.apache.commons.collections.BufferUnderflowException;\n import org.apache.commons.collections.decorators.BlockingBuffer;\n \n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $\n+ * @version $Revision: 1.2 $\n  * \n  * @author Janek Bogucki\n  * @author Phil Steitz\n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Tests {@link BlockingBuffer#get()}.\n+     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add()}.\n      */\n     public void testGetWithAdd() {\n       \n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Tests {@link BlockingBuffer#get()}.\n+     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll()}.\n      */\n     public void testGetWithAddAll() {\n         \n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Tests {@link BlockingBuffer#remove()}.\n+     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add()}.\n      */\n     public void testRemoveWithAdd() {\n         \n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Tests {@link BlockingBuffer#remove()}.\n+     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll()}.\n      */\n     public void testRemoveWithAddAll() {\n         \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n         assertSame(obj, blockingBuffer.remove());\n     }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     *  Tests get using multiple read threads.\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add()} using multiple read threads.\n      *\n-     *  Verifies that multiple adds are required to allow gets by\n-     *  multiple threads on an empty buffer to complete.\n+     *  Two read threads should block on an empty buffer until one object\n+     *  is added then both threads should complete.\n      */\n     public void testBlockedGetWithAdd() {\n         \n         Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n         Object obj = new Object();\n         \n-        // run methods will get and compare -- must wait for adds\n+        // run methods will get and compare -- must wait for add\n         Thread thread1 = new ReadThread(blockingBuffer, obj);\n         Thread thread2 = new ReadThread(blockingBuffer, obj);\n         thread1.start();\n         thread2.start();\n         \n         // give hungry read threads ample time to hang\n-        try {\n-            Thread.currentThread().sleep(100);\n-        } catch (InterruptedException e) {}\n-           \n-        // notify should allow one read thread to complete\n+        delay();\n+           \n+        // notifyAll should allow both read threads to complete\n         blockingBuffer.add(obj);\n         \n-        // allow notified thread(s) to complete \n-        try {\n-            Thread.currentThread().sleep(100);\n-        } catch (InterruptedException e) {}\n-        \n-        // There shoould still be one thread waiting.  Verify this.\n-        // This check will fail if add is changed to notifyAll.\n-        assertTrue(\"One read thread should be waiting\", \n-            thread1.isAlive() || thread2.isAlive());\n- \n-        // now add again so the second thread will be notified\n-        blockingBuffer.add(obj);\n-        \n-        // wait to exit until both threads are dead, or appear to be hung\n-        boolean finished = false;\n-        for (int i = 1; i < 10; i++) {\n-            if (thread1.isAlive() || thread2.isAlive()) {\n-                try {\n-                    Thread.currentThread().sleep(100);\n-                }\n-                catch (InterruptedException e) {}\n-            } else {\n-                finished = true;\n-                break;\n-            }\n-        }\n-        if (!finished) {\n-            fail(\"Read thread did not finish.\");\n-        }\n+        // allow notified threads to complete \n+        delay();\n+        \n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive())\n+            fail(\"Live thread(s) when both should be dead.\");\n     }\n     \n-    /**\n-     *  Tests get using multiple read threads.\n-     *  Shows that one addAll allows multiple gets to complete.\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll()} using multiple read threads.\n+     *\n+     *  Two read threads should block on an empty buffer until a\n+     *  singleton is added then both threads should complete.\n      */\n     public void testBlockedGetWithAddAll() {\n         \n         Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n         Object obj = new Object();\n         \n-        // run methods will get and compare -- must wait for adds\n+        // run methods will get and compare -- must wait for addAll\n         Thread thread1 = new ReadThread(blockingBuffer, obj);\n         Thread thread2 = new ReadThread(blockingBuffer, obj);\n         thread1.start();\n         thread2.start();\n         \n         // give hungry read threads ample time to hang\n-        try {\n-            Thread.currentThread().sleep(100);\n-        } catch (InterruptedException e) {}\n+        delay();\n            \n         // notifyAll should allow both read threads to complete\n         blockingBuffer.addAll(Collections.singleton(obj));\n                \n-        // wait to exit until both threads are dead, or appear to be hung\n-        boolean finished = false;\n-        for (int i = 1; i < 10; i++) {\n-            if (thread1.isAlive() || thread2.isAlive()) {\n-                try {\n-                    Thread.currentThread().sleep(100);\n-                }\n-                catch (InterruptedException e) {}\n-            } else {\n-                finished = true;\n-                break;\n-            }  \n-        }\n-        if (!finished) {\n-            fail(\"Read thread did not finish.\");\n-        }\n+        // allow notified threads to complete \n+        delay();\n+        \n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive())\n+            fail(\"Live thread(s) when both should be dead.\");\n     }\n     \n-    /**\n-     *  Tests interrupted get.\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests interrupted {@link BlockingBuffer#get()}.\n      */\n     public void testInterruptedGet() {\n         \n         thread.interrupt();\n         \n         // Chill, so thread can throw and add message to exceptionList\n-        try {\n-            Thread.currentThread().sleep(100);\n-        } catch (InterruptedException e) {}\n+        delay();\n         \n         assertTrue(\"Thread interrupt should have led to underflow\", \n             exceptionList.contains(\"BufferUnderFlow\"));\n         \n         if (thread.isAlive()) {\n-            fail(\"Hung read thread\");\n+            fail(\"Read thread has hung.\");\n         }\n         \n     }\n     \n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add()} using multiple read threads.\n+     *\n+     *  Two read threads should block on an empty buffer until one\n+     *  object is added then one thread should complete. The remaining\n+     *  thread should complete after the addition of a second object.\n+     */\n+    public void testBlockedRemoveWithAdd() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+        \n+        // run methods will remove and compare -- must wait for add\n+        Thread thread1 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+        \n+        // give hungry read threads ample time to hang\n+        delay();\n+           \n+        blockingBuffer.add(obj);\n+        \n+        // allow notified threads to complete \n+        delay();\n+        \n+        // There should be one thread waiting.\n+        assertTrue (\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+           \n+        blockingBuffer.add(obj);\n+        \n+        // allow notified thread to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if(thread1.isAlive() || thread2.isAlive())\n+            fail(\"Live thread(s) when both should be dead.\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll()} using multiple read threads.\n+     *\n+     *  Two read threads should block on an empty buffer until a\n+     *  singleton collection is added then one thread should\n+     *  complete. The remaining thread should complete after the\n+     *  addition of a second singleton.\n+     */\n+    public void testBlockedRemoveWithAddAll1() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+        \n+        // run methods will remove and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread(blockingBuffer, obj, null, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+        \n+        // give hungry read threads ample time to hang\n+        delay();\n+           \n+        blockingBuffer.addAll(Collections.singleton(obj));\n+        \n+        // allow notified threads to complete \n+        delay();\n+        \n+        // There should be one thread waiting.\n+        assertTrue (\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+           \n+        blockingBuffer.addAll(Collections.singleton(obj));\n+        \n+        // allow notified thread to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if(thread1.isAlive() || thread2.isAlive())\n+            fail(\"Live thread(s) when both should be dead.\");\n+    }\n+\n+   \n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll()} using multiple read threads.\n+     *\n+     *  Two read threads should block on an empty buffer until a\n+     *  collection with two distinct objects is added then both\n+     *  threads should complete. Each thread should have read a\n+     *  different object.\n+     */\n+    public void testBlockedRemoveWithAddAll2() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj1 = new Object();\n+        Object obj2 = new Object();\n+        \n+        Set objs = Collections.synchronizedSet(new HashSet());\n+        objs.add(obj1);\n+        objs.add(obj2);\n+\n+        // run methods will remove and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread(blockingBuffer, objs, \"remove\");\n+        Thread thread2 = new ReadThread(blockingBuffer, objs, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+        \n+        // give hungry read threads ample time to hang\n+        delay();\n+           \n+        blockingBuffer.addAll(objs);\n+        \n+        // allow notified threads to complete \n+        delay();\n+        \n+        assertEquals(\"Both objects were removed\", 0, objs.size());\n+\n+        // There should not be any threads waiting.\n+        if(thread1.isAlive() || thread2.isAlive())\n+            fail(\"Live thread(s) when both should be dead.\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Tests interrupted remove.\n      */\n         thread.interrupt();\n         \n         // Chill, so thread can throw and add message to exceptionList\n-        try {\n-            Thread.currentThread().sleep(100);\n-        } catch (InterruptedException e) {}\n+        delay();\n         \n         assertTrue(\"Thread interrupt should have led to underflow\", \n             exceptionList.contains(\"BufferUnderFlow\"));\n         \n         if (thread.isAlive()) {\n-            fail(\"Hung read thread\");\n+            fail(\"Read thread has hung.\");\n         }\n         \n     }\n         Object obj;\n         ArrayList exceptionList = null;\n         String action = \"get\";\n+        Set objs;\n         \n         ReadThread (Buffer buffer, Object obj) {\n             super();\n             this.action = action;\n         }\n                 \n+        ReadThread (Buffer buffer, Set objs, String action) {\n+            super();\n+            this.buffer = buffer;\n+            this.objs = objs;\n+            this.action = action;\n+        }\n+                \n         public void run()  {\n             try {\n                 if (action == \"get\") {\n                     assertSame(obj, buffer.get());\n                 } else {\n-                    assertSame(obj, buffer.remove());\n+                    if (null != obj)\n+                        assertSame(obj, buffer.remove());\n+                    else\n+                        assertTrue(objs.remove(buffer.remove()));\n                 }\n             } catch (BufferUnderflowException ex) {\n                 exceptionList.add(\"BufferUnderFlow\");\n             return remove(0);\n         }\n     }\n+\n+    private void delay(){\n+        try {\n+            Thread.currentThread().sleep(100);\n+        } catch (InterruptedException e) {}\n+    }\n }", "timestamp": 1063855708, "metainfo": ""}