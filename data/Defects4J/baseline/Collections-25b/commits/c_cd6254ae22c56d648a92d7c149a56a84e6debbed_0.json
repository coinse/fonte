{"sha": "cd6254ae22c56d648a92d7c149a56a84e6debbed", "log": "fixed line feed problem over whole file   ", "commit": "\n--- a/src/java/org/apache/commons/collections/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/LRUMap.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/LRUMap.java,v 1.10 2002/02/20 18:05:07 morgand Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/02/20 18:05:07 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n-package org.apache.commons.collections;\n-\n-import java.io.Externalizable;\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutput;\n-import java.io.ObjectOutputStream;\n-import java.util.Iterator;\n-\n-/** <p>\n-  * An implementation of a Map which has a maximum size and uses a Least Recently Used\n-  * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n-  * </p>\n-  *\n-  * <p>\n-  * A synchronized version can be obtained with:\n-  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n-  * If it will be accessed by multiple threads, you _must_ synchronize access \n-  * to this Map.  Even concurrent get(Object) operations produce indeterminate\n-  * behaviour.\n-  * </p>\n-  *\n-  * <p>\n-  * Unlike that Collections 1.0 version, this version of LRUMap does use a true\n-  * LRU algorithm.  The keys for all gets and puts are moved to the front of\n-  * the list.  LRUMap is now a subclass of SequencedHashMap, and the \"LRU\"\n-  * key is now equivalent to LRUMap.getFirst().\n-  * </p>\n-  * \n-  * \n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n-  */\n-public class LRUMap extends SequencedHashMap implements Externalizable {\n-        \n-    private int maximumSize = 0;\n-\n-    /**\n-     * Default constructor, primarily for the purpose of\n-     * de-externalization.  This constructors sets a default\n-     * LRU limit of 100 keys, but this value may be overridden\n-     * internally as a result of de-externalization.\n-     */\n-    public LRUMap() {\n-        this( 100 );\n-    }\n-\n-    /**\n-     * Create a new LRUMap with a maximum capacity of <i>i</i>.\n-     * Once <i>i</i> capacity is achieved, subsequent gets\n-     * and puts will push keys out of the map.  See .\n-     * \n-     * @param i      Maximum capacity of the LRUMap\n-     */\n-    public LRUMap(int i) {\n-        super( i );\n-        maximumSize = i;\n-    }\n-\n-     /**\n-      * <p>Removes the key and its Object from the Map.</p>\n-      * \n-      * <p>(Note: this may result in the \"Least Recently Used\"\n-      * object being removed from the Map.  In that case,\n-      * the removeLRU() method is called.  See javadoc for\n-      * removeLRU() for more details.)</p>\n-      * \n-      * @param key    Key of the Object to add.\n-      * @param value  Object to add\n-      * @return Former value of the key\n-      * @see removeLRU()\n-      */    \n-    public Object put( Object key, Object value ) {\n-\n-        int mapSize = size();\n-        Object retval = null;\n-\n-        if ( mapSize >= maximumSize ) {\n-\n-            // don't retire LRU if you are just\n-            // updating an existing key\n-            if (!containsKey(key)) {\n-                // lets retire the least recently used item in the cache\n-                removeLRU();\n-            }\n-        }\n-\n-        retval = super.put(key,value);\n-\n-        return retval;\n-    }\n-\n-    /**\n-     * This method is used internally by the class for \n-     * finding and removing the LRU Object.\n-     */\n-    protected void removeLRU() {\n-        Object key = getFirstKey();\n-        Object value = get(key);\n-        \n-        remove(key);\n-\n-        processRemovedLRU(key,value);\n-    }\n-\n-    /**\n-     * Subclasses of LRUMap may hook into this method to\n-     * provide specialized actions whenever an Object is\n-     * automatically removed from the cache.  By default,\n-     * this method does nothing.\n-     * \n-     * @param key    key that was removed\n-     * @param value  value of that key (can be null)\n-     */\n-    protected void processRemovedLRU(Object key, Object value) {\n-    }\n- \n-    // Externalizable interface\n-    //-------------------------------------------------------------------------        \n-    public void readExternal( ObjectInput in )  throws IOException, ClassNotFoundException {\n-        maximumSize = in.readInt();\n-        int size = in.readInt();\n-        \n-        for( int i = 0; i < size; i++ )  {\n-            Object key = in.readObject();\n-            Object value = in.readObject();\n-            put(key,value);\n-        }\n-    }\n-\n-    public void writeExternal( ObjectOutput out ) throws IOException {\n-        out.writeInt( maximumSize );\n-        out.writeInt( size() );\n-        for( Iterator iterator = keySet().iterator(); iterator.hasNext(); ) {\n-            Object key = iterator.next();\n-            out.writeObject( key );\n-            Object value = get( key );\n-            out.writeObject( value );\n-        }\n-    }\n-    \n-    \n-    // Properties\n-    //-------------------------------------------------------------------------        \n-    /** Getter for property maximumSize.\n-     * @return Value of property maximumSize.\n-     */\n-    public int getMaximumSize() {\n-        return maximumSize;\n-    }\n-    /** Setter for property maximumSize.\n-     * @param maximumSize New value of property maximumSize.\n-     */\n-    public void setMaximumSize(int maximumSize) {\n-        this.maximumSize = maximumSize;\n-        while (size() > maximumSize) {\n-            removeLRU();\n-        }\n-    }\n-        \n-}\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/LRUMap.java,v 1.11 2002/02/20 18:30:36 morgand Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/02/20 18:30:36 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutput;\n+import java.io.ObjectOutputStream;\n+import java.util.Iterator;\n+\n+/** <p>\n+  * An implementation of a Map which has a maximum size and uses a Least Recently Used\n+  * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n+  * </p>\n+  *\n+  * <p>\n+  * A synchronized version can be obtained with:\n+  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n+  * If it will be accessed by multiple threads, you _must_ synchronize access \n+  * to this Map.  Even concurrent get(Object) operations produce indeterminate\n+  * behaviour.\n+  * </p>\n+  *\n+  * <p>\n+  * Unlike that Collections 1.0 version, this version of LRUMap does use a true\n+  * LRU algorithm.  The keys for all gets and puts are moved to the front of\n+  * the list.  LRUMap is now a subclass of SequencedHashMap, and the \"LRU\"\n+  * key is now equivalent to LRUMap.getFirst().\n+  * </p>\n+  * \n+  * \n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n+  */\n+public class LRUMap extends SequencedHashMap implements Externalizable {\n+        \n+    private int maximumSize = 0;\n+\n+    /**\n+     * Default constructor, primarily for the purpose of\n+     * de-externalization.  This constructors sets a default\n+     * LRU limit of 100 keys, but this value may be overridden\n+     * internally as a result of de-externalization.\n+     */\n+    public LRUMap() {\n+        this( 100 );\n+    }\n+\n+    /**\n+     * Create a new LRUMap with a maximum capacity of <i>i</i>.\n+     * Once <i>i</i> capacity is achieved, subsequent gets\n+     * and puts will push keys out of the map.  See .\n+     * \n+     * @param i      Maximum capacity of the LRUMap\n+     */\n+    public LRUMap(int i) {\n+        super( i );\n+        maximumSize = i;\n+    }\n+\n+     /**\n+      * <p>Removes the key and its Object from the Map.</p>\n+      * \n+      * <p>(Note: this may result in the \"Least Recently Used\"\n+      * object being removed from the Map.  In that case,\n+      * the removeLRU() method is called.  See javadoc for\n+      * removeLRU() for more details.)</p>\n+      * \n+      * @param key    Key of the Object to add.\n+      * @param value  Object to add\n+      * @return Former value of the key\n+      * @see removeLRU()\n+      */    \n+    public Object put( Object key, Object value ) {\n+\n+        int mapSize = size();\n+        Object retval = null;\n+\n+        if ( mapSize >= maximumSize ) {\n+\n+            // don't retire LRU if you are just\n+            // updating an existing key\n+            if (!containsKey(key)) {\n+                // lets retire the least recently used item in the cache\n+                removeLRU();\n+            }\n+        }\n+\n+        retval = super.put(key,value);\n+\n+        return retval;\n+    }\n+\n+    /**\n+     * This method is used internally by the class for \n+     * finding and removing the LRU Object.\n+     */\n+    protected void removeLRU() {\n+        Object key = getFirstKey();\n+        Object value = get(key);\n+        \n+        remove(key);\n+\n+        processRemovedLRU(key,value);\n+    }\n+\n+    /**\n+     * Subclasses of LRUMap may hook into this method to\n+     * provide specialized actions whenever an Object is\n+     * automatically removed from the cache.  By default,\n+     * this method does nothing.\n+     * \n+     * @param key    key that was removed\n+     * @param value  value of that key (can be null)\n+     */\n+    protected void processRemovedLRU(Object key, Object value) {\n+    }\n+ \n+    // Externalizable interface\n+    //-------------------------------------------------------------------------        \n+    public void readExternal( ObjectInput in )  throws IOException, ClassNotFoundException {\n+        maximumSize = in.readInt();\n+        int size = in.readInt();\n+        \n+        for( int i = 0; i < size; i++ )  {\n+            Object key = in.readObject();\n+            Object value = in.readObject();\n+            put(key,value);\n+        }\n+    }\n+\n+    public void writeExternal( ObjectOutput out ) throws IOException {\n+        out.writeInt( maximumSize );\n+        out.writeInt( size() );\n+        for( Iterator iterator = keySet().iterator(); iterator.hasNext(); ) {\n+            Object key = iterator.next();\n+            out.writeObject( key );\n+            Object value = get( key );\n+            out.writeObject( value );\n+        }\n+    }\n+    \n+    \n+    // Properties\n+    //-------------------------------------------------------------------------        \n+    /** Getter for property maximumSize.\n+     * @return Value of property maximumSize.\n+     */\n+    public int getMaximumSize() {\n+        return maximumSize;\n+    }\n+    /** Setter for property maximumSize.\n+     * @param maximumSize New value of property maximumSize.\n+     */\n+    public void setMaximumSize(int maximumSize) {\n+        this.maximumSize = maximumSize;\n+        while (size() > maximumSize) {\n+            removeLRU();\n+        }\n+    }\n+        \n+}", "timestamp": 1014229836, "metainfo": ""}