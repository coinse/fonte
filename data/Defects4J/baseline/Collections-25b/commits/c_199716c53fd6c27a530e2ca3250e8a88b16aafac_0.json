{"sha": "199716c53fd6c27a530e2ca3250e8a88b16aafac", "log": "Bug fix where Map/BidiMap implementations only checked key and not value in entrySet contains(Object) and remove(Object)   ", "commit": "\n--- a/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n  * @see DualHashBidiMap\n  * @see DualTreeBidiMap\n  * @since Commons Collections 3.0\n- * @version $Id: AbstractDualBidiMap.java,v 1.10 2004/02/18 00:57:39 scolebourne Exp $\n+ * @version $Id: AbstractDualBidiMap.java,v 1.11 2004/04/01 22:18:12 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n                 return false;\n             }\n             Map.Entry entry = (Map.Entry) obj;\n-            if (parent.containsKey(entry.getKey())) {\n-                Object value = parent.maps[0].remove(entry.getKey());\n-                parent.maps[1].remove(value);\n-                return true;\n+            Object key = entry.getKey();\n+            if (parent.containsKey(key)) {\n+                Object value = parent.maps[0].get(key);\n+                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n+                    parent.maps[0].remove(key);\n+                    parent.maps[1].remove(value);\n+                    return true;\n+                }\n             }\n             return false;\n         }\n--- a/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n  * need for unusual subclasses is here.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.13 $ $Date: 2004/03/13 15:54:34 $\n+ * @version $Revision: 1.14 $ $Date: 2004/04/01 22:18:12 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n     }\n     \n     /**\n-     * Compares two keys for equals.\n-     * This implementation uses the equals method.\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * This implementation uses the equals method and assumes neither key is null.\n      * Subclasses can override this to match differently.\n      * \n-     * @param key1  the first key to compare\n-     * @param key2  the second key to compare\n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n      * @return true if equal\n      */\n     protected boolean isEqualKey(Object key1, Object key2) {\n     }\n     \n     /**\n-     * Compares two values for equals.\n-     * This implementation uses the equals method.\n+     * Compares two values, in external form, to see if they are equal.\n+     * This implementation uses the equals method and assumes neither key is null.\n      * Subclasses can override this to match differently.\n      * \n-     * @param value1  the first value to compare\n-     * @param value2  the second value to compare\n+     * @param value1  the first value to compare passed in from outside\n+     * @param value2  the second value extracted from the entry via <code>getValue()</code>\n      * @return true if equal\n      */\n     protected boolean isEqualValue(Object value1, Object value2) {\n     /**\n      * Gets the entrySet view of the map.\n      * Changes made to the view affect this map.\n-     * The Map Entry is not an independent object and changes as the \n-     * iterator progresses.\n      * To simply iterate through the entries, use {@link #mapIterator()}.\n      * \n      * @return the entrySet view\n         \n         public boolean contains(Object entry) {\n             if (entry instanceof Map.Entry) {\n-                return parent.containsKey(((Map.Entry) entry).getKey());\n+                Map.Entry e = (Map.Entry) entry;\n+                Entry match = parent.getEntry(e.getKey());\n+                return (match != null && match.equals(e));\n             }\n             return false;\n         }\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n+            if (contains(obj) == false) {\n+                return false;\n+            }\n             Map.Entry entry = (Map.Entry) obj;\n             Object key = entry.getKey();\n-            boolean result = parent.containsKey(key);\n             parent.remove(key);\n-            return result;\n+            return true;\n         }\n \n         public Iterator iterator() {\n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n- * Decorates a <code>Map</code> to ensure that the order of addition is retained.\n+ * Decorates a <code>Map</code> to ensure that the order of addition is retained\n+ * using a <code>List</code> to maintain order.\n  * <p>\n  * The order will be used via the iterators and toArray methods on the views.\n  * The order is also returned by the <code>MapIterator</code>.\n  * original position in the iteration.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.12 $ $Date: 2004/02/18 01:13:19 $\n+ * @version $Revision: 1.13 $ $Date: 2004/04/01 22:18:12 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Object key = ((Map.Entry) obj).getKey();\n-            if (parent.getMap().containsKey(key) == false) {\n-                return false;\n-            }\n-            parent.remove(key);\n-            return true;\n+            if (getEntrySet().contains(obj)) {\n+                Object key = ((Map.Entry) obj).getKey();\n+                parent.remove(key);\n+                return true;\n+            }\n+            return false;\n         }\n \n         public void clear() {\n--- a/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n+++ b/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n import org.apache.commons.collections.AbstractTestObject;\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n import org.apache.commons.collections.set.AbstractTestSet;\n \n /**\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  * @author Stephen Colebourne\n- * @version $Revision: 1.8 $ $Date: 2004/02/18 01:20:37 $\n+ * @version $Revision: 1.9 $ $Date: 2004/04/01 22:18:12 $\n  */\n public abstract class AbstractTestMap extends AbstractTestObject {\n \n         map.clear();\n         assertTrue(map.size() == 0);\n         assertTrue(entrySet.size() == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testEntrySetContains1() {\n+        resetFull();\n+        Set entrySet = map.entrySet();\n+        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        assertEquals(true, entrySet.contains(entry));\n+    }\n+    public void testEntrySetContains2() {\n+        resetFull();\n+        Set entrySet = map.entrySet();\n+        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        Map.Entry test = new DefaultMapEntry(entry);\n+        assertEquals(true, entrySet.contains(test));\n+    }\n+    public void testEntrySetContains3() {\n+        resetFull();\n+        Set entrySet = map.entrySet();\n+        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        Map.Entry test = new DefaultMapEntry(entry.getKey(), \"A VERY DIFFERENT VALUE\");\n+        assertEquals(false, entrySet.contains(test));\n+    }\n+    \n+    public void testEntrySetRemove1() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = map.size();\n+        Set entrySet = map.entrySet();\n+        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        Object key = entry.getKey();\n+        \n+        assertEquals(true, entrySet.remove(entry));\n+        assertEquals(false, map.containsKey(key));\n+        assertEquals(size - 1, map.size());\n+    }            \n+    public void testEntrySetRemove2() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = map.size();\n+        Set entrySet = map.entrySet();\n+        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        Object key = entry.getKey();\n+        Map.Entry test = new DefaultMapEntry(entry);\n+        \n+        assertEquals(true, entrySet.remove(test));\n+        assertEquals(false, map.containsKey(key));\n+        assertEquals(size - 1, map.size());\n+    }\n+    public void testEntrySetRemove3() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = map.size();\n+        Set entrySet = map.entrySet();\n+        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n+        Object key = entry.getKey();\n+        Map.Entry test = new DefaultMapEntry(entry.getKey(), \"A VERY DIFFERENT VALUE\");\n+        \n+        assertEquals(false, entrySet.remove(test));\n+        assertEquals(true, map.containsKey(key));\n+        assertEquals(size, map.size());\n     }\n     \n     //-----------------------------------------------------------------------", "timestamp": 1080857892, "metainfo": ""}