{"sha": "486a169f5ecbf89b7f4106401f124096e90f9281", "log": "Add AbstractInputCheckedMapDecorator   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.reflect.Array;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n+import org.apache.commons.collections.set.AbstractSetDecorator;\n+\n+/**\n+ * An abstract base class that simplifies the task of creating map decorators.\n+ * <p>\n+ * The Map API is very difficult to decorate correctly, and involves implementing\n+ * lots of different classes. This class exists to provide a simpler API.\n+ * <p>\n+ * Special hook methods are provided that are called when objects are added to\n+ * the map. By overriding these methods, the input can be validated or manipulated.\n+ * In addition to the main map methods, the entrySet is also affected, which is\n+ * the hardest part of writing map implementations.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/05/03 21:48:49 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class AbstractInputCheckedMapDecorator\n+        extends AbstractMapDecorator {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractInputCheckedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected AbstractInputCheckedMapDecorator(Map map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Hook method called when a key is being added to the map using\n+     * <code>put</code> or <code>putAll</code>.\n+     * <p>\n+     * An implementation may validate the key and throw an exception\n+     * or it may transform the key into another object.\n+     * The key may already exist in the map.\n+     * <p>\n+     * This implementation returns the input key.\n+     * \n+     * @param key  the key to check\n+     * @throws UnsupportedOperationException if the map may not be changed by put/putAll\n+     * @throws IllegalArgumentException if the specified key is invalid\n+     * @throws ClassCastException if the class of the specified key is invalid\n+     * @throws NullPointerException if the specified key is null and nulls are invalid\n+     */\n+    protected Object checkPutKey(Object key) {\n+        return key;\n+    }\n+\n+    /**\n+     * Hook method called when a new value is being added to the map using\n+     * <code>put</code> or <code>putAll</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map may not be changed by put/putAll\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkPutValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called when a value is being set using <code>setValue</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map may not be changed by setValue\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkSetValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called to determine if <code>checkSetValue</code> has any effect.\n+     * <p>\n+     * An implementation should return false if the <code>checkSetValue</code> method\n+     * has no effect as this optimises the implementation.\n+     * <p>\n+     * This implementation returns <code>true</code>.\n+     * \n+     * @param value  the value to check\n+     */\n+    protected boolean isSetValueChecking() {\n+        return true;\n+    }\n+\n+    /**\n+     * Checks each element in the specified map, creating a new map.\n+     * <p>\n+     * This method is used by <code>putAll</code> to check all the elements\n+     * before adding them to the map.\n+     * <p>\n+     * This implementation builds a <code>LinkedMap</code> to preserve the order\n+     * of the input map.\n+     * \n+     * @param map  the map to transform\n+     * @throws the transformed object\n+     */\n+    protected Map checkMap(Map map) {\n+        Map result = new LinkedMap(map.size());\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            result.put(checkPutKey(entry.getKey()), checkPutValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Object put(Object key, Object value) {\n+        key = checkPutKey(key);\n+        value = checkPutValue(value);\n+        return getMap().put(key, value);\n+    }\n+\n+    public void putAll(Map mapToCopy) {\n+        if (mapToCopy.size() == 0) {\n+            return;\n+        } else {\n+            mapToCopy = checkMap(mapToCopy);\n+            getMap().putAll(mapToCopy);\n+        }\n+    }\n+\n+    public Set entrySet() {\n+        if (isSetValueChecking()) {\n+            return new EntrySet(map.entrySet(), this);\n+        } else {\n+            return map.entrySet();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set that checks additions via setValue.\n+     */\n+    static class EntrySet extends AbstractSetDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator parent;\n+\n+        protected EntrySet(Set set, AbstractInputCheckedMapDecorator parent) {\n+            super(set);\n+            this.parent = parent;\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntrySetIterator(collection.iterator(), parent);\n+        }\n+        \n+        public Object[] toArray() {\n+            Object[] array = collection.toArray();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = new MapEntry((Map.Entry) array[i], parent);\n+            }\n+            return array;\n+        }\n+        \n+        public Object[] toArray(Object array[]) {\n+            Object[] result = array;\n+            if (array.length > 0) {\n+                // we must create a new array to handle multi-threaded situations\n+                // where another thread could access data before we decorate it\n+                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+            }\n+            result = collection.toArray(result);\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MapEntry((Map.Entry) result[i], parent);\n+            }\n+\n+            // check to see if result should be returned straight\n+            if (result.length > array.length) {\n+                return result;\n+            }\n+\n+            // copy back into input array to fulfil the method contract\n+            System.arraycopy(result, 0, array, 0, result.length);\n+            if (array.length > result.length) {\n+                array[result.length] = null;\n+            }\n+            return array;\n+        }\n+    }\n+\n+    /**\n+     * Implementation of an entry set iterator that checks additions via setValue.\n+     */\n+    static class EntrySetIterator extends AbstractIteratorDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator parent;\n+        \n+        protected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+        \n+        public Object next() {\n+            Map.Entry entry = (Map.Entry) iterator.next();\n+            return new MapEntry(entry, parent);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of a map entry that checks additions via setValue.\n+     */\n+    static class MapEntry extends AbstractMapEntryDecorator {\n+\n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator parent;\n+\n+        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) {\n+            super(entry);\n+            this.parent = parent;\n+        }\n+\n+        public Object setValue(Object value) {\n+            value = parent.checkSetValue(value);\n+            return entry.setValue(value);\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/collections/map/PredicatedMap.java\n+++ b/src/java/org/apache/commons/collections/map/PredicatedMap.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n-import java.lang.reflect.Array;\n import java.util.Iterator;\n import java.util.Map;\n-import java.util.Set;\n \n import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n-import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n \n /**\n  * Decorates another <code>Map</code> to validate that additions\n  * This class is Serializable from Commons Collections 3.1.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.9 $ $Date: 2004/04/09 10:36:01 $\n+ * @version $Revision: 1.10 $ $Date: 2004/05/03 21:48:49 $\n  * \n  * @author Stephen Colebourne\n  * @author Paul Jack\n  */\n public class PredicatedMap\n-        extends AbstractMapDecorator\n+        extends AbstractInputCheckedMapDecorator\n         implements Serializable {\n \n     /** Serialization version */\n         }\n     }\n \n+    /**\n+     * Validates a key value pair.\n+     * \n+     * @param key  the key to validate\n+     * @param value  the value to validate\n+     * @throws IllegalArgumentException if invalid\n+     */\n     protected void validate(Object key, Object value) {\n         if (keyPredicate != null && keyPredicate.evaluate(key) == false) {\n             throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n     }\n \n     //-----------------------------------------------------------------------\n+    // The validate method exists for backwards compatability - in an ideal\n+    // world, it wouldn't and the superclass methods checkPutKey/checkPutValue\n+    // would be overridden instead\n+\n+    /**\n+     * Override to validate an object set into the map via <code>setValue</code>.\n+     * \n+     * @param value  the value to validate\n+     * @throws IllegalArgumentException if invalid\n+     */\n+    protected Object checkSetValue(Object value) {\n+        if (valuePredicate.evaluate(value) == false) {\n+            throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Override to only return true when there is a value transformer.\n+     * \n+     * @return true if a value predicate is in use\n+     */\n+    protected boolean isSetValueChecking() {\n+        return (valuePredicate != null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public Object put(Object key, Object value) {\n         validate(key, value);\n         return map.put(key, value);\n         map.putAll(mapToCopy);\n     }\n \n-    public Set entrySet() {\n-        if (valuePredicate == null) {\n-            return map.entrySet();\n-        }\n-        return new PredicatedMapEntrySet(map.entrySet(), valuePredicate);\n-    }\n-\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Implementation of an entry set that checks (predicates) additions.\n-     */\n-    static class PredicatedMapEntrySet extends AbstractCollectionDecorator implements Set {\n-        \n-        /** The predicate to use */\n-        private final Predicate valuePredicate;\n-\n-        protected PredicatedMapEntrySet(Set set, Predicate valuePred) {\n-            super(set);\n-            this.valuePredicate = valuePred;\n-        }\n-\n-        public Iterator iterator() {\n-            return new PredicatedMapEntrySetIterator(collection.iterator(), valuePredicate);\n-        }\n-        \n-        public Object[] toArray() {\n-            Object[] array = collection.toArray();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = new PredicatedMapEntry((Map.Entry) array[i], valuePredicate);\n-            }\n-            return array;\n-        }\n-        \n-        public Object[] toArray(Object array[]) {\n-            Object[] result = array;\n-            if (array.length > 0) {\n-                // we must create a new array to handle multi-threaded situations\n-                // where another thread could access data before we decorate it\n-                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n-            }\n-            result = collection.toArray(result);\n-            for (int i = 0; i < result.length; i++) {\n-                result[i] = new PredicatedMapEntry((Map.Entry) result[i], valuePredicate);\n-            }\n-\n-            // check to see if result should be returned straight\n-            if (result.length > array.length) {\n-                return result;\n-            }\n-\n-            // copy back into input array to fulfil the method contract\n-            System.arraycopy(result, 0, array, 0, result.length);\n-            if (array.length > result.length) {\n-                array[result.length] = null;\n-            }\n-            return array;\n-        }\n-    }\n-\n-    /**\n-     * Implementation of an entry set iterator.\n-     */\n-    static class PredicatedMapEntrySetIterator extends AbstractIteratorDecorator {\n-        \n-        /** The predicate to use */\n-        private final Predicate valuePredicate;\n-        \n-        protected PredicatedMapEntrySetIterator(Iterator iterator, Predicate valuePredicate) {\n-            super(iterator);\n-            this.valuePredicate = valuePredicate;\n-        }\n-        \n-        public Object next() {\n-            Map.Entry entry = (Map.Entry) iterator.next();\n-            return new PredicatedMapEntry(entry, valuePredicate);\n-        }\n-    }\n-\n-    /**\n-     * Implementation of a map entry that checks (predicates) additions.\n-     */\n-    static class PredicatedMapEntry extends AbstractMapEntryDecorator {\n-\n-        /** The predicate to use */\n-        private final Predicate predicate;\n-\n-        protected PredicatedMapEntry(Map.Entry entry, Predicate valuePredicate) {\n-            super(entry);\n-            this.predicate = valuePredicate;\n-        }\n-\n-        public Object setValue(Object obj) {\n-            if (predicate != null && predicate.evaluate(obj) == false) {\n-                throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n-            }\n-            return entry.setValue(obj);\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/collections/map/TransformedMap.java\n+++ b/src/java/org/apache/commons/collections/map/TransformedMap.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n-import java.lang.reflect.Array;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n-import java.util.Set;\n \n import org.apache.commons.collections.Transformer;\n-import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n-import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n \n /**\n  * Decorates another <code>Map</code> to transform objects that are added.\n  * This class is Serializable from Commons Collections 3.1.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.8 $ $Date: 2004/04/09 10:36:01 $\n+ * @version $Revision: 1.9 $ $Date: 2004/05/03 21:48:49 $\n  * \n  * @author Stephen Colebourne\n  */\n public class TransformedMap\n-        extends AbstractMapDecorator\n+        extends AbstractInputCheckedMapDecorator\n         implements Serializable {\n \n     /** Serialization version */\n     }\n \n     //-----------------------------------------------------------------------\n+    // The transformKey/transformValue/transformMap methods exist for backwards\n+    // compatability - in an ideal world, they wouldn't and the superclass\n+    // methods checkPutKey/checkPutValue would be overridden instead\n+\n     /**\n      * Transforms a key.\n      * <p>\n      * @throws the transformed object\n      */\n     protected Map transformMap(Map map) {\n-        Map result = new HashMap(map.size());\n+        Map result = new LinkedMap(map.size());\n         for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n             Map.Entry entry = (Map.Entry) it.next();\n             result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n         }\n         return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     * \n+     * @param value  the value to transform\n+     * @return the transformed value\n+     */\n+    protected Object checkSetValue(Object value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    /**\n+     * Override to only return true when there is a value transformer.\n+     * \n+     * @return true if a value transformer is in use\n+     */\n+    protected boolean isSetValueChecking() {\n+        return (valueTransformer != null);\n     }\n \n     //-----------------------------------------------------------------------\n         getMap().putAll(mapToCopy);\n     }\n \n-    public Set entrySet() {\n-        if (valueTransformer == null) {\n-            return map.entrySet();\n-        }\n-        return new TransformedMapEntrySet(map.entrySet(), valueTransformer);\n-    }\n-\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Implementation of an entry set that uses a transforming map entry.\n-     */\n-    static class TransformedMapEntrySet extends AbstractCollectionDecorator implements Set {\n-        \n-        /** The transformer to use */\n-        private final Transformer valueTransformer;\n-\n-        protected TransformedMapEntrySet(Set set, Transformer valueTransformer) {\n-            super(set);\n-            this.valueTransformer = valueTransformer;\n-        }\n-\n-        public Iterator iterator() {\n-            return new TransformedMapEntrySetIterator(collection.iterator(), valueTransformer);\n-        }\n-        \n-        public Object[] toArray() {\n-            Object[] array = collection.toArray();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = new TransformedMapEntry((Map.Entry) array[i], valueTransformer);\n-            }\n-            return array;\n-        }\n-        \n-        public Object[] toArray(Object array[]) {\n-            Object[] result = array;\n-            if (array.length > 0) {\n-                // we must create a new array to handle multi-threaded situations\n-                // where another thread could access data before we decorate it\n-                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n-            }\n-            result = collection.toArray(result);\n-            for (int i = 0; i < result.length; i++) {\n-                result[i] = new TransformedMapEntry((Map.Entry) result[i], valueTransformer);\n-            }\n-\n-            // check to see if result should be returned straight\n-            if (result.length > array.length) {\n-                return result;\n-            }\n-\n-            // copy back into input array to fulfil the method contract\n-            System.arraycopy(result, 0, array, 0, result.length);\n-            if (array.length > result.length) {\n-                array[result.length] = null;\n-            }\n-            return array;\n-        }\n-    }\n-\n-    /**\n-     * Implementation of an entry set iterator.\n-     */\n-    static class TransformedMapEntrySetIterator extends AbstractIteratorDecorator {\n-        \n-        /** The transformer to use */\n-        private final Transformer valueTransformer;\n-        \n-        protected TransformedMapEntrySetIterator(Iterator iterator, Transformer valueTransformer) {\n-            super(iterator);\n-            this.valueTransformer = valueTransformer;\n-        }\n-        \n-        public Object next() {\n-            Map.Entry entry = (Map.Entry) iterator.next();\n-            return new TransformedMapEntry(entry, valueTransformer);\n-        }\n-    }\n-\n-    /**\n-     * Implementation of a map entry that transforms additions.\n-     */\n-    static class TransformedMapEntry extends AbstractMapEntryDecorator {\n-\n-        /** The transformer to use */\n-        private final Transformer valueTransformer;\n-\n-        protected TransformedMapEntry(Map.Entry entry, Transformer valueTransformer) {\n-            super(entry);\n-            this.valueTransformer = valueTransformer;\n-        }\n-\n-        public Object setValue(Object object) {\n-            if (valueTransformer != null) {\n-                object = valueTransformer.transform(object);\n-            }\n-            return entry.setValue(object);\n-        }\n-    }\n-\n }", "timestamp": 1083620929, "metainfo": ""}