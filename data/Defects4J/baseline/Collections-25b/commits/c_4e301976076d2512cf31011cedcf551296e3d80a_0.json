{"sha": "4e301976076d2512cf31011cedcf551296e3d80a", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r471580 | scolebourne | 2006-11-05 16:22:53 -0800 (Sun, 05 Nov 2006) | 1 line          Generify CompositeCollection     ------------------------------------------------------------------------     r471203 | scolebourne | 2006-11-04 06:28:02 -0800 (Sat, 04 Nov 2006) | 1 line          Whitespace change     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/collection/CompositeCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/CompositeCollection.java\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n+import java.util.List;\n \n import org.apache.commons.collections.iterators.EmptyIterator;\n import org.apache.commons.collections.iterators.IteratorChain;\n  * Decorates a collection of other collections to provide a single unified view.\n  * <p>\n  * Changes made to this collection will actually be made on the decorated collection.\n- * Add and remove operations require the use of a pluggable strategy. If no \n+ * Add and remove operations require the use of a pluggable strategy. If no\n  * strategy is provided then add and remove are unsupported.\n  *\n+ * @param <E> the type of the elements in the collection\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  * @author Phil Steitz\n  */\n-public class CompositeCollection implements Collection, Serializable {\n-    \n+public class CompositeCollection<E> implements Collection<E>, Serializable {\n+\n     /** CollectionMutator to handle changes to the collection */\n-    protected CollectionMutator mutator;\n-    \n+    protected CollectionMutator<E> mutator;\n+\n     /** Collections in the composite */\n-    protected Collection[] all;\n-    \n+    protected List<Collection<E>> all = new ArrayList<Collection<E>>();\n+\n     /**\n      * Create an empty CompositeCollection.\n      */\n     public CompositeCollection() {\n         super();\n-        this.all = new Collection[0];\n-    }\n-    \n-    /**\n-     * Create a Composite Collection with only coll composited.\n-     * \n-     * @param coll  a collection to decorate\n-     */\n-    public CompositeCollection(Collection coll) {\n-        this();\n-        this.addComposited(coll);\n-    }\n-    \n-    /**\n-     * Create a CompositeCollection with colls as the initial list of\n-     * composited collections.\n-     * \n-     * @param colls  an array of collections to decorate\n-     */\n-    public CompositeCollection(Collection[] colls) {\n-        this();\n-        this.addComposited(colls);\n-    }\n-    \n+    }\n+\n+    /**\n+     * Create a Composite Collection with one collection.\n+     *\n+     * @param compositeCollection  the Collection to be appended to the composite\n+     */\n+    public CompositeCollection(Collection<E> compositeCollection) {\n+        super();\n+        addComposited(compositeCollection);\n+    }\n+\n+    /**\n+     * Create a Composite Collection with two collections.\n+     *\n+     * @param compositeCollection1  the Collection to be appended to the composite\n+     * @param compositeCollection2  the Collection to be appended to the composite\n+     */\n+    public CompositeCollection(Collection<E> compositeCollection1, Collection<E> compositeCollection2) {\n+        super();\n+        addComposited(compositeCollection1, compositeCollection2);\n+    }\n+\n+    /**\n+     * Create a Composite Collection with an array of collections.\n+     *\n+     * @param compositeCollections  the collections to composite\n+     */\n+    public CompositeCollection(Collection<E>[] compositeCollections) {\n+        super();\n+        addComposited(compositeCollections);\n+    }\n+\n+//    /**\n+//     * Create a Composite Collection extracting the collections from an iterable.\n+//     *\n+//     * @param compositeCollections  the collections to composite\n+//     */\n+//    public CompositeCollection(Iterable<Collection<E>> compositeCollections) {\n+//        super();\n+//        addComposited(compositeCollections);\n+//    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the size of this composite collection.\n      */\n     public int size() {\n         int size = 0;\n-        for (int i = this.all.length - 1; i >= 0; i--) {\n-            size += this.all[i].size();\n+        for (Collection<E> item : all) {\n+            size += item.size();\n         }\n         return size;\n     }\n-    \n+\n     /**\n      * Checks whether this composite collection is empty.\n      * <p>\n      * @return true if all of the contained collections are empty\n      */\n     public boolean isEmpty() {\n-        for (int i = this.all.length - 1; i >= 0; i--) {\n-            if (this.all[i].isEmpty() == false) {\n+        for (Collection<? extends E> item : all) {\n+            if (item.isEmpty() == false) {\n                 return false;\n             }\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Checks whether this composite collection contains the object.\n      * <p>\n      * @return true if obj is contained in any of the contained collections\n      */\n     public boolean contains(Object obj) {\n-        for (int i = this.all.length - 1; i >= 0; i--) {\n-            if (this.all[i].contains(obj)) {\n+        for (Collection<? extends E> item : all) {\n+            if (item.contains(obj)) {\n                 return true;\n             }\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Gets an iterator over all the collections in this composite.\n      * <p>\n      *  the order they were added, but this behavior should not be relied upon.\n      * @see IteratorChain\n      */\n-    public Iterator iterator() {\n-        if (this.all.length == 0) {\n-            return EmptyIterator.INSTANCE;\n-        }\n-        IteratorChain chain = new IteratorChain();\n-        for (int i = 0; i < this.all.length; ++i) {\n-            chain.addIterator(this.all[i].iterator());\n+    public Iterator<E> iterator() {\n+        if (all.isEmpty()) {\n+            return EmptyIterator.<E>getInstance();\n+        }\n+        IteratorChain<E> chain = new IteratorChain<E>();\n+        for (Collection<? extends E> item : all) {\n+            chain.addIterator(item.iterator());\n         }\n         return chain;\n     }\n-    \n+\n     /**\n      * Returns an array containing all of the elements in this composite.\n      *\n      * @return an object array of all the elements in the collection\n      */\n     public Object[] toArray() {\n-        final Object[] result = new Object[this.size()];\n+        final Object[] result = new Object[size()];\n         int i = 0;\n-        for (Iterator it = this.iterator(); it.hasNext(); i++) {\n+        for (Iterator<E> it = iterator(); it.hasNext(); i++) {\n             result[i] = it.next();\n         }\n         return result;\n     }\n-    \n+\n     /**\n      * Returns an object array, populating the supplied array if possible.\n      * See <code>Collection</code> interface for full details.\n      * @param array  the array to use, populating if possible\n      * @return an array of all the elements in the collection\n      */\n-    public Object[] toArray(Object[] array) {\n-        int size = this.size();\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        int size = size();\n         Object[] result = null;\n         if (array.length >= size) {\n             result = array;\n-        }\n-        else {\n+        } else {\n             result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n         }\n-        \n+\n         int offset = 0;\n-        for (int i = 0; i < this.all.length; ++i) {\n-            for (Iterator it = this.all[i].iterator(); it.hasNext();) {\n-                result[offset++] = it.next();\n+        for (Collection<? extends E> item : all) {\n+            for (E e : item) {\n+                result[offset++] = e;\n             }\n         }\n         if (result.length > size) {\n             result[size] = null;\n         }\n-        return result;\n-    }\n-    \n+        return (T[]) result;\n+    }\n+\n     /**\n      * Adds an object to the collection, throwing UnsupportedOperationException\n      * unless a CollectionMutator strategy is specified.\n      * @throws NullPointerException if the object cannot be added because its null\n      * @throws IllegalArgumentException if the object cannot be added\n      */\n-    public boolean add(Object obj) {\n-        if (this.mutator == null) {\n+    public boolean add(E obj) {\n+        if (mutator == null) {\n            throw new UnsupportedOperationException(\n-           \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n-        }\n-        return this.mutator.add(this, this.all, obj);\n-    }\n-    \n+               \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.add(this, all, obj);\n+    }\n+\n     /**\n      * Removes an object from the collection, throwing UnsupportedOperationException\n      * unless a CollectionMutator strategy is specified.\n      * @throws IllegalArgumentException if the object cannot be removed\n      */\n     public boolean remove(Object obj) {\n-        if (this.mutator == null) {\n+        if (mutator == null) {\n             throw new UnsupportedOperationException(\n-            \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n-        }\n-        return this.mutator.remove(this, this.all, obj);\n-    }\n-    \n+                \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.remove(this, all, obj);\n+    }\n+\n     /**\n      * Checks whether this composite contains all the elements in the specified collection.\n      * <p>\n      * @param coll  the collection to check for\n      * @return true if all elements contained\n      */\n-    public boolean containsAll(Collection coll) {\n-        for (Iterator it = coll.iterator(); it.hasNext();) {\n-            if (this.contains(it.next()) == false) {\n+    public boolean containsAll(Collection<?> coll) {\n+        for (Object item : coll) {\n+            if (contains(item) == false) {\n                 return false;\n             }\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Adds a collection of elements to this collection, throwing\n      * UnsupportedOperationException unless a CollectionMutator strategy is specified.\n      * @throws NullPointerException if the object cannot be added because its null\n      * @throws IllegalArgumentException if the object cannot be added\n      */\n-    public boolean addAll(Collection coll) {\n-        if (this.mutator == null) {\n+    public boolean addAll(Collection<? extends E> coll) {\n+        if (mutator == null) {\n             throw new UnsupportedOperationException(\n-            \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n-        }\n-        return this.mutator.addAll(this, this.all, coll);\n-    }\n-    \n+                \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.addAll(this, all, coll);\n+    }\n+\n     /**\n      * Removes the elements in the specified collection from this composite collection.\n      * <p>\n      * @return true if the collection was modified\n      * @throws UnsupportedOperationException if removeAll is unsupported\n      */\n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         if (coll.size() == 0) {\n             return false;\n         }\n         boolean changed = false;\n-        for (int i = this.all.length - 1; i >= 0; i--) {\n-            changed = (this.all[i].removeAll(coll) || changed);\n+        for (Collection<? extends E> item : all) {\n+            changed |= item.removeAll(coll);\n         }\n         return changed;\n     }\n-    \n+\n     /**\n      * Retains all the elements in the specified collection in this composite collection,\n      * removing all others.\n      * @return true if the collection was modified\n      * @throws UnsupportedOperationException if retainAll is unsupported\n      */\n-    public boolean retainAll(final Collection coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         boolean changed = false;\n-        for (int i = this.all.length - 1; i >= 0; i--) {\n-            changed = (this.all[i].retainAll(coll) || changed);\n+        for (Collection<? extends E> item : all) {\n+            changed |= item.retainAll(coll);\n         }\n         return changed;\n     }\n-    \n+\n     /**\n      * Removes all of the elements from this collection .\n      * <p>\n      * @throws UnsupportedOperationException if clear is unsupported\n      */\n     public void clear() {\n-        for (int i = 0; i < this.all.length; ++i) {\n-            this.all[i].clear();\n-        }\n-    }\n-    \n+        for (Collection<? extends E> coll : all) {\n+            coll.clear();\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Specify a CollectionMutator strategy instance to handle changes.\n      *\n      * @param mutator  the mutator to use\n      */\n-    public void setMutator(CollectionMutator mutator) {\n+    public void setMutator(CollectionMutator<E> mutator) {\n         this.mutator = mutator;\n     }\n-    \n+\n     /**\n      * Add these Collections to the list of collections in this composite\n      *\n-     * @param comps Collections to be appended to the composite\n-     */\n-    public void addComposited(Collection[] comps) {\n-        ArrayList list = new ArrayList(Arrays.asList(this.all));\n-        list.addAll(Arrays.asList(comps));\n-        all = (Collection[]) list.toArray(new Collection[list.size()]);\n-    }\n-    \n-    /**\n-     * Add an additional collection to this composite.\n-     * \n-     * @param c  the collection to add\n-     */\n-    public void addComposited(Collection c) {\n-        this.addComposited(new Collection[]{c});\n-    }\n-    \n-    /**\n-     * Add two additional collections to this composite.\n-     * \n-     * @param c  the first collection to add\n-     * @param d  the second collection to add\n-     */\n-    public void addComposited(Collection c, Collection d) {\n-        this.addComposited(new Collection[]{c, d});\n-    }\n-    \n+     * @param compositeCollection  the Collection to be appended to the composite\n+     */\n+    public void addComposited(Collection<E> compositeCollection) {\n+        all.add(compositeCollection);\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollection1  the Collection to be appended to the composite\n+     * @param compositeCollection2  the Collection to be appended to the composite\n+     */\n+    public void addComposited(Collection<E> compositeCollection1, Collection<E> compositeCollection2) {\n+        all.add(compositeCollection1);\n+        all.add(compositeCollection2);\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollections  the Collections to be appended to the composite\n+     */\n+    public void addComposited(Collection<E>[] compositeCollections) {\n+        all.addAll(Arrays.asList(compositeCollections));\n+    }\n+\n+//    /**\n+//     * Add these Collections to the list of collections in this composite\n+//     *\n+//     * @param compositeCollections  the Collections to be appended to the composite\n+//     */\n+//    public void addComposited(Iterable<Collection<E>> compositeCollections) {\n+//        for (Collection<E> item : compositeCollections) {\n+//            all.add(item);\n+//        }\n+//    }\n+\n     /**\n      * Removes a collection from the those being decorated in this composite.\n      *\n      * @param coll  collection to be removed\n      */\n-    public void removeComposited(Collection coll) {\n-        ArrayList list = new ArrayList(this.all.length);\n-        list.addAll(Arrays.asList(this.all));\n-        list.remove(coll);\n-        this.all = (Collection[]) list.toArray(new Collection[list.size()]);\n-    }\n-    \n+    public void removeComposited(Collection<E> coll) {\n+        all.remove(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a new collection containing all of the elements\n      *\n      * @return A new ArrayList containing all of the elements in this composite.\n      *         The new collection is <i>not</i> backed by this composite.\n      */\n-    public Collection toCollection() {\n-        return new ArrayList(this);\n-    }\n-    \n+    public Collection<E> toCollection() {\n+        return new ArrayList<E>(this);\n+    }\n+\n     /**\n      * Gets the collections being decorated.\n      *\n-     * @return Unmodifiable collection of all collections in this composite.\n-     */\n-    public Collection getCollections() {\n-        return UnmodifiableList.decorate(Arrays.asList(this.all));\n-    }\n-    \n+     * @return Unmodifiable list of all collections in this composite.\n+     */\n+    public List<? extends Collection<E>> getCollections() {\n+        return UnmodifiableList.decorate(all);\n+    }\n+\n+    /**\n+     * Get the collection mutator to be used for this CompositeCollection.\n+     * @return CollectionMutator<E>\n+     */\n+    protected CollectionMutator<E> getMutator() {\n+        return mutator;\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Pluggable strategy to handle changes to the composite.\n-     */\n-    public interface CollectionMutator extends Serializable {\n-        \n+     *\n+     * @param <E> the element being held in the collection\n+     */\n+    public interface CollectionMutator<E> extends Serializable {\n+\n         /**\n          * Called when an object is to be added to the composite.\n          *\n          * @throws NullPointerException if the object cannot be added because its null\n          * @throws IllegalArgumentException if the object cannot be added\n          */\n-        public boolean add(CompositeCollection composite, Collection[] collections, Object obj);\n-        \n+        public boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj);\n+\n         /**\n          * Called when a collection is to be added to the composite.\n          *\n          * @throws NullPointerException if the object cannot be added because its null\n          * @throws IllegalArgumentException if the object cannot be added\n          */\n-        public boolean addAll(CompositeCollection composite, Collection[] collections, Collection coll);\n-        \n+        public boolean addAll(CompositeCollection<E> composite, List<Collection<E>> collections, Collection<? extends E> coll);\n+\n         /**\n          * Called when an object is to be removed to the composite.\n          *\n          * @throws NullPointerException if the object cannot be removed because its null\n          * @throws IllegalArgumentException if the object cannot be removed\n          */\n-        public boolean remove(CompositeCollection composite, Collection[] collections, Object obj);\n-        \n-    }\n-    \n+        public boolean remove(CompositeCollection<E> composite, List<Collection<E>> collections, Object obj);\n+\n+    }\n+\n }\n ", "timestamp": 1252994083, "metainfo": ""}