{"sha": "bd5708f488770404ef82615704ff070011f28a92", "log": "Javadoc and Reformat files   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ExtendedProperties.java,v 1.13 2003/08/24 10:50:58 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ExtendedProperties.java,v 1.14 2003/08/24 11:29:52 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * it, go ahead and tune it up!\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.13 $ $Date: 2003/08/24 10:50:58 $\n+ * @version $Revision: 1.14 $ $Date: 2003/08/24 11:29:52 $\n  * \n  * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n  * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n  * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n  * @author Janek Bogucki\n  * @author Mohan Kishore\n+ * @author Stephen Colebourne\n  */\n public class ExtendedProperties extends Hashtable {\n     \n     protected final static String START_TOKEN=\"${\";\n     protected final static String END_TOKEN=\"}\";\n \n-    protected String interpolate(String base)\n-    {\n-        if (base == null)\n-        {\n+    protected String interpolate(String base) {\n+        if (base == null) {\n             return null;\n-        }                        \n+        }\n         \n         int begin = -1;\n         int end = -1;\n         \n         // FIXME: we should probably allow the escaping of the start token\n         while ( ((begin=base.indexOf(START_TOKEN,prec+END_TOKEN.length()))>-1)\n-                && ((end=base.indexOf(END_TOKEN,begin))>-1) ) \n-        {\n+                && ((end=base.indexOf(END_TOKEN,begin))>-1) ) {\n             result.append(base.substring(prec+END_TOKEN.length(),begin));\n             variable = base.substring(begin+START_TOKEN.length(),end);\n-            if (get(variable)!=null) \n-            {\n+            if (get(variable) != null) {\n                 result.append(get(variable));\n             }\n             prec=end;\n      */\n     private static String escape(String s) {\n         StringBuffer buf = new StringBuffer(s);\n-        for (int i=0; i < buf.length();i++) {\n+        for (int i = 0; i < buf.length(); i++) {\n             char c = buf.charAt(i);\n             if (c == ',' || c == '\\\\') {\n                 buf.insert(i, '\\\\');\n      */\n     private static String unescape(String s) {\n         StringBuffer buf = new StringBuffer(s);\n-        for (int i=0; i < buf.length()-1;i++) {\n+        for (int i = 0; i < buf.length() - 1; i++) {\n             char c1 = buf.charAt(i);\n-            char c2 = buf.charAt(i+1);\n+            char c2 = buf.charAt(i + 1);\n             if (c1 == '\\\\' && c2 == '\\\\') {\n                 buf.deleteCharAt(i);\n             }\n         }\n         return buf.toString();\n     }\n-    \n+\n     /**\n      * Counts the number of successive times 'ch' appears in the\n      * 'line' before the position indicated by the 'index'.\n      */\n     private static int countPreceding(String line, int index, char ch) {\n         int i;\n-        for (i = index-1; i >= 0; i--) {\n-            if (line.charAt(i) != ch) break;\n-        }\n-        return index-1-i;\n-    }\n-    \n+        for (i = index - 1; i >= 0; i--) {\n+            if (line.charAt(i) != ch) {\n+                break;\n+            }\n+        }\n+        return index - 1 - i;\n+    }\n+\n     /**\n      * Checks if the line ends with odd number of backslashes \n      */\n     private static boolean endsWithSlash(String line) {\n-        if (!line.endsWith(\"\\\\\")) return false;\n-\n-        return (countPreceding(line, line.length()-1, '\\\\') % 2 == 0);\n+        if (!line.endsWith(\"\\\\\")) {\n+            return false;\n+        }\n+        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n     }\n \n     /**\n      * backslash sign a the end of the line.  This is used to\n      * concatenate multiple lines for readability.\n      */\n-    static class PropertiesReader extends LineNumberReader\n-    {\n+    static class PropertiesReader extends LineNumberReader {\n         /**\n          * Constructor.\n          *\n          * @param reader A Reader.\n          */\n-        public PropertiesReader(Reader reader)\n-        {\n+        public PropertiesReader(Reader reader) {\n             super(reader);\n         }\n \n          * Read a property.\n          *\n          * @return A String.\n-         * @exception IOException.\n+         * @throws IOException.\n          */\n-        public String readProperty() throws IOException\n-        {\n+        public String readProperty() throws IOException {\n             StringBuffer buffer = new StringBuffer();\n \n-            try\n-            {\n-                while (true)\n-                {\n+            try {\n+                while (true) {\n                     String line = readLine().trim();\n-                    if ((line.length() != 0) && (line.charAt(0) != '#'))\n-                    {\n-                        if (endsWithSlash(line))\n-                        {\n+                    if ((line.length() != 0) && (line.charAt(0) != '#')) {\n+                        if (endsWithSlash(line)) {\n                             line = line.substring(0, line.length() - 1);\n                             buffer.append(line);\n-                        }\n-                        else\n-                        {\n+                        } else {\n                             buffer.append(line);\n                             break;\n                         }\n                     }\n                 }\n-            }\n-            catch (NullPointerException e)\n-            {\n+            } catch (NullPointerException ex) {\n                 return null;\n             }\n \n      * separator is \",\" but commas into the property value are escaped\n      * using the backslash in front.\n      */\n-    static class PropertiesTokenizer extends StringTokenizer\n-    {\n+    static class PropertiesTokenizer extends StringTokenizer {\n         /**\n          * The property delimiter used while parsing (a comma).\n          */\n          *\n          * @param string A String.\n          */\n-        public PropertiesTokenizer(String string)\n-        {\n+        public PropertiesTokenizer(String string) {\n             super(string, DELIMITER);\n         }\n \n          *\n          * @return True if the object has more tokens.\n          */\n-        public boolean hasMoreTokens()\n-        {\n+        public boolean hasMoreTokens() {\n             return super.hasMoreTokens();\n         }\n \n          *\n          * @return A String.\n          */\n-        public String nextToken()\n-        {\n+        public String nextToken() {\n             StringBuffer buffer = new StringBuffer();\n \n-            while (hasMoreTokens())\n-            {\n+            while (hasMoreTokens()) {\n                 String token = super.nextToken();\n-                if (endsWithSlash(token))\n-                {\n+                if (endsWithSlash(token)) {\n                     buffer.append(token.substring(0, token.length() - 1));\n                     buffer.append(DELIMITER);\n-                }\n-                else\n-                {\n+                } else {\n                     buffer.append(token);\n                     break;\n                 }\n     /**\n      * Creates an empty extended properties object.\n      */\n-    public ExtendedProperties()\n-    {\n+    public ExtendedProperties() {\n         super();\n     }\n \n      * Creates and loads the extended properties from the specified\n      * file.\n      *\n-     * @param file A String.\n-     * @exception IOException.\n-     */\n-    public ExtendedProperties(String file) throws IOException\n-    {\n-        this(file,null);\n+     * @param file  the filename to load\n+     * @throws IOException if a file error occurs\n+     */\n+    public ExtendedProperties(String file) throws IOException {\n+        this(file, null);\n     }\n \n     /**\n      * Creates and loads the extended properties from the specified\n      * file.\n      *\n-     * @param file A String.\n-     * @exception IOException.\n-     */\n-    public ExtendedProperties(String file, String defaultFile)\n-        throws IOException\n-    {\n+     * @param file  the filename to load\n+     * @param defaultFile  a second filename to load default values from\n+     * @throws IOException if a file error occurs\n+     */\n+    public ExtendedProperties(String file, String defaultFile) throws IOException {\n         this.file = file;\n-        \n+\n         basePath = new File(file).getAbsolutePath();\n         basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n-        \n+\n         this.load(new FileInputStream(file));\n-        \n-        if (defaultFile != null)\n-        {\n+\n+        if (defaultFile != null) {\n             defaults = new ExtendedProperties(defaultFile);\n-        }            \n+        }\n     }\n \n     /**\n      * Indicate to client code whether property\n      * resources have been initialized or not.\n      */\n-    public boolean isInitialized()\n-    {\n+    public boolean isInitialized() {\n         return isInitialized;\n-    }        \n+    }\n \n     /**\n      * Gets the property value for including other properties files.\n      *\n      * @return A String.\n      */\n-    public String getInclude()\n-    {\n+    public String getInclude() {\n         return include;\n     }\n \n      *\n      * @param inc A String.\n      */\n-    public void setInclude(String inc)\n-    {\n+    public void setInclude(String inc) {\n         include = inc;\n     }\n \n     /**\n      * Load the properties from the given input stream.\n      *\n-     * @param input An InputStream.\n-     * @exception IOException.\n-     */\n-    public void load( InputStream input )\n-        throws IOException\n-    {\n-        load(input,null);\n-    }\n-    \n+     * @param input  the InputStream to load from\n+     * @throws IOException if an IO error occurs\n+     */\n+    public void load(InputStream input) throws IOException {\n+        load(input, null);\n+    }\n+\n     /**\n      * Load the properties from the given input stream\n      * and using the specified encoding.\n      *\n-     * @param input An InputStream.\n-     * @param enc An encoding.\n-     * @exception IOException.\n-     */\n-    public synchronized void load(InputStream input, String enc)\n-        throws IOException\n-    {\n+     * @param input  the InputStream to load from\n+     * @param enc  the encoding to use\n+     * @throws IOException if an IO error occurs\n+     */\n+    public synchronized void load(InputStream input, String enc) throws IOException {\n         PropertiesReader reader = null;\n-        if (enc != null)\n-        {\n-            try\n-            {\n-                reader =\n-                    new PropertiesReader(new InputStreamReader(input,enc));\n-            }\n-            catch (UnsupportedEncodingException e)\n-            {\n+        if (enc != null) {\n+            try {\n+                reader = new PropertiesReader(new InputStreamReader(input, enc));\n+                \n+            } catch (UnsupportedEncodingException ex) {\n                 // Another try coming up....\n             }\n         }\n         \n-        if (reader == null)\n-        {\n-            try \n-            {\n-                reader =\n-                    new PropertiesReader(new InputStreamReader(input,\"8859_1\"));\n-            } \n-            catch (UnsupportedEncodingException e)\n-            {\n+        if (reader == null) {\n+            try {\n+                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n+                \n+            } catch (UnsupportedEncodingException ex) {\n                 // ISO8859-1 support is required on java platforms but....\n                 // If it's not supported, use the system default encoding\n                 reader = new PropertiesReader(new InputStreamReader(input));\n             }\n         }\n \n-        try\n-        {\n-            while (true)\n-            {\n+        try {\n+            while (true) {\n                 String line = reader.readProperty();\n                 int equalSign = line.indexOf('=');\n \n-                if (equalSign > 0)\n-                {\n+                if (equalSign > 0) {\n                     String key = line.substring(0, equalSign).trim();\n                     String value = line.substring(equalSign + 1).trim();\n \n-                    /*\n-                     * Configure produces lines like this ... just\n-                     * ignore them.\n-                     */\n-                    if (\"\".equals(value))\n+                    // Configure produces lines like this ... just ignore them\n+                    if (\"\".equals(value)) {\n                         continue;\n-\n-                    if (getInclude() != null && \n-                        key.equalsIgnoreCase(getInclude()))\n-                    {\n-                        /*\n-                         * Recursively load properties files.\n-                         */\n+                    }\n+\n+                    if (getInclude() != null && key.equalsIgnoreCase(getInclude())) {\n+                        // Recursively load properties files.\n                         File file = null;\n-                        \n-                        if (value.startsWith(fileSeparator))\n-                        {\n-                            /*\n-                             * We have an absolute path so we'll\n-                             * use this.\n-                             */\n+\n+                        if (value.startsWith(fileSeparator)) {\n+                            // We have an absolute path so we'll use this\n                             file = new File(value);\n-                        }\n-                        else\n-                        {   \n-                            /* \n-                             * We have a relative path, and we have\n-                             * two possible forms here. If we have the\n-                             * \"./\" form then just strip that off first\n-                             * before continuing.\n-                             */\n-                            if (value.startsWith(\".\" + fileSeparator))\n-                            {\n+                            \n+                        } else {\n+                            // We have a relative path, and we have two \n+                            // possible forms here. If we have the \"./\" form\n+                            // then just strip that off first before continuing.\n+                            if (value.startsWith(\".\" + fileSeparator)) {\n                                 value = value.substring(2);\n                             }\n-                            \n+\n                             file = new File(basePath + value);\n                         }\n-                        \n-                        if (file != null && file.exists() && file.canRead())\n-                        {\n-                            load ( new FileInputStream(file));\n+\n+                        if (file != null && file.exists() && file.canRead()) {\n+                            load(new FileInputStream(file));\n                         }\n+                    } else {\n+                        addProperty(key, value);\n                     }\n-                    else\n-                    {\n-                        addProperty(key,value);\n-                    }                       \n                 }\n             }\n-        }\n-        catch (NullPointerException e)\n-        {\n-            /*\n-             * Should happen only when EOF is reached.\n-             */\n+        } catch (NullPointerException ex) {\n+            // Should happen only when EOF is reached.\n             return;\n-        }\n-        finally\n-        {\n-            /*\n-             * Loading is initializing\n-             */\n+        } finally {\n+            // Loading is initializing\n             isInitialized = true;\n         }\n     }\n \n     /**\n-     *  Gets a property from the configuration.\n-     *\n-     *  @param key property to retrieve\n-     *  @return value as object. Will return user value if exists,\n-     *          if not then default value if exists, otherwise null\n-     */\n-    public Object getProperty( String key)\n-    {\n-        /*\n-         *  first, try to get from the 'user value' store\n-         */\n-        Object o = this.get(key);\n-\n-        if ( o == null)\n-        {\n-            /*\n-             *  if there isn't a value there, get it from the\n-             *  defaults if we have them\n-             */\n-            if (defaults != null)\n-            {\n-                o = defaults.get(key);\n-            }\n-        }\n-\n-        return o;\n+     * Gets a property from the configuration.\n+     *\n+     * @param key property to retrieve\n+     * @return value as object. Will return user value if exists,\n+     *        if not then default value if exists, otherwise null\n+     */\n+    public Object getProperty(String key) {\n+        // first, try to get from the 'user value' store\n+        Object obj = this.get(key);\n+\n+        if (obj == null) {\n+            // if there isn't a value there, get it from the\n+            // defaults if we have them\n+            if (defaults != null) {\n+                obj = defaults.get(key);\n+            }\n+        }\n+\n+        return obj;\n     }\n     \n     /**\n      * exists then the value stated here will be added\n      * to the configuration entry. For example, if\n      *\n-     * resource.loader = file\n+     * <code>resource.loader = file</code>\n      *\n      * is already present in the configuration and you\n      *\n-     * addProperty(\"resource.loader\", \"classpath\")\n+     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n      *\n      * Then you will end up with a Vector like the\n      * following:\n      *\n-     * [\"file\", \"classpath\"]\n-     *\n-     * @param String key\n-     * @param String value\n-     */\n-    public void addProperty(String key, Object token)\n-    {\n-        Object o = this.get(key);\n+     * <code>[\"file\", \"classpath\"]</code>\n+     *\n+     * @param key  the key to add\n+     * @param token  the value to add\n+     */\n+    public void addProperty(String key, Object token) {\n+        Object obj = this.get(key);\n \n         /*\n          *  $$$ GMJ\n          *\n          *  This applies throughout\n          */\n-        \n-        if (o instanceof String)\n-        {\n+\n+        if (obj instanceof String) {\n             Vector v = new Vector(2);\n-            v.addElement(o);\n+            v.addElement(obj);\n             v.addElement(token);\n             put(key, v);\n-        }\n-        else if (o instanceof Vector)\n-        {\n-            ((Vector) o).addElement(token);\n-        }\n-        else\n-        {\n+            \n+        } else if (obj instanceof Vector) {\n+            ((Vector) obj).addElement(token);\n+            \n+        } else {\n             /*\n              * This is the first time that we have seen\n              * request to place an object in the \n              * values.\n              */\n             if (token instanceof String &&\n-                ((String)token).indexOf(PropertiesTokenizer.DELIMITER) > 0)\n-            {\n-                PropertiesTokenizer tokenizer = \n-                    new PropertiesTokenizer((String)token);\n+                ((String) token).indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                     \n-                while (tokenizer.hasMoreTokens())\n-                {\n+                PropertiesTokenizer tokenizer = new PropertiesTokenizer((String) token);\n+\n+                while (tokenizer.hasMoreTokens()) {\n                     String value = tokenizer.nextToken();\n-                   \n+\n                     /*\n-                     * we know this is a string, so make sure it\n+                     * We know this is a string, so make sure it\n                      * just goes in rather than risking vectorization\n                      * if it contains an escaped comma\n                      */\n-                    addStringProperty(key,unescape(value));\n+                    addStringProperty(key, unescape(value));\n                 }\n-            }\n-            else\n-            {\n+            } else {\n                 /*\n                  * We want to keep track of the order the keys\n                  * are parsed, or dynamically entered into\n                  * in a definite order it will be possible.\n                  */\n                 if (token instanceof String) {\n-                    token = unescape((String)token);\n+                    token = unescape((String) token);\n                 }\n-                addPropertyDirect( key, token );\n-            }                \n-        }\n-        \n-        /*\n-         * Adding a property connotes initialization\n-         */\n+                addPropertyDirect(key, token);\n+            }\n+        }\n+\n+        // Adding a property connotes initialization\n         isInitialized = true;\n-        \n-    }\n-\n-    /**\n-     *   Adds a key/value pair to the map.  This routine does\n-     *   no magic morphing.  It ensures the keylist is maintained\n-     *\n-     *  @param key key to use for mapping\n-     *  @param obj object to store\n-     */\n-    private void addPropertyDirect( String key, Object obj )\n-    {\n-        /*\n-         * safety check\n-         */\n-        \n-        if( !containsKey( key ) )\n-        {\n+    }\n+\n+    /**\n+     * Adds a key/value pair to the map.  This routine does\n+     * no magic morphing.  It ensures the keylist is maintained\n+     *\n+     * @param key key to use for mapping\n+     * @param obj object to store\n+     */\n+    private void addPropertyDirect(String key, Object obj) {\n+        // safety check\n+        if (!containsKey(key)) {\n             keysAsListed.add(key);\n         }\n-        \n-        /*\n-         * and the value\n-         */\n         put(key, obj);\n     }\n \n     /**\n-     *  Sets a string property w/o checking for commas - used\n-     *  internally when a property has been broken up into\n-     *  strings that could contain escaped commas to prevent\n-     *  the inadvertant vectorization.\n-     *\n-     *  Thanks to Leon Messerschmidt for this one.\n-     *\n-     */\n-    private  void addStringProperty(String key, String token)\n-    {\n-        Object o = this.get(key);\n+     * Sets a string property w/o checking for commas - used\n+     * internally when a property has been broken up into\n+     * strings that could contain escaped commas to prevent\n+     * the inadvertant vectorization.\n+     * <p>\n+     * Thanks to Leon Messerschmidt for this one.\n+     *\n+     */\n+    private void addStringProperty(String key, String token) {\n+        Object obj = this.get(key);\n \n         /*\n          *  $$$ GMJ\n          *  This applies throughout\n          */\n \n-        /*\n-         *  do the usual thing - if we have a value and \n-         *  it's scalar, make a vector, otherwise add\n-         *  to the vector\n-         */\n- \n-        if (o instanceof String)\n-        {\n+        // do the usual thing - if we have a value and \n+        // it's scalar, make a vector, otherwise add\n+        // to the vector\n+        if (obj instanceof String) {\n             Vector v = new Vector(2);\n-            v.addElement(o);\n+            v.addElement(obj);\n             v.addElement(token);\n             put(key, v);\n-        }\n-        else if (o instanceof Vector)\n-        {\n-            ((Vector) o).addElement(token);\n-        }\n-        else\n-        {\n-            addPropertyDirect( key, token );\n+            \n+        } else if (obj instanceof Vector) {\n+            ((Vector) obj).addElement(token);\n+            \n+        } else {\n+            addPropertyDirect(key, token);\n         }\n     }\n \n      * set values. Set values is implicitly a call\n      * to clearProperty(key), addProperty(key,value).\n      *\n-     * @param String key\n-     * @param String value\n-     */\n-    public void setProperty(String key, Object value)\n-    {\n+     * @param key  the key to set\n+     * @param value  the value to set\n+     */\n+    public void setProperty(String key, Object value) {\n         clearProperty(key);\n-        addProperty(key,value);\n+        addProperty(key, value);\n     }\n     \n     /**\n-     * Save the properties to the given outputstream.\n-     *\n-     * @param output An OutputStream.\n-     * @param header A String.\n-     * @exception IOException.\n-     */\n-    public synchronized void save(OutputStream output,\n-                                  String Header)\n-        throws IOException\n-    {\n-        if(output != null)\n-        {\n-            PrintWriter theWrtr = new PrintWriter(output);\n-            if(Header != null)\n-            {\n-                theWrtr.println(Header);\n-            }\n-            Enumeration theKeys = keys();\n-            while(theKeys.hasMoreElements())\n-            {\n-                String key = (String) theKeys.nextElement();\n-                Object value = get((Object) key);\n-                if(value != null)\n-                {\n-                    if(value instanceof String)\n-                    {\n+     * Save the properties to the given output stream.\n+     * <p>\n+     * The stream is not closed, but it is flushed.\n+     *\n+     * @param output  an OutputStream, may be null\n+     * @param header  a textual comment to act as a file header\n+     * @throws IOException if an IO error occurs\n+     */\n+    public synchronized void save(OutputStream output, String header) throws IOException {\n+        if (output == null) {\n+            return;\n+        }\n+        PrintWriter theWrtr = new PrintWriter(output);\n+        if (header != null) {\n+            theWrtr.println(header);\n+        }\n+        \n+        Enumeration theKeys = keys();\n+        while (theKeys.hasMoreElements()) {\n+            String key = (String) theKeys.nextElement();\n+            Object value = get((Object) key);\n+            if (value != null) {\n+                if (value instanceof String) {\n+                    StringBuffer currentOutput = new StringBuffer();\n+                    currentOutput.append(key);\n+                    currentOutput.append(\"=\");\n+                    currentOutput.append(escape((String) value));\n+                    theWrtr.println(currentOutput.toString());\n+                    \n+                } else if (value instanceof Vector) {\n+                    Vector values = (Vector) value;\n+                    Enumeration valuesEnum = values.elements();\n+                    while (valuesEnum.hasMoreElements()) {\n+                        String currentElement = (String) valuesEnum.nextElement();\n                         StringBuffer currentOutput = new StringBuffer();\n                         currentOutput.append(key);\n                         currentOutput.append(\"=\");\n-                        currentOutput.append(escape((String) value));\n+                        currentOutput.append(escape(currentElement));\n                         theWrtr.println(currentOutput.toString());\n                     }\n-                    else if(value instanceof Vector)\n-                    {\n-                        Vector values = (Vector) value;\n-                        Enumeration valuesEnum = values.elements();\n-                        while(valuesEnum.hasMoreElements())\n-                        {\n-                            String currentElement = \n-                                   (String) valuesEnum.nextElement();\n-                            StringBuffer currentOutput = new StringBuffer();\n-                            currentOutput.append(key);\n-                            currentOutput.append(\"=\");\n-                            currentOutput.append(escape(currentElement));\n-                            theWrtr.println(currentOutput.toString());\n-                        }\n-                    }\n-                }    \n-                theWrtr.println();\n-                theWrtr.flush();\n-            }    \n-        }        \n+                }\n+            }\n+            theWrtr.println();\n+            theWrtr.flush();\n+        }\n     }\n \n     /**\n      * Combines an existing Hashtable with this Hashtable.\n-     *\n+     * <p>\n      * Warning: It will overwrite previous entries without warning.\n      *\n      * @param ExtendedProperties\n      */\n-    public void combine( ExtendedProperties c )\n-    {\n-        for (Iterator i = c.getKeys() ; i.hasNext() ;)\n-        {\n+    public void combine(ExtendedProperties c) {\n+        for (Iterator i = c.getKeys(); i.hasNext();) {\n             String key = (String) i.next();\n-            setProperty( key, c.get(key) );\n+            setProperty(key, c.get(key));\n         }\n     }\n     \n     /**\n      * Clear a property in the configuration.\n      *\n-     * @param String key to remove along with corresponding value.\n-     */\n-    public void clearProperty(String key)\n-    {\n-        if (containsKey(key))\n-        {\n-            /*\n-             * we also need to rebuild the keysAsListed or else\n-             * things get *very* confusing\n-             */\n-\n-            for(int i = 0; i < keysAsListed.size(); i++)\n-            {\n-                if ( ( (String) keysAsListed.get(i)).equals( key ) )\n-                {\n+     * @param key  the property key to remove along with corresponding value\n+     */\n+    public void clearProperty(String key) {\n+        if (containsKey(key)) {\n+            // we also need to rebuild the keysAsListed or else\n+            // things get *very* confusing\n+            for (int i = 0; i < keysAsListed.size(); i++) {\n+                if (((String) keysAsListed.get(i)).equals(key)) {\n                     keysAsListed.remove(i);\n                     break;\n                 }\n             }\n-\n             remove(key);\n-        }            \n+        }\n     }\n \n     /**\n      * Get the list of the keys contained in the configuration\n      * repository.\n      *\n-     * @return An Iterator.\n-     */\n-    public Iterator getKeys()\n-    {\n+     * @return an Iterator over the keys\n+     */\n+    public Iterator getKeys() {\n         return keysAsListed.iterator();\n     }\n \n      * Get the list of the keys contained in the configuration\n      * repository that match the specified prefix.\n      *\n-     * @param prefix The prefix to test against.\n-     * @return An Iterator of keys that match the prefix.\n-     */\n-    public Iterator getKeys(String prefix)\n-    {\n+     * @param prefix  the prefix to match\n+     * @return an Iterator of keys that match the prefix\n+     */\n+    public Iterator getKeys(String prefix) {\n         Iterator keys = getKeys();\n         ArrayList matchingKeys = new ArrayList();\n-        \n-        while( keys.hasNext() )\n-        {\n+\n+        while (keys.hasNext()) {\n             Object key = keys.next();\n-            \n-            if( key instanceof String && ((String) key).startsWith(prefix) )\n-            {\n+\n+            if (key instanceof String && ((String) key).startsWith(prefix)) {\n                 matchingKeys.add(key);\n             }\n         }\n      * of this one. Take into account duplicate keys\n      * by using the setProperty() in ExtendedProperties.\n      *\n-     * @param String prefix\n-     */\n-    public ExtendedProperties subset(String prefix)\n-    {\n+     * @param prefix  the prefix to get a subset for\n+     * @return a new independent ExtendedProperties\n+     */\n+    public ExtendedProperties subset(String prefix) {\n         ExtendedProperties c = new ExtendedProperties();\n         Iterator keys = getKeys();\n         boolean validSubset = false;\n-        \n-        while( keys.hasNext() )\n-        {\n+\n+        while (keys.hasNext()) {\n             Object key = keys.next();\n-            \n-            if( key instanceof String && ((String) key).startsWith(prefix) )\n-            {\n-                if (!validSubset)\n-                {\n+\n+            if (key instanceof String && ((String) key).startsWith(prefix)) {\n+                if (!validSubset) {\n                     validSubset = true;\n                 }\n-                \n-                String newKey = null;\n-                \n+\n                 /*\n                  * Check to make sure that c.subset(prefix) doesn't\n                  * blow up when there is only a single property\n                  * with the key prefix. This is not a useful\n                  * subset but it is a valid subset.\n                  */\n-                if ( ((String)key).length() == prefix.length())\n-                {\n+                String newKey = null;\n+                if (((String) key).length() == prefix.length()) {\n                     newKey = prefix;\n+                } else {\n+                    newKey = ((String) key).substring(prefix.length() + 1);\n                 }\n-                else\n-                {\n-                    newKey = ((String)key).substring(prefix.length() + 1);\n-                }                    \n-                \n+\n                 /*\n                  *  use addPropertyDirect() - this will plug the data as \n                  *  is into the Map, but will also do the right thing\n                  *  re key accounting\n                  */\n-\n-                c.addPropertyDirect( newKey, get(key) );\n-            }\n-        }\n-        \n-        if (validSubset)\n-        {\n+                c.addPropertyDirect(newKey, get(key));\n+            }\n+        }\n+\n+        if (validSubset) {\n             return c;\n-        }\n-        else\n-        {\n+        } else {\n             return null;\n         }\n     }\n \n     /**\n-     * Display the configuration for debugging\n-     * purposes.\n-     */\n-    public void display()\n-    {\n+     * Display the configuration for debugging purposes to System.out.\n+     */\n+    public void display() {\n         Iterator i = getKeys();\n-        \n-        while (i.hasNext())\n-        {\n+\n+        while (i.hasNext()) {\n             String key = (String) i.next();\n             Object value = get(key);\n             System.out.println(key + \" => \" + value);\n         }\n-    }     \n+    }\n \n     /**\n      * Get a string associated with the given configuration key.\n      *\n      * @param key The configuration key.\n      * @return The associated string.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String.\n      */\n-    public String getString(String key)\n-    {\n+    public String getString(String key) {\n         return getString(key, null);\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated string if key is found,\n      * default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String.\n      */\n-    public String getString(String key,\n-                            String defaultValue)\n-    {\n+    public String getString(String key, String defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof String)\n-        {\n-            return (String) interpolate((String)value);\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+        if (value instanceof String) {\n+            return (String) interpolate((String) value);\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return interpolate(defaults.getString(key, defaultValue));\n-            }\n-            else\n-            {\n+            } else {\n                 return interpolate(defaultValue);\n             }\n-        }\n-        else if (value instanceof Vector)\n-        {\n+        } else if (value instanceof Vector) {\n             return interpolate((String) ((Vector) value).get(0));\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a String object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n         }\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated properties if key is found.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String/Vector.\n-     * @exception IllegalArgumentException if one of the tokens is\n+     * @throws IllegalArgumentException if one of the tokens is\n      * malformed (does not contain an equals sign).\n      */\n-    public Properties getProperties(String key)\n-    {\n+    public Properties getProperties(String key) {\n         return getProperties(key, new Properties());\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated properties if key is found.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String/Vector.\n-     * @exception IllegalArgumentException if one of the tokens is\n+     * @throws IllegalArgumentException if one of the tokens is\n      * malformed (does not contain an equals sign).\n      */\n-    public Properties getProperties(String key,\n-                                    Properties defaults)\n-    {\n+    public Properties getProperties(String key, Properties defaults) {\n         /*\n          * Grab an array of the tokens for this key.\n          */\n         String[] tokens = getStringArray(key);\n \n-        /* \n-         * Each token is of the form 'key=value'.\n-         */\n+        // Each token is of the form 'key=value'.\n         Properties props = new Properties(defaults);\n-        for (int i = 0; i < tokens.length; i++)\n-        {\n+        for (int i = 0; i < tokens.length; i++) {\n             String token = tokens[i];\n             int equalSign = token.indexOf('=');\n-            if (equalSign > 0)\n-            {\n+            if (equalSign > 0) {\n                 String pkey = token.substring(0, equalSign).trim();\n                 String pvalue = token.substring(equalSign + 1).trim();\n                 props.put(pkey, pvalue);\n-            }\n-            else\n-            {\n-                throw new IllegalArgumentException('\\'' + token +\n-                                                   \"' does not contain \" +\n-                                                   \"an equals sign\");\n+            } else {\n+                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n             }\n         }\n         return props;\n      *\n      * @param key The configuration key.\n      * @return The associated string array if key is found.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String/Vector.\n      */\n-    public String[] getStringArray(String key)\n-    {\n+    public String[] getStringArray(String key) {\n         Object value = get(key);\n \n         // What's your vector, Victor?\n         Vector vector;\n-        if (value instanceof String)\n-        {\n+        if (value instanceof String) {\n             vector = new Vector(1);\n             vector.addElement(value);\n-        }\n-        else if (value instanceof Vector)\n-        {\n-            vector = (Vector)value;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value instanceof Vector) {\n+            vector = (Vector) value;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getStringArray(key);\n-            }\n-            else\n-            {\n+            } else {\n                 return new String[0];\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a String/Vector object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/Vector object\");\n         }\n \n         String[] tokens = new String[vector.size()];\n-        for (int i = 0; i < tokens.length; i++)\n-        {\n-            tokens[i] = (String)vector.elementAt(i);\n+        for (int i = 0; i < tokens.length; i++) {\n+            tokens[i] = (String) vector.elementAt(i);\n         }\n \n         return tokens;\n      *\n      * @param key The configuration key.\n      * @return The associated Vector.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Vector.\n      */\n-    public Vector getVector(String key)\n-    {\n+    public Vector getVector(String key) {\n         return getVector(key, null);\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated Vector.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Vector.\n      */\n-    public Vector getVector(String key,\n-                            Vector defaultValue)\n-    {\n+    public Vector getVector(String key, Vector defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Vector)\n-        {\n+        if (value instanceof Vector) {\n             return (Vector) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Vector v = new Vector(1);\n             v.addElement((String) value);\n             put(key, v);\n             return v;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getVector(key, defaultValue);\n-            }\n-            else\n-            {\n-                return ((defaultValue == null) ?\n-                        new Vector() : defaultValue);\n-            }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Vector object\");\n+            } else {\n+                return ((defaultValue == null) ? new Vector() : defaultValue);\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n         }\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated boolean.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Boolean.\n      */\n-    public boolean getBoolean(String key)\n-    {\n+    public boolean getBoolean(String key) {\n         Boolean b = getBoolean(key, (Boolean) null);\n-        if (b != null)\n-        {\n+        if (b != null) {\n             return b.booleanValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \"' doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated boolean.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Boolean.\n      */\n-    public boolean getBoolean(String key, boolean defaultValue)\n-    {\n+    public boolean getBoolean(String key, boolean defaultValue) {\n         return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated boolean if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Boolean.\n      */\n-    public Boolean getBoolean(String key, Boolean defaultValue)\n-    {\n-    \n+    public Boolean getBoolean(String key, Boolean defaultValue) {\n+\n         Object value = get(key);\n \n-        if (value instanceof Boolean)\n-        {\n+        if (value instanceof Boolean) {\n             return (Boolean) value;\n-        }\n-        else if (value instanceof String)\n-        {\n-            String s = testBoolean((String)value);\n+            \n+        } else if (value instanceof String) {\n+            String s = testBoolean((String) value);\n             Boolean b = new Boolean(s);\n             put(key, b);\n             return b;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getBoolean(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Boolean object\");\n-        }\n-    }\n-    \n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n+        }\n+    }\n+\n     /**\n      * Test whether the string represent by value maps to a boolean\n      * value or not. We will allow <code>true</code>, <code>on</code>,\n      * @return <code>true</code> or <code>false</code> if the supplied\n      * text maps to a boolean value, or <code>null</code> otherwise.\n      */\n-    public String testBoolean(String value)\n-    {\n-        String s = ((String)value).toLowerCase();\n-    \n-        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\"))\n-        {\n+    public String testBoolean(String value) {\n+        String s = ((String) value).toLowerCase();\n+\n+        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n             return \"true\";\n-        }\n-        else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\"))\n-        {\n+        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n             return \"false\";\n-        }\n-        else\n-        {\n+        } else {\n             return null;\n         }\n     }\n      *\n      * @param key The configuration key.\n      * @return The associated byte.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Byte.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public byte getByte(String key)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public byte getByte(String key) {\n         Byte b = getByte(key, null);\n-        if (b != null)\n-        {\n+        if (b != null) {\n             return b.byteValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \" doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated byte.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Byte.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public byte getByte(String key,\n-                        byte defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public byte getByte(String key, byte defaultValue) {\n         return getByte(key, new Byte(defaultValue)).byteValue();\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated byte if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Byte.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public Byte getByte(String key,\n-                        Byte defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Byte getByte(String key, Byte defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Byte)\n-        {\n+        if (value instanceof Byte) {\n             return (Byte) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Byte b = new Byte((String) value);\n             put(key, b);\n             return b;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getByte(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Byte object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n         }\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated short.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Short.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public short getShort(String key)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public short getShort(String key) {\n         Short s = getShort(key, null);\n-        if (s != null)\n-        {\n+        if (s != null) {\n             return s.shortValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \"' doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated short.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Short.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public short getShort(String key,\n-                          short defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public short getShort(String key, short defaultValue) {\n         return getShort(key, new Short(defaultValue)).shortValue();\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated short if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Short.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public Short getShort(String key,\n-                          Short defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Short getShort(String key, Short defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Short)\n-        {\n+        if (value instanceof Short) {\n             return (Short) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Short s = new Short((String) value);\n             put(key, s);\n             return s;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getShort(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Short object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n         }\n     }\n \n      * @param name The resource name.\n      * @return The value of the resource as an integer.\n      */\n-    public int getInt(String name)\n-    {\n+    public int getInt(String name) {\n         return getInteger(name);\n     }\n \n      * @param def The default value of the resource.\n      * @return The value of the resource as an integer.\n      */\n-    public int getInt(String name,\n-                      int def)\n-    {\n+    public int getInt(String name, int def) {\n         return getInteger(name, def);\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated int.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Integer.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public int getInteger(String key)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public int getInteger(String key) {\n         Integer i = getInteger(key, null);\n-        if (i != null)\n-        {\n+        if (i != null) {\n             return i.intValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \"' doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated int.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Integer.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public int getInteger(String key,\n-                          int defaultValue)\n-    {    \n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public int getInteger(String key, int defaultValue) {\n         Integer i = getInteger(key, null);\n-        \n-        if (i == null)\n-        {\n+\n+        if (i == null) {\n             return defaultValue;\n         }\n-        \n         return i.intValue();\n-      }\n-\n+    }\n \n     /**\n      * Get a int associated with the given configuration key.\n      * @param defaultValue The default value.\n      * @return The associated int if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Integer.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public Integer getInteger(String key,\n-                              Integer defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Integer getInteger(String key, Integer defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Integer)\n-        {\n+        if (value instanceof Integer) {\n             return (Integer) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Integer i = new Integer((String) value);\n             put(key, i);\n             return i;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getInteger(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Integer object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n         }\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated long.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Long.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public long getLong(String key)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public long getLong(String key) {\n         Long l = getLong(key, null);\n-        if (l != null)\n-        {\n+        if (l != null) {\n             return l.longValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \"' doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated long.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Long.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public long getLong(String key,\n-                        long defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public long getLong(String key, long defaultValue) {\n         return getLong(key, new Long(defaultValue)).longValue();\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated long if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Long.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public Long getLong(String key,\n-                        Long defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Long getLong(String key, Long defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Long)\n-        {\n+        if (value instanceof Long) {\n             return (Long) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Long l = new Long((String) value);\n             put(key, l);\n             return l;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getLong(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Long object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n         }\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated float.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Float.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public float getFloat(String key)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public float getFloat(String key) {\n         Float f = getFloat(key, null);\n-        if (f != null)\n-        {\n+        if (f != null) {\n             return f.floatValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \"' doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated float.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Float.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public float getFloat(String key,\n-                          float defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public float getFloat(String key, float defaultValue) {\n         return getFloat(key, new Float(defaultValue)).floatValue();\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated float if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Float.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public Float getFloat(String key,\n-                          Float defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Float getFloat(String key, Float defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Float)\n-        {\n+        if (value instanceof Float) {\n             return (Float) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Float f = new Float((String) value);\n             put(key, f);\n             return f;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getFloat(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Float object\");\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n         }\n     }\n \n      *\n      * @param key The configuration key.\n      * @return The associated double.\n-     * @exception NoSuchElementException is thrown if the key doesn't\n+     * @throws NoSuchElementException is thrown if the key doesn't\n      * map to an existing object.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Double.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public double getDouble(String key)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public double getDouble(String key) {\n         Double d = getDouble(key, null);\n-        if (d != null)\n-        {\n+        if (d != null) {\n             return d.doubleValue();\n-        }\n-        else\n-        {\n-            throw new NoSuchElementException(\n-                '\\'' + key + \"' doesn't map to an existing object\");\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      * @param key The configuration key.\n      * @param defaultValue The default value.\n      * @return The associated double.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Double.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public double getDouble(String key,\n-                            double defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public double getDouble(String key, double defaultValue) {\n         return getDouble(key, new Double(defaultValue)).doubleValue();\n     }\n \n      * @param defaultValue The default value.\n      * @return The associated double if key is found and has valid\n      * format, default value otherwise.\n-     * @exception ClassCastException is thrown if the key maps to an\n+     * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Double.\n-     * @exception NumberFormatException is thrown if the value mapped\n-     * by the key has not a valid number format.\n-     */\n-    public Double getDouble(String key,\n-                            Double defaultValue)\n-    {\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Double getDouble(String key, Double defaultValue) {\n         Object value = get(key);\n \n-        if (value instanceof Double)\n-        {\n+        if (value instanceof Double) {\n             return (Double) value;\n-        }\n-        else if (value instanceof String)\n-        {\n+            \n+        } else if (value instanceof String) {\n             Double d = new Double((String) value);\n             put(key, d);\n             return d;\n-        }\n-        else if (value == null)\n-        {\n-            if (defaults != null)\n-            {\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n                 return defaults.getDouble(key, defaultValue);\n-            }\n-            else\n-            {\n+            } else {\n                 return defaultValue;\n             }\n-        }\n-        else\n-        {\n-            throw new ClassCastException(\n-                '\\'' + key + \"' doesn't map to a Double object\");\n-        }\n-    }\n-\n-    /**\n-     * Convert a standard properties class into a configuration\n-     * class.\n-     *\n-     * @param p properties object to convert into\n-     *                   a ExtendedProperties object.\n-     *\n-     * @return ExtendedProperties configuration created from the\n-     *                      properties object.\n-     */\n-    public static ExtendedProperties convertProperties(Properties p)\n-    {\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n+        }\n+    }\n+\n+    /**\n+     * Convert a standard properties class into a configuration class.\n+     *\n+     * @param props  the properties object to convert\n+     * @return new ExtendedProperties created from props\n+     */\n+    public static ExtendedProperties convertProperties(Properties props) {\n         ExtendedProperties c = new ExtendedProperties();\n+\n+        for (Enumeration e = props.keys(); e.hasMoreElements();) {\n+            String s = (String) e.nextElement();\n+            c.setProperty(s, props.getProperty(s));\n+        }\n+\n+        return c;\n+    }\n     \n-        for (Enumeration e = p.keys(); e.hasMoreElements() ; ) \n-        {\n-            String s = (String) e.nextElement();\n-            c.setProperty(s, p.getProperty(s));\n-        }\n-    \n-        return c;\n-    }\n }\n--- a/src/test/org/apache/commons/collections/TestExtendedProperties.java\n+++ b/src/test/org/apache/commons/collections/TestExtendedProperties.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestExtendedProperties.java,v 1.5 2003/08/24 10:50:58 scolebourne Exp $\n- * $Revision: 1.5 $\n- * $Date: 2003/08/24 10:50:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestExtendedProperties.java,v 1.6 2003/08/24 11:29:52 scolebourne Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2003/08/24 11:29:52 $\n  *\n  * ====================================================================\n  *\n  * \n  * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n  * @author Mohan Kishore\n- * @version $Id: TestExtendedProperties.java,v 1.5 2003/08/24 10:50:58 scolebourne Exp $\n+ * @author Stephen Colebourne\n+ * @version $Id: TestExtendedProperties.java,v 1.6 2003/08/24 11:29:52 scolebourne Exp $\n  */\n-public class TestExtendedProperties extends TestCase\n-{\n+public class TestExtendedProperties extends TestCase {\n     protected ExtendedProperties eprop = new ExtendedProperties();\n \n-    public TestExtendedProperties(String testName)\n-    {\n+    public TestExtendedProperties(String testName) {\n         super(testName);\n     }\n \n-    public static Test suite()\n-    {\n-        return new TestSuite( TestExtendedProperties.class );\n-    }\n-\n-    public static void main(String args[])\n-    {\n-        String[] testCaseName = { TestExtendedProperties.class.getName() };\n+    public static Test suite() {\n+        return new TestSuite(TestExtendedProperties.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestExtendedProperties.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public void testRetrieve()\n-    {\n+    public void testRetrieve() {\n         /*\n          * should be emptry and return null\n          */\n-\n         assertEquals(\"This returns null\", eprop.getProperty(\"foo\"), null);\n \n         /*\n          * now add another and get a Vector\n          */\n         eprop.addProperty(\"number\", \"2\");\n-        assertTrue(\"This returns array\", ( eprop.getVector(\"number\") instanceof java.util.Vector ) );\n-        \n+        assertTrue(\"This returns array\", (eprop.getVector(\"number\") instanceof java.util.Vector));\n+\n         /*\n          *  now test dan's new fix where we get the first scalar \n          *  when we access a vector valued\n          *  property\n          */\n-        assertTrue(\"This returns scalar\", ( eprop.getString(\"number\") instanceof String ) );\n+        assertTrue(\"This returns scalar\", (eprop.getString(\"number\") instanceof String));\n \n         /*\n          * test comma separated string properties\n          */\n         String prop = \"hey, that's a test\";\n         eprop.setProperty(\"prop.string\", prop);\n-        assertTrue(\"This returns vector\", ( eprop.getVector(\"prop.string\") instanceof java.util.Vector ) );\n-        \n+        assertTrue(\"This returns vector\", (eprop.getVector(\"prop.string\") instanceof java.util.Vector));\n+\n         String prop2 = \"hey\\\\, that's a test\";\n         eprop.remove(\"prop.string\");\n         eprop.setProperty(\"prop.string\", prop2);\n-        assertTrue(\"This returns array\", ( eprop.getString(\"prop.string\") instanceof java.lang.String) );\n-        \n+        assertTrue(\"This returns array\", (eprop.getString(\"prop.string\") instanceof java.lang.String));\n+\n         /*\n          * test subset : we want to make sure that the EP doesn't reprocess the data \n          *  elements when generating the subset\n \n         ExtendedProperties subEprop = eprop.subset(\"prop\");\n \n-        assertTrue(\"Returns the full string\",  subEprop.getString(\"string\").equals( prop ) );\n-        assertTrue(\"This returns string for subset\", ( subEprop.getString(\"string\") instanceof java.lang.String) );\n-        assertTrue(\"This returns array for subset\", ( subEprop.getVector(\"string\") instanceof java.util.Vector) );\n-        \n-    }\n-\n-    public void testInterpolation()\n-    {\n+        assertTrue(\"Returns the full string\", subEprop.getString(\"string\").equals(prop));\n+        assertTrue(\"This returns string for subset\", (subEprop.getString(\"string\") instanceof java.lang.String));\n+        assertTrue(\"This returns array for subset\", (subEprop.getVector(\"string\") instanceof java.util.Vector));\n+\n+    }\n+\n+    public void testInterpolation() {\n         eprop.setProperty(\"applicationRoot\", \"/home/applicationRoot\");\n         eprop.setProperty(\"db\", \"${applicationRoot}/db/hypersonic\");\n         String dbProp = \"/home/applicationRoot/db/hypersonic\";\n         assertTrue(\"Checking interpolated variable\", eprop.getString(\"db\").equals(dbProp));\n     }\n-    \n+\n     public void testSaveAndLoad() {\n         ExtendedProperties ep1 = new ExtendedProperties();\n         ExtendedProperties ep2 = new ExtendedProperties();\n             fail(\"There was an exception saving and loading the EP\");\n         }\n     }\n-    \n+\n     public void testTrailingBackSlash() {\n         ExtendedProperties ep1 = new ExtendedProperties();\n \n             fail(\"There was an exception loading the EP\");\n         }\n     }\n+    \n }", "timestamp": 1061724592, "metainfo": ""}