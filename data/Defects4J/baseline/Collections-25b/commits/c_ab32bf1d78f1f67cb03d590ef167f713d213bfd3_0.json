{"sha": "ab32bf1d78f1f67cb03d590ef167f713d213bfd3", "log": "[COLLECTIONS-272] Added support for serialization to FixedOrderComparator and TransformingComparator, added missing equals/hashCode, renamed tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n  */\n package org.apache.commons.collections.comparators;\n \n+import java.io.Serializable;\n import java.util.Comparator;\n import java.util.HashMap;\n import java.util.List;\n  * Instances of FixedOrderComparator are not synchronized.  The class is not\n  * thread-safe at construction time, but it is thread-safe to perform\n  * multiple comparisons  after all the setup operations are complete.\n+ * <p>\n+ * This class is Serializable from Commons Collections 4.0.\n  *\n  * @since 3.0\n  * @version $Id$\n  */\n-public class FixedOrderComparator<T> implements Comparator<T> {\n+public class FixedOrderComparator<T> implements Comparator<T>, Serializable {\n+\n+    /** Serialization version from Collections 4.0. */\n+    private static final long serialVersionUID = 82794675842863201L;\n \n     /**\n      * Unknown object behavior enum.\n         return position1.compareTo(position2);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 17;\n+        total = total*37 + (map == null ? 0 : map.hashCode());\n+        total = total*37 + (unknownObjectBehavior == null ? 0 : unknownObjectBehavior.hashCode());\n+        total = total*37 + counter;\n+        total = total*37 + (isLocked ? 0 : 1);\n+        return total;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>that</i></code> is a {@link FixedOrderComparator} \n+     * whose attributes are equal to mine.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            FixedOrderComparator<?> comp = (FixedOrderComparator<?>) object;\n+            return (null == map ? null == comp.map : map.equals(comp.map) &&\n+                    null == unknownObjectBehavior ? null == comp.unknownObjectBehavior :\n+                        unknownObjectBehavior == comp.unknownObjectBehavior &&\n+                    counter == comp.counter &&\n+                    isLocked == comp.isLocked &&\n+                    unknownObjectBehavior == comp.unknownObjectBehavior);\n+        }\n+        return false;\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n  */\n package org.apache.commons.collections.comparators;\n \n+import java.io.Serializable;\n import java.util.Comparator;\n \n import org.apache.commons.collections.ComparatorUtils;\n  * Decorates another Comparator with transformation behavior. That is, the\n  * return value from the transform operation will be passed to the decorated\n  * {@link Comparator#compare(Object,Object) compare} method.\n+ * <p>\n+ * This class is Serializable from Commons Collections 4.0.\n  *\n  * @since 2.1\n  * @version $Id$\n  * @see org.apache.commons.collections.Transformer\n  * @see org.apache.commons.collections.comparators.ComparableComparator\n  */\n-public class TransformingComparator<E> implements Comparator<E> {\n+public class TransformingComparator<E> implements Comparator<E>, Serializable {\n     \n+    /** Serialization version from Collections 4.0. */\n+    private static final long serialVersionUID = 3456940356043606220L;\n+\n     /** The decorated comparator. */\n     protected final Comparator<E> decorated;\n     /** The transformer being used. */    \n         return this.decorated.compare(value1, value2);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 17;\n+        total = total*37 + (decorated == null ? 0 : decorated.hashCode());\n+        total = total*37 + (transformer == null ? 0 : transformer.hashCode());\n+        return total;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>that</i></code> is a {@link TransformingComparator} \n+     * whose attributes are equal to mine.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            TransformingComparator<?> comp = (TransformingComparator<?>) object;\n+            return (null == decorated ? null == comp.decorated : decorated.equals(comp.decorated) &&\n+                    null == transformer ? null == comp.transformer : transformer.equals(comp.transformer));\n+        }\n+        return false;\n+    }\n+\n }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.junit.Test;\n+\n+/**\n+ * Abstract test class for testing the Comparator interface.\n+ * <p>\n+ * Concrete subclasses declare the comparator to be tested.\n+ * They also declare certain aspects of the tests.\n+ */\n+public abstract class AbstractComparatorTest<T> extends AbstractTestObject {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractComparatorTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Implement this method to return a list of sorted objects.\n+     * \n+     * @return sorted objects\n+     */\n+    public abstract List<T> getComparableObjectsOrdered();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements the abstract superclass method to return the comparator.\n+     * \n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract Comparator<T> makeObject();\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsEmptyCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsFullCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to set the compatability to version 2\n+     * as there were no Comparators in version 1.x.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"2\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverse the list.\n+     */\n+    protected void reverseObjects(List<?> list) {\n+        Collections.reverse(list);\n+    }\n+\n+    /**\n+     * Randomize the list.\n+     */\n+    protected void randomizeObjects(List<?> list) {\n+        Collections.shuffle(list);\n+    }\n+\n+    /**\n+     * Sort the list.\n+     */\n+    protected void sortObjects(List<T> list, Comparator<? super T> comparator) {\n+        Collections.sort(list, comparator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test sorting an empty list\n+     */\n+    @Test\n+    public void testEmptyListSort() {\n+        List<T> list = new LinkedList<T>();\n+        sortObjects(list, makeObject());\n+\n+        List<T> list2 = new LinkedList<T>();\n+\n+        assertTrue(\"Comparator cannot sort empty lists\", list2.equals(list));\n+    }\n+\n+    /**\n+     * Test sorting a reversed list.\n+     */\n+    @Test\n+    public void testReverseListSort() {\n+        Comparator<T> comparator = makeObject();\n+\n+        List<T> randomList = getComparableObjectsOrdered();\n+        reverseObjects(randomList);\n+        sortObjects(randomList, comparator);\n+\n+        List<T> orderedList = getComparableObjectsOrdered();\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+    }\n+\n+    /**\n+     * Test sorting a random list.\n+     */\n+    @Test\n+    public void testRandomListSort() {\n+        Comparator<T> comparator = makeObject();\n+\n+        List<T> randomList = getComparableObjectsOrdered();\n+        randomizeObjects(randomList);\n+        sortObjects(randomList,comparator);\n+\n+        List<T> orderedList = getComparableObjectsOrdered();\n+\n+        /* debug \n+        Iterator i = randomList.iterator();\n+        while (i.hasNext()) {\n+            System.out.println(i.next());\n+        }\n+        */\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+\n+    }\n+\n+    /**\n+     * Nearly all Comparators should be Serializable.\n+     */\n+    @Test\n+    public void testComparatorIsSerializable() {\n+        Comparator<T> comparator = makeObject();\n+        assertTrue(\"This comparator should be Serializable.\",\n+                   comparator instanceof Serializable);\n+    }\n+\n+    public String getCanonicalComparatorName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(TEST_DATA_PATH);\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\")+1,colName.length());\n+        retval.append(colName);\n+        retval.append(\".version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Comparator\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testComparatorCompatibility() throws IOException, ClassNotFoundException {\n+        if (!skipSerializedCanonicalTests()) {\n+            Comparator<T> comparator = null;\n+    \n+            // test to make sure the canonical form has been preserved\n+            try {\n+                comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n+            } catch (FileNotFoundException exception) {\n+    \n+                boolean autoCreateSerialized = false;\n+    \n+                if (autoCreateSerialized) {\n+                    comparator = makeObject();\n+                    String fileName = getCanonicalComparatorName(comparator);\n+                    writeExternalFormToDisk((Serializable) comparator, fileName);\n+                    fail(\"Serialized form could not be found.  A serialized version \"\n+                            + \"has now been written (and should be added to CVS): \" + fileName);\n+                } else {\n+                    fail(\"The Serialized form could be located to test serialization \"\n+                            + \"compatibility: \" + exception.getMessage());\n+                }\n+            }\n+    \n+            \n+            // make sure the canonical form produces the ordering we currently\n+            // expect\n+            List<T> randomList = getComparableObjectsOrdered();\n+            reverseObjects(randomList);\n+            sortObjects(randomList, comparator);\n+    \n+            List<T> orderedList = getComparableObjectsOrdered();\n+    \n+            assertTrue(\"Comparator did not reorder the List correctly\",\n+                       orderedList.equals(randomList));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractNullComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test the NullComparator.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractNullComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    public AbstractNullComparatorTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AbstractNullComparatorTest.class.getName());\n+        suite.addTest(new TestSuite(TestNullComparator1.class));\n+        suite.addTest(new TestSuite(TestNullComparator2.class));\n+        return suite;\n+    }\n+\n+    /**\n+     *  Test the NullComparator with nulls high, using comparable comparator\n+     **/\n+    public static class TestNullComparator1 extends AbstractNullComparatorTest {\n+\n+        public TestNullComparator1(String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public Comparator<Integer> makeObject() {\n+            return new NullComparator<Integer>();\n+        }\n+\n+        @Override\n+        public List<Integer> getComparableObjectsOrdered() {\n+            List<Integer> list = new LinkedList<Integer>();\n+            list.add(new Integer(1));\n+            list.add(new Integer(2));\n+            list.add(new Integer(3));\n+            list.add(new Integer(4));\n+            list.add(new Integer(5));\n+            list.add(null);\n+            return list;\n+        }\n+\n+        @Override\n+        public String getCanonicalComparatorName(Object object) {\n+            return super.getCanonicalComparatorName(object) + \"1\";\n+        }\n+    }\n+\n+    /**\n+     *  Test the NullComparator with nulls low using the comparable comparator\n+     **/\n+    public static class TestNullComparator2 extends AbstractNullComparatorTest {\n+\n+        public TestNullComparator2(String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public Comparator<Integer> makeObject() {\n+            return new NullComparator<Integer>(false);\n+        }\n+\n+        @Override\n+        public List<Integer> getComparableObjectsOrdered() {\n+            List<Integer> list = new LinkedList<Integer>();\n+            list.add(null);\n+            list.add(new Integer(1));\n+            list.add(new Integer(2));\n+            list.add(new Integer(3));\n+            list.add(new Integer(4));\n+            list.add(new Integer(5));\n+            return list;\n+        }\n+\n+        @Override\n+        public String getCanonicalComparatorName(Object object) {\n+            return super.getCanonicalComparatorName(object) + \"2\";\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/BooleanComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests for {@link BooleanComparator}.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class BooleanComparatorTest extends AbstractComparatorTest<Boolean> {\n+\n+    // conventional\n+    // ------------------------------------------------------------------------\n+\n+    public BooleanComparatorTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // collections testing framework\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public Comparator<Boolean> makeObject() {\n+        return new BooleanComparator();\n+    }\n+\n+    @Override\n+    public List<Boolean> getComparableObjectsOrdered() {\n+        List<Boolean> list = new ArrayList<Boolean>();\n+        list.add(new Boolean(false));\n+        list.add(Boolean.FALSE);\n+        list.add(new Boolean(false));\n+        list.add(Boolean.TRUE);\n+        list.add(new Boolean(true));\n+        list.add(true);\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    // tests\n+    // ------------------------------------------------------------------------\n+\n+    @Test\n+    public void testConstructors() {\n+        allTests(false,new BooleanComparator());\n+        allTests(false,new BooleanComparator(false));\n+        allTests(true,new BooleanComparator(true));\n+    }\n+\n+    @Test\n+\n+    public void testStaticFactoryMethods() {\n+        allTests(false,BooleanComparator.getFalseFirstComparator());\n+        allTests(false,BooleanComparator.booleanComparator(false));\n+        allTests(true,BooleanComparator.getTrueFirstComparator());\n+        allTests(true,BooleanComparator.booleanComparator(true));\n+    }\n+\n+    @Test\n+    public void testEqualsCompatibleInstance() {\n+        assertEquals(new BooleanComparator(),new BooleanComparator(false));\n+        assertEquals(new BooleanComparator(false),new BooleanComparator(false));\n+        assertEquals(new BooleanComparator(false),BooleanComparator.getFalseFirstComparator());\n+        assertSame(BooleanComparator.getFalseFirstComparator(),BooleanComparator.booleanComparator(false));\n+\n+        assertEquals(new BooleanComparator(true),new BooleanComparator(true));\n+        assertEquals(new BooleanComparator(true),BooleanComparator.getTrueFirstComparator());\n+        assertSame(BooleanComparator.getTrueFirstComparator(),BooleanComparator.booleanComparator(true));\n+\n+        assertTrue(!(new BooleanComparator().equals(new BooleanComparator(true))));\n+        assertTrue(!(new BooleanComparator(true).equals(new BooleanComparator(false))));\n+    }\n+\n+    // utilities\n+    // ------------------------------------------------------------------------\n+\n+    protected void allTests(boolean trueFirst, BooleanComparator comp) {\n+        orderIndependentTests(comp);\n+        if(trueFirst) {\n+            trueFirstTests(comp);\n+        } else {\n+            falseFirstTests(comp);\n+        }\n+    }\n+\n+    protected void trueFirstTests(BooleanComparator comp) {\n+        assertNotNull(comp);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) > 0);\n+        assertTrue(comp.compare(true, false) < 0);\n+    }\n+\n+    protected void falseFirstTests(BooleanComparator comp) {\n+        assertNotNull(comp);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) < 0);\n+        assertTrue(comp.compare(true, false) > 0);\n+    }\n+\n+    protected void orderIndependentTests(BooleanComparator comp) {\n+        nullArgumentTests(comp);\n+    }\n+\n+    protected void nullArgumentTests(BooleanComparator comp) {\n+        assertNotNull(comp);\n+        try {\n+            comp.compare(null,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(Boolean.TRUE,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(Boolean.FALSE,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(null,Boolean.TRUE);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(null,Boolean.FALSE);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/ComparableComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Tests for ComparableComparator.\n+ *\n+ * @version $Id$\n+ *\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class ComparableComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    public ComparableComparatorTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+        return new ComparableComparator<Integer>();\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        list.add(5);\n+        return list;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/ComparatorChainTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests for ComparatorChain.\n+ *\n+ * @version $Id$\n+ */\n+public class ComparatorChainTest extends AbstractComparatorTest<ComparatorChainTest.PseudoRow> {\n+\n+    public ComparatorChainTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Comparator<PseudoRow> makeObject() {\n+        ComparatorChain<PseudoRow> chain = new ComparatorChain<PseudoRow>(new ColumnComparator(0));\n+        chain.addComparator(new ColumnComparator(1), true); // reverse the second column\n+        chain.addComparator(new ColumnComparator(2), false);\n+        return chain;\n+    }\n+\n+    @Test\n+    public void testNoopComparatorChain() {\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        chain.addComparator(new ComparableComparator<Integer>());\n+\n+        int correctValue = i1.compareTo(i2);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n+    }\n+\n+    @Test\n+    public void testBadNoopComparatorChain() {\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        try {\n+            chain.compare(i1,i2);\n+            fail(\"An exception should be thrown when a chain contains zero comparators.\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testListComparatorChain() {\n+        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        list.add(new ComparableComparator<Integer>());\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+\n+        int correctValue = i1.compareTo(i2);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n+    }\n+\n+    @Test\n+    public void testBadListComparatorChain() {\n+        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        try {\n+            chain.compare(i1, i2);\n+            fail(\"An exception should be thrown when a chain contains zero comparators.\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testComparatorChainOnMinvaluedCompatator() {\n+        // -1 * Integer.MIN_VALUE is less than 0,\n+        // test that ComparatorChain handles this edge case correctly\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        chain.addComparator(new Comparator<Integer>() {\n+            public int compare(Integer a, Integer b) {\n+                int result = a.compareTo(b);\n+                if (result < 0) {\n+                    return Integer.MIN_VALUE;\n+                }\n+                if (result > 0) {\n+                    return Integer.MAX_VALUE;\n+                }\n+                return 0;\n+            }\n+        }, true);\n+\n+        assertTrue(chain.compare(new Integer(4), new Integer(5)) > 0);\n+        assertTrue(chain.compare(new Integer(5), new Integer(4)) < 0);\n+        assertTrue(chain.compare(new Integer(4), new Integer(4)) == 0);\n+    }\n+\n+    @Override\n+    public List<PseudoRow> getComparableObjectsOrdered() {\n+        List<PseudoRow> list = new LinkedList<PseudoRow>();\n+        // this is the correct order assuming a\n+        // \"0th forward, 1st reverse, 2nd forward\" sort\n+        list.add(new PseudoRow(1, 2, 3));\n+        list.add(new PseudoRow(2, 3, 5));\n+        list.add(new PseudoRow(2, 2, 4));\n+        list.add(new PseudoRow(2, 2, 8));\n+        list.add(new PseudoRow(3, 1, 0));\n+        list.add(new PseudoRow(4, 4, 4));\n+        list.add(new PseudoRow(4, 4, 7));\n+        return list;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class PseudoRow implements Serializable {\n+\n+        public int cols[] = new int[3];\n+\n+        public PseudoRow(int col1, int col2, int col3) {\n+            cols[0] = col1;\n+            cols[1] = col2;\n+            cols[2] = col3;\n+        }\n+\n+        public int getColumn(int colIndex) {\n+            return cols[colIndex];\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(\"[\");\n+            buf.append(cols[0]);\n+            buf.append(\",\");\n+            buf.append(cols[1]);\n+            buf.append(\",\");\n+            buf.append(cols[2]);\n+            buf.append(\"]\");\n+            return buf.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof PseudoRow)) {\n+                return false;\n+            }\n+\n+            PseudoRow row = (PseudoRow) o;\n+            if (getColumn(0) != row.getColumn(0)) {\n+                return false;\n+            }\n+\n+            if (getColumn(1) != row.getColumn(1)) {\n+                return false;\n+            }\n+\n+            if (getColumn(2) != row.getColumn(2)) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+    }\n+\n+    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {\n+        private static final long serialVersionUID = -2284880866328872105L;\n+\n+        protected int colIndex = 0;\n+\n+        public ColumnComparator(int colIndex) {\n+            this.colIndex = colIndex;\n+        }\n+\n+        public int compare(PseudoRow o1, PseudoRow o2) {\n+\n+            int col1 = o1.getColumn(colIndex);\n+            int col2 = o2.getColumn(colIndex);\n+\n+            if (col1 > col2) {\n+                return 1;\n+            }\n+            if (col1 < col2) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return colIndex;\n+        }\n+\n+        @Override\n+        public boolean equals(Object that) {\n+            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/FixedOrderComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test class for FixedOrderComparator.\n+ *\n+ * @version $Id$\n+ */\n+public class FixedOrderComparatorTest extends AbstractComparatorTest<String> {\n+\n+    /**\n+     * Top cities of the world, by population including metro areas.\n+     */\n+    private static final String topCities[] = new String[] {\n+        \"Tokyo\",\n+        \"Mexico City\",\n+        \"Mumbai\",\n+        \"Sao Paulo\",\n+        \"New York\",\n+        \"Shanghai\",\n+        \"Lagos\",\n+        \"Los Angeles\",\n+        \"Calcutta\",\n+        \"Buenos Aires\"\n+    };\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public FixedOrderComparatorTest(String name) {\n+        super(name);\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+    @Override\n+    public Comparator<String> makeObject() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        return comparator;\n+    }\n+\n+    @Override\n+    public List<String> getComparableObjectsOrdered() {\n+        return Arrays.asList(topCities);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    //\n+    // The tests\n+    //\n+\n+    /**\n+     * Tests that the constructor plus add method compares items properly.\n+     */\n+    @Test\n+    public void testConstructorPlusAdd() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n+        for (int i = 0; i < topCities.length; i++) {\n+            comparator.add(topCities[i]);\n+        }\n+        String[] keys = topCities.clone();\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests that the array constructor compares items properly.\n+     */\n+    @Test\n+    public void testArrayConstructor() {\n+        String[] keys = topCities.clone();\n+        String[] topCitiesForTest = topCities.clone();\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest[0] = \"Brighton\";\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests the list constructor.\n+     */\n+    @Test\n+    public void testListConstructor() {\n+        String[] keys = topCities.clone();\n+        List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest.set(0, \"Brighton\");\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests addAsEqual method.\n+     */\n+    @Test\n+    public void testAddAsEqual() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n+        assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n+    }\n+\n+    /**\n+     * Tests whether or not updates are disabled after a comparison is made.\n+     */\n+    @Test\n+    public void testLock() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        assertEquals(false, comparator.isLocked());\n+        comparator.compare(\"New York\", \"Tokyo\");\n+        assertEquals(true, comparator.isLocked());\n+        try {\n+            comparator.add(\"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+\n+        try {\n+            comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+    }\n+\n+    @Test\n+    public void testUnknownObjectBehavior() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        try {\n+            comparator.compare(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        try {\n+            comparator.compare(\"Minneapolis\", \"New York\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());\n+        LinkedList<String> keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.addFirst(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n+        keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.add(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+    }\n+\n+    //\n+    // Helper methods\n+    //\n+\n+    /** Shuffles the keys and asserts that the comparator sorts them back to\n+     * their original order.\n+     */\n+    private void assertComparatorYieldsOrder(String[] orderedObjects,\n+                                             Comparator<String> comparator) {\n+        String[] keys = orderedObjects.clone();\n+\n+        // shuffle until the order changes.  It's extremely rare that\n+        // this requires more than one shuffle.\n+\n+        boolean isInNewOrder = false;\n+        Random rand = new Random();\n+        while (keys.length > 1 && isInNewOrder == false) {\n+            // shuffle:\n+            for (int i = keys.length-1; i > 0; i--) {\n+                String swap = keys[i];\n+                int j = rand.nextInt(i+1);\n+                keys[i] = keys[j];\n+                keys[j] = swap;\n+            }\n+\n+            // testShuffle\n+            for (int i = 0; i < keys.length && !isInNewOrder; i++) {\n+                if( !orderedObjects[i].equals(keys[i])) {\n+                    isInNewOrder = true;\n+                }\n+            }\n+        }\n+\n+        // The real test:  sort and make sure they come out right.\n+\n+        Arrays.sort(keys, comparator);\n+\n+        for (int i = 0; i < orderedObjects.length; i++) {\n+            assertEquals(orderedObjects[i], keys[i]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/ReverseComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Tests for ReverseComparator.\n+ *\n+ * @version $Id$\n+ */\n+public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    public ReverseComparatorTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * For the purposes of this test, return a\n+     * ReverseComparator that wraps the java.util.Collections.reverseOrder()\n+     * Comparator.  The resulting comparator should\n+     * sort according to natural Order.  (Note: we wrap\n+     * a Comparator taken from the JDK so that we can\n+     * save a \"canonical\" form in SVN.\n+     *\n+     * @return Comparator that returns \"natural\" order\n+     */\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+        return new ReverseComparator<Integer>(Collections.<Integer>reverseOrder());\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n+        list.add(new Integer(1));\n+        list.add(new Integer(2));\n+        list.add(new Integer(3));\n+        list.add(new Integer(4));\n+        list.add(new Integer(5));\n+        return list;\n+    }\n+\n+    /**\n+     * Override this inherited test since Collections.reverseOrder\n+     * doesn't adhere to the \"soft\" Comparator contract, and we've\n+     * already \"cannonized\" the comparator returned by makeComparator.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Comparator comp = new ReverseComparator(new ComparableComparator());\n+\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(comp);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        Object dest = in.readObject();\n+        in.close();\n+        assertEquals(\"obj != deserialize(serialize(obj))\",comp,dest);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/TransformingComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections.TransformerUtils;\n+\n+/**\n+ * Test class for TransformingComparator.\n+ *\n+ * @version $Id$\n+ */\n+public class TransformingComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public TransformingComparatorTest(String name) {\n+        super(name);\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+       Comparator<Integer> decorated = new ComparableComparator<Integer>();\n+       TransformingComparator<Integer> comparator =\n+               new TransformingComparator<Integer>(TransformerUtils.<Integer>nopTransformer(), decorated);\n+       return comparator;\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        list.add(5);\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    //\n+    // The tests\n+    //\n+\n+}", "timestamp": 1343766209, "metainfo": ""}