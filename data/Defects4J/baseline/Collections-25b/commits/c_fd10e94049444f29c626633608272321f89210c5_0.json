{"sha": "fd10e94049444f29c626633608272321f89210c5", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r751871 | mbenson | 2009-03-09 15:13:34 -0700 (Mon, 09 Mar 2009) | 1 line          Add OrderedMap to our SortedMap implementations     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public class DualTreeBidiMap\n-        extends AbstractDualBidiMap implements SortedBidiMap, Serializable {\n+public class DualTreeBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements\n+        SortedBidiMap<K, V>, Serializable {\n \n     /** Ensure serialization compatibility */\n     private static final long serialVersionUID = 721969328361809L;\n-    /** The comparator to use */\n-    protected final Comparator comparator;\n+\n+    /** The key comparator to use */\n+    protected final Comparator<? super K> comparator;\n+\n+    /** The value comparator to use */\n+    protected final Comparator<? super V> valueComparator;\n     \n     /**\n      * Creates an empty <code>DualTreeBidiMap</code>\n      */\n     public DualTreeBidiMap() {\n-        super(new TreeMap(), new TreeMap());\n+        super(new TreeMap<K, V>(), new TreeMap<V, K>());\n         this.comparator = null;\n-    }\n-\n-    /** \n+        this.valueComparator = null;\n+    }\n+\n+    /**\n      * Constructs a <code>DualTreeBidiMap</code> and copies the mappings from\n-     * specified <code>Map</code>.  \n+     * specified <code>Map</code>.\n      *\n      * @param map  the map whose mappings are to be placed in this map\n      */\n-    public DualTreeBidiMap(Map map) {\n-        super(new TreeMap(), new TreeMap());\n+    public DualTreeBidiMap(Map<K, V> map) {\n+        super(new TreeMap<K, V>(), new TreeMap<V, K>());\n         putAll(map);\n         this.comparator = null;\n-    }\n-\n-    /** \n+        this.valueComparator = null;\n+    }\n+\n+    /**\n      * Constructs a <code>DualTreeBidiMap</code> using the specified Comparator.\n      *\n-     * @param comparator  the Comparator\n-     */\n-    public DualTreeBidiMap(Comparator comparator) {\n-        super(new TreeMap(comparator), new TreeMap(comparator));\n-        this.comparator = comparator;\n-    }\n-\n-    /** \n+     * @param keyComparator  the Comparator\n+     */\n+    public DualTreeBidiMap(Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {\n+        super(new TreeMap<K, V>(keyComparator), new TreeMap<V, K>(valueComparator));\n+        this.comparator = keyComparator;\n+        this.valueComparator = valueComparator;\n+    }\n+\n+    /**\n      * Constructs a <code>DualTreeBidiMap</code> that decorates the specified maps.\n      *\n      * @param normalMap  the normal direction map\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected DualTreeBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+    protected DualTreeBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n         super(normalMap, reverseMap, inverseBidiMap);\n-        this.comparator = ((SortedMap) normalMap).comparator();\n+        this.comparator = ((SortedMap<K, V>) normalMap).comparator();\n+        this.valueComparator = ((SortedMap<V, K>) reverseMap).comparator();\n     }\n \n     /**\n      * Creates a new instance of this object.\n-     * \n+     *\n      * @param normalMap  the normal direction map\n      * @param reverseMap  the reverse direction map\n      * @param inverseMap  the inverse BidiMap\n      * @return new bidi map\n      */\n-    protected BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseMap) {\n-        return new DualTreeBidiMap(normalMap, reverseMap, inverseMap);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public Comparator comparator() {\n-        return ((SortedMap) maps[0]).comparator();\n-    }\n-\n-    public Object firstKey() {\n-        return ((SortedMap) maps[0]).firstKey();\n-    }\n-\n-    public Object lastKey() {\n-        return ((SortedMap) maps[0]).lastKey();\n-    }\n-\n-    public Object nextKey(Object key) {\n+    protected DualTreeBidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap) {\n+        return new DualTreeBidiMap<V, K>(normalMap, reverseMap, inverseMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator<? super K> comparator() {\n+        return ((SortedMap<K, V>) normalMap).comparator();\n+    }\n+\n+    public Comparator<? super V> valueComparator() {\n+        return ((SortedMap<V, K>) reverseMap).comparator();\n+        \n+    }\n+\n+    public K firstKey() {\n+        return ((SortedMap<K, V>) normalMap).firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return ((SortedMap<K, V>) normalMap).lastKey();\n+    }\n+\n+    public K nextKey(K key) {\n         if (isEmpty()) {\n             return null;\n         }\n-        if (maps[0] instanceof OrderedMap) {\n-            return ((OrderedMap) maps[0]).nextKey(key);\n-        }\n-        SortedMap sm = (SortedMap) maps[0];\n-        Iterator it = sm.tailMap(key).keySet().iterator();\n+        if (normalMap instanceof OrderedMap) {\n+            return ((OrderedMap<K, ?>) normalMap).nextKey(key);\n+        }\n+        SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        Iterator<K> it = sm.tailMap(key).keySet().iterator();\n         it.next();\n         if (it.hasNext()) {\n             return it.next();\n         return null;\n     }\n \n-    public Object previousKey(Object key) {\n+    public K previousKey(K key) {\n         if (isEmpty()) {\n             return null;\n         }\n-        if (maps[0] instanceof OrderedMap) {\n-            return ((OrderedMap) maps[0]).previousKey(key);\n-        }\n-        SortedMap sm = (SortedMap) maps[0];\n-        SortedMap hm = sm.headMap(key);\n+        if (normalMap instanceof OrderedMap) {\n+            return ((OrderedMap<K, V>) normalMap).previousKey(key);\n+        }\n+        SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        SortedMap<K, V> hm = sm.headMap(key);\n         if (hm.isEmpty()) {\n             return null;\n         }\n      * <p>\n      * This implementation copies the elements to an ArrayList in order to\n      * provide the forward/backward behaviour.\n-     * \n+     *\n      * @return a new ordered map iterator\n      */\n-    public OrderedMapIterator orderedMapIterator() {\n-        return new BidiOrderedMapIterator(this);\n-    }\n-\n-    public SortedBidiMap inverseSortedBidiMap() {\n-        return (SortedBidiMap) inverseBidiMap();\n-    }\n-\n-    public OrderedBidiMap inverseOrderedBidiMap() {\n-        return (OrderedBidiMap) inverseBidiMap();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public SortedMap headMap(Object toKey) {\n-        SortedMap sub = ((SortedMap) maps[0]).headMap(toKey);\n-        return new ViewMap(this, sub);\n-    }\n-\n-    public SortedMap tailMap(Object fromKey) {\n-        SortedMap sub = ((SortedMap) maps[0]).tailMap(fromKey);\n-        return new ViewMap(this, sub);\n-    }\n-\n-    public SortedMap subMap(Object fromKey, Object toKey) {\n-        SortedMap sub = ((SortedMap) maps[0]).subMap(fromKey, toKey);\n-        return new ViewMap(this, sub);\n-    }\n-    \n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new BidiOrderedMapIterator<K, V>(this);\n+    }\n+\n+    public SortedBidiMap<V, K> inverseSortedBidiMap() {\n+        return (SortedBidiMap<V, K>) inverseBidiMap();\n+    }\n+\n+    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n+        return (OrderedBidiMap<V, K>) inverseBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        return (SortedBidiMap<V, K>) super.inverseBidiMap();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Internal sorted map view.\n      */\n-    protected static class ViewMap extends AbstractSortedMapDecorator {\n+    protected static class ViewMap<K, V> extends AbstractSortedMapDecorator<K, V> {\n         /** The parent bidi map. */\n-        final DualTreeBidiMap bidi;\n-        \n+        final DualTreeBidiMap<K, V> bidi;\n+\n         /**\n          * Constructor.\n          * @param bidi  the parent bidi map\n          * @param sm  the subMap sorted map\n          */\n-        protected ViewMap(DualTreeBidiMap bidi, SortedMap sm) {\n+        protected ViewMap(DualTreeBidiMap<K, V> bidi, SortedMap<K, V> sm) {\n             // the implementation is not great here...\n-            // use the maps[0] as the filtered map, but maps[1] as the full map\n+            // use the normalMap as the filtered map, but reverseMap as the full map\n             // this forces containsValue and clear to be overridden\n-            super((SortedMap) bidi.createBidiMap(sm, bidi.maps[1], bidi.inverseBidiMap));\n-            this.bidi = (DualTreeBidiMap) map;\n-        }\n-        \n+            super(new DualTreeBidiMap<K, V>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n+            this.bidi = (DualTreeBidiMap<K, V>) decorated();\n+        }\n+\n         public boolean containsValue(Object value) {\n-            // override as default implementation jumps to [1]\n-            return bidi.maps[0].containsValue(value);\n-        }\n-        \n+            // override as default implementation uses reverseMap\n+            return decorated().normalMap.containsValue(value);\n+        }\n+\n         public void clear() {\n-            // override as default implementation jumps to [1]\n-            for (Iterator it = keySet().iterator(); it.hasNext();) {\n+            // override as default implementation uses reverseMap\n+            for (Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                 it.next();\n                 it.remove();\n             }\n         }\n-        \n-        public SortedMap headMap(Object toKey) {\n-            return new ViewMap(bidi, super.headMap(toKey));\n-        }\n-\n-        public SortedMap tailMap(Object fromKey) {\n-            return new ViewMap(bidi, super.tailMap(fromKey));\n-        }\n-\n-        public SortedMap subMap(Object fromKey, Object toKey) {\n-            return new ViewMap(bidi, super.subMap(fromKey, toKey));\n-        }\n+\n+        public SortedMap<K, V> headMap(K toKey) {\n+            return new ViewMap<K, V>(decorated(), super.headMap(toKey));\n+        }\n+\n+        public SortedMap<K, V> tailMap(K fromKey) {\n+            return new ViewMap<K, V>(decorated(), super.tailMap(fromKey));\n+        }\n+\n+        public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+            return new ViewMap<K, V>(decorated(), super.subMap(fromKey, toKey));\n+        }\n+\n+        @Override\n+        protected DualTreeBidiMap<K, V> decorated() {\n+            return (DualTreeBidiMap<K, V>) super.decorated();\n+        }\n+\n+        public K previousKey(K key) {\n+            return decorated().previousKey(key);\n+        };\n+\n+        public K nextKey(K key) {\n+            return decorated().nextKey(key);\n+        };\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Inner class MapIterator.\n      */\n-    protected static class BidiOrderedMapIterator implements OrderedMapIterator, ResettableIterator {\n-        \n+    protected static class BidiOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n         /** The parent map */\n-        protected final AbstractDualBidiMap parent;\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n         /** The iterator being decorated */\n-        protected ListIterator iterator;\n+        protected ListIterator<Map.Entry<K, V>> iterator;\n+\n         /** The last returned entry */\n-        private Map.Entry last = null;\n-        \n+        private Map.Entry<K, V> last = null;\n+\n         /**\n          * Constructor.\n          * @param parent  the parent map\n          */\n-        protected BidiOrderedMapIterator(AbstractDualBidiMap parent) {\n+        protected BidiOrderedMapIterator(AbstractDualBidiMap<K, V> parent) {\n             super();\n             this.parent = parent;\n-            iterator = new ArrayList(parent.entrySet()).listIterator();\n-        }\n-        \n+            iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n+        }\n+\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n-        \n-        public Object next() {\n-            last = (Map.Entry) iterator.next();\n+\n+        public K next() {\n+            last = iterator.next();\n             return last.getKey();\n         }\n-        \n+\n         public boolean hasPrevious() {\n             return iterator.hasPrevious();\n         }\n-        \n-        public Object previous() {\n-            last = (Map.Entry) iterator.previous();\n+\n+        public K previous() {\n+            last = iterator.previous();\n             return last.getKey();\n         }\n-        \n+\n         public void remove() {\n             iterator.remove();\n             parent.remove(last.getKey());\n             last = null;\n         }\n-        \n-        public Object getKey() {\n+\n+        public K getKey() {\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n             }\n             return last.getKey();\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n             }\n             return last.getValue();\n         }\n-        \n-        public Object setValue(Object value) {\n+\n+        public V setValue(V value) {\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n             }\n-            if (parent.maps[1].containsKey(value) &&\n-                parent.maps[1].get(value) != last.getKey()) {\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != last.getKey()) {\n                 throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n             }\n             return parent.put(last.getKey(), value);\n         }\n-        \n+\n         public void reset() {\n-            iterator = new ArrayList(parent.entrySet()).listIterator();\n+            iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n             last = null;\n         }\n-        \n+\n         public String toString() {\n             if (last != null) {\n                 return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n-            } else {\n-                return \"MapIterator[]\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"MapIterator[]\";\n+        }\n+    }\n+\n     // Serialization\n     //-----------------------------------------------------------------------\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n-        out.writeObject(maps[0]);\n-    }\n-\n+        out.writeObject(normalMap);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        maps[0] = new TreeMap(comparator);\n-        maps[1] = new TreeMap(comparator);\n+        normalMap = new TreeMap(comparator);\n+        reverseMap = new TreeMap(comparator);\n         Map map = (Map) in.readObject();\n         putAll(map);\n     }", "timestamp": 1252994061, "metainfo": ""}