{"sha": "81f6b79a484d2821fc5acb3fd679e5953845c269", "log": "Added new ReferenceMap class. PR:9571 Obtained from: Submitted by: Reviewed by:   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ReferenceMap.java\n+package org.apache.commons.collections;\n+\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+\n+/**\n+ *  Hashtable-based {@link Map} implementation that allows\n+ *  mappings to be removed by the garbage collector.<P>\n+ *\n+ *  When you construct a <Code>ReferenceMap</Code>, you can \n+ *  specify what kind of references are used to store the\n+ *  map's keys and values.  If non-hard references are \n+ *  used, then the garbage collector can remove mappings\n+ *  if a key or value becomes unreachable, or if the \n+ *  JVM's memory is running low.  For information on how\n+ *  the different reference types behave, see\n+ *  {@link Reference}.<P>\n+ *\n+ *  Different types of references can be specified for keys\n+ *  and values.  The keys can be configured to be weak but\n+ *  the values hard, in which case this class will behave\n+ *  like a {@link java.util.WeakHashMap}.  However, you\n+ *  can also specify hard keys and weak values, or any other\n+ *  combination.  The default constructor uses hard keys\n+ *  and soft values, providing a memory-sensitive cache.<P>\n+ *\n+ *  The algorithms used are basically the same as those\n+ *  in {@link java.util.HashMap}.  In particular, you \n+ *  can specify a load factor and capacity to suit your\n+ *  needs.  All optional {@link Map} operations are \n+ *  supported.<P>\n+ *\n+ *  However, this {@link Map} implementation does <I>not</I>\n+ *  allow null elements.  Attempting to add a null key or\n+ *  or a null value to the map will raise a \n+ *  <Code>NullPointerException</Code>.<P>\n+ *\n+ *  As usual, this implementation is not synchronized.  You\n+ *  can use {@link java.util.Collections#synchronizedMap} to \n+ *  provide synchronized access to a <Code>ReferenceMap</Code>.\n+ *\n+ *  @author Paul Jack \n+ *  @see java.lang.ref.Reference\n+ */\n+public class ReferenceMap extends AbstractMap implements Serializable {\n+\n+\n+    /**\n+     *  Constant indicating that hard references should be used.\n+     */\n+    final public static int HARD = 0;\n+\n+\n+    /**\n+     *  Constant indiciating that soft references should be used.\n+     */\n+    final public static int SOFT = 1;\n+\n+\n+    /**\n+     *  Constant indicating that weak references should be used.\n+     */\n+    final public static int WEAK = 2;\n+\n+\n+    // --- serialized instance variables:\n+\n+\n+    /**\n+     *  The reference type for keys.  Must be HARD, SOFT, WEAK.\n+     *  Note: I originally marked this field as final, but then this class\n+     *   didn't compile under JDK1.2.2.\n+     *  @serial\n+     */\n+    private int keyType;\n+\n+\n+    /**\n+     *  The reference type for values.  Must be HARD, SOFT, WEAK.\n+     *  Note: I originally marked this field as final, but then this class\n+     *   didn't compile under JDK1.2.2.\n+     *  @serial\n+     */\n+    private int valueType;\n+\n+\n+    /**\n+     *  The threshold variable is calculated by multiplying\n+     *  table.length and loadFactor.  \n+     *  Note: I originally marked this field as final, but then this class\n+     *   didn't compile under JDK1.2.2.\n+     *  @serial\n+     */\n+    private float loadFactor;\n+\n+\n+    // -- Non-serialized instance variables\n+\n+    /**\n+     *  ReferenceQueue used to eliminate stale mappings.\n+     *  @see #purge\n+     */\n+    private transient ReferenceQueue queue = new ReferenceQueue();\n+\n+\n+    /**\n+     *  The hash table.  Its length is always a power of two.  \n+     */\n+    private transient Entry[] table;\n+\n+\n+    /**\n+     *  Number of mappings in this map.\n+     */\n+    private transient int size;\n+\n+\n+    /**\n+     *  When size reaches threshold, the map is resized.  \n+     *  @see resize\n+     */\n+    private transient int threshold;\n+\n+\n+    /**\n+     *  Number of times this map has been modified.\n+     */\n+    private transient volatile int modCount;\n+\n+\n+    /**\n+     *  Cached key set.  May be null if key set is never accessed.\n+     */\n+    private transient Set keySet;\n+\n+\n+    /**\n+     *  Cached entry set.  May be null if entry set is never accessed.\n+     */\n+    private transient Set entrySet;\n+\n+\n+    /**\n+     *  Cached values.  May be null if values() is never accessed.\n+     */\n+    private transient Collection values;\n+\n+\n+    /**\n+     *  Constructs a new <Code>ReferenceMap</Code> that will\n+     *  use hard references to keys and soft references to values.\n+     */\n+    public ReferenceMap() {\n+        this(HARD, SOFT);\n+    }\n+\n+\n+    /**\n+     *  Constructs a new <Code>ReferenceMap</Code> that will\n+     *  use the specified types of references.\n+     *\n+     *  @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link WEAK}\n+     *  @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link WEAK}\n+     */\n+    public ReferenceMap(int keyType, int valueType) {\n+        this(keyType, valueType, 16, 0.75f);\n+    }\n+\n+\n+    /**\n+     *  Constructs a new <Code>ReferenceMap</Code> with the\n+     *  specified reference types, load factor and initial\n+     *  capacity.\n+     *\n+     *  @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link WEAK}\n+     *  @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link WEAK}\n+     *  @param capacity  the initial capacity for the map\n+     *  @param loadFactor  the load factor for the map\n+     */\n+    public ReferenceMap(int keyType, int valueType, int capacity, float loadFactor) {\n+        super();\n+\n+        verify(\"keyType\", keyType);\n+        verify(\"valueType\", valueType);\n+\n+        if (capacity <= 0) {\n+            throw new IllegalArgumentException(\"capacity must be positive\");\n+        }\n+        if ((loadFactor <= 0.0f) || (loadFactor >= 1.0f)) {\n+            throw new IllegalArgumentException(\"Load factor must be greater than 0 and less than 1.\");\n+        }\n+\n+        this.keyType = keyType;\n+        this.valueType = valueType;\n+\n+        int v = 1;\n+        while (v < capacity) v *= 2;\n+\n+        this.table = new Entry[v];\n+        this.loadFactor = loadFactor;\n+        this.threshold = (int)(v * loadFactor);\n+    }\n+\n+\n+    // used by constructor\n+    private static void verify(String name, int type) {\n+        if ((type < HARD) || (type > WEAK)) {\n+            throw new IllegalArgumentException(name + \n+               \" must be HARD, SOFT, WEAK.\");\n+        }\n+    }\n+\n+\n+    /**\n+     *  Writes this object to the given output stream.\n+     *\n+     *  @param out  the output stream to write to\n+     *  @throws IOException  if the stream raises it\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(table.length);\n+\n+        // Have to use null-terminated list because size might shrink\n+        // during iteration\n+\n+        for (Iterator iter = entrySet().iterator(); iter.hasNext();) {\n+            Map.Entry entry = (Map.Entry)iter.next();\n+            out.writeObject(entry.getKey());\n+            out.writeObject(entry.getValue());\n+        }\n+        out.writeObject(null);\n+    }\n+\n+\n+    /**\n+     *  Reads the contents of this object from the given input stream.\n+     *\n+     *  @param inp  the input stream to read from\n+     *  @throws IOException  if the stream raises it\n+     *  @throws ClassNotFoundException  if the stream raises it\n+     */\n+    private void readObject(ObjectInputStream inp) throws IOException, ClassNotFoundException {\n+        inp.defaultReadObject();\n+        table = new Entry[inp.readInt()];\n+        threshold = (int)(table.length * loadFactor);\n+        queue = new ReferenceQueue();\n+        Object key = inp.readObject();\n+        while (key != null) {\n+            Object value = inp.readObject();\n+            put(key, value);\n+            key = inp.readObject();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Constructs a reference of the given type to the given \n+     *  referent.  The reference is registered with the queue\n+     *  for later purging.\n+     *\n+     *  @param type  HARD, SOFT or WEAK\n+     *  @param referent  the object to refer to\n+     *  @param hash  the hash code of the <I>key</I> of the mapping;\n+     *    this number might be different from referent.hashCode() if\n+     *    the referent represents a value and not a key\n+     */\n+    private Object toReference(int type, Object referent, int hash) {\n+        switch (type) {\n+            case HARD: return referent;\n+            case SOFT: return new SoftRef(hash, referent, queue);\n+            case WEAK: return new WeakRef(hash, referent, queue);\n+            default: throw new Error();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns the entry associated with the given key.\n+     *\n+     *  @param key  the key of the entry to look up\n+     *  @return  the entry associated with that key, or null\n+     *    if the key is not in this map\n+     */\n+    private Entry getEntry(Object key) {\n+        if (key == null) return null;\n+        int hash = key.hashCode();\n+        int index = indexFor(hash);\n+        for (Entry entry = table[index]; entry != null; entry = entry.next) {\n+            if ((entry.hash == hash) && key.equals(entry.getKey())) {\n+                return entry;\n+            }\n+        }\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Converts the given hash code into an index into the\n+     *  hash table.\n+     */\n+    private int indexFor(int hash) {\n+        // mix the bits to avoid bucket collisions...\n+        hash += ~(hash << 15);\n+        hash ^= (hash >>> 10);\n+        hash += (hash << 3);\n+        hash ^= (hash >>> 6);\n+        hash += ~(hash << 11);\n+        hash ^= (hash >>> 16);\n+        return hash & (table.length - 1);\n+    }\n+\n+\n+\n+    /**\n+     *  Resizes this hash table by doubling its capacity.\n+     *  This is an expensive operation, as entries must\n+     *  be copied from the old smaller table to the new \n+     *  bigger table.\n+     */\n+    private void resize() {\n+        Entry[] old = table;\n+        table = new Entry[old.length * 2];\n+\n+        for (int i = 0; i < old.length; i++) {\n+            Entry next = old[i];\n+            while (next != null) {\n+                Entry entry = next;\n+                next = next.next;\n+                int index = indexFor(entry.hash);\n+                entry.next = table[index];\n+                table[index] = entry;\n+            }\n+            old[i] = null;\n+        }\n+        threshold = (int)(table.length * loadFactor);\n+    }\n+\n+\n+\n+    /**\n+     *  Purges stale mappings from this map.<P>\n+     *\n+     *  Ordinarily, stale mappings are only removed during\n+     *  a write operation; typically a write operation will    \n+     *  occur often enough that you'll never need to manually\n+     *  invoke this method.<P>\n+     *\n+     *  Note that this method is not synchronized!  Special\n+     *  care must be taken if, for instance, you want stale\n+     *  mappings to be removed on a periodic basis by some\n+     *  background thread.\n+     */\n+    private void purge() {\n+        Reference ref = queue.poll();\n+        while (ref != null) {\n+            purge(ref);\n+            ref = queue.poll();\n+        }\n+    }\n+\n+\n+    private void purge(Reference ref) {\n+        // The hashCode of the reference is the hashCode of the\n+        // mapping key, even if the reference refers to the \n+        // mapping value...\n+        int hash = ref.hashCode();\n+        int index = indexFor(hash);\n+        Entry previous = null;\n+        Entry entry = table[index];\n+        while (entry != null) {\n+            if (entry.purge(ref)) {\n+                if (previous == null) table[index] = entry.next;\n+                else previous.next = entry.next;\n+                this.size--;\n+                return;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Returns the size of this map.\n+     *\n+     *  @return  the size of this map\n+     */\n+    public int size() {\n+        purge();\n+        return size;\n+    }\n+\n+\n+    /**\n+     *  Returns <Code>true</Code> if this map is empty.\n+     *\n+     *  @return <Code>true</Code> if this map is empty\n+     */\n+    public boolean isEmpty() {\n+        purge();\n+        return size == 0;\n+    }\n+\n+\n+    /**\n+     *  Returns <Code>true</Code> if this map contains the given key.\n+     *\n+     *  @return true if the given key is in this map\n+     */\n+    public boolean containsKey(Object key) {\n+        purge();\n+        Entry entry = getEntry(key);\n+        if (entry == null) return false;\n+        return entry.getValue() != null;\n+    }\n+\n+\n+    /**\n+     *  Returns the value associated with the given key, if any.\n+     *\n+     *  @return the value associated with the given key, or <Code>null</Code>\n+     *   if the key maps to no value\n+     */\n+    public Object get(Object key) {\n+        purge();\n+        Entry entry = getEntry(key);\n+        if (entry == null) return null;\n+        return entry.getValue();\n+    }\n+\n+\n+    /**\n+     *  Associates the given key with the given value.<P>\n+     *  Neither the key nor the value may be null.\n+     *\n+     *  @param key  the key of the mapping\n+     *  @param value  the value of the mapping\n+     *  @return  the last value associated with that key, or \n+     *   null if no value was associated with the key\n+     *  @throws NullPointerException if either the key or value\n+     *   is null\n+     */\n+    public Object put(Object key, Object value) {\n+        if (key == null) throw new NullPointerException(\"null keys not allowed\");\n+        if (value == null) throw new NullPointerException(\"null values not allowed\");\n+\n+        purge();\n+        if (size + 1 > threshold) resize();\n+\n+        int hash = key.hashCode();\n+        int index = indexFor(hash);\n+        Entry entry = table[index];\n+        while (entry != null) {\n+            if ((hash == entry.hash) && key.equals(entry.getKey())) {\n+                Object result = entry.getValue();\n+                entry.setValue(value);\n+                return result;\n+            }\n+            entry = entry.next;\n+        }\n+        this.size++; \n+        modCount++;\n+        key = toReference(keyType, key, hash);\n+        value = toReference(valueType, value, hash);\n+        table[index] = new Entry(key, hash, value, table[index]);\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Removes the key and its associated value from this map.\n+     *\n+     *  @param key  the key to remove\n+     *  @return the value associated with that key, or null if\n+     *   the key was not in the map\n+     */\n+    public Object remove(Object key) {\n+        if (key == null) return null;\n+        purge();\n+        int hash = key.hashCode();\n+        int index = indexFor(hash);\n+        Entry previous = null;\n+        Entry entry = table[index];\n+        while (entry != null) {\n+            if ((hash == entry.hash) && key.equals(entry.getKey())) {\n+                if (previous == null) table[index] = entry.next;\n+                else previous.next = entry.next;\n+                this.size--;\n+                modCount++;\n+                return entry.getValue();\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Clears this map.\n+     */\n+    public void clear() {\n+        Arrays.fill(table, null);\n+        size = 0;\n+        while (queue.poll() != null); // drain the queue\n+    }\n+\n+\n+    /**\n+     *  Returns a set view of this map's entries.\n+     *\n+     *  @return a set view of this map's entries\n+     */\n+    public Set entrySet() {\n+        if (entrySet != null) return entrySet;\n+        entrySet = new AbstractSet() {\n+            public int size() {\n+                return ReferenceMap.this.size();\n+            }\n+\n+\n+            public void clear() {\n+                ReferenceMap.this.clear();\n+            }\n+\n+\n+            public boolean contains(Object o) {\n+                if (o == null) return false;\n+                if (!(o instanceof Map.Entry)) return false;\n+                Map.Entry e = (Map.Entry)o;\n+                Entry e2 = getEntry(e.getKey());\n+                return (e2 != null) && e.equals(e2);\n+            }\n+\n+\n+            public boolean remove(Object o) {\n+                boolean r = contains(o);\n+                if (r) {\n+                    Map.Entry e = (Map.Entry)o;\n+                    ReferenceMap.this.remove(e.getKey());\n+                }\n+                return r;\n+            }\n+\n+\n+            public Iterator iterator() {\n+                return new EntryIterator();\n+            }\n+\n+            public Object[] toArray() {\n+                return toArray(new Object[0]);\n+            }\n+\n+\n+            public Object[] toArray(Object[] arr) {\n+                ArrayList list = new ArrayList();\n+                Iterator iterator = iterator();\n+                while (iterator.hasNext()) {\n+                    Entry e = (Entry)iterator.next();\n+                    list.add(new DefaultMapEntry(e.getKey(), e.getValue()));\n+                }\n+                return list.toArray(arr);\n+            }\n+        };\n+        return entrySet;\n+    }\n+\n+\n+    /**\n+     *  Returns a set view of this map's keys.\n+     *\n+     *  @return a set view of this map's keys\n+     */\n+    public Set keySet() {\n+        if (keySet != null) return keySet;\n+        keySet = new AbstractSet() {\n+            public int size() {\n+                return size;\n+            }\n+\n+            public Iterator iterator() {\n+                return new KeyIterator();\n+            }\n+\n+            public boolean contains(Object o) {\n+                return containsKey(o);\n+            }\n+\n+\n+            public boolean remove(Object o) {\n+                Object r = ReferenceMap.this.remove(o);\n+                return r != null;\n+            }\n+\n+            public void clear() {\n+                ReferenceMap.this.clear();\n+            }\n+\n+        };\n+        return keySet;\n+    }\n+\n+\n+    /**\n+     *  Returns a collection view of this map's values.\n+     *\n+     *  @return a collection view of this map's values.\n+     */\n+    public Collection values() {\n+        if (values != null) return values;\n+        values = new AbstractCollection()  {\n+            public int size() {\n+                return size;\n+            }\n+\n+            public void clear() {\n+                ReferenceMap.this.clear();\n+            }\n+\n+            public Iterator iterator() {\n+                return new ValueIterator();\n+            }\n+        };\n+        return values;\n+    }\n+\n+\n+    // If getKey() or getValue() returns null, it means\n+    // the mapping is stale and should be removed.\n+    private class Entry implements Map.Entry {\n+\n+        Object key;\n+        Object value;\n+        int hash;\n+        Entry next;\n+\n+\n+        public Entry(Object key, int hash, Object value, Entry next) {\n+            this.key = key;\n+            this.hash = hash;\n+            this.value = value;\n+            this.next = next;\n+        }\n+\n+\n+        public Object getKey() {\n+            return (keyType > HARD) ? ((Reference)key).get() : key;\n+        }\n+\n+\n+        public Object getValue() {\n+            return (valueType > HARD) ? ((Reference)value).get() : value;\n+        }\n+\n+\n+        public Object setValue(Object object) {\n+            Object old = getValue();\n+            if (valueType > HARD) ((Reference)value).clear();\n+            value = toReference(valueType, object, hash);\n+            return old;\n+        }\n+\n+\n+        public boolean equals(Object o) {\n+            if (o == null) return false;\n+            if (o == this) return true;\n+            if (!(o instanceof Map.Entry)) return false;\n+            \n+            Map.Entry entry = (Map.Entry)o;\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+            if ((key == null) || (value == null)) return false;\n+            return key.equals(getKey()) && value.equals(getValue());\n+        }\n+\n+\n+        public int hashCode() {\n+            Object v = getValue();\n+            return hash ^ ((v == null) ? 0 : v.hashCode());\n+        }\n+\n+\n+        public String toString() {\n+            return getKey() + \"=\" + getValue();\n+        }\n+\n+\n+        boolean purge(Reference ref) {\n+            boolean r = (keyType > HARD) && (key == ref);\n+            r = r || ((valueType > HARD) && (value == ref));\n+            if (r) {\n+                if (keyType > HARD) ((Reference)key).clear();\n+                if (valueType > HARD) ((Reference)value).clear();\n+            }\n+            return r;\n+        }\n+    }\n+\n+\n+    private class EntryIterator implements Iterator {\n+        // These fields keep track of where we are in the table.\n+        int index;\n+        Entry entry;\n+        Entry previous;\n+\n+        // These Object fields provide hard references to the\n+        // current and next entry; this assures that if hasNext()\n+        // returns true, next() will actually return a valid element.\n+        Object nextKey, nextValue;\n+        Object currentKey, currentValue;\n+\n+        int expectedModCount;\n+\n+\n+        public EntryIterator() {\n+            index = (size() != 0 ? table.length : 0);\n+            // have to do this here!  size() invocation above\n+            // may have altered the modCount.\n+            expectedModCount = modCount;\n+        }\n+\n+\n+        public boolean hasNext() {\n+            checkMod();\n+            while (nextNull()) {\n+                Entry e = entry;\n+                int i = index;\n+                while ((e == null) && (i > 0)) {\n+                    i--;\n+                    e = table[i];\n+                }\n+                entry = e;\n+                index = i;\n+                if (e == null) {\n+                    currentKey = null;\n+                    currentValue = null;\n+                    return false;\n+                }\n+                nextKey = e.getKey();\n+                nextValue = e.getValue();\n+                if (nextNull()) entry = entry.next;\n+            }\n+            return true;\n+        }\n+\n+\n+        private void checkMod() {\n+            if (modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+\n+        private boolean nextNull() {\n+            return (nextKey == null) || (nextValue == null);\n+        }\n+\n+        protected Entry nextEntry() {    \n+            checkMod();\n+            if (nextNull() && !hasNext()) throw new NoSuchElementException();\n+            previous = entry;\n+            entry = entry.next;\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+            nextKey = null;\n+            nextValue = null;\n+            return previous;\n+        }\n+\n+\n+        public Object next() {\n+            return nextEntry();\n+        }\n+\n+\n+        public void remove() {\n+            checkMod();\n+            if (previous == null) throw new IllegalStateException();\n+            ReferenceMap.this.remove(currentKey);\n+            previous = null;\n+            currentKey = null;\n+            currentValue = null;\n+            expectedModCount = modCount;\n+        }\n+\n+    }\n+\n+\n+    private class ValueIterator extends EntryIterator {\n+        public Object next() {\n+            return nextEntry().getValue();\n+        }\n+    }\n+\n+\n+    private class KeyIterator extends EntryIterator {\n+        public Object next() {\n+            return nextEntry().getKey();\n+        }\n+    }\n+\n+\n+\n+    // These two classes store the hashCode of the key of\n+    // of the mapping, so that after they're dequeued a quick\n+    // lookup of the bucket in the table can occur.\n+\n+\n+    private static class SoftRef extends SoftReference {\n+        private int hash;\n+\n+\n+        public SoftRef(int hash, Object r, ReferenceQueue q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+\n+    private static class WeakRef extends WeakReference {\n+        private int hash;\n+\n+\n+        public WeakRef(int hash, Object r, ReferenceQueue q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.30 2002/07/09 16:48:56 rwaldhoff Exp $\n- * $Revision: 1.30 $\n- * $Date: 2002/07/09 16:48:56 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.31 2002/08/12 18:13:09 pjack Exp $\n+ * $Revision: 1.31 $\n+ * $Date: 2002/08/12 18:13:09 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.30 2002/07/09 16:48:56 rwaldhoff Exp $\n+ * @version $Id: TestAll.java,v 1.31 2002/08/12 18:13:09 pjack Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestTreeBag.suite());\n         suite.addTest(TestUnboundedFifoBuffer.suite());\n         suite.addTest(TestUniqueFilterIterator.suite());\n+        suite.addTest(TestReferenceMap.suite());\n         suite.addTest(org.apache.commons.collections.primitives.TestAll.suite());\n         return suite;\n     }\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestReferenceMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestReferenceMap.java,v 1.1 2002/08/12 18:13:09 pjack Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/12 18:13:09 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\n+/**\n+ * Tests for ReferenceMap. \n+ *\n+ * @author Paul Jack\n+ * @version $Id: TestReferenceMap.java,v 1.1 2002/08/12 18:13:09 pjack Exp $\n+ */\n+public class TestReferenceMap extends TestMap {\n+\n+\n+    private static Random random = new Random();\n+\n+\n+    private Object[] hardKeys;\n+    private Object[] hardValues;\n+    private HashMap refs = new HashMap();\n+    \n+\n+    public TestReferenceMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestReferenceMap.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestReferenceMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        return map;\n+    }\n+\n+    public boolean useNullKey() {\n+        return false;\n+    }\n+\n+    public boolean useNullValue() {\n+        return false;\n+    }\n+\n+\n+/*\n+   // Unfortunately, these tests all rely on System.gc(), which is\n+   // not reliable across platforms.  Not sure how to code the tests\n+   // without using System.gc() though...\n+   // They all passed on my platform though. :)\n+\n+    public void testPurge() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        System.gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        System.gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        System.gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        System.gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        System.gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+\n+/*\n+    // Uncomment to create test files in /data/test\n+    public void testCreateTestFiles() throws Exception {\n+        ReferenceMap m = (ReferenceMap)makeEmptyMap();\n+        writeExternalFormToDisk(m, getCanonicalEmptyCollectionName(m));\n+        m = (ReferenceMap)makeFullMap();\n+        writeExternalFormToDisk(m, getCanonicalFullCollectionName(m));\n+    }\n+*/\n+\n+\n+    public int getCompatibilityVersion() {\n+        return 2; // actually 2.1, but can't represent that as an int\n+    }\n+\n+\n+}", "timestamp": 1029175989, "metainfo": ""}