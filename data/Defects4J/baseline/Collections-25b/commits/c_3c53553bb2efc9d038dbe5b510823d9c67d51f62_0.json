{"sha": "3c53553bb2efc9d038dbe5b510823d9c67d51f62", "log": "fixed funky line feeds and indicated that MultiHashMap is new to Collections 2.x   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestMultiHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestMultiHashMap.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/02/22 02:18:50 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n-\n-package org.apache.commons.collections;\n-\n-import java.util.*;\n-\n-import junit.framework.Test;\n-import junit.framework.TestCase;\n-import junit.framework.TestSuite;\n-\n-\n-/**\n- * Unit Tests for <code>MultiHashMap</code>.\n- *\n- */\n-public class TestMultiHashMap extends TestMap\n-{\n-    public TestMultiHashMap(String testName)\n-    {\n-        super(testName);\n-    }\n-\n-    public static Test suite()\n-    {\n-        return new TestSuite(TestMultiHashMap.class);\n-    }\n-\n-    public static void main(String args[])\n-    {\n-        String[] testCaseName = { TestMultiHashMap.class.getName() };\n-        junit.textui.TestRunner.main(testCaseName);\n-    }\n-\n-    public Map makeEmptyMap() {\n-        return new MultiHashMap();\n-    }\n-    \n-    //----------------------------\n-    //          Tests\n-    //----------------------------\n-    public void testPutNGet()\n-    {\n-        MultiHashMap map = new MultiHashMap();\n-        loadMap( map );\n-        checkMap( map );\n-        \n-        assertTrue( map.get(new Integer(99)) == null );\n-        \n-        map.clear();\n-        assertTrue( map.size() == 0 );\n-    }\n-    \n-    public void testContainsValue()\n-    {\n-        MultiHashMap map = new MultiHashMap();\n-        loadMap( map );\n-        \n-        assertTrue( map.containsValue( \"uno\" ) );\n-        assertTrue( map.containsValue( \"quatro\" ) );\n-        assertTrue( map.containsValue( \"two\" ) );\n-        \n-        assertTrue( ! map.containsValue( \"uggaBugga\" ) );\n-        \n-        map.clear();\n-    }\n-    \n-    public void testValues()\n-    {\n-        MultiHashMap map = new MultiHashMap();\n-        loadMap( map );\n-        \n-        Collection vals = map.values();\n-        assertTrue( vals.size() == getFullSize() );\n-        \n-        map.clear();\n-    }\n-\n-    \n-    static private class MapPair\n-    {\n-        MapPair( int key, String val )\n-        {\n-            mKey = new Integer( key );\n-            mValue = val;\n-        }\n-        \n-        Integer mKey = null;\n-        String mValue = null;\n-    }\n-    \n-    static private MapPair[][] sMapPairs =\n-    {\n-        {new MapPair(0,\"zero\")},\n-        {new MapPair(1,\"one\"), new MapPair(1,\"ONE\"), new MapPair(1,\"uno\")},\n-        {new MapPair(2,\"two\"), new MapPair(2,\"two\") },\n-        {new MapPair(3,\"three\"), new MapPair(3,\"THREE\"), new MapPair(3,\"tres\")},\n-        {new MapPair(4,\"four\"), new MapPair(4,\"quatro\")}\n-    };\n-    \n-    private void loadMap( MultiHashMap map )\n-    {\n-        // Set up so that we load the keys \"randomly\"\n-        // (i.e. we don't want to load int row-order, so that all like keys\n-        // load together. We want to mix it up...)\n-        \n-        int numRows = sMapPairs.length;\n-        int maxCols = 0;\n-        for( int ii=0; ii < sMapPairs.length; ii++ ){\n-            if ( sMapPairs[ii].length > maxCols )\n-                maxCols = sMapPairs[ii].length;\n-        }\n-        for( int ii=0; ii < maxCols; ii++ ){\n-            for( int jj=0; jj < numRows; jj++ ){\n-                if ( ii < sMapPairs[jj].length ) {\n-                    map.put( sMapPairs[jj][ii].mKey, sMapPairs[jj][ii].mValue);\n-                    //---------------------------------------------------------\n-                }\n-            }\n-        }\n-        assertTrue( map.size() == sMapPairs.length );\n-    }\n-    \n-    private void checkMap( MultiHashMap map )\n-    {\n-        for( int ii=0; ii < sMapPairs.length; ii++ ){\n-            checkKeyList( map, ii );\n-        }\n-    }\n-    \n-    private void checkKeyList( MultiHashMap map, int index )\n-    {\n-        assertTrue( index < sMapPairs.length );\n-        Integer key = sMapPairs[index][0].mKey ;\n-        \n-        Object obj = map.get( key );\n-        //--------------------------\n-        \n-        assertTrue( obj != null );\n-        assertTrue( obj instanceof Collection );\n-        Collection keyList = (Collection)obj;\n-        \n-        assertTrue( keyList.size()  == sMapPairs[index].length );\n-        Iterator iter = keyList.iterator();\n-        while ( iter.hasNext() ) {\n-            Object oval = iter.next();\n-            assertTrue( oval != null );\n-            assertTrue( oval instanceof String );\n-            String val = (String)oval;\n-            boolean foundIt = false;\n-            for( int ii=0; ii < sMapPairs[index].length; ii++ ){\n-                if( val.equals( sMapPairs[index][ii].mValue ) )\n-                    foundIt = true;\n-            }\n-            assertTrue( foundIt );\n-        }\n-    }\n-    \n-    public int getFullSize()\n-    {\n-        int len = 0;\n-        for( int ii=0; ii < sMapPairs.length; ii++ ){\n-            len += sMapPairs[ii].length;\n-        }\n-        return len;\n-    }\n-    \n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.3 2002/02/26 00:13:37 morgand Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/26 00:13:37 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import java.util.*;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+\n+/**\n+ * Unit Tests for <code>MultiHashMap</code>.\n+ *\n+ */\n+public class TestMultiHashMap extends TestMap\n+{\n+    public TestMultiHashMap(String testName)\n+    {\n+        super(testName);\n+    }\n+\n+    public static Test suite()\n+    {\n+        return new TestSuite(TestMultiHashMap.class);\n+    }\n+\n+    public static void main(String args[])\n+    {\n+        String[] testCaseName = { TestMultiHashMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    // MutltiHashMap was introduced in Collections 2.x\n+    public int getCompatibilityVersion() {\n+        return 2;\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new MultiHashMap();\n+    }\n+    \n+    //----------------------------\n+    //          Tests\n+    //----------------------------\n+    public void testPutNGet()\n+    {\n+        MultiHashMap map = new MultiHashMap();\n+        loadMap( map );\n+        checkMap( map );\n+        \n+        assertTrue( map.get(new Integer(99)) == null );\n+        \n+        map.clear();\n+        assertTrue( map.size() == 0 );\n+    }\n+    \n+    public void testContainsValue()\n+    {\n+        MultiHashMap map = new MultiHashMap();\n+        loadMap( map );\n+        \n+        assertTrue( map.containsValue( \"uno\" ) );\n+        assertTrue( map.containsValue( \"quatro\" ) );\n+        assertTrue( map.containsValue( \"two\" ) );\n+        \n+        assertTrue( ! map.containsValue( \"uggaBugga\" ) );\n+        \n+        map.clear();\n+    }\n+    \n+    public void testValues()\n+    {\n+        MultiHashMap map = new MultiHashMap();\n+        loadMap( map );\n+        \n+        Collection vals = map.values();\n+        assertTrue( vals.size() == getFullSize() );\n+        \n+        map.clear();\n+    }\n+\n+    \n+    static private class MapPair\n+    {\n+        MapPair( int key, String val )\n+        {\n+            mKey = new Integer( key );\n+            mValue = val;\n+        }\n+        \n+        Integer mKey = null;\n+        String mValue = null;\n+    }\n+    \n+    static private MapPair[][] sMapPairs =\n+    {\n+        {new MapPair(0,\"zero\")},\n+        {new MapPair(1,\"one\"), new MapPair(1,\"ONE\"), new MapPair(1,\"uno\")},\n+        {new MapPair(2,\"two\"), new MapPair(2,\"two\") },\n+        {new MapPair(3,\"three\"), new MapPair(3,\"THREE\"), new MapPair(3,\"tres\")},\n+        {new MapPair(4,\"four\"), new MapPair(4,\"quatro\")}\n+    };\n+    \n+    private void loadMap( MultiHashMap map )\n+    {\n+        // Set up so that we load the keys \"randomly\"\n+        // (i.e. we don't want to load int row-order, so that all like keys\n+        // load together. We want to mix it up...)\n+        \n+        int numRows = sMapPairs.length;\n+        int maxCols = 0;\n+        for( int ii=0; ii < sMapPairs.length; ii++ ){\n+            if ( sMapPairs[ii].length > maxCols )\n+                maxCols = sMapPairs[ii].length;\n+        }\n+        for( int ii=0; ii < maxCols; ii++ ){\n+            for( int jj=0; jj < numRows; jj++ ){\n+                if ( ii < sMapPairs[jj].length ) {\n+                    map.put( sMapPairs[jj][ii].mKey, sMapPairs[jj][ii].mValue);\n+                    //---------------------------------------------------------\n+                }\n+            }\n+        }\n+        assertTrue( map.size() == sMapPairs.length );\n+    }\n+    \n+    private void checkMap( MultiHashMap map )\n+    {\n+        for( int ii=0; ii < sMapPairs.length; ii++ ){\n+            checkKeyList( map, ii );\n+        }\n+    }\n+    \n+    private void checkKeyList( MultiHashMap map, int index )\n+    {\n+        assertTrue( index < sMapPairs.length );\n+        Integer key = sMapPairs[index][0].mKey ;\n+        \n+        Object obj = map.get( key );\n+        //--------------------------\n+        \n+        assertTrue( obj != null );\n+        assertTrue( obj instanceof Collection );\n+        Collection keyList = (Collection)obj;\n+        \n+        assertTrue( keyList.size()  == sMapPairs[index].length );\n+        Iterator iter = keyList.iterator();\n+        while ( iter.hasNext() ) {\n+            Object oval = iter.next();\n+            assertTrue( oval != null );\n+            assertTrue( oval instanceof String );\n+            String val = (String)oval;\n+            boolean foundIt = false;\n+            for( int ii=0; ii < sMapPairs[index].length; ii++ ){\n+                if( val.equals( sMapPairs[index][ii].mValue ) )\n+                    foundIt = true;\n+            }\n+            assertTrue( foundIt );\n+        }\n+    }\n+    \n+    public int getFullSize()\n+    {\n+        int len = 0;\n+        for( int ii=0; ii < sMapPairs.length; ii++ ){\n+            len += sMapPairs[ii].length;\n+        }\n+        return len;\n+    }\n+    \n \n     public void testEntrySetIterator() {\n     }\n         // for.\n         return;\n     }\n-}\n+}", "timestamp": 1014682417, "metainfo": ""}