{"sha": "6f42ddf1baa4c6f5f385684dd03d57eefce38406", "log": "[COLLECTIONS-429] Improved CollectionUtils#containsAll with the version from the patch, added more javadoc with information on the runtime/space trade-off.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n             return getFreq(obj, cardinalityB);\n         }\n \n-        /**\n-         * Returns the number of unique elements in collection A.\n-         * @return the number of unique elements in collection A\n-         */\n-        @SuppressWarnings(\"unused\")\n-        public int sizeA() {\n-            return cardinalityA.size();\n-        }\n-        \n-        /**\n-         * Returns the number of unique elements in collection A.\n-         * @return the number of unique elements in collection A\n-         */\n-        public int sizeB() {\n-            return cardinalityB.size();\n-        }\n-\n         private final int getFreq(final Object obj, final Map<?, Integer> freqMap) {\n             final Integer count = freqMap.get(obj);\n             if (count != null) {\n      * will be returned.\n      * <p>\n      * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n-     * with a guaranteed runtime complexity of {@code O(n)}. Depending on the type of\n+     * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n      * {@link Collection} provided, this method will be much faster than calling\n-     * {@link Collection#containsAll(Collection)} instead.\n+     * {@link Collection#containsAll(Collection)} instead, though this will come at the\n+     * cost of an additional space complexity O(n).\n      *\n      * @param coll1  the first collection, must not be null\n      * @param coll2  the second collection, must not be null\n         if (coll2.isEmpty()) {\n             return true;\n         } else {\n-            final SetOperationCardinalityHelper<Object> helper =\n-                    new SetOperationCardinalityHelper<Object>(coll1, coll2);\n-            for (final Object obj : helper) {\n-                helper.setCardinality(obj, helper.min(obj));\n-            }\n-            return helper.list().size() == helper.sizeB();\n+            final Iterator<?> it = coll1.iterator();\n+            final Set<Object> elementsAlreadySeen = new HashSet<Object>();\n+            for (final Object nextElement : coll2) {\n+                if (elementsAlreadySeen.contains(nextElement)) {\n+                    continue;\n+                }\n+\n+                boolean foundCurrentElement = false;\n+                while (it.hasNext()) {\n+                    final Object p = it.next();\n+                    elementsAlreadySeen.add(p);\n+                    if (nextElement == null ? p == null : nextElement.equals(p)) {\n+                        foundCurrentElement = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (foundCurrentElement) {\n+                    continue;\n+                } else {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n     }\n     ", "timestamp": 1366227154, "metainfo": ""}