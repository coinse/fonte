{"sha": "38bb9b4ac534abc95a83c75faf5e87cfe25319d4", "log": "Removed unneeded inheritDoc tags, formatting.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/trie/SynchronizedTrie.java\n+++ b/src/main/java/org/apache/commons/collections/trie/SynchronizedTrie.java\n     /**\n      * Factory method to create a synchronized trie.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param trie  the trie to decorate, must not be null\n      * @return a new synchronized trie\n      * @throws IllegalArgumentException if trie is null\n         this.delegate = trie;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n-    public synchronized Entry<K, V> select(K key, \n-            Cursor<? super K, ? super V> cursor) {\n+    public synchronized Entry<K, V> select(K key, Cursor<? super K, ? super V> cursor) {\n         return delegate.select(key, cursor);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized Entry<K, V> select(K key) {\n         return delegate.select(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized K selectKey(K key) {\n         return delegate.selectKey(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized V selectValue(K key) {\n         return delegate.selectValue(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized Entry<K, V> traverse(Cursor<? super K, ? super V> cursor) {\n         return delegate.traverse(cursor);\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized Set<Entry<K, V>> entrySet() {\n         return SynchronizedSet.synchronizedSet(delegate.entrySet());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized Set<K> keySet() {\n         return SynchronizedSet.synchronizedSet(delegate.keySet());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized Collection<V> values() {\n         return SynchronizedCollection.synchronizedCollection(delegate.values());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized void clear() {\n         delegate.clear();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized boolean containsKey(Object key) {\n         return delegate.containsKey(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized boolean containsValue(Object value) {\n         return delegate.containsValue(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized V get(Object key) {\n         return delegate.get(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized boolean isEmpty() {\n         return delegate.isEmpty();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized V put(K key, V value) {\n         return delegate.put(key, value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized void putAll(Map<? extends K, ? extends V> m) {\n         delegate.putAll(m);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized V remove(Object key) {\n         return delegate.remove(key);\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized K lastKey() {\n         return delegate.lastKey();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> subMap(K fromKey, K toKey) {\n         return Collections.synchronizedSortedMap(delegate.subMap(fromKey, toKey));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> tailMap(K fromKey) {\n         return Collections.synchronizedSortedMap(delegate.tailMap(fromKey));\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized Comparator<? super K> comparator() {\n         return delegate.comparator();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized K firstKey() {\n         return delegate.firstKey();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> headMap(K toKey) {\n         return Collections.synchronizedSortedMap(delegate.headMap(toKey));\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, offset, length));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> getPrefixedBy(K key, int length) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, length));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> getPrefixedBy(K key) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized SortedMap<K, V> getPrefixedByBits(K key, \n             int offsetInBits, int lengthInBits) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public synchronized int size() {\n         return delegate.size();\n     }\n--- a/src/main/java/org/apache/commons/collections/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections/trie/UnmodifiableTrie.java\n     /**\n      * Factory method to create a unmodifiable trie.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param trie  the trie to decorate, must not be null\n      * @return a new unmodifiable trie\n      * @throws IllegalArgumentException if trie is null\n      * Constructor that wraps (not copies).\n      * \n      * @param trie  the trie to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws IllegalArgumentException if trie is null\n      */\n     public UnmodifiableTrie(Trie<K, V> trie) {\n         if (trie == null) {\n-            throw new IllegalArgumentException(\"Collection must not be null\");\n+            throw new IllegalArgumentException(\"Trie must not be null\");\n         }\n         this.delegate = trie;\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Entry<K, V> select(K key, final Cursor<? super K, ? super V> cursor) {\n         Cursor<K, V> c = new Cursor<K, V>() {\n             public Decision select(Map.Entry<? extends K, ? extends V> entry) {\n         return delegate.select(key, c);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Entry<K, V> select(K key) {\n         return delegate.select(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public K selectKey(K key) {\n         return delegate.selectKey(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public V selectValue(K key) {\n         return delegate.selectValue(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n         Cursor<K, V> c = new Cursor<K, V>() {\n             public Decision select(Map.Entry<? extends K, ? extends V> entry) {\n         return delegate.traverse(c);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Set<Entry<K, V>> entrySet() {\n         return Collections.unmodifiableSet(delegate.entrySet());\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Set<K> keySet() {\n         return Collections.unmodifiableSet(delegate.keySet());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Collection<V> values() {\n         return Collections.unmodifiableCollection(delegate.values());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void clear() {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean containsKey(Object key) {\n         return delegate.containsKey(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean containsValue(Object value) {\n         return delegate.containsValue(value);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public V get(Object key) {\n         return delegate.get(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public boolean isEmpty() {\n         return delegate.isEmpty();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public V put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public void putAll(Map<? extends K, ? extends V> m) {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public V remove(Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public K firstKey() {\n         return delegate.firstKey();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> headMap(K toKey) {\n         return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public K lastKey() {\n         return delegate.lastKey();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> subMap(K fromKey, K toKey) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.subMap(fromKey, toKey));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> tailMap(K fromKey) {\n         return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key, offset, length));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedBy(K key, int length) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key, length));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedBy(K key) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedByBits(key, lengthInBits));\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n-    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits,\n-            int lengthInBits) {\n-        return Collections.unmodifiableSortedMap(\n-                delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits) {\n+        return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n+    }\n+\n     public Comparator<? super K> comparator() {\n         return delegate.comparator();\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int size() {\n         return delegate.size();\n     }\n     \n-    /**\n-     * {@inheritDoc}\n-     */\n     public int hashCode() {\n         return delegate.hashCode();\n     }", "timestamp": 1346009005, "metainfo": ""}