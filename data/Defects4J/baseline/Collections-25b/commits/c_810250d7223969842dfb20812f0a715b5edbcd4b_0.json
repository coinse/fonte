{"sha": "810250d7223969842dfb20812f0a715b5edbcd4b", "log": "Remove trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @throws IllegalArgumentException if the initial capacity is negative\n-     * @throws IllegalArgumentException if the load factor is less than or equal to zero \n+     * @throws IllegalArgumentException if the load factor is less than or equal to zero\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected AbstractHashedMap(int initialCapacity, final float loadFactor) {\n         super();\n         if (initialCapacity < 0) {\n-            throw new IllegalArgumentException(\"Initial capacity must be a non negative number\");  \n+            throw new IllegalArgumentException(\"Initial capacity must be a non negative number\");\n         }\n         if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n             throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n      * This implementation iterates around the specified map and\n      * uses {@link #put(Object, Object)}.\n      * <p>\n-     * It is private to allow the constructor to still call it \n-     * even when putAll is overriden. \n-     * \n+     * It is private to allow the constructor to still call it\n+     * even when putAll is overriden.\n+     *\n      * @param map  the map to add\n      * @throws NullPointerException if the map is null\n      */\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n      * or it may transform the value into another object.\n      * <p>\n      * This implementation returns the input value.\n-     * \n+     *\n      * @param value  the value to check\n      * @throws UnsupportedOperationException if the map may not be changed by setValue\n      * @throws IllegalArgumentException if the specified value is invalid\n      * has no effect as this optimises the implementation.\n      * <p>\n      * This implementation returns <code>true</code>.\n-     * \n+     *\n      * @return true always\n      */\n     protected boolean isSetValueChecking() {\n      * Implementation of an entry set that checks additions via setValue.\n      */\n     private class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>> {\n-        \n+\n         /** Generated serial version ID. */\n         private static final long serialVersionUID = 4354731610923110264L;\n \n         public Iterator<Map.Entry<K, V>> iterator() {\n             return new EntrySetIterator(collection.iterator(), parent);\n         }\n-        \n+\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public Object[] toArray() {\n             }\n             return array;\n         }\n-        \n+\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public <T> T[] toArray(final T[] array) {\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java\n  * @version $Id$\n  */\n public abstract class AbstractLinkedMap<K, V> extends AbstractHashedMap<K, V> implements OrderedMap<K, V> {\n-    \n+\n     /** Header in the linked list */\n     protected transient LinkEntry<K, V> header; // TODO Privatise?\n \n \n     /**\n      * Constructor which performs no validation on the passed in parameters.\n-     * \n+     *\n      * @param initialCapacity  the initial capacity, must be a power of two\n      * @param loadFactor  the load factor, must be > 0.0f and generally < 1.0f\n      * @param threshold  the threshold, must be sensible\n     }\n \n     /**\n-     * Constructs a new, empty map with the specified initial capacity. \n+     * Constructs a new, empty map with the specified initial capacity.\n      *\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether the map contains the specified value.\n-     * \n+     *\n      * @param value  the value to search for\n      * @return true if the map contains the value\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the first key in the map, which is the first inserted.\n-     * \n+     *\n      * @return the eldest key\n      */\n     public K firstKey() {\n \n     /**\n      * Gets the last key in the map, which is the most recently inserted.\n-     * \n+     *\n      * @return the most recently inserted key\n      */\n     public K lastKey() {\n \n     /**\n      * Gets the next key in sequence.\n-     * \n+     *\n      * @param key  the key to get after\n      * @return the next key\n      */\n \n     /**\n      * Gets the previous key in sequence.\n-     * \n+     *\n      * @param key  the key to get before\n      * @return the previous key\n      */\n         return entry == null || entry.before == header ? null : entry.before.getKey();\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the key at the specified index.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n         }\n         return entry;\n     }\n-    \n+\n     /**\n      * Adds an entry into this map, maintaining insertion order.\n      * <p>\n      * This implementation adds the entry to the data storage table and\n      * to the end of the linked list.\n-     * \n+     *\n      * @param entry  the entry to add\n      * @param hashIndex  the index into the data array to store at\n      */\n      * Creates an entry to store the data.\n      * <p>\n      * This implementation creates a new LinkEntry instance.\n-     * \n+     *\n      * @param next  the next entry in sequence\n      * @param hashCode  the hash code to use\n      * @param key  the key to store\n      * <p>\n      * This implementation removes the entry from the linked list chain, then\n      * calls the superclass implementation.\n-     * \n+     *\n      * @param entry  the entry to remove\n      * @param hashIndex  the index into the data structure\n      * @param previous  the previous entry in the chain\n     /**\n      * Gets the <code>before</code> field from a <code>LinkEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n-     * \n+     *\n      * @param entry  the entry to query, must not be null\n      * @return the <code>before</code> field of the entry\n      * @throws NullPointerException if the entry is null\n     /**\n      * Gets the <code>after</code> field from a <code>LinkEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n-     * \n+     *\n      * @param entry  the entry to query, must not be null\n      * @return the <code>after</code> field of the entry\n      * @throws NullPointerException if the entry is null\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Creates an entry set iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @return the entrySet iterator\n      */\n     @Override\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Creates a key set iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @return the keySet iterator\n      */\n     @Override\n      */\n     protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n             OrderedIterator<K>, ResettableIterator<K> {\n-        \n+\n         @SuppressWarnings(\"unchecked\")\n         protected KeySetIterator(final AbstractLinkedMap<K, ?> parent) {\n             super((AbstractLinkedMap<K, Object>) parent);\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Creates a values iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @return the values iterator\n      */\n     @Override\n \n         /**\n          * Constructs a new entry.\n-         * \n+         *\n          * @param next  the next entry in the hash bucket sequence\n          * @param hashCode  the hash code\n          * @param key  the key\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java\n \n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     protected Map<K, V> decorated() {\n     public Collection<V> values() {\n         return decorated().values();\n     }\n-   \n+\n     @Override\n     public boolean equals(final Object object) {\n         if (object == this) {\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java\n import org.apache.commons.collections4.OrderedMap;\n import org.apache.commons.collections4.OrderedMapIterator;\n \n-/** \n+/**\n  * Provides a base decorator that enables additional functionality to be added\n  * to an OrderedMap via decoration.\n  * <p>\n \n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java\n      * load factor and initial capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link ReferenceStrength#HARD HARD}, \n-     *   {@link ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link ReferenceStrength#HARD HARD},\n+     *   {@link ReferenceStrength#SOFT SOFT},\n      *   {@link ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link ReferenceStrength#HARD},\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java\n import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.iterators.ListIteratorWrapper;\n \n-/** \n+/**\n  * Provides a base decorator that enables additional functionality to be added\n  * to a Map via decoration.\n  * <p>\n \n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java\n  * to all lowercase in a locale-independent fashion by using information from the Unicode\n  * data file.\n  * <p>\n- * Null keys are supported.  \n+ * Null keys are supported.\n  * <p>\n  * The <code>keySet()</code> method returns all lowercase keys, or nulls.\n  * <p>\n  * <strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since 3.0\n     }\n \n     /**\n-     * Constructs a new, empty map with the specified initial capacity. \n+     * Constructs a new, empty map with the specified initial capacity.\n      *\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to \n+     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to\n      * lower case.\n      * <p>\n      * Returns {@link AbstractHashedMap#NULL} if key is null.\n-     * \n+     *\n      * @param key  the key convert\n      * @return the converted key\n      */\n             return new String(chars);\n         }\n         return AbstractHashedMap.NULL;\n-    }   \n+    }\n \n     //-----------------------------------------------------------------------\n     /**\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n- \n+\n }\n--- a/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java\n  * <strong>Note that DefaultedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since 3.2\n      * Factory method to create a defaulting map.\n      * <p>\n      * The value specified is returned when a missing key is found.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * <p>\n      * The factory specified is called when a missing key is found.\n      * The result will be returned as the result of the map get(key) method.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * The transformer specified is called when a missing key is found.\n      * The key is passed to the transformer as the input, and the result\n      * will be returned as the result of the map get(key) method.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * <p>\n      * The object passed in will be returned by the map whenever an\n      * unknown key is requested.\n-     * \n+     *\n      * @param defaultValue  the default value to return when the key is not found\n      */\n     public DefaultedMap(final V defaultValue) {\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param defaultValueTransformer  the value transformer to use\n      * @throws IllegalArgumentException if map or transformer is null\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n--- a/src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java\n+++ b/src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java\n      * Get the currently active entry.\n      * @return Map.Entry<K, V>\n      */\n-    protected synchronized Map.Entry<K, V> current() { \n+    protected synchronized Map.Entry<K, V> current() {\n         if (entry == null) {\n             throw new IllegalStateException();\n         }\n--- a/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java\n  * key however.\n  * <p>\n  * If trying to remove or clear the map, an UnsupportedOperationException is\n- * thrown. If trying to put a new mapping into the map, an \n- * IllegalArgumentException is thrown. This is because the put method can \n+ * thrown. If trying to put a new mapping into the map, an\n+ * IllegalArgumentException is thrown. This is because the put method can\n  * succeed if the mapping's key already exists in the map, so the put method\n  * is not always unsupported.\n  * <p>\n  * <strong>Note that FixedSizeMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n \n     /**\n      * Factory method to create a fixed size map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      * @since 3.1\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n--- a/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java\n  * key however.\n  * <p>\n  * If trying to remove or clear the map, an UnsupportedOperationException is\n- * thrown. If trying to put a new mapping into the map, an \n- * IllegalArgumentException is thrown. This is because the put method can \n+ * thrown. If trying to put a new mapping into the map, an\n+ * IllegalArgumentException is thrown. This is because the put method can\n  * succeed if the mapping's key already exists in the map, so the put method\n  * is not always unsupported.\n  * <p>\n  * <strong>Note that FixedSizeSortedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n \n     /**\n      * Factory method to create a fixed size sorted map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n \n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     protected SortedMap<K, V> getSortedMap() {\n     /**\n      * Read the map in using a custom routine.\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n--- a/src/main/java/org/apache/commons/collections4/map/Flat3Map.java\n+++ b/src/main/java/org/apache/commons/collections4/map/Flat3Map.java\n          * <p>\n          * As a consequence, all subsequent call to {@link #getKey()},\n          * {@link #setValue(Object)} and {@link #getValue()} will fail.\n-         * \n+         *\n          * @param flag\n          */\n         void setRemoved(final boolean flag) {\n--- a/src/main/java/org/apache/commons/collections4/map/LRUMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/LRUMap.java\n             modCount++;\n             // remove\n             if(entry.before == null) {\n-                throw new IllegalStateException(\"Entry.before is null.\" + \n+                throw new IllegalStateException(\"Entry.before is null.\" +\n                     \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n                     \" If so, then please report this to dev@commons.apache.org as a bug.\");\n             }\n \n     /**\n      * Writes the data necessary for <code>put()</code> to work in deserialization.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException if an error occurs while writing to the stream\n      */\n--- a/src/main/java/org/apache/commons/collections4/map/LazyMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/LazyMap.java\n  * <strong>Note that LazyMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n \n     /**\n      * Factory method to create a lazily instantiated map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n \n     /**\n      * Factory method to create a lazily instantiated map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n--- a/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java\n  * <strong>Note that LazySortedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n \n     /**\n      * Factory method to create a lazily instantiated sorted map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n \n     /**\n      * Factory method to create a lazily instantiated sorted map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     protected SortedMap<K,V> getSortedMap() {\n--- a/src/main/java/org/apache/commons/collections4/map/LinkedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/LinkedMap.java\n  * A <code>Map</code> implementation that maintains the order of the entries.\n  * In this implementation order is maintained by original insertion.\n  * <p>\n- * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n+ * This implementation improves on the JDK1.4 LinkedHashMap by adding the\n  * {@link org.apache.commons.collections4.MapIterator MapIterator}\n  * functionality, additional convenience methods and allowing\n  * bidirectional iteration. It also implements <code>OrderedMap</code>.\n  * <strong>Note that LinkedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since 3.0\n \n     /** Serialisation version */\n     private static final long serialVersionUID = 9077234323521161066L;\n-    \n+\n     /**\n      * Constructs a new empty map with default size and load factor.\n      */\n     }\n \n     /**\n-     * Constructs a new, empty map with the specified initial capacity. \n+     * Constructs a new, empty map with the specified initial capacity.\n      *\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n     public LinkedMap<K, V> clone() {\n         return (LinkedMap<K, V>) super.clone();\n     }\n-    \n+\n     /**\n      * Write the map out using a custom routine.\n      */\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the key at the specified index.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n     public K get(final int index) {\n         return getEntry(index).getKey();\n     }\n-    \n+\n     /**\n      * Gets the value at the specified index.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the value at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n     public V getValue(final int index) {\n         return getEntry(index).getValue();\n     }\n-    \n+\n     /**\n      * Gets the index of the specified key.\n-     * \n+     *\n      * @param key  the key to find the index of\n      * @return the index, or -1 if not found\n      */\n      * An alternative to this method is to use {@link #keySet()}.\n      *\n      * @see #keySet()\n-     * @return The ordered list of keys.  \n+     * @return The ordered list of keys.\n      */\n     public List<K> asList() {\n         return new LinkedMapList<K>(this);\n--- a/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java\n  * <strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * <strong>Note that ListOrderedMap doesn't work with\n      * Factory method to create an ordered map.\n      * <p>\n      * An <code>ArrayList</code> is used to retain order.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     /**\n      * Constructs a new empty <code>ListOrderedMap</code> that decorates\n      * a <code>HashMap</code>.\n-     * \n+     *\n      * @since 3.1\n      */\n     public ListOrderedMap() {\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      * @since 3.1\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n         }\n         return insertOrder.get(size() - 1);\n     }\n-    \n+\n     /**\n      * Gets the next key to the one specified using insert order.\n      * This method performs a list search to find the key and is O(n).\n-     * \n+     *\n      * @param key  the key to find previous for\n      * @return the next key, null if no match or at start\n      */\n     /**\n      * Gets the previous key to the one specified using insert order.\n      * This method performs a list search to find the key and is O(n).\n-     * \n+     *\n      * @param key  the key to find previous for\n      * @return the previous key, null if no match or at start\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Returns the Map as a string.\n-     * \n+     *\n      * @return the Map as a String\n      */\n     @Override\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the key at the specified index.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n     public K get(final int index) {\n         return insertOrder.get(index);\n     }\n-    \n+\n     /**\n      * Gets the value at the specified index.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n     public V getValue(final int index) {\n         return get(insertOrder.get(index));\n     }\n-    \n+\n     /**\n      * Gets the index of the specified key.\n-     * \n+     *\n      * @param key  the key to find the index of\n      * @return the index, or -1 if not found\n      */\n      *\n      * @see #keyList()\n      * @see #keySet()\n-     * @return The ordered list of keys.  \n+     * @return The ordered list of keys.\n      */\n     public List<K> asList() {\n         return keyList();\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n         private final ListOrderedMap<K, V> parent;\n         private final List<K> insertOrder;\n             }\n             return entrySet;\n         }\n-        \n+\n         @Override\n         public int size() {\n             return this.parent.size();\n     static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n         private final ListOrderedMap<K, V> parent;\n         private K last = null;\n-        \n+\n         ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n             super(insertOrder.iterator());\n             this.parent = parent;\n             readable = true;\n             return last;\n         }\n-        \n+\n         public boolean hasPrevious() {\n             return iterator.hasPrevious();\n         }\n--- a/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java\n         return new MultiKeyMap<K, V>(map);\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Constructs a new MultiKeyMap that decorates a <code>HashedMap</code>.\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @return the mapped value, null if no match\n \n     /**\n      * Checks whether the map contains the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @return true if the map contains the key\n \n     /**\n      * Stores the value against the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param value  the value to store\n \n     /**\n      * Removes the specified multi-key from this map.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @return the value mapped to the removed key, null if key not in map\n \n     /**\n      * Gets the hash code for the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @return the hash code\n \n     /**\n      * Is the key equal to the combined key.\n-     * \n+     *\n      * @param entry  the entry to compare to\n      * @param key1  the first key\n      * @param key2  the second key\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Checks whether the map contains the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Stores the value against the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Removes the specified multi-key from this map.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Gets the hash code for the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Is the key equal to the combined key.\n-     * \n+     *\n      * @param entry  the entry to compare to\n      * @param key1  the first key\n      * @param key2  the second key\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Checks whether the map contains the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Stores the value against the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Removes the specified multi-key from this map.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Gets the hash code for the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Is the key equal to the combined key.\n-     * \n+     *\n      * @param entry  the entry to compare to\n      * @param key1  the first key\n      * @param key2  the second key\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Checks whether the map contains the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Stores the value against the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Removes the specified multi-key from this map.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Gets the hash code for the specified multi-key.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n \n     /**\n      * Is the key equal to the combined key.\n-     * \n+     *\n      * @param entry  the entry to compare to\n      * @param key1  the first key\n      * @param key2  the second key\n      * <p>\n      * This method removes all the mappings where the <code>MultiKey</code>\n      * has one or more keys, and the first matches that specified.\n-     * \n+     *\n      * @param key1  the first key\n      * @return true if any elements were removed\n      */\n      * <p>\n      * This method removes all the mappings where the <code>MultiKey</code>\n      * has two or more keys, and the first two match those specified.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @return true if any elements were removed\n      * <p>\n      * This method removes all the mappings where the <code>MultiKey</code>\n      * has three or more keys, and the first three match those specified.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n      * <p>\n      * This method removes all the mappings where the <code>MultiKey</code>\n      * has four or more keys, and the first four match those specified.\n-     * \n+     *\n      * @param key1  the first key\n      * @param key2  the second key\n      * @param key3  the third key\n     //-----------------------------------------------------------------------\n     /**\n      * Check to ensure that input keys are valid MultiKey objects.\n-     * \n+     *\n      * @param key  the key to check\n      */\n     protected void checkKey(final MultiKey<?> key) {\n     /**\n      * Puts the key and value into the map, where the key must be a non-null\n      * MultiKey object.\n-     * \n+     *\n      * @param key  the non-null MultiKey object\n      * @param value  the value to store\n      * @return the previous value for the key\n     /**\n      * Copies all of the keys and values from the specified map to this map.\n      * Each key must be non-null and a MultiKey object.\n-     * \n+     *\n      * @param mapToCopy  to this map\n      * @throws NullPointerException if the mapToCopy or any key within is null\n      * @throws ClassCastException if any key in mapToCopy is not a MultiKey\n     protected AbstractHashedMap<MultiKey<? extends K>, V> decorated() {\n         return (AbstractHashedMap<MultiKey<? extends K>, V>) super.decorated();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n         in.defaultReadObject();\n         map = (Map<MultiKey<? extends K>, V>) in.readObject();\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 4.0\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      * @since 4.0\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, Object>) in.readObject(); // (1)\n      * NOTE: the returned Entry objects will contain as value a {@link Collection}\n      * of all values that are mapped to the given key. To get a \"flattened\" version\n      * of all mappings contained in this map, use {@link #iterator()}.\n-     * \n+     *\n      * @see #iterator()\n      */\n     @Override\n     public Iterator<Entry<K, V>> iterator() {\n         final Collection<K> allKeys = new ArrayList<K>(keySet());\n         final Iterator<K> keyIterator = allKeys.iterator();\n-        \n+\n         return new LazyIteratorChain<Entry<K, V>>() {\n             @Override\n             protected Iterator<? extends Entry<K, V>> nextIterator(int count) {\n--- a/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n  * This class may throw exceptions when accessed by concurrent threads without\n  * synchronization.\n  * </p>\n- * \n+ *\n  * @param <K> the type of the keys in the map\n  * @param <V> the type of the values in the map\n  * @since 4.0\n      * A {@link org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy ExpirationPolicy}\n      * that returns a expiration time that is a\n      * constant about of time in the future from the current time.\n-     * \n+     *\n      * @param <K> the type of the keys in the map\n      * @param <V> the type of the values in the map\n      * @since 4.0\n          * milliseconds. A negative time-to-live value indicates entries never\n          * expire. A zero time-to-live value indicates entries expire (nearly)\n          * immediately.\n-         * \n+         *\n          * @param timeToLiveMillis the constant amount of time (in milliseconds)\n          *        an entry is available before it expires. A negative value\n          *        results in entries that NEVER expire. A zero value results in\n         /**\n          * Construct a policy with the given time-to-live constant measured in\n          * the given time unit of measure.\n-         * \n+         *\n          * @param timeToLive the constant amount of time an entry is available\n          *        before it expires. A negative value results in entries that\n          *        NEVER expire. A zero value results in entries that ALWAYS\n \n         /**\n          * Determine the expiration time for the given key-value entry.\n-         * \n+         *\n          * @param key the key for the entry (ignored).\n          * @param value the value for the entry (ignored).\n          * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n \n     /**\n      * A policy to determine the expiration time for key-value entries.\n-     * \n+     *\n      * @param <K> the key object type.\n      * @param <V> the value object type\n      * @since 4.0\n \n         /**\n          * Determine the expiration time for the given key-value entry.\n-         * \n+         *\n          * @param key the key for the entry.\n          * @param value the value for the entry.\n          * @return the expiration time value measured in milliseconds. A\n      * the given time measured in the given units to the same time measured in\n      * milliseconds. If the parameters are invalid, an\n      * {@link IllegalArgumentException} is thrown.\n-     * \n+     *\n      * @param timeToLive the constant amount of time an entry is available\n      *        before it expires. A negative value results in entries that NEVER\n      *        expire. A zero value results in entries that ALWAYS expire.\n     /**\n      * Construct a map decorator using the given expiration policy to determine\n      * expiration times.\n-     * \n+     *\n      * @param expiringPolicy the policy used to determine expiration times of\n      *        entries as they are added.\n      */\n      * expiration policy to determine expiration times. If there are any\n      * elements already in the map being decorated, they will NEVER expire\n      * unless they are replaced.\n-     * \n+     *\n      * @param expiringPolicy the policy used to determine expiration times of\n      *        entries as they are added.\n      * @param map the map to decorate, must not be null.\n      * Construct a map decorator that decorates the given map using the given\n      * time-to-live value measured in milliseconds to create and use a\n      * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n-     * \n+     *\n      * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n      *        entry is available before it expires. A negative value results in\n      *        entries that NEVER expire. A zero value results in entries that\n      * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. If there\n      * are any elements already in the map being decorated, they will NEVER\n      * expire unless they are replaced.\n-     * \n+     *\n      * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n      *        entry is available before it expires. A negative value results in\n      *        entries that NEVER expire. A zero value results in entries that\n      * Construct a map decorator using the given time-to-live value measured in\n      * the given time units of measure to create and use a\n      * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n-     * \n+     *\n      * @param timeToLive the constant amount of time an entry is available\n      *        before it expires. A negative value results in entries that NEVER\n      *        expire. A zero value results in entries that ALWAYS expire.\n      * is used to determine expiration times. If there are any elements already\n      * in the map being decorated, they will NEVER expire unless they are\n      * replaced.\n-     * \n+     *\n      * @param timeToLive the constant amount of time an entry is available\n      *        before it expires. A negative value results in entries that NEVER\n      *        expire. A zero value results in entries that ALWAYS expire.\n      * Constructs a map decorator that decorates the given map and results in\n      * entries NEVER expiring. If there are any elements already in the map\n      * being decorated, they also will NEVER expire.\n-     * \n+     *\n      * @param map the map to decorate, must not be null.\n      * @throws IllegalArgumentException if the map is null.\n      */\n \n     /**\n      * Determines if the given expiration time is less than <code>now</code>.\n-     * \n+     *\n      * @param now the time in milliseconds used to compare against the\n      *        expiration time.\n      * @param expirationTimeObject the expiration time value retrieved from\n      * Removes all entries in the map whose expiration time is less than\n      * <code>now</code>. The exceptions are entries with negative expiration\n      * times; those entries are never removed.\n-     * \n+     *\n      * @see #isExpired(long, Long)\n      */\n     private void removeAllExpired(final long now) {\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n \n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out the output stream\n      * @throws IOException\n      */\n--- a/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java\n  * <strong>Note that PredicatedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n         super(map);\n         this.keyPredicate = keyPredicate;\n         this.valuePredicate = valuePredicate;\n-        \n+\n         final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n         while (it.hasNext()) {\n             final Map.Entry<K, V> entry = it.next();\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      * @since 3.1\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     //-----------------------------------------------------------------------\n     /**\n      * Validates a key value pair.\n-     * \n+     *\n      * @param key  the key to validate\n      * @param value  the value to validate\n      * @throws IllegalArgumentException if invalid\n \n     /**\n      * Override to validate an object set into the map via <code>setValue</code>.\n-     * \n+     *\n      * @param value  the value to validate\n      * @return the value itself\n      * @throws IllegalArgumentException if invalid\n \n     /**\n      * Override to only return true when there is a value transformer.\n-     * \n+     *\n      * @return true if a value predicate is in use\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java\n  * <strong>Note that PredicatedSortedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     protected SortedMap<K, V> getSortedMap() {\n--- a/src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java\n  * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n  * <p>\n  * This implementation is not synchronized.\n- * You can use {@link java.util.Collections#synchronizedMap} to \n+ * You can use {@link java.util.Collections#synchronizedMap} to\n  * provide synchronized access to a <code>ReferenceIdentityMap</code>.\n  * Remember that synchronization will not stop the garbage collector removing entries.\n  * <p>\n  * <strong>Note that ReferenceIdentityMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @see java.lang.ref.Reference\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n-     * @param valueType  the type of reference to use for values;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n-     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n-     * @param purgeValues should the value be automatically purged when the \n-     *   key is garbage collected \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param purgeValues should the value be automatically purged when the\n+     *   key is garbage collected\n      */\n     public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n             final boolean purgeValues) {\n      * specified reference types, load factor and initial capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      * specified reference types, load factor and initial capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n-     * @param purgeValues  should the value be automatically purged when the \n-     *   key is garbage collected \n+     * @param purgeValues  should the value be automatically purged when the\n+     *   key is garbage collected\n      */\n     public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n             final int capacity, final float loadFactor, final boolean purgeValues) {\n      * Gets the hash code for the key specified.\n      * <p>\n      * This implementation uses the identity hash code.\n-     * \n+     *\n      * @param key  the key to get a hash code for\n      * @return the hash code\n      */\n      * Gets the hash code for a MapEntry.\n      * <p>\n      * This implementation uses the identity hash code.\n-     * \n+     *\n      * @param key  the key to get a hash code for, may be null\n      * @param value  the value to get a hash code for, may be null\n      * @return the hash code, as per the MapEntry specification\n      * <p>\n      * This implementation converts the key from the entry to a real reference\n      * before comparison and uses <code>==</code>.\n-     * \n+     *\n      * @param key1  the first key to compare passed in from outside\n      * @param key2  the second key extracted from the entry via <code>entry.key</code>\n      * @return true if equal by identity\n      * Compares two values for equals.\n      * <p>\n      * This implementation uses <code>==</code>.\n-     * \n+     *\n      * @param value1  the first value to compare passed in from outside\n      * @param value2  the second value extracted from the entry via <code>getValue()</code>\n      * @return true if equal by identity\n--- a/src/main/java/org/apache/commons/collections4/map/ReferenceMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/ReferenceMap.java\n  * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n  * <p>\n  * This implementation is not synchronized.\n- * You can use {@link java.util.Collections#synchronizedMap} to \n+ * You can use {@link java.util.Collections#synchronizedMap} to\n  * provide synchronized access to a <code>ReferenceMap</code>.\n  * Remember that synchronization will not stop the garbage collector removing entries.\n  * <p>\n  * <strong>Note that ReferenceMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * NOTE: As from Commons Collections 3.1 this map extends <code>AbstractReferenceMap</code>\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n-     * @param purgeValues should the value be automatically purged when the \n-     *   key is garbage collected \n+     * @param purgeValues should the value be automatically purged when the\n+     *   key is garbage collected\n      */\n     public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final boolean purgeValues) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n      * capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      * capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n-     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n-     * @param purgeValues  should the value be automatically purged when the \n-     *   key is garbage collected \n+     * @param purgeValues  should the value be automatically purged when the\n+     *   key is garbage collected\n      */\n     public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n             final float loadFactor, final boolean purgeValues) {\n--- a/src/main/java/org/apache/commons/collections4/map/SingletonMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/SingletonMap.java\n  * <p>\n  * If trying to remove or clear the map, an UnsupportedOperationException is thrown.\n  * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\n- * The put method will only suceed if the key specified is the same as the \n+ * The put method will only suceed if the key specified is the same as the\n  * singleton key.\n  * <p>\n  * The key and value can be obtained by:\n     /**\n      * Gets the key.\n      *\n-     * @return the key \n+     * @return the key\n      */\n     public K getKey() {\n         return key;\n \n     /**\n      * Gets the maximum size of the map, always 1.\n-     * \n+     *\n      * @return 1 always\n      */\n     public int maxSize() {\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the key specified.\n-     * \n+     *\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n \n     /**\n      * Gets the size of the map, always 1.\n-     * \n+     *\n      * @return the size of 1\n      */\n     public int size() {\n \n     /**\n      * Checks whether the map is currently empty, which it never is.\n-     * \n+     *\n      * @return false always\n      */\n     public boolean isEmpty() {\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether the map contains the specified key.\n-     * \n+     *\n      * @param key  the key to search for\n      * @return true if the map contains the key\n      */\n \n     /**\n      * Checks whether the map contains the specified value.\n-     * \n+     *\n      * @param value  the value to search for\n      * @return true if the map contains the key\n      */\n      * <p>\n      * An IllegalArgumentException is thrown if the key does not match as the map\n      * is fixed size.\n-     * \n+     *\n      * @param key  the key to set, must be the key of the map\n      * @param value  the value to set\n      * @return the value previously mapped to this key, null if none\n      * The map must be of size 0 or size 1.\n      * If it is size 1, the key must match the key of this map otherwise an\n      * IllegalArgumentException is thrown.\n-     * \n+     *\n      * @param map  the map to add, must be size 0 or 1, and the key must match\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the key does not match\n                 throw new IllegalArgumentException(\"The map size must be 0 or 1\");\n         }\n     }\n-    \n+\n     /**\n      * Unsupported operation.\n-     * \n+     *\n      * @param key  the mapping to remove\n      * @return the value mapped to the removed key, null if key not in map\n      * @throws UnsupportedOperationException always\n      * Gets the entrySet view of the map.\n      * Changes made via <code>setValue</code> affect this map.\n      * To simply iterate through the entries, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the entrySet view\n      */\n     public Set<Map.Entry<K, V>> entrySet() {\n         final Map.Entry<K, V> entry = new TiedMapEntry<K, V>(this, getKey());\n         return Collections.singleton(entry);\n     }\n-    \n+\n     /**\n      * Gets the unmodifiable keySet view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the keys, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the keySet view\n      */\n     public Set<K> keySet() {\n      * Gets the unmodifiable values view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the values, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the values view\n      */\n     public Collection<V> values() {\n \n     /**\n      * Gets the first (and only) key in the map.\n-     * \n+     *\n      * @return the key\n      */\n     public K firstKey() {\n \n     /**\n      * Gets the last (and only) key in the map.\n-     * \n+     *\n      * @return the key\n      */\n     public K lastKey() {\n \n     /**\n      * Gets the next key after the key specified, always null.\n-     * \n+     *\n      * @param key  the next key\n      * @return null always\n      */\n \n     /**\n      * Gets the previous key before the key specified, always null.\n-     * \n+     *\n      * @param key  the next key\n      * @return null always\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Compares the specified key to the stored key.\n-     * \n+     *\n      * @param key  the key to compare\n      * @return true if equal\n      */\n \n     /**\n      * Compares the specified value to the stored value.\n-     * \n+     *\n      * @param value  the value to compare\n      * @return true if equal\n      */\n         private final SingletonMap<K, V> parent;\n         private boolean hasNext = true;\n         private boolean canGetSet = false;\n-        \n+\n         SingletonMapIterator(final SingletonMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             }\n             return parent.setValue(value);\n         }\n-        \n+\n         public void reset() {\n             hasNext = true;\n         }\n-        \n+\n         @Override\n         public String toString() {\n             if (hasNext) {\n             return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n         }\n     }\n-    \n+\n     /**\n      * Values implementation for the SingletonMap.\n      * This class is needed as values is a view that must update as the map updates.\n             return new SingletonIterator<V>(parent.getValue(), false);\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Clones the map without cloning the key or value.\n \n     /**\n      * Compares this map with another.\n-     * \n+     *\n      * @param obj  the object to compare to\n      * @return true if equal\n      */\n \n     /**\n      * Gets the standard Map hashCode.\n-     * \n+     *\n      * @return the hash code defined in the Map interface\n      */\n     @Override\n     public int hashCode() {\n         return (getKey() == null ? 0 : getKey().hashCode()) ^\n-               (getValue() == null ? 0 : getValue().hashCode()); \n+               (getValue() == null ? 0 : getValue().hashCode());\n     }\n \n     /**\n      * Gets the map as a String.\n-     * \n+     *\n      * @return a string version of the map\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java\n  * A StaticBucketMap is an efficient, thread-safe implementation of\n  * <code>java.util.Map</code> that performs well in in a highly\n  * thread-contentious environment.  The map supports very efficient\n- * {@link #get(Object) get}, {@link #put(Object,Object) put}, \n+ * {@link #get(Object) get}, {@link #put(Object,Object) put},\n  * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\n  * operations, assuming (approximate) uniform hashing and\n  * that the number of entries does not exceed the number of buckets.  If the\n  * scenario that is proportional to the number of elements in the map\n  * (<i>O(n)</i>).<p>\n  *\n- * Each bucket in the hash table has its own monitor, so two threads can \n- * safely operate on the map at the same time, often without incurring any \n+ * Each bucket in the hash table has its own monitor, so two threads can\n+ * safely operate on the map at the same time, often without incurring any\n  * monitor contention.  This means that you don't have to wrap instances\n  * of this class with {@link java.util.Collections#synchronizedMap(Map)};\n- * instances are already thread-safe.  Unfortunately, however, this means \n- * that this map implementation behaves in ways you may find disconcerting.  \n+ * instances are already thread-safe.  Unfortunately, however, this means\n+ * that this map implementation behaves in ways you may find disconcerting.\n  * Bulk operations, such as {@link #putAll(Map) putAll} or the\n- * {@link Collection#retainAll(Collection) retainAll} operation in collection \n- * views, are <i>not</i> atomic.  If two threads are simultaneously \n- * executing \n+ * {@link Collection#retainAll(Collection) retainAll} operation in collection\n+ * views, are <i>not</i> atomic.  If two threads are simultaneously\n+ * executing\n  *\n  * <pre>\n  *   staticBucketMapInstance.putAll(map);\n  * </pre>\n  *\n  * then the results are generally random.  Those two statement could cancel\n- * each other out, leaving <code>staticBucketMapInstance</code> essentially \n- * unchanged, or they could leave some random subset of <code>map</code> in \n+ * each other out, leaving <code>staticBucketMapInstance</code> essentially\n+ * unchanged, or they could leave some random subset of <code>map</code> in\n  * <code>staticBucketMapInstance</code>.<p>\n  *\n- * Also, much like an encyclopedia, the results of {@link #size()} and \n+ * Also, much like an encyclopedia, the results of {@link #size()} and\n  * {@link #isEmpty()} are out-of-date as soon as they are produced.<p>\n  *\n  * The iterators returned by the collection views of this class are <i>not</i>\n- * fail-fast.  They will <i>never</i> raise a \n- * {@link java.util.ConcurrentModificationException}.  Keys and values \n+ * fail-fast.  They will <i>never</i> raise a\n+ * {@link java.util.ConcurrentModificationException}.  Keys and values\n  * added to the map after the iterator is created do not necessarily appear\n- * during iteration.  Similarly, the iterator does not necessarily fail to \n+ * during iteration.  Similarly, the iterator does not necessarily fail to\n  * return keys and values that were removed after the iterator was created.<p>\n  *\n  * Finally, unlike {@link java.util.HashMap}-style implementations, this\n- * class <i>never</i> rehashes the map.  The number of buckets is fixed \n- * at construction time and never altered.  Performance may degrade if \n+ * class <i>never</i> rehashes the map.  The number of buckets is fixed\n+ * at construction time and never altered.  Performance may degrade if\n  * you do not allocate enough buckets upfront.<p>\n  *\n  * The {@link #atomic(Runnable)} method is provided to allow atomic iterations\n  * will basically result in a map that's slower than an ordinary synchronized\n  * {@link java.util.HashMap}.\n  *\n- * Use this class if you do not require reliable bulk operations and \n- * iterations, or if you can make your own guarantees about how bulk \n+ * Use this class if you do not require reliable bulk operations and\n+ * iterations, or if you can make your own guarantees about how bulk\n  * operations will affect the map.<p>\n  *\n  * @since 3.0 (previously in main package v2.1)\n     /**\n      * Gets the current size of the map.\n      * The value is computed fresh each time the method is called.\n-     * \n+     *\n      * @return the current size\n      */\n     public int size() {\n \n     /**\n      * Checks if the size is currently zero.\n-     * \n+     *\n      * @return true if empty\n      */\n     public boolean isEmpty() {\n \n     /**\n      * Gets the value associated with the key.\n-     * \n+     *\n      * @param key  the key to retrieve\n      * @return the associated value\n      */\n \n     /**\n      * Checks if the map contains the specified key.\n-     * \n+     *\n      * @param key  the key to check\n      * @return true if found\n      */\n \n     /**\n      * Checks if the map contains the specified value.\n-     * \n+     *\n      * @param value  the value to check\n      * @return true if found\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Puts a new key value mapping into the map.\n-     * \n+     *\n      * @param key  the key to use\n      * @param value  the value to use\n      * @return the previous mapping for the key\n \n     /**\n      * Removes the specified key from the map.\n-     * \n+     *\n      * @param key  the key to remove\n      * @return the previous value at this key\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the key set.\n-     * \n+     *\n      * @return the key set\n      */\n     public Set<K> keySet() {\n \n     /**\n      * Gets the values.\n-     * \n+     *\n      * @return the values\n      */\n     public Collection<V> values() {\n \n     /**\n      * Gets the entry set.\n-     * \n+     *\n      * @return the entry set\n      */\n     public Set<Map.Entry<K, V>> entrySet() {\n     /**\n      * Puts all the entries from the specified map into this map.\n      * This operation is <b>not atomic</b> and may have undesired effects.\n-     * \n+     *\n      * @param map  the map of entries to add\n      */\n     public void putAll(final Map<? extends K, ? extends V> map) {\n \n     /**\n      * Compares this map to another, as per the Map specification.\n-     * \n+     *\n      * @param obj  the object to compare to\n      * @return true if equal\n      */\n \n     /**\n      * Gets the hash code, as per the Map specification.\n-     * \n+     *\n      * @return the hash code\n      */\n     @Override\n     /**\n      *  Prevents any operations from occurring on this map while the\n      *  given {@link Runnable} executes.  This method can be used, for\n-     *  instance, to execute a bulk operation atomically: \n+     *  instance, to execute a bulk operation atomically:\n      *\n      *  <pre>\n      *    staticBucketMapInstance.atomic(new Runnable() {\n--- a/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n      * @throws ClassNotFoundException\n      * @since 3.1\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n--- a/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java\n  * <strong>Note that TransformedSortedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n \n     /** Serialization version */\n     private static final long serialVersionUID = -8751771676410385778L;\n-    \n+\n     /**\n      * Factory method to create a transforming sorted map.\n      * <p>\n      * If there are any elements already in the map being decorated, they are NOT transformed.\n      * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * If there are any elements already in the map being decorated, they\n      * will be transformed by this method.\n      * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * <p>\n      * If there are any elements already in the collection being decorated, they\n      * are NOT transformed.</p>\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the predicate to validate the keys, null means no transformation\n      * @param valueTransformer  the predicate to validate to values, null means no transformation\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the map being decorated.\n-     * \n+     *\n      * @return the decorated map\n      */\n     protected SortedMap<K, V> getSortedMap() {\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n /**\n  * Decorates a map entry <code>Set</code> to ensure it can't be altered.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n \n     /**\n      * Factory method to create an unmodifiable set of Map Entry objects.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param set  the set to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n     public Iterator<Map.Entry<K, V>> iterator() {\n         return new UnmodifiableEntrySetIterator(collection.iterator());\n     }\n-    \n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Object[] toArray() {\n         }\n         return array;\n     }\n-    \n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T> T[] toArray(final T[] array) {\n         }\n         return array;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Implementation of an entry set iterator.\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n \n     /**\n      * Factory method to create an unmodifiable map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n \n     /**\n      * Factory method to create an unmodifiable sorted map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      * @since 3.1\n      */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n \n     /**\n      * Factory method to create an unmodifiable sorted map.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n     private UnmodifiableSortedMap(final SortedMap<K, V> map) {\n         super(map);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException", "timestamp": 1367351771, "metainfo": ""}