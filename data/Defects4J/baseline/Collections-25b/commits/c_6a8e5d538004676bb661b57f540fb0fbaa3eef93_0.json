{"sha": "6a8e5d538004676bb661b57f540fb0fbaa3eef93", "log": "Added new methods to CollectionUtils (plus associated test cases) #retainAll(Collection, Collection) #removeAll(Collection, Collection) #unmodifiableCollectionCopy(Collection)   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n  * Provides utility methods and decorators for {@link Collection} instances.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.62 $ $Date: 2004/07/17 21:38:33 $\n+ * @version $Revision: 1.63 $ $Date: 2004/12/11 06:30:38 $\n  * \n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  * @author Phil Steitz\n  * @author Steven Melzer\n  * @author Jon Schewe\n+ * @author Neil O'Toole\n  */\n public class CollectionUtils {\n \n         return UnmodifiableCollection.decorate(collection);\n     }\n \n+\t/**\n+\t * Returns an unmodifiable copy of the collection.\n+\t * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     * \n+\t * @param collection the <code>Collection</code> to copy.\n+\t * @return an unmodifiable <code>Collection</code>.\n+\t * @throws IllegalArgumentException if collection is null\n+\t */\n+\tpublic static Collection unmodifiableCollectionCopy(final Collection collection){\n+\t\tif (collection == null) throw new IllegalArgumentException(\"null not permitted.\");\n+\t\t\n+\t\tfinal Collection copy = new ArrayList(collection.size());\n+\t\tcopy.addAll(collection);\n+\t\treturn UnmodifiableCollection.decorate(copy);\n+\t}\n     /**\n      * Returns a predicated (validating) collection backed by the given collection.\n      * <p>\n     public static Collection transformedCollection(Collection collection, Transformer transformer) {\n         return TransformedCollection.decorate(collection, transformer);\n     }\n-    \n+   \n+\t/**\n+\t * Returns a collection containing all the elements in <code>collection</code>\n+\t * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+\t * in the returned collection is the same as the cardinality of <code>e</code>\n+\t * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+\t * case the cardinality is zero. This method is useful if you do not wish to modify\n+\t * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n+\t * \n+\t * @param collection the collection whose contents are the target of the #retailAll operation\n+\t * @param retain the collection containing the elements to be retained in the returned collection\n+\t * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n+\t * that occur at least once in <code>retain</code>.\n+\t * @throws NullPointerException if either parameter is null\n+\t */\n+\tpublic static Collection retainAll(final Collection collection, final Collection retain) {\n+\t\treturn ListUtils.retainAll(collection, retain);\n+\t}\n+\n+\t/**\n+\t * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+\t * method returns a collection containing all the elements in <code>c</code>\n+\t * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+\t * in the returned collection is the same as the cardinality of <code>e</code>\n+\t * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+\t * case the cardinality is zero. This method is useful if you do not wish to modify\n+\t * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+\t * \n+\t * @param collection the collection from which items are removed (in the returned collection)\n+\t * @param remove the items to be removed from the returned <code>collection</code>\n+\t * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n+\t * any elements that also occur in <code>remove</code>.\n+\t * @throws NullPointerException if either parameter is null\n+\t */\n+\tpublic static Collection removeAll(final Collection collection, final Collection remove) {\n+\t\treturn ListUtils.retainAll(collection, remove);\n+\t}\n+\t\n+\n }\n--- a/src/test/org/apache/commons/collections/TestCollectionUtils.java\n+++ b/src/test/org/apache/commons/collections/TestCollectionUtils.java\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.HashSet;\n  * @author Stephen Colebourne\n  * @author Phil Steitz\n  * @author Steven Melzer\n+ * @author Neil O'Toole\n  * \n- * @version $Revision: 1.41 $ $Date: 2004/08/03 18:20:41 $\n+ * @version $Revision: 1.42 $ $Date: 2004/12/11 06:30:38 $\n  */\n public class TestCollectionUtils extends TestCase {\n     \n             // expected\n         }  \n     }\n-\n+    \n+    public void testUnmodifiableCollectionCopy() {\n+\t\tCollection collection = new ArrayList();\n+\t\tcollection.add(\"a\");\n+    \tCollection copy = CollectionUtils.unmodifiableCollectionCopy(collection);\n+\n+\t\tassertTrue(copy instanceof Unmodifiable);\n+\t\tassertTrue(CollectionUtils.isEqualCollection(collection, copy));\n+\t\tcollection.clear();\n+\t\tassertTrue(copy.isEmpty() == false);\n+\n+\t\ttry\n+\t\t{\n+\t\t\tcopy.clear();\n+\t\t\tfail(\"should be unmodifiable.\");\n+\t\t}\n+\t\tcatch (UnsupportedOperationException uoe)\n+\t\t{} // this is what we want\n+\t\t\n+\t\ttry\n+\t\t{\n+\t\t\tcopy = CollectionUtils.unmodifiableCollectionCopy(null);\n+\t\t\tfail(\"should throw IllegalArgumentException\");\n+\t\t}\n+\t\tcatch(IllegalArgumentException iae)\n+\t\t{}\n+\t}\n+    \n }", "timestamp": 1102746638, "metainfo": ""}