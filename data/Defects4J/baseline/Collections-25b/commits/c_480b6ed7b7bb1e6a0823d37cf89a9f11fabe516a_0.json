{"sha": "480b6ed7b7bb1e6a0823d37cf89a9f11fabe516a", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r813954 | sebb | 2009-09-11 10:50:42 -0700 (Fri, 11 Sep 2009) | 2 lines          Make private immutable variables final     Add missing @Override markers and fix some raw types     ------------------------------------------------------------------------     r740150 | mbenson | 2009-02-02 15:24:00 -0800 (Mon, 02 Feb 2009) | 1 line          make all [collections] maps implement IterableMap     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n+++ b/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n  * @author Janek Bogucki\n  * @author Kazuya Ujihara\n  */\n-public final class StaticBucketMap implements Map {\n+public final class StaticBucketMap<K, V> extends AbstractIterableMap<K, V> {\n \n     /** The default number of buckets to use */\n     private static final int DEFAULT_BUCKETS = 255;\n     /** The array of buckets, where the actual data is held */\n-    private Node[] buckets;\n+    private final Node<K, V>[] buckets;\n     /** The matching array of locks */\n-    private Lock[] locks;\n+    private final Lock[] locks;\n \n     /**\n      * Initializes the map with the default number of buckets (255).\n      *\n      * @param numBuckets  the number of buckets for this map\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public StaticBucketMap(int numBuckets) {\n         int size = Math.max(17, numBuckets);\n \n      * @param key  the key to retrieve\n      * @return the associated value\n      */\n-    public Object get(final Object key) {\n+    public V get(final Object key) {\n         int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n-            Node n = buckets[hash];\n+            Node<K, V> n = buckets[hash];\n \n             while (n != null) {\n                 if (n.key == key || (n.key != null && n.key.equals(key))) {\n         int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n-            Node n = buckets[hash];\n+            Node<K, V> n = buckets[hash];\n \n             while (n != null) {\n                 if (n.key == key || (n.key != null && n.key.equals(key))) {\n     public boolean containsValue(final Object value) {\n         for (int i = 0; i < buckets.length; i++) {\n             synchronized (locks[i]) {\n-                Node n = buckets[i];\n+                Node<K, V> n = buckets[i];\n \n                 while (n != null) {\n                     if (n.value == value || (n.value != null && n.value.equals(value))) {\n      * @param value  the value to use\n      * @return the previous mapping for the key\n      */\n-    public Object put(final Object key, final Object value) {\n+    public V put(final K key, final V value) {\n         int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n-            Node n = buckets[hash];\n+            Node<K, V> n = buckets[hash];\n \n             if (n == null) {\n-                n = new Node();\n+                n = new Node<K, V>();\n                 n.key = key;\n                 n.value = value;\n                 buckets[hash] = n;\n             // Set n to the last node in the linked list.  Check each key along the way\n             //  If the key is found, then change the value of that node and return\n             //  the old value.\n-            for (Node next = n; next != null; next = next.next) {\n+            for (Node<K, V> next = n; next != null; next = next.next) {\n                 n = next;\n \n                 if (n.key == key || (n.key != null && n.key.equals(key))) {\n-                    Object returnVal = n.value;\n+                    V returnVal = n.value;\n                     n.value = value;\n                     return returnVal;\n                 }\n \n             // The key was not found in the current list of nodes, add it to the end\n             //  in a new node.\n-            Node newNode = new Node();\n+            Node<K, V> newNode = new Node<K, V>();\n             newNode.key = key;\n             newNode.value = value;\n             n.next = newNode;\n      * @param key  the key to remove\n      * @return the previous value at this key\n      */\n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n-            Node n = buckets[hash];\n-            Node prev = null;\n+            Node<K, V> n = buckets[hash];\n+            Node<K, V> prev = null;\n \n             while (n != null) {\n                 if (n.key == key || (n.key != null && n.key.equals(key))) {\n         }\n         return null;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the key set.\n      * \n      * @return the key set\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         return new KeySet();\n     }\n \n      * \n      * @return the values\n      */\n-    public Collection values() {\n+    public Collection<V> values() {\n         return new Values();\n     }\n \n      * \n      * @return the entry set\n      */\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         return new EntrySet();\n     }\n \n      * \n      * @param map  the map of entries to add\n      */\n-    public void putAll(Map map) {\n-        Iterator i = map.entrySet().iterator();\n-\n-        while (i.hasNext()) {\n-            Map.Entry entry = (Entry) i.next();\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n      * @param obj  the object to compare to\n      * @return true if equal\n      */\n+    @Override\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n         }\n-        if (obj instanceof Map == false) {\n+        if (obj instanceof Map<?, ?> == false) {\n             return false;\n         }\n-        Map other = (Map) obj;\n+        Map<?, ?> other = (Map<?, ?>) obj;\n         return entrySet().equals(other.entrySet());\n     }\n \n      * \n      * @return the hash code\n      */\n+    @Override\n     public int hashCode() {\n         int hashCode = 0;\n \n         for (int i = 0; i < buckets.length; i++) {\n             synchronized (locks[i]) {\n-                Node n = buckets[i];\n+                Node<K, V> n = buckets[i];\n \n                 while (n != null) {\n                     hashCode += n.hashCode();\n     /**\n      * The Map.Entry for the StaticBucketMap.\n      */\n-    private static final class Node implements Map.Entry, KeyValue {\n-        protected Object key;\n-        protected Object value;\n-        protected Node next;\n-\n-        public Object getKey() {\n+    private static final class Node<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+        protected K key;\n+        protected V value;\n+        protected Node<K, V> next;\n+\n+        public K getKey() {\n             return key;\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             return value;\n         }\n \n+        @Override\n         public int hashCode() {\n             return ((key == null ? 0 : key.hashCode()) ^\n                     (value == null ? 0 : value.hashCode()));\n         }\n \n+        @Override\n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n-            if (obj instanceof Map.Entry == false) {\n+            if (obj instanceof Map.Entry<?, ?> == false) {\n                 return false;\n             }\n \n-            Map.Entry e2 = (Map.Entry) obj;\n+            Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n             return (\n                 (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n                 (value == null ? e2.getValue() == null : value.equals(e2.getValue())));\n         }\n \n-        public Object setValue(Object obj) {\n-            Object retVal = value;\n+        public V setValue(V obj) {\n+            V retVal = value;\n             value = obj;\n             return retVal;\n         }\n     }\n \n-\n     /**\n      * The lock object, which also includes a count of the nodes in this lock.\n      */\n         public int size;\n     }\n \n-\n     //-----------------------------------------------------------------------\n-    private class EntryIterator implements Iterator {\n-\n-        private ArrayList current = new ArrayList();\n+    private class BaseIterator {\n+        private ArrayList<Map.Entry<K, V>> current = new ArrayList<Map.Entry<K,V>>();\n         private int bucket;\n-        private Map.Entry last;\n-\n+        private Map.Entry<K, V> last;\n \n         public boolean hasNext() {\n             if (current.size() > 0) return true;\n             while (bucket < buckets.length) {\n                 synchronized (locks[bucket]) {\n-                    Node n = buckets[bucket];\n+                    Node<K, V> n = buckets[bucket];\n                     while (n != null) {\n                         current.add(n);\n                         n = n.next;\n             return false;\n         }\n \n-        protected Map.Entry nextEntry() {\n+        protected Map.Entry<K, V> nextEntry() {\n             if (!hasNext()) throw new NoSuchElementException();\n-            last = (Map.Entry)current.remove(current.size() - 1);\n+            last = current.remove(current.size() - 1);\n             return last;\n-        }\n-\n-        public Object next() {\n-            return nextEntry();\n         }\n \n         public void remove() {\n             StaticBucketMap.this.remove(last.getKey());\n             last = null;\n         }\n-\n-    }\n-\n-    private class ValueIterator extends EntryIterator {\n-\n-        public Object next() {\n+    }\n+\n+    private class EntryIterator extends BaseIterator implements Iterator<Map.Entry<K, V>> {\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+    }\n+\n+    private class ValueIterator extends BaseIterator implements Iterator<V> {\n+\n+        public V next() {\n             return nextEntry().getValue();\n         }\n \n     }\n \n-    private class KeyIterator extends EntryIterator {\n-\n-        public Object next() {\n+    private class KeyIterator extends BaseIterator implements Iterator<K> {\n+\n+        public K next() {\n             return nextEntry().getKey();\n         }\n \n     }\n \n-    private class EntrySet extends AbstractSet {\n-\n+    private class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n+\n+        @Override\n         public int size() {\n             return StaticBucketMap.this.size();\n         }\n \n+        @Override\n         public void clear() {\n             StaticBucketMap.this.clear();\n         }\n \n-        public Iterator iterator() {\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n             return new EntryIterator();\n         }\n \n+        @Override\n         public boolean contains(Object obj) {\n-            Map.Entry entry = (Map.Entry) obj;\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n             int hash = getHash(entry.getKey());\n             synchronized (locks[hash]) {\n-                for (Node n = buckets[hash]; n != null; n = n.next) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                     if (n.equals(entry)) return true;\n                 }\n             }\n             return false;\n         }\n \n+        @Override\n         public boolean remove(Object obj) {\n-            if (obj instanceof Map.Entry == false) {\n+            if (obj instanceof Map.Entry<?, ?> == false) {\n                 return false;\n             }\n-            Map.Entry entry = (Map.Entry) obj;\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n             int hash = getHash(entry.getKey());\n             synchronized (locks[hash]) {\n-                for (Node n = buckets[hash]; n != null; n = n.next) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                     if (n.equals(entry)) {\n                         StaticBucketMap.this.remove(n.getKey());\n                         return true;\n \n     }\n \n-\n-    private class KeySet extends AbstractSet {\n-\n+    private class KeySet extends AbstractSet<K> {\n+\n+        @Override\n         public int size() {\n             return StaticBucketMap.this.size();\n         }\n \n+        @Override\n         public void clear() {\n             StaticBucketMap.this.clear();\n         }\n \n-        public Iterator iterator() {\n+        @Override\n+        public Iterator<K> iterator() {\n             return new KeyIterator();\n         }\n \n+        @Override\n         public boolean contains(Object obj) {\n             return StaticBucketMap.this.containsKey(obj);\n         }\n \n+        @Override\n         public boolean remove(Object obj) {\n             int hash = getHash(obj);\n             synchronized (locks[hash]) {\n-                for (Node n = buckets[hash]; n != null; n = n.next) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                     Object k = n.getKey();\n                     if ((k == obj) || ((k != null) && k.equals(obj))) {\n                         StaticBucketMap.this.remove(k);\n                 }\n             }\n             return false;\n-\n-        }\n-\n-    }\n-\n-\n-    private class Values extends AbstractCollection {\n-\n+        }\n+\n+    }\n+\n+\n+    private class Values extends AbstractCollection<V> {\n+\n+        @Override\n         public int size() {\n             return StaticBucketMap.this.size();\n         }\n \n+        @Override\n         public void clear() {\n             StaticBucketMap.this.clear();\n         }\n \n-        public Iterator iterator() {\n+        @Override\n+        public Iterator<V> iterator() {\n             return new ValueIterator();\n         }\n \n     }\n-\n \n     /**\n      *  Prevents any operations from occurring on this map while the", "timestamp": 1252994175, "metainfo": ""}