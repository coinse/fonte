{"sha": "1decf8b6fb10004cf19e48f5fc947c444a02c415", "log": "Refactor CommonsLinkedList and NodeCachingLinkedList to list subpackage   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CommonsLinkedList.java\n+++ b/src/java/org/apache/commons/collections/CommonsLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/CommonsLinkedList.java,v 1.9 2003/10/09 20:58:52 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/CommonsLinkedList.java,v 1.10 2003/12/11 00:18:06 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n import java.lang.reflect.Array;\n import java.util.Collection;\n import java.util.ConcurrentModificationException;\n  * of {@link LinkedList}, but which provides a more open interface for\n  * subclasses to extend.\n  * \n+ * @deprecated TO BE REMOVED BEFORE v3.0\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.9 $ $Date: 2003/10/09 20:58:52 $\n+ * @version $Revision: 1.10 $ $Date: 2003/12/11 00:18:06 $\n  * \n  * @author Rich Dougherty\n  * @author Phil Steitz\n  */\n class CommonsLinkedList extends LinkedList\n-        implements List, Serializable {\n+        implements List {\n \n     /*\n      * Implementation notes:\n--- a/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n+++ b/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/NodeCachingLinkedList.java,v 1.9 2003/10/09 20:58:52 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/NodeCachingLinkedList.java,v 1.10 2003/12/11 00:18:06 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * unnecessary object creates and deletion. This should result in a performance\n  * improvement.\n  * \n+ * @deprecated TO BE REMOVED BEFORE v3.0\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.9 $ $Date: 2003/10/09 20:58:52 $\n+ * @version $Revision: 1.10 $ $Date: 2003/12/11 00:18:06 $\n  * \n  * @author Jeff Varszegi\n  * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/AbstractLinkedList.java,v 1.1 2003/12/11 00:18:06 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.OrderedIterator;\n+\n+/**\n+ * An abstract implementation of a linked list which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * Overridable methods are provided to change the storage node, and to change how\n+ * entries are added to and removed from the map. Hopefully, all you need for\n+ * unusual subclasses is here.\n+ * <p>\n+ * This class currently extends AbstractList, but do not rely on that. It may change.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/11 00:18:06 $\n+ *\n+ * @author Rich Dougherty\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractLinkedList extends AbstractList implements List {\n+\n+    /*\n+     * Implementation notes:\n+     * - a standard circular doubly-linked list\n+     * - a marker node is stored to mark the start and the end of the list\n+     * - node creation and removal always occurs through createNode() and\n+     *   removeNode().\n+     * - a modification count is kept, with the same semantics as\n+     * {@link java.util.LinkedList}.\n+     * - respects {@link AbstractList#modCount}\n+     * - only extends AbstractList for subList() - TODO\n+     */\n+\n+    /**\n+     * A {@link Node} which indicates the start and end of the list and does not\n+     * hold a value. The value of <code>next</code> is the first item in the\n+     * list. The value of of <code>previous</code> is the last item in the list.\n+     */\n+    protected transient Node header;\n+    /** The size of the list */\n+    protected transient int size;\n+//    /** Modification count for iterators */\n+//    protected transient int modCount;\n+\n+    /**\n+     * Constructor that does nothing intended for deserialization.\n+     * <p>\n+     * If this constructor is used by a serializable subclass then the init()\n+     * method must be called.\n+     */\n+    protected AbstractLinkedList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a list copying data from the specified collection.\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    protected AbstractLinkedList(Collection coll) {\n+        super();\n+        init();\n+        addAll(coll);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor, broken out so it can be called\n+     * by any constructor and by <code>readObject</code>.\n+     * Subclasses which override this method should make sure they call super,\n+     * so the list is initialised properly.\n+     */\n+    protected void init() {\n+        header = createHeaderNode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int size() {\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    public Object get(int index) {\n+        Node node = getNode(index, false);\n+        return node.value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Iterator iterator() {\n+        return listIterator();\n+    }\n+\n+    public ListIterator listIterator() {\n+        return new LinkedListIterator();\n+    }\n+\n+    public ListIterator listIterator(int startIndex) {\n+        return new LinkedListIterator(startIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int indexOf(Object value) {\n+        int i = 0;\n+        for (Node node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.value, value)) {\n+                return i;\n+            }\n+            i++;\n+        }\n+        return -1;\n+    }\n+\n+    public int lastIndexOf(Object value) {\n+        int i = size - 1;\n+        for (Node node = header.previous; node != header; node = node.previous) {\n+            if (isEqualValue(node.value, value)) {\n+                return i;\n+            }\n+            i--;\n+        }\n+        return -1;\n+    }\n+\n+    public boolean contains(Object value) {\n+        return indexOf(value) != -1;\n+    }\n+\n+    public boolean containsAll(Collection coll) {\n+        Iterator it = coll.iterator();\n+        while (it.hasNext()) {\n+            if (contains(it.next()) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public boolean add(Object value) {\n+        addLast(value);\n+        return true;\n+    }\n+    \n+    public void add(int index, Object value) {\n+        Node node = getNode(index, true);\n+        addNodeBefore(node, value);\n+    }\n+    \n+    public boolean addAll(Collection coll) {\n+        return addAll(size, coll);\n+    }\n+\n+    public boolean addAll(int index, Collection coll) {\n+        Node node = getNode(index, true);\n+        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n+            Object value = itr.next();\n+            addNodeBefore(node, value);\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Object remove(int index) {\n+        Node node = getNode(index, false);\n+        Object oldValue = node.value;\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public boolean remove(Object value) {\n+        for (Node node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.value, value)) {\n+                removeNode(node);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean removeAll(Collection coll) {\n+        boolean modified = false;\n+        Iterator it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean retainAll(Collection coll) {\n+        boolean modified = false;\n+        Iterator it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next()) == false) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    public Object set(int index, Object value) {\n+        Node node = getNode(index, false);\n+        Object oldValue = node.value;\n+        node.value = value;\n+        return oldValue;\n+    }\n+\n+    public void clear() {\n+        removeAllNodes();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public Object[] toArray() {\n+        return toArray(new Object[size]);\n+    }\n+\n+    public Object[] toArray(Object[] array) {\n+        // Extend the array if needed\n+        if (array.length < size) {\n+            Class componentType = array.getClass().getComponentType();\n+            array = (Object[]) Array.newInstance(componentType, size);\n+        }\n+        // Copy the values into the array\n+        Node node = header.next;\n+        for (int i = 0; i < size; i++) {\n+            array[i] = node.value;\n+            node = node.next;\n+        }\n+        // Set the value after the last value to null\n+        if (array.length > size) {\n+            array[size] = null;\n+        }\n+        return array;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Object getFirst() {\n+        Node node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.value;\n+    }\n+\n+    public Object getLast() {\n+        Node node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.value;\n+    }\n+\n+    public void addFirst(Object o) {\n+        addNodeAfter(header, o);\n+    }\n+\n+    public void addLast(Object o) {\n+        addNodeBefore(header, o);\n+    }\n+\n+    public Object removeFirst() {\n+        Node node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        Object oldValue = node.value;\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public Object removeLast() {\n+        Node node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        Object oldValue = node.value;\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof List == false) {\n+            return false;\n+        }\n+        List other = (List) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        ListIterator it1 = listIterator();\n+        ListIterator it2 = other.listIterator();\n+        while (it1.hasNext() && it2.hasNext()) {\n+            Object o1 = it1.next();\n+            Object o2 = it2.next();\n+            if (!(o1 == null ? o2 == null : o1.equals(o2)))\n+                return false;\n+        }\n+        return !(it1.hasNext() || it2.hasNext());\n+    }\n+\n+    public int hashCode() {\n+        int hashCode = 1;\n+        Iterator it = iterator();\n+        while (it.hasNext()) {\n+            Object obj = it.next();\n+            hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+        }\n+        return hashCode;\n+    }\n+\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"[]\";\n+        }\n+        StringBuffer buf = new StringBuffer(16 * size());\n+        buf.append(\"[\");\n+\n+        Iterator it = iterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            Object value = it.next();\n+            buf.append(value == this ? \"(this Collection)\" : value);\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+        buf.append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses the equals method.\n+     * Subclasses can override this to match differently.\n+     * \n+     * @param value1  the first value to compare, may be null\n+     * @param value2  the second value to compare, may be null\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return (value1 == value2 || (value1 == null ? false : value1.equals(value2)));\n+    }\n+    \n+    /**\n+     * Creates a new node with previous, next and element all set to null.\n+     * This implementation creates a new empty Node.\n+     * Subclasses can override this to create a different class.\n+     * \n+     * @return  newly created node\n+     */\n+    protected Node createHeaderNode() {\n+        return new Node();\n+    }\n+\n+    /**\n+     * Creates a new node with the specified properties.\n+     * This implementation creates a new Node with data.\n+     * Subclasses can override this to create a different class.\n+     * \n+     * @param previous  node to precede the new node\n+     * @param next  node to follow the new node\n+     * @param value  value of the new node\n+     */\n+    protected Node createNode(Node previous, Node next, Object value) {\n+        return new Node(previous, next, value);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its \n+     * <code>value</code> and inserts it before <code>node</code>.\n+     *\n+     * @param node  node to insert before\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void addNodeBefore(Node node, Object value) {\n+        Node newNode = createNode(node.previous, node, value);\n+        node.previous.next = newNode;\n+        node.previous = newNode;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its \n+     * <code>value</code> and inserts it after <code>node</code>.\n+     * \n+     * @param node  node to insert after\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void addNodeAfter(Node node, Object value) {\n+        Node newNode = createNode(node, node.next, value);\n+        node.next.previous = newNode;\n+        node.next = newNode;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void removeNode(Node node) {\n+        node.previous.next = node.next;\n+        node.next.previous = node.previous;\n+        size--;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes all nodes by resetting the circular list marker.\n+     */\n+    protected void removeAllNodes() {\n+        header.next = header;\n+        header.previous = header;\n+        size = 0;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Gets the node at a particular index.\n+     * \n+     * @param index  the index, starting from 0\n+     * @param endMarkerAllowed  whether or not the end marker can be returned if\n+     * startIndex is set to the list's size\n+     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n+     * the size of the list and endMakerAllowed is false; or greater than the\n+     * size of the list\n+     */\n+    protected Node getNode(int index, boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+        // Check the index is within the bounds\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") less than zero.\");\n+        }\n+        if (!endMarkerAllowed && index == size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") is the size of the list.\");\n+        }\n+        if (index > size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") greater than the size of the \" +\n+                    \"list (\" + size + \").\");\n+        }\n+        // Search the list and get the node\n+        Node node;\n+        if (index < (size / 2)) {\n+            // Search forwards\n+            node = header.next;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                node = node.next;\n+            }\n+        } else {\n+            // Search backwards\n+            node = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                node = node.previous;\n+            }\n+        }\n+        return node;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * <code>writeObject</code>.\n+     */\n+    protected void doWriteObject(ObjectOutputStream outputStream) throws IOException {\n+        // Write the size so we know how many nodes to read back\n+        outputStream.writeInt(size());\n+        for (Iterator itr = iterator(); itr.hasNext();) {\n+            outputStream.writeObject(itr.next());\n+        }\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * <code>readObject</code>.\n+     */\n+    protected void doReadObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n+        init();\n+        int size = inputStream.readInt();\n+        for (int i = 0; i < size; i++) {\n+            add(inputStream.readObject());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node within the linked list.\n+     * \n+     * @author Rich Dougherty\n+     * @author Stephen Colebourne\n+     */\n+    protected static class Node {\n+\n+        /** A pointer to the node before this node */\n+        public Node previous;\n+        /** A pointer to the node after this node */\n+        public Node next;\n+        /** The object contained within this node */\n+        public Object value;\n+\n+        /**\n+         * Constructs a new header node.\n+         */\n+        public Node() {\n+            super();\n+            previous = this;\n+            next = this;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         * \n+         * @param previous  the previous node in the list\n+         * @param next  the next node in the list\n+         * @param value  the value to store\n+         */\n+        public Node(Node previous, Node next, Object value) {\n+            super();\n+            this.previous = previous;\n+            this.next = next;\n+            this.value = value;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A list iterator over the linked list.\n+     * \n+     * @author Rich Dougherty\n+     */\n+    protected class LinkedListIterator implements ListIterator, OrderedIterator {\n+\n+        /**\n+         * The node that will be returned by {@link #next()}. If this is equal\n+         * to {@link #marker} then there are no more values to return.\n+         */\n+        protected Node nextNode;\n+\n+        /**\n+         * The index of {@link #nextNode}.\n+         */\n+        protected int nextIndex;\n+\n+        /**\n+         * The last node that was returned by {@link #next()} or {@link\n+         * #previous()}. Set to <code>null</code> if {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Should be accesed through {@link #getLastNodeReturned()} to enforce\n+         * this behaviour.\n+         */\n+        protected Node lastNodeReturned;\n+\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list, starting at the first value in\n+         * the list.\n+         */\n+        public LinkedListIterator() throws IndexOutOfBoundsException {\n+            this(0);\n+        }\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         * \n+         * @param startIndex The index to start at.\n+         */\n+        public LinkedListIterator(int startIndex) throws IndexOutOfBoundsException {\n+            super();\n+            expectedModCount = modCount;\n+            nextNode = getNode(startIndex, true);\n+            nextIndex = startIndex;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         * \n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount()\n+            throws ConcurrentModificationException {\n+            if (modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        /**\n+         * Gets the last node returned.\n+         * \n+         * @throws IllegalStateException If {@link #next()} or\n+         * {@link #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         */\n+        protected Node getLastNodeReturned() throws IllegalStateException {\n+            if (lastNodeReturned == null) {\n+                throw new IllegalStateException();\n+            }\n+            return lastNodeReturned;\n+        }\n+\n+        public boolean hasNext() {\n+            return nextNode != header;\n+        }\n+\n+        public Object next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" +\n+                        nextIndex + \".\");\n+            }\n+            Object value = nextNode.value;\n+            lastNodeReturned = nextNode;\n+            nextNode = nextNode.next;\n+            nextIndex++;\n+            return value;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return nextNode.previous != header;\n+        }\n+\n+        public Object previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            nextNode = nextNode.previous;\n+            Object value = nextNode.value;\n+            lastNodeReturned = nextNode;\n+            nextIndex--;\n+            return value;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            removeNode(getLastNodeReturned());\n+            lastNodeReturned = null;\n+            nextIndex--;\n+            expectedModCount++;\n+        }\n+\n+        public void set(Object o) {\n+            checkModCount();\n+            getLastNodeReturned().value = o;\n+        }\n+\n+        public void add(Object o) {\n+            checkModCount();\n+            addNodeBefore(nextNode, o);\n+            lastNodeReturned = null;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java,v 1.1 2003/12/11 00:18:06 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * A linked list implementation that caches the nodes used internally to prevent\n+ * unnecessary object creates and deletion. This results in a performance\n+ * improvement for long-lived lists which both add and remove.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/11 00:18:06 $\n+ * \n+ * @author Jeff Varszegi\n+ * @author Rich Dougherty\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class NodeCachingLinkedList extends AbstractLinkedList implements Serializable {\n+\n+    /** Serialization version */\n+    static final long serialVersionUID = 6897789178562232073L;\n+\n+    /**\n+     * The default value for {@link #maximumCacheSize}.\n+     */\n+    protected static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n+\n+    /**\n+     * The first cached node, or <code>null</code> if no nodes are cached.\n+     * Cached nodes are stored in a singly-linked list with {@link Node#next}\n+     * pointing to the next element.\n+     */\n+    protected transient Node firstCachedNode;\n+    \n+    /**\n+     * The size of the cache.\n+     */\n+    protected transient int cacheSize;\n+\n+    /**\n+     * The maximum size of the cache.\n+     */\n+    protected int maximumCacheSize;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates.\n+     */\n+    public NodeCachingLinkedList() {\n+        this(DEFAULT_MAXIMUM_CACHE_SIZE);\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public NodeCachingLinkedList(Collection coll) {\n+        super(coll);\n+        this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n+    }\n+    \n+    /**\n+     * Constructor that species the maximum cache size.\n+     *\n+     * @param maximumCacheSize  the maximum cache size\n+     */\n+    public NodeCachingLinkedList(int maximumCacheSize) {\n+        super();\n+        this.maximumCacheSize = maximumCacheSize;\n+        init();  // must call init() as use super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the maximum size of the cache.\n+     */\n+    protected int getMaximumCacheSize() {\n+        return maximumCacheSize;\n+    }\n+\n+    /**\n+     * Sets the maximum size of the cache.\n+     */\n+    protected void setMaximumCacheSize(int maximumCacheSize) {\n+        this.maximumCacheSize = maximumCacheSize;\n+        shrinkCacheToMaximumSize();\n+    }\n+\n+    /**\n+     * Reduce the size of the cache to the maximum, if necessary.\n+     */\n+    protected void shrinkCacheToMaximumSize() {\n+        // Rich Dougherty: This could be more efficient.\n+        while (cacheSize > maximumCacheSize) {\n+            getNodeFromCache();\n+        }\n+    }\n+    \n+    /**\n+     * Gets a node from the cache. If a node is returned, then the value of\n+     * {@link #cacheSize} is decreased accordingly. The node that is returned\n+     * will have <code>null</code> values for next, previous and element.\n+     *\n+     * @return A node, or <code>null</code> if there are no nodes in the cache.\n+     */\n+    protected Node getNodeFromCache() {\n+        if (cacheSize == 0) {\n+            return null;\n+        }\n+        Node cachedNode = firstCachedNode;\n+        firstCachedNode = cachedNode.next;\n+        cachedNode.next = null; // This should be changed anyway, but defensively\n+                                // set it to null.                    \n+        cacheSize--;\n+        return cachedNode;\n+    }\n+    \n+    protected boolean isCacheFull() {\n+        return cacheSize >= maximumCacheSize;\n+    }\n+    \n+    /**\n+     * Adds a node to the cache, if the cache isn't full. The node's contents\n+     * are cleared to so they can be garbage collected.\n+     */\n+    protected void addNodeToCache(Node node) {\n+        if (isCacheFull()) {\n+            // Don't cache the node.\n+            return;\n+        }\n+        // Clear the node's contents and add it to the cache.\n+        Node nextCachedNode = firstCachedNode;\n+        node.previous = null;\n+        node.next = nextCachedNode;\n+        node.value = null;\n+        firstCachedNode = node;\n+        cacheSize++;\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Create a node, getting it from the cache if possible.\n+     */\n+    protected Node createHeaderNode() {\n+        Node cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createHeaderNode();\n+        } else {\n+            return cachedNode;\n+        }\n+    }\n+    \n+    /**\n+     * Creates a new node with the specified properties, using a cached Node\n+     * if possible.\n+     * \n+     * @param previous  node to precede the new node\n+     * @param next  node to follow the new node\n+     * @param value  value of the new node\n+     */\n+    protected Node createNode(Node previous, Node next, Object value) {\n+        Node cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode(previous, next, value);\n+        } else {\n+            cachedNode.next = next;\n+            cachedNode.previous = previous;\n+            cachedNode.value = value;\n+            return cachedNode;\n+        }\n+    }\n+\n+    /**\n+     * Calls the superclass' implementation then calls\n+     * <code>addNodeToCache</code> on the node which has \n+     * been removed.\n+     */\n+    protected void removeNode(Node node) {\n+        super.removeNode(node);\n+        addNodeToCache(node);\n+    }\n+    \n+    protected void removeAllNodes() {\n+        // Add the removed nodes to the cache, then remove the rest.\n+        // We can add them to the cache before removing them, since\n+        // {@link AbstractLinkedList.removeAllNodes()} removes the\n+        // nodes by removing references directly from {@link #header}.\n+        int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n+        Node node = header.next;\n+        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n+            Node oldNode = node;\n+            node = node.next;\n+            addNodeToCache(oldNode);\n+        }\n+        super.removeAllNodes();        \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestCommonsLinkedList.java\n+++ b/src/test/org/apache/commons/collections/TestCommonsLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCommonsLinkedList.java,v 1.7 2003/10/06 21:02:50 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCommonsLinkedList.java,v 1.8 2003/12/11 00:18:06 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Test case for {@link CommonsLinkedList}.\n  * \n- * @version $Revision: 1.7 $ $Date: 2003/10/06 21:02:50 $\n+ * @version $Revision: 1.8 $ $Date: 2003/12/11 00:18:06 $\n  * \n  * @author Rich Dougherty\n  * @author David Hay\n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n+    \n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+    public void testCanonicalEmptyCollectionExists() {\n+    }\n+    public void testCanonicalFullCollectionExists() {\n+    }\n+\n     \n     public void setUp() {\n         list = (CommonsLinkedList)makeEmptyList();\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/list/TestAbstractLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestAbstractLinkedList.java,v 1.1 2003/12/11 00:18:06 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Test case for {@link AbstractLinkedList}.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/12/11 00:18:06 $\n+ * \n+ * @author Rich Dougherty\n+ * @author David Hay\n+ * @author Phil Steitz\n+ */\n+public abstract class TestAbstractLinkedList extends AbstractTestList {\n+    \n+    public TestAbstractLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public void testRemoveFirst() {\n+        resetEmpty();\n+        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        if (isRemoveSupported() == false) {\n+            try {\n+                list.removeFirst();\n+            } catch (UnsupportedOperationException ex) {}\n+        } \n+        \n+        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n+        assertEquals( \"value1\", list.removeFirst() );\n+        checkNodes();\n+        list.addLast( \"value3\");\n+        checkNodes();\n+        assertEquals( \"value2\", list.removeFirst() );\n+        assertEquals( \"value3\", list.removeFirst() );\n+        checkNodes();\n+        list.addLast( \"value4\" );\n+        checkNodes();\n+        assertEquals( \"value4\", list.removeFirst() );\n+        checkNodes();\n+    }\n+    \n+    public void testRemoveLast() {\n+        resetEmpty();\n+        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        if (isRemoveSupported() == false) {\n+            try {\n+                list.removeLast();\n+            } catch (UnsupportedOperationException ex) {}\n+        } \n+        \n+        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n+        assertEquals( \"value2\", list.removeLast() );\n+        list.addFirst( \"value3\");\n+        checkNodes();\n+        assertEquals( \"value1\", list.removeLast() );\n+        assertEquals( \"value3\", list.removeLast() );\n+        list.addFirst( \"value4\" );\n+        checkNodes();\n+        assertEquals( \"value4\", list.removeFirst() );\n+    }\n+    \n+    public void testAddNodeAfter() {\n+        resetEmpty();\n+        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        if (isAddSupported() == false) {\n+            try {\n+                list.addFirst(null);\n+            } catch (UnsupportedOperationException ex) {}\n+        } \n+        \n+        list.addFirst(\"value1\");\n+        list.addNodeAfter(list.getNode(0,false),\"value2\");\n+        assertEquals(\"value1\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.removeFirst();\n+        checkNodes();\n+        list.addNodeAfter(list.getNode(0,false),\"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        list.addNodeAfter(list.getNode(0, false),\"value4\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        assertEquals(\"value4\", list.get(1));\n+        list.addNodeAfter(list.getNode(2, false), \"value5\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value4\", list.get(1));\n+        assertEquals(\"value3\", list.get(2));\n+        assertEquals(\"value5\", list.getLast());\n+    }\n+    \n+    public void testRemoveNode() {\n+        resetEmpty();\n+        if (isAddSupported() == false || isRemoveSupported() == false) return;\n+        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        \n+        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.addFirst(\"value1\");\n+        list.addFirst(\"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value0\", list.getLast());\n+        checkNodes();\n+    }\n+    \n+    public void testGetNode() {\n+        resetEmpty();\n+        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        // get marker\n+        assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n+        try {\n+            Object obj = list.getNode(0, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n+        checkNodes();\n+        list.addFirst(\"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        checkNodes();\n+        try {\n+            Object obj = list.getNode(2, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        try {\n+            Object obj = list.getNode(-1, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+         try {\n+            Object obj = list.getNode(3, true);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }       \n+    }\n+    \n+    protected void checkNodes() {\n+        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        for (int i = 0; i < list.size; i++) {\n+            assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n+            if (i < list.size - 1) {\n+                assertEquals(list.getNode(i + 1, false).previous, \n+                    list.getNode(i, false));  \n+            }\n+        }\n+    }\n+        \n+}\n--- a/src/test/org/apache/commons/collections/list/TestAll.java\n+++ b/src/test/org/apache/commons/collections/list/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestAll.java,v 1.1 2003/11/16 00:05:44 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestAll.java,v 1.2 2003/12/11 00:18:06 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/11/16 00:05:44 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/11 00:18:06 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n+        suite.addTest(TestNodeCachingLinkedList.suite());\n+        \n         suite.addTest(TestFixedSizeList.suite());\n         suite.addTest(TestPredicatedList.suite());\n         suite.addTest(TestSetUniqueList.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/list/TestNodeCachingLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestNodeCachingLinkedList.java,v 1.1 2003/12/11 00:18:06 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Test class for NodeCachingLinkedList, a performance optimised LinkedList.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/12/11 00:18:06 $\n+ * \n+ * @author Jeff Varszegi\n+ * @author Phil Steitz\n+ */\n+public class TestNodeCachingLinkedList extends TestAbstractLinkedList {\n+\n+    public TestNodeCachingLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String args[]) {\n+        compareSpeed();\n+        String[] testCaseName = { TestNodeCachingLinkedList.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestNodeCachingLinkedList.class);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    public List makeEmptyList() {\n+        return new NodeCachingLinkedList();\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testShrinkCache() {\n+        if (isRemoveSupported() == false || isAddSupported() == false) return;\n+        resetEmpty();\n+        NodeCachingLinkedList list = (NodeCachingLinkedList) collection;\n+        \n+        list.addAll( Arrays.asList( new String[]{\"1\", \"2\", \"3\", \"4\"}));\n+        list.removeAllNodes();        // Will dump all 4 elements into cache\n+        ((NodeCachingLinkedList) list).setMaximumCacheSize(2); // shrink cache\n+        list.addAll( Arrays.asList( new String[]{\"1\", \"2\", \"3\", \"4\"}));\n+        checkNodes();\n+        list.removeNode(list.getNode(0, false)); // no room in cache\n+        list.removeNode(list.getNode(0, false)); \n+        list.removeNode(list.getNode(0, false)); \n+        checkNodes();    \n+        list.addAll( Arrays.asList( new String[]{\"1\", \"2\", \"3\", \"4\"}));\n+        checkNodes();     \n+    }       \n+    \n+    //-----------------------------------------------------------------------\n+    public static void compareSpeed() {\n+        NodeCachingLinkedList ncll = new NodeCachingLinkedList();\n+        LinkedList ll = new LinkedList();\n+        \n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        \n+        int loopCount = 4000000;\n+        \n+        long startTime, endTime;\n+        \n+        System.out.println(\"Testing relative execution time of commonly-used methods...\");\n+        \n+        startTime = System.currentTimeMillis();   \n+        for(int x = loopCount; x > 0; x--) {\n+            // unrolled a few times to minimize effect of loop\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+            //\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+            //\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+        }\n+        endTime = System.currentTimeMillis();   \n+        System.out.println(\"Time with LinkedList: \" + (endTime - startTime) + \" ms\");\n+\n+        startTime = System.currentTimeMillis();   \n+        for(int x = loopCount; x > 0; x--) {\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+            //\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+            //\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+        }\n+        endTime = System.currentTimeMillis();   \n+        System.out.println(\"Time with NodeCachingLinkedList: \" + (endTime - startTime) + \" ms\");\n+\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection,\n+//           \"D:/dev/collections/data/test/NodeCachingLinkedList.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection,\n+//            \"D:/dev/collections/data/test/NodeCachingLinkedList.fullCollection.version3.obj\");\n+//    }\n+}", "timestamp": 1071101886, "metainfo": ""}