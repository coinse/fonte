{"sha": "3c81ef8c393b09fdbc6f284d68ea686fc76c6080", "log": "Refactor functors from inner classes to subpackage   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ClosureUtils.java\n+++ b/src/java/org/apache/commons/collections/ClosureUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ClosureUtils.java,v 1.4 2003/11/23 14:41:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ClosureUtils.java,v 1.5 2003/11/23 17:01:36 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n-import java.io.Serializable;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n \n-import org.apache.commons.collections.functors.FunctorException;\n+import org.apache.commons.collections.functors.ChainedClosure;\n+import org.apache.commons.collections.functors.ExceptionClosure;\n+import org.apache.commons.collections.functors.ForClosure;\n+import org.apache.commons.collections.functors.IfClosure;\n+import org.apache.commons.collections.functors.NOPClosure;\n+import org.apache.commons.collections.functors.SwitchClosure;\n+import org.apache.commons.collections.functors.TransformerClosure;\n+import org.apache.commons.collections.functors.WhileClosure;\n \n /**\n  * <code>ClosureUtils</code> provides reference implementations and utilities\n  * All the supplied closures are Serializable.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/11/23 14:41:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/11/23 17:01:36 $\n  *\n  * @author Stephen Colebourne\n  */\n public class ClosureUtils {\n \n     /**\n-     * A Closure that always throws an exception\n-     */\n-    private static final Closure EXCEPTION_CLOSURE = new ExceptionClosure();\n-    /**\n-     * A Closure that does nothing\n-     */\n-    private static final Closure NOP_CLOSURE = new NOPClosure();\n-\n-    /**\n      * This class is not normally instantiated.\n      */\n     public ClosureUtils() {\n      * @return the closure\n      */\n     public static Closure exceptionClosure() {\n-        return EXCEPTION_CLOSURE;\n+        return ExceptionClosure.INSTANCE;\n     }\n \n     /**\n      * @return the closure\n      */\n     public static Closure nopClosure() {\n-        return NOP_CLOSURE;\n+        return NOPClosure.INSTANCE;\n     }\n \n     /**\n      * The transformer will be called using the closure's input object.\n      * The transformer's result will be ignored.\n      *\n-     * @param transformer  the transformer to run each time in the closure\n-     * @return the closure.\n+     * @param transformer  the transformer to run each time in the closure, null means nop\n+     * @return the closure\n      */\n     public static Closure asClosure(Transformer transformer) {\n-        if (transformer == null) {\n-            throw new IllegalArgumentException(\"The transformer must not be null\");\n-        }\n-        return new TransformerClosure(transformer);\n+        return TransformerClosure.getInstance(transformer);\n     }\n \n     /**\n      * Creates a Closure that will call the closure <code>count</code> times.\n+     * <p>\n+     * A null closure or zero count returns the <code>NOPClosure</code>.\n      *\n      * @param count  the number of times to loop\n      * @param closure  the closure to call repeatedly\n      * @return the <code>for</code> closure\n-     * @throws IllegalArgumentException if either argument is null\n      */\n     public static Closure forClosure(int count, Closure closure) {\n-        if (count < 0) {\n-            throw new IllegalArgumentException(\"The loop count must not be less than zero, it was \" + count);\n-        }\n-        if (closure == null) {\n-            throw new IllegalArgumentException(\"The closure must not be null\");\n-        }\n-        return new ForClosure(count, closure);\n+        return ForClosure.getInstance(count, closure);\n     }\n \n     /**\n      * Creates a Closure that will call the closure repeatedly until the \n      * predicate returns false.\n      *\n-     * @param predicate  the predicate to use as an end of loop test\n-     * @param closure  the closure to call repeatedly\n+     * @param predicate  the predicate to use as an end of loop test, not null\n+     * @param closure  the closure to call repeatedly, not null\n      * @return the <code>while</code> closure\n      * @throws IllegalArgumentException if either argument is null\n      */\n     public static Closure whileClosure(Predicate predicate, Closure closure) {\n-        if (predicate == null) {\n-            throw new IllegalArgumentException(\"The predicate must not be null\");\n-        }\n-        if (closure == null) {\n-            throw new IllegalArgumentException(\"The closure must not be null\");\n-        }\n-        return new WhileClosure(predicate, closure, false);\n+        return WhileClosure.getInstance(predicate, closure, false);\n     }\n \n     /**\n      * Creates a Closure that will call the closure once and then repeatedly\n      * until the predicate returns false.\n      *\n-     * @param closure  the closure to call repeatedly\n-     * @param predicate  the predicate to use as an end of loop test\n+     * @param closure  the closure to call repeatedly, not null\n+     * @param predicate  the predicate to use as an end of loop test, not null\n      * @return the <code>do-while</code> closure\n      * @throws IllegalArgumentException if either argument is null\n      */\n     public static Closure doWhileClosure(Closure closure, Predicate predicate) {\n-        if (closure == null) {\n-            throw new IllegalArgumentException(\"The closure must not be null\");\n-        }\n-        if (predicate == null) {\n-            throw new IllegalArgumentException(\"The predicate must not be null\");\n-        }\n-        return new WhileClosure(predicate, closure, true);\n+        return WhileClosure.getInstance(predicate, closure, true);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either closure is null\n      */\n     public static Closure chainedClosure(Closure closure1, Closure closure2) {\n-        Closure[] closures = new Closure[] { closure1, closure2 };\n-        validate(closures);\n-        return new ChainedClosure(closures);\n+        return ChainedClosure.getInstance(closure1, closure2);\n     }\n \n     /**\n      * @param closures  an array of closures to chain\n      * @return the <code>chained</code> closure\n      * @throws IllegalArgumentException if the closures array is null\n-     * @throws IllegalArgumentException if the closures array has 0 elements\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n     public static Closure chainedClosure(Closure[] closures) {\n-        closures = copy(closures);\n-        validate(closures);\n-        return new ChainedClosure(closures);\n+        return ChainedClosure.getInstance(closures);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n     public static Closure chainedClosure(Collection closures) {\n-        if (closures == null) {\n-            throw new IllegalArgumentException(\"The closure collection must not be null\");\n-        }\n-        // convert to array like this to guarantee iterator() ordering\n-        Closure[] cmds = new Closure[closures.size()];\n-        int i = 0;\n-        for (Iterator it = closures.iterator(); it.hasNext();) {\n-            cmds[i++] = (Closure) it.next();\n-        }\n-        validate(cmds);\n-        return new ChainedClosure(cmds);\n+        return ChainedClosure.getInstance(closures);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicate is null\n      * @throws IllegalArgumentException if either closure is null\n      */\n-    public static Closure switchClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n-        return switchClosureInternal(new Predicate[] { predicate }, new Closure[] { trueClosure }, falseClosure);\n+    public static Closure ifClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+        return IfClosure.getInstance(predicate, trueClosure, falseClosure);\n     }\n \n     /**\n      * location 0 returned true. Each predicate is evaluated\n      * until one returns true.\n      * \n-     * @param predicates  an array of predicates to check\n-     * @param closures  an array of closures to call\n+     * @param predicates  an array of predicates to check, not null\n+     * @param closures  an array of closures to call, not null\n      * @return the <code>switch</code> closure\n      * @throws IllegalArgumentException if the either array is null\n-     * @throws IllegalArgumentException if the either array has 0 elements\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static Closure switchClosure(Predicate[] predicates, Closure[] closures) {\n-        return switchClosureInternal(copy(predicates), copy(closures), null);\n+        return SwitchClosure.getInstance(predicates, closures, null);\n     }\n \n     /**\n      * until one returns true. If no predicates evaluate to true, the default\n      * closure is called.\n      * \n-     * @param predicates  an array of predicates to check\n-     * @param closures  an array of closures to call\n+     * @param predicates  an array of predicates to check, not null\n+     * @param closures  an array of closures to call, not null\n      * @param defaultClosure  the default to call if no predicate matches\n      * @return the <code>switch</code> closure\n      * @throws IllegalArgumentException if the either array is null\n-     * @throws IllegalArgumentException if the either array has 0 elements\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static Closure switchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n-        return switchClosureInternal(copy(predicates), copy(closures), defaultClosure);\n+        return SwitchClosure.getInstance(predicates, closures, defaultClosure);\n     }\n     \n     /**\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     public static Closure switchClosure(Map predicatesAndClosures) {\n-        Closure[] trs = null;\n-        Predicate[] preds = null;\n-        if (predicatesAndClosures == null) {\n-            throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n-        }\n-        // convert to array like this to guarantee iterator() ordering\n-        Closure def = (Closure) predicatesAndClosures.remove(null);\n-        int size = predicatesAndClosures.size();\n-        trs = new Closure[size];\n-        preds = new Predicate[size];\n-        int i = 0;\n-        for (Iterator it = predicatesAndClosures.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            preds[i] = (Predicate) entry.getKey();\n-            trs[i] = (Closure) entry.getValue();\n-            i++;\n-        }\n-        return switchClosureInternal(preds, trs, def);\n-    }\n-\n-    /**\n-     * Validate input and create closure.\n-     * \n-     * @param predicates  an array of predicates to check\n-     * @param closures  an array of closures to call\n-     * @param defaultClosure  the default to call if no predicate matches\n-     * @return the <code>switch</code> closure\n-     * @throws IllegalArgumentException if the either array is null\n-     * @throws IllegalArgumentException if the either array has 0 elements\n-     * @throws IllegalArgumentException if any element in the arrays is null\n-     * @throws IllegalArgumentException if the arrays are different sizes\n-     */\n-    private static Closure switchClosureInternal(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n-        validate(predicates);\n-        validate(closures);\n-        if (predicates.length != closures.length) {\n-            throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n-        }\n-        if (defaultClosure == null) {\n-            defaultClosure = nopClosure();\n-        }\n-        return new SwitchClosure(predicates, closures, defaultClosure);\n+        return SwitchClosure.getInstance(predicatesAndClosures);\n     }\n \n     /**\n         return switchClosure(preds, trs, def);\n     }\n \n-    /**\n-     * Clone the predicates to ensure that the internal reference can't be messed with.\n-     * \n-     * @param predicates  the predicates to copy\n-     * @return the cloned predicates\n-     */\n-    private static Predicate[] copy(Predicate[] predicates) {\n-        if (predicates == null) {\n-            return null;\n-        }\n-        return (Predicate[]) predicates.clone();\n-    }\n-    \n-    /**\n-     * Validate the predicates to ensure that all is well.\n-     * \n-     * @param predicates  the predicates to validate\n-     * @return the validated predicates\n-     */\n-    private static void validate(Predicate[] predicates) {\n-        if (predicates == null) {\n-            throw new IllegalArgumentException(\"The predicate array must not be null\");\n-        }\n-        if (predicates.length < 1) {\n-            throw new IllegalArgumentException(\n-                \"At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n-        }\n-        for (int i = 0; i < predicates.length; i++) {\n-            if (predicates[i] == null) {\n-                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Clone the closures to ensure that the internal reference can't be messed with.\n-     * \n-     * @param closures  the closures to copy\n-     * @return the cloned closures\n-     */\n-    private static Closure[] copy(Closure[] closures) {\n-        if (closures == null) {\n-            return null;\n-        }\n-        return (Closure[]) closures.clone();\n-    }\n-    \n-    /**\n-     * Validate the closures to ensure that all is well.\n-     * \n-     * @param closures  the closures to validate\n-     * @return the validated closures\n-     */\n-    private static void validate(Closure[] closures) {\n-        if (closures == null) {\n-            throw new IllegalArgumentException(\"The closure array must not be null\");\n-        }\n-        if (closures.length < 1) {\n-            throw new IllegalArgumentException(\n-                \"At least 1 closure must be specified in the closure array, size was \" + closures.length);\n-        }\n-        for (int i = 0; i < closures.length; i++) {\n-            if (closures[i] == null) {\n-                throw new IllegalArgumentException(\"The closure array must not contain a null closure, index \" + i + \" was null\");\n-            }\n-        }\n-    }\n-\n-    // ExceptionClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ExceptionClosure always throws an exception\n-     */\n-    private static class ExceptionClosure implements Closure, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private ExceptionClosure() {\n-            super();\n-        }\n-\n-        /**\n-         * Always throw an exception\n-         */\n-        public void execute(Object input) {\n-            throw new FunctorException(\"ExceptionClosure invoked\");\n-        }\n-    }\n-\n-    // NOPClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * NOPClosure does nothing\n-     */\n-    private static class NOPClosure implements Closure, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private NOPClosure() {\n-            super();\n-        }\n-\n-        /**\n-         * Do nothing\n-         */\n-        public void execute(Object input) {\n-            // do nothing\n-        }\n-    }\n-\n-    // TransformerClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * TransformerClosure calls a Transformer using the input object and ignore the result.\n-     */\n-    private static class TransformerClosure implements Closure, Serializable {\n-        /** The transformer to wrap */\n-        private final Transformer iTransformer;\n-\n-        /**\n-         * Constructor to store transformer\n-         */\n-        private TransformerClosure(Transformer transformer) {\n-            super();\n-            iTransformer = transformer;\n-        }\n-\n-        /**\n-         * Call the transformer\n-         */\n-        public void execute(Object input) {\n-            iTransformer.transform(input);\n-        }\n-    }\n-\n-    // ChainedClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ChainedClosure calls a list of closures.\n-     */\n-    private static class ChainedClosure implements Closure, Serializable {\n-        /** The closures to call in turn */\n-        private final Closure[] iClosures;\n-\n-        /**\n-         * Constructor to store params\n-         */\n-        private ChainedClosure(Closure[] closures) {\n-            super();\n-            iClosures = closures;\n-        }\n-\n-        /**\n-         * Execute a list of closures\n-         */\n-        public void execute(Object input) {\n-            for (int i = 0; i < iClosures.length; i++) {\n-                iClosures[i].execute(input);\n-            }\n-        }\n-    }\n-\n-    // SwitchClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * SwitchClosure calls the closure whose predicate returns true.\n-     */\n-    private static class SwitchClosure implements Closure, Serializable {\n-        /** The tests to consider */\n-        private final Predicate[] iPredicates;\n-        /** The matching closures to call */\n-        private final Closure[] iClosures;\n-        /** The default closure to call if no tests match */\n-        private final Closure iDefault;\n-\n-        /**\n-         * Constructor to store params\n-         */\n-        private SwitchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n-            super();\n-            iPredicates = predicates;\n-            iClosures = closures;\n-            iDefault = defaultClosure;\n-        }\n-\n-        /**\n-         * Execute the closure whose predicate returns true\n-         */\n-        public void execute(Object input) {\n-            for (int i = 0; i < iPredicates.length; i++) {\n-                if (iPredicates[i].evaluate(input) == true) {\n-                    iClosures[i].execute(input);\n-                    return;\n-                }\n-            }\n-            iDefault.execute(input);\n-        }\n-    }\n-\n-    // ForClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ForClosure calls the closure a fixed number of times.\n-     */\n-    private static class ForClosure implements Closure, Serializable {\n-        /** The number of times to loop */\n-        private final int iCount;\n-        /** The closure to call */\n-        private final Closure iClosure;\n-\n-        /**\n-         * Constructor to store params\n-         */\n-        private ForClosure(int count, Closure closure) {\n-            super();\n-            iCount = count;\n-            iClosure = closure;\n-        }\n-\n-        /**\n-         * Execute the closure count times\n-         */\n-        public void execute(Object input) {\n-            for (int i = 0; i < iCount; i++) {\n-                iClosure.execute(input);\n-            }\n-        }\n-    }\n-\n-    // WhileClosure\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * WhileClosure calls the closure until the predicate is false.\n-     */\n-    private static class WhileClosure implements Closure, Serializable {\n-        /** The test condition */\n-        private final Predicate iPredicate;\n-        /** The closure to call */\n-        private final Closure iClosure;\n-        /** The flag, true is a do loop, false is a while */\n-        private final boolean iDoLoop;\n-\n-        /**\n-         * Constructor to store params\n-         */\n-        private WhileClosure(Predicate predicate, Closure closure, boolean doLoop) {\n-            super();\n-            iPredicate = predicate;\n-            iClosure = closure;\n-            iDoLoop = doLoop;\n-        }\n-\n-        /**\n-         * Execute the closure until the predicate is false\n-         */\n-        public void execute(Object input) {\n-            if (iDoLoop) {\n-                iClosure.execute(input);\n-            }\n-            while (iPredicate.evaluate(input)) {\n-                iClosure.execute(input);\n-            }\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/collections/FactoryUtils.java\n+++ b/src/java/org/apache/commons/collections/FactoryUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FactoryUtils.java,v 1.9 2003/11/23 14:41:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FactoryUtils.java,v 1.10 2003/11/23 17:01:36 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n \n+import org.apache.commons.collections.functors.ExceptionFactory;\n import org.apache.commons.collections.functors.FunctorException;\n \n /**\n  * All the supplied factories are Serializable.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.9 $ $Date: 2003/11/23 14:41:27 $\n+ * @version $Revision: 1.10 $ $Date: 2003/11/23 17:01:36 $\n  *\n  * @author Stephen Colebourne\n  */\n public class FactoryUtils {\n \n     /**\n-     * A factory that always throws an exception\n-     */\n-    private static final Factory EXCEPTION_FACTORY = new ExceptionFactory();\n-    /**\n      * A factory that always returns null\n      */\n     private static final Factory NULL_FACTORY = new ConstantFactory(null);\n      * @return the factory\n      */\n     public static Factory exceptionFactory() {\n-        return EXCEPTION_FACTORY;\n+        return ExceptionFactory.INSTANCE;\n     }\n \n     /**\n      */\n     public static Factory reflectionFactory(Class classToInstantiate, Class[] paramTypes, Object[] args) {\n         return new ReflectionFactory(classToInstantiate, paramTypes, args);\n-    }\n-\n-    // ExceptionFactory\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ExceptionFactory always throws an exception\n-     */\n-    private static class ExceptionFactory implements Factory, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private ExceptionFactory() {\n-            super();\n-        }\n-\n-        /**\n-         * Always throw an exception\n-         */\n-        public Object create() {\n-            throw new FunctorException(\"ExceptionFactory invoked\");\n-        }\n     }\n \n     // ConstantFactory\n--- a/src/java/org/apache/commons/collections/PredicateUtils.java\n+++ b/src/java/org/apache/commons/collections/PredicateUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PredicateUtils.java,v 1.11 2003/11/23 14:41:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PredicateUtils.java,v 1.12 2003/11/23 17:01:36 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Iterator;\n import java.util.Set;\n \n+import org.apache.commons.collections.functors.ExceptionPredicate;\n import org.apache.commons.collections.functors.FunctorException;\n \n /**\n  * All the supplied predicates are Serializable.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.11 $ $Date: 2003/11/23 14:41:27 $\n+ * @version $Revision: 1.12 $ $Date: 2003/11/23 17:01:36 $\n  * \n  * @author Stephen Colebourne\n  * @author Ola Berg\n public class PredicateUtils {\n \n     /**\n-     * A predicate that always throws an exception\n-     */\n-    private static final Predicate EXCEPTION_PREDICATE = new ExceptionPredicate();\n-    /**\n      * A predicate that always returns true\n      */\n     private static final Predicate TRUE_PREDICATE = new ConstantPredicate(true);\n      * @return the predicate\n      */\n     public static Predicate exceptionPredicate() {\n-        return EXCEPTION_PREDICATE;\n+        return ExceptionPredicate.INSTANCE;\n     }\n \n     /**\n             preds[i] = predicates[i];\n         }\n         return preds;\n-    }\n-\n-    // ExceptionPredicate\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ExceptionPredicate always throws an exception\n-     */\n-    private static class ExceptionPredicate implements Predicate, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private ExceptionPredicate() {\n-            super();\n-        }\n-\n-        /**\n-         * Always throw an exception\n-         */\n-        public boolean evaluate(Object object) {\n-            throw new FunctorException(\"ExceptionPredicate invoked\");\n-        }\n     }\n \n     // ConstantPredicate\n--- a/src/java/org/apache/commons/collections/TransformerUtils.java\n+++ b/src/java/org/apache/commons/collections/TransformerUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TransformerUtils.java,v 1.6 2003/11/23 14:41:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TransformerUtils.java,v 1.7 2003/11/23 17:01:36 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Iterator;\n import java.util.Map;\n \n+import org.apache.commons.collections.functors.ExceptionTransformer;\n import org.apache.commons.collections.functors.FunctorException;\n \n /**\n  * All the supplied transformers are Serializable.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.6 $ $Date: 2003/11/23 14:41:27 $\n+ * @version $Revision: 1.7 $ $Date: 2003/11/23 17:01:36 $\n  * \n  * @author Stephen Colebourne\n  * @author James Carman\n public class TransformerUtils {\n \n     /**\n-     * A transformer that always throws an exception\n-     */\n-    private static final Transformer EXCEPTION_TRANSFORMER = new ExceptionTransformer();\n-    /**\n      * A transformer that always returns null\n      */\n     private static final Transformer NULL_TRANSFORMER = new ConstantTransformer(null);\n      * @return the transformer\n      */\n     public static Transformer exceptionTransformer() {\n-        return EXCEPTION_TRANSFORMER;\n+        return ExceptionTransformer.INSTANCE;\n     }\n \n     /**\n         }\n     }\n \n-    // ExceptionTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ExceptionTransformer always throws an exception.\n-     */\n-    private static class ExceptionTransformer implements Transformer, Serializable {\n-\n-        /**\n-         * Constructor\n-         */\n-        private ExceptionTransformer() {\n-            super();\n-        }\n-\n-        /**\n-         * Always throw exception\n-         */\n-        public Object transform(Object input) {\n-            throw new FunctorException(\"ExceptionTransformer invoked\");\n-        }\n-    }\n-\n     // NOPTransformer\n     //----------------------------------------------------------------------------------\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ChainedClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ChainedClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that chains the specifed closures together.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ChainedClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = -3520677225766901240L;\n+\n+    /** The closures to call in turn */\n+    private final Closure[] iClosures;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter array.\n+     * \n+     * @param closures  the closures to chain, copied, no nulls\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures array is null\n+     * @throws IllegalArgumentException if any closure in the array is null\n+     */\n+    public static Closure getInstance(Closure[] closures) {\n+        FunctorUtils.validate(closures);\n+        if (closures.length == 0) {\n+            return NOPClosure.INSTANCE;\n+        }\n+        closures = FunctorUtils.copy(closures);\n+        return new ChainedClosure(closures);\n+    }\n+    \n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param closures  a collection of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws IllegalArgumentException if any closure in the collection is null\n+     */\n+    public static Closure getInstance(Collection closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"Closure collection must not be null\");\n+        }\n+        if (closures.size() == 0) {\n+            return NOPClosure.INSTANCE;\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure[] cmds = new Closure[closures.size()];\n+        int i = 0;\n+        for (Iterator it = closures.iterator(); it.hasNext();) {\n+            cmds[i++] = (Closure) it.next();\n+        }\n+        FunctorUtils.validate(cmds);\n+        return new ChainedClosure(cmds);\n+    }\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param closure1  the first closure, not null\n+     * @param closure2  the second closure, not null\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static Closure getInstance(Closure closure1, Closure closure2) {\n+        if (closure1 == null || closure2 == null) {\n+            throw new IllegalArgumentException(\"Closures must not be null\");\n+        }\n+        Closure[] closures = new Closure[] { closure1, closure2 };\n+        return new ChainedClosure(closures);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param closures  the closures to chain, not copied, no nulls\n+     */\n+    public ChainedClosure(Closure[] closures) {\n+        super();\n+        iClosures = closures;\n+    }\n+\n+    /**\n+     * Execute a list of closures.\n+     * \n+     * @param input  the input object passed to each closure\n+     */\n+    public void execute(Object input) {\n+        for (int i = 0; i < iClosures.length; i++) {\n+            iClosures[i].execute(input);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ExceptionClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that always throws an exception.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 7179106032121985545L;\n+    \n+\n+    /** Singleton predicate instance */    \n+    public static final Closure INSTANCE = new ExceptionClosure();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionClosure() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throw an exception.\n+     */\n+    public void execute(Object object) {\n+        throw new FunctorException(\"ExceptionClosure invoked\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ExceptionFactory.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Factory;\n+\n+/**\n+ * Factory implementation that always throws an exception.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionFactory implements Factory, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 7179106032121985545L;\n+    \n+\n+    /** Singleton predicate instance */    \n+    public static final Factory INSTANCE = new ExceptionFactory();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionFactory() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throw an exception.\n+     */\n+    public Object create() {\n+        throw new FunctorException(\"ExceptionFactory invoked\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ExceptionPredicate.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that always throws an exception.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionPredicate implements Predicate, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 7179106032121985545L;\n+    \n+    /** Singleton predicate instance */    \n+    public static final Predicate INSTANCE = new ExceptionPredicate();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throw an exception\n+     */\n+    public boolean evaluate(Object object) {\n+        throw new FunctorException(\"ExceptionPredicate invoked\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ExceptionTransformer.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that always throws an exception.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionTransformer implements Transformer, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 7179106032121985545L;\n+    \n+\n+    /** Singleton predicate instance */    \n+    public static final Transformer INSTANCE = new ExceptionTransformer();\n+    \n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throw an exception.\n+     */\n+    public Object transform(Object object) {\n+        throw new FunctorException(\"ExceptionTransformer invoked\");\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/ForClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/ForClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that calls another closure n times, like a for loop.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ForClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = -1190120533393621674L;\n+\n+    /** The number of times to loop */\n+    private final int iCount;\n+    /** The closure to call */\n+    private final Closure iClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * A null closure or zero count returns the <code>NOPClosure</code>.\n+     * A count of one returns the specified closure.\n+     * \n+     * @param count  the number of times to execute the closure\n+     * @param closure  the closure to execute, not null\n+     * @return the <code>for</code> closure\n+     */\n+    public static Closure getInstance(int count, Closure closure) {\n+        if (count <= 0 || closure == null) {\n+            return NOPClosure.INSTANCE;\n+        }\n+        if (count == 1) {\n+            return closure;\n+        }\n+        return new ForClosure(count, closure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param count  the number of times to execute the closure\n+     * @param closure  the closure to execute, not null\n+     */\n+    public ForClosure(int count, Closure closure) {\n+        super();\n+        iCount = count;\n+        iClosure = closure;\n+    }\n+\n+    /**\n+     * Execute the closure count times.\n+     */\n+    public void execute(Object input) {\n+        for (int i = 0; i < iCount; i++) {\n+            iClosure.execute(input);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/FunctorUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/FunctorUtils.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Internal utilities for functors.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+class FunctorUtils {\n+    \n+    /**\n+     * Clone the predicates to ensure that the internal reference can't be messed with.\n+     * \n+     * @param predicates  the predicates to copy\n+     * @return the cloned predicates\n+     */\n+    static Predicate[] copy(Predicate[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate[]) predicates.clone();\n+    }\n+    \n+    /**\n+     * Validate the predicates to ensure that all is well.\n+     * \n+     * @param predicates  the predicates to validate\n+     * @return the validated predicates\n+     */\n+    static void validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clone the closures to ensure that the internal reference can't be messed with.\n+     * \n+     * @param closures  the closures to copy\n+     * @return the cloned closures\n+     */\n+    static Closure[] copy(Closure[] closures) {\n+        if (closures == null) {\n+            return null;\n+        }\n+        return (Closure[]) closures.clone();\n+    }\n+    \n+    /**\n+     * Validate the closures to ensure that all is well.\n+     * \n+     * @param closures  the closures to validate\n+     * @return the validated closures\n+     */\n+    static void validate(Closure[] closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"The closure array must not be null\");\n+        }\n+        for (int i = 0; i < closures.length; i++) {\n+            if (closures[i] == null) {\n+                throw new IllegalArgumentException(\"The closure array must not contain a null closure, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/IfClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/IfClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Closure implementation acts as an if statement calling one or other closure\n+ * based on a predicate.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class IfClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** The test */\n+    private final Predicate iPredicate;\n+    /** The closure to use if true */\n+    private final Closure iTrueClosure;\n+    /** The closure to use if false */\n+    private final Closure iFalseClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param closures  matching array of closures, cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    public static Closure getInstance(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        if (trueClosure == null || falseClosure == null) {\n+            throw new IllegalArgumentException(\"Closures must not be null\");\n+        }\n+        return new IfClosure(predicate, trueClosure, falseClosure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  predicate to switch on, not null\n+     * @param trueClosure  closure used if true, not null\n+     * @param falseClosure  closure used if false, not null\n+     */\n+    public IfClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+        super();\n+        iPredicate = predicate;\n+        iTrueClosure = trueClosure;\n+        iFalseClosure = falseClosure;\n+    }\n+\n+    /**\n+     * Execute the correct closure.\n+     */\n+    public void execute(Object input) {\n+        if (iPredicate.evaluate(input) == true) {\n+            iTrueClosure.execute(input);\n+        } else {\n+            iFalseClosure.execute(input);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/NOPClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/NOPClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that does nothing.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class NOPClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** Singleton predicate instance */    \n+    public static final Closure INSTANCE = new NOPClosure();\n+    \n+    /**\n+     * Constructor\n+     */\n+    private NOPClosure() {\n+        super();\n+    }\n+\n+    /**\n+     * Do nothing\n+     */\n+    public void execute(Object input) {\n+        // do nothing\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/SwitchClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/SwitchClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Closure implementation calls the closure whose predicate returns true,\n+ * like a switch statement.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SwitchClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** The tests to consider */\n+    private final Predicate[] iPredicates;\n+    /** The matching closures to call */\n+    private final Closure[] iClosures;\n+    /** The default closure to call if no tests match */\n+    private final Closure iDefault;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter arrays.\n+     * \n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param closures  matching array of closures, cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    public static Closure getInstance(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+        FunctorUtils.validate(predicates);\n+        FunctorUtils.validate(closures);\n+        if (predicates.length != closures.length) {\n+            throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n+        }\n+        if (predicates.length == 0) {\n+            return (defaultClosure == null ? NOPClosure.INSTANCE : defaultClosure);\n+        }\n+        predicates = FunctorUtils.copy(predicates);\n+        closures = FunctorUtils.copy(closures);\n+        return new SwitchClosure(predicates, closures, defaultClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called. The default closure is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param predicatesAndClosures  a map of predicates to closures\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Closure getInstance(Map predicatesAndClosures) {\n+        Closure[] closures = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndClosures == null) {\n+            throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n+        }\n+        if (predicatesAndClosures.size() == 0) {\n+            return NOPClosure.INSTANCE;\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure defaultClosure = (Closure) predicatesAndClosures.remove(null);\n+        int size = predicatesAndClosures.size();\n+        if (size == 0) {\n+            return (defaultClosure == null ? NOPClosure.INSTANCE : defaultClosure);\n+        }\n+        closures = new Closure[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndClosures.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            closures[i] = (Closure) entry.getValue();\n+            i++;\n+        }\n+        return new SwitchClosure(preds, closures, defaultClosure);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicates  array of predicates, not cloned, no nulls\n+     * @param closures  matching array of closures, not cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     */\n+    public SwitchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+        super();\n+        iPredicates = predicates;\n+        iClosures = closures;\n+        iDefault = (defaultClosure == null ? NOPClosure.INSTANCE : defaultClosure);\n+    }\n+\n+    /**\n+     * Execute the closure whose predicate returns true\n+     */\n+    public void execute(Object input) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(input) == true) {\n+                iClosures[i].execute(input);\n+                return;\n+            }\n+        }\n+        iDefault.execute(input);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/TransformerClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/TransformerClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Closure implementation that calls a Transformer using the input object\n+ * and ignore the result.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformerClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = -5194992589193388969L;\n+\n+    /** The transformer to wrap */\n+    private final Transformer iTransformer;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * A null transformer will return the <code>NOPClosure</code>.\n+     * \n+     * @param transformer  the transformer to call, null means nop\n+     * @return the <code>transformer</code> closure\n+     */\n+    public static Closure getInstance(Transformer transformer) {\n+        if (transformer == null) {\n+            return NOPClosure.INSTANCE;\n+        }\n+        return new TransformerClosure(transformer);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param transformer  the transformer to call, not null\n+     */\n+    public TransformerClosure(Transformer transformer) {\n+        super();\n+        iTransformer = transformer;\n+    }\n+\n+    /**\n+     * Call the transformer.\n+     */\n+    public void execute(Object input) {\n+        iTransformer.transform(input);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/functors/WhileClosure.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/functors/WhileClosure.java,v 1.1 2003/11/23 17:01:35 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Closure implementation that executes a closure repeatedly until a condition is met,\n+ * like a do-while or while loop.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/23 17:01:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class WhileClosure implements Closure, Serializable {\n+\n+    /** Serial version UID */\n+    static final long serialVersionUID = -3110538116913760108L;\n+\n+    /** The test condition */\n+    private final Predicate iPredicate;\n+    /** The closure to call */\n+    private final Closure iClosure;\n+    /** The flag, true is a do loop, false is a while */\n+    private final boolean iDoLoop;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n+     * @param closure  the closure the execute, not null\n+     * @param doLoop  true to act as a do-while loop, always executing the closure once\n+     * @return the <code>while</code> closure\n+     * @throws IllegalArgumentException if the predicate or closure is null\n+     */\n+    public static Closure getInstance(Predicate predicate, Closure closure, boolean doLoop) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"Closure must not be null\");\n+        }\n+        return new WhileClosure(predicate, closure, doLoop);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n+     * @param closure  the closure the execute, not null\n+     * @param doLoop  true to act as a do-while loop, always executing the closure once\n+     */\n+    public WhileClosure(Predicate predicate, Closure closure, boolean doLoop) {\n+        super();\n+        iPredicate = predicate;\n+        iClosure = closure;\n+        iDoLoop = doLoop;\n+    }\n+\n+    /**\n+     * Execute the closure until the predicate is false.\n+     */\n+    public void execute(Object input) {\n+        if (iDoLoop) {\n+            iClosure.execute(input);\n+        }\n+        while (iPredicate.evaluate(input)) {\n+            iClosure.execute(input);\n+        }\n+    }\n+    \n+}\n+\n--- a/src/test/org/apache/commons/collections/TestClosureUtils.java\n+++ b/src/test/org/apache/commons/collections/TestClosureUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestClosureUtils.java,v 1.4 2003/11/23 14:41:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestClosureUtils.java,v 1.5 2003/11/23 17:01:36 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.textui.TestRunner;\n \n import org.apache.commons.collections.functors.FunctorException;\n+import org.apache.commons.collections.functors.NOPClosure;\n \n /**\n  * Tests the org.apache.commons.collections.ClosureUtils class.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/11/23 14:41:27 $\n+ * @version $Revision: 1.5 $ $Date: 2003/11/23 17:01:36 $\n  *\n  * @author Stephen Colebourne\n  */\n         MockClosure cmd = new MockClosure();\n         ClosureUtils.forClosure(5, cmd).execute(null);\n         assertEquals(5, cmd.count);\n-        try {\n-            ClosureUtils.forClosure(-1, new MockClosure());\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));\n+        assertSame(cmd, ClosureUtils.forClosure(1, cmd));\n     }\n \n     // whileClosure\n         ClosureUtils.chainedClosure(coll).execute(null);\n         assertEquals(1, a.count);\n         assertEquals(2, b.count);\n-    }\n-\n-    public void testChainedClosureEx1a() {\n+        \n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.chainedClosure(new Closure[0]));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.chainedClosure(Collections.EMPTY_LIST));\n+        \n         try {\n             ClosureUtils.chainedClosure(null, null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedClosureEx1b() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.chainedClosure((Closure[]) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedClosureEx1c() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.chainedClosure((Collection) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedClosureEx2() {\n-        try {\n-            ClosureUtils.chainedClosure(new Closure[0]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedClosureEx3() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.chainedClosure(new Closure[] {null, null});\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedClosureEx4() {\n-        try {\n-            ClosureUtils.chainedClosure(Collections.EMPTY_LIST);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testChainedClosureEx5() {\n-        try {\n-            Collection coll = new ArrayList();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList();\n             coll.add(null);\n             coll.add(null);\n             ClosureUtils.chainedClosure(coll);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     // switchClosure\n     public void testSwitchClosure() {\n         MockClosure a = new MockClosure();\n         MockClosure b = new MockClosure();\n-        ClosureUtils.switchClosure(PredicateUtils.truePredicate(), a, b).execute(null);\n+        ClosureUtils.ifClosure(PredicateUtils.truePredicate(), a, b).execute(null);\n         assertEquals(1, a.count);\n         assertEquals(0, b.count);\n         \n         a = new MockClosure();\n         b = new MockClosure();\n-        ClosureUtils.switchClosure(PredicateUtils.falsePredicate(), a, b).execute(null);\n+        ClosureUtils.ifClosure(PredicateUtils.falsePredicate(), a, b).execute(null);\n         assertEquals(0, a.count);\n         assertEquals(1, b.count);\n         \n         assertEquals(0, a.count);\n         assertEquals(0, b.count);\n         assertEquals(1, c.count);\n-    }\n-\n-    public void testSwitchClosureEx1a() {\n+        \n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.switchClosure(new Predicate[0], new Closure[0]));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.switchClosure(new HashMap()));\n+        map = new HashMap();\n+        map.put(null, null);\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));\n+\n         try {\n             ClosureUtils.switchClosure(null, null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx1b() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.switchClosure((Predicate[]) null, (Closure[]) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx1c() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.switchClosure((Map) null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx2() {\n-        try {\n-            ClosureUtils.switchClosure(new Predicate[0], new Closure[0]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx3() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.switchClosure(new Predicate[2], new Closure[2]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx4() {\n-        try {\n-            ClosureUtils.switchClosure(new HashMap());\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx5() {\n-        try {\n-            Map map = new HashMap();\n-            map.put(null, null);\n-            map.put(null, null);\n-            ClosureUtils.switchClosure(map);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchClosureEx6() {\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.switchClosure(new Predicate[2], new Closure[1]);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     // switchMapClosure\n         assertEquals(0, a.count);\n         assertEquals(0, b.count);\n         assertEquals(1, c.count);\n-    }\n-\n-    public void testSwitchMapClosureEx1() {\n+\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap()));\n+        \n         try {\n             ClosureUtils.switchMapClosure(null);\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n-    }\n-    \n-    public void testSwitchMapClosureEx2() {\n-        try {\n-            ClosureUtils.switchMapClosure(new HashMap());\n-        } catch (IllegalArgumentException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n     \n     ", "timestamp": 1069606896, "metainfo": ""}