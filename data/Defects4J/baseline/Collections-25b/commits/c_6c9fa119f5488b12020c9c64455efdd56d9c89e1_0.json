{"sha": "6c9fa119f5488b12020c9c64455efdd56d9c89e1", "log": "Add since tags for 3.2  ", "commit": "\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n      * @param buffer  the buffer to synchronize, must not be null\n      * @return a blocking buffer backed by that buffer\n      * @throws IllegalArgumentException  if the Buffer is null\n+     * @since Commons Collections 3.2\n      */\n     public static Buffer timeoutBuffer(Buffer buffer, long timeout) {\n         return TimeoutBuffer.decorate(buffer, timeout);\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n      * @param object  the object to add, if null it will not be added\n      * @return true if the collection changed\n      * @throws NullPointerException if the collection is null\n+     * @since Commons Collections 3.2\n      */\n     public static boolean addIgnoreNull(Collection collection, Object object) {\n         return (object == null ? false : collection.add(object));\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Returns a collection containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n+     * \n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static Collection retainAll(Collection collection, Collection retain) {\n+        return ListUtils.retainAll(collection, retain);\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a collection containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     * \n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static Collection removeAll(Collection collection, Collection remove) {\n+        return ListUtils.retainAll(collection, remove);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Returns a synchronized collection backed by the given collection.\n      * <p>\n      * You must manually synchronize on the returned buffer's iterator to \n     public static Collection transformedCollection(Collection collection, Transformer transformer) {\n         return TransformedCollection.decorate(collection, transformer);\n     }\n-   \n-    /**\n-     * Returns a collection containing all the elements in <code>collection</code>\n-     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n-     * in the returned collection is the same as the cardinality of <code>e</code>\n-     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n-     * case the cardinality is zero. This method is useful if you do not wish to modify\n-     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n-     * \n-     * @param collection  the collection whose contents are the target of the #retailAll operation\n-     * @param retain  the collection containing the elements to be retained in the returned collection\n-     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n-     * that occur at least once in <code>retain</code>.\n-     * @throws NullPointerException if either parameter is null\n-     */\n-    public static Collection retainAll(Collection collection, Collection retain) {\n-        return ListUtils.retainAll(collection, retain);\n-    }\n-\n-    /**\n-     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n-     * method returns a collection containing all the elements in <code>c</code>\n-     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n-     * in the returned collection is the same as the cardinality of <code>e</code>\n-     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n-     * case the cardinality is zero. This method is useful if you do not wish to modify\n-     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n-     * \n-     * @param collection  the collection from which items are removed (in the returned collection)\n-     * @param remove  the items to be removed from the returned <code>collection</code>\n-     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n-     * any elements that also occur in <code>remove</code>.\n-     * @throws NullPointerException if either parameter is null\n-     */\n-    public static Collection removeAll(Collection collection, Collection remove) {\n-        return ListUtils.retainAll(collection, remove);\n-    }\n \n }\n--- a/src/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n      * @return The associated List object.\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a List.\n+     * @since Commons Collections 3.2\n      */\n     public List getList(String key) {\n         return getList(key, null);\n      * @return The associated List.\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a List.\n+     * @since Commons Collections 3.2\n      */\n     public List getList(String key, List defaultValue) {\n         Object value = get(key);\n--- a/src/java/org/apache/commons/collections/IteratorUtils.java\n+++ b/src/java/org/apache/commons/collections/IteratorUtils.java\n      * @param list  the list to iterate over, not null\n      * @return a new looping iterator\n      * @throws NullPointerException if the list is null\n+     * @since Commons Collections 3.2\n      */\n     public static ResettableIterator loopingListIterator(List list) {\n         if (list == null) {\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Returns a List containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned list is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n+     * \n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>List</code> containing all the elements of <code>c</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static List retainAll(Collection collection, Collection retain) {\n+        List list = new ArrayList(Math.min(collection.size(), retain.size()));\n+\n+        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n+            Object obj = iter.next();\n+            if (retain.contains(obj)) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a list containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     * \n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>List</code> containing all the elements of <code>c</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static List removeAll(Collection collection, Collection remove) {\n+        List list = new ArrayList();\n+        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n+            Object obj = iter.next();\n+            if (remove.contains(obj) == false) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Returns a synchronized list backed by the given list.\n      * <p>\n      * You must manually synchronize on the returned buffer's iterator to \n         return FixedSizeList.decorate(list);\n     }\n \n-    /**\n-     * Returns a List containing all the elements in <code>collection</code>\n-     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n-     * in the returned list is the same as the cardinality of <code>e</code>\n-     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n-     * case the cardinality is zero. This method is useful if you do not wish to modify\n-     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n-     * \n-     * @param collection  the collection whose contents are the target of the #retailAll operation\n-     * @param retain  the collection containing the elements to be retained in the returned collection\n-     * @return a <code>List</code> containing all the elements of <code>c</code>\n-     * that occur at least once in <code>retain</code>.\n-     * @throws NullPointerException if either parameter is null\n-     */\n-    public static List retainAll(Collection collection, Collection retain) {\n-        List list = new ArrayList(Math.min(collection.size(), retain.size()));\n-\n-        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n-            Object obj = iter.next();\n-            if (retain.contains(obj)) {\n-                list.add(obj);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    /**\n-     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n-     * method returns a list containing all the elements in <code>c</code>\n-     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n-     * in the returned collection is the same as the cardinality of <code>e</code>\n-     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n-     * case the cardinality is zero. This method is useful if you do not wish to modify\n-     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n-     * \n-     * @param collection  the collection from which items are removed (in the returned collection)\n-     * @param remove  the items to be removed from the returned <code>collection</code>\n-     * @return a <code>List</code> containing all the elements of <code>c</code> except\n-     * any elements that also occur in <code>remove</code>.\n-     * @throws NullPointerException if either parameter is null\n-     */\n-    public static List removeAll(Collection collection, Collection remove) {\n-        List list = new ArrayList();\n-        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n-            Object obj = iter.next();\n-            if (remove.contains(obj) == false) {\n-                list.add(obj);\n-            }\n-        }\n-        return list;\n-    }\n-\n }\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n      * @param timeout  the timeout value in milliseconds\n      * @throws BufferUnderflowException if an interrupt is received\n      * @throws BufferUnderflowException if the timeout expires\n+     * @since Commons Collections 3.2\n      */\n     public Object get(final long timeout) {\n         synchronized (lock) {\n      * @param timeout  the timeout value in milliseconds\n      * @throws BufferUnderflowException if an interrupt is received\n      * @throws BufferUnderflowException if the timeout expires\n+     * @since Commons Collections 3.2\n      */\n     public Object remove(final long timeout) {\n         synchronized (lock) {\n--- a/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n     //-----------------------------------------------------------------------\n     /**\n      * A cursor for the sublist based on LinkedSubListIterator.\n+     *\n+     * @since Commons Collections 3.2\n      */\n     protected static class SubCursor extends Cursor {\n \n--- a/src/java/org/apache/commons/collections/map/TransformedMap.java\n+++ b/src/java/org/apache/commons/collections/map/TransformedMap.java\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n+     * @since Commons Collections 3.2\n      */\n     public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n         TransformedMap decorated = new TransformedMap(map, keyTransformer, valueTransformer);\n--- a/src/java/org/apache/commons/collections/map/TransformedSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/TransformedSortedMap.java\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n+     * @since Commons Collections 3.2\n      */\n     public static SortedMap decorateTransform(SortedMap map, Transformer keyTransformer, Transformer valueTransformer) {\n         TransformedSortedMap decorated = new TransformedSortedMap(map, keyTransformer, valueTransformer);", "timestamp": 1132615485, "metainfo": ""}