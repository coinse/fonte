{"sha": "d2280c28ece3cbdc32aa24ed2ab652b1ec3760a9", "log": "[COLLECTIONS-432] Add CircularFifoQueue based on CircularFifoBuffer.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/queue/CircularFifoQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections.BoundedCollection;\n+\n+/**\n+ * CircularFifoQueue is a first-in first-out queue with a fixed size that\n+ * replaces its oldest element if full.\n+ * <p>\n+ * The removal order of a {@link CircularFifoQueue} is based on the\n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ * <p>\n+ * This queue prevents null objects from being added.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CircularFifoQueue<E> extends AbstractCollection<E>\n+    implements Queue<E>, BoundedCollection<E>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -8423413834657610406L;\n+\n+    /** Underlying storage array. */\n+    private transient E[] elements;\n+\n+    /** Array index of first (oldest) queue element. */\n+    private transient int start = 0;\n+\n+    /**\n+     * Index mod maxElements of the array position following the last queue\n+     * element.  Queue elements start at elements[start] and \"wrap around\"\n+     * elements[maxElements-1], ending at elements[decrement(end)].\n+     * For example, elements = {c,a,b}, start=1, end=1 corresponds to\n+     * the queue [a,b,c].\n+     */\n+    private transient int end = 0;\n+\n+    /** Flag to indicate if the queue is currently full. */\n+    private transient boolean full = false;\n+\n+    /** Capacity of the queue. */\n+    private final int maxElements;\n+\n+    /**\n+     * Constructor that creates a queue with the default size of 32.\n+     */\n+    public CircularFifoQueue() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructor that creates a queue with the specified size.\n+     *\n+     * @param size  the size of the queue (cannot be changed)\n+     * @throws IllegalArgumentException  if the size is &lt; 1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CircularFifoQueue(final int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        elements = (E[]) new Object[size];\n+        maxElements = elements.length;\n+    }\n+\n+    /**\n+     * Constructor that creates a queue from the specified collection.\n+     * The collection size also sets the queue size.\n+     *\n+     * @param coll  the collection to copy into the queue, may not be null\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public CircularFifoQueue(final Collection<E> coll) {\n+        this(coll.size());\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the queue out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException if an I/O error occurs while writing to the output stream\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(size());\n+        for (final E e : this) {\n+            out.writeObject(e);\n+        }\n+    }\n+\n+    /**\n+     * Read the queue in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException if an I/O error occurs while writing to the output stream\n+     * @throws ClassNotFoundException if the class of a serialized object can not be found\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        elements = (E[]) new Object[maxElements];\n+        final int size = in.readInt();\n+        for (int i = 0; i < size; i++) {\n+            elements[i] = (E) in.readObject();\n+        }\n+        start = 0;\n+        full = size == maxElements;\n+        if (full) {\n+            end = 0;\n+        } else {\n+            end = size;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements stored in the queue.\n+     *\n+     * @return this queue's size\n+     */\n+    @Override\n+    public int size() {\n+        int size = 0;\n+\n+        if (end < start) {\n+            size = maxElements - start + end;\n+        } else if (end == start) {\n+            size = full ? maxElements : 0;\n+        } else {\n+            size = end - start;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if this queue is empty; false otherwise.\n+     *\n+     * @return true if this queue is empty\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * A {@code CircularFifoQueue} can never be full, thus this returns always\n+     * {@code false}.\n+     *\n+     * @return always returns {@code false}\n+     */\n+    public boolean isFull() {\n+        return false;\n+    }\n+\n+    private boolean isAtFullCapacity() {\n+        return size() == maxElements;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the collection (the bound).\n+     *\n+     * @return the maximum number of elements the collection can hold\n+     */\n+    public int maxSize() {\n+        return maxElements;\n+    }\n+\n+    /**\n+     * Clears this queue.\n+     */\n+    @Override\n+    public void clear() {\n+        full = false;\n+        start = 0;\n+        end = 0;\n+        Arrays.fill(elements, null);\n+    }\n+\n+    /**\n+     * Adds the given element to this queue. If the queue is full, the least recently added\n+     * element is discarded so that a new element can be inserted.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     */\n+    @Override\n+    public boolean add(final E element) {\n+        if (null == element) {\n+            throw new NullPointerException(\"Attempted to add null object to queue\");\n+        }\n+\n+        if (isAtFullCapacity()) {\n+            remove();\n+        }\n+\n+        elements[end++] = element;\n+\n+        if (end >= maxElements) {\n+            end = 0;\n+        }\n+\n+        if (end == start) {\n+            full = true;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the element at the specified position in this queue.\n+     *\n+     * @param index the position of the element in the queue\n+     * @return the element at position {@code index}\n+     * @throws NoSuchElementException if the requested position is outside the range [0, size)\n+     */\n+    public E get(final int index) {\n+        final int sz = size();\n+        if (index < 0 || index >= sz) {\n+            throw new NoSuchElementException(\n+                    String.format(\"The specified index (%1$d) is outside the available range [0, %2$d)\",\n+                                  index, sz));\n+        }\n+        \n+        final int idx = (start + index) % maxElements;\n+        return elements[idx];\n+    }\n+ \n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Adds the given element to this queue. If the queue is full, the least recently added\n+     * element is discarded so that a new element can be inserted.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     */\n+    public boolean offer(E element) {\n+        return add(element);\n+    }\n+\n+    public E poll() {\n+        if (isEmpty()) {\n+            return null;\n+        } else {\n+            return remove();\n+        }\n+    }\n+\n+    public E element() {\n+        if (isEmpty()) {\n+            throw new NoSuchElementException(\"queue is empty\");\n+        } else {\n+            return peek();\n+        }\n+    }\n+\n+    public E peek() {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        return elements[start];\n+    }\n+\n+    public E remove() {\n+        if (isEmpty()) {\n+            throw new NoSuchElementException(\"queue is empty\");\n+        }\n+\n+        final E element = elements[start];\n+        if (null != element) {\n+            elements[start++] = null;\n+\n+            if (start >= maxElements) {\n+                start = 0;\n+            }\n+            full = false;\n+        }\n+        return element;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the internal index.\n+     *\n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n+    private int increment(int index) {\n+        index++;\n+        if (index >= maxElements) {\n+            index = 0;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Decrements the internal index.\n+     *\n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) {\n+            index = maxElements - 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Returns an iterator over this queue's elements.\n+     *\n+     * @return an iterator over this queue's elements\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n+\n+            private int index = start;\n+            private int lastReturnedIndex = -1;\n+            private boolean isFirst = full;\n+\n+            public boolean hasNext() {\n+                return isFirst || index != end;\n+            }\n+\n+            public E next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                isFirst = false;\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == start) {\n+                    CircularFifoQueue.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                int pos = lastReturnedIndex + 1;\n+                if (start < lastReturnedIndex && pos < end) {\n+                    // shift in one part\n+                    System.arraycopy(elements, pos, elements, lastReturnedIndex, end - pos);\n+                } else {\n+                    // Other elements require us to shift the subsequent elements\n+                    while (pos != end) {\n+                        if (pos >= maxElements) {\n+                            elements[pos - 1] = elements[0];\n+                            pos = 0;\n+                        } else {\n+                            elements[decrement(pos)] = elements[pos];\n+                            pos = increment(pos);\n+                        }\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                end = decrement(end);\n+                elements[end] = null;\n+                full = false;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+    \n+}\n--- a/src/main/java/org/apache/commons/collections/queue/package-info.java\n+++ b/src/main/java/org/apache/commons/collections/queue/package-info.java\n  * limitations under the License.\n  */\n /**\n- * This package contains decorators for the {@link java.util.Queue Queue} interface.\n+ * This package contains implementations for the {@link java.util.Queue Queue} interface.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>CircularFifoQueue - implements a queue with a fixed size that discards oldest when full\n+ * </ul>\n  * <p>\n  * The following decorators are provided in the package:\n  * <ul>\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/queue/CircularFifoQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.queue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+\n+/**\n+ * Test cases for CircularFifoQueue.\n+ *\n+ * @version $Id$\n+ */\n+public class CircularFifoQueueTest<E> extends AbstractCollectionTest<E> {\n+\n+    public CircularFifoQueueTest(final String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(CircularFifoQueueTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that\n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        final Iterator<E> iterator1 = getCollection().iterator();\n+        final Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            final Object o1 = iterator1.next();\n+            final Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because CircularFifoQueue doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because CircularFifoQueue isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty ArrayList.\n+     *\n+     * @return an empty ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     * Returns a full ArrayList.\n+     *\n+     * @return a full ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final Collection<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Returns an empty CircularFifoQueue that won't overflow.\n+     *\n+     * @return an empty CircularFifoQueue\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CircularFifoQueue<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCircularFifoQueueCircular() {\n+        final List<E> list = new ArrayList<E>();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        final Queue<E> queue = new CircularFifoQueue<E>(list);\n+\n+        assertEquals(true, queue.contains(\"A\"));\n+        assertEquals(true, queue.contains(\"B\"));\n+        assertEquals(true, queue.contains(\"C\"));\n+\n+        queue.add((E) \"D\");\n+\n+        assertEquals(false, queue.contains(\"A\"));\n+        assertEquals(true, queue.contains(\"B\"));\n+        assertEquals(true, queue.contains(\"C\"));\n+        assertEquals(true, queue.contains(\"D\"));\n+\n+        assertEquals(\"B\", queue.peek());\n+        assertEquals(\"B\", queue.remove());\n+        assertEquals(\"C\", queue.remove());\n+        assertEquals(\"D\", queue.remove());\n+    }\n+\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testCircularFifoQueueRemove() {\n+        resetFull();\n+        final int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            final Object o1 = getCollection().remove();\n+            final Object o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            getCollection().remove();\n+            fail(\"Empty queue should raise Underflow.\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new CircularFifoQueue<E>(0);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new CircularFifoQueue<E>(-20);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new CircularFifoQueue<E>(null);\n+        } catch (final NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError1() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[1, 2, 5]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError2() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+        fifo.add((E) \"6\");\n+\n+        assertEquals(5, fifo.size());\n+        assertEquals(\"[2, 3, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[2, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError3() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.add((E) \"6\");\n+        fifo.add((E) \"7\");\n+        assertEquals(\"[2, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError4() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");  // remove element in middle of array, after start\n+        assertEquals(\"[3, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError5() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"5\");  // remove element at last pos in array\n+        assertEquals(\"[3, 4, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError6() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"6\");  // remove element at position zero in array\n+        assertEquals(\"[3, 4, 5, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError7() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array\n+        assertEquals(\"[3, 4, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError8() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array, need to shift 8\n+        assertEquals(\"[4, 5, 6, 8]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError9() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"8\");  // remove element at position two in array\n+        assertEquals(\"[4, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRepeatedSerialization() throws Exception {\n+        // bug 31433\n+        final CircularFifoQueue<E> b = new CircularFifoQueue<E>(2);\n+        b.add((E) \"a\");\n+        assertEquals(1, b.size());\n+        assertEquals(true, b.contains(\"a\"));\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b);\n+\n+        final CircularFifoQueue<E> b2 = (CircularFifoQueue<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(1, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        b2.add((E) \"b\");\n+        assertEquals(2, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        assertEquals(true, b2.contains(\"b\"));\n+\n+        bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b2);\n+\n+        final CircularFifoQueue<E> b3 = (CircularFifoQueue<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"a\"));\n+        assertEquals(true, b3.contains(\"b\"));\n+        b3.add((E) \"c\");\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"b\"));\n+        assertEquals(true, b3.contains(\"c\"));\n+    }\n+\n+    public void testGetIndex() {\n+        resetFull();\n+        \n+        final CircularFifoQueue<E> queue = getCollection();\n+        final List<E> confirmed = getConfirmed();\n+        for (int i = 0; i < confirmed.size(); i++) {\n+            assertEquals(confirmed.get(i), queue.get(i));\n+        }\n+\n+        // remove the first two elements and check again\n+        queue.remove();\n+        queue.remove();\n+        \n+        for (int i = 0; i < queue.size(); i++) {\n+            assertEquals(confirmed.get(i + 2), queue.get(i));\n+        }        \n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CircularFifoQueue.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CircularFifoQueue.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CircularFifoQueue<E> getCollection() {\n+        return (CircularFifoQueue<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}", "timestamp": 1366142029, "metainfo": ""}