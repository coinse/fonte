{"sha": "f3eef9b91d5eebbdf32d28fe2fcb31d2f0e890b9", "log": "fixed strage javadoc wording per patch   ", "commit": "\n--- a/src/java/org/apache/commons/collections/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/LRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/LRUMap.java,v 1.12 2002/03/19 01:18:09 jefft Exp $\n- * $Revision: 1.12 $\n- * $Date: 2002/03/19 01:18:09 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/LRUMap.java,v 1.13 2002/04/16 21:15:13 morgand Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2002/04/16 21:15:13 $\n  *\n  * ====================================================================\n  *\n import java.io.ObjectOutputStream;\n import java.util.Iterator;\n \n-/** <p>\n-  * An implementation of a Map which has a maximum size and uses a Least Recently Used\n-  * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n-  * </p>\n-  *\n-  * <p>\n-  * A synchronized version can be obtained with:\n-  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n-  * If it will be accessed by multiple threads, you _must_ synchronize access \n-  * to this Map.  Even concurrent get(Object) operations produce indeterminate\n-  * behaviour.\n-  * </p>\n-  *\n-  * <p>\n-  * Unlike that Collections 1.0 version, this version of LRUMap does use a true\n-  * LRU algorithm.  The keys for all gets and puts are moved to the front of\n-  * the list.  LRUMap is now a subclass of SequencedHashMap, and the \"LRU\"\n-  * key is now equivalent to LRUMap.getFirst().\n-  * </p>\n-  * \n-  * \n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n-  */\n+/**\n+ * <p>\n+ * An implementation of a Map which has a maximum size and uses a Least Recently Used\n+ * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n+ * </p>\n+ * \n+ * <p>\n+ * A synchronized version can be obtained with:\n+ * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n+ * If it will be accessed by multiple threads, you _must_ synchronize access\n+ * to this Map.  Even concurrent get(Object) operations produce indeterminate\n+ * behaviour.\n+ * </p>\n+ * \n+ * <p>\n+ * Unlike the Collections 1.0 version, this version of LRUMap does use a true\n+ * LRU algorithm.  The keys for all gets and puts are moved to the front of\n+ * the list.  LRUMap is now a subclass of SequencedHashMap, and the \"LRU\"\n+ * key is now equivalent to LRUMap.getFirst().\n+ * </p>\n+ * \n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n+ */\n public class LRUMap extends SequencedHashMap implements Externalizable {\n         \n     private int maximumSize = 0;", "timestamp": 1018991713, "metainfo": ""}