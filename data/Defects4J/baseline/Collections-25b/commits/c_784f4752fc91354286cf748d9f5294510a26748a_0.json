{"sha": "784f4752fc91354286cf748d9f5294510a26748a", "log": "Convert control statement bodies to block.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/main/java/org/apache/commons/collections/map/Flat3Map.java\n             switch (size) {\n                 // drop through\n                 case 3:\n-                    if (key3 == null) return value3;\n+                    if (key3 == null) {\n+                        return value3;\n+                    }\n                 case 2:\n-                    if (key2 == null) return value2;\n+                    if (key2 == null) {\n+                        return value2;\n+                    }\n                 case 1:\n-                    if (key1 == null) return value1;\n+                    if (key1 == null) {\n+                        return value1;\n+                    }\n             }\n         } else {\n             if (size > 0) {\n                 switch (size) {\n                     // drop through\n                     case 3:\n-                        if (hash3 == hashCode && key.equals(key3)) return value3;\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            return value3;\n+                        }\n                     case 2:\n-                        if (hash2 == hashCode && key.equals(key2)) return value2;\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            return value2;\n+                        }\n                     case 1:\n-                        if (hash1 == hashCode && key.equals(key1)) return value1;\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            return value1;\n+                        }\n                 }\n             }\n         }\n         if (key == null) {\n             switch (size) {  // drop through\n                 case 3:\n-                    if (key3 == null) return true;\n+                    if (key3 == null) {\n+                        return true;\n+                    }\n                 case 2:\n-                    if (key2 == null) return true;\n+                    if (key2 == null) {\n+                        return true;\n+                    }\n                 case 1:\n-                    if (key1 == null) return true;\n+                    if (key1 == null) {\n+                        return true;\n+                    }\n             }\n         } else {\n             if (size > 0) {\n                 int hashCode = key.hashCode();\n                 switch (size) {  // drop through\n                     case 3:\n-                        if (hash3 == hashCode && key.equals(key3)) return true;\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            return true;\n+                        }\n                     case 2:\n-                        if (hash2 == hashCode && key.equals(key2)) return true;\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            return true;\n+                        }\n                     case 1:\n-                        if (hash1 == hashCode && key.equals(key1)) return true;\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            return true;\n+                        }\n                 }\n             }\n         }\n         if (value == null) {  // drop through\n             switch (size) {\n                 case 3:\n-                    if (value3 == null) return true;\n+                    if (value3 == null) {\n+                        return true;\n+                    }\n                 case 2:\n-                    if (value2 == null) return true;\n+                    if (value2 == null) {\n+                        return true;\n+                    }\n                 case 1:\n-                    if (value1 == null) return true;\n+                    if (value1 == null) {\n+                        return true;\n+                    }\n             }\n         } else {\n             switch (size) {  // drop through\n                 case 3:\n-                    if (value.equals(value3)) return true;\n+                    if (value.equals(value3)) {\n+                        return true;\n+                    }\n                 case 2:\n-                    if (value.equals(value2)) return true;\n+                    if (value.equals(value2)) {\n+                        return true;\n+                    }\n                 case 1:\n-                    if (value.equals(value1)) return true;\n+                    if (value.equals(value1)) {\n+                        return true;\n+                    }\n             }\n         }\n         return false;\n--- a/src/test/java/org/apache/commons/collections/AbstractLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractLinkedListTest.java\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testLinkedListAddFirst() {\n-        if (!isAddSupported()) return;\n+        if (!isAddSupported()) {\n+            return;\n+        }\n         T o = (T) \"hello\";\n \n         resetEmpty();\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testLinkedListAddLast() {\n-        if (!isAddSupported()) return;\n+        if (!isAddSupported()) {\n+            return;\n+        }\n         T o = (T) \"hello\";\n \n         resetEmpty();\n      *  Tests {@link LinkedList#removeFirst()}.\n      */\n     public void testLinkedListRemoveFirst() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         try {\n      *  Tests {@link LinkedList#removeLast()}.\n      */\n     public void testLinkedListRemoveLast() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         try {\n--- a/src/test/java/org/apache/commons/collections/BulkTest.java\n+++ b/src/test/java/org/apache/commons/collections/BulkTest.java\n         Class<? extends BulkTest> c = bulk.getClass();\n         Method[] all = c.getMethods();\n         for (Method element : all) {\n-            if (isTest(element)) addTest(bulk, element);\n-            if (isBulk(element)) addBulk(bulk, element);\n+            if (isTest(element)) {\n+                addTest(bulk, element);\n+            }\n+            if (isBulk(element)) {\n+                addBulk(bulk, element);\n+            }\n         }\n     }\n \n         BulkTest bulk2 = (BulkTest)bulk.clone();\n         bulk2.setName(m.getName());\n         bulk2.verboseName = prefix + \".\" + m.getName();\n-        if (ignored.contains(bulk2.verboseName)) return;\n+        if (ignored.contains(bulk2.verboseName)) {\n+            return;\n+        }\n         result.addTest(bulk2);\n     }\n \n      */\n     void addBulk(BulkTest bulk, Method m) {\n         String verboseName = prefix + \".\" + m.getName();\n-        if (ignored.contains(verboseName)) return;\n+        if (ignored.contains(verboseName)) {\n+            return;\n+        }\n         \n         BulkTest bulk2;\n         try {\n             bulk2 = (BulkTest)m.invoke(bulk, (Object[]) null);\n-            if (bulk2 == null) return;\n+            if (bulk2 == null) {\n+                return;\n+            }\n         } catch (InvocationTargetException ex) {\n             ex.getTargetException().printStackTrace();\n             throw new Error(); // FIXME;\n     private static <T extends BulkTest> BulkTest makeFirstTestCase(Class<T> c) {\n         Method[] all = c.getMethods();\n         for (Method element : all) {\n-            if (isTest(element)) return makeTestCase(c, element);\n+            if (isTest(element)) {\n+                return makeTestCase(c, element);\n+            }\n         }\n         throw new IllegalArgumentException(c.getName() + \" must provide \" \n           + \" at least one test method.\");\n      *  Returns true if the given method is a simple test method.\n      */\n     private static boolean isTest(Method m) {\n-        if (!m.getName().startsWith(\"test\")) return false;\n-        if (m.getReturnType() != Void.TYPE) return false;\n-        if (m.getParameterTypes().length != 0) return false;\n+        if (!m.getName().startsWith(\"test\")) {\n+            return false;\n+        }\n+        if (m.getReturnType() != Void.TYPE) {\n+            return false;\n+        }\n+        if (m.getParameterTypes().length != 0) {\n+            return false;\n+        }\n         int mods = m.getModifiers();\n-        if (Modifier.isStatic(mods)) return false;\n-        if (Modifier.isAbstract(mods)) return false;\n+        if (Modifier.isStatic(mods)) {\n+            return false;\n+        }\n+        if (Modifier.isAbstract(mods)) {\n+            return false;\n+        }\n         return true;\n     }\n \n      *  Returns true if the given method is a bulk test method.\n      */\n     private static boolean isBulk(Method m) {\n-        if (!m.getName().startsWith(\"bulkTest\")) return false;\n-        if (m.getReturnType() != BulkTest.class) return false;\n-        if (m.getParameterTypes().length != 0) return false;\n+        if (!m.getName().startsWith(\"bulkTest\")) {\n+            return false;\n+        }\n+        if (m.getReturnType() != BulkTest.class) {\n+            return false;\n+        }\n+        if (m.getParameterTypes().length != 0) {\n+            return false;\n+        }\n         int mods = m.getModifiers();\n-        if (Modifier.isStatic(mods)) return false;\n-        if (Modifier.isAbstract(mods)) return false;\n+        if (Modifier.isStatic(mods)) {\n+            return false;\n+        }\n+        if (Modifier.isAbstract(mods)) {\n+            return false;\n+        }\n         return true;\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bag/AbstractBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/AbstractBagTest.java\n     //-----------------------------------------------------------------------\n     public void testEmptyBagSerialization() throws IOException, ClassNotFoundException {\n         Bag<T> bag = makeObject();\n-        if (!(bag instanceof Serializable && isTestSerialization())) return;\n+        if (!(bag instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n         \n         byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n         Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n         bag.add((T) \"B\");\n         bag.add((T) \"C\");\n         int size = bag.size();\n-        if (!(bag instanceof Serializable && isTestSerialization())) return;\n+        if (!(bag instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n         \n         byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n         Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testBidiPut() {\n-        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n \n         BidiMap<K, V> map = makeObject();\n         BidiMap<V, K> inverse = map.inverseBidiMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiModifyEntrySet() {\n-        if (isSetValueSupported() == false) return;\n+        if (isSetValueSupported() == false) {\n+            return;\n+        }\n \n         modifyEntrySet(makeFullMap());\n         modifyEntrySet(makeFullMap().inverseBidiMap());\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByKeySet() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n         removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByEntrySet() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n         removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n \n     //-----------------------------------------------------------------------\n     public void testBidiClearByHeadMap() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByHeadMap() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByHeadMapEntrySet() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiClearByTailMap() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByTailMap() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByTailMapEntrySet() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiClearBySubMap() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveBySubMap() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n \n     //-----------------------------------------------------------------------\n     public void testBidiRemoveBySubMapEntrySet() {\n-        if (isRemoveSupported() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n \n         // extra test as other tests get complex\n         SortedBidiMap<K, V> sm = makeFullMap();\n--- a/src/test/java/org/apache/commons/collections/buffer/PriorityBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/PriorityBufferTest.java\n         StringBuilder buffer = new StringBuilder();\n         for (int offset = 1; count < h.size() + 1; offset *= 2) {\n             for (int i = offset; i < offset * 2; i++) {\n-                if (i < h.elements.length && h.elements[i] != null)\n+                if (i < h.elements.length && h.elements[i] != null) {\n                     buffer.append(h.elements[i] + \" \");\n+                }\n                 count++;\n             }\n             buffer.append('\\n');\n--- a/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n      *  Tests {@link Collection#add(Object)}.\n      */\n     public void testCollectionAdd() {\n-        if (!isAddSupported()) return;\n+        if (!isAddSupported()) {\n+            return;\n+        }\n \n         E[] elements = getFullElements();\n         for (E element : elements) {\n             boolean r = getCollection().add(element);\n             getConfirmed().add(element);\n             verify();\n-            if (r) size++;\n+            if (r) {\n+                size++;\n+            }\n             assertEquals(\"Collection size should grow after add\", size, getCollection().size());\n             assertTrue(\"Collection should contain added element\", getCollection().contains(element));\n         }\n      *  Tests {@link Collection#addAll(Collection)}.\n      */\n     public void testCollectionAddAll() {\n-        if (!isAddSupported()) return;\n+        if (!isAddSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         E[] elements = getFullElements();\n      *  raise <code>UnsupportedOperationException.\n      */\n     public void testUnsupportedAdd() {\n-        if (isAddSupported()) return;\n+        if (isAddSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         try {\n      *  Test {@link Collection#clear()}.\n      */\n     public void testCollectionClear() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         getCollection().clear(); // just to make sure it doesn't raise anything\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testCollectionIteratorRemove() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         try {\n      *  Tests {@link Collection#remove(Object)}.\n      */\n     public void testCollectionRemove() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         E[] elements = getFullElements();\n      *  Tests {@link Collection#removeAll(Collection)}.\n      */\n     public void testCollectionRemoveAll() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         assertTrue(\"Empty collection removeAll should return false for empty input\",\n      *  Tests {@link Collection#retainAll(Collection)}.\n      */\n     public void testCollectionRetainAll() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         List<E> elements = Arrays.asList(getFullElements());\n             // find a match in the confirmed array\n             for (int j = 0; j < array.length; j++) {\n                 // skip already matched\n-                if (matched[j])\n+                if (matched[j]) {\n                     continue;\n+                }\n                 if (array[i] == confirmedArray[j]\n                         || (array[i] != null && array[i].equals(confirmedArray[j]))) {\n                     matched[j] = true;\n         for (Object element : array) {\n             classes.add((element == null) ? null : element.getClass());\n         }\n-        if (classes.size() > 1) return;\n+        if (classes.size() > 1) {\n+            return;\n+        }\n \n         Class<?> cl = classes.iterator().next();\n         if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet\n      *  operations raise an UnsupportedOperationException.\n      */\n     public void testUnsupportedRemove() {\n-        if (isRemoveSupported()) return;\n+        if (isRemoveSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         try {\n      *  Tests that the collection's iterator is fail-fast.\n      */\n     public void testCollectionIteratorFailFast() {\n-        if (!isFailFastSupported()) return;\n+        if (!isFailFastSupported()) {\n+            return;\n+        }\n \n         if (isAddSupported()) {\n             resetFull();\n             verify();\n         }\n \n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         resetFull();\n         try {\n--- a/src/test/java/org/apache/commons/collections/list/AbstractLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractLinkedListTest.java\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveNode() {\n         resetEmpty();\n-        if (isAddSupported() == false || isRemoveSupported() == false) return;\n+        if (isAddSupported() == false || isRemoveSupported() == false) {\n+            return;\n+        }\n         AbstractLinkedList<E> list = getCollection();\n \n         list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n--- a/src/test/java/org/apache/commons/collections/list/AbstractListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractListTest.java\n      *  full list.\n      */\n     public void testListSetByIndexBoundsChecking2() {\n-        if (!isSetSupported()) return;\n+        if (!isSetSupported()) {\n+            return;\n+        }\n \n         List<E> list = makeFullCollection();\n         E element = getOtherElements()[0];\n      *  Test {@link List#set(int,Object)}.\n      */\n     public void testListSetByIndex() {\n-        if (!isSetSupported()) return;\n+        if (!isSetSupported()) {\n+            return;\n+        }\n \n         resetFull();\n         E[] elements = getFullElements();\n      *  raises <Code>UnsupportedOperationException.\n      */\n     public void testUnsupportedSet() {\n-        if (isSetSupported()) return;\n+        if (isSetSupported()) {\n+            return;\n+        }\n \n         resetFull();\n         try {\n      *  empty list.\n      */\n     public void testListRemoveByIndexBoundsChecking() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         List<E> list = makeObject();\n \n      *  full list.\n      */\n     public void testListRemoveByIndexBoundsChecking2() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         List<E> list = makeFullCollection();\n \n      *  Tests {@link List#remove(int)}.\n      */\n     public void testListRemoveByIndex() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         int max = getFullElements().length;\n         for (int i = 0; i < max; i++) {\n      * Tests remove on list iterator is correct.\n      */\n     public void testListListIteratorPreviousRemoveNext() {\n-        if (isRemoveSupported() == false) return;\n-        resetFull();\n-        if (getCollection().size() < 4) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n         ListIterator<E> it = getCollection().listIterator();\n         E zero = it.next();\n         E one = it.next();\n      * Tests remove on list iterator is correct.\n      */\n     public void testListListIteratorPreviousRemovePrevious() {\n-        if (isRemoveSupported() == false) return;\n-        resetFull();\n-        if (getCollection().size() < 4) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n         ListIterator<E> it = getCollection().listIterator();\n         E zero = it.next();\n         E one = it.next();\n      * Tests remove on list iterator is correct.\n      */\n     public void testListListIteratorNextRemoveNext() {\n-        if (isRemoveSupported() == false) return;\n-        resetFull();\n-        if (getCollection().size() < 4) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n         ListIterator<E> it = getCollection().listIterator();\n         E zero = it.next();\n         E one = it.next();\n      * Tests remove on list iterator is correct.\n      */\n     public void testListListIteratorNextRemovePrevious() {\n-        if (isRemoveSupported() == false) return;\n-        resetFull();\n-        if (getCollection().size() < 4) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n         ListIterator<E> it = getCollection().listIterator();\n         E zero = it.next();\n         E one = it.next();\n      *  iterator.\n      */\n     public void testListIteratorAdd() {\n-        if (!isAddSupported()) return;\n+        if (!isAddSupported()) {\n+            return;\n+        }\n \n         resetEmpty();\n         List<E> list1 = getCollection();\n      *  iterator.\n      */\n     public void testListIteratorSet() {\n-        if (!isSetSupported()) return;\n+        if (!isSetSupported()) {\n+            return;\n+        }\n \n         E[] elements = getFullElements();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEmptyListSerialization() throws IOException, ClassNotFoundException {\n         List<E> list = makeObject();\n-        if (!(list instanceof Serializable && isTestSerialization())) return;\n+        if (!(list instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n \n         byte[] objekt = writeExternalFormToBytes((Serializable) list);\n         List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n     public void testFullListSerialization() throws IOException, ClassNotFoundException {\n         List<E> list = makeFullCollection();\n         int size = getFullElements().length;\n-        if (!(list instanceof Serializable && isTestSerialization())) return;\n+        if (!(list instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n \n         byte[] objekt = writeExternalFormToBytes((Serializable) list);\n         List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n      *  modified when the sublist is.\n      */\n     public BulkTest bulkTestSubList() {\n-        if (getFullElements().length - 6 < 10) return null;\n+        if (getFullElements().length - 6 < 10) {\n+            return null;\n+        }\n         return new BulkTestSubList<E>(this);\n     }\n \n     *  if elements are added to the original list.\n     */\n    public void testListSubListFailFastOnAdd() {\n-       if (!isFailFastSupported()) return;\n-       if (!isAddSupported()) return;\n+       if (!isFailFastSupported()) {\n+        return;\n+    }\n+       if (!isAddSupported()) {\n+        return;\n+    }\n \n        resetFull();\n        int size = getCollection().size();\n     *  if elements are removed from the original list.\n     */\n    public void testListSubListFailFastOnRemove() {\n-       if (!isFailFastSupported()) return;\n-       if (!isRemoveSupported()) return;\n+       if (!isFailFastSupported()) {\n+        return;\n+    }\n+       if (!isRemoveSupported()) {\n+        return;\n+    }\n \n        resetFull();\n        int size = getCollection().size();\n     *  @param m     the method to invoke\n     */\n    protected void failFastMethod(List<E> list, Method m) {\n-       if (m.getName().equals(\"equals\")) return;\n+       if (m.getName().equals(\"equals\")) {\n+        return;\n+    }\n \n        E element = getOtherElements()[0];\n        Collection<E> c = Collections.singleton(element);\n        Class<?>[] types = m.getParameterTypes();\n        Object[] params = new Object[types.length];\n        for (int i = 0; i < params.length; i++) {\n-           if (types[i] == Integer.TYPE) params[i] = new Integer(0);\n-           else if (types[i] == Collection.class) params[i] = c;\n-           else if (types[i] == Object.class) params[i] = element;\n-           else if (types[i] == Object[].class) params[i] = new Object[0];\n+           if (types[i] == Integer.TYPE) {\n+            params[i] = new Integer(0);\n+        } else if (types[i] == Collection.class) {\n+            params[i] = c;\n+        } else if (types[i] == Object.class) {\n+            params[i] = element;\n+        } else if (types[i] == Object[].class) {\n+            params[i] = new Object[0];\n+        }\n        }\n \n        try {\n--- a/src/test/java/org/apache/commons/collections/list/NodeCachingLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/NodeCachingLinkedListTest.java\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testShrinkCache() {\n-        if (isRemoveSupported() == false || isAddSupported() == false) return;\n+        if (isRemoveSupported() == false || isAddSupported() == false) {\n+            return;\n+        }\n         resetEmpty();\n         NodeCachingLinkedList<E> list = getCollection();\n \n--- a/src/test/java/org/apache/commons/collections/map/AbstractIterableMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractIterableMapTest.java\n \n     //-----------------------------------------------------------------------\n     public void testFailFastEntrySet() {\n-        if (isRemoveSupported() == false) return;\n-        if (isFailFastExpected() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        if (isFailFastExpected() == false) {\n+            return;\n+        }\n         resetFull();\n         Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();\n         Map.Entry<K, V> val = it.next();\n     }\n \n     public void testFailFastKeySet() {\n-        if (isRemoveSupported() == false) return;\n-        if (isFailFastExpected() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        if (isFailFastExpected() == false) {\n+            return;\n+        }\n         resetFull();\n         Iterator<K> it = getMap().keySet().iterator();\n         K val = it.next();\n     }\n \n     public void testFailFastValues() {\n-        if (isRemoveSupported() == false) return;\n-        if (isFailFastExpected() == false) return;\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        if (isFailFastExpected() == false) {\n+            return;\n+        }\n         resetFull();\n         Iterator<V> it = getMap().values().iterator();\n         it.next();\n--- a/src/test/java/org/apache/commons/collections/map/AbstractMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractMapTest.java\n      * the underlying map for clear().\n      */\n     public void testValuesClearChangesMap() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         // clear values, reflected in map\n         resetFull();\n      * the underlying map for clear().\n      */\n     public void testKeySetClearChangesMap() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         // clear values, reflected in map\n         resetFull();\n      * the underlying map for clear().\n      */\n     public void testEntrySetClearChangesMap() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n \n         // clear values, reflected in map\n         resetFull();\n     }\n \n     public void testEntrySetRemove1() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n         resetFull();\n         int size = getMap().size();\n         Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n     }\n \n     public void testEntrySetRemove2() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n         resetFull();\n         int size = getMap().size();\n         Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEntrySetRemove3() {\n-        if (!isRemoveSupported()) return;\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n         resetFull();\n         int size = getMap().size();\n         Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n         }\n \n         public void testMapEntrySetRemoveNonMapEntry() {\n-            if (isRemoveSupported() == false) return;\n+            if (isRemoveSupported() == false) {\n+                return;\n+            }\n             resetFull();\n             assertEquals(false, getCollection().remove(null));\n             assertEquals(false, getCollection().remove(new Object()));\n--- a/src/test/java/org/apache/commons/collections/map/AbstractSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractSortedMapTest.java\n             return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n         }\n         public void testHeadMapOutOfRange() {\n-            if (isPutAddSupported() == false) return;\n+            if (isPutAddSupported() == false) {\n+                return;\n+            }\n             resetEmpty();\n             try {\n                 getMap().put(toKey, subSortedValues.get(0));\n             return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n         }\n         public void testTailMapOutOfRange() {\n-            if (isPutAddSupported() == false) return;\n+            if (isPutAddSupported() == false) {\n+                return;\n+            }\n             resetEmpty();\n             try {\n                 getMap().put(invalidKey, subSortedValues.get(0));\n             return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n         }\n         public void testSubMapOutOfRange() {\n-            if (isPutAddSupported() == false) return;\n+            if (isPutAddSupported() == false) {\n+                return;\n+            }\n             resetEmpty();\n             try {\n                 getMap().put(toKey, subSortedValues.get(0));\n--- a/src/test/java/org/apache/commons/collections/map/LRUMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/LRUMapTest.java\n \n     //-----------------------------------------------------------------------\n     public void testLRU() {\n-        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n         K[] keys = getSampleKeys();\n         V[] values = getSampleValues();\n         Iterator<K> kit;\n \n     //-----------------------------------------------------------------------\n     public void testAccessOrder() {\n-        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n         K[] keys = getSampleKeys();\n         V[] values = getSampleValues();\n         Iterator<K> kit = null;\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalState_Buckets() {\n-        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n         SingleHashCode one = new SingleHashCode(\"1\");\n         SingleHashCode two = new SingleHashCode(\"2\");\n         SingleHashCode three = new SingleHashCode(\"3\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalState_getEntry_int() {\n-        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n         SingleHashCode one = new SingleHashCode(\"1\");\n         SingleHashCode two = new SingleHashCode(\"2\");\n         SingleHashCode three = new SingleHashCode(\"3\");\n--- a/src/test/java/org/apache/commons/collections/map/LinkedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/LinkedMapTest.java\n \n     //-----------------------------------------------------------------------\n     public void testInsertionOrder() {\n-        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n         K[] keys = getSampleKeys();\n         V[] values = getSampleValues();\n         Iterator<K> keyIter;", "timestamp": 1357577707, "metainfo": ""}