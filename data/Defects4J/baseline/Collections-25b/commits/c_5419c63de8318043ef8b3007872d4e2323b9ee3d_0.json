{"sha": "5419c63de8318043ef8b3007872d4e2323b9ee3d", "log": "Complete OrderedMap with MapIterator Ensure fully tested   ", "commit": "\n--- a/src/java/org/apache/commons/collections/decorators/OrderedMap.java\n+++ b/src/java/org/apache/commons/collections/decorators/OrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/OrderedMap.java,v 1.4 2003/10/03 23:19:32 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/OrderedMap.java,v 1.5 2003/11/04 23:36:23 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.decorators;\n \n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections.pairs.DefaultMapEntry;\n+import org.apache.commons.collections.iterators.DefaultMapIterator;\n+import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.pairs.AbstractMapEntry;\n \n /**\n- * Decorates a <code>Map</code> to ensure that the order of addition\n- * is retained and used by the values and keySet iterators.\n+ * Decorates a <code>Map</code> to ensure that the order of addition is retained.\n+ * <p>\n+ * The order will be used via the iterators and toArray methods on the views.\n+ * The order is also returned by the <code>MapIterator</code>.\n  * <p>\n  * If an object is added to the Map for a second time, it will remain in the\n  * original position in the iteration.\n- * <p>\n- * The order can be observed via the iterator or toArray methods.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/10/03 23:19:32 $\n+ * @version $Revision: 1.5 $ $Date: 2003/11/04 23:36:23 $\n  * \n  * @author Henri Yandell\n+ * @author Stephen Colebourne\n  */\n public class OrderedMap extends AbstractMapDecorator implements Map {\n \n \n     /**\n      * Factory method to create an ordered map.\n+     * <p>\n+     * An <code>ArrayList</code> is used to retain order.\n      * \n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n     protected OrderedMap(Map map) {\n         super(map);\n-        insertOrder.addAll( getMap().keySet() );\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void clear() {\n-        getMap().clear();\n-        insertOrder.clear();\n-    }\n-\n-    public void putAll(Map m) {\n-        for (Iterator it = m.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            put(entry.getKey(), entry.getValue());\n-        }\n-    }\n-\n+        insertOrder.addAll(getMap().keySet());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public Object put(Object key, Object value) {\n         if (getMap().containsKey(key)) {\n             // re-adding doesn't change order\n         }\n     }\n \n+    public void putAll(Map map) {\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n     public Object remove(Object key) {\n         Object result = getMap().remove(key);\n         insertOrder.remove(key);\n         return result;\n     }\n \n+    public void clear() {\n+        getMap().clear();\n+        insertOrder.clear();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public MapIterator mapIterator() {\n+        return new DefaultMapIterator(this);\n+    }\n+    \n     public Set keySet() {\n-        return new KeyView( this, this.insertOrder );\n+        return new KeySetView(this);\n     }\n \n     public Collection values() {\n-        return new ValuesView( this, this.insertOrder );\n-    }\n-\n-    // QUERY: Should a change of value change insertion order?\n+        return new ValuesView(this);\n+    }\n+\n     public Set entrySet() {\n-        return new EntrySetView( this, this.insertOrder );\n-    }\n-\n-    // TODO: Code a toString up. \n-    //       It needs to retain the right order, else it will \n-    //       look peculiar.\n+        return new EntrySetView(this, this.insertOrder);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the Map as a string.\n+     * \n+     * @return the Map as a String\n+     */\n     public String toString() {\n-        return super.toString();\n-    }\n-\n-    // class for handling the values() method's callback to this Map\n-    // THESE NEED UNIT TESTING as their own collections\n-    class ValuesView implements Collection {\n-        private OrderedMap parent;\n-        private List insertOrder;\n-\n-        ValuesView(OrderedMap parent, List insertOrder) {\n-            this.parent = parent;\n-            this.insertOrder = insertOrder;\n-        }\n-\n-        // slow to call\n-        Collection _values() {\n-            Iterator keys = this.insertOrder.iterator();\n-            ArrayList list = new ArrayList( insertOrder.size() );\n-            while( keys.hasNext() ) {\n-                list.add( this.parent.getMap().get( keys.next() ) );\n-            }\n-            return list;\n+        if (isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringBuffer buf = new StringBuffer();\n+        buf.append('{');\n+        boolean first = true;\n+        Iterator it = entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key);\n+            buf.append('=');\n+            buf.append(value == this ? \"(this Map)\" : value);\n+            if (first) {\n+                first = false;\n+            } else {\n+                buf.append(\", \");\n+            }\n+        }\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ValuesView extends AbstractCollection {\n+        private final OrderedMap parent;\n+\n+        ValuesView(OrderedMap parent) {\n+            super();\n+            this.parent = parent;\n         }\n \n         public int size() {\n             return this.parent.size();\n         }\n \n+        public boolean contains(Object value) {\n+            return this.parent.containsValue(value);\n+        }\n+\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new AbstractIteratorDecorator(parent.entrySet().iterator()) {\n+                public Object next() {\n+                    return ((Map.Entry) iterator.next()).getValue();\n+                }\n+            };\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    static class KeySetView extends AbstractSet {\n+        private final OrderedMap parent;\n+\n+        KeySetView(OrderedMap parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public int size() {\n+            return this.parent.size();\n+        }\n+\n+        public boolean contains(Object value) {\n+            return this.parent.containsKey(value);\n+        }\n+\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new AbstractIteratorDecorator(parent.entrySet().iterator()) {\n+                public Object next() {\n+                    return ((Map.Entry) super.next()).getKey();\n+                }\n+            };\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    static class EntrySetView extends AbstractSet {\n+        private final OrderedMap parent;\n+        private final List insertOrder;\n+        private Set entrySet;\n+\n+        public EntrySetView(OrderedMap parent, List insertOrder) {\n+            super();\n+            this.parent = parent;\n+            this.insertOrder = insertOrder;\n+        }\n+\n+        private Set getEntrySet() {\n+            if (entrySet == null) {\n+                entrySet = parent.getMap().entrySet();\n+            }\n+            return entrySet;\n+        }\n+        \n+        public int size() {\n+            return this.parent.size();\n+        }\n         public boolean isEmpty() {\n             return this.parent.isEmpty();\n         }\n \n-        public boolean contains(Object value) {\n-            return this.parent.containsValue(value);\n-        }\n-\n-        public Iterator iterator() {\n-            // TODO: Allow this to be backed\n-            return _values().iterator();\n-//            return new ValuesViewIterator( who? );\n-        }\n-\n-        public Object[] toArray() {\n-            return _values().toArray();\n-        }\n-\n-        public Object[] toArray(Object[] array) {\n-            return _values().toArray(array);\n-        }\n-\n-        public boolean add(Object obj) {\n-            throw new UnsupportedOperationException(\"Not allowed. \");\n+        public boolean contains(Object obj) {\n+            return getEntrySet().contains(obj);\n+        }\n+\n+        public boolean containsAll(Collection coll) {\n+            return getEntrySet().containsAll(coll);\n         }\n \n         public boolean remove(Object obj) {\n-            // who?? which value do I choose? first one?\n-            for(Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n-                Object key = itr.next();\n-                Object value = this.parent.get(key);\n-\n-                // also handles null\n-                if(value == obj) {\n-                    return (this.parent.remove(key) != null);\n-                } \n-\n-                if( (value != null) && value.equals(obj) ) {\n-                    return (this.parent.remove(key) != null);\n-                }\n-            }\n-\n-            return false;\n-        }\n-\n-        public boolean containsAll(Collection coll) {\n-            // TODO: What does Collection spec say about null/empty?\n-            for(Iterator itr = coll.iterator(); itr.hasNext(); ) {\n-                if( !this.parent.containsValue( itr.next() ) ) {\n-                    return false;\n-                }\n-            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Object key = ((Map.Entry) obj).getKey();\n+            if (parent.getMap().containsKey(key) == false) {\n+                return false;\n+            }\n+            parent.remove(key);\n             return true;\n-        }\n-\n-        public boolean addAll(Collection coll) {\n-            throw new UnsupportedOperationException(\"Not allowed. \");\n-        }\n-\n-        public boolean removeAll(Collection coll) {\n-            // not transactional. No idea if removeAll's boolean\n-            // reply is meant to be\n-            boolean ret = false;\n-            for( Iterator itr = coll.iterator(); itr.hasNext(); ) {\n-                ret = ret && remove(itr.next());\n-            }\n-            return ret;\n-        }\n-\n-        public boolean retainAll(Collection coll) {\n-            // transactional?\n-            boolean ret = false;\n-\n-            for( Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n-                Object key = itr.next();\n-                Object value = this.parent.get(key);\n-                if( coll.contains(value) ) {\n-                    // retain\n-                } else {\n-                    ret = ret && (parent.remove(key) != null);\n-                }\n-            }\n-\n-            return ret;\n         }\n \n         public void clear() {\n             this.parent.clear();\n         }\n-\n+        \n         public boolean equals(Object obj) {\n-            // exactly what to do here?\n-            return super.equals(obj);\n-        }\n+            if (obj == this) {\n+                return true;\n+            }\n+            return getEntrySet().equals(obj);\n+        }\n+        \n         public int hashCode() {\n-            return _values().hashCode();\n+            return getEntrySet().hashCode();\n         }\n \n         public String toString() {\n-            return _values().toString();\n-        }\n-    }\n-\n-    class KeyView implements Set {\n-\n-        private OrderedMap parent;\n-        private List insertOrder;\n-\n-        public KeyView(OrderedMap parent, List insertOrder) {\n-            this.parent = parent;\n-            this.insertOrder = insertOrder;\n-        }\n-\n-        public int size() {\n-            return this.parent.size();\n-        }\n-        public boolean isEmpty() {\n-            return this.parent.isEmpty();\n-        }\n-        public boolean contains(Object obj) {\n-            return this.parent.containsKey(obj);\n-        }\n+            return getEntrySet().toString();\n+        }\n+        \n         public Iterator iterator() {\n-            // TODO: Needs to return a KeyViewIterator, which \n-            //       removes from this and from the Map\n-            return this.insertOrder.iterator();\n-        }\n-        public Object toArray()[] {\n-            return this.insertOrder.toArray();\n-        }\n-        public Object toArray(Object[] array)[] {\n-            return this.insertOrder.toArray(array);\n-        }\n-        public boolean add(Object obj) {\n-            throw new UnsupportedOperationException(\"Not allowed. \");\n-        }\n-        public boolean remove(Object obj) {\n-            return (this.parent.remove(obj) != null);\n-        }\n-        public boolean containsAll(Collection coll) {\n-            // TODO: What does Collection spec say about null/empty?\n-            for(Iterator itr = coll.iterator(); itr.hasNext(); ) {\n-                if( !this.parent.containsKey( itr.next() ) ) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        public boolean addAll(Collection coll) {\n-            throw new UnsupportedOperationException(\"Not allowed. \");\n-        }\n-        public boolean removeAll(Collection coll) {\n-            // not transactional. No idea if removeAll's boolean\n-            // reply is meant to be\n-            boolean ret = false;\n-            for( Iterator itr = coll.iterator(); itr.hasNext(); ) {\n-                ret = ret && remove(itr.next());\n-            }\n-            return ret;\n-        }\n-        public boolean retainAll(Collection coll) {\n-            // transactional?\n-            boolean ret = false;\n-\n-            for( Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n-                Object key = itr.next();\n-                if( coll.contains(key) ) {\n-                    // retain\n-                } else {\n-                    ret = ret && (parent.remove(key) != null);\n-                }\n-            }\n-\n-            return ret;\n-        }\n-        public void clear() {\n-            this.parent.clear();\n-        }\n-        public boolean equals(Object obj) {\n-            // exactly what to do here?\n-            return super.equals(obj);\n-        }\n-        public int hashCode() {\n-            return this.parent.getMap().keySet().hashCode();\n-        }\n-\n-        public String toString() {\n-            return this.insertOrder.toString();\n-        }\n-    }\n-\n-    class EntrySetView implements Set {\n-\n-        private OrderedMap parent;\n-        private List insertOrder;\n-\n-        public EntrySetView(OrderedMap parent, List insertOrder) {\n-            this.parent = parent;\n-            this.insertOrder = insertOrder;\n-        }\n-\n-        public Set _entries() {\n-            Set set = new java.util.HashSet( this.insertOrder.size() );\n-            set = OrderedSet.decorate( set );\n-            for (Iterator it = insertOrder.iterator(); it.hasNext();) {\n-                Object key = it.next();\n-                set.add( new DefaultMapEntry( key, getMap().get( key ) ) );\n-            }\n-            return set;\n-        }\n-\n-        public int size() {\n-            return this.parent.size();\n-        }\n-        public boolean isEmpty() {\n-            return this.parent.isEmpty();\n-        }\n-\n-        public boolean contains(Object obj) {\n-            if(obj instanceof Map.Entry) {\n-                Map.Entry entry = (Map.Entry) obj;\n-                if( this.parent.containsKey(entry.getKey()) ) {\n-                    Object value = this.parent.get(entry.getKey());\n-                    if( obj == null && value == null ) {\n-                        return true;\n-                    } else {\n-                        return obj.equals(value);\n-                    }\n-                } else {\n-                    return false;\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\"Parameter must be a Map.Entry\");\n-            }\n-        }\n-        public Iterator iterator() {\n-            // TODO: Needs to return a EntrySetViewIterator, which \n-            //       removes from this and from the Map\n-            return _entries().iterator();\n-        }\n-        public Object toArray()[] {\n-            return _entries().toArray();\n-        }\n-        public Object toArray(Object[] array)[] {\n-            return _entries().toArray(array);\n-        }\n-        public boolean add(Object obj) {\n-            throw new UnsupportedOperationException(\"Not allowed. \");\n-        }\n-        public boolean remove(Object obj) {\n-            if(obj instanceof Map.Entry) {\n-                Map.Entry entry = (Map.Entry) obj;\n-                return (this.parent.remove(entry.getKey()) != null);\n-            } else {\n-                throw new IllegalArgumentException(\"Parameter must be a Map.Entry\");\n-            }\n-        }\n-        // need to decide on IllegalArgument or ClassCast in this class\n-        // when not Map.Entry\n-        public boolean containsAll(Collection coll) {\n-            // TODO: What does Collection spec say about null/empty?\n-            for(Iterator itr = coll.iterator(); itr.hasNext(); ) {\n-                Map.Entry entry = (Map.Entry) itr.next();\n-                if( !this.parent.containsKey( entry.getKey() ) ) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        public boolean addAll(Collection coll) {\n-            throw new UnsupportedOperationException(\"Not allowed. \");\n-        }\n-        public boolean removeAll(Collection coll) {\n-            // not transactional. No idea if removeAll's boolean\n-            // reply is meant to be\n-            boolean ret = false;\n-            for( Iterator itr = coll.iterator(); itr.hasNext(); ) {\n-                Map.Entry entry = (Map.Entry) itr.next();\n-                ret = ret && remove( entry.getKey() );\n-            }\n-            return ret;\n-        }\n-        public boolean retainAll(Collection coll) {\n-            // transactional?\n-            boolean ret = false;\n-\n-            for( Iterator itr = this.insertOrder.iterator(); itr.hasNext(); ) {\n-                Map.Entry entry = (Map.Entry) itr.next();\n-                Object key = entry.getKey();\n-                if( coll.contains(key) ) {\n-                    // retain\n-                } else {\n-                    ret = ret && (parent.remove(key) != null);\n-                }\n-            }\n-\n-            return ret;\n-        }\n-        public void clear() {\n-            this.parent.clear();\n-        }\n-        public boolean equals(Object obj) {\n-            // exactly what to do here?\n-            return super.equals(obj);\n-        }\n-        public int hashCode() {\n-            return this.parent.getMap().entrySet().hashCode();\n-        }\n-\n-        public String toString() {\n-            return this._entries().toString();\n+            return new OrderedIterator(parent, insertOrder);\n+        }\n+    }\n+    \n+    static class OrderedIterator extends AbstractIteratorDecorator {\n+        private final OrderedMap parent;\n+        private Object last = null;\n+        \n+        OrderedIterator(OrderedMap parent, List insertOrder) {\n+            super(insertOrder.iterator());\n+            this.parent = parent;\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return new OrderedMapEntry(parent, last);\n+        }\n+\n+        public void remove() {\n+            super.remove();\n+            parent.getMap().remove(last);\n+        }\n+    }\n+    \n+    static class OrderedMapEntry extends AbstractMapEntry {\n+        private final OrderedMap parent;\n+        \n+        OrderedMapEntry(OrderedMap parent, Object key) {\n+            super(key, null);\n+            this.parent = parent;\n+        }\n+        \n+        public Object getValue() {\n+            return parent.get(key);\n+        }\n+\n+        public Object setValue(Object value) {\n+            return parent.getMap().put(key, value);\n         }\n     }\n \n--- a/src/test/org/apache/commons/collections/decorators/TestOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestOrderedMap.java,v 1.2 2003/10/03 12:54:54 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestOrderedMap.java,v 1.3 2003/11/04 23:36:23 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Set;\n \n import junit.framework.Test;\n-import junit.framework.TestSuite;\n \n import org.apache.commons.collections.AbstractTestMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+import org.apache.commons.collections.iterators.MapIterator;\n \n /**\n  * Extension of {@link TestMap} for exercising the {@link OrderedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/10/03 12:54:54 $\n+ * @version $Revision: 1.3 $ $Date: 2003/11/04 23:36:23 $\n  * \n  * @author Henri Yandell\n+ * @author Stephen Colebourne\n  */\n public class TestOrderedMap extends AbstractTestMap {\n \n     }\n \n     public static Test suite() {\n-        return new TestSuite(TestOrderedMap.class);\n+        return BulkTest.makeSuite(TestOrderedMap.class);\n     }\n \n     public static void main(String args[]) {\n         return OrderedMap.decorate(new HashMap());\n     }\n \n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestMapIterator() {\n+        return new TestOrderedMapIterator();\n+    }\n+    \n+    public class TestOrderedMapIterator extends AbstractTestMapIterator {\n+        public TestOrderedMapIterator() {\n+            super(\"TestOrderedMapIterator\");\n+        }\n+        \n+        protected Object addSetValue() {\n+            return TestOrderedMap.this.getNewSampleValues()[0];\n+        }\n+        \n+        protected boolean supportsRemove() {\n+            return TestOrderedMap.this.isRemoveSupported();\n+        }\n+\n+        protected boolean supportsSetValue() {\n+            return TestOrderedMap.this.isSetValueSupported();\n+        }\n+\n+        protected MapIterator makeEmptyMapIterator() {\n+            resetEmpty();\n+            return ((OrderedMap) TestOrderedMap.this.map).mapIterator();\n+        }\n+\n+        protected MapIterator makeFullMapIterator() {\n+            resetFull();\n+            return ((OrderedMap) TestOrderedMap.this.map).mapIterator();\n+        }\n+        \n+        protected Map getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return TestOrderedMap.this.map;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorRemove() {\n+        resetFull();\n+        OrderedMap testMap = (OrderedMap) map;\n+        MapIterator it = testMap.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key = it.next();\n+        \n+        if (isRemoveSupported() == false) {\n+            try {\n+                it.remove();\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+        \n+        it.remove();\n+        confirmed.remove(key);\n+        assertEquals(false, testMap.containsKey(key));\n+        verify();\n+        \n+        try {\n+            it.remove();  // second remove fails\n+        } catch (IllegalStateException ex) {\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSet() {\n+        Object newValue1 = getOtherValues()[0];\n+        Object newValue2 = getOtherValues()[1];\n+        \n+        resetFull();\n+        OrderedMap testMap = (OrderedMap) map;\n+        MapIterator it = testMap.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key1 = it.next();\n+        \n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+        \n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, testMap.containsKey(key1));\n+        assertEquals(true, testMap.containsValue(newValue1));\n+        assertEquals(newValue1, testMap.get(key1));\n+        verify();\n+        \n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, testMap.containsKey(key1));\n+        assertEquals(true, testMap.containsValue(newValue1));\n+        assertEquals(newValue1, testMap.get(key1));\n+        verify();\n+        \n+        Object key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, testMap.containsKey(key2));\n+        assertEquals(true, testMap.containsValue(newValue2));\n+        assertEquals(newValue2, testMap.get(key2));\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     // Creates a known series of Objects, puts them in \n     // an OrderedMap and ensures that all three Collection \n     // methods return in the correct order.", "timestamp": 1067988983, "metainfo": ""}