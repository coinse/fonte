{"sha": "d16bc8509fc423540a131184552649de1bbcaf98", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified in commit r738956.    ", "commit": "\n--- a/src/java/org/apache/commons/collections/ArrayStack.java\n+++ b/src/java/org/apache/commons/collections/ArrayStack.java\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  */\n-public class ArrayStack extends ArrayList implements Buffer {\n+public class ArrayStack<E> extends ArrayList<E> implements Buffer<E> {\n \n     /** Ensure serialization compatibility */    \n     private static final long serialVersionUID = 2130079159931574599L;\n      * @return the top item on the stack\n      * @throws EmptyStackException  if the stack is empty\n      */\n-    public Object peek() throws EmptyStackException {\n+    public E peek() throws EmptyStackException {\n         int n = size();\n         if (n <= 0) {\n             throw new EmptyStackException();\n      * @throws EmptyStackException  if there are not enough items on the\n      *  stack to satisfy this request\n      */\n-    public Object peek(int n) throws EmptyStackException {\n+    public E peek(int n) throws EmptyStackException {\n         int m = (size() - n) - 1;\n         if (m < 0) {\n             throw new EmptyStackException();\n      * @return the top item on the stack\n      * @throws EmptyStackException  if the stack is empty\n      */\n-    public Object pop() throws EmptyStackException {\n+    public E pop() throws EmptyStackException {\n         int n = size();\n         if (n <= 0) {\n             throw new EmptyStackException();\n      * @param item  the item to be added\n      * @return the item just pushed\n      */\n-    public Object push(Object item) {\n+    public E push(E item) {\n         add(item);\n         return item;\n     }\n      * @return the element on the top of the stack\n      * @throws BufferUnderflowException  if the stack is empty\n      */\n-    public Object get() {\n+    public E get() {\n         int size = size();\n         if (size == 0) {\n             throw new BufferUnderflowException();\n      * @return the removed element \n      * @throws BufferUnderflowException  if the stack is empty\n      */\n-    public Object remove() {\n+    public E remove() {\n         int size = size();\n         if (size == 0) {\n             throw new BufferUnderflowException();\n--- a/src/java/org/apache/commons/collections/BoundedCollection.java\n+++ b/src/java/org/apache/commons/collections/BoundedCollection.java\n  * @author Herve Quiroz\n  * @author Stephen Colebourne\n  */\n-public interface BoundedCollection extends Collection {\n+public interface BoundedCollection<E> extends Collection<E> {\n \n     /**\n      * Returns true if this collection is full and no new elements can be added.\n--- a/src/java/org/apache/commons/collections/BufferOverflowException.java\n+++ b/src/java/org/apache/commons/collections/BufferOverflowException.java\n  */\n public class BufferOverflowException extends RuntimeException {\n     \n+    /** Serialization version */\n+    private static final long serialVersionUID = -3992254982265755876L;\n+\n     /** The root cause throwable */\n     private final Throwable throwable;\n \n--- a/src/java/org/apache/commons/collections/BufferUnderflowException.java\n+++ b/src/java/org/apache/commons/collections/BufferUnderflowException.java\n  */\n public class BufferUnderflowException extends NoSuchElementException {\n     \n+    /** Serialization version */\n+    private static final long serialVersionUID = 4054570024234606028L;\n+\n     /** The root cause throwable */\n     private final Throwable throwable;\n \n--- a/src/java/org/apache/commons/collections/Closure.java\n+++ b/src/java/org/apache/commons/collections/Closure.java\n  * <p>\n  * Standard implementations of common closures are provided by\n  * {@link ClosureUtils}. These include method invokation and for/while loops.\n- *  \n+ *\n+ * @param <T> the type that the closure acts on\n  * @since Commons Collections 1.0\n  * @version $Revision$ $Date$\n  *\n  * @author Nicola Ken Barozzi\n  * @author Stephen Colebourne\n  */\n-public interface Closure {\n+public interface Closure<T> {\n \n     /**\n      * Performs an action on the specified input object.\n      * @throws IllegalArgumentException (runtime) if the input is invalid\n      * @throws FunctorException (runtime) if any other error occurs\n      */\n-    public void execute(Object input);\n+    public void execute(T input);\n \n }\n--- a/src/java/org/apache/commons/collections/ComparatorUtils.java\n+++ b/src/java/org/apache/commons/collections/ComparatorUtils.java\n      *\n      * @see ComparableComparator#getInstance\n      */\n-    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.getInstance();\n+    @SuppressWarnings(\"unchecked\")\n+    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>getInstance();\n \n     /**\n      * Gets a comparator that uses the natural order of the objects.\n      *\n      * @return  a comparator which uses natural order\n      */\n-    public static Comparator naturalComparator() {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n         return NATURAL_COMPARATOR;\n     }\n \n      * @throws NullPointerException if either comparator is null\n      * @see ComparatorChain\n      */\n-    public static Comparator chainedComparator(Comparator comparator1, Comparator comparator2) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Comparator<E> comparator1, Comparator<E> comparator2) {\n         return chainedComparator(new Comparator[] {comparator1, comparator2});\n     }\n \n      * @throws NullPointerException if comparators array is null or contains a null\n      * @see ComparatorChain\n      */\n-    public static Comparator chainedComparator(Comparator[] comparators) {\n-        ComparatorChain chain = new ComparatorChain();\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Comparator<E>[] comparators) {\n+        ComparatorChain<E> chain = new ComparatorChain<E>();\n         for (int i = 0; i < comparators.length; i++) {\n             if (comparators[i] == null) {\n                 throw new NullPointerException(\"Comparator cannot be null\");\n      * @throws ClassCastException if the comparators collection contains the wrong object type\n      * @see ComparatorChain\n      */\n-    public static Comparator chainedComparator(Collection comparators) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Collection<Comparator<E>> comparators) {\n         return chainedComparator(\n-            (Comparator[]) comparators.toArray(new Comparator[comparators.size()])\n+            (Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()])\n         );\n     }\n \n      * @return  a comparator that reverses the order of the input comparator\n      * @see ReverseComparator\n      */\n-    public static Comparator reversedComparator(Comparator comparator) {\n-        if (comparator == null) {\n-            comparator = NATURAL_COMPARATOR;\n-        }\n-        return new ReverseComparator(comparator);\n+    public static <E> Comparator<E> reversedComparator(Comparator<E> comparator) {\n+        return new ReverseComparator<E>(comparator);\n     }\n \n     /**\n      *        <code>false</code> {@link Boolean}s.\n      * @return  a comparator that sorts booleans\n      */\n-    public static Comparator booleanComparator(boolean trueFirst) {\n+    public static Comparator<Boolean> booleanComparator(boolean trueFirst) {\n         return BooleanComparator.getBooleanComparator(trueFirst);\n     }\n     \n      * @return  a version of that comparator that allows nulls\n      * @see NullComparator\n      */\n-    public static Comparator nullLowComparator(Comparator comparator) {\n-        if (comparator == null) {\n-            comparator = NATURAL_COMPARATOR;\n-        }\n-        return new NullComparator(comparator, false);\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new NullComparator<E>(comparator, false);\n     }\n \n     /**\n      * @return  a version of that comparator that allows nulls\n      * @see NullComparator\n      */\n-    public static Comparator nullHighComparator(Comparator comparator) {\n-        if (comparator == null) {\n-            comparator = NATURAL_COMPARATOR;\n-        }\n-        return new NullComparator(comparator, true);\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new NullComparator<E>(comparator, true);\n     }\n \n     /**\n      * @return  a comparator that transforms its input objects before comparing them\n      * @see  TransformingComparator\n      */\n-    public static Comparator transformedComparator(Comparator comparator, Transformer transformer) {\n-        if (comparator == null) {\n-            comparator = NATURAL_COMPARATOR;\n-        }\n-        return new TransformingComparator(transformer, comparator);\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> transformedComparator(Comparator<E> comparator, Transformer<? super E, ? extends E> transformer) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new TransformingComparator<E>(transformer, comparator);\n     }\n \n     /**\n      *  @param comparator  the sort order to use\n      *  @return  the smaller of the two objects\n      */\n-    public static Object min(Object o1, Object o2, Comparator comparator) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E min(E o1, E o2, Comparator<E> comparator) {\n         if (comparator == null) {\n             comparator = NATURAL_COMPARATOR;\n         }\n      *  @param comparator  the sort order to use\n      *  @return  the larger of the two objects\n      */\n-    public static Object max(Object o1, Object o2, Comparator comparator) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E max(E o1, E o2, Comparator<E> comparator) {\n         if (comparator == null) {\n             comparator = NATURAL_COMPARATOR;\n         }\n--- a/src/java/org/apache/commons/collections/EnumerationUtils.java\n+++ b/src/java/org/apache/commons/collections/EnumerationUtils.java\n  */\n package org.apache.commons.collections;\n \n+import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.List;\n+import java.util.StringTokenizer;\n \n import org.apache.commons.collections.iterators.EnumerationIterator;\n \n      * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n      * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n      */\n-    public static List toList(Enumeration enumeration) {\n-        return IteratorUtils.toList(new EnumerationIterator(enumeration));\n+    public static <E> List<E> toList(Enumeration<E> enumeration) {\n+        return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n     }\n \n+    /**\n+     * Override toList(Enumeration) for StringTokenizer as it implements Enumeration<String>\n+     * for the sake of backward compatibility.\n+     * @param stringTokenizer\n+     * @return List<String>\n+     */\n+    public static List<String> toList(StringTokenizer stringTokenizer) {\n+        List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n+        while (stringTokenizer.hasMoreTokens()) {\n+            result.add(stringTokenizer.nextToken());\n+        }\n+        return result;\n+    }\n }\n--- a/src/java/org/apache/commons/collections/Factory.java\n+++ b/src/java/org/apache/commons/collections/Factory.java\n  * {@link FactoryUtils}. These include factories that return a constant,\n  * a copy of a prototype or a new instance.\n  *\n+ * @param <T> the type that the factory creates\n+ *\n  * @since Commons Collections 2.1\n  * @version $Revision$ $Date$\n  *\n  * @author Arron Bates\n  * @author Stephen Colebourne\n  */\n-public interface Factory {\n+public interface Factory<T> {\n \n     /**\n      * Create a new object.\n      * @return a new object\n      * @throws FunctorException (runtime) if the factory cannot create an object\n      */\n-    public Object create();\n+    public T create();\n \n }\n--- a/src/java/org/apache/commons/collections/FunctorException.java\n+++ b/src/java/org/apache/commons/collections/FunctorException.java\n  */\n public class FunctorException extends RuntimeException {\n     \n+    /** Serialization version */\n+    private static final long serialVersionUID = 9139387246344345475L;\n+\n     /**\n      * Does JDK support nested exceptions\n      */\n     private static final boolean JDK_SUPPORTS_NESTED;\n-    \n+\n     static {\n         boolean flag = false;\n         try {\n         }\n         JDK_SUPPORTS_NESTED = flag;\n     }\n-    \n+\n     /**\n      * Root cause of the exception\n      */\n--- a/src/java/org/apache/commons/collections/Predicate.java\n+++ b/src/java/org/apache/commons/collections/Predicate.java\n  * {@link PredicateUtils}. These include true, false, instanceof, equals, and,\n  * or, not, method invokation and null testing.\n  *\n+ * @param <T> the type that the predicate queries\n+ *\n  * @since Commons Collections 1.0\n  * @version $Revision$ $Date$\n  *\n  * @author James Strachan\n  * @author Stephen Colebourne\n  */\n-public interface Predicate {\n+public interface Predicate<T> {\n \n     /**\n      * Use the specified parameter to perform a test that returns true or false.\n      * @throws IllegalArgumentException (runtime) if the input is invalid\n      * @throws FunctorException (runtime) if the predicate encounters a problem\n      */\n-    public boolean evaluate(Object object);\n+    public boolean evaluate(T object);\n \n }\n--- a/src/java/org/apache/commons/collections/Transformer.java\n+++ b/src/java/org/apache/commons/collections/Transformer.java\n  * {@link TransformerUtils}. These include method invokation, returning a constant,\n  * cloning and returning the string value.\n  *\n+ * @param <I> the input type to the transformer\n+ * @param <O> the output type from the transformer\n+ *\n  * @since Commons Collections 1.0\n  * @version $Revision$ $Date$\n  *\n  * @author James Strachan\n  * @author Stephen Colebourne\n  */\n-public interface Transformer {\n+public interface Transformer<I, O> {\n \n     /**\n      * Transforms the input object (leaving it unchanged) into some output object.\n      * @throws IllegalArgumentException (runtime) if the input is invalid\n      * @throws FunctorException (runtime) if the transform cannot be completed\n      */\n-    public Object transform(Object input);\n+    public O transform(I input);\n \n }\n--- a/src/java/org/apache/commons/collections/bag/AbstractMapBag.java\n+++ b/src/java/org/apache/commons/collections/bag/AbstractMapBag.java\n  * Abstract implementation of the {@link Bag} interface to simplify the creation\n  * of subclass implementations.\n  * <p>\n- * Subclasses specify a Map implementation to use as the internal storage.\n- * The map will be used to map bag elements to a number; the number represents\n- * the number of occurrences of that element in the bag.\n+ * Subclasses specify a Map implementation to use as the internal storage. The\n+ * map will be used to map bag elements to a number; the number represents the\n+ * number of occurrences of that element in the bag.\n  *\n  * @since Commons Collections 3.0 (previously DefaultMapBag v2.0)\n  * @version $Revision$ $Date$\n  * @author Janek Bogucki\n  * @author Steve Clark\n  */\n-public abstract class AbstractMapBag implements Bag {\n-    \n+public abstract class AbstractMapBag<E> implements Bag<E> {\n+\n     /** The map to use to store the data */\n-    private transient Map map;\n+    private transient Map<E, MutableInteger> map;\n     /** The current total size of the bag */\n     private int size;\n     /** The modification count for fail fast iterators */\n     private transient int modCount;\n     /** The modification count for fail fast iterators */\n-    private transient Set uniqueSet;\n+    private transient Set<E> uniqueSet;\n \n     /**\n      * Constructor needed for subclass serialisation.\n     }\n \n     /**\n-     * Constructor that assigns the specified Map as the backing store.\n-     * The map must be empty and non-null.\n-     * \n-     * @param map  the map to assign\n-     */\n-    protected AbstractMapBag(Map map) {\n+     * Constructor that assigns the specified Map as the backing store. The map\n+     * must be empty and non-null.\n+     * \n+     * @param map the map to assign\n+     */\n+    protected AbstractMapBag(Map<E, MutableInteger> map) {\n         super();\n         this.map = map;\n     }\n \n     /**\n-     * Utility method for implementations to access the map that backs\n-     * this bag. Not intended for interactive use outside of subclasses.\n+     * Utility method for implementations to access the map that backs this bag.\n+     * Not intended for interactive use outside of subclasses.\n      * \n      * @return the map being used by the Bag\n      */\n-    protected Map getMap() {\n+    protected Map<E, MutableInteger> getMap() {\n         return map;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Returns the number of elements in this bag.\n-     *\n+     * \n      * @return current size of the bag\n      */\n     public int size() {\n \n     /**\n      * Returns true if the underlying map is empty.\n-     *\n+     * \n      * @return true if bag is empty\n      */\n     public boolean isEmpty() {\n     }\n \n     /**\n-     * Returns the number of occurrence of the given element in this bag\n-     * by looking up its count in the underlying map.\n-     *\n-     * @param object  the object to search for\n+     * Returns the number of occurrence of the given element in this bag by\n+     * looking up its count in the underlying map.\n+     * \n+     * @param object the object to search for\n      * @return the number of occurrences of the object, zero if not found\n      */\n     public int getCount(Object object) {\n-        MutableInteger count = (MutableInteger) map.get(object);\n+        MutableInteger count = map.get(object);\n         if (count != null) {\n             return count.value;\n         }\n     /**\n      * Determines if the bag contains the given element by checking if the\n      * underlying map contains the element as a key.\n-     *\n-     * @param object  the object to search for\n+     * \n+     * @param object the object to search for\n      * @return true if the bag contains the given element\n      */\n     public boolean contains(Object object) {\n     /**\n      * Determines if the bag contains the given elements.\n      * \n-     * @param coll  the collection to check against\n+     * @param coll the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n-    public boolean containsAll(Collection coll) {\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean containsAll(Collection<?> coll) {\n         if (coll instanceof Bag) {\n-            return containsAll((Bag) coll);\n-        }\n-        return containsAll(new HashBag(coll));\n-    }\n-\n-    /**\n-     * Returns <code>true</code> if the bag contains all elements in\n-     * the given collection, respecting cardinality.\n-     * \n-     * @param other  the bag to check against\n+            return containsAll((Bag<?>) coll);\n+        }\n+        return containsAll(new HashBag<Object>((Collection<Object>) coll));\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the bag contains all elements in the given\n+     * collection, respecting cardinality.\n+     * \n+     * @param other the bag to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n-    boolean containsAll(Bag other) {\n+    boolean containsAll(Bag<?> other) {\n         boolean result = true;\n-        Iterator it = other.uniqueSet().iterator();\n+        Iterator<?> it = other.uniqueSet().iterator();\n         while (it.hasNext()) {\n             Object current = it.next();\n             boolean contains = getCount(current) >= other.getCount(current);\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets an iterator over the bag elements.\n-     * Elements present in the Bag more than once will be returned repeatedly.\n+     * Gets an iterator over the bag elements. Elements present in the Bag more\n+     * than once will be returned repeatedly.\n      * \n      * @return the iterator\n      */\n-    public Iterator iterator() {\n-        return new BagIterator(this);\n+    public Iterator<E> iterator() {\n+        return new BagIterator<E>(this);\n     }\n \n     /**\n      * Inner class iterator for the Bag.\n      */\n-    static class BagIterator implements Iterator {\n-        private AbstractMapBag parent;\n-        private Iterator entryIterator;\n-        private Map.Entry current;\n+    static class BagIterator<E> implements Iterator<E> {\n+        private AbstractMapBag<E> parent;\n+        private Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n+        private Map.Entry<E, MutableInteger> current;\n         private int itemCount;\n         private final int mods;\n         private boolean canRemove;\n         /**\n          * Constructor.\n          * \n-         * @param parent  the parent bag\n+         * @param parent the parent bag\n          */\n-        public BagIterator(AbstractMapBag parent) {\n+        public BagIterator(AbstractMapBag<E> parent) {\n             this.parent = parent;\n             this.entryIterator = parent.map.entrySet().iterator();\n             this.current = null;\n             return (itemCount > 0 || entryIterator.hasNext());\n         }\n \n-        public Object next() {\n+        public E next() {\n             if (parent.modCount != mods) {\n                 throw new ConcurrentModificationException();\n             }\n             if (itemCount == 0) {\n-                current = (Map.Entry) entryIterator.next();\n-                itemCount = ((MutableInteger) current.getValue()).value;\n+                current = (Map.Entry<E, MutableInteger>) entryIterator.next();\n+                itemCount = current.getValue().value;\n             }\n             canRemove = true;\n             itemCount--;\n             if (canRemove == false) {\n                 throw new IllegalStateException();\n             }\n-            MutableInteger mut = (MutableInteger) current.getValue();\n+            MutableInteger mut = current.getValue();\n             if (mut.value > 1) {\n                 mut.value--;\n             } else {\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Adds a new element to the bag, incrementing its count in the underlying map.\n-     *\n-     * @param object  the object to add\n-     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n-     */\n-    public boolean add(Object object) {\n+     * Adds a new element to the bag, incrementing its count in the underlying\n+     * map.\n+     * \n+     * @param object the object to add\n+     * @return <code>true</code> if the object was not already in the\n+     * <code>uniqueSet</code>\n+     */\n+    public boolean add(E object) {\n         return add(object, 1);\n     }\n \n     /**\n      * Adds a new element to the bag, incrementing its count in the map.\n-     *\n-     * @param object  the object to search for\n-     * @param nCopies  the number of copies to add\n-     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n-     */\n-    public boolean add(Object object, int nCopies) {\n+     * \n+     * @param object the object to search for\n+     * @param nCopies the number of copies to add\n+     * @return <code>true</code> if the object was not already in the\n+     * <code>uniqueSet</code>\n+     */\n+    public boolean add(E object, int nCopies) {\n         modCount++;\n         if (nCopies > 0) {\n-            MutableInteger mut = (MutableInteger) map.get(object);\n+            MutableInteger mut = map.get(object);\n             size += nCopies;\n             if (mut == null) {\n                 map.put(object, new MutableInteger(nCopies));\n                 return true;\n-            } else {\n-                mut.value += nCopies;\n-                return false;\n-            }\n-        } else {\n+            }\n+            mut.value += nCopies;\n             return false;\n         }\n+        return false;\n     }\n \n     /**\n      * Invokes {@link #add(Object)} for each element in the given collection.\n-     *\n-     * @param coll  the collection to add\n+     * \n+     * @param coll the collection to add\n      * @return <code>true</code> if this call changed the bag\n      */\n-    public boolean addAll(Collection coll) {\n+    public boolean addAll(Collection<? extends E> coll) {\n         boolean changed = false;\n-        Iterator i = coll.iterator();\n+        Iterator<? extends E> i = coll.iterator();\n         while (i.hasNext()) {\n             boolean added = add(i.next());\n             changed = changed || added;\n     /**\n      * Removes all copies of the specified object from the bag.\n      * \n-     * @param object  the object to remove\n+     * @param object the object to remove\n      * @return true if the bag changed\n      */\n     public boolean remove(Object object) {\n-        MutableInteger mut = (MutableInteger) map.get(object);\n+        MutableInteger mut = map.get(object);\n         if (mut == null) {\n             return false;\n         }\n     /**\n      * Removes a specified number of copies of an object from the bag.\n      * \n-     * @param object  the object to remove\n-     * @param nCopies  the number of copies to remove\n+     * @param object the object to remove\n+     * @param nCopies the number of copies to remove\n      * @return true if the bag changed\n      */\n     public boolean remove(Object object, int nCopies) {\n-        MutableInteger mut = (MutableInteger) map.get(object);\n+        MutableInteger mut = map.get(object);\n         if (mut == null) {\n             return false;\n         }\n     }\n \n     /**\n-     * Removes objects from the bag according to their count in the specified collection.\n-     * \n-     * @param coll  the collection to use\n+     * Removes objects from the bag according to their count in the specified\n+     * collection.\n+     * \n+     * @param coll the collection to use\n      * @return true if the bag changed\n      */\n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         boolean result = false;\n         if (coll != null) {\n-            Iterator i = coll.iterator();\n+            Iterator<?> i = coll.iterator();\n             while (i.hasNext()) {\n                 boolean changed = remove(i.next(), 1);\n                 result = result || changed;\n     }\n \n     /**\n-     * Remove any members of the bag that are not in the given\n-     * bag, respecting cardinality.\n-     *\n-     * @param coll  the collection to retain\n+     * Remove any members of the bag that are not in the given bag, respecting\n+     * cardinality.\n+     * \n+     * @param coll the collection to retain\n      * @return true if this call changed the collection\n      */\n-    public boolean retainAll(Collection coll) {\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean retainAll(Collection<?> coll) {\n         if (coll instanceof Bag) {\n-            return retainAll((Bag) coll);\n-        }\n-        return retainAll(new HashBag(coll));\n-    }\n-\n-    /**\n-     * Remove any members of the bag that are not in the given\n-     * bag, respecting cardinality.\n+            return retainAll((Bag<?>) coll);\n+        }\n+        return retainAll(new HashBag<Object>((Collection<Object>) coll));\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given bag, respecting\n+     * cardinality.\n      * @see #retainAll(Collection)\n      * \n-     * @param other  the bag to retain\n+     * @param other the bag to retain\n      * @return <code>true</code> if this call changed the collection\n      */\n-    boolean retainAll(Bag other) {\n+    boolean retainAll(Bag<?> other) {\n         boolean result = false;\n-        Bag excess = new HashBag();\n-        Iterator i = uniqueSet().iterator();\n+        Bag<E> excess = new HashBag<E>();\n+        Iterator<E> i = uniqueSet().iterator();\n         while (i.hasNext()) {\n-            Object current = i.next();\n+            E current = i.next();\n             int myCount = getCount(current);\n             int otherCount = other.getCount(current);\n             if (1 <= otherCount && otherCount <= myCount) {\n     protected static class MutableInteger {\n         /** The value of this mutable. */\n         protected int value;\n-        \n+\n         /**\n          * Constructor.\n-         * @param value  the initial value\n+         * @param value the initial value\n          */\n         MutableInteger(int value) {\n             this.value = value;\n         }\n-        \n+\n         public boolean equals(Object obj) {\n             if (obj instanceof MutableInteger == false) {\n                 return false;\n             return value;\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns an array of all of this bag's elements.\n-     *\n+     * \n      * @return an array of all of this bag's elements\n      */\n     public Object[] toArray() {\n         Object[] result = new Object[size()];\n         int i = 0;\n-        Iterator it = map.keySet().iterator();\n+        Iterator<E> it = map.keySet().iterator();\n         while (it.hasNext()) {\n-            Object current = it.next();\n+            E current = it.next();\n             for (int index = getCount(current); index > 0; index--) {\n                 result[i++] = current;\n             }\n \n     /**\n      * Returns an array of all of this bag's elements.\n-     *\n-     * @param array  the array to populate\n+     * \n+     * @param array the array to populate\n      * @return an array of all of this bag's elements\n      */\n-    public Object[] toArray(Object[] array) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n         int size = size();\n         if (array.length < size) {\n-            array = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n+            array = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n         }\n \n         int i = 0;\n-        Iterator it = map.keySet().iterator();\n+        Iterator<E> it = map.keySet().iterator();\n         while (it.hasNext()) {\n-            Object current = it.next();\n+            E current = it.next();\n             for (int index = getCount(current); index > 0; index--) {\n-                array[i++] = current;\n-            }\n-        }\n-        if (array.length > size) {\n-            array[size] = null;\n+                array[i++] = (T) current;\n+            }\n+        }\n+        while (i < array.length) {\n+            array[i++] = null;\n         }\n         return array;\n     }\n \n     /**\n      * Returns an unmodifiable view of the underlying map's key set.\n-     *\n+     * \n      * @return the set of unique elements in this bag\n      */\n-    public Set uniqueSet() {\n+    public Set<E> uniqueSet() {\n         if (uniqueSet == null) {\n-            uniqueSet = UnmodifiableSet.decorate(map.keySet());\n+            uniqueSet = UnmodifiableSet.<E> decorate(map.keySet());\n         }\n         return uniqueSet;\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * @param out  the output stream\n+     * @param out the output stream\n      * @throws IOException\n      */\n     protected void doWriteObject(ObjectOutputStream out) throws IOException {\n         out.writeInt(map.size());\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+        for (Iterator<Map.Entry<E, MutableInteger>> it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry<E, MutableInteger> entry = it.next();\n             out.writeObject(entry.getKey());\n-            out.writeInt(((MutableInteger) entry.getValue()).value);\n+            out.writeInt(entry.getValue().value);\n         }\n     }\n \n     /**\n      * Read the map in using a custom routine.\n-     * @param map  the map to use\n-     * @param in  the input stream\n+     * @param map the map to use\n+     * @param in the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      */\n-    protected void doReadObject(Map map, ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(Map map, ObjectInputStream in) throws IOException,\n+            ClassNotFoundException {\n         this.map = map;\n         int entrySize = in.readInt();\n         for (int i = 0; i < entrySize; i++) {\n             size += count;\n         }\n     }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compares this Bag to another.\n-     * This Bag equals another Bag if it contains the same number of occurrences of\n-     * the same elements.\n-     * \n-     * @param object  the Bag to compare to\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this Bag to another. This Bag equals another Bag if it contains\n+     * the same number of occurrences of the same elements.\n+     * \n+     * @param object the Bag to compare to\n      * @return true if equal\n      */\n     public boolean equals(Object object) {\n         if (object instanceof Bag == false) {\n             return false;\n         }\n-        Bag other = (Bag) object;\n+        Bag<?> other = (Bag<?>) object;\n         if (other.size() != size()) {\n             return false;\n         }\n-        for (Iterator it = map.keySet().iterator(); it.hasNext();) {\n-            Object element = it.next();\n+        for (Iterator<E> it = map.keySet().iterator(); it.hasNext();) {\n+            E element = it.next();\n             if (other.getCount(element) != getCount(element)) {\n                 return false;\n             }\n \n     /**\n      * Gets a hash code for the Bag compatible with the definition of equals.\n-     * The hash code is defined as the sum total of a hash code for each element.\n-     * The per element hash code is defined as\n-     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>.\n-     * This hash code is compatible with the Set interface.\n+     * The hash code is defined as the sum total of a hash code for each\n+     * element. The per element hash code is defined as\n+     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>. This hash code\n+     * is compatible with the Set interface.\n      * \n      * @return the hash code of the Bag\n      */\n     public int hashCode() {\n         int total = 0;\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            Object element = entry.getKey();\n-            MutableInteger count = (MutableInteger) entry.getValue();\n+        for (Iterator<Map.Entry<E, MutableInteger>> it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry<E, MutableInteger> entry = it.next();\n+            E element = entry.getKey();\n+            MutableInteger count = entry.getValue();\n             total += (element == null ? 0 : element.hashCode()) ^ count.value;\n         }\n         return total;\n         }\n         StringBuffer buf = new StringBuffer();\n         buf.append('[');\n-        Iterator it = uniqueSet().iterator();\n+        Iterator<E> it = uniqueSet().iterator();\n         while (it.hasNext()) {\n             Object current = it.next();\n             int count = getCount(current);\n         buf.append(']');\n         return buf.toString();\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/bag/HashBag.java\n+++ b/src/java/org/apache/commons/collections/bag/HashBag.java\n  * @author Chuck Burdick\n  * @author Stephen Colebourne\n  */\n-public class HashBag\n-        extends AbstractMapBag implements Bag, Serializable {\n+public class HashBag<E>\n+        extends AbstractMapBag<E> implements Bag<E>, Serializable {\n \n     /** Serial version lock */\n     private static final long serialVersionUID = -6561115435802554013L;\n      * Constructs an empty <code>HashBag</code>.\n      */\n     public HashBag() {\n-        super(new HashMap());\n+        super(new HashMap<E, MutableInteger>());\n     }\n \n     /**\n      * \n      * @param coll  a collection to copy into this bag\n      */\n-    public HashBag(Collection coll) {\n+    public HashBag(Collection<? extends E> coll) {\n         this();\n         addAll(coll);\n     }\n      */\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        super.doReadObject(new HashMap(), in);\n+        super.doReadObject(new HashMap<E, MutableInteger>(), in);\n     }\n     \n }\n--- a/src/java/org/apache/commons/collections/bag/TransformedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/TransformedBag.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedBag\n-        extends TransformedCollection implements Bag {\n+public class TransformedBag<E>\n+        extends TransformedCollection<E> implements Bag<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 5421170911299074185L;\n      * @return a new transformed Bag\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    public static Bag decorate(Bag bag, Transformer transformer) {\n-        return new TransformedBag(bag, transformer);\n+    public static <E> Bag<E> decorate(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedBag<E>(bag, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if bag or transformer is null\n      * @since Commons Collections 3.3\n      */\n+    // TODO: Generics\n     public static Bag decorateTransform(Bag bag, Transformer transformer) {\n         TransformedBag decorated = new TransformedBag(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             Object[] values = bag.toArray();\n             bag.clear();\n             for(int i=0; i<values.length; i++) {\n-                decorated.getCollection().add(transformer.transform(values[i]));\n+                decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n         return decorated;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    protected TransformedBag(Bag bag, Transformer transformer) {\n+    protected TransformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         super(bag, transformer);\n     }\n \n      * \n      * @return the decorated bag\n      */\n-    protected Bag getBag() {\n-        return (Bag) collection;\n+    protected Bag<E> getBag() {\n+        return (Bag<E>) collection;\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add(Object object, int nCopies) {\n-        object = transform(object);\n-        return getBag().add(object, nCopies);\n+    public boolean add(E object, int nCopies) {\n+        return getBag().add(transform(object), nCopies);\n     }\n \n-    public Set uniqueSet() {\n-        Set set = getBag().uniqueSet();\n-        return TransformedSet.decorate(set, transformer);\n+    public Set<E> uniqueSet() {\n+        Set<E> set = getBag().uniqueSet();\n+        return TransformedSet.<E>decorate(set, transformer);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedSortedBag\n-        extends TransformedBag implements SortedBag {\n+public class TransformedSortedBag<E>\n+        extends TransformedBag<E> implements SortedBag<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -251737742649401930L;\n      * @return a new transformed SortedBag\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    public static SortedBag decorate(SortedBag bag, Transformer transformer) {\n-        return new TransformedSortedBag(bag, transformer);\n+    public static <E> SortedBag<E> decorate(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSortedBag<E>(bag, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if bag or transformer is null\n      * @since Commons Collections 3.3\n      */\n+    // TODO: Generics\n     public static SortedBag decorateTransform(SortedBag bag, Transformer transformer) {\n         TransformedSortedBag decorated = new TransformedSortedBag(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             Object[] values = bag.toArray();\n             bag.clear();\n             for(int i=0; i<values.length; i++) {\n-                decorated.getCollection().add(transformer.transform(values[i]));\n+                decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n         return decorated;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    protected TransformedSortedBag(SortedBag bag, Transformer transformer) {\n+    protected TransformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         super(bag, transformer);\n     }\n \n      * \n      * @return the decorated bag\n      */\n-    protected SortedBag getSortedBag() {\n-        return (SortedBag) collection;\n+    protected SortedBag<E> getSortedBag() {\n+        return (SortedBag<E>) collection;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object first() {\n+    public E first() {\n         return getSortedBag().first();\n     }\n \n-    public Object last() {\n+    public E last() {\n         return getSortedBag().last();\n     }\n \n-    public Comparator comparator() {\n+    public Comparator<? super E> comparator() {\n         return getSortedBag().comparator();\n     }\n \n--- a/src/java/org/apache/commons/collections/bag/TreeBag.java\n+++ b/src/java/org/apache/commons/collections/bag/TreeBag.java\n  * Order will be maintained among the bag members and can be viewed through the\n  * iterator.\n  * <p>\n- * A <code>Bag</code> stores each object in the collection together with a\n- * count of occurrences. Extra methods on the interface allow multiple copies\n- * of an object to be added or removed at once. It is important to read the\n- * interface javadoc carefully as several methods violate the\n- * <code>Collection</code> interface specification.\n+ * A <code>Bag</code> stores each object in the collection together with a count\n+ * of occurrences. Extra methods on the interface allow multiple copies of an\n+ * object to be added or removed at once. It is important to read the interface\n+ * javadoc carefully as several methods violate the <code>Collection</code>\n+ * interface specification.\n  *\n  * @since Commons Collections 3.0 (previously in main package v2.0)\n  * @version $Revision$ $Date$\n  * @author Chuck Burdick\n  * @author Stephen Colebourne\n  */\n-public class TreeBag\n-        extends AbstractMapBag implements SortedBag, Serializable {\n+public class TreeBag<E> extends AbstractMapBag<E> implements SortedBag<E>, Serializable {\n \n     /** Serial version lock */\n     private static final long serialVersionUID = -7740146511091606676L;\n-    \n+\n     /**\n      * Constructs an empty <code>TreeBag</code>.\n      */\n     public TreeBag() {\n-        super(new TreeMap());\n+        super(new TreeMap<E, MutableInteger>());\n     }\n \n     /**\n-     * Constructs an empty bag that maintains order on its unique\n-     * representative members according to the given {@link Comparator}.\n+     * Constructs an empty bag that maintains order on its unique representative\n+     * members according to the given {@link Comparator}.\n      * \n-     * @param comparator  the comparator to use\n+     * @param comparator the comparator to use\n      */\n-    public TreeBag(Comparator comparator) {\n-        super(new TreeMap(comparator));\n+    public TreeBag(Comparator<? super E> comparator) {\n+        super(new TreeMap<E, MutableInteger>(comparator));\n     }\n \n     /**\n      * Constructs a <code>TreeBag</code> containing all the members of the\n      * specified collection.\n      * \n-     * @param coll  the collection to copy into the bag\n+     * @param coll the collection to copy into the bag\n      */\n-    public TreeBag(Collection coll) {\n+    public TreeBag(Collection<? extends E> coll) {\n         this();\n         addAll(coll);\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add(Object o) {\n-        if(comparator() == null && !(o instanceof Comparable)) {\n-            throw new IllegalArgumentException(\"Objects of type \" + o.getClass() + \" cannot be added to \" + \n+    // TODO: Generics - should this be E<? extends Comparable> or some such?\n+    public boolean add(E object) {\n+        if(comparator() == null && !(object instanceof Comparable)) {\n+            throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" + \n                                                \"a naturally ordered TreeBag as it does not implement Comparable\");\n         }\n-        return super.add(o);\n+        return super.add(object);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object first() {\n-        return ((SortedMap) getMap()).firstKey();\n+    public E first() {\n+        return getMap().firstKey();\n     }\n \n-    public Object last() {\n-        return ((SortedMap) getMap()).lastKey();\n+    public E last() {\n+        return getMap().lastKey();\n     }\n \n-    public Comparator comparator() {\n-        return ((SortedMap) getMap()).comparator();\n+    public Comparator<? super E> comparator() {\n+        return getMap().comparator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected SortedMap<E, org.apache.commons.collections.bag.AbstractMapBag.MutableInteger> getMap() {\n+        return (SortedMap<E, org.apache.commons.collections.bag.AbstractMapBag.MutableInteger>) super\n+                .getMap();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Read the bag in using a custom routine.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         Comparator comp = (Comparator) in.readObject();\n         super.doReadObject(new TreeMap(comp), in);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public class DualHashBidiMap\n-        extends AbstractDualBidiMap implements Serializable {\n+public class DualHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n \n     /** Ensure serialization compatibility */\n     private static final long serialVersionUID = 721969328361808L;\n      * Creates an empty <code>HashBidiMap</code>.\n      */\n     public DualHashBidiMap() {\n-        super(new HashMap(), new HashMap());\n+        super(new HashMap<K, V>(), new HashMap<V, K>());\n     }\n \n     /** \n      *\n      * @param map  the map whose mappings are to be placed in this map\n      */\n-    public DualHashBidiMap(Map map) {\n-        super(new HashMap(), new HashMap());\n+    public DualHashBidiMap(Map<K, V> map) {\n+        super(new HashMap<K, V>(), new HashMap<V, K>());\n         putAll(map);\n     }\n     \n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected DualHashBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+    protected DualHashBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n         super(normalMap, reverseMap, inverseBidiMap);\n     }\n \n      * @param inverseBidiMap  the inverse BidiMap\n      * @return new bidi map\n      */\n-    protected BidiMap createBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n-        return new DualHashBidiMap(normalMap, reverseMap, inverseBidiMap);\n+    protected BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseBidiMap) {\n+        return new DualHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n     }\n \n     // Serialization\n     //-----------------------------------------------------------------------\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n-        out.writeObject(maps[0]);\n+        out.writeObject(normalMap);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        maps[0] = new HashMap();\n-        maps[1] = new HashMap();\n+        normalMap = new HashMap();\n+        reverseMap = new HashMap();\n         Map map = (Map) in.readObject();\n         putAll(map);\n     }\n--- a/src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n  */\n package org.apache.commons.collections.bidimap;\n \n-import java.io.Serializable;\n-\n import java.util.AbstractSet;\n import java.util.Collection;\n import java.util.ConcurrentModificationException;\n import java.util.NoSuchElementException;\n import java.util.Set;\n \n-import org.apache.commons.collections.BidiMap;\n import org.apache.commons.collections.KeyValue;\n import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedBidiMap;\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n import org.apache.commons.collections.keyvalue.UnmodifiableMapEntry;\n+import static org.apache.commons.collections.bidimap.TreeBidiMap.DataElement.*;\n \n /**\n  * Red-Black tree-based implementation of BidiMap where all objects added\n  *\n  * @author Marc Johnson\n  * @author Stephen Colebourne\n+ * @author Matt Benson\n  */\n-public class TreeBidiMap implements OrderedBidiMap, Serializable {\n-\n-    private static final int KEY = 0;\n-    private static final int VALUE = 1;\n-    private static final int MAPENTRY = 2;\n-    private static final int INVERSEMAPENTRY = 3;\n-    private static final int SUM_OF_INDICES = KEY + VALUE;\n-    private static final int FIRST_INDEX = 0;\n-    private static final int NUMBER_OF_INDICES = 2;\n-    private static final String[] dataName = new String[] { \"key\", \"value\" };\n-    \n-    private Node[] rootNode = new Node[2];\n+public class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> implements OrderedBidiMap<K, V> {\n+\n+    static enum DataElement {\n+        KEY(\"key\"), VALUE(\"value\");\n+\n+        private final String description;\n+\n+        /**\n+         * Create a new TreeBidiMap.DataElement.\n+         */\n+        private DataElement(String description) {\n+            this.description = description;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return description;\n+        }\n+    }\n+\n+    private Node<K, V>[] rootNode;\n     private int nodeCount = 0;\n     private int modifications = 0;\n-\n-    private transient Set keySet;\n-    private transient Set valuesSet;\n-    private transient Set entrySet;\n-    private transient TreeBidiMap.Inverse inverse = null;\n+    private Set<K> keySet;\n+    private Set<V> valuesSet;\n+    private Set<Map.Entry<K, V>> entrySet;\n+    private Inverse inverse = null;\n \n     //-----------------------------------------------------------------------\n     /**\n      * Constructs a new empty TreeBidiMap.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public TreeBidiMap() {\n         super();\n+        rootNode = new Node[2];\n     }\n \n     /**\n      *  not Comparable or are not mutually comparable\n      * @throws NullPointerException if any key or value in the map is null\n      */\n-    public TreeBidiMap(final Map map) {\n-        super();\n+    public TreeBidiMap(final Map<K, V> map) {\n+        this();\n         putAll(map);\n     }\n \n      */\n     public boolean containsKey(final Object key) {\n         checkKey(key);\n-        return (lookup((Comparable) key, KEY) != null);\n-    }\n-\n-    /**\n-     * Checks whether this map contains a mapping for the specified value.\n+        return (lookupKey(key) != null);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified value.\n      * <p>\n      * The value must implement <code>Comparable</code>.\n      *\n      */\n     public boolean containsValue(final Object value) {\n         checkValue(value);\n-        return (lookup((Comparable) value, VALUE) != null);\n+        return (lookupValue(value) != null);\n     }\n \n     /**\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n-    public Object get(final Object key) {\n-        return doGet((Comparable) key, KEY);\n+    public V get(final Object key) {\n+        checkKey(key);\n+        Node<K, V> node = lookupKey(key);\n+        return node == null ? null : node.getValue();\n     }\n \n     /**\n      *  BidiMap map1 = new TreeBidiMap();\n      *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n      *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n-     * \n+     *\n      *  BidiMap map2 = new TreeBidiMap();\n      *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n      *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n-    public Object put(final Object key, final Object value) {\n-        return doPut((Comparable) key, (Comparable) value, KEY);\n+    public V put(final K key, final V value) {\n+        V result = get(key);\n+        doPut(key, value);\n+        return result;\n     }\n \n     /**\n      * Puts all the mappings from the specified map into this map.\n      * <p>\n      * All keys and values must implement <code>Comparable</code>.\n-     * \n+     *\n      * @param map  the map to copy from\n      */\n-    public void putAll(Map map) {\n-        Iterator it = map.entrySet().iterator();\n-        while (it.hasNext()) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            put(entry.getKey(), entry.getValue());\n-        }\n-    }\n-        \n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n+            put(e.getKey(), e.getValue());\n+        }\n+    }\n+\n     /**\n      * Removes the mapping for this key from this map if present.\n      * <p>\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n-    public Object remove(final Object key) {\n-        return doRemove((Comparable) key, KEY);\n+    public V remove(final Object key) {\n+        return doRemoveKey(key);\n     }\n \n     /**\n         modify();\n \n         nodeCount = 0;\n-        rootNode[KEY] = null;\n-        rootNode[VALUE] = null;\n+        rootNode[KEY.ordinal()] = null;\n+        rootNode[VALUE.ordinal()] = null;\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ClassCastException if the value is of an inappropriate type\n      * @throws NullPointerException if the value is null\n      */\n-    public Object getKey(final Object value) {\n-        return doGet((Comparable) value, VALUE);\n+    public K getKey(final Object value) {\n+        checkValue(value);\n+        Node<K, V> node = lookupValue(value);\n+        return node == null ? null : node.getKey();\n     }\n \n     /**\n      * @throws ClassCastException if the value is of an inappropriate type\n      * @throws NullPointerException if the value is null\n      */\n-    public Object removeValue(final Object value) {\n-        return doRemove((Comparable) value, VALUE);\n+    public K removeValue(final Object value) {\n+        return doRemoveValue(value);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the first (lowest) key currently in this sorted map\n      * @throws NoSuchElementException if this map is empty\n      */\n-    public Object firstKey() {\n+    public K firstKey() {\n         if (nodeCount == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n         }\n-        return leastNode(rootNode[KEY], KEY).getKey();\n+        return leastNode(rootNode[KEY.ordinal()], KEY).getKey();\n     }\n \n     /**\n      * @return the last (highest) key currently in this sorted map\n      * @throws NoSuchElementException if this map is empty\n      */\n-    public Object lastKey() {\n+    public K lastKey() {\n         if (nodeCount == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n         }\n-        return greatestNode(rootNode[KEY], KEY).getKey();\n-    }\n-    \n+        return greatestNode(rootNode[KEY.ordinal()], KEY).getKey();\n+    }\n+\n     /**\n      * Gets the next key after the one specified.\n      * <p>\n      * @param key the key to search for next from\n      * @return the next key, null if no match or at end\n      */\n-    public Object nextKey(Object key) {\n+    public K nextKey(K key) {\n         checkKey(key);\n-        Node node = nextGreater(lookup((Comparable) key, KEY), KEY);\n-        return (node == null ? null : node.getKey());\n+        Node<K, V> node = nextGreater(lookupKey(key), KEY);\n+        return node == null ? null : node.getKey();\n     }\n \n     /**\n      * @param key the key to search for previous from\n      * @return the previous key, null if no match or at start\n      */\n-    public Object previousKey(Object key) {\n+    public K previousKey(K key) {\n         checkKey(key);\n-        Node node = nextSmaller(lookup((Comparable) key, KEY), KEY);\n-        return (node == null ? null : node.getKey());\n-    }\n-    \n+        Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n+        return node == null ? null : node.getKey();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a set view of the keys contained in this map in key order.\n      *\n      * @return a set view of the keys contained in this map.\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         if (keySet == null) {\n-            keySet = new View(this, KEY, KEY);\n+            keySet = new KeyView(KEY);\n         }\n         return keySet;\n     }\n      *\n      * @return a set view of the values contained in this map.\n      */\n-    public Collection values() {\n+    public Collection<V> values() {\n         if (valuesSet == null) {\n-            valuesSet = new View(this, KEY, VALUE);\n+            valuesSet = new ValueView(KEY);\n         }\n         return valuesSet;\n     }\n      *\n      * @return a set view of the values contained in this map.\n      */\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         if (entrySet == null) {\n-            entrySet = new EntryView(this, KEY, MAPENTRY);\n+            return new EntryView();\n         }\n         return entrySet;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets an iterator over the map entries.\n-     * <p>\n-     * For this map, this iterator is the fastest way to iterate over the entries.\n-     * \n-     * @return an iterator\n-     */\n-    public MapIterator mapIterator() {\n+     * {@inheritDoc}\n+     */\n+    public OrderedMapIterator<K, V> mapIterator() {\n         if (isEmpty()) {\n-            return EmptyOrderedMapIterator.INSTANCE;\n-        }\n-        return new ViewMapIterator(this, KEY);\n-    }\n-\n-    /**\n-     * Gets an ordered iterator over the map entries.\n-     * <p>\n-     * This iterator allows both forward and reverse iteration over the entries.\n-     * \n-     * @return an iterator\n-     */\n-    public OrderedMapIterator orderedMapIterator() {\n-        if (isEmpty()) {\n-            return EmptyOrderedMapIterator.INSTANCE;\n-        }\n-        return new ViewMapIterator(this, KEY);\n+            return EmptyOrderedMapIterator.<K, V>getInstance();\n+        }\n+        return new ViewMapIterator(KEY);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Gets the inverse map for comparison.\n-     * \n+     *\n      * @return the inverse map\n      */\n-    public BidiMap inverseBidiMap() {\n-        return inverseOrderedBidiMap();\n-    }\n-\n-    /**\n-     * Gets the inverse map for comparison.\n-     * \n-     * @return the inverse map\n-     */\n-    public OrderedBidiMap inverseOrderedBidiMap() {\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n         if (inverse == null) {\n-            inverse = new Inverse(this);\n+            inverse = new Inverse();\n         }\n         return inverse;\n     }\n     public boolean equals(Object obj) {\n         return this.doEquals(obj, KEY);\n     }\n-    \n+\n     /**\n      * Gets the hash code value for this map as per the API.\n      *\n     public int hashCode() {\n         return this.doHashCode(KEY);\n     }\n-    \n+\n     /**\n      * Returns a string version of this Map in standard format.\n-     * \n+     *\n      * @return a standard format string version of the map\n      */\n     public String toString() {\n         return this.doToString(KEY);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n-     * Common get logic, used to get by key or get by value\n-     *\n-     * @param obj  the key or value that we're looking for\n-     * @param index  the KEY or VALUE int\n-     * @return the key (if the value was mapped) or the value (if the\n-     *         key was mapped); null if we couldn't find the specified\n-     *         object\n-     */\n-    private Object doGet(final Comparable obj, final int index) {\n-        checkNonNullComparable(obj, index);\n-        Node node = lookup(obj, index);\n-        return ((node == null) ? null : node.getData(oppositeIndex(index)));\n-    }\n-\n-    /**\n-     * Common put logic, differing only in the return value.\n-     * \n+     * Put logic.\n+     *\n      * @param key  the key, always the main map key\n      * @param value  the value, always the main map value\n-     * @param index  the KEY or VALUE int, for the return value only\n-     * @return the previously mapped value\n-     */\n-    private Object doPut(final Comparable key, final Comparable value, final int index) {\n+     */\n+    private void doPut(final K key, final V value) {\n         checkKeyAndValue(key, value);\n-        \n+\n         // store previous and remove previous mappings\n-        Object prev = (index == KEY ? doGet(key, KEY) :  doGet(value, VALUE));\n-        doRemove(key, KEY);\n-        doRemove(value, VALUE);\n-        \n-        Node node = rootNode[KEY];\n+        doRemoveKey(key);\n+        doRemoveValue(value);\n+\n+        Node<K, V> node = rootNode[KEY.ordinal()];\n         if (node == null) {\n             // map is empty\n-            Node root = new Node(key, value);\n-            rootNode[KEY] = root;\n-            rootNode[VALUE] = root;\n+            Node<K, V> root = new Node<K, V>(key, value);\n+            rootNode[KEY.ordinal()] = root;\n+            rootNode[VALUE.ordinal()] = root;\n             grow();\n-            \n+\n         } else {\n             // add new mapping\n             while (true) {\n-                int cmp = compare(key, node.getData(KEY));\n-        \n+                int cmp = compare(key, node.getKey());\n+\n                 if (cmp == 0) {\n                     // shouldn't happen\n                     throw new IllegalArgumentException(\"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\");\n                     if (node.getLeft(KEY) != null) {\n                         node = node.getLeft(KEY);\n                     } else {\n-                        Node newNode = new Node(key, value);\n-        \n+                        Node<K, V> newNode = new Node<K, V>(key, value);\n+\n                         insertValue(newNode);\n                         node.setLeft(newNode, KEY);\n                         newNode.setParent(node, KEY);\n                         doRedBlackInsert(newNode, KEY);\n                         grow();\n-        \n+\n                         break;\n                     }\n                 } else { // cmp > 0\n                     if (node.getRight(KEY) != null) {\n                         node = node.getRight(KEY);\n                     } else {\n-                        Node newNode = new Node(key, value);\n-        \n+                        Node<K, V> newNode = new Node<K, V>(key, value);\n+\n                         insertValue(newNode);\n                         node.setRight(newNode, KEY);\n                         newNode.setParent(node, KEY);\n                         doRedBlackInsert(newNode, KEY);\n                         grow();\n-        \n+\n                         break;\n                     }\n                 }\n             }\n         }\n-        return prev;\n-    }\n-\n-    /**\n-     * Remove by object (remove by key or remove by value)\n-     *\n-     * @param o the key, or value, that we're looking for\n-     * @param index  the KEY or VALUE int\n-     *\n-     * @return the key, if remove by value, or the value, if remove by\n-     *         key. null if the specified key or value could not be\n-     *         found\n-     */\n-    private Object doRemove(final Comparable o, final int index) {\n-        Node node = lookup(o, index);\n-        Object rval = null;\n-        if (node != null) {\n-            rval = node.getData(oppositeIndex(index));\n-            doRedBlackDelete(node);\n-        }\n-        return rval;\n+    }\n+\n+    private V doRemoveKey(Object key) {\n+        Node<K, V> node = lookupKey(key);\n+        if (node == null) {\n+            return null;\n+        }\n+        doRedBlackDelete(node);\n+        return node.getValue();\n+    }\n+\n+    private K doRemoveValue(Object value) {\n+        Node<K, V> node = lookupValue(value);\n+        if (node == null) {\n+            return null;\n+        }\n+        doRedBlackDelete(node);\n+        return node.getKey();\n     }\n \n     /**\n      * @return the desired Node, or null if there is no mapping of the\n      *         specified data\n      */\n-    private Node lookup(final Comparable data, final int index) {\n-        Node rval = null;\n-        Node node = rootNode[index];\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends Comparable<T>> Node<K, V> lookup(final Object data, final DataElement dataElement) {\n+        Node<K, V> rval = null;\n+        Node<K, V> node = rootNode[dataElement.ordinal()];\n \n         while (node != null) {\n-            int cmp = compare(data, node.getData(index));\n+            int cmp = compare((T) data, (T) node.getData(dataElement));\n             if (cmp == 0) {\n                 rval = node;\n                 break;\n             } else {\n-                node = (cmp < 0) ? node.getLeft(index) : node.getRight(index);\n+                node = (cmp < 0) ? node.getLeft(dataElement) : node.getRight(dataElement);\n             }\n         }\n \n         return rval;\n+    }\n+\n+    private Node<K, V> lookupKey(Object key) {\n+        return this.<K>lookup(key, KEY);\n+    }\n+\n+    private Node<K, V> lookupValue(Object value) {\n+        return this.<V>lookup(value, VALUE);\n     }\n \n     /**\n      * @param index  the KEY or VALUE int\n      * @return the specified node\n      */\n-    private Node nextGreater(final Node node, final int index) {\n-        Node rval = null;\n+    private Node<K, V> nextGreater(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = null;\n         if (node == null) {\n             rval = null;\n-        } else if (node.getRight(index) != null) {\n+        } else if (node.getRight(dataElement) != null) {\n             // everything to the node's right is larger. The least of\n             // the right node's descendants is the next larger node\n-            rval = leastNode(node.getRight(index), index);\n+            rval = leastNode(node.getRight(dataElement), dataElement);\n         } else {\n             // traverse up our ancestry until we find an ancestor that\n             // is null or one whose left child is our ancestor. If we\n             // tree, and there is no greater node. Otherwise, we are\n             // the largest node in the subtree on that ancestor's left\n             // ... and that ancestor is the next greatest node\n-            Node parent = node.getParent(index);\n-            Node child = node;\n-\n-            while ((parent != null) && (child == parent.getRight(index))) {\n+            Node<K, V> parent = node.getParent(dataElement);\n+            Node<K, V> child = node;\n+\n+            while ((parent != null) && (child == parent.getRight(dataElement))) {\n                 child = parent;\n-                parent = parent.getParent(index);\n+                parent = parent.getParent(dataElement);\n             }\n             rval = parent;\n         }\n      * @param index  the KEY or VALUE int\n      * @return the specified node\n      */\n-    private Node nextSmaller(final Node node, final int index) {\n-        Node rval = null;\n+    private Node<K, V> nextSmaller(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = null;\n         if (node == null) {\n             rval = null;\n-        } else if (node.getLeft(index) != null) {\n+        } else if (node.getLeft(dataElement) != null) {\n             // everything to the node's left is smaller. The greatest of\n             // the left node's descendants is the next smaller node\n-            rval = greatestNode(node.getLeft(index), index);\n+            rval = greatestNode(node.getLeft(dataElement), dataElement);\n         } else {\n             // traverse up our ancestry until we find an ancestor that\n             // is null or one whose right child is our ancestor. If we\n             // tree, and there is no greater node. Otherwise, we are\n             // the largest node in the subtree on that ancestor's right\n             // ... and that ancestor is the next greatest node\n-            Node parent = node.getParent(index);\n-            Node child = node;\n-\n-            while ((parent != null) && (child == parent.getLeft(index))) {\n+            Node<K, V> parent = node.getParent(dataElement);\n+            Node<K, V> child = node;\n+\n+            while ((parent != null) && (child == parent.getLeft(dataElement))) {\n                 child = parent;\n-                parent = parent.getParent(index);\n+                parent = parent.getParent(dataElement);\n             }\n             rval = parent;\n         }\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Get the opposite index of the specified index\n-     *\n-     * @param index  the KEY or VALUE int\n-     * @return VALUE (if KEY was specified), else KEY\n-     */\n-    private static int oppositeIndex(final int index) {\n-        // old trick ... to find the opposite of a value, m or n,\n-        // subtract the value from the sum of the two possible\n-        // values. (m + n) - m = n; (m + n) - n = m\n-        return SUM_OF_INDICES - index;\n-    }\n \n     /**\n      * Compare two objects\n      * @return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n      *         value if o1 &gt; o2\n      */\n-    private static int compare(final Comparable o1, final Comparable o2) {\n+    private static <T extends Comparable<T>> int compare(final T o1, final T o2) {\n         return o1.compareTo(o2);\n     }\n \n      * @return the smallest node, from the specified node, in the\n      *         specified mapping\n      */\n-    private static Node leastNode(final Node node, final int index) {\n-        Node rval = node;\n+    private Node<K, V> leastNode(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = node;\n         if (rval != null) {\n-            while (rval.getLeft(index) != null) {\n-                rval = rval.getLeft(index);\n+            while (rval.getLeft(dataElement) != null) {\n+                rval = rval.getLeft(dataElement);\n             }\n         }\n         return rval;\n      * @param index  the KEY or VALUE int\n      * @return the greatest node, from the specified node\n      */\n-    private static Node greatestNode(final Node node, final int index) {\n-        Node rval = node;\n+    private Node<K, V> greatestNode(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = node;\n         if (rval != null) {\n-            while (rval.getRight(index) != null) {\n-                rval = rval.getRight(index);\n+            while (rval.getRight(dataElement) != null) {\n+                rval = rval.getRight(dataElement);\n             }\n         }\n         return rval;\n      * @param to the node whose color we're changing; may be null\n      * @param index  the KEY or VALUE int\n      */\n-    private static void copyColor(final Node from, final Node to, final int index) {\n+    private void copyColor(final Node<K, V> from, final Node<K, V> to, final DataElement dataElement) {\n         if (to != null) {\n             if (from == null) {\n                 // by default, make it black\n-                to.setBlack(index);\n+                to.setBlack(dataElement);\n             } else {\n-                to.copyColor(from, index);\n+                to.copyColor(from, dataElement);\n             }\n         }\n     }\n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static boolean isRed(final Node node, final int index) {\n-        return ((node == null) ? false : node.isRed(index));\n+    private static boolean isRed(final Node<?, ?> node, final DataElement dataElement) {\n+        return node != null && node.isRed(dataElement);\n     }\n \n     /**\n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static boolean isBlack(final Node node, final int index) {\n-        return ((node == null) ? true : node.isBlack(index));\n+    private static boolean isBlack(final Node<?, ?> node, final DataElement dataElement) {\n+        return node == null || node.isBlack(dataElement);\n     }\n \n     /**\n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static void makeRed(final Node node, final int index) {\n+    private static void makeRed(final Node<?, ?> node, final DataElement dataElement) {\n         if (node != null) {\n-            node.setRed(index);\n+            node.setRed(dataElement);\n         }\n     }\n \n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static void makeBlack(final Node node, final int index) {\n+    private static void makeBlack(final Node<?, ?> node, final DataElement dataElement) {\n         if (node != null) {\n-            node.setBlack(index);\n+            node.setBlack(dataElement);\n         }\n     }\n \n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static Node getGrandParent(final Node node, final int index) {\n-        return getParent(getParent(node, index), index);\n+    private Node<K, V> getGrandParent(final Node<K, V> node, final DataElement dataElement) {\n+        return getParent(getParent(node, dataElement), dataElement);\n     }\n \n     /**\n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static Node getParent(final Node node, final int index) {\n-        return ((node == null) ? null : node.getParent(index));\n+    private Node<K, V> getParent(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getParent(dataElement);\n     }\n \n     /**\n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static Node getRightChild(final Node node, final int index) {\n-        return (node == null) ? null : node.getRight(index);\n+    private Node<K, V> getRightChild(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getRight(dataElement);\n     }\n \n     /**\n      * @param node the node (may be null) in question\n      * @param index  the KEY or VALUE int\n      */\n-    private static Node getLeftChild(final Node node, final int index) {\n-        return (node == null) ? null : node.getLeft(index);\n-    }\n-\n-    /**\n-     * is this node its parent's left child? mind you, the node, or\n-     * its parent, may not exist. no problem. if the node doesn't\n-     * exist ... it's its non-existent parent's left child. If the\n-     * node does exist but has no parent ... no, we're not the\n-     * non-existent parent's left child. Otherwise (both the specified\n-     * node AND its parent exist), check.\n-     *\n-     * @param node the node (may be null) in question\n-     * @param index  the KEY or VALUE int\n-     */\n-    private static boolean isLeftChild(final Node node, final int index) {\n-        return (node == null)\n-            ? true\n-            : ((node.getParent(index) == null) ?\n-                false : (node == node.getParent(index).getLeft(index)));\n-    }\n-\n-    /**\n-     * is this node its parent's right child? mind you, the node, or\n-     * its parent, may not exist. no problem. if the node doesn't\n-     * exist ... it's its non-existent parent's right child. If the\n-     * node does exist but has no parent ... no, we're not the\n-     * non-existent parent's right child. Otherwise (both the\n-     * specified node AND its parent exist), check.\n-     *\n-     * @param node the node (may be null) in question\n-     * @param index  the KEY or VALUE int\n-     */\n-    private static boolean isRightChild(final Node node, final int index) {\n-        return (node == null)\n-            ? true\n-            : ((node.getParent(index) == null) ? \n-                false : (node == node.getParent(index).getRight(index)));\n+    private Node<K, V> getLeftChild(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getLeft(dataElement);\n     }\n \n     /**\n      * @param node the node to be rotated\n      * @param index  the KEY or VALUE int\n      */\n-    private void rotateLeft(final Node node, final int index) {\n-        Node rightChild = node.getRight(index);\n-        node.setRight(rightChild.getLeft(index), index);\n-\n-        if (rightChild.getLeft(index) != null) {\n-            rightChild.getLeft(index).setParent(node, index);\n-        }\n-        rightChild.setParent(node.getParent(index), index);\n-        \n-        if (node.getParent(index) == null) {\n+    private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rightChild = node.getRight(dataElement);\n+        node.setRight(rightChild.getLeft(dataElement), dataElement);\n+\n+        if (rightChild.getLeft(dataElement) != null) {\n+            rightChild.getLeft(dataElement).setParent(node, dataElement);\n+        }\n+        rightChild.setParent(node.getParent(dataElement), dataElement);\n+\n+        if (node.getParent(dataElement) == null) {\n             // node was the root ... now its right child is the root\n-            rootNode[index] = rightChild;\n-        } else if (node.getParent(index).getLeft(index) == node) {\n-            node.getParent(index).setLeft(rightChild, index);\n+            rootNode[dataElement.ordinal()] = rightChild;\n+        } else if (node.getParent(dataElement).getLeft(dataElement) == node) {\n+            node.getParent(dataElement).setLeft(rightChild, dataElement);\n         } else {\n-            node.getParent(index).setRight(rightChild, index);\n-        }\n-\n-        rightChild.setLeft(node, index);\n-        node.setParent(rightChild, index);\n+            node.getParent(dataElement).setRight(rightChild, dataElement);\n+        }\n+\n+        rightChild.setLeft(node, dataElement);\n+        node.setParent(rightChild, dataElement);\n     }\n \n     /**\n      * @param node the node to be rotated\n      * @param index  the KEY or VALUE int\n      */\n-    private void rotateRight(final Node node, final int index) {\n-        Node leftChild = node.getLeft(index);\n-        node.setLeft(leftChild.getRight(index), index);\n-        if (leftChild.getRight(index) != null) {\n-            leftChild.getRight(index).setParent(node, index);\n-        }\n-        leftChild.setParent(node.getParent(index), index);\n-\n-        if (node.getParent(index) == null) {\n+    private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> leftChild = node.getLeft(dataElement);\n+        node.setLeft(leftChild.getRight(dataElement), dataElement);\n+        if (leftChild.getRight(dataElement) != null) {\n+            leftChild.getRight(dataElement).setParent(node, dataElement);\n+        }\n+        leftChild.setParent(node.getParent(dataElement), dataElement);\n+\n+        if (node.getParent(dataElement) == null) {\n             // node was the root ... now its left child is the root\n-            rootNode[index] = leftChild;\n-        } else if (node.getParent(index).getRight(index) == node) {\n-            node.getParent(index).setRight(leftChild, index);\n+            rootNode[dataElement.ordinal()] = leftChild;\n+        } else if (node.getParent(dataElement).getRight(dataElement) == node) {\n+            node.getParent(dataElement).setRight(leftChild, dataElement);\n         } else {\n-            node.getParent(index).setLeft(leftChild, index);\n-        }\n-\n-        leftChild.setRight(node, index);\n-        node.setParent(leftChild, index);\n+            node.getParent(dataElement).setLeft(leftChild, dataElement);\n+        }\n+\n+        leftChild.setRight(node, dataElement);\n+        node.setParent(leftChild, dataElement);\n     }\n \n     /**\n      * implementation, though it's barely recognizable any more\n      *\n      * @param insertedNode the node to be inserted\n-     * @param index  the KEY or VALUE int\n-     */\n-    private void doRedBlackInsert(final Node insertedNode, final int index) {\n-        Node currentNode = insertedNode;\n-        makeRed(currentNode, index);\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void doRedBlackInsert(final Node<K, V> insertedNode, final DataElement dataElement) {\n+        Node<K, V> currentNode = insertedNode;\n+        makeRed(currentNode, dataElement);\n \n         while ((currentNode != null)\n-            && (currentNode != rootNode[index])\n-            && (isRed(currentNode.getParent(index), index))) {\n-            if (isLeftChild(getParent(currentNode, index), index)) {\n-                Node y = getRightChild(getGrandParent(currentNode, index), index);\n-\n-                if (isRed(y, index)) {\n-                    makeBlack(getParent(currentNode, index), index);\n-                    makeBlack(y, index);\n-                    makeRed(getGrandParent(currentNode, index), index);\n-\n-                    currentNode = getGrandParent(currentNode, index);\n+            && (currentNode != rootNode[dataElement.ordinal()])\n+            && (isRed(currentNode.getParent(dataElement), dataElement))) {\n+            if (currentNode.isLeftChild(dataElement)) {\n+                Node<K, V> y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(y, dataElement)) {\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(y, dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = getGrandParent(currentNode, dataElement);\n                 } else {\n-                    if (isRightChild(currentNode, index)) {\n-                        currentNode = getParent(currentNode, index);\n-\n-                        rotateLeft(currentNode, index);\n+                    //dead code?\n+                    if (currentNode.isRightChild(dataElement)) {\n+                        currentNode = getParent(currentNode, dataElement);\n+\n+                        rotateLeft(currentNode, dataElement);\n                     }\n \n-                    makeBlack(getParent(currentNode, index), index);\n-                    makeRed(getGrandParent(currentNode, index), index);\n-\n-                    if (getGrandParent(currentNode, index) != null) {\n-                        rotateRight(getGrandParent(currentNode, index), index);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    if (getGrandParent(currentNode, dataElement) != null) {\n+                        rotateRight(getGrandParent(currentNode, dataElement), dataElement);\n                     }\n                 }\n             } else {\n \n                 // just like clause above, except swap left for right\n-                Node y = getLeftChild(getGrandParent(currentNode, index), index);\n-\n-                if (isRed(y, index)) {\n-                    makeBlack(getParent(currentNode, index), index);\n-                    makeBlack(y, index);\n-                    makeRed(getGrandParent(currentNode, index), index);\n-\n-                    currentNode = getGrandParent(currentNode, index);\n+                Node<K, V> y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(y, dataElement)) {\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(y, dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = getGrandParent(currentNode, dataElement);\n                 } else {\n-                    if (isLeftChild(currentNode, index)) {\n-                        currentNode = getParent(currentNode, index);\n-\n-                        rotateRight(currentNode, index);\n+                    //dead code?\n+                    if (currentNode.isLeftChild(dataElement)) {\n+                        currentNode = getParent(currentNode, dataElement);\n+\n+                        rotateRight(currentNode, dataElement);\n                     }\n \n-                    makeBlack(getParent(currentNode, index), index);\n-                    makeRed(getGrandParent(currentNode, index), index);\n-\n-                    if (getGrandParent(currentNode, index) != null) {\n-                        rotateLeft(getGrandParent(currentNode, index), index);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    if (getGrandParent(currentNode, dataElement) != null) {\n+                        rotateLeft(getGrandParent(currentNode, dataElement), dataElement);\n                     }\n                 }\n             }\n         }\n \n-        makeBlack(rootNode[index], index);\n+        makeBlack(rootNode[dataElement.ordinal()], dataElement);\n     }\n \n     /**\n      *\n      * @param deletedNode the node to be deleted\n      */\n-    private void doRedBlackDelete(final Node deletedNode) {\n-        for (int index = FIRST_INDEX; index < NUMBER_OF_INDICES; index++) {\n+    private void doRedBlackDelete(final Node<K, V> deletedNode) {\n+        for (DataElement dataElement : DataElement.values()) {\n             // if deleted node has both left and children, swap with\n             // the next greater node\n-            if ((deletedNode.getLeft(index) != null) && (deletedNode.getRight(index) != null)) {\n-                swapPosition(nextGreater(deletedNode, index), deletedNode, index);\n-            }\n-\n-            Node replacement =\n-                ((deletedNode.getLeft(index) != null) ? deletedNode.getLeft(index) : deletedNode.getRight(index));\n+            if ((deletedNode.getLeft(dataElement) != null) && (deletedNode.getRight(dataElement) != null)) {\n+                swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\n+            }\n+\n+            Node<K, V> replacement =\n+                ((deletedNode.getLeft(dataElement) != null) ? deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement));\n \n             if (replacement != null) {\n-                replacement.setParent(deletedNode.getParent(index), index);\n-\n-                if (deletedNode.getParent(index) == null) {\n-                    rootNode[index] = replacement;\n-                } else if (deletedNode == deletedNode.getParent(index).getLeft(index)) {\n-                    deletedNode.getParent(index).setLeft(replacement, index);\n+                replacement.setParent(deletedNode.getParent(dataElement), dataElement);\n+\n+                if (deletedNode.getParent(dataElement) == null) {\n+                    rootNode[dataElement.ordinal()] = replacement;\n+                } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n+                    deletedNode.getParent(dataElement).setLeft(replacement, dataElement);\n                 } else {\n-                    deletedNode.getParent(index).setRight(replacement, index);\n+                    deletedNode.getParent(dataElement).setRight(replacement, dataElement);\n                 }\n \n-                deletedNode.setLeft(null, index);\n-                deletedNode.setRight(null, index);\n-                deletedNode.setParent(null, index);\n-\n-                if (isBlack(deletedNode, index)) {\n-                    doRedBlackDeleteFixup(replacement, index);\n+                deletedNode.setLeft(null, dataElement);\n+                deletedNode.setRight(null, dataElement);\n+                deletedNode.setParent(null, dataElement);\n+\n+                if (isBlack(deletedNode, dataElement)) {\n+                    doRedBlackDeleteFixup(replacement, dataElement);\n                 }\n             } else {\n \n                 // replacement is null\n-                if (deletedNode.getParent(index) == null) {\n+                if (deletedNode.getParent(dataElement) == null) {\n \n                     // empty tree\n-                    rootNode[index] = null;\n+                    rootNode[dataElement.ordinal()] = null;\n                 } else {\n \n                     // deleted node had no children\n-                    if (isBlack(deletedNode, index)) {\n-                        doRedBlackDeleteFixup(deletedNode, index);\n+                    if (isBlack(deletedNode, dataElement)) {\n+                        doRedBlackDeleteFixup(deletedNode, dataElement);\n                     }\n \n-                    if (deletedNode.getParent(index) != null) {\n-                        if (deletedNode == deletedNode.getParent(index).getLeft(index)) {\n-                            deletedNode.getParent(index).setLeft(null, index);\n+                    if (deletedNode.getParent(dataElement) != null) {\n+                        if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n+                            deletedNode.getParent(dataElement).setLeft(null, dataElement);\n                         } else {\n-                            deletedNode.getParent(index).setRight(null, index);\n+                            deletedNode.getParent(dataElement).setRight(null, dataElement);\n                         }\n \n-                        deletedNode.setParent(null, index);\n+                        deletedNode.setParent(null, dataElement);\n                     }\n                 }\n             }\n      * perfectly balanced -- perfect balancing takes longer)\n      *\n      * @param replacementNode the node being replaced\n-     * @param index  the KEY or VALUE int\n-     */\n-    private void doRedBlackDeleteFixup(final Node replacementNode, final int index) {\n-        Node currentNode = replacementNode;\n-\n-        while ((currentNode != rootNode[index]) && (isBlack(currentNode, index))) {\n-            if (isLeftChild(currentNode, index)) {\n-                Node siblingNode = getRightChild(getParent(currentNode, index), index);\n-\n-                if (isRed(siblingNode, index)) {\n-                    makeBlack(siblingNode, index);\n-                    makeRed(getParent(currentNode, index), index);\n-                    rotateLeft(getParent(currentNode, index), index);\n-\n-                    siblingNode = getRightChild(getParent(currentNode, index), index);\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void doRedBlackDeleteFixup(final Node<K, V> replacementNode, final DataElement dataElement) {\n+        Node<K, V> currentNode = replacementNode;\n+\n+        while ((currentNode != rootNode[dataElement.ordinal()]) && (isBlack(currentNode, dataElement))) {\n+            if (currentNode.isLeftChild(dataElement)) {\n+                Node<K, V> siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(siblingNode, dataElement)) {\n+                    makeBlack(siblingNode, dataElement);\n+                    makeRed(getParent(currentNode, dataElement), dataElement);\n+                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n+\n+                    siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n                 }\n \n-                if (isBlack(getLeftChild(siblingNode, index), index)\n-                    && isBlack(getRightChild(siblingNode, index), index)) {\n-                    makeRed(siblingNode, index);\n-\n-                    currentNode = getParent(currentNode, index);\n+                if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)\n+                    && isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n+                    makeRed(siblingNode, dataElement);\n+\n+                    currentNode = getParent(currentNode, dataElement);\n                 } else {\n-                    if (isBlack(getRightChild(siblingNode, index), index)) {\n-                        makeBlack(getLeftChild(siblingNode, index), index);\n-                        makeRed(siblingNode, index);\n-                        rotateRight(siblingNode, index);\n-\n-                        siblingNode = getRightChild(getParent(currentNode, index), index);\n+                    if (isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n+                        makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n+                        makeRed(siblingNode, dataElement);\n+                        rotateRight(siblingNode, dataElement);\n+\n+                        siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n                     }\n \n-                    copyColor(getParent(currentNode, index), siblingNode, index);\n-                    makeBlack(getParent(currentNode, index), index);\n-                    makeBlack(getRightChild(siblingNode, index), index);\n-                    rotateLeft(getParent(currentNode, index), index);\n-\n-                    currentNode = rootNode[index];\n+                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n+                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = rootNode[dataElement.ordinal()];\n                 }\n             } else {\n-                Node siblingNode = getLeftChild(getParent(currentNode, index), index);\n-\n-                if (isRed(siblingNode, index)) {\n-                    makeBlack(siblingNode, index);\n-                    makeRed(getParent(currentNode, index), index);\n-                    rotateRight(getParent(currentNode, index), index);\n-\n-                    siblingNode = getLeftChild(getParent(currentNode, index), index);\n+                Node<K, V> siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(siblingNode, dataElement)) {\n+                    makeBlack(siblingNode, dataElement);\n+                    makeRed(getParent(currentNode, dataElement), dataElement);\n+                    rotateRight(getParent(currentNode, dataElement), dataElement);\n+\n+                    siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n                 }\n \n-                if (isBlack(getRightChild(siblingNode, index), index)\n-                    && isBlack(getLeftChild(siblingNode, index), index)) {\n-                    makeRed(siblingNode, index);\n-\n-                    currentNode = getParent(currentNode, index);\n+                if (isBlack(getRightChild(siblingNode, dataElement), dataElement)\n+                    && isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n+                    makeRed(siblingNode, dataElement);\n+\n+                    currentNode = getParent(currentNode, dataElement);\n                 } else {\n-                    if (isBlack(getLeftChild(siblingNode, index), index)) {\n-                        makeBlack(getRightChild(siblingNode, index), index);\n-                        makeRed(siblingNode, index);\n-                        rotateLeft(siblingNode, index);\n-\n-                        siblingNode = getLeftChild(getParent(currentNode, index), index);\n+                    if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n+                        makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n+                        makeRed(siblingNode, dataElement);\n+                        rotateLeft(siblingNode, dataElement);\n+\n+                        siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n                     }\n \n-                    copyColor(getParent(currentNode, index), siblingNode, index);\n-                    makeBlack(getParent(currentNode, index), index);\n-                    makeBlack(getLeftChild(siblingNode, index), index);\n-                    rotateRight(getParent(currentNode, index), index);\n-\n-                    currentNode = rootNode[index];\n+                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n+                    rotateRight(getParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = rootNode[dataElement.ordinal()];\n                 }\n             }\n         }\n \n-        makeBlack(currentNode, index);\n+        makeBlack(currentNode, dataElement);\n     }\n \n     /**\n      *\n      * @param x one node\n      * @param y another node\n-     * @param index  the KEY or VALUE int\n-     */\n-    private void swapPosition(final Node x, final Node y, final int index) {\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\n         // Save initial values.\n-        Node xFormerParent = x.getParent(index);\n-        Node xFormerLeftChild = x.getLeft(index);\n-        Node xFormerRightChild = x.getRight(index);\n-        Node yFormerParent = y.getParent(index);\n-        Node yFormerLeftChild = y.getLeft(index);\n-        Node yFormerRightChild = y.getRight(index);\n-        boolean xWasLeftChild = (x.getParent(index) != null) && (x == x.getParent(index).getLeft(index));\n-        boolean yWasLeftChild = (y.getParent(index) != null) && (y == y.getParent(index).getLeft(index));\n+        Node<K, V> xFormerParent = x.getParent(dataElement);\n+        Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\n+        Node<K, V> xFormerRightChild = x.getRight(dataElement);\n+        Node<K, V> yFormerParent = y.getParent(dataElement);\n+        Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\n+        Node<K, V> yFormerRightChild = y.getRight(dataElement);\n+        boolean xWasLeftChild = (x.getParent(dataElement) != null) && (x == x.getParent(dataElement).getLeft(dataElement));\n+        boolean yWasLeftChild = (y.getParent(dataElement) != null) && (y == y.getParent(dataElement).getLeft(dataElement));\n \n         // Swap, handling special cases of one being the other's parent.\n         if (x == yFormerParent) { // x was y's parent\n-            x.setParent(y, index);\n+            x.setParent(y, dataElement);\n \n             if (yWasLeftChild) {\n-                y.setLeft(x, index);\n-                y.setRight(xFormerRightChild, index);\n+                y.setLeft(x, dataElement);\n+                y.setRight(xFormerRightChild, dataElement);\n             } else {\n-                y.setRight(x, index);\n-                y.setLeft(xFormerLeftChild, index);\n+                y.setRight(x, dataElement);\n+                y.setLeft(xFormerLeftChild, dataElement);\n             }\n         } else {\n-            x.setParent(yFormerParent, index);\n+            x.setParent(yFormerParent, dataElement);\n \n             if (yFormerParent != null) {\n                 if (yWasLeftChild) {\n-                    yFormerParent.setLeft(x, index);\n+                    yFormerParent.setLeft(x, dataElement);\n                 } else {\n-                    yFormerParent.setRight(x, index);\n+                    yFormerParent.setRight(x, dataElement);\n                 }\n             }\n \n-            y.setLeft(xFormerLeftChild, index);\n-            y.setRight(xFormerRightChild, index);\n+            y.setLeft(xFormerLeftChild, dataElement);\n+            y.setRight(xFormerRightChild, dataElement);\n         }\n \n         if (y == xFormerParent) { // y was x's parent\n-            y.setParent(x, index);\n+            y.setParent(x, dataElement);\n \n             if (xWasLeftChild) {\n-                x.setLeft(y, index);\n-                x.setRight(yFormerRightChild, index);\n+                x.setLeft(y, dataElement);\n+                x.setRight(yFormerRightChild, dataElement);\n             } else {\n-                x.setRight(y, index);\n-                x.setLeft(yFormerLeftChild, index);\n+                x.setRight(y, dataElement);\n+                x.setLeft(yFormerLeftChild, dataElement);\n             }\n         } else {\n-            y.setParent(xFormerParent, index);\n+            y.setParent(xFormerParent, dataElement);\n \n             if (xFormerParent != null) {\n                 if (xWasLeftChild) {\n-                    xFormerParent.setLeft(y, index);\n+                    xFormerParent.setLeft(y, dataElement);\n                 } else {\n-                    xFormerParent.setRight(y, index);\n+                    xFormerParent.setRight(y, dataElement);\n                 }\n             }\n \n-            x.setLeft(yFormerLeftChild, index);\n-            x.setRight(yFormerRightChild, index);\n+            x.setLeft(yFormerLeftChild, dataElement);\n+            x.setRight(yFormerRightChild, dataElement);\n         }\n \n         // Fix children's parent pointers\n-        if (x.getLeft(index) != null) {\n-            x.getLeft(index).setParent(x, index);\n-        }\n-\n-        if (x.getRight(index) != null) {\n-            x.getRight(index).setParent(x, index);\n-        }\n-\n-        if (y.getLeft(index) != null) {\n-            y.getLeft(index).setParent(y, index);\n-        }\n-\n-        if (y.getRight(index) != null) {\n-            y.getRight(index).setParent(y, index);\n-        }\n-\n-        x.swapColors(y, index);\n+        if (x.getLeft(dataElement) != null) {\n+            x.getLeft(dataElement).setParent(x, dataElement);\n+        }\n+\n+        if (x.getRight(dataElement) != null) {\n+            x.getRight(dataElement).setParent(x, dataElement);\n+        }\n+\n+        if (y.getLeft(dataElement) != null) {\n+            y.getLeft(dataElement).setParent(y, dataElement);\n+        }\n+\n+        if (y.getRight(dataElement) != null) {\n+            y.getRight(dataElement).setParent(y, dataElement);\n+        }\n+\n+        x.swapColors(y, dataElement);\n \n         // Check if root changed\n-        if (rootNode[index] == x) {\n-            rootNode[index] = y;\n-        } else if (rootNode[index] == y) {\n-            rootNode[index] = x;\n+        if (rootNode[dataElement.ordinal()] == x) {\n+            rootNode[dataElement.ordinal()] = y;\n+        } else if (rootNode[dataElement.ordinal()] == y) {\n+            rootNode[dataElement.ordinal()] = x;\n         }\n     }\n \n      * @throws NullPointerException if o is null\n      * @throws ClassCastException if o is not Comparable\n      */\n-    private static void checkNonNullComparable(final Object o, final int index) {\n+    private static void checkNonNullComparable(final Object o, final DataElement dataElement) {\n         if (o == null) {\n-            throw new NullPointerException(dataName[index] + \" cannot be null\");\n+            throw new NullPointerException(dataElement + \" cannot be null\");\n         }\n         if (!(o instanceof Comparable)) {\n-            throw new ClassCastException(dataName[index] + \" must be Comparable\");\n+            throw new ClassCastException(dataElement + \" must be Comparable\");\n         }\n     }\n \n      * @throws IllegalArgumentException if the node already exists\n      *                                     in the value mapping\n      */\n-    private void insertValue(final Node newNode) throws IllegalArgumentException {\n-        Node node = rootNode[VALUE];\n+    private void insertValue(final Node<K, V> newNode) throws IllegalArgumentException {\n+        Node<K, V> node = rootNode[VALUE.ordinal()];\n \n         while (true) {\n-            int cmp = compare(newNode.getData(VALUE), node.getData(VALUE));\n+            int cmp = compare(newNode.getValue(), node.getValue());\n \n             if (cmp == 0) {\n                 throw new IllegalArgumentException(\n             }\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Compares for equals as per the API.\n      * @param type  the KEY or VALUE int\n      * @return true if equal\n      */\n-    private boolean doEquals(Object obj, final int type) {\n+    private boolean doEquals(Object obj, DataElement dataElement) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map == false) {\n             return false;\n         }\n-        Map other = (Map) obj;\n+        Map<?, ?> other = (Map<?, ?>) obj;\n         if (other.size() != size()) {\n             return false;\n         }\n \n         if (nodeCount > 0) {\n             try {\n-                for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {\n+                for (MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n                     Object key = it.next();\n                     Object value = it.getValue();\n                     if (value.equals(other.get(key)) == false) {\n      * @param type  the KEY or VALUE int\n      * @return the hash code value for this map\n      */\n-    private int doHashCode(final int type) {\n+    private int doHashCode(DataElement dataElement) {\n         int total = 0;\n         if (nodeCount > 0) {\n-            for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {\n+            for (MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n                 Object key = it.next();\n                 Object value = it.getValue();\n                 total += (key.hashCode() ^ value.hashCode());\n         }\n         return total;\n     }\n-    \n+\n     /**\n      * Gets the string form of this map as per AbstractMap.\n      *\n      * @param type  the KEY or VALUE int\n      * @return the string form of this map\n      */\n-    private String doToString(final int type) {\n+    private String doToString(DataElement dataElement) {\n         if (nodeCount == 0) {\n             return \"{}\";\n         }\n         StringBuffer buf = new StringBuffer(nodeCount * 32);\n         buf.append('{');\n-        MapIterator it = new ViewMapIterator(this, type);\n+        MapIterator<?, ?> it = getMapIterator(dataElement);\n         boolean hasNext = it.hasNext();\n         while (hasNext) {\n             Object key = it.next();\n         return buf.toString();\n     }\n \n+    private MapIterator<?, ?> getMapIterator(DataElement dataElement) {\n+        switch (dataElement) {\n+        case KEY:\n+            return new ViewMapIterator(KEY);\n+        case VALUE:\n+            return new InverseViewMapIterator(VALUE);\n+        default:\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * A view of this map.\n      */\n-    static class View extends AbstractSet {\n-        \n-        /** The parent map. */\n-        protected final TreeBidiMap main;\n+    abstract class View<E> extends AbstractSet<E> {\n+\n         /** Whether to return KEY or VALUE order. */\n-        protected final int orderType;\n-        /** Whether to return KEY, VALUE, MAPENTRY or INVERSEMAPENTRY data. */\n-        protected final int dataType;\n+        protected final DataElement orderType;\n \n         /**\n          * Constructor.\n-         *\n+         * @param orderType  the KEY or VALUE int for the order\n          * @param main  the main map\n-         * @param orderType  the KEY or VALUE int for the order\n-         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int\n-         */\n-        View(final TreeBidiMap main, final int orderType, final int dataType) {\n+         */\n+        View(final DataElement orderType) {\n             super();\n-            this.main = main;\n             this.orderType = orderType;\n-            this.dataType = dataType;\n-        }\n-        \n-        public Iterator iterator() {\n-            return new ViewIterator(main, orderType, dataType);\n         }\n \n         public int size() {\n-            return main.size();\n-        }\n-\n+            return TreeBidiMap.this.size();\n+        }\n+\n+        public void clear() {\n+            TreeBidiMap.this.clear();\n+        }\n+    }\n+\n+    class KeyView extends View<K> {\n+\n+        /**\n+         * Create a new TreeBidiMap.KeyView.\n+         */\n+        public KeyView(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new ViewMapIterator(orderType);\n+        }\n+\n+        @Override\n         public boolean contains(final Object obj) {\n-            checkNonNullComparable(obj, dataType);\n-            return (main.lookup((Comparable) obj, dataType) != null);\n-        }\n-\n-        public boolean remove(final Object obj) {\n-            return (main.doRemove((Comparable) obj, dataType) != null);\n-        }\n-\n-        public void clear() {\n-            main.clear();\n+            checkNonNullComparable(obj, KEY);\n+            return (lookupKey(obj) != null);\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            return doRemoveKey(o) != null;\n+        }\n+\n+    }\n+\n+    class ValueView extends View<V> {\n+\n+        /**\n+         * Create a new TreeBidiMap.ValueView.\n+         */\n+        public ValueView(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new InverseViewMapIterator(orderType);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, VALUE);\n+            return (lookupValue(obj) != null);\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            return doRemoveValue(o) != null;\n+        }\n+\n+    }\n+\n+    /**\n+     * A view of this map.\n+     */\n+    class EntryView extends View<Map.Entry<K, V>> {\n+\n+        EntryView() {\n+            super(KEY);\n+        }\n+\n+        public boolean contains(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupKey(entry.getKey());\n+            return node != null && node.getValue().equals(value);\n+        }\n+\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupKey(entry.getKey());\n+            if (node != null && node.getValue().equals(value)) {\n+                doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<java.util.Map.Entry<K, V>> iterator() {\n+            return new ViewMapEntryIterator();\n+        }\n+    }\n+\n+    /**\n+     * A view of this map.\n+     */\n+    class InverseEntryView extends View<Map.Entry<V, K>> {\n+\n+        InverseEntryView() {\n+            super(VALUE);\n+        }\n+\n+        public boolean contains(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupValue(entry.getKey());\n+            return node != null && node.getKey().equals(value);\n+        }\n+\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupValue(entry.getKey());\n+            if (node != null && node.getKey().equals(value)) {\n+                doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<java.util.Map.Entry<V, K>> iterator() {\n+            return new InverseViewMapEntryIterator();\n         }\n     }\n \n     /**\n      * An iterator over the map.\n      */\n-    static class ViewIterator implements OrderedIterator {\n-\n-        /** The parent map. */\n-        protected final TreeBidiMap main;\n+    abstract class ViewIterator {\n+\n         /** Whether to return KEY or VALUE order. */\n-        protected final int orderType;\n-        /** Whether to return KEY, VALUE, MAPENTRY or INVERSEMAPENTRY data. */\n-        protected final int dataType;\n+        protected final DataElement orderType;\n         /** The last node returned by the iterator. */\n-        protected Node lastReturnedNode;\n+        protected Node<K, V> lastReturnedNode;\n         /** The next node to be returned by the iterator. */\n-        protected Node nextNode;\n+        protected Node<K, V> nextNode;\n         /** The previous node in the sequence returned by the iterator. */\n-        protected Node previousNode;\n+        protected Node<K, V> previousNode;\n         /** The modification count. */\n         private int expectedModifications;\n \n         /**\n          * Constructor.\n-         *\n+         * @param orderType  the KEY or VALUE int for the order\n          * @param main  the main map\n-         * @param orderType  the KEY or VALUE int for the order\n-         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int\n-         */\n-        ViewIterator(final TreeBidiMap main, final int orderType, final int dataType) {\n+         */\n+        ViewIterator(final DataElement orderType) {\n             super();\n-            this.main = main;\n             this.orderType = orderType;\n-            this.dataType = dataType;\n-            expectedModifications = main.modifications;\n-            nextNode = leastNode(main.rootNode[orderType], orderType);\n+            expectedModifications = modifications;\n+            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n             lastReturnedNode = null;\n             previousNode = null;\n         }\n \n         public final boolean hasNext() {\n-            return (nextNode != null);\n-        }\n-\n-        public final Object next() {\n+            return nextNode != null;\n+        }\n+\n+        protected Node<K, V> navigateNext() {\n             if (nextNode == null) {\n                 throw new NoSuchElementException();\n             }\n-            if (main.modifications != expectedModifications) {\n+            if (modifications != expectedModifications) {\n                 throw new ConcurrentModificationException();\n             }\n             lastReturnedNode = nextNode;\n             previousNode = nextNode;\n-            nextNode = main.nextGreater(nextNode, orderType);\n-            return doGetData();\n+            nextNode = nextGreater(nextNode, orderType);\n+            return lastReturnedNode;\n         }\n \n         public boolean hasPrevious() {\n-            return (previousNode != null);\n-        }\n-\n-        public Object previous() {\n+            return previousNode != null;\n+        }\n+\n+        protected Node<K, V> navigatePrevious() {\n             if (previousNode == null) {\n                 throw new NoSuchElementException();\n             }\n-            if (main.modifications != expectedModifications) {\n+            if (modifications != expectedModifications) {\n                 throw new ConcurrentModificationException();\n             }\n             nextNode = lastReturnedNode;\n             if (nextNode == null) {\n-                nextNode = main.nextGreater(previousNode, orderType);\n+                nextNode = nextGreater(previousNode, orderType);\n             }\n             lastReturnedNode = previousNode;\n-            previousNode = main.nextSmaller(previousNode, orderType);\n-            return doGetData();\n-        }\n-\n-        /**\n-         * Gets the data value for the lastReturnedNode field.\n-         * @return the data value\n-         */\n-        protected Object doGetData() {\n-            switch (dataType) {\n-                case KEY:\n-                    return lastReturnedNode.getKey();\n-                case VALUE:\n-                    return lastReturnedNode.getValue();\n-                case MAPENTRY:\n-                    return lastReturnedNode;\n-                case INVERSEMAPENTRY:\n-                    return new UnmodifiableMapEntry(lastReturnedNode.getValue(), lastReturnedNode.getKey());\n-            }\n-            return null;\n+            previousNode = nextSmaller(previousNode, orderType);\n+            return lastReturnedNode;\n         }\n \n         public final void remove() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException();\n             }\n-            if (main.modifications != expectedModifications) {\n+            if (modifications != expectedModifications) {\n                 throw new ConcurrentModificationException();\n             }\n-            main.doRedBlackDelete(lastReturnedNode);\n+            doRedBlackDelete(lastReturnedNode);\n             expectedModifications++;\n             lastReturnedNode = null;\n             if (nextNode == null) {\n-                previousNode = TreeBidiMap.greatestNode(main.rootNode[orderType], orderType);\n+                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n             } else {\n-                previousNode = main.nextSmaller(nextNode, orderType);\n+                previousNode = nextSmaller(nextNode, orderType);\n             }\n         }\n     }\n     /**\n      * An iterator over the map.\n      */\n-    static class ViewMapIterator extends ViewIterator implements OrderedMapIterator {\n-\n-        private final int oppositeType;\n-        \n+    class ViewMapIterator extends ViewIterator implements OrderedMapIterator<K, V> {\n+\n         /**\n          * Constructor.\n-         *\n-         * @param main  the main map\n-         * @param orderType  the KEY or VALUE int for the order\n-         */\n-        ViewMapIterator(final TreeBidiMap main, final int orderType) {\n-            super(main, orderType, orderType);\n-            this.oppositeType = oppositeIndex(dataType);\n-        }\n-        \n-        public Object getKey() {\n+         */\n+        ViewMapIterator(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        public K getKey() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n             }\n-            return lastReturnedNode.getData(dataType);\n-        }\n-\n-        public Object getValue() {\n+            return lastReturnedNode.getKey();\n+        }\n+\n+        public V getValue() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n             }\n-            return lastReturnedNode.getData(oppositeType);\n-        }\n-\n-        public Object setValue(final Object obj) {\n+            return lastReturnedNode.getValue();\n+        }\n+\n+        public V setValue(final V obj) {\n             throw new UnsupportedOperationException();\n         }\n+\n+        public K next() {\n+            return navigateNext().getKey();\n+        }\n+\n+        public K previous() {\n+            return navigatePrevious().getKey();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the map.\n+     */\n+    class InverseViewMapIterator extends ViewIterator implements OrderedMapIterator<V, K> {\n+\n+        /**\n+         * Create a new TreeBidiMap.InverseViewMapIterator.\n+         */\n+        public InverseViewMapIterator(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        public V getKey() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getValue();\n+        }\n+\n+        public K getValue() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getKey();\n+        }\n+\n+        public K setValue(final K obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V next() {\n+            return navigateNext().getValue();\n+        }\n+\n+        public V previous() {\n+            return navigatePrevious().getValue();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the map entries.\n+     */\n+    class ViewMapEntryIterator extends ViewIterator implements OrderedIterator<Map.Entry<K, V>> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        ViewMapEntryIterator() {\n+            super(KEY);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return navigateNext();\n+        }\n+\n+        public Map.Entry<K, V> previous() {\n+            return navigatePrevious();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the inverse map entries.\n+     */\n+    class InverseViewMapEntryIterator extends ViewIterator implements OrderedIterator<Map.Entry<V, K>> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        InverseViewMapEntryIterator() {\n+            super(VALUE);\n+        }\n+\n+        public Map.Entry<V, K> next() {\n+            return createEntry(navigateNext());\n+        }\n+\n+        public Map.Entry<V, K> previous() {\n+            return createEntry(navigatePrevious());\n+        }\n+\n+        private Map.Entry<V, K> createEntry(Node<K, V> node) {\n+            return new UnmodifiableMapEntry<V, K>(node.getValue(), node.getKey());\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * A view of this map.\n-     */\n-    static class EntryView extends View {\n-        \n-        private final int oppositeType;\n-        \n-        /**\n-         * Constructor.\n-         *\n-         * @param main  the main map\n-         * @param orderType  the KEY or VALUE int for the order\n-         * @param dataType  the MAPENTRY or INVERSEMAPENTRY int for the returned data\n-         */\n-        EntryView(final TreeBidiMap main, final int orderType, final int dataType) {\n-            super(main, orderType, dataType);\n-            this.oppositeType = TreeBidiMap.oppositeIndex(orderType);\n-        }\n-        \n-        public boolean contains(Object obj) {\n-            if (obj instanceof Map.Entry == false) {\n-                return false;\n-            }\n-            Map.Entry entry = (Map.Entry) obj;\n-            Object value = entry.getValue();\n-            Node node = main.lookup((Comparable) entry.getKey(), orderType);\n-            return (node != null && node.getData(oppositeType).equals(value));\n-        }\n-\n-        public boolean remove(Object obj) {\n-            if (obj instanceof Map.Entry == false) {\n-                return false;\n-            }\n-            Map.Entry entry = (Map.Entry) obj;\n-            Object value = entry.getValue();\n-            Node node = main.lookup((Comparable) entry.getKey(), orderType);\n-            if (node != null && node.getData(oppositeType).equals(value)) {\n-                main.doRedBlackDelete(node);\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * A node used to store the data.\n      */\n-    static class Node implements Map.Entry, KeyValue, Serializable {\n-\n-        private Comparable[] data;\n-        private Node[] leftNode;\n-        private Node[] rightNode;\n-        private Node[] parentNode;\n+    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V>, KeyValue<K, V> {\n+\n+        private K key;\n+        private V value;\n+        private Node<K, V>[] leftNode;\n+        private Node<K, V>[] rightNode;\n+        private Node<K, V>[] parentNode;\n         private boolean[] blackColor;\n         private int hashcodeValue;\n         private boolean calculatedHashCode;\n          * @param key\n          * @param value\n          */\n-        Node(final Comparable key, final Comparable value) {\n+        @SuppressWarnings(\"unchecked\")\n+        Node(final K key, final V value) {\n             super();\n-            data = new Comparable[] { key, value };\n+            this.key = key;\n+            this.value = value;\n             leftNode = new Node[2];\n             rightNode = new Node[2];\n             parentNode = new Node[2];\n             calculatedHashCode = false;\n         }\n \n-        /**\n-         * Get the specified data.\n-         *\n-         * @param index  the KEY or VALUE int\n-         * @return the key or value\n-         */\n-        private Comparable getData(final int index) {\n-            return data[index];\n-        }\n-\n-        /**\n-         * Set this node's left node.\n-         *\n-         * @param node  the new left node\n-         * @param index  the KEY or VALUE int\n-         */\n-        private void setLeft(final Node node, final int index) {\n-            leftNode[index] = node;\n-        }\n-\n-        /**\n-         * Get the left node.\n-         *\n-         * @param index  the KEY or VALUE int\n-         * @return the left node, may be null\n-         */\n-        private Node getLeft(final int index) {\n-            return leftNode[index];\n-        }\n-\n-        /**\n-         * Set this node's right node.\n-         *\n-         * @param node  the new right node\n-         * @param index  the KEY or VALUE int\n-         */\n-        private void setRight(final Node node, final int index) {\n-            rightNode[index] = node;\n-        }\n-\n-        /**\n-         * Get the right node.\n-         *\n-         * @param index  the KEY or VALUE int\n-         * @return the right node, may be null\n-         */\n-        private Node getRight(final int index) {\n-            return rightNode[index];\n+        private Object getData(final DataElement dataElement) {\n+            switch (dataElement) {\n+            case KEY:\n+                return getKey();\n+            case VALUE:\n+                return getValue();\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\n+            leftNode[dataElement.ordinal()] = node;\n+        }\n+\n+        private Node<K, V> getLeft(final DataElement dataElement) {\n+            return leftNode[dataElement.ordinal()];\n+        }\n+\n+        private void setRight(final Node<K, V> node, final DataElement dataElement) {\n+            rightNode[dataElement.ordinal()] = node;\n+        }\n+\n+        private Node<K, V> getRight(final DataElement dataElement) {\n+            return rightNode[dataElement.ordinal()];\n         }\n \n         /**\n          * @param node  the new parent node\n          * @param index  the KEY or VALUE int\n          */\n-        private void setParent(final Node node, final int index) {\n-            parentNode[index] = node;\n+        private void setParent(final Node<K, V> node, final DataElement dataElement) {\n+            parentNode[dataElement.ordinal()] = node;\n         }\n \n         /**\n          * @param index  the KEY or VALUE int\n          * @return the parent node, may be null\n          */\n-        private Node getParent(final int index) {\n-            return parentNode[index];\n+        private Node<K, V> getParent(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()];\n         }\n \n         /**\n          * @param node  the node to swap with\n          * @param index  the KEY or VALUE int\n          */\n-        private void swapColors(final Node node, final int index) {\n+        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n             // Swap colors -- old hacker's trick\n-            blackColor[index]      ^= node.blackColor[index];\n-            node.blackColor[index] ^= blackColor[index];\n-            blackColor[index]      ^= node.blackColor[index];\n+            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n+            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n+            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n         }\n \n         /**\n          * @param index  the KEY or VALUE int\n          * @return true if black (which is represented as a true boolean)\n          */\n-        private boolean isBlack(final int index) {\n-            return blackColor[index];\n+        private boolean isBlack(final DataElement dataElement) {\n+            return blackColor[dataElement.ordinal()];\n         }\n \n         /**\n          * @param index  the KEY or VALUE int\n          * @return true if non-black\n          */\n-        private boolean isRed(final int index) {\n-            return !blackColor[index];\n+        private boolean isRed(final DataElement dataElement) {\n+            return !blackColor[dataElement.ordinal()];\n         }\n \n         /**\n          *\n          * @param index  the KEY or VALUE int\n          */\n-        private void setBlack(final int index) {\n-            blackColor[index] = true;\n+        private void setBlack(final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = true;\n         }\n \n         /**\n          *\n          * @param index  the KEY or VALUE int\n          */\n-        private void setRed(final int index) {\n-            blackColor[index] = false;\n+        private void setRed(final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = false;\n         }\n \n         /**\n          * @param node  the node whose color we're adopting\n          * @param index  the KEY or VALUE int\n          */\n-        private void copyColor(final Node node, final int index) {\n-            blackColor[index] = node.blackColor[index];\n+        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n+        }\n+\n+        private boolean isLeftChild(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()] != null\n+                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n+        }\n+\n+        private boolean isRightChild(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()] != null\n+                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n         }\n \n         //-------------------------------------------------------------------\n         /**\n          * Gets the key.\n-         * \n+         *\n          * @return the key corresponding to this entry.\n          */\n-        public Object getKey() {\n-            return data[KEY];\n+        public K getKey() {\n+            return key;\n         }\n \n         /**\n          * Gets the value.\n-         * \n+         *\n          * @return the value corresponding to this entry.\n          */\n-        public Object getValue() {\n-            return data[VALUE];\n+        public V getValue() {\n+            return value;\n         }\n \n         /**\n          * @return does not return\n          * @throws UnsupportedOperationException always\n          */\n-        public Object setValue(final Object ignored)\n-                throws UnsupportedOperationException {\n-            throw new UnsupportedOperationException(\n-                \"Map.Entry.setValue is not supported\");\n+        public V setValue(final V ignored) throws UnsupportedOperationException {\n+            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n         }\n \n         /**\n             if (!(obj instanceof Map.Entry)) {\n                 return false;\n             }\n-            Map.Entry e = (Map.Entry) obj;\n-            return data[KEY].equals(e.getKey()) && data[VALUE].equals(e.getValue());\n+            Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n+            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n         }\n \n         /**\n          */\n         public int hashCode() {\n             if (!calculatedHashCode) {\n-                hashcodeValue = data[KEY].hashCode() ^ data[VALUE].hashCode();\n+                hashcodeValue = getKey().hashCode() ^ getValue().hashCode();\n                 calculatedHashCode = true;\n             }\n             return hashcodeValue;\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n-     * A node used to store the data.\n-     */\n-    static class Inverse implements OrderedBidiMap {\n-        \n-        /** The parent map. */\n-        private final TreeBidiMap main;\n+     * The inverse map implementation.\n+     */\n+    class Inverse implements OrderedBidiMap<V, K> {\n+\n         /** Store the keySet once created. */\n-        private Set keySet;\n+        private Set<V> keySet;\n         /** Store the valuesSet once created. */\n-        private Set valuesSet;\n+        private Set<K> valuesSet;\n         /** Store the entrySet once created. */\n-        private Set entrySet;\n-        \n-        /**\n-         * Constructor.\n-         * @param main  the main map\n-         */\n-        Inverse(final TreeBidiMap main) {\n-            super();\n-            this.main = main;\n-        }\n+        private Set<Map.Entry<V, K>> entrySet;\n \n         public int size() {\n-            return main.size();\n+            return TreeBidiMap.this.size();\n         }\n \n         public boolean isEmpty() {\n-            return main.isEmpty();\n-        }\n-\n-        public Object get(final Object key) {\n-            return main.getKey(key);\n-        }\n-\n-        public Object getKey(final Object value) {\n-            return main.get(value);\n+            return TreeBidiMap.this.isEmpty();\n+        }\n+\n+        public K get(final Object key) {\n+            return TreeBidiMap.this.getKey(key);\n+        }\n+\n+        public V getKey(final Object value) {\n+            return TreeBidiMap.this.get(value);\n         }\n \n         public boolean containsKey(final Object key) {\n-            return main.containsValue(key);\n+            return TreeBidiMap.this.containsValue(key);\n         }\n \n         public boolean containsValue(final Object value) {\n-            return main.containsKey(value);\n-        }\n-\n-        public Object firstKey() {\n-            if (main.nodeCount == 0) {\n+            return TreeBidiMap.this.containsKey(value);\n+        }\n+\n+        public V firstKey() {\n+            if (TreeBidiMap.this.nodeCount == 0) {\n                 throw new NoSuchElementException(\"Map is empty\");\n             }\n-            return TreeBidiMap.leastNode(main.rootNode[VALUE], VALUE).getValue();\n-        }\n-\n-        public Object lastKey() {\n-            if (main.nodeCount == 0) {\n+            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n+        }\n+\n+        public V lastKey() {\n+            if (TreeBidiMap.this.nodeCount == 0) {\n                 throw new NoSuchElementException(\"Map is empty\");\n             }\n-            return TreeBidiMap.greatestNode(main.rootNode[VALUE], VALUE).getValue();\n-        }\n-    \n-        public Object nextKey(Object key) {\n+            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n+        }\n+\n+        public V nextKey(V key) {\n             checkKey(key);\n-            Node node = main.nextGreater(main.lookup((Comparable) key, VALUE), VALUE);\n-            return (node == null ? null : node.getValue());\n-        }\n-\n-        public Object previousKey(Object key) {\n+            Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            return node == null ? null : node.getValue();\n+        }\n+\n+        public V previousKey(V key) {\n             checkKey(key);\n-            Node node = main.nextSmaller(main.lookup((Comparable) key, VALUE), VALUE);\n-            return (node == null ? null : node.getValue());\n-        }\n-\n-        public Object put(final Object key, final Object value) {\n-            return main.doPut((Comparable) value, (Comparable) key, VALUE);\n-        }\n-\n-        public void putAll(Map map) {\n-            Iterator it = map.entrySet().iterator();\n-            while (it.hasNext()) {\n-                Map.Entry entry = (Map.Entry) it.next();\n-                put(entry.getKey(), entry.getValue());\n-            }\n-        }\n-        \n-        public Object remove(final Object key) {\n-            return main.removeValue(key);\n-        }\n-\n-        public Object removeValue(final Object value) {\n-            return main.remove(value);\n+            Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            return node == null ? null : node.getValue();\n+        }\n+\n+        public K put(final V key, final K value) {\n+            K result = get(key);\n+            TreeBidiMap.this.doPut(value, key);\n+            return result;\n+        }\n+\n+        public void putAll(Map<? extends V, ? extends K> map) {\n+            for (Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n+                put(e.getKey(), e.getValue());\n+            }\n+        }\n+\n+        public K remove(final Object key) {\n+            return TreeBidiMap.this.removeValue(key);\n+        }\n+\n+        public V removeValue(final Object value) {\n+            return TreeBidiMap.this.remove(value);\n         }\n \n         public void clear() {\n-            main.clear();\n-        }\n-\n-        public Set keySet() {\n+            TreeBidiMap.this.clear();\n+        }\n+\n+        public Set<V> keySet() {\n             if (keySet == null) {\n-                keySet = new View(main, VALUE, VALUE);\n+                keySet = new ValueView(VALUE);\n             }\n             return keySet;\n         }\n \n-        public Collection values() {\n+        public Collection<K> values() {\n             if (valuesSet == null) {\n-                valuesSet = new View(main, VALUE, KEY);\n+                valuesSet = new KeyView(VALUE);\n             }\n             return valuesSet;\n         }\n \n-        public Set entrySet() {\n+        public Set<Map.Entry<V, K>> entrySet() {\n             if (entrySet == null) {\n-                entrySet= new EntryView(main, VALUE, INVERSEMAPENTRY);\n+                return new InverseEntryView();\n             }\n             return entrySet;\n         }\n-        \n-        public MapIterator mapIterator() {\n+\n+        public OrderedMapIterator<V, K> mapIterator() {\n             if (isEmpty()) {\n-                return EmptyOrderedMapIterator.INSTANCE;\n-            }\n-            return new ViewMapIterator(main, VALUE);\n-        }\n-\n-        public OrderedMapIterator orderedMapIterator() {\n-            if (isEmpty()) {\n-                return EmptyOrderedMapIterator.INSTANCE;\n-            }\n-            return new ViewMapIterator(main, VALUE);\n-        }\n-\n-        public BidiMap inverseBidiMap() {\n-            return main;\n-        }\n-        \n-        public OrderedBidiMap inverseOrderedBidiMap() {\n-            return main;\n-        }\n-        \n+                return EmptyOrderedMapIterator.<V, K>getInstance();\n+            }\n+            return new InverseViewMapIterator(VALUE);\n+        }\n+\n+        public OrderedBidiMap<K, V> inverseBidiMap() {\n+            return TreeBidiMap.this;\n+        }\n+\n         public boolean equals(Object obj) {\n-            return main.doEquals(obj, VALUE);\n-        }\n-    \n+            return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);\n+        }\n+\n         public int hashCode() {\n-            return main.doHashCode(VALUE);\n-        }\n-    \n+            return TreeBidiMap.this.doHashCode(DataElement.VALUE);\n+        }\n+\n         public String toString() {\n-            return main.doToString(VALUE);\n+            return TreeBidiMap.this.doToString(DataElement.VALUE);\n         }\n     }\n \n--- a/src/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableBidiMap\n-        extends AbstractBidiMapDecorator implements Unmodifiable {\n-    \n+public final class UnmodifiableBidiMap<K, V>\n+        extends AbstractBidiMapDecorator<K, V> implements Unmodifiable {\n+\n     /** The inverse unmodifiable map */\n-    private UnmodifiableBidiMap inverse;\n+    private UnmodifiableBidiMap<V, K> inverse;\n \n     /**\n      * Factory method to create an unmodifiable map.\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable BidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static BidiMap decorate(BidiMap map) {\n+    public static <K, V> BidiMap<K, V> decorate(BidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n-        return new UnmodifiableBidiMap(map);\n+        return new UnmodifiableBidiMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableBidiMap(BidiMap map) {\n+    private UnmodifiableBidiMap(BidiMap<K, V> map) {\n         super(map);\n     }\n \n         throw new UnsupportedOperationException();\n     }\n \n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public void putAll(Map mapToCopy) {\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Set entrySet() {\n-        Set set = super.entrySet();\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.decorate(set);\n     }\n \n-    public Set keySet() {\n-        Set set = super.keySet();\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n         return UnmodifiableSet.decorate(set);\n     }\n \n-    public Collection values() {\n-        Collection coll = super.values();\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n         return UnmodifiableCollection.decorate(coll);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object removeValue(Object value) {\n+    public K removeValue(Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public MapIterator mapIterator() {\n-        MapIterator it = getBidiMap().mapIterator();\n+    public MapIterator<K, V> mapIterator() {\n+        MapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableMapIterator.decorate(it);\n     }\n \n-    public BidiMap inverseBidiMap() {\n+    public synchronized BidiMap<V, K> inverseBidiMap() {\n         if (inverse == null) {\n-            inverse = new UnmodifiableBidiMap(getBidiMap().inverseBidiMap());\n+            inverse = new UnmodifiableBidiMap<V, K>(decorated().inverseBidiMap());\n             inverse.inverse = this;\n         }\n         return inverse;\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections.BidiMap;\n-import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedBidiMap;\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.Unmodifiable;\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableOrderedBidiMap\n-        extends AbstractOrderedBidiMapDecorator implements Unmodifiable {\n-    \n+public final class UnmodifiableOrderedBidiMap<K, V>\n+        extends AbstractOrderedBidiMapDecorator<K, V> implements Unmodifiable {\n+\n     /** The inverse unmodifiable map */\n-    private UnmodifiableOrderedBidiMap inverse;\n+    private UnmodifiableOrderedBidiMap<V, K> inverse;\n \n     /**\n      * Factory method to create an unmodifiable map.\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable OrderedBidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static OrderedBidiMap decorate(OrderedBidiMap map) {\n+    public static <K, V> OrderedBidiMap<K, V> decorate(OrderedBidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n-        return new UnmodifiableOrderedBidiMap(map);\n+        return new UnmodifiableOrderedBidiMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableOrderedBidiMap(OrderedBidiMap map) {\n+    private UnmodifiableOrderedBidiMap(OrderedBidiMap<K, V> map) {\n         super(map);\n     }\n \n         throw new UnsupportedOperationException();\n     }\n \n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public void putAll(Map mapToCopy) {\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Set entrySet() {\n-        Set set = super.entrySet();\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.decorate(set);\n     }\n \n-    public Set keySet() {\n-        Set set = super.keySet();\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n         return UnmodifiableSet.decorate(set);\n     }\n \n-    public Collection values() {\n-        Collection coll = super.values();\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n         return UnmodifiableCollection.decorate(coll);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object removeValue(Object value) {\n+    public K removeValue(Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public MapIterator mapIterator() {\n-        return orderedMapIterator();\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        return inverseOrderedBidiMap();\n     }\n \n-    public BidiMap inverseBidiMap() {\n-        return inverseOrderedBidiMap();\n-    }\n-    \n     //-----------------------------------------------------------------------\n-    public OrderedMapIterator orderedMapIterator() {\n-        OrderedMapIterator it = getOrderedBidiMap().orderedMapIterator();\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        OrderedMapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableOrderedMapIterator.decorate(it);\n     }\n \n-    public OrderedBidiMap inverseOrderedBidiMap() {\n+    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n         if (inverse == null) {\n-            inverse = new UnmodifiableOrderedBidiMap(getOrderedBidiMap().inverseOrderedBidiMap());\n+            inverse = new UnmodifiableOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n             inverse.inverse = this;\n         }\n         return inverse;\n--- a/src/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n import java.util.Set;\n import java.util.SortedMap;\n \n-import org.apache.commons.collections.BidiMap;\n-import org.apache.commons.collections.MapIterator;\n-import org.apache.commons.collections.OrderedBidiMap;\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.SortedBidiMap;\n import org.apache.commons.collections.Unmodifiable;\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableSortedBidiMap\n-        extends AbstractSortedBidiMapDecorator implements Unmodifiable {\n-    \n+public final class UnmodifiableSortedBidiMap<K, V>\n+        extends AbstractSortedBidiMapDecorator<K, V> implements Unmodifiable {\n+\n     /** The inverse unmodifiable map */\n-    private UnmodifiableSortedBidiMap inverse;\n+    private UnmodifiableSortedBidiMap<V, K> inverse;\n \n     /**\n      * Factory method to create an unmodifiable map.\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable SortedBidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static SortedBidiMap decorate(SortedBidiMap map) {\n+    public static <K, V> SortedBidiMap<K, V> decorate(SortedBidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n-        return new UnmodifiableSortedBidiMap(map);\n+        return new UnmodifiableSortedBidiMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableSortedBidiMap(SortedBidiMap map) {\n+    private UnmodifiableSortedBidiMap(SortedBidiMap<K, V> map) {\n         super(map);\n     }\n \n         throw new UnsupportedOperationException();\n     }\n \n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public void putAll(Map mapToCopy) {\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Set entrySet() {\n-        Set set = super.entrySet();\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.decorate(set);\n     }\n \n-    public Set keySet() {\n-        Set set = super.keySet();\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n         return UnmodifiableSet.decorate(set);\n     }\n \n-    public Collection values() {\n-        Collection coll = super.values();\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n         return UnmodifiableCollection.decorate(coll);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object removeValue(Object value) {\n+    public K removeValue(Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public MapIterator mapIterator() {\n-        return orderedMapIterator();\n-    }\n-\n-    public BidiMap inverseBidiMap() {\n-        return inverseSortedBidiMap();\n-    }\n-    \n     //-----------------------------------------------------------------------\n-    public OrderedMapIterator orderedMapIterator() {\n-        OrderedMapIterator it = getSortedBidiMap().orderedMapIterator();\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        OrderedMapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableOrderedMapIterator.decorate(it);\n     }\n \n-    public OrderedBidiMap inverseOrderedBidiMap() {\n-        return inverseSortedBidiMap();\n-    }\n-\n     //-----------------------------------------------------------------------\n-    public SortedBidiMap inverseSortedBidiMap() {\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n         if (inverse == null) {\n-            inverse = new UnmodifiableSortedBidiMap(getSortedBidiMap().inverseSortedBidiMap());\n+            inverse = new UnmodifiableSortedBidiMap<V, K>(decorated().inverseBidiMap());\n             inverse.inverse = this;\n         }\n         return inverse;\n     }\n \n-    public SortedMap subMap(Object fromKey, Object toKey) {\n-        SortedMap sm = getSortedBidiMap().subMap(fromKey, toKey);\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n         return UnmodifiableSortedMap.decorate(sm);\n     }\n \n-    public SortedMap headMap(Object toKey) {\n-        SortedMap sm = getSortedBidiMap().headMap(toKey);\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> sm = decorated().headMap(toKey);\n         return UnmodifiableSortedMap.decorate(sm);\n     }\n \n-    public SortedMap tailMap(Object fromKey) {\n-        SortedMap sm = getSortedBidiMap().tailMap(fromKey);\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> sm = decorated().tailMap(fromKey);\n         return UnmodifiableSortedMap.decorate(sm);\n     }\n \n--- a/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n  * The BoundedFifoBuffer is a very efficient implementation of\n  * <code>Buffer</code> that is of a fixed size.\n  * <p>\n- * The removal order of a <code>BoundedFifoBuffer</code> is based on the \n+ * The removal order of a <code>BoundedFifoBuffer</code> is based on the\n  * insertion order; elements are removed in the same order in which they\n  * were added.  The iteration order is the same as the removal order.\n  * <p>\n  * @author Stephen Colebourne\n  * @author Herve Quiroz\n  */\n-public class BoundedFifoBuffer extends AbstractCollection\n-        implements Buffer, BoundedCollection, Serializable {\n+public class BoundedFifoBuffer<E> extends AbstractCollection<E>\n+        implements Buffer<E>, BoundedCollection<E>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 5603722811189451017L;\n \n     /** Underlying storage array */\n-    private transient Object[] elements;\n-    \n+    private transient E[] elements;\n+\n     /** Array index of first (oldest) buffer element */\n     private transient int start = 0;\n-    \n-    /** \n+\n+    /**\n      * Index mod maxElements of the array position following the last buffer\n      * element.  Buffer elements start at elements[start] and \"wrap around\"\n-     * elements[maxElements-1], ending at elements[decrement(end)].  \n-     * For example, elements = {c,a,b}, start=1, end=1 corresponds to \n+     * elements[maxElements-1], ending at elements[decrement(end)].\n+     * For example, elements = {c,a,b}, start=1, end=1 corresponds to\n      * the buffer [a,b,c].\n      */\n     private transient int end = 0;\n-    \n+\n     /** Flag to indicate if the buffer is currently full. */\n     private transient boolean full = false;\n-    \n+\n     /** Capacity of the buffer */\n     private final int maxElements;\n \n      * @param size  the maximum number of elements for this fifo\n      * @throws IllegalArgumentException  if the size is less than 1\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public BoundedFifoBuffer(int size) {\n         if (size <= 0) {\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n-        elements = new Object[size];\n+        elements = (E[]) new Object[size];\n         maxElements = elements.length;\n     }\n \n      * @param coll  the collection whose elements to add, may not be null\n      * @throws NullPointerException if the collection is null\n      */\n-    public BoundedFifoBuffer(Collection coll) {\n+    public BoundedFifoBuffer(Collection<? extends E> coll) {\n         this(coll.size());\n         addAll(coll);\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Write the buffer out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeInt(size());\n-        for (Iterator it = iterator(); it.hasNext();) {\n+        for (Iterator<E> it = iterator(); it.hasNext();) {\n             out.writeObject(it.next());\n         }\n     }\n \n     /**\n      * Read the buffer in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        elements = new Object[maxElements];\n+        elements = (E[]) new Object[maxElements];\n         int size = in.readInt();\n         for (int i = 0; i < size; i++) {\n-            elements[i] = in.readObject();\n+            elements[i] = (E) in.readObject();\n         }\n         start = 0;\n         full = (size == maxElements);\n     public boolean isFull() {\n         return size() == maxElements;\n     }\n-    \n+\n     /**\n      * Gets the maximum size of the collection (the bound).\n      *\n     public int maxSize() {\n         return maxElements;\n     }\n-    \n+\n     /**\n      * Clears this buffer.\n      */\n      * @throws NullPointerException  if the given element is null\n      * @throws BufferOverflowException  if this buffer is full\n      */\n-    public boolean add(Object element) {\n+    public boolean add(E element) {\n         if (null == element) {\n             throw new NullPointerException(\"Attempted to add null object to buffer\");\n         }\n      * @return the least recently inserted element\n      * @throws BufferUnderflowException  if the buffer is empty\n      */\n-    public Object get() {\n+    public E get() {\n         if (isEmpty()) {\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n-\n         return elements[start];\n     }\n \n      * @return the least recently inserted element\n      * @throws BufferUnderflowException  if the buffer is empty\n      */\n-    public Object remove() {\n+    public E remove() {\n         if (isEmpty()) {\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        Object element = elements[start];\n+        E element = elements[start];\n \n         if (null != element) {\n             elements[start++] = null;\n             if (start >= maxElements) {\n                 start = 0;\n             }\n-\n             full = false;\n         }\n-\n         return element;\n     }\n \n     /**\n      * Increments the internal index.\n-     * \n+     *\n      * @param index  the index to increment\n      * @return the updated index\n      */\n     private int increment(int index) {\n-        index++; \n+        index++;\n         if (index >= maxElements) {\n             index = 0;\n         }\n \n     /**\n      * Decrements the internal index.\n-     * \n+     *\n      * @param index  the index to decrement\n      * @return the updated index\n      */\n      *\n      * @return an iterator over this buffer's elements\n      */\n-    public Iterator iterator() {\n-        return new Iterator() {\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n \n             private int index = start;\n             private int lastReturnedIndex = -1;\n \n             public boolean hasNext() {\n                 return isFirst || (index != end);\n-                \n             }\n \n-            public Object next() {\n+            public E next() {\n                 if (!hasNext()) {\n                     throw new NoSuchElementException();\n                 }\n--- a/src/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java\n \n import java.util.Collection;\n \n-/** \n+/**\n  * CircularFifoBuffer is a first in first out buffer with a fixed size that\n  * replaces its oldest element if full.\n  * <p>\n- * The removal order of a <code>CircularFifoBuffer</code> is based on the \n+ * The removal order of a <code>CircularFifoBuffer</code> is based on the\n  * insertion order; elements are removed in the same order in which they\n  * were added.  The iteration order is the same as the removal order.\n  * <p>\n  * @author Stefano Fornari\n  * @author Stephen Colebourne\n  */\n-public class CircularFifoBuffer extends BoundedFifoBuffer {\n+public class CircularFifoBuffer<E> extends BoundedFifoBuffer<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -8423413834657610406L;\n \n     /**\n      * Constructor that creates a buffer with the specified size.\n-     * \n+     *\n      * @param size  the size of the buffer (cannot be changed)\n      * @throws IllegalArgumentException  if the size is less than 1\n      */\n     /**\n      * Constructor that creates a buffer from the specified collection.\n      * The collection size also sets the buffer size\n-     * \n+     *\n      * @param coll  the collection to copy into the buffer, may not be null\n      * @throws NullPointerException if the collection is null\n      */\n-    public CircularFifoBuffer(Collection coll) {\n+    public CircularFifoBuffer(Collection<E> coll) {\n         super(coll);\n     }\n \n      * @param element the element to add\n      * @return true, always\n      */\n-    public boolean add(Object element) {\n+    public boolean add(E element) {\n         if (isFull()) {\n             remove();\n         }\n         return super.add(element);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n \n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n \n /**\n  * Binary heap implementation of <code>Buffer</code> that provides for\n  * @author Stephen Colebourne\n  * @author Steve Phelps\n  */\n-public class PriorityBuffer extends AbstractCollection\n-        implements Buffer, Serializable {\n+public class PriorityBuffer<E> extends AbstractCollection<E> implements Buffer<E>, Serializable {\n \n     /** Serialization lock. */\n     private static final long serialVersionUID = 6891186490470027896L;\n     /**\n      * The elements in this buffer.\n      */\n-    protected Object[] elements;\n+    protected E[] elements;\n+\n     /**\n      * The number of elements currently in this buffer.\n      */\n     protected int size;\n+\n     /**\n      * If true, the first element as determined by the sort order will \n      * be returned.  If false, the last element as determined by the\n      * sort order will be returned.\n      */\n     protected boolean ascendingOrder;\n+\n     /**\n      * The comparator used to order the elements\n      */\n-    protected Comparator comparator;\n+    protected Comparator<? super E> comparator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param comparator  the comparator used to order the elements,\n      *  null means use natural order\n      */\n-    public PriorityBuffer(Comparator comparator) {\n+    public PriorityBuffer(Comparator<? super E> comparator) {\n         this(DEFAULT_CAPACITY, true, comparator);\n     }\n \n      * @param comparator  the comparator used to order the elements,\n      *  null means use natural order\n      */\n-    public PriorityBuffer(boolean ascendingOrder, Comparator comparator) {\n+    public PriorityBuffer(boolean ascendingOrder, Comparator<? super E> comparator) {\n         this(DEFAULT_CAPACITY, ascendingOrder, comparator);\n     }\n \n      *  null means use natural order\n      * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n      */\n-    public PriorityBuffer(int capacity, Comparator comparator) {\n+    public PriorityBuffer(int capacity, Comparator<? super E> comparator) {\n         this(capacity, true, comparator);\n     }\n \n      *  null means use natural order\n      * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n      */\n-    public PriorityBuffer(int capacity, boolean ascendingOrder, Comparator comparator) {\n+    @SuppressWarnings(\"unchecked\")\n+    public PriorityBuffer(int capacity, boolean ascendingOrder, Comparator<? super E> comparator) {\n         super();\n         if (capacity <= 0) {\n             throw new IllegalArgumentException(\"invalid capacity\");\n         this.ascendingOrder = ascendingOrder;\n \n         //+1 as 0 is noop\n-        this.elements = new Object[capacity + 1];\n-        this.comparator = comparator;\n+        this.elements = (E[]) new Object[capacity + 1];\n+        this.comparator = (Comparator<? super E>) (comparator == null ? ComparableComparator.INSTANCE : comparator);\n     }\n \n     //-----------------------------------------------------------------------\n      * \n      * @return the comparator in use, null is natural order\n      */\n-    public Comparator comparator() {\n+    public Comparator<? super E> comparator() {\n         return comparator;\n     }\n     \n     /**\n      * Clears all elements from the buffer.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void clear() {\n-        elements = new Object[elements.length]; // for gc\n+        elements = (E[]) new Object[elements.length]; // for gc\n         size = 0;\n     }\n \n      * @param element  the element to be added\n      * @return true always\n      */\n-    public boolean add(Object element) {\n+    public boolean add(E element) {\n         if (isAtCapacity()) {\n             grow();\n         }\n-        // percolate element to it's place in tree\n+        // percolate element to its place in tree\n         if (ascendingOrder) {\n             percolateUpMinHeap(element);\n         } else {\n      * @return the next element\n      * @throws BufferUnderflowException if the buffer is empty\n      */\n-    public Object get() {\n+    public E get() {\n         if (isEmpty()) {\n             throw new BufferUnderflowException();\n-        } else {\n-            return elements[1];\n-        }\n+        }\n+        return elements[1];\n     }\n \n     /**\n      * @return the next element\n      * @throws BufferUnderflowException if the buffer is empty\n      */\n-    public Object remove() {\n-        final Object result = get();\n+    public E remove() {\n+        final E result = get();\n         elements[1] = elements[size--];\n \n         // set the unused element to 'null' so that the garbage collector\n      * @param index the index for the element\n      */\n     protected void percolateDownMinHeap(final int index) {\n-        final Object element = elements[index];\n+        final E element = elements[index];\n         int hole = index;\n \n         while ((hole * 2) <= size) {\n      * @param index the index of the element\n      */\n     protected void percolateDownMaxHeap(final int index) {\n-        final Object element = elements[index];\n+        final E element = elements[index];\n         int hole = index;\n \n         while ((hole * 2) <= size) {\n      */\n     protected void percolateUpMinHeap(final int index) {\n         int hole = index;\n-        Object element = elements[hole];\n+        E element = elements[hole];\n         while (hole > 1 && compare(element, elements[hole / 2]) < 0) {\n             // save element that is being pushed down\n             // as the element \"bubble\" is percolated up\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMinHeap(final Object element) {\n+    protected void percolateUpMinHeap(final E element) {\n         elements[++size] = element;\n         percolateUpMinHeap(size);\n     }\n      */\n     protected void percolateUpMaxHeap(final int index) {\n         int hole = index;\n-        Object element = elements[hole];\n+        E element = elements[hole];\n \n         while (hole > 1 && compare(element, elements[hole / 2]) > 0) {\n             // save element that is being pushed down\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMaxHeap(final Object element) {\n+    protected void percolateUpMaxHeap(final E element) {\n         elements[++size] = element;\n         percolateUpMaxHeap(size);\n     }\n      * @param b  the second object\n      * @return -ve if a less than b, 0 if they are equal, +ve if a greater than b\n      */\n-    protected int compare(Object a, Object b) {\n-        if (comparator != null) {\n-            return comparator.compare(a, b);\n-        } else {\n-            return ((Comparable) a).compareTo(b);\n-        }\n+    protected int compare(E a, E b) {\n+        return comparator.compare(a, b);\n     }\n \n     /**\n      * Increases the size of the heap to support additional elements\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected void grow() {\n-        final Object[] array = new Object[elements.length * 2];\n+        final E[] array = (E[]) new Object[elements.length * 2];\n         System.arraycopy(elements, 0, array, 0, elements.length);\n         elements = array;\n     }\n      *\n      * @return an iterator over this heap's elements\n      */\n-    public Iterator iterator() {\n-        return new Iterator() {\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n \n             private int index = 1;\n             private int lastReturnedIndex = -1;\n                 return index <= size;\n             }\n \n-            public Object next() {\n+            public E next() {\n                 if (!hasNext()) {\n                     throw new NoSuchElementException();\n                 }\n--- a/src/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedBuffer extends TransformedCollection implements Buffer {\n+public class TransformedBuffer<E> extends TransformedCollection<E> implements Buffer<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -7901091318986132033L;\n      * @return a new transformed Buffer\n      * @throws IllegalArgumentException if buffer or transformer is null\n      */\n-    public static Buffer decorate(Buffer buffer, Transformer transformer) {\n-        return new TransformedBuffer(buffer, transformer);\n+    public static <E> Buffer<E> decorate(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedBuffer<E>(buffer, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if buffer or transformer is null\n      * @since Commons Collections 3.3\n      */\n+    // TODO: Generics\n     public static Buffer decorateTransform(Buffer buffer, Transformer transformer) {\n         TransformedBuffer decorated = new TransformedBuffer(buffer, transformer);\n         if (transformer != null && buffer != null && buffer.size() > 0) {\n             Object[] values = buffer.toArray();\n             buffer.clear();\n             for(int i=0; i<values.length; i++) {\n-                decorated.getCollection().add(transformer.transform(values[i]));\n+                decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n         return decorated;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if buffer or transformer is null\n      */\n-    protected TransformedBuffer(Buffer buffer, Transformer transformer) {\n+    protected TransformedBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n         super(buffer, transformer);\n     }\n \n      * \n      * @return the decorated buffer\n      */\n-    protected Buffer getBuffer() {\n-        return (Buffer) collection;\n+    protected Buffer<E> getBuffer() {\n+        return (Buffer<E>) collection;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object get() {\n+    public E get() {\n         return getBuffer().get();\n     }\n \n-    public Object remove() {\n+    public E remove() {\n         return getBuffer().remove();\n     }\n \n--- a/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n  * @author Thomas Knych\n  * @author Jordan Krey\n  */\n-public class UnboundedFifoBuffer extends AbstractCollection implements Buffer, Serializable {\n+public class UnboundedFifoBuffer<E> extends AbstractCollection<E> implements Buffer<E>, Serializable {\n     // invariant: buffer.length > size()\n     //   ie.buffer always has at least one empty entry\n \n     private static final long serialVersionUID = -3482960336579541419L;\n \n     /** The array of objects in the buffer. */\n-    protected transient Object[] buffer;\n+    protected transient E[] buffer;\n+\n     /** The current head index. */\n     protected transient int head;\n+\n     /** The current tail index. */\n     protected transient int tail;\n \n     /**\n      * Constructs an UnboundedFifoBuffer with the specified number of elements.\n      * The integer must be a positive integer.\n-     * \n+     *\n      * @param initialSize  the initial size of the buffer\n      * @throws IllegalArgumentException  if the size is less than 1\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public UnboundedFifoBuffer(int initialSize) {\n         if (initialSize <= 0) {\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n-        buffer = new Object[initialSize + 1];\n+        buffer = (E[]) new Object[initialSize + 1];\n         head = 0;\n         tail = 0;\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Write the buffer out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n         out.defaultWriteObject();\n         out.writeInt(size());\n         out.writeInt(buffer.length);\n-        for (Iterator it = iterator(); it.hasNext();) {\n+        for (Iterator<E> it = iterator(); it.hasNext();) {\n             out.writeObject(it.next());\n         }\n     }\n \n     /**\n      * Read the buffer in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         int size = in.readInt();\n         int length = in.readInt();\n-        buffer = new Object[length];\n+        buffer = (E[]) new Object[length];\n         for (int i = 0; i < size; i++) {\n-            buffer[i] = in.readObject();\n+            buffer[i] = (E) in.readObject();\n         }\n         head = 0;\n         tail = size;\n      * @return true, always\n      * @throws NullPointerException  if the given element is null\n      */\n-    public boolean add(final Object obj) {\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean add(final E obj) {\n         if (obj == null) {\n             throw new NullPointerException(\"Attempted to add null object to buffer\");\n         }\n \n         if (size() + 1 >= buffer.length) {\n             // copy contents to a new buffer array\n-            Object[] tmp = new Object[((buffer.length - 1) * 2) + 1];\n+            E[] tmp = (E[]) new Object[((buffer.length - 1) * 2) + 1];\n             int j = 0;\n             // move head to element zero in the new array\n             for (int i = head; i != tail;) {\n      * @return the next object in the buffer\n      * @throws BufferUnderflowException  if this buffer is empty\n      */\n-    public Object get() {\n+    public E get() {\n         if (isEmpty()) {\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n      * @return the removed object\n      * @throws BufferUnderflowException  if this buffer is empty\n      */\n-    public Object remove() {\n+    public E remove() {\n         if (isEmpty()) {\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        Object element = buffer[head];\n+        E element = buffer[head];\n         if (element != null) {\n             buffer[head] = null;\n             head = increment(head);\n \n     /**\n      * Increments the internal index.\n-     * \n+     *\n      * @param index  the index to increment\n      * @return the updated index\n      */\n \n     /**\n      * Decrements the internal index.\n-     * \n+     *\n      * @param index  the index to decrement\n      * @return the updated index\n      */\n      *\n      * @return an iterator over this buffer's elements\n      */\n-    public Iterator iterator() {\n-        return new Iterator() {\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n \n             private int index = head;\n             private int lastReturnedIndex = -1;\n \n             }\n \n-            public Object next() {\n+            public E next() {\n                 if (!hasNext()) {\n                     throw new NoSuchElementException();\n                 }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/collection/AbstractUntypedCollectionDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * Decorates another <code>Collection</code> to provide additional behaviour\n+ * without guaranteeing that the provided <code>Collection</code> type is the\n+ * same as that of the decorated <code>Collection</code>.\n+ * <p>\n+ * Each untyped method call made on this <code>Collection</code> is forwarded to the\n+ * decorated <code>Collection</code>. This class is used as a framework on which\n+ * to build to extensions such as synchronized and unmodifiable behaviour. The\n+ * main advantage of decoration is that one decorator can wrap any\n+ * implementation of <code>Collection</code>, whereas sub-classing requires a\n+ * new class to be written for each implementation.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #iterator()}. Instead it simply returns the value from the wrapped\n+ * collection. This may be undesirable, for example if you are trying to write\n+ * an unmodifiable implementation it might provide a loophole.\n+ *\n+ * @param <D> the type of the elements in the decorated collection\n+ * @param <E> the element type of the Collection implementation\n+ * @since Commons Collections 5\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ * @author Matt Benson\n+ */\n+public abstract class AbstractUntypedCollectionDecorator<E, D> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8016691444524268856L;\n+\n+    /** The collection being decorated */\n+    protected Collection<D> collection;\n+\n+    /**\n+     * Create a new AbstractUntypedCollectionDecorator.\n+     */\n+    public AbstractUntypedCollectionDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the collection being decorated. All access to the decorated\n+     * collection goes via this method.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<D> decorated() {\n+        return collection;\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean contains(Object object) {\n+        return decorated().contains(object);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public boolean remove(Object object) {\n+        return decorated().remove(object);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Object[] toArray() {\n+        return decorated().toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] object) {\n+        return decorated().toArray(object);\n+    }\n+\n+    public boolean containsAll(Collection<?> coll) {\n+        return decorated().containsAll(coll);\n+    }\n+\n+    public boolean removeAll(Collection<?> coll) {\n+        return decorated().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(Collection<?> coll) {\n+        return decorated().retainAll(coll);\n+    }\n+\n+    public boolean equals(Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/collections/comparators/BooleanComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/BooleanComparator.java\n  *\n  * @author Rodney Waldhoff\n  */\n-public final class BooleanComparator implements Comparator, Serializable {\n+public final class BooleanComparator implements Comparator<Boolean>, Serializable {\n \n     /** Serialization version. */\n     private static final long serialVersionUID = 1830042991606340609L;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Compares two arbitrary Objects.\n-     * When both arguments are <code>Boolean</code>, this method is equivalent to \n-     * {@link #compare(Boolean,Boolean) compare((Boolean)<i>obj1</i>,(Boolean)<i>obj2</i>)}.\n-     * When either argument is not a <code>Boolean</code>, this methods throws\n-     * a {@link ClassCastException}.\n-     * \n-     * @param obj1  the first object to compare\n-     * @param obj2  the second object to compare\n-     * @return negative if obj1 is less, positive if greater, zero if equal\n-     * @throws ClassCastException when either argument is not <code>Boolean</code>\n-     */\n-    public int compare(Object obj1, Object obj2) {\n-        return compare((Boolean)obj1, (Boolean)obj2);\n-    }\n-    \n-    /**\n      * Compares two non-<code>null</code> <code>Boolean</code> objects\n      * according to the value of {@link #sortsTrueFirst()}.\n      * \n--- a/src/java/org/apache/commons/collections/comparators/ComparableComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/ComparableComparator.java\n  *\n  * @see java.util.Collections#reverseOrder()\n  */\n-public class ComparableComparator implements Comparator, Serializable {\n+public class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E>, Serializable {\n \n     /** Serialization version. */\n     private static final long serialVersionUID=-291439688585137865L;\n \n     /** The singleton instance. */\n-    private static final ComparableComparator instance = new ComparableComparator();\n+    @SuppressWarnings(\"unchecked\")\n+    public static final ComparableComparator<?> INSTANCE = new ComparableComparator();\n \n     //-----------------------------------------------------------------------\n     /**\n      * \n      * @return the singleton ComparableComparator\n      */\n-    public static ComparableComparator getInstance() {\n-        return instance;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> ComparableComparator<E> getInstance() {\n+        return (ComparableComparator<E>) INSTANCE;\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ClassCastException when <i>obj1</i> is not a <code>Comparable</code>,\n      *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n      */\n-    public int compare(Object obj1, Object obj2) {\n-        return ((Comparable)obj1).compareTo(obj2);\n+    public int compare(E obj1, E obj2) {\n+        return obj1.compareTo(obj2);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/collections/comparators/ComparatorChain.java\n+++ b/src/java/org/apache/commons/collections/comparators/ComparatorChain.java\n  * @author Morgan Delagrange\n  * @version $Revision$ $Date$\n  */\n-public class ComparatorChain implements Comparator, Serializable {\n+public class ComparatorChain<E> implements Comparator<E>, Serializable {\n \n     /** Serialization version from Collections 2.0. */\n     private static final long serialVersionUID = -721644942746081630L;\n-    \n+\n     /** The list of comparators in the chain. */\n-    protected List comparatorChain = null;\n+    protected List<Comparator<E>> comparatorChain = null;\n     /** Order - false (clear) = ascend; true (set) = descend. */\n     protected BitSet orderingBits = null;\n    /** Whether the chain has been \"locked\". */\n     /**\n      * Construct a ComparatorChain with no Comparators.\n      * You must add at least one Comparator before calling\n-     * the compare(Object,Object) method, or an \n+     * the compare(Object,Object) method, or an\n      * UnsupportedOperationException is thrown\n      */\n     public ComparatorChain() {\n-        this(new ArrayList(),new BitSet());\n+        this(new ArrayList<Comparator<E>>(), new BitSet());\n     }\n \n     /**\n      * Construct a ComparatorChain with a single Comparator,\n      * sorting in the forward order\n-     * \n+     *\n      * @param comparator First comparator in the Comparator chain\n      */\n-    public ComparatorChain(Comparator comparator) {\n-        this(comparator,false);\n+    public ComparatorChain(Comparator<E> comparator) {\n+        this(comparator, false);\n     }\n \n     /**\n      * Construct a Comparator chain with a single Comparator,\n      * sorting in the given order\n-     * \n+     *\n      * @param comparator First Comparator in the ComparatorChain\n      * @param reverse    false = forward sort; true = reverse sort\n      */\n-    public ComparatorChain(Comparator comparator, boolean reverse) {\n-        comparatorChain = new ArrayList();\n+    public ComparatorChain(Comparator<E> comparator, boolean reverse) {\n+        comparatorChain = new ArrayList<Comparator<E>>();\n         comparatorChain.add(comparator);\n         orderingBits = new BitSet(1);\n         if (reverse == true) {\n \n     /**\n      * Construct a ComparatorChain from the Comparators in the\n-     * List.  All Comparators will default to the forward \n+     * List.  All Comparators will default to the forward\n      * sort order.\n-     * \n+     *\n      * @param list   List of Comparators\n      * @see #ComparatorChain(List,BitSet)\n      */\n-    public ComparatorChain(List list) {\n-        this(list,new BitSet(list.size()));\n+    public ComparatorChain(List<Comparator<E>> list) {\n+        this(list, new BitSet(list.size()));\n     }\n \n     /**\n      * If that method returns <i>false</i>, the forward\n      * sort order is used; a return value of <i>true</i>\n      * indicates reverse sort order.\n-     * \n+     *\n      * @param list   List of Comparators.  NOTE: This constructor does not perform a\n      *               defensive copy of the list\n      * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n      *               unless extra Comparators are added by another method.\n      */\n-    public ComparatorChain(List list, BitSet bits) {\n+    public ComparatorChain(List<Comparator<E>> list, BitSet bits) {\n         comparatorChain = list;\n         orderingBits = bits;\n     }\n     /**\n      * Add a Comparator to the end of the chain using the\n      * forward sort order\n-     * \n+     *\n      * @param comparator Comparator with the forward sort order\n      */\n-    public void addComparator(Comparator comparator) {\n-        addComparator(comparator,false);\n+    public void addComparator(Comparator<E> comparator) {\n+        addComparator(comparator, false);\n     }\n \n     /**\n      * Add a Comparator to the end of the chain using the\n      * given sort order\n-     * \n+     *\n      * @param comparator Comparator to add to the end of the chain\n      * @param reverse    false = forward sort order; true = reverse sort order\n      */\n-    public void addComparator(Comparator comparator, boolean reverse) {\n+    public void addComparator(Comparator<E> comparator, boolean reverse) {\n         checkLocked();\n-        \n+\n         comparatorChain.add(comparator);\n         if (reverse == true) {\n             orderingBits.set(comparatorChain.size() - 1);\n     /**\n      * Replace the Comparator at the given index, maintaining\n      * the existing sort order.\n-     * \n+     *\n      * @param index      index of the Comparator to replace\n      * @param comparator Comparator to place at the given index\n      * @exception IndexOutOfBoundsException\n      *                   if index &lt; 0 or index &gt;= size()\n      */\n-    public void setComparator(int index, Comparator comparator) \n-    throws IndexOutOfBoundsException {\n-        setComparator(index,comparator,false);\n+    public void setComparator(int index, Comparator<E> comparator) throws IndexOutOfBoundsException {\n+        setComparator(index, comparator, false);\n     }\n \n     /**\n      * Replace the Comparator at the given index in the\n      * ComparatorChain, using the given sort order\n-     * \n+     *\n      * @param index      index of the Comparator to replace\n      * @param comparator Comparator to set\n      * @param reverse    false = forward sort order; true = reverse sort order\n      */\n-    public void setComparator(int index, Comparator comparator, boolean reverse) {\n+    public void setComparator(int index, Comparator<E> comparator, boolean reverse) {\n         checkLocked();\n \n         comparatorChain.set(index,comparator);\n         }\n     }\n \n-\n     /**\n      * Change the sort order at the given index in the\n      * ComparatorChain to a forward sort.\n-     * \n+     *\n      * @param index  Index of the ComparatorChain\n      */\n     public void setForwardSort(int index) {\n     /**\n      * Change the sort order at the given index in the\n      * ComparatorChain to a reverse sort.\n-     * \n+     *\n      * @param index  Index of the ComparatorChain\n      */\n     public void setReverseSort(int index) {\n \n     /**\n      * Number of Comparators in the current ComparatorChain.\n-     * \n+     *\n      * @return Comparator count\n      */\n     public int size() {\n      * Determine if modifications can still be made to the\n      * ComparatorChain.  ComparatorChains cannot be modified\n      * once they have performed a comparison.\n-     * \n-     * @return true = ComparatorChain cannot be modified; false = \n+     *\n+     * @return true = ComparatorChain cannot be modified; false =\n      *         ComparatorChain can still be modified.\n      */\n     public boolean isLocked() {\n     /**\n      * Perform comparisons on the Objects as per\n      * Comparator.compare(o1,o2).\n-     * \n+     *\n      * @param o1  the first object to compare\n      * @param o2  the second object to compare\n      * @return -1, 0, or 1\n      *                   if the ComparatorChain does not contain at least one\n      *                   Comparator\n      */\n-    public int compare(Object o1, Object o2) throws UnsupportedOperationException {\n+    public int compare(E o1, E o2) throws UnsupportedOperationException {\n         if (isLocked == false) {\n             checkChainIntegrity();\n             isLocked = true;\n         }\n \n         // iterate over all comparators in the chain\n-        Iterator comparators = comparatorChain.iterator();\n+        Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n         for (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\n \n-            Comparator comparator = (Comparator) comparators.next();\n+            Comparator<E> comparator = comparators.next();\n             int retval = comparator.compare(o1,o2);\n             if (retval != 0) {\n                 // invert the order if it is a reverse sort\n                 if (orderingBits.get(comparatorIndex) == true) {\n                     if(Integer.MIN_VALUE == retval) {\n                         retval = Integer.MAX_VALUE;\n-                    } else {                        \n+                    } else {\n                         retval *= -1;\n                     }\n                 }\n-\n                 return retval;\n             }\n-\n         }\n \n         // if comparators are exhausted, return 0\n     /**\n      * Implement a hash code for this comparator that is consistent with\n      * {@link #equals(Object) equals}.\n-     * \n+     *\n      * @return a suitable hash code\n      * @since Commons Collections 3.0\n      */\n     public int hashCode() {\n         int hash = 0;\n-        if(null != comparatorChain) {\n+        if (null != comparatorChain) {\n             hash ^= comparatorChain.hashCode();\n         }\n-        if(null != orderingBits) {\n+        if (null != orderingBits) {\n             hash ^= orderingBits.hashCode();\n         }\n         return hash;\n     }\n \n     /**\n-     * Returns <code>true</code> iff <i>that</i> Object is \n-     * is a {@link Comparator} whose ordering is known to be \n+     * Returns <code>true</code> iff <i>that</i> Object is\n+     * is a {@link Comparator} whose ordering is known to be\n      * equivalent to mine.\n      * <p>\n      * This implementation returns <code>true</code>\n      * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n-     * equals <code>this.getClass()</code>, and the underlying \n+     * equals <code>this.getClass()</code>, and the underlying\n      * comparators and order bits are equal.\n      * Subclasses may want to override this behavior to remain consistent\n      * with the {@link Comparator#equals(Object)} contract.\n-     * \n+     *\n      * @param object  the object to compare with\n      * @return true if equal\n      * @since Commons Collections 3.0\n      */\n     public boolean equals(Object object) {\n-        if(this == object) {\n+        if (this == object) {\n             return true;\n-        } else if(null == object) {\n+        }\n+        if (null == object) {\n             return false;\n-        } else if(object.getClass().equals(this.getClass())) {\n-            ComparatorChain chain = (ComparatorChain)object;\n-            return ( (null == orderingBits ? null == chain.orderingBits : orderingBits.equals(chain.orderingBits))\n-                   && (null == comparatorChain ? null == chain.comparatorChain : comparatorChain.equals(chain.comparatorChain)) );\n-        } else {\n-            return false;\n-        }\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            ComparatorChain<?> chain = (ComparatorChain<?>) object;\n+            return ((null == orderingBits ? null == chain.orderingBits : orderingBits\n+                    .equals(chain.orderingBits)) && (null == comparatorChain ? null == chain.comparatorChain\n+                    : comparatorChain.equals(chain.comparatorChain)));\n+        }\n+        return false;\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n \n import java.util.Comparator;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n \n-/** \n+/**\n  * A Comparator which imposes a specific order on a specific set of Objects.\n  * Objects are presented to the FixedOrderComparator in a specified order and\n  * subsequent calls to {@link #compare(Object, Object) compare} yield that order.\n  * @author Stephen Colebourne\n  * @author Janek Bogucki\n  */\n-public class FixedOrderComparator implements Comparator {\n-\n-    /** \n-     * Behavior when comparing unknown Objects:\n-     * unknown objects compare as before known Objects.\n-     */\n-    public static final int UNKNOWN_BEFORE = 0;\n-\n-    /** \n-     * Behavior when comparing unknown Objects:\n-     * unknown objects compare as after known Objects.\n-     */\n-    public static final int UNKNOWN_AFTER = 1;\n-\n-    /** \n-     * Behavior when comparing unknown Objects:\n-     * unknown objects cause a IllegalArgumentException to be thrown.\n-     * This is the default behavior.\n-     */\n-    public static final int UNKNOWN_THROW_EXCEPTION = 2;\n+public class FixedOrderComparator<T> implements Comparator<T> {\n+\n+    /**\n+     * Unknown object behavior enum.\n+     * @since Commons Collections 5\n+     */\n+    public static enum UnknownObjectBehavior {\n+        BEFORE, AFTER, EXCEPTION;\n+    }\n \n     /** Internal map of object to position */\n-    private final Map map = new HashMap();\n+    private final Map<T, Integer> map = new HashMap<T, Integer>();\n+\n     /** Counter used in determining the position in the map */\n     private int counter = 0;\n+\n     /** Is the comparator locked against further change */\n     private boolean isLocked = false;\n+\n     /** The behaviour in the case of an unknown object */\n-    private int unknownObjectBehavior = UNKNOWN_THROW_EXCEPTION;\n+    private UnknownObjectBehavior unknownObjectBehavior = UnknownObjectBehavior.EXCEPTION;\n \n     // Constructors\n     //-----------------------------------------------------------------------\n-    /** \n+    /**\n      * Constructs an empty FixedOrderComparator.\n      */\n     public FixedOrderComparator() {\n         super();\n     }\n \n-    /** \n+    /**\n      * Constructs a FixedOrderComparator which uses the order of the given array\n      * to compare the objects.\n      * <p>\n      * The array is copied, so later changes will not affect the comparator.\n-     * \n+     *\n      * @param items  the items that the comparator can compare in order\n      * @throws IllegalArgumentException if the array is null\n      */\n-    public FixedOrderComparator(Object[] items) {\n+    public FixedOrderComparator(T[] items) {\n         super();\n         if (items == null) {\n             throw new IllegalArgumentException(\"The list of items must not be null\");\n         }\n     }\n \n-    /** \n+    /**\n      * Constructs a FixedOrderComparator which uses the order of the given list\n      * to compare the objects.\n      * <p>\n      * The list is copied, so later changes will not affect the comparator.\n-     * \n+     *\n      * @param items  the items that the comparator can compare in order\n      * @throws IllegalArgumentException if the list is null\n      */\n-    public FixedOrderComparator(List items) {\n+    public FixedOrderComparator(List<T> items) {\n         super();\n         if (items == null) {\n             throw new IllegalArgumentException(\"The list of items must not be null\");\n         }\n-        for (Iterator it = items.iterator(); it.hasNext();) {\n-            add(it.next());\n+        for (T t : items) {\n+            add(t);\n         }\n     }\n \n     /**\n      * Returns true if modifications cannot be made to the FixedOrderComparator.\n      * FixedOrderComparators cannot be modified once they have performed a comparison.\n-     * \n+     *\n      * @return true if attempts to change the FixedOrderComparator yield an\n      *  UnsupportedOperationException, false if it can be changed.\n      */\n \n     /**\n      * Checks to see whether the comparator is now locked against further changes.\n-     * \n+     *\n      * @throws UnsupportedOperationException if the comparator is locked\n      */\n     protected void checkLocked() {\n         }\n     }\n \n-    /** \n+    /**\n      * Gets the behavior for comparing unknown objects.\n-     * \n-     * @return the flag for unknown behaviour - UNKNOWN_AFTER,\n-     * UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n-     */\n-    public int getUnknownObjectBehavior() {\n+     *\n+     * @return {@link UnknownObjectBehavior}\n+     */\n+    public UnknownObjectBehavior getUnknownObjectBehavior() {\n         return unknownObjectBehavior;\n     }\n \n-    /** \n+    /**\n      * Sets the behavior for comparing unknown objects.\n-     * \n+     *\n      * @param unknownObjectBehavior  the flag for unknown behaviour -\n      * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n      * @throws UnsupportedOperationException if a comparison has been performed\n      * @throws IllegalArgumentException if the unknown flag is not valid\n      */\n-    public void setUnknownObjectBehavior(int unknownObjectBehavior) {\n+    public void setUnknownObjectBehavior(UnknownObjectBehavior unknownObjectBehavior) {\n         checkLocked();\n-        if (unknownObjectBehavior != UNKNOWN_AFTER \n-            && unknownObjectBehavior != UNKNOWN_BEFORE \n-            && unknownObjectBehavior != UNKNOWN_THROW_EXCEPTION) {\n-            throw new IllegalArgumentException(\"Unrecognised value for unknown behaviour flag\");    \n+        if (unknownObjectBehavior == null) {\n+            throw new IllegalArgumentException(\"Unknown object behavior must not be null\");\n         }\n         this.unknownObjectBehavior = unknownObjectBehavior;\n     }\n \n     // Methods for adding items\n     //-----------------------------------------------------------------------\n-    /** \n+    /**\n      * Adds an item, which compares as after all items known to the Comparator.\n      * If the item is already known to the Comparator, its old position is\n      * replaced with the new position.\n-     * \n+     *\n      * @param obj  the item to be added to the Comparator.\n      * @return true if obj has been added for the first time, false if\n      *  it was already known to the Comparator.\n      * @throws UnsupportedOperationException if a comparison has already been made\n      */\n-    public boolean add(Object obj) {\n+    public boolean add(T obj) {\n         checkLocked();\n-        Object position = map.put(obj, new Integer(counter++));\n+        Integer position = map.put(obj, new Integer(counter++));\n         return (position == null);\n     }\n \n     /**\n      * Adds a new item, which compares as equal to the given existing item.\n-     * \n-     * @param existingObj  an item already in the Comparator's set of \n+     *\n+     * @param existingObj  an item already in the Comparator's set of\n      *  known objects\n      * @param newObj  an item to be added to the Comparator's set of\n      *  known objects\n      * @return true if newObj has been added for the first time, false if\n      *  it was already known to the Comparator.\n-     * @throws IllegalArgumentException if existingObject is not in the \n+     * @throws IllegalArgumentException if existingObject is not in the\n      *  Comparator's set of known objects.\n      * @throws UnsupportedOperationException if a comparison has already been made\n      */\n-    public boolean addAsEqual(Object existingObj, Object newObj) {\n+    public boolean addAsEqual(T existingObj, T newObj) {\n         checkLocked();\n-        Integer position = (Integer) map.get(existingObj);\n+        Integer position = map.get(existingObj);\n         if (position == null) {\n             throw new IllegalArgumentException(existingObj + \" not known to \" + this);\n         }\n-        Object result = map.put(newObj, position);\n+        Integer result = map.put(newObj, position);\n         return (result == null);\n     }\n \n     // Comparator methods\n     //-----------------------------------------------------------------------\n-    /** \n+    /**\n      * Compares two objects according to the order of this Comparator.\n      * <p>\n      * It is important to note that this class will throw an IllegalArgumentException\n-     * in the case of an unrecognised object. This is not specified in the \n+     * in the case of an unrecognised object. This is not specified in the\n      * Comparator interface, but is the most appropriate exception.\n-     * \n+     *\n      * @param obj1  the first object to compare\n      * @param obj2  the second object to compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n-     * @throws IllegalArgumentException if obj1 or obj2 are not known \n+     * @throws IllegalArgumentException if obj1 or obj2 are not known\n      *  to this Comparator and an alternative behavior has not been set\n      *  via {@link #setUnknownObjectBehavior(int)}.\n      */\n-    public int compare(Object obj1, Object obj2) {\n+    public int compare(T obj1, T obj2) {\n         isLocked = true;\n-        Integer position1 = (Integer) map.get(obj1);\n-        Integer position2 = (Integer) map.get(obj2);\n+        Integer position1 = map.get(obj1);\n+        Integer position2 = map.get(obj2);\n         if (position1 == null || position2 == null) {\n             switch (unknownObjectBehavior) {\n-                case UNKNOWN_BEFORE :\n-                    if (position1 == null) {\n-                        return (position2 == null) ? 0 : -1;\n-                    } else {\n-                        return 1;\n-                    }\n-                case UNKNOWN_AFTER :\n-                    if (position1 == null) {\n-                        return (position2 == null) ? 0 : 1;\n-                    } else {\n-                        return -1;\n-                    }\n-                case UNKNOWN_THROW_EXCEPTION :\n-                    Object unknownObj = (position1 == null) ? obj1 : obj2;\n-                    throw new IllegalArgumentException(\"Attempting to compare unknown object \" + unknownObj);\n-                default :\n-                    throw new UnsupportedOperationException(\"Unknown unknownObjectBehavior: \" + unknownObjectBehavior);\n+            case BEFORE:\n+                return position1 == null ? position2 == null ? 0 : -1 : 1;\n+            case AFTER:\n+                return position1 == null ? position2 == null ? 0 : 1 : -1;\n+            case EXCEPTION:\n+                Object unknownObj = (position1 == null) ? obj1 : obj2;\n+                throw new IllegalArgumentException(\"Attempting to compare unknown object \"\n+                        + unknownObj);\n+            default: //could be null\n+                throw new UnsupportedOperationException(\"Unknown unknownObjectBehavior: \"\n+                        + unknownObjectBehavior);\n             }\n-        } else {\n-            return position1.compareTo(position2);\n-        }\n+        }\n+        return position1.compareTo(position2);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/comparators/ReverseComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/ReverseComparator.java\n import java.io.Serializable;\n import java.util.Comparator;\n \n+import org.apache.commons.collections.ComparatorUtils;\n+\n /**\n  * Reverses the order of another comparator by reversing the arguments\n  * to its {@link #compare(Object, Object) compare} method.\n  *\n  * @see java.util.Collections#reverseOrder()\n  */\n-public class ReverseComparator implements Comparator, Serializable {\n+public class ReverseComparator<E> implements Comparator<E>, Serializable {\n \n     /** Serialization version from Collections 2.0. */\n     private static final long serialVersionUID = 2858887242028539265L;\n \n     /** The comparator being decorated. */\n-    private Comparator comparator;\n+    private Comparator<E> comparator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * \n      * @param comparator Comparator to reverse\n      */\n-    public ReverseComparator(Comparator comparator) {\n-        if(comparator != null) {\n-            this.comparator = comparator;\n-        } else {\n-            this.comparator = ComparableComparator.getInstance();\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    public ReverseComparator(Comparator<E> comparator) {\n+        this.comparator = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n     }\n \n     //-----------------------------------------------------------------------\n      * @param obj2  the second object to compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      */\n-    public int compare(Object obj1, Object obj2) {\n+    public int compare(E obj1, E obj2) {\n         return comparator.compare(obj2, obj1);\n     }\n \n      * @since Commons Collections 3.0\n      */\n     public boolean equals(Object object) {\n-        if(this == object) {\n+        if (this == object) {\n             return true;\n-        } else if(null == object) {\n-            return false;\n-        } else if(object.getClass().equals(this.getClass())) {\n-            ReverseComparator thatrc = (ReverseComparator)object;\n-            return comparator.equals(thatrc.comparator);\n-        } else {\n+        }\n+        if (null == object) {\n             return false;\n         }\n+        if (object.getClass().equals(this.getClass())) {\n+            ReverseComparator<?> thatrc = (ReverseComparator<?>) object;\n+            return comparator.equals(thatrc.comparator);\n+        }\n+        return false;\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/comparators/TransformingComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/TransformingComparator.java\n \n import java.util.Comparator;\n \n+import org.apache.commons.collections.ComparatorUtils;\n import org.apache.commons.collections.Transformer;\n \n /**\n  * @see org.apache.commons.collections.Transformer\n  * @see org.apache.commons.collections.comparators.ComparableComparator\n  */\n-public class TransformingComparator implements Comparator {\n+public class TransformingComparator<E> implements Comparator<E> {\n     \n     /** The decorated comparator. */\n-    protected Comparator decorated;\n+    protected Comparator<E> decorated;\n     /** The transformer being used. */    \n-    protected Transformer transformer;\n+    protected Transformer<? super E, ? extends E> transformer;\n \n     //-----------------------------------------------------------------------\n     /**\n      * \n      * @param transformer what will transform the arguments to <code>compare</code>\n      */\n-    public TransformingComparator(Transformer transformer) {\n-        this(transformer, new ComparableComparator());\n+    @SuppressWarnings(\"unchecked\")\n+    public TransformingComparator(Transformer<? super E, ? extends E> transformer) {\n+        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);\n     }\n \n     /**\n      * @param transformer  what will transform the arguments to <code>compare</code>\n      * @param decorated  the decorated Comparator\n      */\n-    public TransformingComparator(Transformer transformer, Comparator decorated) {\n+    public TransformingComparator(Transformer<? super E, ? extends E> transformer, Comparator<E> decorated) {\n         this.decorated = decorated;\n         this.transformer = transformer;\n     }\n      * @param obj2  the second object to transform then compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      */\n-    public int compare(Object obj1, Object obj2) {\n-        Object value1 = this.transformer.transform(obj1);\n-        Object value2 = this.transformer.transform(obj2);\n+    public int compare(E obj1, E obj2) {\n+        E value1 = this.transformer.transform(obj1);\n+        E value2 = this.transformer.transform(obj2);\n         return this.decorated.compare(value1, value2);\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/AndPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/AndPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class AndPredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class AndPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 4189014213763186912L;\n-    \n+\n     /** The array of predicates to call */\n-    private final Predicate iPredicate1;\n+    private final Predicate<? super T> iPredicate1;\n     /** The array of predicates to call */\n-    private final Predicate iPredicate2;\n-    \n+    private final Predicate<? super T> iPredicate2;\n+\n     /**\n      * Factory to create the predicate.\n-     * \n+     *\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static Predicate getInstance(Predicate predicate1, Predicate predicate2) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new AndPredicate(predicate1, predicate2);\n+        return new AndPredicate<T>(predicate1, predicate2);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      */\n-    public AndPredicate(Predicate predicate1, Predicate predicate2) {\n+    public AndPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n         super();\n         iPredicate1 = predicate1;\n         iPredicate2 = predicate2;\n \n     /**\n      * Evaluates the predicate returning true if both predicates return true.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if both decorated predicates return true\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n        return (iPredicate1.evaluate(object) && iPredicate2.evaluate(object));\n     }\n \n     /**\n      * Gets the two predicates being decorated as an array.\n-     * \n+     *\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n         return new Predicate[] {iPredicate1, iPredicate2};\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/AnyPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/AnyPredicate.java\n  * @author Stephen Colebourne\n  * @author Matt Benson\n  */\n-public final class AnyPredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class AnyPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7429999530934647542L;\n-    \n+\n     /** The array of predicates to call */\n-    private final Predicate[] iPredicates;\n-    \n+    private final Predicate<? super T>[] iPredicates;\n+\n     /**\n      * Factory to create the predicate.\n      * <p>\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static Predicate getInstance(Predicate[] predicates) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> getInstance(Predicate<? super T>[] predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n-            return FalsePredicate.INSTANCE;\n+            return FalsePredicate.<T>falsePredicate();\n         }\n         if (predicates.length == 1) {\n-            return predicates[0];\n+            return (Predicate<T>) predicates[0];\n         }\n-        return new AnyPredicate(FunctorUtils.copy(predicates));\n+        return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static Predicate getInstance(Collection predicates) {\n-        Predicate[] preds = FunctorUtils.validate(predicates);\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> getInstance(Collection<? extends Predicate<T>> predicates) {\n+        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         if (preds.length == 0) {\n-            return FalsePredicate.INSTANCE;\n+            return FalsePredicate.<T>falsePredicate();\n         }\n         if (preds.length == 1) {\n-            return preds[0];\n+            return (Predicate<T>) preds[0];\n         }\n-        return new AnyPredicate(preds);\n+        return new AnyPredicate<T>(preds);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public AnyPredicate(Predicate[] predicates) {\n+    public AnyPredicate(Predicate<? super T>[] predicates) {\n         super();\n         iPredicates = predicates;\n     }\n \n     /**\n      * Evaluates the predicate returning true if any predicate returns true.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if any decorated predicate return true\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(object)) {\n                 return true;\n \n     /**\n      * Gets the predicates, do not modify the array.\n-     * \n+     *\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    public Predicate<? super T>[] getPredicates() {\n         return iPredicates;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ChainedClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/ChainedClosure.java\n \n import java.io.Serializable;\n import java.util.Collection;\n-import java.util.Iterator;\n \n import org.apache.commons.collections.Closure;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class ChainedClosure implements Closure, Serializable {\n+public class ChainedClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -3520677225766901240L;\n \n     /** The closures to call in turn */\n-    private final Closure[] iClosures;\n+    private final Closure<? super E>[] iClosures;\n \n     /**\n      * Factory method that performs validation and copies the parameter array.\n      * @throws IllegalArgumentException if the closures array is null\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n-    public static Closure getInstance(Closure[] closures) {\n+    public static <E> Closure<E> getInstance(Closure<? super E>[] closures) {\n         FunctorUtils.validate(closures);\n         if (closures.length == 0) {\n-            return NOPClosure.INSTANCE;\n+            return NOPClosure.<E>getInstance();\n         }\n         closures = FunctorUtils.copy(closures);\n-        return new ChainedClosure(closures);\n+        return new ChainedClosure<E>(closures);\n     }\n-    \n+\n     /**\n      * Create a new Closure that calls each closure in turn, passing the \n      * result into the next closure. The ordering is that of the iterator()\n      * @throws IllegalArgumentException if the closures collection is null\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n-    public static Closure getInstance(Collection closures) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance(Collection<Closure<E>> closures) {\n         if (closures == null) {\n             throw new IllegalArgumentException(\"Closure collection must not be null\");\n         }\n         if (closures.size() == 0) {\n-            return NOPClosure.INSTANCE;\n+            return NOPClosure.<E>getInstance();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Closure[] cmds = new Closure[closures.size()];\n+        Closure<? super E>[] cmds = new Closure[closures.size()];\n         int i = 0;\n-        for (Iterator it = closures.iterator(); it.hasNext();) {\n-            cmds[i++] = (Closure) it.next();\n+        for (Closure<? super E> closure : closures) {\n+            cmds[i++] = (Closure<E>) closure;\n         }\n         FunctorUtils.validate(cmds);\n-        return new ChainedClosure(cmds);\n+        return new ChainedClosure<E>(cmds);\n     }\n \n     /**\n      * @return the <code>chained</code> closure\n      * @throws IllegalArgumentException if either closure is null\n      */\n-    public static Closure getInstance(Closure closure1, Closure closure2) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance(Closure<? super E> closure1, Closure<? super E> closure2) {\n         if (closure1 == null || closure2 == null) {\n             throw new IllegalArgumentException(\"Closures must not be null\");\n         }\n-        Closure[] closures = new Closure[] { closure1, closure2 };\n-        return new ChainedClosure(closures);\n+        Closure<E>[] closures = new Closure[] { closure1, closure2 };\n+        return new ChainedClosure<E>(closures);\n     }\n \n     /**\n      * \n      * @param closures  the closures to chain, not copied, no nulls\n      */\n-    public ChainedClosure(Closure[] closures) {\n+    public ChainedClosure(Closure<? super E>[] closures) {\n         super();\n         iClosures = closures;\n     }\n      * \n      * @param input  the input object passed to each closure\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         for (int i = 0; i < iClosures.length; i++) {\n             iClosures[i].execute(input);\n         }\n      * @return the closures\n      * @since Commons Collections 3.1\n      */\n-    public Closure[] getClosures() {\n+    public Closure<? super E>[] getClosures() {\n         return iClosures;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ChainedTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ChainedTransformer.java\n \n import java.io.Serializable;\n import java.util.Collection;\n-import java.util.Iterator;\n \n import org.apache.commons.collections.Transformer;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class ChainedTransformer implements Transformer, Serializable {\n+public class ChainedTransformer<T> implements Transformer<T, T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 3514945074733160196L;\n \n     /** The transformers to call in turn */\n-    private final Transformer[] iTransformers;\n+    private final Transformer<? super T, ? extends T>[] iTransformers;\n \n     /**\n      * Factory method that performs validation and copies the parameter array.\n      * @throws IllegalArgumentException if the transformers array is null\n      * @throws IllegalArgumentException if any transformer in the array is null\n      */\n-    public static Transformer getInstance(Transformer[] transformers) {\n+    public static <T> Transformer<T, T> getInstance(Transformer<? super T, ? extends T>[] transformers) {\n         FunctorUtils.validate(transformers);\n         if (transformers.length == 0) {\n-            return NOPTransformer.INSTANCE;\n+            return NOPTransformer.<T>getInstance();\n         }\n         transformers = FunctorUtils.copy(transformers);\n-        return new ChainedTransformer(transformers);\n+        return new ChainedTransformer<T>(transformers);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if the transformers collection is null\n      * @throws IllegalArgumentException if any transformer in the collection is null\n      */\n-    public static Transformer getInstance(Collection transformers) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> getInstance(Collection<? extends Transformer<T, T>> transformers) {\n         if (transformers == null) {\n             throw new IllegalArgumentException(\"Transformer collection must not be null\");\n         }\n         if (transformers.size() == 0) {\n-            return NOPTransformer.INSTANCE;\n+            return NOPTransformer.<T>getInstance();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Transformer[] cmds = new Transformer[transformers.size()];\n-        int i = 0;\n-        for (Iterator it = transformers.iterator(); it.hasNext();) {\n-            cmds[i++] = (Transformer) it.next();\n-        }\n+        Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n         FunctorUtils.validate(cmds);\n-        return new ChainedTransformer(cmds);\n+        return new ChainedTransformer<T>(cmds);\n     }\n \n     /**\n      * @return the <code>chained</code> transformer\n      * @throws IllegalArgumentException if either transformer is null\n      */\n-    public static Transformer getInstance(Transformer transformer1, Transformer transformer2) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> getInstance(Transformer<? super T, ? extends T> transformer1, Transformer<? super T, ? extends T> transformer2) {\n         if (transformer1 == null || transformer2 == null) {\n             throw new IllegalArgumentException(\"Transformers must not be null\");\n         }\n-        Transformer[] transformers = new Transformer[] { transformer1, transformer2 };\n-        return new ChainedTransformer(transformers);\n+        Transformer<? super T, ? extends T>[] transformers = new Transformer[] { transformer1, transformer2 };\n+        return new ChainedTransformer<T>(transformers);\n     }\n \n     /**\n      * \n      * @param transformers  the transformers to chain, not copied, no nulls\n      */\n-    public ChainedTransformer(Transformer[] transformers) {\n+    public ChainedTransformer(Transformer<? super T, ? extends T>[] transformers) {\n         super();\n         iTransformers = transformers;\n     }\n      * @param object  the input object passed to the first transformer\n      * @return the transformed result\n      */\n-    public Object transform(Object object) {\n+    public T transform(T object) {\n         for (int i = 0; i < iTransformers.length; i++) {\n             object = iTransformers[i].transform(object);\n         }\n      * @return the transformers\n      * @since Commons Collections 3.1\n      */\n-    public Transformer[] getTransformers() {\n+    public Transformer<? super T, ? extends T>[] getTransformers() {\n         return iTransformers;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/CloneTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/CloneTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class CloneTransformer implements Transformer, Serializable {\n+public class CloneTransformer<T> implements Transformer<T, T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -8188742709499652567L;\n \n     /** Singleton predicate instance */\n-    public static final Transformer INSTANCE = new CloneTransformer();\n+    public static final Transformer<Object, Object> INSTANCE = new CloneTransformer<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Transformer getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> getInstance() {\n+        return (Transformer<T, T>) INSTANCE;\n     }\n \n     /**\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public T transform(T input) {\n         if (input == null) {\n             return null;\n         }\n--- a/src/java/org/apache/commons/collections/functors/ClosureTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ClosureTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class ClosureTransformer implements Transformer, Serializable {\n+public class ClosureTransformer<T> implements Transformer<T, T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 478466901448617286L;\n \n     /** The closure to wrap */\n-    private final Closure iClosure;\n+    private final Closure<? super T> iClosure;\n \n     /**\n      * Factory method that performs validation.\n      * @return the <code>closure</code> transformer\n      * @throws IllegalArgumentException if the closure is null\n      */\n-    public static Transformer getInstance(Closure closure) {\n+    public static <T> Transformer<T, T> getInstance(Closure<? super T> closure) {\n         if (closure == null) {\n             throw new IllegalArgumentException(\"Closure must not be null\");\n         }\n-        return new ClosureTransformer(closure);\n+        return new ClosureTransformer<T>(closure);\n     }\n \n     /**\n      * \n      * @param closure  the closure to call, not null\n      */\n-    public ClosureTransformer(Closure closure) {\n+    public ClosureTransformer(Closure<? super T> closure) {\n         super();\n         iClosure = closure;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public T transform(T input) {\n         iClosure.execute(input);\n         return input;\n     }\n      * @return the closure\n      * @since Commons Collections 3.1\n      */\n-    public Closure getClosure() {\n+    public Closure<? super T> getClosure() {\n         return iClosure;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ConstantFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/ConstantFactory.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class ConstantFactory implements Factory, Serializable {\n+public class ConstantFactory<T> implements Factory<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -3520677225766901240L;\n     \n     /** Returns null each time */\n-    public static final Factory NULL_INSTANCE = new ConstantFactory(null);\n+    public static final Factory<Object> NULL_INSTANCE = new ConstantFactory<Object>(null);\n \n     /** The closures to call in turn */\n-    private final Object iConstant;\n+    private final T iConstant;\n \n     /**\n      * Factory method that performs validation.\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n-    public static Factory getInstance(Object constantToReturn) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> getInstance(T constantToReturn) {\n         if (constantToReturn == null) {\n-            return NULL_INSTANCE;\n+            return (Factory<T>) NULL_INSTANCE;\n         }\n-        return new ConstantFactory(constantToReturn);\n+        return new ConstantFactory<T>(constantToReturn);\n     }\n     \n     /**\n      * \n      * @param constantToReturn  the constant to return each time\n      */\n-    public ConstantFactory(Object constantToReturn) {\n+    public ConstantFactory(T constantToReturn) {\n         super();\n         iConstant = constantToReturn;\n     }\n      * \n      * @return the stored constant value\n      */\n-    public Object create() {\n+    public T create() {\n         return iConstant;\n     }\n \n      * @return the constant\n      * @since Commons Collections 3.1\n      */\n-    public Object getConstant() {\n+    public T getConstant() {\n         return iConstant;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ConstantTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ConstantTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class ConstantTransformer implements Transformer, Serializable {\n+public class ConstantTransformer<I, O> implements Transformer<I, O>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 6374440726369055124L;\n     \n     /** Returns null each time */\n-    public static final Transformer NULL_INSTANCE = new ConstantTransformer(null);\n+    public static final Transformer<Object, Object> NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);\n \n     /** The closures to call in turn */\n-    private final Object iConstant;\n+    private final O iConstant;\n+\n+    /**\n+     * Get a typed null instance.\n+     * @param <I>\n+     * @param <O>\n+     * @return Transformer<I, O> that always returns null.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> getNullInstance() {\n+        return (Transformer<I, O>) NULL_INSTANCE;\n+    }\n \n     /**\n      * Transformer method that performs validation.\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n-    public static Transformer getInstance(Object constantToReturn) {\n+    public static <I, O> Transformer<I, O> getInstance(O constantToReturn) {\n         if (constantToReturn == null) {\n-            return NULL_INSTANCE;\n+            return getNullInstance();\n         }\n-        return new ConstantTransformer(constantToReturn);\n+        return new ConstantTransformer<I, O>(constantToReturn);\n     }\n     \n     /**\n      * \n      * @param constantToReturn  the constant to return each time\n      */\n-    public ConstantTransformer(Object constantToReturn) {\n+    public ConstantTransformer(O constantToReturn) {\n         super();\n         iConstant = constantToReturn;\n     }\n      * @param input  the input object which is ignored\n      * @return the stored constant\n      */\n-    public Object transform(Object input) {\n+    public O transform(I input) {\n         return iConstant;\n     }\n \n      * @return the constant\n      * @since Commons Collections 3.1\n      */\n-    public Object getConstant() {\n+    public O getConstant() {\n         return iConstant;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof ConstantTransformer == false) {\n+            return false;\n+        }\n+        Object otherConstant = ((ConstantTransformer<?, ?>) obj).getConstant();\n+        return otherConstant == getConstant() || otherConstant != null && otherConstant.equals(getConstant());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = \"ConstantTransformer\".hashCode() << 2;\n+        if (getConstant() != null) {\n+            result |= getConstant().hashCode();\n+        }\n+        return result;\n+    }\n }\n--- a/src/java/org/apache/commons/collections/functors/ExceptionClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionClosure.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class ExceptionClosure implements Closure, Serializable {\n+public final class ExceptionClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7179106032121985545L;\n-    \n \n     /** Singleton predicate instance */\n-    public static final Closure INSTANCE = new ExceptionClosure();\n+    public static final Closure<Object> INSTANCE = new ExceptionClosure<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Closure getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance() {\n+        return (Closure<E>) INSTANCE;\n     }\n \n     /**\n      * @param input  the input object\n      * @throws FunctorException always\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         throw new FunctorException(\"ExceptionClosure invoked\");\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ExceptionFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionFactory.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class ExceptionFactory implements Factory, Serializable {\n+public final class ExceptionFactory<T> implements Factory<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7179106032121985545L;\n-    \n \n     /** Singleton predicate instance */\n-    public static final Factory INSTANCE = new ExceptionFactory();\n+    public static final Factory<Object> INSTANCE = new ExceptionFactory<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Factory getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> getInstance() {\n+        return (Factory<T>) INSTANCE;\n     }\n \n     /**\n      * @return never\n      * @throws FunctorException always\n      */\n-    public Object create() {\n+    public T create() {\n         throw new FunctorException(\"ExceptionFactory invoked\");\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class ExceptionPredicate implements Predicate, Serializable {\n+public final class ExceptionPredicate<T> implements Predicate<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7179106032121985545L;\n-    \n+\n     /** Singleton predicate instance */\n-    public static final Predicate INSTANCE = new ExceptionPredicate();\n+    public static final Predicate<Object> INSTANCE = new ExceptionPredicate<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n-     * \n+     *\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Predicate getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> getInstance() {\n+        return (Predicate<T>) INSTANCE;\n     }\n \n     /**\n \n     /**\n      * Evaluates the predicate always throwing an exception.\n-     * \n+     *\n      * @param object  the input object\n      * @return never\n      * @throws FunctorException always\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         throw new FunctorException(\"ExceptionPredicate invoked\");\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class ExceptionTransformer implements Transformer, Serializable {\n+public final class ExceptionTransformer<I, O> implements Transformer<I, O>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7179106032121985545L;\n-    \n \n     /** Singleton predicate instance */\n-    public static final Transformer INSTANCE = new ExceptionTransformer();\n+    public static final Transformer<Object, Object> INSTANCE = new ExceptionTransformer<Object, Object>();\n \n     /**\n      * Factory returning the singleton instance.\n-     * \n+     *\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Transformer getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> getInstance() {\n+        return (Transformer<I, O>) INSTANCE;\n     }\n \n     /**\n \n     /**\n      * Transforms the input to result by cloning it.\n-     * \n+     *\n      * @param input  the input object to transform\n      * @return never\n      * @throws FunctorException always\n      */\n-    public Object transform(Object input) {\n+    public O transform(I input) {\n         throw new FunctorException(\"ExceptionTransformer invoked\");\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/FactoryTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/FactoryTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class FactoryTransformer implements Transformer, Serializable {\n+public class FactoryTransformer<I, O> implements Transformer<I, O>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -6817674502475353160L;\n \n     /** The factory to wrap */\n-    private final Factory iFactory;\n+    private final Factory<? extends O> iFactory;\n \n     /**\n      * Factory method that performs validation.\n      * @return the <code>factory</code> transformer\n      * @throws IllegalArgumentException if the factory is null\n      */\n-    public static Transformer getInstance(Factory factory) {\n+    public static <I, O> Transformer<I, O> getInstance(Factory<? extends O> factory) {\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n         }\n-        return new FactoryTransformer(factory);\n+        return new FactoryTransformer<I, O>(factory);\n     }\n \n     /**\n      * \n      * @param factory  the factory to call, not null\n      */\n-    public FactoryTransformer(Factory factory) {\n+    public FactoryTransformer(Factory<? extends O> factory) {\n         super();\n         iFactory = factory;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public O transform(I input) {\n         return iFactory.create();\n     }\n \n      * @return the factory\n      * @since Commons Collections 3.1\n      */\n-    public Factory getFactory() {\n+    public Factory<? extends O> getFactory() {\n         return iFactory;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/FalsePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/FalsePredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class FalsePredicate implements Predicate, Serializable {\n+public final class FalsePredicate<T> implements Predicate<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7533784454832764388L;\n-    \n+\n     /** Singleton predicate instance */\n-    public static final Predicate INSTANCE = new FalsePredicate();\n+    public static final Predicate<Object> INSTANCE = new FalsePredicate<Object>();\n \n     /**\n-     * Factory returning the singleton instance.\n-     * \n+     * Get a typed instance.\n+     *\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n+     * @deprecated use {@link #falsePredicate()} instead.\n      */\n-    public static Predicate getInstance() {\n-        return INSTANCE;\n+    public static <T> Predicate<T> getInstance() {\n+        return FalsePredicate.<T>falsePredicate();\n+    }\n+\n+    /**\n+     * Get a typed instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> falsePredicate() {\n+        return (Predicate<T>) INSTANCE;\n     }\n \n     /**\n \n     /**\n      * Evaluates the predicate returning false always.\n-     * \n+     *\n      * @param object  the input object\n      * @return false always\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         return false;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ForClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/ForClosure.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class ForClosure implements Closure, Serializable {\n+public class ForClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -1190120533393621674L;\n     /** The number of times to loop */\n     private final int iCount;\n     /** The closure to call */\n-    private final Closure iClosure;\n+    private final Closure<? super E> iClosure;\n \n     /**\n      * Factory method that performs validation.\n      * @param closure  the closure to execute, not null\n      * @return the <code>for</code> closure\n      */\n-    public static Closure getInstance(int count, Closure closure) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance(int count, Closure<? super E> closure) {\n         if (count <= 0 || closure == null) {\n-            return NOPClosure.INSTANCE;\n+            return NOPClosure.<E>getInstance();\n         }\n         if (count == 1) {\n-            return closure;\n+            return (Closure<E>) closure;\n         }\n-        return new ForClosure(count, closure);\n+        return new ForClosure<E>(count, closure);\n     }\n \n     /**\n      * @param count  the number of times to execute the closure\n      * @param closure  the closure to execute, not null\n      */\n-    public ForClosure(int count, Closure closure) {\n+    public ForClosure(int count, Closure<? super E> closure) {\n         super();\n         iCount = count;\n         iClosure = closure;\n      * \n      * @param input  the input object\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         for (int i = 0; i < iCount; i++) {\n             iClosure.execute(input);\n         }\n      * @return the closure\n      * @since Commons Collections 3.1\n      */\n-    public Closure getClosure() {\n+    public Closure<? super E> getClosure() {\n         return iClosure;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/IdentityPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/IdentityPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class IdentityPredicate implements Predicate, Serializable {\n+public final class IdentityPredicate<T> implements Predicate<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -89901658494523293L;\n \n-    \n     /** The value to compare to */\n-    private final Object iValue;\n-    \n+    private final T iValue;\n+\n     /**\n      * Factory to create the identity predicate.\n-     * \n+     *\n      * @param object  the object to compare to\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Predicate getInstance(Object object) {\n+    public static <T> Predicate<T> getInstance(T object) {\n         if (object == null) {\n-            return NullPredicate.INSTANCE;\n+            return NullPredicate.<T>nullPredicate();\n         }\n-        return new IdentityPredicate(object);\n+        return new IdentityPredicate<T>(object);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param object  the object to compare to\n      */\n-    public IdentityPredicate(Object object) {\n+    public IdentityPredicate(T object) {\n         super();\n         iValue = object;\n     }\n     /**\n      * Evaluates the predicate returning true if the input object is identical to\n      * the stored object.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if input is the same object as the stored value\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         return (iValue == object);\n     }\n \n     /**\n      * Gets the value.\n-     * \n+     *\n      * @return the value\n      * @since Commons Collections 3.1\n      */\n-    public Object getValue() {\n+    public T getValue() {\n         return iValue;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/IfClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/IfClosure.java\n  * @author Stephen Colebourne\n  * @author Matt Benson\n  */\n-public class IfClosure implements Closure, Serializable {\n+public class IfClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 3518477308466486130L;\n \n     /** The test */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super E> iPredicate;\n     /** The closure to use if true */\n-    private final Closure iTrueClosure;\n+    private final Closure<? super E> iTrueClosure;\n     /** The closure to use if false */\n-    private final Closure iFalseClosure;\n+    private final Closure<? super E> iFalseClosure;\n \n     /**\n      * Factory method that performs validation.\n      * @throws IllegalArgumentException if either argument is null\n      * @since Commons Collections 3.2\n      */\n-    public static Closure getInstance(Predicate predicate, Closure trueClosure) {\n-        return getInstance(predicate, trueClosure, NOPClosure.INSTANCE);\n+    public static <E> Closure<E> getInstance(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+        return IfClosure.<E>getInstance(predicate, trueClosure, NOPClosure.<E>getInstance());\n     }\n \n     /**\n      * @return the <code>if</code> closure\n      * @throws IllegalArgumentException if any argument is null\n      */\n-    public static Closure getInstance(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+    public static <E> Closure<E> getInstance(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n         if (trueClosure == null || falseClosure == null) {\n             throw new IllegalArgumentException(\"Closures must not be null\");\n         }\n-        return new IfClosure(predicate, trueClosure, falseClosure);\n+        return new IfClosure<E>(predicate, trueClosure, falseClosure);\n     }\n \n     /**\n      * @param trueClosure  closure used if true, not null\n      * @since Commons Collections 3.2\n      */\n-    public IfClosure(Predicate predicate, Closure trueClosure) {\n+    public IfClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n         this(predicate, trueClosure, NOPClosure.INSTANCE);\n     }\n \n      * @param trueClosure  closure used if true, not null\n      * @param falseClosure  closure used if false, not null\n      */\n-    public IfClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+    public IfClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n         super();\n         iPredicate = predicate;\n         iTrueClosure = trueClosure;\n      * \n      * @param input  the input object\n      */\n-    public void execute(Object input) {\n-        if (iPredicate.evaluate(input) == true) {\n+    public void execute(E input) {\n+        if (iPredicate.evaluate(input)) {\n             iTrueClosure.execute(input);\n         } else {\n             iFalseClosure.execute(input);\n      * @return the predicate\n      * @since Commons Collections 3.1\n      */\n-    public Predicate getPredicate() {\n+    public Predicate<? super E> getPredicate() {\n         return iPredicate;\n     }\n \n      * @return the closure\n      * @since Commons Collections 3.1\n      */\n-    public Closure getTrueClosure() {\n+    public Closure<? super E> getTrueClosure() {\n         return iTrueClosure;\n     }\n \n      * @return the closure\n      * @since Commons Collections 3.1\n      */\n-    public Closure getFalseClosure() {\n+    public Closure<? super E> getFalseClosure() {\n         return iFalseClosure;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class InstanceofPredicate implements Predicate, Serializable {\n+public final class InstanceofPredicate implements Predicate<Object>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -6682656911025165584L;\n \n     /** The type to compare to */\n-    private final Class iType;\n-    \n+    private final Class<?> iType;\n+\n     /**\n      * Factory to create the identity predicate.\n-     * \n+     *\n      * @param type  the type to check for, may not be null\n      * @return the predicate\n      * @throws IllegalArgumentException if the class is null\n      */\n-    public static Predicate getInstance(Class type) {\n+    public static Predicate<Object> getInstance(Class<?> type) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n         }\n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param type  the type to check for\n      */\n-    public InstanceofPredicate(Class type) {\n+    public InstanceofPredicate(Class<?> type) {\n         super();\n         iType = type;\n     }\n \n     /**\n      * Evaluates the predicate returning true if the input object is of the correct type.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if input is of stored type\n      */\n \n     /**\n      * Gets the type to compare to.\n-     * \n+     *\n      * @return the type\n      * @since Commons Collections 3.1\n      */\n-    public Class getType() {\n+    public Class<?> getType() {\n         return iType;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class InstantiateTransformer implements Transformer, Serializable {\n+public class InstantiateTransformer<T> implements Transformer<Class<? extends T>, T>, Serializable {\n \n     /** The serial version */\n     private static final long serialVersionUID = 3786388740793356347L;\n-    \n+\n     /** Singleton instance that uses the no arg constructor */\n-    public static final Transformer NO_ARG_INSTANCE = new InstantiateTransformer();\n+    public static final Transformer<Class<?>, ?> NO_ARG_INSTANCE = new InstantiateTransformer<Object>();\n \n     /** The constructor parameter types */\n-    private final Class[] iParamTypes;\n+    private final Class<?>[] iParamTypes;\n     /** The constructor arguments */\n     private final Object[] iArgs;\n \n     /**\n+     * Get a typed no-arg instance.\n+     * @param <T>\n+     * @return Transformer<Class<? extends T>, T>\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> getInstance() {\n+        return new InstantiateTransformer<T>();\n+    }\n+\n+    /**\n      * Transformer method that performs validation.\n-     * \n+     *\n      * @param paramTypes  the constructor parameter types\n      * @param args  the constructor arguments\n      * @return an instantiate transformer\n      */\n-    public static Transformer getInstance(Class[] paramTypes, Object[] args) {\n+    public static <T> Transformer<Class<? extends T>, T> getInstance(Class<?>[] paramTypes, Object[] args) {\n         if (((paramTypes == null) && (args != null))\n             || ((paramTypes != null) && (args == null))\n             || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n         }\n \n         if (paramTypes == null || paramTypes.length == 0) {\n-            return NO_ARG_INSTANCE;\n-        } else {\n-            paramTypes = (Class[]) paramTypes.clone();\n-            args = (Object[]) args.clone();\n+            return new InstantiateTransformer<T>();\n         }\n-        return new InstantiateTransformer(paramTypes, args);\n+        paramTypes = (Class[]) paramTypes.clone();\n+        args = (Object[]) args.clone();\n+        return new InstantiateTransformer<T>(paramTypes, args);\n     }\n \n     /**\n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param paramTypes  the constructor parameter types, not cloned\n      * @param args  the constructor arguments, not cloned\n      */\n-    public InstantiateTransformer(Class[] paramTypes, Object[] args) {\n+    public InstantiateTransformer(Class<?>[] paramTypes, Object[] args) {\n         super();\n         iParamTypes = paramTypes;\n         iArgs = args;\n \n     /**\n      * Transforms the input Class object to a result by instantiation.\n-     * \n+     *\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public T transform(Class<? extends T> input) {\n         try {\n             if (input instanceof Class == false) {\n                 throw new FunctorException(\n                     \"InstantiateTransformer: Input object was not an instanceof Class, it was a \"\n                         + (input == null ? \"null object\" : input.getClass().getName()));\n             }\n-            Constructor con = ((Class) input).getConstructor(iParamTypes);\n+            Constructor<? extends T> con = input.getConstructor(iParamTypes);\n             return con.newInstance(iArgs);\n-\n         } catch (NoSuchMethodException ex) {\n             throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \");\n         } catch (InstantiationException ex) {\n--- a/src/java/org/apache/commons/collections/functors/InvokerTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/InvokerTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class InvokerTransformer implements Transformer, Serializable {\n+public class InvokerTransformer<I, O> implements Transformer<I, O>, Serializable {\n \n     /** The serial version */\n     private static final long serialVersionUID = -8653385846894047688L;\n     /** The method name to call */\n     private final String iMethodName;\n     /** The array of reflection parameter types */\n-    private final Class[] iParamTypes;\n+    private final Class<?>[] iParamTypes;\n     /** The array of reflection arguments */\n     private final Object[] iArgs;\n \n      * @return an invoker transformer\n      * @since Commons Collections 3.1\n      */\n-    public static Transformer getInstance(String methodName) {\n+    public static <I, O> Transformer<I, O> getInstance(String methodName) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n-        return new InvokerTransformer(methodName);\n+        return new InvokerTransformer<I, O>(methodName);\n     }\n \n     /**\n      * @param args  the arguments to pass to the method\n      * @return an invoker transformer\n      */\n-    public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) {\n+    public static <I, O> Transformer<I, O> getInstance(String methodName, Class<?>[] paramTypes, Object[] args) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n             throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n         }\n         if (paramTypes == null || paramTypes.length == 0) {\n-            return new InvokerTransformer(methodName);\n+            return new InvokerTransformer<I, O>(methodName);\n         } else {\n             paramTypes = (Class[]) paramTypes.clone();\n             args = (Object[]) args.clone();\n-            return new InvokerTransformer(methodName, paramTypes, args);\n+            return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n         }\n     }\n \n      * @param paramTypes  the constructor parameter types, not cloned\n      * @param args  the constructor arguments, not cloned\n      */\n-    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n+    public InvokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args) {\n         super();\n         iMethodName = methodName;\n         iParamTypes = paramTypes;\n      * @param input  the input object to transform\n      * @return the transformed result, null if null input\n      */\n-    public Object transform(Object input) {\n+    @SuppressWarnings(\"unchecked\")\n+    public O transform(Object input) {\n         if (input == null) {\n             return null;\n         }\n         try {\n-            Class cls = input.getClass();\n+            Class<?> cls = input.getClass();\n             Method method = cls.getMethod(iMethodName, iParamTypes);\n-            return method.invoke(input, iArgs);\n-                \n+            return (O) method.invoke(input, iArgs);\n         } catch (NoSuchMethodException ex) {\n             throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n         } catch (IllegalAccessException ex) {\n--- a/src/java/org/apache/commons/collections/functors/MapTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/MapTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class MapTransformer implements Transformer, Serializable {\n+public final class MapTransformer<I, O> implements Transformer<I, O>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 862391807045468939L;\n-    \n+\n     /** The map of data to lookup in */\n-    private final Map iMap;\n+    private final Map<? super I, ? extends O> iMap;\n \n     /**\n      * Factory to create the transformer.\n      * <p>\n      * If the map is null, a transformer that always returns null is returned.\n-     * \n+     *\n      * @param map the map, not cloned\n      * @return the transformer\n      */\n-    public static Transformer getInstance(Map map) {\n+    public static <I, O> Transformer<I, O> getInstance(Map<? super I, ? extends O> map) {\n         if (map == null) {\n-            return ConstantTransformer.NULL_INSTANCE;\n+            return ConstantTransformer.<I, O>getNullInstance();\n         }\n-        return new MapTransformer(map);\n+        return new MapTransformer<I, O>(map);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param map  the map to use for lookup, not cloned\n      */\n-    private MapTransformer(Map map) {\n+    private MapTransformer(Map<? super I, ? extends O> map) {\n         super();\n         iMap = map;\n     }\n \n     /**\n      * Transforms the input to result by looking it up in a <code>Map</code>.\n-     * \n+     *\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public O transform(I input) {\n         return iMap.get(input);\n     }\n \n     /**\n      * Gets the map to lookup in.\n-     * \n+     *\n      * @return the map\n      * @since Commons Collections 3.1\n      */\n-    public Map getMap() {\n+    public Map<? super I, ? extends O> getMap() {\n         return iMap;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NOPClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/NOPClosure.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class NOPClosure implements Closure, Serializable {\n+public class NOPClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 3518477308466486130L;\n \n     /** Singleton predicate instance */\n-    public static final Closure INSTANCE = new NOPClosure();\n+    public static final Closure<Object> INSTANCE = new NOPClosure<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Closure getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance() {\n+        return (Closure<E>) INSTANCE;\n     }\n \n     /**\n      * \n      * @param input  the input object\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         // do nothing\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object arg0) {\n+        return arg0.hashCode() == this.hashCode();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(INSTANCE);\n+    }\n }\n--- a/src/java/org/apache/commons/collections/functors/NOPTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/NOPTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class NOPTransformer implements Transformer, Serializable {\n+public class NOPTransformer<T> implements Transformer<T, T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 2133891748318574490L;\n \n     /** Singleton predicate instance */\n-    public static final Transformer INSTANCE = new NOPTransformer();\n+    public static final Transformer<Object, Object> INSTANCE = new NOPTransformer<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Transformer getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> getInstance() {\n+        return (Transformer<T, T>) INSTANCE;\n     }\n \n     /**\n      * @param input  the input object to transform\n      * @return the transformed result which is the input\n      */\n-    public Object transform(Object input) {\n+    public T transform(T input) {\n         return input;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NonePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NonePredicate.java\n  * @author Stephen Colebourne\n  * @author Matt Benson\n  */\n-public final class NonePredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class NonePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 2007613066565892961L;\n-    \n+\n     /** The array of predicates to call */\n-    private final Predicate[] iPredicates;\n-    \n+    private final Predicate<? super T>[] iPredicates;\n+\n     /**\n      * Factory to create the predicate.\n      * <p>\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static Predicate getInstance(Predicate[] predicates) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T>[] predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n-            return TruePredicate.INSTANCE;\n+            return TruePredicate.<T>truePredicate();\n         }\n         predicates = FunctorUtils.copy(predicates);\n-        return new NonePredicate(predicates);\n+        return new NonePredicate<T>(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static Predicate getInstance(Collection predicates) {\n-        Predicate[] preds = FunctorUtils.validate(predicates);\n+    public static <T> Predicate<T> getInstance(Collection<? extends Predicate<T>> predicates) {\n+        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         if (preds.length == 0) {\n-            return TruePredicate.INSTANCE;\n+            return TruePredicate.<T>truePredicate();\n         }\n-        return new NonePredicate(preds);\n+        return new NonePredicate<T>(preds);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public NonePredicate(Predicate[] predicates) {\n+    public NonePredicate(Predicate<? super T>[] predicates) {\n         super();\n         iPredicates = predicates;\n     }\n \n     /**\n      * Evaluates the predicate returning false if any stored predicate returns false.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if none of decorated predicates return true\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(object)) {\n                 return false;\n \n     /**\n      * Gets the predicates, do not modify the array.\n-     * \n+     *\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    public Predicate<? super T>[] getPredicates() {\n         return iPredicates;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NotNullPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NotNullPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class NotNullPredicate implements Predicate, Serializable {\n+public final class NotNullPredicate<T> implements Predicate<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7533784454832764388L;\n     \n     /** Singleton predicate instance */\n-    public static final Predicate INSTANCE = new NotNullPredicate();\n+    public static final Predicate<Object> INSTANCE = new NotNullPredicate<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Predicate getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> getInstance() {\n+        return (Predicate<T>) INSTANCE;\n     }\n \n     /**\n      * @param object  the object to evaluate\n      * @return true if not null\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         return (object != null);\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NotPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NotPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class NotPredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class NotPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -2654603322338049674L;\n     \n     /** The predicate to decorate */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super T> iPredicate;\n     \n     /**\n      * Factory to create the not predicate.\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Predicate getInstance(Predicate predicate) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new NotPredicate(predicate);\n+        return new NotPredicate<T>(predicate);\n     }\n \n     /**\n      * \n      * @param predicate  the predicate to call after the null check\n      */\n-    public NotPredicate(Predicate predicate) {\n+    public NotPredicate(Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param object  the input object\n      * @return true if predicate returns false\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         return !(iPredicate.evaluate(object));\n     }\n \n      * @return the predicate as the only element in an array\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n         return new Predicate[] {iPredicate};\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class NullIsExceptionPredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class NullIsExceptionPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 3243449850504576071L;\n     \n     /** The predicate to decorate */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super T> iPredicate;\n     \n     /**\n      * Factory to create the null exception predicate.\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Predicate getInstance(Predicate predicate) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new NullIsExceptionPredicate(predicate);\n+        return new NullIsExceptionPredicate<T>(predicate);\n     }\n \n     /**\n      * \n      * @param predicate  the predicate to call after the null check\n      */\n-    public NullIsExceptionPredicate(Predicate predicate) {\n+    public NullIsExceptionPredicate(Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @return true if decorated predicate returns true\n      * @throws FunctorException if input is null\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         if (object == null) {\n             throw new FunctorException(\"Input Object must not be null\");\n         }\n      * @return the predicate as the only element in an array\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n-        return new Predicate[] {iPredicate};\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class NullIsFalsePredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class NullIsFalsePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -2997501534564735525L;\n-    \n+\n     /** The predicate to decorate */\n-    private final Predicate iPredicate;\n-    \n+    private final Predicate<? super T> iPredicate;\n+\n     /**\n      * Factory to create the null false predicate.\n-     * \n+     *\n      * @param predicate  the predicate to decorate, not null\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Predicate getInstance(Predicate predicate) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new NullIsFalsePredicate(predicate);\n+        return new NullIsFalsePredicate<T>(predicate);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param predicate  the predicate to call after the null check\n      */\n-    public NullIsFalsePredicate(Predicate predicate) {\n+    public NullIsFalsePredicate(Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n     /**\n      * Evaluates the predicate returning the result of the decorated predicate\n      * once a null check is performed.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if decorated predicate returns true, false if input is null\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         if (object == null) {\n             return false;\n         }\n \n     /**\n      * Gets the predicate being decorated.\n-     * \n+     *\n      * @return the predicate as the only element in an array\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n-        return new Predicate[] {iPredicate};\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class NullIsTruePredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class NullIsTruePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -7625133768987126273L;\n     \n     /** The predicate to decorate */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super T> iPredicate;\n     \n     /**\n      * Factory to create the null true predicate.\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Predicate getInstance(Predicate predicate) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new NullIsTruePredicate(predicate);\n+        return new NullIsTruePredicate<T>(predicate);\n     }\n \n     /**\n      * \n      * @param predicate  the predicate to call after the null check\n      */\n-    public NullIsTruePredicate(Predicate predicate) {\n+    public NullIsTruePredicate(Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param object  the input object\n      * @return true if decorated predicate returns true or input is null\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         if (object == null) {\n             return true;\n         }\n      * @return the predicate as the only element in an array\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n-        return new Predicate[] {iPredicate};\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/functors/OnePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/OnePredicate.java\n  * @author Stephen Colebourne\n  * @author Matt Benson\n  */\n-public final class OnePredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class OnePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -8125389089924745785L;\n     \n     /** The array of predicates to call */\n-    private final Predicate[] iPredicates;\n+    private final Predicate<? super T>[] iPredicates;\n     \n     /**\n      * Factory to create the predicate.\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static Predicate getInstance(Predicate[] predicates) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> getInstance(Predicate<? super T>[] predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n-            return FalsePredicate.INSTANCE;\n+            return FalsePredicate.<T>falsePredicate();\n         }\n         if (predicates.length == 1) {\n-            return predicates[0];\n+            return (Predicate<T>) predicates[0];\n         }\n         predicates = FunctorUtils.copy(predicates);\n-        return new OnePredicate(predicates);\n+        return new OnePredicate<T>(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static Predicate getInstance(Collection predicates) {\n-        Predicate[] preds = FunctorUtils.validate(predicates);\n-        return new OnePredicate(preds);\n+    public static <T> Predicate<T> getInstance(Collection<? extends Predicate<T>> predicates) {\n+        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        return new OnePredicate<T>(preds);\n     }\n \n     /**\n      * \n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public OnePredicate(Predicate[] predicates) {\n+    public OnePredicate(Predicate<? super T>[] predicates) {\n         super();\n         iPredicates = predicates;\n     }\n      * @param object  the input object\n      * @return true if only one decorated predicate returns true\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         boolean match = false;\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(object)) {\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    public Predicate<? super T>[] getPredicates() {\n         return iPredicates;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/OrPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/OrPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class OrPredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class OrPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -8791518325735182855L;\n-    \n+\n     /** The array of predicates to call */\n-    private final Predicate iPredicate1;\n+    private final Predicate<? super T> iPredicate1;\n     /** The array of predicates to call */\n-    private final Predicate iPredicate2;\n-    \n+    private final Predicate<? super T> iPredicate2;\n+\n     /**\n      * Factory to create the predicate.\n-     * \n+     *\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static Predicate getInstance(Predicate predicate1, Predicate predicate2) {\n+    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new OrPredicate(predicate1, predicate2);\n+        return new OrPredicate<T>(predicate1, predicate2);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      */\n-    public OrPredicate(Predicate predicate1, Predicate predicate2) {\n+    public OrPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n         super();\n         iPredicate1 = predicate1;\n         iPredicate2 = predicate2;\n \n     /**\n      * Evaluates the predicate returning true if either predicate returns true.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if either decorated predicate returns true\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n        return (iPredicate1.evaluate(object) || iPredicate2.evaluate(object));\n     }\n \n     /**\n      * Gets the two predicates being decorated as an array.\n-     * \n+     *\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n         return new Predicate[] {iPredicate1, iPredicate2};\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/PredicateTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/PredicateTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class PredicateTransformer implements Transformer, Serializable {\n+public class PredicateTransformer<T> implements Transformer<T, Boolean>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 5278818408044349346L;\n \n     /** The closure to wrap */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super T> iPredicate;\n \n     /**\n      * Factory method that performs validation.\n      * @return the <code>predicate</code> transformer\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Transformer getInstance(Predicate predicate) {\n+    public static <T> Transformer<T, Boolean> getInstance(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n-        return new PredicateTransformer(predicate);\n+        return new PredicateTransformer<T>(predicate);\n     }\n \n     /**\n      * \n      * @param predicate  the predicate to call, not null\n      */\n-    public PredicateTransformer(Predicate predicate) {\n+    public PredicateTransformer(Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n-        return (iPredicate.evaluate(input) ? Boolean.TRUE : Boolean.FALSE);\n+    public Boolean transform(T input) {\n+        return iPredicate.evaluate(input);\n     }\n \n     /**\n      * @return the predicate\n      * @since Commons Collections 3.1\n      */\n-    public Predicate getPredicate() {\n+    public Predicate<? super T> getPredicate() {\n         return iPredicate;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/PrototypeFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/PrototypeFactory.java\n      * @throws IllegalArgumentException if the prototype is null\n      * @throws IllegalArgumentException if the prototype cannot be cloned\n      */\n-    public static Factory getInstance(Object prototype) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> getInstance(T prototype) {\n         if (prototype == null) {\n-            return ConstantFactory.NULL_INSTANCE;\n+            return ConstantFactory.<T>getInstance(null);\n         }\n         try {\n             Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n-            return new PrototypeCloneFactory(prototype, method);\n+            return new PrototypeCloneFactory<T>(prototype, method);\n \n         } catch (NoSuchMethodException ex) {\n             try {\n-                prototype.getClass().getConstructor(new Class[] { prototype.getClass()});\n-                return new InstantiateFactory(\n-                    prototype.getClass(),\n-                    new Class[] { prototype.getClass()},\n+                prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n+                return new InstantiateFactory<T>(\n+                    (Class<T>) prototype.getClass(),\n+                    new Class<?>[] { prototype.getClass() },\n                     new Object[] { prototype });\n-\n             } catch (NoSuchMethodException ex2) {\n                 if (prototype instanceof Serializable) {\n                     return new PrototypeSerializationFactory((Serializable) prototype);\n     /**\n      * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n      */\n-    static class PrototypeCloneFactory implements Factory, Serializable {\n+    static class PrototypeCloneFactory<T> implements Factory<T>, Serializable {\n         \n         /** The serial version */\n         private static final long serialVersionUID = 5604271422565175555L;\n         \n         /** The object to clone each time */\n-        private final Object iPrototype;\n+        private final T iPrototype;\n         /** The method used to clone */\n         private transient Method iCloneMethod;\n \n         /**\n          * Constructor to store prototype.\n          */\n-        private PrototypeCloneFactory(Object prototype, Method method) {\n+        private PrototypeCloneFactory(T prototype, Method method) {\n             super();\n             iPrototype = prototype;\n             iCloneMethod = method;\n         private void findCloneMethod() {\n             try {\n                 iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n-\n             } catch (NoSuchMethodException ex) {\n                 throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n             }\n          * \n          * @return the new object\n          */\n-        public Object create() {\n+        @SuppressWarnings(\"unchecked\")\n+        public T create() {\n             // needed for post-serialization\n             if (iCloneMethod == null) {\n                 findCloneMethod();\n             }\n \n             try {\n-                return iCloneMethod.invoke(iPrototype, (Object[])null);\n-\n+                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n             } catch (IllegalAccessException ex) {\n                 throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n             } catch (InvocationTargetException ex) {\n     /**\n      * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n      */\n-    static class PrototypeSerializationFactory implements Factory, Serializable {\n+    static class PrototypeSerializationFactory<T extends Serializable> implements Factory<T>, Serializable {\n         \n         /** The serial version */\n         private static final long serialVersionUID = -8704966966139178833L;\n         \n         /** The object to clone via serialization each time */\n-        private final Serializable iPrototype;\n+        private final T iPrototype;\n \n         /**\n          * Constructor to store prototype\n          */\n-        private PrototypeSerializationFactory(Serializable prototype) {\n+        private PrototypeSerializationFactory(T prototype) {\n             super();\n             iPrototype = prototype;\n         }\n          * \n          * @return the new object\n          */\n-        public Object create() {\n+        @SuppressWarnings(\"unchecked\")\n+        public T create() {\n             ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n             ByteArrayInputStream bais = null;\n             try {\n \n                 bais = new ByteArrayInputStream(baos.toByteArray());\n                 ObjectInputStream in = new ObjectInputStream(bais);\n-                return in.readObject();\n+                return (T) in.readObject();\n \n             } catch (ClassNotFoundException ex) {\n                 throw new FunctorException(ex);\n--- a/src/java/org/apache/commons/collections/functors/StringValueTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/StringValueTransformer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class StringValueTransformer implements Transformer, Serializable {\n+public final class StringValueTransformer<T> implements Transformer<T, String>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 7511110693171758606L;\n \n     /** Singleton predicate instance */\n-    public static final Transformer INSTANCE = new StringValueTransformer();\n+    public static final Transformer<Object, String> INSTANCE = new StringValueTransformer<Object>();\n \n     /**\n      * Factory returning the singleton instance.\n      * @return the singleton instance\n      * @since Commons Collections 3.1\n      */\n-    public static Transformer getInstance() {\n-        return INSTANCE;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, String> getInstance() {\n+        return (Transformer<T, String>) INSTANCE;\n     }\n \n     /**\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public String transform(T input) {\n         return String.valueOf(input);\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/SwitchClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/SwitchClosure.java\n package org.apache.commons.collections.functors;\n \n import java.io.Serializable;\n-import java.util.Iterator;\n import java.util.Map;\n \n import org.apache.commons.collections.Closure;\n  *\n  * @author Stephen Colebourne\n  */\n-public class SwitchClosure implements Closure, Serializable {\n+public class SwitchClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = 3518477308466486130L;\n \n     /** The tests to consider */\n-    private final Predicate[] iPredicates;\n+    private final Predicate<? super E>[] iPredicates;\n     /** The matching closures to call */\n-    private final Closure[] iClosures;\n+    private final Closure<? super E>[] iClosures;\n     /** The default closure to call if no tests match */\n-    private final Closure iDefault;\n+    private final Closure<? super E> iDefault;\n \n     /**\n      * Factory method that performs validation and copies the parameter arrays.\n-     * \n+     *\n      * @param predicates  array of predicates, cloned, no nulls\n      * @param closures  matching array of closures, cloned, no nulls\n      * @param defaultClosure  the closure to use if no match, null means nop\n      * @throws IllegalArgumentException if array is null\n      * @throws IllegalArgumentException if any element in the array is null\n      */\n-    public static Closure getInstance(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n         FunctorUtils.validate(predicates);\n         FunctorUtils.validate(closures);\n         if (predicates.length != closures.length) {\n             throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n         }\n         if (predicates.length == 0) {\n-            return (defaultClosure == null ? NOPClosure.INSTANCE : defaultClosure);\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>getInstance(): defaultClosure);\n         }\n         predicates = FunctorUtils.copy(predicates);\n         closures = FunctorUtils.copy(closures);\n-        return new SwitchClosure(predicates, closures, defaultClosure);\n+        return new SwitchClosure<E>(predicates, closures, defaultClosure);\n     }\n \n     /**\n-     * Create a new Closure that calls one of the closures depending \n-     * on the predicates. \n+     * Create a new Closure that calls one of the closures depending\n+     * on the predicates.\n      * <p>\n-     * The Map consists of Predicate keys and Closure values. A closure \n+     * The Map consists of Predicate keys and Closure values. A closure\n      * is called if its matching predicate returns true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n-     * closure is called. The default closure is set in the map with a \n-     * null key. The ordering is that of the iterator() method on the entryset \n+     * closure is called. The default closure is set in the map with a\n+     * null key. The ordering is that of the iterator() method on the entryset\n      * collection of the map.\n-     * \n+     *\n      * @param predicatesAndClosures  a map of predicates to closures\n      * @return the <code>switch</code> closure\n      * @throws IllegalArgumentException if the map is null\n      * @throws IllegalArgumentException if any closure in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n-    public static Closure getInstance(Map predicatesAndClosures) {\n-        Closure[] closures = null;\n-        Predicate[] preds = null;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> getInstance(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n         if (predicatesAndClosures == null) {\n             throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n         }\n-        if (predicatesAndClosures.size() == 0) {\n-            return NOPClosure.INSTANCE;\n-        }\n         // convert to array like this to guarantee iterator() ordering\n-        Closure defaultClosure = (Closure) predicatesAndClosures.remove(null);\n+        Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n         int size = predicatesAndClosures.size();\n         if (size == 0) {\n-            return (defaultClosure == null ? NOPClosure.INSTANCE : defaultClosure);\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>getInstance() : defaultClosure);\n         }\n-        closures = new Closure[size];\n-        preds = new Predicate[size];\n+        Closure<E>[] closures = new Closure[size];\n+        Predicate<E>[] preds = new Predicate[size];\n         int i = 0;\n-        for (Iterator it = predicatesAndClosures.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            preds[i] = (Predicate) entry.getKey();\n-            closures[i] = (Closure) entry.getValue();\n+        for (Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n+            preds[i] = entry.getKey();\n+            closures[i] = entry.getValue();\n             i++;\n         }\n-        return new SwitchClosure(preds, closures, defaultClosure);\n+        return new SwitchClosure<E>(preds, closures, defaultClosure);\n     }\n-    \n+\n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param predicates  array of predicates, not cloned, no nulls\n      * @param closures  matching array of closures, not cloned, no nulls\n      * @param defaultClosure  the closure to use if no match, null means nop\n      */\n-    public SwitchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+    @SuppressWarnings(\"unchecked\")\n+    public SwitchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n         super();\n         iPredicates = predicates;\n         iClosures = closures;\n-        iDefault = (defaultClosure == null ? NOPClosure.INSTANCE : defaultClosure);\n+        iDefault = (Closure<? super E>) (defaultClosure == null ? NOPClosure.<E>getInstance() : defaultClosure);\n     }\n \n     /**\n      * Executes the closure whose matching predicate returns true\n-     * \n+     *\n      * @param input  the input object\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(input) == true) {\n                 iClosures[i].execute(input);\n \n     /**\n      * Gets the predicates, do not modify the array.\n-     * \n+     *\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    public Predicate<? super E>[] getPredicates() {\n         return iPredicates;\n     }\n \n     /**\n      * Gets the closures, do not modify the array.\n-     * \n+     *\n      * @return the closures\n      * @since Commons Collections 3.1\n      */\n-    public Closure[] getClosures() {\n+    public Closure<? super E>[] getClosures() {\n         return iClosures;\n     }\n \n     /**\n      * Gets the default closure.\n-     * \n+     *\n      * @return the default closure\n      * @since Commons Collections 3.1\n      */\n-    public Closure getDefaultClosure() {\n+    public Closure<? super E> getDefaultClosure() {\n         return iDefault;\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/functors/SwitchTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/SwitchTransformer.java\n package org.apache.commons.collections.functors;\n \n import java.io.Serializable;\n-import java.util.Iterator;\n import java.util.Map;\n \n import org.apache.commons.collections.Predicate;\n  *\n  * @author Stephen Colebourne\n  */\n-public class SwitchTransformer implements Transformer, Serializable {\n+public class SwitchTransformer<I, O> implements Transformer<I, O>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -6404460890903469332L;\n \n     /** The tests to consider */\n-    private final Predicate[] iPredicates;\n+    private final Predicate<? super I>[] iPredicates;\n     /** The matching transformers to call */\n-    private final Transformer[] iTransformers;\n+    private final Transformer<? super I, ? extends O>[] iTransformers;\n     /** The default transformer to call if no tests match */\n-    private final Transformer iDefault;\n+    private final Transformer<? super I, ? extends O> iDefault;\n \n     /**\n      * Factory method that performs validation and copies the parameter arrays.\n      * @throws IllegalArgumentException if array is null\n      * @throws IllegalArgumentException if any element in the array is null\n      */\n-    public static Transformer getInstance(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> getInstance(Predicate<? super I>[] predicates,\n+            Transformer<? super I, ? extends O>[] transformers,\n+            Transformer<? super I, ? extends O> defaultTransformer) {\n         FunctorUtils.validate(predicates);\n         FunctorUtils.validate(transformers);\n         if (predicates.length != transformers.length) {\n             throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n         }\n         if (predicates.length == 0) {\n-            return (defaultTransformer == null ? ConstantTransformer.NULL_INSTANCE : defaultTransformer);\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>getNullInstance() : defaultTransformer);\n         }\n         predicates = FunctorUtils.copy(predicates);\n         transformers = FunctorUtils.copy(transformers);\n-        return new SwitchTransformer(predicates, transformers, defaultTransformer);\n+        return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any transformer in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n-    public static Transformer getInstance(Map predicatesAndTransformers) {\n-        Transformer[] transformers = null;\n-        Predicate[] preds = null;\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> getInstance(\n+            Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> predicatesAndTransformers) {\n         if (predicatesAndTransformers == null) {\n             throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n         }\n         if (predicatesAndTransformers.size() == 0) {\n-            return ConstantTransformer.NULL_INSTANCE;\n+            return ConstantTransformer.<I, O>getNullInstance();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Transformer defaultTransformer = (Transformer) predicatesAndTransformers.remove(null);\n+        Transformer<? super I, ? extends O> defaultTransformer = predicatesAndTransformers.remove(null);\n         int size = predicatesAndTransformers.size();\n         if (size == 0) {\n-            return (defaultTransformer == null ? ConstantTransformer.NULL_INSTANCE : defaultTransformer);\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>getNullInstance() : defaultTransformer);\n         }\n-        transformers = new Transformer[size];\n-        preds = new Predicate[size];\n+        Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n+        Predicate<? super I>[] preds = new Predicate[size];\n         int i = 0;\n-        for (Iterator it = predicatesAndTransformers.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            preds[i] = (Predicate) entry.getKey();\n-            transformers[i] = (Transformer) entry.getValue();\n+        for (Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : predicatesAndTransformers.entrySet()) {\n+            preds[i] = entry.getKey();\n+            transformers[i] = entry.getValue();\n             i++;\n         }\n-        return new SwitchTransformer(preds, transformers, defaultTransformer);\n+        return new SwitchTransformer<I, O>(preds, transformers, defaultTransformer);\n     }\n     \n     /**\n      * @param transformers  matching array of transformers, not cloned, no nulls\n      * @param defaultTransformer  the transformer to use if no match, null means return null\n      */\n-    public SwitchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+    @SuppressWarnings(\"unchecked\")\n+    public SwitchTransformer(Predicate<? super I>[] predicates,\n+            Transformer<? super I, ? extends O>[] transformers,\n+            Transformer<? super I, ? extends O> defaultTransformer) {\n         super();\n         iPredicates = predicates;\n         iTransformers = transformers;\n-        iDefault = (defaultTransformer == null ? ConstantTransformer.NULL_INSTANCE : defaultTransformer);\n+        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ? ConstantTransformer.<I, O>getNullInstance() : defaultTransformer);\n     }\n \n     /**\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Object transform(Object input) {\n+    public O transform(I input) {\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(input) == true) {\n                 return iTransformers[i].transform(input);\n      * @return the predicates\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    public Predicate<? super I>[] getPredicates() {\n         return iPredicates;\n     }\n \n      * @return the transformers\n      * @since Commons Collections 3.1\n      */\n-    public Transformer[] getTransformers() {\n+    public Transformer<? super I, ? extends O>[] getTransformers() {\n         return iTransformers;\n     }\n \n      * @return the default transformer\n      * @since Commons Collections 3.1\n      */\n-    public Transformer getDefaultTransformer() {\n+    public Transformer<? super I, ? extends O> getDefaultTransformer() {\n         return iDefault;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/TransformedPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/TransformedPredicate.java\n  * @author Alban Peignier\n  * @author Stephen Colebourne\n  */\n-public final class TransformedPredicate implements Predicate, PredicateDecorator, Serializable {\n+public final class TransformedPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -5596090919668315834L;\n-    \n+\n     /** The transformer to call */\n-    private final Transformer iTransformer;\n+    private final Transformer<? super T, ? extends T> iTransformer;\n+\n     /** The predicate to call */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super T> iPredicate;\n \n     /**\n      * Factory to create the predicate.\n-     * \n+     *\n      * @param transformer  the transformer to call\n      * @param predicate  the predicate to call with the result of the transform\n      * @return the predicate\n      * @throws IllegalArgumentException if the transformer or the predicate is null\n      */\n-    public static Predicate getInstance(Transformer transformer, Predicate predicate) {\n+    public static <T> Predicate<T> getInstance(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"The predicate to call must not be null\");\n         }\n-        return new TransformedPredicate(transformer, predicate);\n+        return new TransformedPredicate<T>(transformer, predicate);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param transformer  the transformer to use\n      * @param predicate  the predicate to decorate\n      */\n-    public TransformedPredicate(Transformer transformer, Predicate predicate) {\n+    public TransformedPredicate(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n         iTransformer = transformer;\n         iPredicate = predicate;\n     }\n-    \n+\n     /**\n      * Evaluates the predicate returning the result of the decorated predicate\n      * once the input has been transformed\n-     * \n+     *\n      * @param object  the input object which will be transformed\n      * @return true if decorated predicate returns true\n      */\n-    public boolean evaluate(Object object) {\n-        Object result = iTransformer.transform(object);\n+    public boolean evaluate(T object) {\n+        T result = iTransformer.transform(object);\n         return iPredicate.evaluate(result);\n     }\n \n     /**\n      * Gets the predicate being decorated.\n-     * \n+     *\n      * @return the predicate as the only element in an array\n      * @since Commons Collections 3.1\n      */\n-    public Predicate[] getPredicates() {\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n         return new Predicate[] {iPredicate};\n     }\n \n     /**\n      * Gets the transformer in use.\n-     * \n+     *\n      * @return the transformer\n      */\n-    public Transformer getTransformer() {\n+    public Transformer<? super T, ? extends T> getTransformer() {\n         return iTransformer;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/TransformerClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/TransformerClosure.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformerClosure implements Closure, Serializable {\n+public class TransformerClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -5194992589193388969L;\n \n     /** The transformer to wrap */\n-    private final Transformer iTransformer;\n+    private final Transformer<? super E, ?> iTransformer;\n \n     /**\n      * Factory method that performs validation.\n      * @param transformer  the transformer to call, null means nop\n      * @return the <code>transformer</code> closure\n      */\n-    public static Closure getInstance(Transformer transformer) {\n+    public static <E> Closure<E> getInstance(Transformer<? super E, ?> transformer) {\n         if (transformer == null) {\n-            return NOPClosure.INSTANCE;\n+            return NOPClosure.<E>getInstance();\n         }\n-        return new TransformerClosure(transformer);\n+        return new TransformerClosure<E>(transformer);\n     }\n \n     /**\n      * \n      * @param transformer  the transformer to call, not null\n      */\n-    public TransformerClosure(Transformer transformer) {\n+    public TransformerClosure(Transformer<? super E, ?> transformer) {\n         super();\n         iTransformer = transformer;\n     }\n      * \n      * @param input  the input object\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         iTransformer.transform(input);\n     }\n \n      * @return the transformer\n      * @since Commons Collections 3.1\n      */\n-    public Transformer getTransformer() {\n+    public Transformer<? super E, ?> getTransformer() {\n         return iTransformer;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/TransformerPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/TransformerPredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class TransformerPredicate implements Predicate, Serializable {\n+public final class TransformerPredicate<T> implements Predicate<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -2407966402920578741L;\n-    \n+\n     /** The transformer to call */\n-    private final Transformer iTransformer;\n-    \n+    private final Transformer<? super T, Boolean> iTransformer;\n+\n     /**\n      * Factory to create the predicate.\n-     * \n+     *\n      * @param transformer  the transformer to decorate\n      * @return the predicate\n      * @throws IllegalArgumentException if the transformer is null\n      */\n-    public static Predicate getInstance(Transformer transformer) {\n+    public static <T> Predicate<T> getInstance(Transformer<? super T, Boolean> transformer) {\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n-        return new TransformerPredicate(transformer);\n+        return new TransformerPredicate<T>(transformer);\n     }\n \n     /**\n      * Constructor that performs no validation.\n      * Use <code>getInstance</code> if you want that.\n-     * \n+     *\n      * @param transformer  the transformer to decorate\n      */\n-    public TransformerPredicate(Transformer transformer) {\n+    public TransformerPredicate(Transformer<? super T, Boolean> transformer) {\n         super();\n         iTransformer = transformer;\n     }\n \n     /**\n      * Evaluates the predicate returning the result of the decorated transformer.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if decorated transformer returns Boolean.TRUE\n      * @throws FunctorException if the transformer returns an invalid type\n      */\n-    public boolean evaluate(Object object) {\n-        Object result = iTransformer.transform(object);\n-        if (result instanceof Boolean == false) {\n+    public boolean evaluate(T object) {\n+        Boolean result = iTransformer.transform(object);\n+        if (result == null) {\n             throw new FunctorException(\n-                \"Transformer must return an instanceof Boolean, it was a \"\n-                    + (result == null ? \"null object\" : result.getClass().getName()));\n+                    \"Transformer must return an instanceof Boolean, it was a null object\");\n         }\n-        return ((Boolean) result).booleanValue();\n+        return result;\n     }\n \n     /**\n      * Gets the transformer.\n-     * \n+     *\n      * @return the transformer\n      * @since Commons Collections 3.1\n      */\n-    public Transformer getTransformer() {\n+    public Transformer<? super T, Boolean> getTransformer() {\n         return iTransformer;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/UniquePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/UniquePredicate.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UniquePredicate implements Predicate, Serializable {\n+public final class UniquePredicate<T> implements Predicate<T>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -3319417438027438040L;\n-    \n+\n     /** The set of previously seen objects */\n-    private final Set iSet = new HashSet();\n-    \n+    private final Set<T> iSet = new HashSet<T>();\n+\n     /**\n      * Factory to create the predicate.\n-     * \n+     *\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static Predicate getInstance() {\n-        return new UniquePredicate();\n+    public static <E> Predicate<E> getInstance() {\n+        return new UniquePredicate<E>();\n     }\n \n     /**\n     /**\n      * Evaluates the predicate returning true if the input object hasn't been\n      * received yet.\n-     * \n+     *\n      * @param object  the input object\n      * @return true if this is the first time the object is seen\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(T object) {\n         return iSet.add(object);\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/WhileClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/WhileClosure.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class WhileClosure implements Closure, Serializable {\n+public class WhileClosure<E> implements Closure<E>, Serializable {\n \n     /** Serial version UID */\n     private static final long serialVersionUID = -3110538116913760108L;\n \n     /** The test condition */\n-    private final Predicate iPredicate;\n+    private final Predicate<? super E> iPredicate;\n     /** The closure to call */\n-    private final Closure iClosure;\n+    private final Closure<? super E> iClosure;\n     /** The flag, true is a do loop, false is a while */\n     private final boolean iDoLoop;\n \n      * @return the <code>while</code> closure\n      * @throws IllegalArgumentException if the predicate or closure is null\n      */\n-    public static Closure getInstance(Predicate predicate, Closure closure, boolean doLoop) {\n+    public static <E> Closure<E> getInstance(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n         if (closure == null) {\n             throw new IllegalArgumentException(\"Closure must not be null\");\n         }\n-        return new WhileClosure(predicate, closure, doLoop);\n+        return new WhileClosure<E>(predicate, closure, doLoop);\n     }\n \n     /**\n      * @param closure  the closure the execute, not null\n      * @param doLoop  true to act as a do-while loop, always executing the closure once\n      */\n-    public WhileClosure(Predicate predicate, Closure closure, boolean doLoop) {\n+    public WhileClosure(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n         super();\n         iPredicate = predicate;\n         iClosure = closure;\n      * \n      * @param input  the input object\n      */\n-    public void execute(Object input) {\n+    public void execute(E input) {\n         if (iDoLoop) {\n             iClosure.execute(input);\n         }\n      * @return the predicate\n      * @since Commons Collections 3.1\n      */\n-    public Predicate getPredicate() {\n+    public Predicate<? super E> getPredicate() {\n         return iPredicate;\n     }\n \n      * @return the closure\n      * @since Commons Collections 3.1\n      */\n-    public Closure getClosure() {\n+    public Closure<? super E> getClosure() {\n         return iClosure;\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/AbstractEmptyIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/AbstractEmptyIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-abstract class AbstractEmptyIterator {\n+abstract class AbstractEmptyIterator<E> {\n  \n     /**\n      * Constructor.\n         return false;\n     }\n \n-    public Object next() {\n+    public E next() {\n         throw new NoSuchElementException(\"Iterator contains no elements\");\n     }\n \n         return false;\n     }\n \n-    public Object previous() {\n+    public E previous() {\n         throw new NoSuchElementException(\"Iterator contains no elements\");\n     }\n \n         return -1;\n     }\n \n-    public void add(Object obj) {\n+    public void add(E obj) {\n         throw new UnsupportedOperationException(\"add() not supported for empty Iterator\");\n     }\n \n-    public void set(Object obj) {\n+    public void set(E obj) {\n         throw new IllegalStateException(\"Iterator contains no elements\");\n     }\n \n     public void remove() {\n-        throw new IllegalStateException(\"Iterator contains no elements\");\n-    }\n-\n-    public Object getKey() {\n-        throw new IllegalStateException(\"Iterator contains no elements\");\n-    }\n-\n-    public Object getValue() {\n-        throw new IllegalStateException(\"Iterator contains no elements\");\n-    }\n-\n-    public Object setValue(Object value) {\n         throw new IllegalStateException(\"Iterator contains no elements\");\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/AbstractIteratorDecorator.java\n+++ b/src/java/org/apache/commons/collections/iterators/AbstractIteratorDecorator.java\n \n import java.util.Iterator;\n \n-/** \n+/**\n  * Provides basic behaviour for decorating an iterator with extra functionality.\n  * <p>\n  * All methods are forwarded to the decorated iterator.\n  * @author James Strachan\n  * @author Stephen Colebourne\n  */\n-public class AbstractIteratorDecorator implements Iterator {\n-\n-    /** The iterator being decorated */\n-    protected final Iterator iterator;\n+public abstract class AbstractIteratorDecorator<E> extends AbstractUntypedIteratorDecorator<E, E> {\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractIteratorDecorator(Iterator iterator) {\n-        super();\n-        if (iterator == null) {\n-            throw new IllegalArgumentException(\"Iterator must not be null\");\n-        }\n-        this.iterator = iterator;\n+    protected AbstractIteratorDecorator(Iterator<E> iterator) {\n+        super(iterator);\n     }\n \n-    /**\n-     * Gets the iterator being decorated.\n-     * \n-     * @return the decorated iterator\n-     */\n-    protected Iterator getIterator() {\n-        return iterator;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public boolean hasNext() {\n-        return iterator.hasNext();\n-    }\n-\n-    public Object next() {\n-        return iterator.next();\n-    }\n-\n-    public void remove() {\n-        iterator.remove();\n+    public E next() {\n+        return getIterator().next();\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/iterators/AbstractMapIteratorDecorator.java\n+++ b/src/java/org/apache/commons/collections/iterators/AbstractMapIteratorDecorator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class AbstractMapIteratorDecorator implements MapIterator {\n+public class AbstractMapIteratorDecorator<K, V> implements MapIterator<K, V> {\n \n     /** The iterator being decorated */\n-    protected final MapIterator iterator;\n+    protected final MapIterator<K, V> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractMapIteratorDecorator(MapIterator iterator) {\n+    public AbstractMapIteratorDecorator(MapIterator<K, V> iterator) {\n         super();\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"MapIterator must not be null\");\n      * \n      * @return the decorated iterator\n      */\n-    protected MapIterator getMapIterator() {\n+    protected MapIterator<K, V> getMapIterator() {\n         return iterator;\n     }\n \n         return iterator.hasNext();\n     }\n \n-    public Object next() {\n+    public K next() {\n         return iterator.next();\n     }\n \n         iterator.remove();\n     }\n     \n-    public Object getKey() {\n+    public K getKey() {\n         return iterator.getKey();\n     }\n \n-    public Object getValue() {\n+    public V getValue() {\n         return iterator.getValue();\n     }\n \n-    public Object setValue(Object obj) {\n+    public V setValue(V obj) {\n         return iterator.setValue(obj);\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorDecorator.java\n+++ b/src/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorDecorator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class AbstractOrderedMapIteratorDecorator implements OrderedMapIterator {\n+public class AbstractOrderedMapIteratorDecorator<K, V> implements OrderedMapIterator<K, V> {\n \n     /** The iterator being decorated */\n-    protected final OrderedMapIterator iterator;\n+    protected final OrderedMapIterator<K, V> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractOrderedMapIteratorDecorator(OrderedMapIterator iterator) {\n+    public AbstractOrderedMapIteratorDecorator(OrderedMapIterator<K, V> iterator) {\n         super();\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n      * \n      * @return the decorated iterator\n      */\n-    protected OrderedMapIterator getOrderedMapIterator() {\n+    protected OrderedMapIterator<K, V> getOrderedMapIterator() {\n         return iterator;\n     }\n \n         return iterator.hasNext();\n     }\n \n-    public Object next() {\n+    public K next() {\n         return iterator.next();\n     }\n \n         return iterator.hasPrevious();\n     }\n \n-    public Object previous() {\n+    public K previous() {\n         return iterator.previous();\n     }\n \n         iterator.remove();\n     }\n     \n-    public Object getKey() {\n+    public K getKey() {\n         return iterator.getKey();\n     }\n \n-    public Object getValue() {\n+    public V getValue() {\n         return iterator.getValue();\n     }\n \n-    public Object setValue(Object obj) {\n+    public V setValue(V obj) {\n         return iterator.setValue(obj);\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/CollatingIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/CollatingIterator.java\n import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n- * Provides an ordered iteration over the elements contained in\n- * a collection of ordered Iterators.\n+ * Provides an ordered iteration over the elements contained in a collection of\n+ * ordered Iterators.\n  * <p>\n- * Given two ordered {@link Iterator} instances <code>A</code> and <code>B</code>,\n- * the {@link #next} method on this iterator will return the lesser of \n- * <code>A.next()</code> and <code>B.next()</code>.\n+ * Given two ordered {@link Iterator} instances <code>A</code> and\n+ * <code>B</code>, the {@link #next} method on this iterator will return the\n+ * lesser of <code>A.next()</code> and <code>B.next()</code>.\n  *\n  * @since Commons Collections 2.1\n  * @version $Revision$ $Date$\n  * @author Rodney Waldhoff\n  * @author Stephen Colebourne\n  */\n-public class CollatingIterator implements Iterator {\n+public class CollatingIterator<E> implements Iterator<E> {\n \n     /** The {@link Comparator} used to evaluate order. */\n-    private Comparator comparator = null;\n+    private Comparator<? super E> comparator = null;\n \n     /** The list of {@link Iterator}s to evaluate. */\n-    private ArrayList iterators = null;\n-   \n+    private ArrayList<Iterator<? extends E>> iterators = null;\n+\n     /** {@link Iterator#next Next} objects peeked from each iterator. */\n-    private ArrayList values = null;\n-    \n+    private ArrayList<E> values = null;\n+\n     /** Whether or not each {@link #values} element has been set. */\n     private BitSet valueSet = null;\n \n-    /** Index of the {@link #iterators iterator} from whom the last returned value was obtained. */\n+    /**\n+     * Index of the {@link #iterators iterator} from whom the last returned\n+     * value was obtained.\n+     */\n     private int lastReturned = -1;\n \n     // Constructors\n     // ----------------------------------------------------------------------\n     /**\n-     * Constructs a new <code>CollatingIterator</code>.  Natural sort order\n-     * will be used, and child iterators will have to be manually added \n-     * using the {@link #addIterator(Iterator)} method.\n+     * Constructs a new <code>CollatingIterator</code>. Natural sort order will\n+     * be used, and child iterators will have to be manually added using the\n+     * {@link #addIterator(Iterator)} method.\n      */\n     public CollatingIterator() {\n-        this(null,2);\n-    }\n-    \n+        this(null, 2);\n+    }\n+\n     /**\n      * Constructs a new <code>CollatingIterator</code> that will used the\n-     * specified comparator for ordering.  Child iterators will have to be \n+     * specified comparator for ordering. Child iterators will have to be\n      * manually added using the {@link #addIterator(Iterator)} method.\n-     *\n-     * @param comp  the comparator to use to sort, or null to use natural sort order\n-     */\n-    public CollatingIterator(final Comparator comp) {\n-        this(comp,2);\n-    }\n-    \n+     * \n+     * @param comp the comparator to use to sort, or null to use natural sort\n+     * order\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp) {\n+        this(comp, 2);\n+    }\n+\n     /**\n      * Constructs a new <code>CollatingIterator</code> that will used the\n      * specified comparator for ordering and have the specified initial\n-     * capacity.  Child iterators will have to be \n-     * manually added using the {@link #addIterator(Iterator)} method.\n-     *\n-     * @param comp  the comparator to use to sort, or null to use natural sort order\n-     * @param initIterCapacity  the initial capacity for the internal list\n-     *    of child iterators\n-     */\n-    public CollatingIterator(final Comparator comp, final int initIterCapacity) {\n-        iterators = new ArrayList(initIterCapacity);\n+     * capacity. Child iterators will have to be manually added using the\n+     * {@link #addIterator(Iterator)} method.\n+     * \n+     * @param comp the comparator to use to sort, or null to use natural sort\n+     * order\n+     * @param initIterCapacity the initial capacity for the internal list of\n+     * child iterators\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final int initIterCapacity) {\n+        iterators = new ArrayList<Iterator<? extends E>>(initIterCapacity);\n         setComparator(comp);\n     }\n \n     /**\n      * Constructs a new <code>CollatingIterator</code> that will use the\n-     * specified comparator to provide ordered iteration over the two\n-     * given iterators.\n-     *\n-     * @param comp  the comparator to use to sort, or null to use natural sort order\n-     * @param a  the first child ordered iterator\n-     * @param b  the second child ordered iterator\n+     * specified comparator to provide ordered iteration over the two given\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort, or null to use natural sort\n+     * order\n+     * @param a the first child ordered iterator\n+     * @param b the second child ordered iterator\n      * @throws NullPointerException if either iterator is null\n      */\n-    public CollatingIterator(final Comparator comp, final Iterator a, final Iterator b) {\n-        this(comp,2);\n+    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E> a, final Iterator<? extends E> b) {\n+        this(comp, 2);\n         addIterator(a);\n         addIterator(b);\n     }\n \n     /**\n      * Constructs a new <code>CollatingIterator</code> that will use the\n-     * specified comparator to provide ordered iteration over the array\n-     * of iterators.\n-     *\n-     * @param comp  the comparator to use to sort, or null to use natural sort order\n-     * @param iterators  the array of iterators\n+     * specified comparator to provide ordered iteration over the array of\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort, or null to use natural sort\n+     * order\n+     * @param iterators the array of iterators\n      * @throws NullPointerException if iterators array is or contains null\n      */\n-    public CollatingIterator(final Comparator comp, final Iterator[] iterators) {\n+    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators) {\n         this(comp, iterators.length);\n         for (int i = 0; i < iterators.length; i++) {\n             addIterator(iterators[i]);\n \n     /**\n      * Constructs a new <code>CollatingIterator</code> that will use the\n-     * specified comparator to provide ordered iteration over the collection\n-     * of iterators.\n-     *\n-     * @param comp  the comparator to use to sort, or null to use natural sort order\n-     * @param iterators  the collection of iterators\n-     * @throws NullPointerException if the iterators collection is or contains null\n+     * specified comparator to provide ordered iteration over the collection of\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort, or null to use natural sort\n+     * order\n+     * @param iterators the collection of iterators\n+     * @throws NullPointerException if the iterators collection is or contains\n+     * null\n      * @throws ClassCastException if the iterators collection contains an\n-     *         element that's not an {@link Iterator}\n-     */\n-    public CollatingIterator(final Comparator comp, final Collection iterators) {\n+     * element that's not an {@link Iterator}\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators) {\n         this(comp, iterators.size());\n-        for (Iterator it = iterators.iterator(); it.hasNext();) {\n-            Iterator item = (Iterator) it.next();\n-            addIterator(item);\n+        for (Iterator<? extends E> iterator : iterators) {\n+            addIterator(iterator);\n         }\n     }\n \n     /**\n      * Adds the given {@link Iterator} to the iterators being collated.\n      * \n-     * @param iterator  the iterator to add to the collation, must not be null\n+     * @param iterator the iterator to add to the collation, must not be null\n      * @throws IllegalStateException if iteration has started\n      * @throws NullPointerException if the iterator is null\n      */\n-    public void addIterator(final Iterator iterator) {\n+    public void addIterator(final Iterator<? extends E> iterator) {\n         checkNotStarted();\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n     /**\n      * Sets the iterator at the given index.\n      * \n-     * @param index  index of the Iterator to replace\n-     * @param iterator  Iterator to place at the given index\n+     * @param index index of the Iterator to replace\n+     * @param iterator Iterator to place at the given index\n      * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n      * @throws IllegalStateException if iteration has started\n      * @throws NullPointerException if the iterator is null\n      */\n-    public void setIterator(final int index, final Iterator iterator) {\n+    public void setIterator(final int index, final Iterator<? extends E> iterator) {\n         checkNotStarted();\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n      * \n      * @return the unmodifiable list of iterators added\n      */\n-    public List getIterators() {\n+    public List<Iterator<? extends E>> getIterators() {\n         return UnmodifiableList.decorate(iterators);\n     }\n \n     /**\n      * Gets the {@link Comparator} by which collatation occurs.\n      */\n-    public Comparator getComparator() {\n+    public Comparator<? super E> getComparator() {\n         return comparator;\n     }\n \n      * \n      * @throws IllegalStateException if iteration has started\n      */\n-    public void setComparator(final Comparator comp) {\n+    public void setComparator(final Comparator<? super E> comp) {\n         checkNotStarted();\n         comparator = comp;\n     }\n     // -------------------------------------------------------------------\n     /**\n      * Returns <code>true</code> if any child iterator has remaining elements.\n-     *\n+     * \n      * @return true if this iterator has remaining elements\n      */\n     public boolean hasNext() {\n \n     /**\n      * Returns the next ordered element from a child iterator.\n-     *\n+     * \n      * @return the next ordered element\n      * @throws NoSuchElementException if no child iterator has any more elements\n      */\n-    public Object next() throws NoSuchElementException {\n+    public E next() throws NoSuchElementException {\n         if (hasNext() == false) {\n             throw new NoSuchElementException();\n         }\n         int leastIndex = least();\n         if (leastIndex == -1) {\n             throw new NoSuchElementException();\n-        } else {\n-            Object val = values.get(leastIndex);\n-            clear(leastIndex);\n-            lastReturned = leastIndex;\n-            return val;\n-        }\n-    }\n-\n-    /**\n-     * Removes the last returned element from the child iterator that \n-     * produced it.\n-     *\n-     * @throws IllegalStateException if there is no last returned element,\n-     *  or if the last returned element has already been removed\n+        }\n+        E val = values.get(leastIndex);\n+        clear(leastIndex);\n+        lastReturned = leastIndex;\n+        return val;\n+    }\n+\n+    /**\n+     * Removes the last returned element from the child iterator that produced\n+     * it.\n+     * \n+     * @throws IllegalStateException if there is no last returned element, or if\n+     * the last returned element has already been removed\n      */\n     public void remove() {\n         if (lastReturned == -1) {\n             throw new IllegalStateException(\"No value can be removed at present\");\n         }\n-        Iterator it = (Iterator) (iterators.get(lastReturned));\n-        it.remove();\n+        iterators.get(lastReturned).remove();\n     }\n \n     /**\n     \n     // Private Methods\n     // -------------------------------------------------------------------\n-    /** \n+    /**\n      * Initializes the collating state if it hasn't been already.\n      */\n     private void start() {\n         if (values == null) {\n-            values = new ArrayList(iterators.size());\n+            values = new ArrayList<E>(iterators.size());\n             valueSet = new BitSet(iterators.size());\n             for (int i = 0; i < iterators.size(); i++) {\n                 values.add(null);\n         }\n     }\n \n-    /** \n-     * Sets the {@link #values} and {@link #valueSet} attributes \n-     * at position <i>i</i> to the next value of the \n-     * {@link #iterators iterator} at position <i>i</i>, or \n-     * clear them if the <i>i</i><sup>th</sup> iterator\n-     * has no next value.\n-     *\n+    /**\n+     * Sets the {@link #values} and {@link #valueSet} attributes at position\n+     * <i>i</i> to the next value of the {@link #iterators iterator} at position\n+     * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n+     * value.\n+     * \n      * @return <tt>false</tt> iff there was no value to set\n      */\n     private boolean set(int i) {\n-        Iterator it = (Iterator)(iterators.get(i));\n+        Iterator<? extends E> it = iterators.get(i);\n         if (it.hasNext()) {\n             values.set(i, it.next());\n             valueSet.set(i);\n             return true;\n-        } else {\n-            values.set(i,null);\n-            valueSet.clear(i);\n-            return false;\n-        }\n-    }\n-\n-    /** \n-     * Clears the {@link #values} and {@link #valueSet} attributes \n-     * at position <i>i</i>.\n+        }\n+        values.set(i, null);\n+        valueSet.clear(i);\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the {@link #values} and {@link #valueSet} attributes at position\n+     * <i>i</i>.\n      */\n     private void clear(int i) {\n-        values.set(i,null);\n+        values.set(i, null);\n         valueSet.clear(i);\n     }\n \n-    /** \n-     * Throws {@link IllegalStateException} if iteration has started \n-     * via {@link #start}.\n+    /**\n+     * Throws {@link IllegalStateException} if iteration has started via\n+     * {@link #start}.\n      * \n      * @throws IllegalStateException if iteration started\n      */\n         }\n     }\n \n-    /** \n+    /**\n      * Returns the index of the least element in {@link #values},\n      * {@link #set(int) setting} any uninitialized values.\n      * \n      */\n     private int least() {\n         int leastIndex = -1;\n-        Object leastObject = null;                \n+        E leastObject = null;\n         for (int i = 0; i < values.size(); i++) {\n             if (valueSet.get(i) == false) {\n                 set(i);\n                     leastIndex = i;\n                     leastObject = values.get(i);\n                 } else {\n-                    Object curObject = values.get(i);\n-                    if (comparator.compare(curObject,leastObject) < 0) {\n+                    E curObject = values.get(i);\n+                    if (comparator.compare(curObject, leastObject) < 0) {\n                         leastObject = curObject;\n                         leastIndex = i;\n                     }\n     }\n \n     /**\n-     * Returns <code>true</code> iff any bit in the given set is \n+     * Returns <code>true</code> iff any bit in the given set is\n      * <code>true</code>.\n      */\n     private boolean anyValueSet(BitSet set) {\n     }\n \n     /**\n-     * Returns <code>true</code> iff any {@link Iterator} \n-     * in the given list has a next value.\n-     */\n-    private boolean anyHasNext(ArrayList iters) {\n-        for (int i = 0; i < iters.size(); i++) {\n-            Iterator it = (Iterator) iters.get(i);\n-            if (it.hasNext()) {\n+     * Returns <code>true</code> iff any {@link Iterator} in the given list has\n+     * a next value.\n+     */\n+    private boolean anyHasNext(ArrayList<Iterator<? extends E>> iters) {\n+        for (Iterator<? extends E> iterator : iters) {\n+            if (iterator.hasNext()) {\n                 return true;\n             }\n         }\n--- a/src/java/org/apache/commons/collections/iterators/EmptyIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class EmptyIterator extends AbstractEmptyIterator implements ResettableIterator {\n+public class EmptyIterator<E> extends AbstractEmptyIterator<E> implements ResettableIterator<E> {\n \n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 3.1\n      */\n-    public static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator();\n+    public static final ResettableIterator<Object> RESETTABLE_INSTANCE = new EmptyIterator<Object>();\n+\n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 2.1.1 and 3.1\n      */\n-    public static final Iterator INSTANCE = RESETTABLE_INSTANCE;\n+    public static final Iterator<Object> INSTANCE = RESETTABLE_INSTANCE;\n+\n+    /**\n+     * Get a typed resettable empty iterator instance.\n+     * @param <E>\n+     * @return ResettableIterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ResettableIterator<E> getResettableInstance() {\n+        return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed empty iterator instance.\n+     * @param <E>\n+     * @return Iterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Iterator<E> getInstance() {\n+        return (Iterator<E>) INSTANCE;\n+    }\n \n     /**\n      * Constructor.\n--- a/src/java/org/apache/commons/collections/iterators/EmptyListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyListIterator.java\n \n import org.apache.commons.collections.ResettableListIterator;\n \n-/** \n+/**\n  * Provides an implementation of an empty list iterator.\n  * <p>\n- * This class provides an implementation of an empty list iterator.\n- * This class provides for binary compatability between Commons Collections\n- * 2.1.1 and 3.1 due to issues with <code>IteratorUtils</code>.\n+ * This class provides an implementation of an empty list iterator. This class\n+ * provides for binary compatability between Commons Collections 2.1.1 and 3.1\n+ * due to issues with <code>IteratorUtils</code>.\n  *\n  * @since Commons Collections 2.1.1 and 3.1\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public class EmptyListIterator extends AbstractEmptyIterator implements ResettableListIterator {\n+public class EmptyListIterator<E> extends AbstractEmptyIterator<E> implements\n+        ResettableListIterator<E> {\n \n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 3.1\n      */\n-    public static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator();\n+    public static final ResettableListIterator<Object> RESETTABLE_INSTANCE = new EmptyListIterator<Object>();\n+\n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 2.1.1 and 3.1\n      */\n-    public static final ListIterator INSTANCE = RESETTABLE_INSTANCE;\n+    public static final ListIterator<Object> INSTANCE = RESETTABLE_INSTANCE;\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <E>\n+     * @return {@link ResettableListIterator}<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ResettableListIterator<E> getResettableInstance() {\n+        return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <E>\n+     * @return {@link ListIterator}<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ListIterator<E> getInstance() {\n+        return (ListIterator<E>) INSTANCE;\n+    }\n \n     /**\n      * Constructor.\n--- a/src/java/org/apache/commons/collections/iterators/EmptyMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyMapIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class EmptyMapIterator extends AbstractEmptyIterator implements MapIterator, ResettableIterator {\n+public class EmptyMapIterator<K, V> extends AbstractEmptyMapIterator<K, V> implements\n+        MapIterator<K, V>, ResettableIterator<K> {\n \n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 3.1\n      */\n-    public static final MapIterator INSTANCE = new EmptyMapIterator();\n+    public static final MapIterator<Object, Object> INSTANCE = new EmptyMapIterator<Object, Object>();\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <K>\n+     * @param <V>\n+     * @return {@link MapIterator}<K, V>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> MapIterator<K, V> getInstance() {\n+        return (MapIterator<K, V>) INSTANCE;\n+    }\n \n     /**\n      * Constructor.\n--- a/src/java/org/apache/commons/collections/iterators/EmptyOrderedIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyOrderedIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class EmptyOrderedIterator extends AbstractEmptyIterator implements OrderedIterator, ResettableIterator {\n+public class EmptyOrderedIterator<E> extends AbstractEmptyIterator<E> implements OrderedIterator<E>, ResettableIterator<E> {\n \n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 3.1\n      */\n-    public static final OrderedIterator INSTANCE = new EmptyOrderedIterator();\n+    public static final OrderedIterator<Object> INSTANCE = new EmptyOrderedIterator<Object>();\n+\n+    /**\n+     * Typed instance of the iterator.\n+     * @param <E>\n+     * @return OrderedIterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> OrderedIterator<E> getInstance() {\n+        return (OrderedIterator<E>) INSTANCE;\n+    }\n \n     /**\n      * Constructor.\n--- a/src/java/org/apache/commons/collections/iterators/EmptyOrderedMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyOrderedMapIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class EmptyOrderedMapIterator extends AbstractEmptyIterator implements OrderedMapIterator, ResettableIterator {\n+public class EmptyOrderedMapIterator<K, V> extends AbstractEmptyMapIterator<K, V> implements\n+        OrderedMapIterator<K, V>, ResettableIterator<K> {\n \n     /**\n      * Singleton instance of the iterator.\n      * @since Commons Collections 3.1\n      */\n-    public static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator();\n+    public static final OrderedMapIterator<Object, Object> INSTANCE = new EmptyOrderedMapIterator<Object, Object>();\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <K>\n+     * @param <V>\n+     * @return {@link OrderedMapIterator}<K, V>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> OrderedMapIterator<K, V> getInstance() {\n+        return (OrderedMapIterator<K, V>) INSTANCE;\n+    }\n \n     /**\n      * Constructor.\n--- a/src/java/org/apache/commons/collections/iterators/EntrySetMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EntrySetMapIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class EntrySetMapIterator implements MapIterator, ResettableIterator {\n+public class EntrySetMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n     \n-    private final Map map;\n-    private Iterator iterator;\n-    private Map.Entry last;\n+    private final Map<K, V> map;\n+    private Iterator<Map.Entry<K, V>> iterator;\n+    private Map.Entry<K, V> last;\n     private boolean canRemove = false;\n     \n     /**\n      * \n      * @param map  the map to iterate over\n      */\n-    public EntrySetMapIterator(Map map) {\n+    public EntrySetMapIterator(Map<K, V> map) {\n         super();\n         this.map = map;\n         this.iterator = map.entrySet().iterator();\n      * @return the next key in the iteration\n      * @throws java.util.NoSuchElementException if the iteration is finished\n      */\n-    public Object next() {\n-        last = (Map.Entry) iterator.next();\n+    public K next() {\n+        last = (Map.Entry<K, V>) iterator.next();\n         canRemove = true;\n         return last.getKey();\n     }\n      * @return the current key\n      * @throws IllegalStateException if <code>next()</code> has not yet been called\n      */\n-    public Object getKey() {\n+    public K getKey() {\n         if (last == null) {\n             throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n         }\n      * @return the current value\n      * @throws IllegalStateException if <code>next()</code> has not yet been called\n      */\n-    public Object getValue() {\n+    public V getValue() {\n         if (last == null) {\n             throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n         }\n      * @throws IllegalStateException if <code>remove()</code> has been called since the\n      *  last call to <code>next()</code>\n      */\n-    public Object setValue(Object value) {\n+    public V setValue(V value) {\n         if (last == null) {\n             throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n         }\n     public String toString() {\n         if (last != null) {\n             return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n-        } else {\n-            return \"MapIterator[]\";\n         }\n+        return \"MapIterator[]\";\n     }\n     \n }\n--- a/src/java/org/apache/commons/collections/iterators/EnumerationIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EnumerationIterator.java\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n  */\n-public class EnumerationIterator implements Iterator {\n+public class EnumerationIterator<E> implements Iterator<E> {\n     \n     /** The collection to remove elements from */\n-    private Collection collection;\n+    private Collection<? super E> collection;\n     /** The enumeration being converted */\n-    private Enumeration enumeration;\n+    private Enumeration<? extends E> enumeration;\n     /** The last object retrieved */\n-    private Object last;\n+    private E last;\n     \n     // Constructors\n     //-----------------------------------------------------------------------\n      *\n      * @param enumeration  the enumeration to use\n      */\n-    public EnumerationIterator(final Enumeration enumeration) {\n+    public EnumerationIterator(final Enumeration<? extends E> enumeration) {\n         this(enumeration, null);\n     }\n \n      * elements from the specified collection.\n      *\n      * @param enumeration  the enumeration to use\n-     * @param collection  the collection to remove elements form\n+     * @param collection  the collection to remove elements from\n      */\n-    public EnumerationIterator(final Enumeration enumeration, final Collection collection) {\n+    public EnumerationIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> collection) {\n         super();\n         this.enumeration = enumeration;\n         this.collection = collection;\n      * @return the next object from the enumeration\n      * @throws NullPointerException if the enumeration is null\n      */\n-    public Object next() {\n+    public E next() {\n         last = enumeration.nextElement();\n         return last;\n     }\n      *\n      * @return the underlying enumeration\n      */\n-    public Enumeration getEnumeration() {\n+    public Enumeration<? extends E> getEnumeration() {\n         return enumeration;\n     }\n \n      *\n      * @param enumeration  the new underlying enumeration\n      */\n-    public void setEnumeration(final Enumeration enumeration) {\n+    public void setEnumeration(final Enumeration<? extends E> enumeration) {\n         this.enumeration = enumeration;\n     }\n     \n--- a/src/java/org/apache/commons/collections/iterators/FilterIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/FilterIterator.java\n  * @author Ralph Wagner\n  * @author Stephen Colebourne\n  */\n-public class FilterIterator implements Iterator {\n+public class FilterIterator<E> implements Iterator<E> {\n \n     /** The iterator being used */\n-    private Iterator iterator;\n+    private Iterator<? extends E> iterator;\n     /** The predicate being used */\n-    private Predicate predicate;\n+    private Predicate<? super E> predicate;\n     /** The next object in the iteration */\n-    private Object nextObject;\n+    private E nextObject;\n     /** Whether the next object has been calculated yet */\n     private boolean nextObjectSet = false;\n \n      *\n      * @param iterator  the iterator to use\n      */\n-    public FilterIterator(Iterator iterator) {\n+    public FilterIterator(Iterator<? extends E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n      * @param iterator  the iterator to use\n      * @param predicate  the predicate to use\n      */\n-    public FilterIterator(Iterator iterator, Predicate predicate) {\n+    public FilterIterator(Iterator<? extends E> iterator, Predicate<? super E> predicate) {\n         super();\n         this.iterator = iterator;\n         this.predicate = predicate;\n      * @throws NullPointerException if either the iterator or predicate are null\n      */\n     public boolean hasNext() {\n-        if (nextObjectSet) {\n-            return true;\n-        } else {\n-            return setNextObject();\n-        }\n+        return nextObjectSet || setNextObject();\n     }\n \n     /** \n      * @throws NoSuchElementException if there are no more elements that\n      *  match the predicate \n      */\n-    public Object next() {\n+    public E next() {\n         if (!nextObjectSet) {\n             if (!setNextObject()) {\n                 throw new NoSuchElementException();\n      *\n      * @return the iterator\n      */\n-    public Iterator getIterator() {\n+    public Iterator<? extends E> getIterator() {\n         return iterator;\n     }\n \n      *\n      * @param iterator  the iterator to use\n      */\n-    public void setIterator(Iterator iterator) {\n+    public void setIterator(Iterator<? extends E> iterator) {\n         this.iterator = iterator;\n         nextObject = null;\n         nextObjectSet = false;\n      *\n      * @return the predicate\n      */\n-    public Predicate getPredicate() {\n+    public Predicate<? super E> getPredicate() {\n         return predicate;\n     }\n \n      *\n      * @param predicate  the predicate to use\n      */\n-    public void setPredicate(Predicate predicate) {\n+    public void setPredicate(Predicate<? super E> predicate) {\n         this.predicate = predicate;\n         nextObject = null;\n         nextObjectSet = false;\n      */\n     private boolean setNextObject() {\n         while (iterator.hasNext()) {\n-            Object object = iterator.next();\n+            E object = iterator.next();\n             if (predicate.evaluate(object)) {\n                 nextObject = object;\n                 nextObjectSet = true;\n--- a/src/java/org/apache/commons/collections/iterators/FilterListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/FilterListIterator.java\n  *\n  * @author Rodney Waldhoff\n  */\n-public class FilterListIterator implements ListIterator {\n+public class FilterListIterator<E> implements ListIterator<E> {\n \n     /** The iterator being used */\n-    private ListIterator iterator;\n+    private ListIterator<? extends E> iterator;\n     \n     /** The predicate being used */\n-    private Predicate predicate;\n+    private Predicate<? super E> predicate;\n \n     /** \n      * The value of the next (matching) object, when \n      * {@link #nextObjectSet} is true. \n      */\n-    private Object nextObject;\n+    private E nextObject;\n \n     /** \n      * Whether or not the {@link #nextObject} has been set\n      * The value of the previous (matching) object, when \n      * {@link #previousObjectSet} is true. \n      */\n-    private Object previousObject;\n+    private E previousObject;\n \n     /** \n      * Whether or not the {@link #previousObject} has been set\n      *\n      * @param iterator  the iterator to use\n      */\n-    public FilterListIterator(ListIterator iterator ) {\n+    public FilterListIterator(ListIterator<? extends E> iterator ) {\n         super();\n         this.iterator = iterator;\n     }\n      * @param iterator  the iterator to use\n      * @param predicate  the predicate to use\n      */\n-    public FilterListIterator(ListIterator iterator, Predicate predicate) {\n+    public FilterListIterator(ListIterator<? extends E> iterator, Predicate<? super E> predicate) {\n         super();\n         this.iterator = iterator;\n         this.predicate = predicate;\n      *\n      * @param predicate  the predicate to use.\n      */\n-    public FilterListIterator(Predicate predicate) {\n+    public FilterListIterator(Predicate<? super E> predicate) {\n         super();\n         this.predicate = predicate;\n     }\n \n     //-----------------------------------------------------------------------\n     /** Not supported. */\n-    public void add(Object o) {\n+    public void add(E o) {\n         throw new UnsupportedOperationException(\"FilterListIterator.add(Object) is not supported.\");\n     }\n \n     public boolean hasNext() {\n-        if(nextObjectSet) {\n-            return true;\n-        } else {\n-            return setNextObject();\n-        }\n+        return nextObjectSet || setNextObject();\n     }\n \n     public boolean hasPrevious() {\n-        if(previousObjectSet) {\n-            return true;\n-        } else {\n-            return setPreviousObject();\n-        }\n-    }\n-\n-    public Object next() {\n-        if(!nextObjectSet) {\n-            if(!setNextObject()) {\n+        return previousObjectSet || setPreviousObject();\n+    }\n+\n+    public E next() {\n+        if (!nextObjectSet) {\n+            if (!setNextObject()) {\n                 throw new NoSuchElementException();\n             }\n         }\n         nextIndex++;\n-        Object temp = nextObject;\n+        E temp = nextObject;\n         clearNextObject();\n         return temp;\n     }\n         return nextIndex;\n     }\n \n-    public Object previous() {\n-        if(!previousObjectSet) {\n-            if(!setPreviousObject()) {\n+    public E previous() {\n+        if (!previousObjectSet) {\n+            if (!setPreviousObject()) {\n                 throw new NoSuchElementException();\n             }\n         }\n         nextIndex--;\n-        Object temp = previousObject;\n+        E temp = previousObject;\n         clearPreviousObject();\n         return temp;\n     }\n     }\n \n     /** Not supported. */\n-    public void set(Object o) {\n+    public void set(E o) {\n         throw new UnsupportedOperationException(\"FilterListIterator.set(Object) is not supported.\");\n     }\n \n      * \n      * @return the iterator.\n      */\n-    public ListIterator getListIterator() {\n+    public ListIterator<? extends E> getListIterator() {\n         return iterator;\n     }\n \n      * \n      * @param iterator  the iterator to use\n      */\n-    public void setListIterator(ListIterator iterator) {\n+    public void setListIterator(ListIterator<? extends E> iterator) {\n         this.iterator = iterator;\n     }\n \n      * \n      * @return the predicate.\n      */\n-    public Predicate getPredicate() {\n+    public Predicate<? super E> getPredicate() {\n         return predicate;\n     }\n \n      * \n      * @param predicate  the transformer to use\n      */\n-    public void setPredicate(Predicate predicate) {\n+    public void setPredicate(Predicate<? super E> predicate) {\n         this.predicate = predicate;\n     }\n \n         // then we've walked back one step in the \n         // underlying list (due to a hasPrevious() call)\n         // so skip ahead one matching object\n-        if(previousObjectSet) {\n+        if (previousObjectSet) {\n             clearPreviousObject();\n-            if(!setNextObject()) {\n+            if (!setNextObject()) {\n                 return false;\n-            } else {\n-                clearNextObject();\n-            }\n-        }\n-\n-        while(iterator.hasNext()) {\n-            Object object = iterator.next();\n-            if(predicate.evaluate(object)) {\n+            }\n+            clearNextObject();\n+        }\n+\n+        while (iterator.hasNext()) {\n+            E object = iterator.next();\n+            if (predicate.evaluate(object)) {\n                 nextObject = object;\n                 nextObjectSet = true;\n                 return true;\n         // then we've walked back one step in the \n         // underlying list (due to a hasNext() call)\n         // so skip ahead one matching object\n-        if(nextObjectSet) {\n+        if (nextObjectSet) {\n             clearNextObject();\n-            if(!setPreviousObject()) {\n+            if (!setPreviousObject()) {\n                 return false;\n-            } else {\n-                clearPreviousObject();\n-            }\n-        }\n-\n-        while(iterator.hasPrevious()) {\n-            Object object = iterator.previous();\n-            if(predicate.evaluate(object)) {\n+            }\n+            clearPreviousObject();\n+        }\n+\n+        while (iterator.hasPrevious()) {\n+            E object = iterator.previous();\n+            if (predicate.evaluate(object)) {\n                 previousObject = object;\n                 previousObjectSet = true;\n                 return true;\n--- a/src/java/org/apache/commons/collections/iterators/IteratorChain.java\n+++ b/src/java/org/apache/commons/collections/iterators/IteratorChain.java\n /**\n  * An IteratorChain is an Iterator that wraps a number of Iterators.\n  * <p>\n- * This class makes multiple iterators look like one to the caller\n- * When any method from the Iterator interface is called, the IteratorChain\n- * will delegate to a single underlying Iterator. The IteratorChain will\n- * invoke the Iterators in sequence until all Iterators are exhausted.\n+ * This class makes multiple iterators look like one to the caller When any\n+ * method from the Iterator interface is called, the IteratorChain will delegate\n+ * to a single underlying Iterator. The IteratorChain will invoke the Iterators\n+ * in sequence until all Iterators are exhausted.\n  * <p>\n- * Under many circumstances, linking Iterators together in this manner is\n- * more efficient (and convenient) than reading out the contents of each\n- * Iterator into a List and creating a new Iterator.\n+ * Under many circumstances, linking Iterators together in this manner is more\n+ * efficient (and convenient) than reading out the contents of each Iterator\n+ * into a List and creating a new Iterator.\n  * <p>\n  * Calling a method that adds new Iterator<i>after a method in the Iterator\n- * interface has been called</i> will result in an UnsupportedOperationException.\n- * Subclasses should <i>take care</i> to not alter the underlying List of Iterators.\n+ * interface has been called</i> will result in an\n+ * UnsupportedOperationException. Subclasses should <i>take care</i> to not\n+ * alter the underlying List of Iterators.\n  * <p>\n- * NOTE: As from version 3.0, the IteratorChain may contain no\n- * iterators. In this case the class will function as an empty iterator.\n+ * NOTE: As from version 3.0, the IteratorChain may contain no iterators. In\n+ * this case the class will function as an empty iterator.\n  *\n  * @since Commons Collections 2.1\n- * @version $Revision$ $Date$\n+ * @version $Revision$ $Date: 2006-10-27 19:52:37 -0500 (Fri, 27 Oct\n+ * 2006) $\n  *\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public class IteratorChain implements Iterator {\n+public class IteratorChain<E> implements Iterator<E> {\n \n     /** The chain of iterators */\n-    protected final List iteratorChain = new ArrayList();\n+    protected final List<Iterator<? extends E>> iteratorChain = new ArrayList<Iterator<? extends E>>();\n+\n     /** The index of the current iterator */\n     protected int currentIteratorIndex = 0;\n+\n     /** The current iterator */\n-    protected Iterator currentIterator = null;\n-    /**\n-     * The \"last used\" Iterator is the Iterator upon which\n-     * next() or hasNext() was most recently called\n-     * used for the remove() operation only\n-     */\n-    protected Iterator lastUsedIterator = null;\n-    /**\n-     * ComparatorChain is \"locked\" after the first time\n-     * compare(Object,Object) is called\n+    protected Iterator<? extends E> currentIterator = null;\n+\n+    /**\n+     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n+     * was most recently called used for the remove() operation only\n+     */\n+    protected Iterator<? extends E> lastUsedIterator = null;\n+\n+    /**\n+     * ComparatorChain is \"locked\" after the first time compare(Object,Object)\n+     * is called\n      */\n     protected boolean isLocked = false;\n \n     /**\n      * Construct an IteratorChain with no Iterators.\n      * <p>\n-     * You will normally use {@link #addIterator(Iterator)} to add\n-     * some iterators after using this constructor.\n+     * You will normally use {@link #addIterator(Iterator)} to add some\n+     * iterators after using this constructor.\n      */\n     public IteratorChain() {\n         super();\n     /**\n      * Construct an IteratorChain with a single Iterator.\n      * <p>\n-     * This method takes one iterator. The newly constructed iterator\n-     * will iterate through that iterator. Thus calling this constructor\n-     * on its own will have no effect other than decorating the input iterator.\n-     * <p>\n-     * You will normally use {@link #addIterator(Iterator)} to add\n-     * some more iterators after using this constructor.\n-     *\n-     * @param iterator  the first child iterator in the IteratorChain, not null\n+     * This method takes one iterator. The newly constructed iterator will\n+     * iterate through that iterator. Thus calling this constructor on its own\n+     * will have no effect other than decorating the input iterator.\n+     * <p>\n+     * You will normally use {@link #addIterator(Iterator)} to add some more\n+     * iterators after using this constructor.\n+     * \n+     * @param iterator the first child iterator in the IteratorChain, not null\n      * @throws NullPointerException if the iterator is null\n      */\n-    public IteratorChain(Iterator iterator) {\n+    public IteratorChain(Iterator<? extends E> iterator) {\n         super();\n         addIterator(iterator);\n     }\n \n     /**\n-     * Constructs a new <code>IteratorChain</code> over the two\n-     * given iterators.\n-     * <p>\n-     * This method takes two iterators. The newly constructed iterator\n-     * will iterate through each one of the input iterators in turn.\n-     *\n-     * @param first  the first child iterator in the IteratorChain, not null\n-     * @param second  the second child iterator in the IteratorChain, not null\n+     * Constructs a new <code>IteratorChain</code> over the two given iterators.\n+     * <p>\n+     * This method takes two iterators. The newly constructed iterator will\n+     * iterate through each one of the input iterators in turn.\n+     * \n+     * @param first the first child iterator in the IteratorChain, not null\n+     * @param second the second child iterator in the IteratorChain, not null\n      * @throws NullPointerException if either iterator is null\n      */\n-    public IteratorChain(Iterator first, Iterator second) {\n+    public IteratorChain(Iterator<? extends E> first, Iterator<? extends E> second) {\n         super();\n         addIterator(first);\n         addIterator(second);\n     }\n \n     /**\n-     * Constructs a new <code>IteratorChain</code> over the array\n-     * of iterators.\n+     * Constructs a new <code>IteratorChain</code> over the array of iterators.\n      * <p>\n      * This method takes an array of iterators. The newly constructed iterator\n      * will iterate through each one of the input iterators in turn.\n-     *\n-     * @param iteratorChain  the array of iterators, not null\n+     * \n+     * @param iteratorChain the array of iterators, not null\n      * @throws NullPointerException if iterators array is or contains null\n      */\n-    public IteratorChain(Iterator[] iteratorChain) {\n+    public IteratorChain(Iterator<? extends E>[] iteratorChain) {\n         super();\n         for (int i = 0; i < iteratorChain.length; i++) {\n             addIterator(iteratorChain[i]);\n     }\n \n     /**\n-     * Constructs a new <code>IteratorChain</code> over the collection\n-     * of iterators.\n-     * <p>\n-     * This method takes a collection of iterators. The newly constructed iterator\n-     * will iterate through each one of the input iterators in turn.\n-     *\n-     * @param iteratorChain  the collection of iterators, not null\n+     * Constructs a new <code>IteratorChain</code> over the collection of\n+     * iterators.\n+     * <p>\n+     * This method takes a collection of iterators. The newly constructed\n+     * iterator will iterate through each one of the input iterators in turn.\n+     * \n+     * @param iteratorChain the collection of iterators, not null\n      * @throws NullPointerException if iterators collection is or contains null\n-     * @throws ClassCastException if iterators collection doesn't contain an iterator\n-     */\n-    public IteratorChain(Collection iteratorChain) {\n-        super();\n-        for (Iterator it = iteratorChain.iterator(); it.hasNext();) {\n-            Iterator item = (Iterator) it.next();\n-            addIterator(item);\n+     * @throws ClassCastException if iterators collection doesn't contain an\n+     * iterator\n+     */\n+    public IteratorChain(Collection<Iterator<? extends E>> iteratorChain) {\n+        super();\n+        for (Iterator<? extends E> iterator : iteratorChain) {\n+            addIterator(iterator);\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Add an Iterator to the end of the chain\n-     *\n+     * \n      * @param iterator Iterator to add\n      * @throws IllegalStateException if I've already started iterating\n      * @throws NullPointerException if the iterator is null\n      */\n-    public void addIterator(Iterator iterator) {\n+    public void addIterator(Iterator<? extends E> iterator) {\n         checkLocked();\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n \n     /**\n      * Set the Iterator at the given index\n-     *\n-     * @param index      index of the Iterator to replace\n-     * @param iterator   Iterator to place at the given index\n+     * \n+     * @param index index of the Iterator to replace\n+     * @param iterator Iterator to place at the given index\n      * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n      * @throws IllegalStateException if I've already started iterating\n      * @throws NullPointerException if the iterator is null\n      */\n-    public void setIterator(int index, Iterator iterator) throws IndexOutOfBoundsException {\n+    public void setIterator(int index, Iterator<? extends E> iterator)\n+            throws IndexOutOfBoundsException {\n         checkLocked();\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n \n     /**\n      * Get the list of Iterators (unmodifiable)\n-     *\n+     * \n      * @return the unmodifiable list of iterators added\n      */\n-    public List getIterators() {\n+    public List<Iterator<? extends E>> getIterators() {\n         return UnmodifiableList.decorate(iteratorChain);\n     }\n \n     /**\n      * Number of Iterators in the current IteratorChain.\n-     *\n+     * \n      * @return Iterator count\n      */\n     public int size() {\n \n     /**\n      * Determine if modifications can still be made to the IteratorChain.\n-     * IteratorChains cannot be modified once they have executed a method\n-     * from the Iterator interface.\n-     *\n+     * IteratorChains cannot be modified once they have executed a method from\n+     * the Iterator interface.\n+     * \n      * @return true if IteratorChain cannot be modified, false if it can\n      */\n     public boolean isLocked() {\n      */\n     private void checkLocked() {\n         if (isLocked == true) {\n-            throw new UnsupportedOperationException(\"IteratorChain cannot be changed after the first use of a method from the Iterator interface\");\n-        }\n-    }\n-\n-    /**\n-     * Lock the chain so no more iterators can be added.\n-     * This must be called from all Iterator interface methods.\n+            throw new UnsupportedOperationException(\n+                    \"IteratorChain cannot be changed after the first use of a method from the Iterator interface\");\n+        }\n+    }\n+\n+    /**\n+     * Lock the chain so no more iterators can be added. This must be called\n+     * from all Iterator interface methods.\n      */\n     private void lockChain() {\n         if (isLocked == false) {\n     }\n \n     /**\n-     * Updates the current iterator field to ensure that the current Iterator\n-     * is not exhausted\n+     * Updates the current iterator field to ensure that the current Iterator is\n+     * not exhausted\n      */\n     protected void updateCurrentIterator() {\n         if (currentIterator == null) {\n             if (iteratorChain.isEmpty()) {\n-                currentIterator = EmptyIterator.INSTANCE;\n+                currentIterator = EmptyIterator.<E> getInstance();\n             } else {\n-                currentIterator = (Iterator) iteratorChain.get(0);\n+                currentIterator = iteratorChain.get(0);\n             }\n             // set last used iterator here, in case the user calls remove\n             // before calling hasNext() or next() (although they shouldn't)\n             lastUsedIterator = currentIterator;\n         }\n \n-        while (currentIterator.hasNext() == false && currentIteratorIndex < iteratorChain.size() - 1) {\n+        while (currentIterator.hasNext() == false\n+                && currentIteratorIndex < iteratorChain.size() - 1) {\n             currentIteratorIndex++;\n-            currentIterator = (Iterator) iteratorChain.get(currentIteratorIndex);\n+            currentIterator = iteratorChain.get(currentIteratorIndex);\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Return true if any Iterator in the IteratorChain has a remaining element.\n-     *\n+     * \n      * @return true if elements remain\n      */\n     public boolean hasNext() {\n \n     /**\n      * Returns the next Object of the current Iterator\n-     *\n+     * \n      * @return Object from the current Iterator\n-     * @throws java.util.NoSuchElementException if all the Iterators are exhausted\n-     */\n-    public Object next() {\n+     * @throws java.util.NoSuchElementException if all the Iterators are\n+     * exhausted\n+     */\n+    public E next() {\n         lockChain();\n         updateCurrentIterator();\n         lastUsedIterator = currentIterator;\n     }\n \n     /**\n-     * Removes from the underlying collection the last element\n-     * returned by the Iterator.  As with next() and hasNext(),\n-     * this method calls remove() on the underlying Iterator.\n-     * Therefore, this method may throw an\n-     * UnsupportedOperationException if the underlying\n-     * Iterator does not support this method.\n-     *\n-     * @throws UnsupportedOperationException\n-     *   if the remove operator is not supported by the underlying Iterator\n-     * @throws IllegalStateException\n-     *   if the next method has not yet been called, or the remove method has\n-     *   already been called after the last call to the next method.\n+     * Removes from the underlying collection the last element returned by the\n+     * Iterator. As with next() and hasNext(), this method calls remove() on the\n+     * underlying Iterator. Therefore, this method may throw an\n+     * UnsupportedOperationException if the underlying Iterator does not support\n+     * this method.\n+     * \n+     * @throws UnsupportedOperationException if the remove operator is not\n+     * supported by the underlying Iterator\n+     * @throws IllegalStateException if the next method has not yet been called,\n+     * or the remove method has already been called after the last call to the\n+     * next method.\n      */\n     public void remove() {\n         lockChain();\n--- a/src/java/org/apache/commons/collections/iterators/IteratorEnumeration.java\n+++ b/src/java/org/apache/commons/collections/iterators/IteratorEnumeration.java\n import java.util.Enumeration;\n import java.util.Iterator;\n \n-/** \n- * Adapter to make an {@link Iterator Iterator} instance appear to be\n- * an {@link Enumeration Enumeration} instance.\n+/**\n+ * Adapter to make an {@link Iterator Iterator} instance appear to be an\n+ * {@link Enumeration Enumeration} instance.\n  *\n  * @since Commons Collections 1.0\n  * @version $Revision$ $Date$\n  *\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  */\n-public class IteratorEnumeration implements Enumeration {\n-    \n+public class IteratorEnumeration<E> implements Enumeration<E> {\n+\n     /** The iterator being decorated. */\n-    private Iterator iterator;\n-    \n+    private Iterator<? extends E> iterator;\n+\n     /**\n-     * Constructs a new <code>IteratorEnumeration</code> that will not \n-     * function until {@link #setIterator(Iterator) setIterator} is  \n-     * invoked.\n+     * Constructs a new <code>IteratorEnumeration</code> that will not function\n+     * until {@link #setIterator(Iterator) setIterator} is invoked.\n      */\n     public IteratorEnumeration() {\n         super();\n     }\n \n     /**\n-     * Constructs a new <code>IteratorEnumeration</code> that will use\n-     * the given iterator. \n+     * Constructs a new <code>IteratorEnumeration</code> that will use the given\n+     * iterator.\n      * \n-     * @param iterator  the iterator to use\n+     * @param iterator the iterator to use\n      */\n-    public IteratorEnumeration( Iterator iterator ) {\n+    public IteratorEnumeration(Iterator<? extends E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n     //-------------------------------------------------------------------------\n \n     /**\n-     *  Returns true if the underlying iterator has more elements.\n-     *\n-     *  @return true if the underlying iterator has more elements\n+     * Returns true if the underlying iterator has more elements.\n+     * \n+     * @return true if the underlying iterator has more elements\n      */\n     public boolean hasMoreElements() {\n         return iterator.hasNext();\n     }\n \n     /**\n-     *  Returns the next element from the underlying iterator.\n-     *\n-     *  @return the next element from the underlying iterator.\n-     *  @throws java.util.NoSuchElementException  if the underlying iterator has no\n-     *    more elements\n+     * Returns the next element from the underlying iterator.\n+     * \n+     * @return the next element from the underlying iterator.\n+     * @throws java.util.NoSuchElementException if the underlying iterator has\n+     * no more elements\n      */\n-    public Object nextElement() {\n+    public E nextElement() {\n         return iterator.next();\n     }\n \n     //-------------------------------------------------------------------------\n \n     /**\n-     *  Returns the underlying iterator.\n+     * Returns the underlying iterator.\n      * \n-     *  @return the underlying iterator\n+     * @return the underlying iterator\n      */\n-    public Iterator getIterator() {\n+    public Iterator<? extends E> getIterator() {\n         return iterator;\n     }\n \n     /**\n-     *  Sets the underlying iterator.\n-     *\n-     *  @param iterator  the new underlying iterator\n+     * Sets the underlying iterator.\n+     * \n+     * @param iterator the new underlying iterator\n      */\n-    public void setIterator( Iterator iterator ) {\n+    public void setIterator(Iterator<? extends E> iterator) {\n         this.iterator = iterator;\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/iterators/LoopingIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/LoopingIterator.java\n  * @author <a href=\"mailto:joncrlsn@users.sf.net\">Jonathan Carlson</a>\n  * @author Stephen Colebourne\n  */\n-public class LoopingIterator implements ResettableIterator {\n+public class LoopingIterator<E> implements ResettableIterator<E> {\n     \n     /** The collection to base the iterator on */\n-    private Collection collection;\n+    private Collection<? extends E> collection;\n     /** The current iterator */\n-    private Iterator iterator;\n+    private Iterator<? extends E> iterator;\n \n     /**\n      * Constructor that wraps a collection.\n      * @param coll  the collection to wrap\n      * @throws NullPointerException if the collection is null\n      */\n-    public LoopingIterator(Collection coll) {\n+    public LoopingIterator(Collection<? extends E> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n      * @throws NoSuchElementException if there are no elements\n      *         at all.  Use {@link #hasNext} to avoid this error.\n      */\n-    public Object next() {\n+    public E next() {\n         if (collection.size() == 0) {\n             throw new NoSuchElementException(\"There are no elements for this iterator to loop on\");\n         }\n--- a/src/java/org/apache/commons/collections/iterators/LoopingListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/LoopingListIterator.java\n  *\n  * @author Eric Crampton <ccesc@eonomine.com>\n  */\n-public class LoopingListIterator implements ResettableListIterator {\n+public class LoopingListIterator<E> implements ResettableListIterator<E> {\n \n     /** The list to base the iterator on */\n-    private List list;\n+    private List<E> list;\n     /** The current list iterator */\n-    private ListIterator iterator;\n+    private ListIterator<E> iterator;\n \n     /**\n      * Constructor that wraps a list.\n      * @param list the list to wrap\n      * @throws NullPointerException if the list it null\n      */\n-    public LoopingListIterator(List list) {\n+    public LoopingListIterator(List<E> list) {\n         if (list == null) {\n             throw new NullPointerException(\"The list must not be null\");\n         }\n      * @return the object after the last element returned\n      * @throws NoSuchElementException if there are no elements in the list\n      */\n-    public Object next() {\n+    public E next() {\n         if (list.isEmpty()) {\n             throw new NoSuchElementException(\n                 \"There are no elements for this iterator to loop on\");\n         }\n         if (iterator.hasNext() == false) {\n             return 0;\n-        } else {\n-            return iterator.nextIndex();\n-        }\n+        }\n+        return iterator.nextIndex();\n     }\n \n     /**\n      * @return the object before the last element returned\n      * @throws NoSuchElementException if there are no elements in the list\n      */\n-    public Object previous() {\n+    public E previous() {\n         if (list.isEmpty()) {\n             throw new NoSuchElementException(\n                 \"There are no elements for this iterator to loop on\");\n         }\n         if (iterator.hasPrevious() == false) {\n-            Object result = null;\n+            E result = null;\n             while (iterator.hasNext()) {\n                 result = iterator.next();\n             }\n             iterator.previous();\n             return result;\n-        } else {\n-            return iterator.previous();\n-        }\n+        }\n+        return iterator.previous();\n     }\n \n     /**\n         }\n         if (iterator.hasPrevious() == false) {\n             return list.size() - 1;\n-        } else {\n-            return iterator.previousIndex();\n-        }\n+        }\n+        return iterator.previousIndex();\n     }\n \n     /**\n      * @throws UnsupportedOperationException if the add method is not\n      *  supported by the iterator implementation of the underlying list\n      */\n-    public void add(Object obj) {\n+    public void add(E obj) {\n         iterator.add(obj);\n     }\n \n      * @throws UnsupportedOperationException if the set method is not\n      *  supported by the iterator implementation of the underlying list\n      */\n-    public void set(Object obj) {\n+    public void set(E obj) {\n         iterator.set(obj);\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n  * @author Stephen Colebourne\n  * @author Phil Steitz\n  */\n-public class ObjectArrayIterator\n-        implements Iterator, ResettableIterator {\n+public class ObjectArrayIterator<E>\n+        implements Iterator<E>, ResettableIterator<E> {\n \n     /** The array */\n-    protected Object[] array = null;\n+    protected E[] array = null;\n     /** The start index to loop from */\n     protected int startIndex = 0;\n     /** The end index to loop to */\n      * @param array the array to iterate over\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayIterator(Object[] array) {\n+    public ObjectArrayIterator(E[] array) {\n         this(array, 0, array.length);\n     }\n \n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      * @throws IndexOutOfBoundsException if the start index is out of bounds\n      */\n-    public ObjectArrayIterator(Object array[], int start) {\n+    public ObjectArrayIterator(E array[], int start) {\n         this(array, start, array.length);\n     }\n \n      * @throws IllegalArgumentException if end index is before the start\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayIterator(Object array[], int start, int end) {\n+    public ObjectArrayIterator(E array[], int start, int end) {\n         super();\n         if (start < 0) {\n             throw new ArrayIndexOutOfBoundsException(\"Start index must not be less than zero\");\n      * @throws NoSuchElementException if all the elements in the array\n      *    have already been returned\n      */\n-    public Object next() {\n+    public E next() {\n         if (hasNext() == false) {\n             throw new NoSuchElementException();\n         }\n      * the no-arg constructor was used and {@link #setArray} has never\n      * been called with a valid array.\n      */\n-    public Object[] getArray() {\n+    public E[] getArray() {\n         return this.array;\n     }\n \n      * @throws IllegalStateException if the <code>array</code> was set in the constructor\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public void setArray(Object[] array) {\n+    public void setArray(E[] array) {\n         if (this.array != null) {\n             throw new IllegalStateException(\"The array to iterate over has already been set\");\n         }\n--- a/src/java/org/apache/commons/collections/iterators/ReverseListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/ReverseListIterator.java\n  * @since Commons Collections 3.2\n  * @version $Revision: $ $Date$\n  */\n-public class ReverseListIterator implements ResettableListIterator {\n+public class ReverseListIterator<E> implements ResettableListIterator<E> {\n \n     /** The list being wrapped. */\n-    private final List list;\n+    private final List<E> list;\n     /** The list iterator being wrapped. */\n-    private ListIterator iterator;\n+    private ListIterator<E> iterator;\n     /** Flag to indicate if updating is possible at the moment. */\n     private boolean validForUpdate = true;\n \n      * @param list  the list to create a reversed iterator for\n      * @throws NullPointerException if the list is null\n      */\n-    public ReverseListIterator(List list) {\n+    public ReverseListIterator(List<E> list) {\n         super();\n         this.list = list;\n         iterator = list.listIterator(list.size());\n      *\n      * @return the next element in the iterator\n      */\n-    public Object next() {\n-        Object obj = iterator.previous();\n+    public E next() {\n+        E obj = iterator.previous();\n         validForUpdate = true;\n         return obj;\n     }\n      *\n      * @return the previous element in the iterator\n      */\n-    public Object previous() {\n-        Object obj = iterator.next();\n+    public E previous() {\n+        E obj = iterator.next();\n         validForUpdate = true;\n         return obj;\n     }\n      * @throws UnsupportedOperationException if the list is unmodifiable\n      * @throws IllegalStateException if the iterator is not in a valid state for set\n      */\n-    public void set(Object obj) {\n+    public void set(E obj) {\n         if (validForUpdate == false) {\n             throw new IllegalStateException(\"Cannot set to list until next() or previous() called\");\n         }\n      * @throws UnsupportedOperationException if the list is unmodifiable\n      * @throws IllegalStateException if the iterator is not in a valid state for set\n      */\n-    public void add(Object obj) {\n+    public void add(E obj) {\n         // the validForUpdate flag is needed as the necessary previous()\n         // method call re-enables remove and add\n         if (validForUpdate == false) {\n--- a/src/java/org/apache/commons/collections/iterators/SingletonListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/SingletonListIterator.java\n  * @author Stephen Colebourne\n  * @author Rodney Waldhoff\n  */\n-public class SingletonListIterator implements ListIterator, ResettableListIterator {\n+public class SingletonListIterator<E> implements ListIterator<E>, ResettableListIterator<E> {\n \n     private boolean beforeFirst = true;\n     private boolean nextCalled = false;\n     private boolean removed = false;\n-    private Object object;\n+    private E object;\n \n     /**\n      * Constructs a new <code>SingletonListIterator</code>.\n      *\n      * @param object  the single object to return from the iterator\n      */\n-    public SingletonListIterator(Object object) {\n+    public SingletonListIterator(E object) {\n         super();\n         this.object = object;\n     }\n      * @throws NoSuchElementException if the single object has already \n      *    been returned\n      */\n-    public Object next() {\n+    public E next() {\n         if (!beforeFirst || removed) {\n             throw new NoSuchElementException();\n         }\n      * @throws NoSuchElementException if the single object has not already \n      *    been returned\n      */\n-    public Object previous() {\n+    public E previous() {\n         if (beforeFirst || removed) {\n             throw new NoSuchElementException();\n         }\n      *\n      * @throws UnsupportedOperationException always\n      */\n-    public void add(Object obj) {\n+    public void add(E obj) {\n         throw new UnsupportedOperationException(\"add() is not supported by this iterator\");\n     }\n     \n      * @throws IllegalStateException if <tt>next</tt> has not been called \n      *          or the object has been removed\n      */\n-    public void set(Object obj) {\n+    public void set(E obj) {\n         if (!nextCalled || removed) {\n             throw new IllegalStateException();\n         }\n--- a/src/java/org/apache/commons/collections/iterators/TransformIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/TransformIterator.java\n  * @author James Strachan\n  * @author Stephen Colebourne\n  */\n-public class TransformIterator implements Iterator {\n+public class TransformIterator<I, O> implements Iterator<O> {\n \n     /** The iterator being used */\n-    private Iterator iterator;\n+    private Iterator<? extends I> iterator;\n     /** The transformer being used */\n-    private Transformer transformer;\n+    private Transformer<? super I, ? extends O> transformer;\n \n     //-----------------------------------------------------------------------\n     /**\n      * Constructs a new <code>TransformIterator</code> that will not function\n-     * until the {@link #setIterator(Iterator) setIterator} method is \n-     * invoked.\n+     * until the {@link #setIterator(Iterator) setIterator} and \n+     * {@link #setTransformer(Transformer)} methods are invoked.\n      */\n     public TransformIterator() {\n         super();\n      *\n      * @param iterator  the iterator to use\n      */\n-    public TransformIterator(Iterator iterator) {\n+    public TransformIterator(Iterator<? extends I> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n      * @param iterator  the iterator to use\n      * @param transformer  the transformer to use\n      */\n-    public TransformIterator(Iterator iterator, Transformer transformer) {\n+    public TransformIterator(Iterator<? extends I> iterator, Transformer<? super I, ? extends O> transformer) {\n         super();\n         this.iterator = iterator;\n         this.transformer = transformer;\n      * @return the next object\n      * @throws java.util.NoSuchElementException if there are no more elements\n      */\n-    public Object next() {\n+    public O next() {\n         return transform(iterator.next());\n     }\n \n      * \n      * @return the iterator.\n      */\n-    public Iterator getIterator() {\n+    public Iterator<? extends I> getIterator() {\n         return iterator;\n     }\n \n      * \n      * @param iterator  the iterator to use\n      */\n-    public void setIterator(Iterator iterator) {\n+    public void setIterator(Iterator<? extends I> iterator) {\n         this.iterator = iterator;\n     }\n \n      * \n      * @return the transformer.\n      */\n-    public Transformer getTransformer() {\n+    public Transformer<? super I, ? extends O> getTransformer() {\n         return transformer;\n     }\n \n      * \n      * @param transformer  the transformer to use\n      */\n-    public void setTransformer(Transformer transformer) {\n+    public void setTransformer(Transformer<? super I, ? extends O> transformer) {\n         this.transformer = transformer;\n     }\n \n      * @param source  the object to transform\n      * @return the transformed object\n      */\n-    protected Object transform(Object source) {\n-        if (transformer != null) {\n-            return transformer.transform(source);\n-        }\n-        return source;\n+    protected O transform(I source) {\n+        return transformer.transform(source);\n     }\n }\n--- a/src/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n \n import org.apache.commons.collections.functors.UniquePredicate;\n \n-/** \n+/**\n  * A FilterIterator which only returns \"unique\" Objects.  Internally,\n  * the Iterator maintains a Set of objects it has already encountered,\n  * and duplicate Objects are skipped.\n  *\n  * @author Morgan Delagrange\n  */\n-public class UniqueFilterIterator extends FilterIterator {\n-       \n+public class UniqueFilterIterator<E> extends FilterIterator<E> {\n+\n     //-------------------------------------------------------------------------\n-    \n+\n     /**\n      *  Constructs a new <code>UniqueFilterIterator</code>.\n      *\n      *  @param iterator  the iterator to use\n      */\n-    public UniqueFilterIterator( Iterator iterator ) {\n+    public UniqueFilterIterator(Iterator<E> iterator) {\n         super(iterator, UniquePredicate.getInstance());\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableIterator implements Iterator, Unmodifiable {\n+public final class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable {\n \n     /** The iterator being decorated */\n-    private Iterator iterator;\n+    private Iterator<E> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static Iterator decorate(Iterator iterator) {\n+    public static <E> Iterator<E> decorate(Iterator<E> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"Iterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             return iterator;\n         }\n-        return new UnmodifiableIterator(iterator);\n+        return new UnmodifiableIterator<E>(iterator);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor.\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableIterator(Iterator iterator) {\n+    private UnmodifiableIterator(Iterator<E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         return iterator.hasNext();\n     }\n \n-    public Object next() {\n+    public E next() {\n         return iterator.next();\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableListIterator implements ListIterator, Unmodifiable {\n+public final class UnmodifiableListIterator<E> implements ListIterator<E>, Unmodifiable {\n \n     /** The iterator being decorated */\n-    private ListIterator iterator;\n+    private ListIterator<E> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static ListIterator decorate(ListIterator iterator) {\n+    public static <E> ListIterator<E> decorate(ListIterator<E> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"ListIterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             return iterator;\n         }\n-        return new UnmodifiableListIterator(iterator);\n+        return new UnmodifiableListIterator<E>(iterator);\n     }\n     \n     //-----------------------------------------------------------------------\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableListIterator(ListIterator iterator) {\n+    private UnmodifiableListIterator(ListIterator<E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         return iterator.hasNext();\n     }\n \n-    public Object next() {\n+    public E next() {\n         return iterator.next();\n     }\n \n         return iterator.hasPrevious();\n     }\n \n-    public Object previous() {\n+    public E previous() {\n         return iterator.previous();\n     }\n \n         throw new UnsupportedOperationException(\"remove() is not supported\");\n     }\n \n-    public void set(Object obj) {\n+    public void set(E obj) {\n         throw new UnsupportedOperationException(\"set() is not supported\");\n     }\n \n-    public void add(Object obj) {\n+    public void add(E obj) {\n         throw new UnsupportedOperationException(\"add() is not supported\");\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableMapIterator implements MapIterator, Unmodifiable {\n+public final class UnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable {\n \n     /** The iterator being decorated */\n-    private MapIterator iterator;\n+    private MapIterator<K, V> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static MapIterator decorate(MapIterator iterator) {\n+    public static <K, V> MapIterator<K, V> decorate(MapIterator<K, V> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"MapIterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             return iterator;\n         }\n-        return new UnmodifiableMapIterator(iterator);\n+        return new UnmodifiableMapIterator<K, V>(iterator);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor.\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableMapIterator(MapIterator iterator) {\n+    private UnmodifiableMapIterator(MapIterator<K, V> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         return iterator.hasNext();\n     }\n \n-    public Object next() {\n+    public K next() {\n         return iterator.next();\n     }\n \n-    public Object getKey() {\n+    public K getKey() {\n         return iterator.getKey();\n     }\n \n-    public Object getValue() {\n+    public V getValue() {\n         return iterator.getValue();\n     }\n \n-    public Object setValue(Object value) {\n+    public V setValue(V value) {\n         throw new UnsupportedOperationException(\"setValue() is not supported\");\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.Unmodifiable;\n \n-/** \n+/**\n  * Decorates an ordered map iterator such that it cannot be modified.\n  * <p>\n  * Attempts to modify it will result in an UnsupportedOperationException. \n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableOrderedMapIterator implements OrderedMapIterator, Unmodifiable {\n+public final class UnmodifiableOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>,\n+        Unmodifiable {\n \n     /** The iterator being decorated */\n-    private OrderedMapIterator iterator;\n+    private OrderedMapIterator<K, V> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static OrderedMapIterator decorate(OrderedMapIterator iterator) {\n+    public static <K, V> OrderedMapIterator<K, V> decorate(OrderedMapIterator<K, V> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             return iterator;\n         }\n-        return new UnmodifiableOrderedMapIterator(iterator);\n+        return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor.\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableOrderedMapIterator(OrderedMapIterator iterator) {\n+    private UnmodifiableOrderedMapIterator(OrderedMapIterator<K, V> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         return iterator.hasNext();\n     }\n \n-    public Object next() {\n+    public K next() {\n         return iterator.next();\n     }\n \n         return iterator.hasPrevious();\n     }\n \n-    public Object previous() {\n+    public K previous() {\n         return iterator.previous();\n     }\n \n-    public Object getKey() {\n+    public K getKey() {\n         return iterator.getKey();\n     }\n \n-    public Object getValue() {\n+    public V getValue() {\n         return iterator.getValue();\n     }\n \n-    public Object setValue(Object value) {\n+    public V setValue(V value) {\n         throw new UnsupportedOperationException(\"setValue() is not supported\");\n     }\n \n--- a/src/java/org/apache/commons/collections/keyvalue/AbstractKeyValue.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/AbstractKeyValue.java\n  * @author Neil O'Toole\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractKeyValue implements KeyValue {\n+public abstract class AbstractKeyValue<K, V> implements KeyValue<K, V> {\n \n     /** The key */\n-    protected Object key;\n+    protected K key;\n     /** The value */\n-    protected Object value;\n+    protected V value;\n \n     /**\n      * Constructs a new pair with the specified key and given value.\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    protected AbstractKeyValue(Object key, Object value) {\n+    protected AbstractKeyValue(K key, V value) {\n         super();\n         this.key = key;\n         this.value = value;\n      *\n      * @return the key \n      */\n-    public Object getKey() {\n+    public K getKey() {\n         return key;\n     }\n \n      *\n      * @return the value\n      */\n-    public Object getValue() {\n+    public V getValue() {\n         return value;\n     }\n \n--- a/src/java/org/apache/commons/collections/keyvalue/AbstractMapEntry.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/AbstractMapEntry.java\n  * @author Neil O'Toole\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractMapEntry extends AbstractKeyValue implements Map.Entry {\n+public abstract class AbstractMapEntry<K, V> extends AbstractKeyValue<K, V> implements Map.Entry<K, V> {\n \n     /**\n      * Constructs a new entry with the given key and given value.\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    protected AbstractMapEntry(Object key, Object value) {\n+    protected AbstractMapEntry(K key, V value) {\n         super(key, value);\n     }\n \n      * @param value  the new value\n      * @return the previous value\n      */\n-    public Object setValue(Object value) {\n-        Object answer = this.value;\n+    public V setValue(V value) {\n+        V answer = this.value;\n         this.value = value;\n         return answer;\n     }\n      * @param obj  the object to compare to\n      * @return true if equal key and value\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n--- a/src/java/org/apache/commons/collections/keyvalue/AbstractMapEntryDecorator.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/AbstractMapEntryDecorator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractMapEntryDecorator implements Map.Entry, KeyValue {\n+public abstract class AbstractMapEntryDecorator<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n     \n     /** The <code>Map.Entry</code> to decorate */\n-    protected final Map.Entry entry;\n+    protected final Map.Entry<K, V> entry;\n \n     /**\n      * Constructor that wraps (not copies).\n      * @param entry  the <code>Map.Entry</code> to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractMapEntryDecorator(Map.Entry entry) {\n+    public AbstractMapEntryDecorator(Map.Entry<K, V> entry) {\n         if (entry == null) {\n             throw new IllegalArgumentException(\"Map Entry must not be null\");\n         }\n      * \n      * @return the decorated map\n      */\n-    protected Map.Entry getMapEntry() {\n+    protected Map.Entry<K, V> getMapEntry() {\n         return entry;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object getKey() {\n+    public K getKey() {\n         return entry.getKey();\n     }\n \n-    public Object getValue() {\n+    public V getValue() {\n         return entry.getValue();\n     }\n \n-    public Object setValue(Object object) {\n+    public V setValue(V object) {\n         return entry.setValue(object);\n     }\n    \n--- a/src/java/org/apache/commons/collections/keyvalue/DefaultKeyValue.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/DefaultKeyValue.java\n  * @author Neil O'Toole\n  * @author Stephen Colebourne\n  */\n-public class DefaultKeyValue extends AbstractKeyValue {\n+public class DefaultKeyValue<K, V> extends AbstractKeyValue<K, V> {\n \n     /**\n      * Constructs a new pair with a null key and null value.\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    public DefaultKeyValue(final Object key, final Object value) {\n+    public DefaultKeyValue(final K key, final V value) {\n         super(key, value);\n     }\n \n      * @param pair  the pair to copy, must not be null\n      * @throws NullPointerException if the entry is null\n      */\n-    public DefaultKeyValue(final KeyValue pair) {\n+    public DefaultKeyValue(final KeyValue<K, V> pair) {\n         super(pair.getKey(), pair.getValue());\n     }\n \n      * @param entry  the entry to copy, must not be null\n      * @throws NullPointerException if the entry is null\n      */\n-    public DefaultKeyValue(final Map.Entry entry) {\n+    public DefaultKeyValue(final Map.Entry<K, V> entry) {\n         super(entry.getKey(), entry.getValue());\n     }\n \n      * @return the old key\n      * @throws IllegalArgumentException if key is this object\n      */\n-    public Object setKey(final Object key) {\n+    public K setKey(final K key) {\n         if (key == this) {\n             throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a key.\");\n         }\n \n-        final Object old = this.key;\n+        final K old = this.key;\n         this.key = key;\n         return old;\n     }\n      * @param value the new value\n      * @throws IllegalArgumentException if value is this object\n      */\n-    public Object setValue(final Object value) {\n+    public V setValue(final V value) {\n         if (value == this) {\n             throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a value.\");\n         }\n \n-        final Object old = this.value;\n+        final V old = this.value;\n         this.value = value;\n         return old;\n     }\n      * \n      * @return a MapEntry instance\n      */\n-    public Map.Entry toMapEntry() {\n-        return new DefaultMapEntry(this);\n+    public Map.Entry<K, V> toMapEntry() {\n+        return new DefaultMapEntry<K, V>(this);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param obj  the object to compare to\n      * @return true if equal key and value\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n--- a/src/java/org/apache/commons/collections/keyvalue/DefaultMapEntry.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/DefaultMapEntry.java\n  * @author Neil O'Toole\n  * @author Stephen Colebourne\n  */\n-public final class DefaultMapEntry extends AbstractMapEntry {\n+public final class DefaultMapEntry<K, V> extends AbstractMapEntry<K, V> {\n \n     /**\n      * Constructs a new entry with the specified key and given value.\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    public DefaultMapEntry(final Object key, final Object value) {\n+    public DefaultMapEntry(final K key, final V value) {\n         super(key, value);\n     }\n \n      * @param pair  the pair to copy, must not be null\n      * @throws NullPointerException if the entry is null\n      */\n-    public DefaultMapEntry(final KeyValue pair) {\n+    public DefaultMapEntry(final KeyValue<K, V> pair) {\n         super(pair.getKey(), pair.getValue());\n     }\n \n      * @param entry  the entry to copy, must not be null\n      * @throws NullPointerException if the entry is null\n      */\n-    public DefaultMapEntry(final Map.Entry entry) {\n+    public DefaultMapEntry(final Map.Entry<K, V> entry) {\n         super(entry.getKey(), entry.getValue());\n     }\n \n--- a/src/java/org/apache/commons/collections/keyvalue/MultiKey.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/MultiKey.java\n  * @author Howard Lewis Ship\n  * @author Stephen Colebourne\n  */\n-public class MultiKey implements Serializable {\n+public class MultiKey<K> implements Serializable {\n     // This class could implement List, but that would confuse it's purpose\n \n     /** Serialisation version */\n     private static final long serialVersionUID = 4465448607415788805L;\n \n     /** The individual keys */\n-    private final Object[] keys;\n+    private final K[] keys;\n     /** The cached hashCode */\n     private transient int hashCode;\n-    \n+\n     /**\n      * Constructor taking two keys.\n      * <p>\n      * @param key1  the first key\n      * @param key2  the second key\n      */\n-    public MultiKey(Object key1, Object key2) {\n-        this(new Object[] {key1, key2}, false);\n-    }\n-    \n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2) {\n+        this((K[]) new Object[] { key1, key2 }, false);\n+    }\n+\n     /**\n      * Constructor taking three keys.\n      * <p>\n      * @param key2  the second key\n      * @param key3  the third key\n      */\n-    public MultiKey(Object key1, Object key2, Object key3) {\n-        this(new Object[] {key1, key2, key3}, false);\n-    }\n-    \n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2, K key3) {\n+        this((K[]) new Object[] {key1, key2, key3}, false);\n+    }\n+\n     /**\n      * Constructor taking four keys.\n      * <p>\n      * @param key3  the third key\n      * @param key4  the fourth key\n      */\n-    public MultiKey(Object key1, Object key2, Object key3, Object key4) {\n-        this(new Object[] {key1, key2, key3, key4}, false);\n-    }\n-    \n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2, K key3, K key4) {\n+        this((K[]) new Object[] {key1, key2, key3, key4}, false);\n+    }\n+\n     /**\n      * Constructor taking five keys.\n      * <p>\n      * @param key4  the fourth key\n      * @param key5  the fifth key\n      */\n-    public MultiKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n-        this(new Object[] {key1, key2, key3, key4, key5}, false);\n-    }\n-    \n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2, K key3, K key4, K key5) {\n+        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n+    }\n+\n     /**\n      * Constructor taking an array of keys which is cloned.\n      * <p>\n      * @param keys  the array of keys, not null\n      * @throws IllegalArgumentException if the key array is null\n      */\n-    public MultiKey(Object[] keys) {\n+    public MultiKey(K[] keys) {\n         this(keys, true);\n     }\n-    \n+\n     /**\n      * Constructor taking an array of keys, optionally choosing whether to clone.\n      * <p>\n      * @throws IllegalArgumentException if the key array is null\n      * @since Commons Collections 3.1\n      */\n-    public MultiKey(Object[] keys, boolean makeClone) {\n+    public MultiKey(K[] keys, boolean makeClone) {\n         super();\n         if (keys == null) {\n             throw new IllegalArgumentException(\"The array of keys must not be null\");\n         }\n         if (makeClone) {\n-            this.keys = (Object[]) keys.clone();\n+            this.keys = keys.clone();\n         } else {\n             this.keys = keys;\n         }\n-        \n+\n         calculateHashCode(keys);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets a clone of the array of keys.\n      * \n      * @return the individual keys\n      */\n-    public Object[] getKeys() {\n-        return (Object[]) keys.clone();\n-    }\n-    \n+    public K[] getKeys() {\n+        return keys.clone();\n+    }\n+\n     /**\n      * Gets the key at the specified index.\n      * <p>\n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @since Commons Collections 3.1\n      */\n-    public Object getKey(int index) {\n+    public K getKey(int index) {\n         return keys[index];\n     }\n-    \n+\n     /**\n      * Gets the size of the list of keys.\n      * \n     public int size() {\n         return keys.length;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object to another.\n             return true;\n         }\n         if (other instanceof MultiKey) {\n-            MultiKey otherMulti = (MultiKey) other;\n+            MultiKey<?> otherMulti = (MultiKey<?>) other;\n             return Arrays.equals(keys, otherMulti.keys);\n         }\n         return false;\n--- a/src/java/org/apache/commons/collections/keyvalue/TiedMapEntry.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/TiedMapEntry.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TiedMapEntry implements Map.Entry, KeyValue, Serializable {\n+public class TiedMapEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V>, Serializable {\n \n     /** Serialization version */    \n     private static final long serialVersionUID = -8453869361373831205L;\n \n     /** The map underlying the entry/iterator */    \n-    private final Map map;\n+    private final Map<K, V> map;\n+\n     /** The key */\n-    private final Object key;\n+    private final K key;\n \n     /**\n      * Constructs a new entry with the given Map and key.\n      * @param map  the map\n      * @param key  the key\n      */\n-    public TiedMapEntry(Map map, Object key) {\n+    public TiedMapEntry(Map<K, V> map, K key) {\n         super();\n         this.map = map;\n         this.key = key;\n      * \n      * @return the key\n      */\n-    public Object getKey() {\n+    public K getKey() {\n         return key;\n     }\n \n      * \n      * @return the value\n      */\n-    public Object getValue() {\n+    public V getValue() {\n         return map.get(key);\n     }\n \n      * @return the old value\n      * @throws IllegalArgumentException if the value is set to this map entry\n      */\n-    public Object setValue(Object value) {\n+    public V setValue(V value) {\n         if (value == this) {\n             throw new IllegalArgumentException(\"Cannot set value to this map entry\");\n         }\n      * @param obj  the object to compare to\n      * @return true if equal key and value\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n--- a/src/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntry.java\n+++ b/src/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntry.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableMapEntry extends AbstractMapEntry implements Unmodifiable {\n+public final class UnmodifiableMapEntry<K, V> extends AbstractMapEntry<K, V> implements Unmodifiable {\n \n     /**\n      * Constructs a new entry with the specified key and given value.\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    public UnmodifiableMapEntry(final Object key, final Object value) {\n+    public UnmodifiableMapEntry(final K key, final V value) {\n         super(key, value);\n     }\n \n      * @param pair  the pair to copy, must not be null\n      * @throws NullPointerException if the entry is null\n      */\n-    public UnmodifiableMapEntry(final KeyValue pair) {\n+    public UnmodifiableMapEntry(final KeyValue<K, V> pair) {\n         super(pair.getKey(), pair.getValue());\n     }\n \n      * @param entry  the entry to copy, must not be null\n      * @throws NullPointerException if the entry is null\n      */\n-    public UnmodifiableMapEntry(final Map.Entry entry) {\n+    public UnmodifiableMapEntry(final Map.Entry<K, V> entry) {\n         super(entry.getKey(), entry.getValue());\n     }\n \n      * @return the previous value\n      * @throws UnsupportedOperationException always\n      */\n-    public Object setValue(Object value) {\n+    public V setValue(V value) {\n         throw new UnsupportedOperationException(\"setValue() is not supported\");\n     }\n \n--- a/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractLinkedList implements List {\n+public abstract class AbstractLinkedList<E> implements List<E> {\n \n     /*\n      * Implementation notes:\n      * hold a value. The value of <code>next</code> is the first item in the\n      * list. The value of of <code>previous</code> is the last item in the list.\n      */\n-    protected transient Node header;\n+    protected transient Node<E> header;\n+\n     /** The size of the list */\n     protected transient int size;\n+\n     /** Modification count for iterators */\n     protected transient int modCount;\n \n \n     /**\n      * Constructs a list copying data from the specified collection.\n-     * \n+     *\n      * @param coll  the collection to copy\n      */\n-    protected AbstractLinkedList(Collection coll) {\n+    protected AbstractLinkedList(Collection<? extends E> coll) {\n         super();\n         init();\n         addAll(coll);\n         return (size() == 0);\n     }\n \n-    public Object get(int index) {\n-        Node node = getNode(index, false);\n+    public E get(int index) {\n+        Node<E> node = getNode(index, false);\n         return node.getValue();\n     }\n \n     //-----------------------------------------------------------------------\n-    public Iterator iterator() {\n+    public Iterator<E> iterator() {\n         return listIterator();\n     }\n \n-    public ListIterator listIterator() {\n-        return new LinkedListIterator(this, 0);\n-    }\n-\n-    public ListIterator listIterator(int fromIndex) {\n-        return new LinkedListIterator(this, fromIndex);\n+    public ListIterator<E> listIterator() {\n+        return new LinkedListIterator<E>(this, 0);\n+    }\n+\n+    public ListIterator<E> listIterator(int fromIndex) {\n+        return new LinkedListIterator<E>(this, fromIndex);\n     }\n \n     //-----------------------------------------------------------------------\n     public int indexOf(Object value) {\n         int i = 0;\n-        for (Node node = header.next; node != header; node = node.next) {\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n             if (isEqualValue(node.getValue(), value)) {\n                 return i;\n             }\n \n     public int lastIndexOf(Object value) {\n         int i = size - 1;\n-        for (Node node = header.previous; node != header; node = node.previous) {\n+        for (Node<E> node = header.previous; node != header; node = node.previous) {\n             if (isEqualValue(node.getValue(), value)) {\n                 return i;\n             }\n         return indexOf(value) != -1;\n     }\n \n-    public boolean containsAll(Collection coll) {\n-        Iterator it = coll.iterator();\n-        while (it.hasNext()) {\n-            if (contains(it.next()) == false) {\n+    public boolean containsAll(Collection<?> coll) {\n+        for (Object o : coll) {\n+            if (!contains(o)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public Object[] toArray() {\n         return toArray(new Object[size]);\n     }\n \n-    public Object[] toArray(Object[] array) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n         // Extend the array if needed\n         if (array.length < size) {\n             Class componentType = array.getClass().getComponentType();\n-            array = (Object[]) Array.newInstance(componentType, size);\n+            array = (T[]) Array.newInstance(componentType, size);\n         }\n         // Copy the values into the array\n         int i = 0;\n-        for (Node node = header.next; node != header; node = node.next, i++) {\n-            array[i] = node.getValue();\n+        for (Node<E> node = header.next; node != header; node = node.next, i++) {\n+            array[i] = (T) node.getValue();\n         }\n         // Set the value after the last value to null\n         if (array.length > size) {\n \n     /**\n      * Gets a sublist of the main list.\n-     * \n+     *\n      * @param fromIndexInclusive  the index to start from\n      * @param toIndexExclusive  the index to end at\n      * @return the new sublist\n      */\n-    public List subList(int fromIndexInclusive, int toIndexExclusive) {\n-        return new LinkedSubList(this, fromIndexInclusive, toIndexExclusive);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public boolean add(Object value) {\n+    public List<E> subList(int fromIndexInclusive, int toIndexExclusive) {\n+        return new LinkedSubList<E>(this, fromIndexInclusive, toIndexExclusive);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(E value) {\n         addLast(value);\n         return true;\n     }\n-    \n-    public void add(int index, Object value) {\n-        Node node = getNode(index, true);\n+\n+    public void add(int index, E value) {\n+        Node<E> node = getNode(index, true);\n         addNodeBefore(node, value);\n     }\n-    \n-    public boolean addAll(Collection coll) {\n+\n+    public boolean addAll(Collection<? extends E> coll) {\n         return addAll(size, coll);\n     }\n \n-    public boolean addAll(int index, Collection coll) {\n-        Node node = getNode(index, true);\n-        for (Iterator itr = coll.iterator(); itr.hasNext();) {\n-            Object value = itr.next();\n-            addNodeBefore(node, value);\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        Node<E> node = getNode(index, true);\n+        for (E e : coll) {\n+            addNodeBefore(node, e);\n         }\n         return true;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object remove(int index) {\n-        Node node = getNode(index, false);\n-        Object oldValue = node.getValue();\n+    public E remove(int index) {\n+        Node<E> node = getNode(index, false);\n+        E oldValue = node.getValue();\n         removeNode(node);\n         return oldValue;\n     }\n \n     public boolean remove(Object value) {\n-        for (Node node = header.next; node != header; node = node.next) {\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n             if (isEqualValue(node.getValue(), value)) {\n                 removeNode(node);\n                 return true;\n         return false;\n     }\n \n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         boolean modified = false;\n-        Iterator it = iterator();\n+        Iterator<E> it = iterator();\n         while (it.hasNext()) {\n             if (coll.contains(it.next())) {\n                 it.remove();\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean retainAll(Collection coll) {\n+    public boolean retainAll(Collection<?> coll) {\n         boolean modified = false;\n-        Iterator it = iterator();\n+        Iterator<E> it = iterator();\n         while (it.hasNext()) {\n             if (coll.contains(it.next()) == false) {\n                 it.remove();\n         return modified;\n     }\n \n-    public Object set(int index, Object value) {\n-        Node node = getNode(index, false);\n-        Object oldValue = node.getValue();\n+    public E set(int index, E value) {\n+        Node<E> node = getNode(index, false);\n+        E oldValue = node.getValue();\n         updateNode(node, value);\n         return oldValue;\n     }\n     public void clear() {\n         removeAllNodes();\n     }\n-    \n-    //-----------------------------------------------------------------------\n-    public Object getFirst() {\n-        Node node = header.next;\n+\n+    //-----------------------------------------------------------------------\n+    public E getFirst() {\n+        Node<E> node = header.next;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n         return node.getValue();\n     }\n \n-    public Object getLast() {\n-        Node node = header.previous;\n+    public E getLast() {\n+        Node<E> node = header.previous;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n         return node.getValue();\n     }\n \n-    public boolean addFirst(Object o) {\n+    public boolean addFirst(E o) {\n         addNodeAfter(header, o);\n         return true;\n     }\n \n-    public boolean addLast(Object o) {\n+    public boolean addLast(E o) {\n         addNodeBefore(header, o);\n         return true;\n     }\n \n-    public Object removeFirst() {\n-        Node node = header.next;\n+    public E removeFirst() {\n+        Node<E> node = header.next;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n-        Object oldValue = node.getValue();\n+        E oldValue = node.getValue();\n         removeNode(node);\n         return oldValue;\n     }\n \n-    public Object removeLast() {\n-        Node node = header.previous;\n+    public E removeLast() {\n+        Node<E> node = header.previous;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n-        Object oldValue = node.getValue();\n+        E oldValue = node.getValue();\n         removeNode(node);\n         return oldValue;\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n \n     public int hashCode() {\n         int hashCode = 1;\n-        Iterator it = iterator();\n-        while (it.hasNext()) {\n-            Object obj = it.next();\n-            hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+        for (E e : this) {\n+            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n         }\n         return hashCode;\n     }\n         StringBuffer buf = new StringBuffer(16 * size());\n         buf.append(\"[\");\n \n-        Iterator it = iterator();\n+        Iterator<E> it = iterator();\n         boolean hasNext = it.hasNext();\n         while (hasNext) {\n             Object value = it.next();\n      * Compares two values for equals.\n      * This implementation uses the equals method.\n      * Subclasses can override this to match differently.\n-     * \n+     *\n      * @param value1  the first value to compare, may be null\n      * @param value2  the second value to compare, may be null\n      * @return true if equal\n     protected boolean isEqualValue(Object value1, Object value2) {\n         return (value1 == value2 || (value1 == null ? false : value1.equals(value2)));\n     }\n-    \n+\n     /**\n      * Updates the node with a new value.\n      * This implementation sets the value on the node.\n      * Subclasses can override this to record the change.\n-     * \n+     *\n      * @param node  node to update\n      * @param value  new value of the node\n      */\n-    protected void updateNode(Node node, Object value) {\n+    protected void updateNode(Node<E> node, E value) {\n         node.setValue(value);\n     }\n \n      * Creates a new node with previous, next and element all set to null.\n      * This implementation creates a new empty Node.\n      * Subclasses can override this to create a different class.\n-     * \n+     *\n      * @return  newly created node\n      */\n-    protected Node createHeaderNode() {\n-        return new Node();\n+    protected Node<E> createHeaderNode() {\n+        return new Node<E>();\n     }\n \n     /**\n      * Creates a new node with the specified properties.\n      * This implementation creates a new Node with data.\n      * Subclasses can override this to create a different class.\n-     * \n+     *\n      * @param value  value of the new node\n      */\n-    protected Node createNode(Object value) {\n-        return new Node(value);\n-    }\n-\n-    /**\n-     * Creates a new node with the specified object as its \n+    protected Node<E> createNode(E value) {\n+        return new Node<E>(value);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n      * <code>value</code> and inserts it before <code>node</code>.\n      * <p>\n      * This implementation uses {@link #createNode(Object)} and\n      * @param value  value of the newly added node\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void addNodeBefore(Node node, Object value) {\n-        Node newNode = createNode(value);\n+    protected void addNodeBefore(Node<E> node, E value) {\n+        Node<E> newNode = createNode(value);\n         addNode(newNode, node);\n     }\n \n     /**\n-     * Creates a new node with the specified object as its \n+     * Creates a new node with the specified object as its\n      * <code>value</code> and inserts it after <code>node</code>.\n      * <p>\n      * This implementation uses {@link #createNode(Object)} and\n      * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n-     * \n+     *\n      * @param node  node to insert after\n      * @param value  value of the newly added node\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void addNodeAfter(Node node, Object value) {\n-        Node newNode = createNode(value);\n+    protected void addNodeAfter(Node<E> node, E value) {\n+        Node<E> newNode = createNode(value);\n         addNode(newNode, node.next);\n     }\n \n      * @param insertBeforeNode  node to insert before\n      * @throws NullPointerException if either node is null\n      */\n-    protected void addNode(Node nodeToInsert, Node insertBeforeNode) {\n+    protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n         nodeToInsert.next = insertBeforeNode;\n         nodeToInsert.previous = insertBeforeNode.previous;\n         insertBeforeNode.previous.next = nodeToInsert;\n      * @param node  the node to remove\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void removeNode(Node node) {\n+    protected void removeNode(Node<E> node) {\n         node.previous.next = node.next;\n         node.next.previous = node.previous;\n         size--;\n \n     /**\n      * Gets the node at a particular index.\n-     * \n+     *\n      * @param index  the index, starting from 0\n      * @param endMarkerAllowed  whether or not the end marker can be returned if\n      * startIndex is set to the list's size\n      * the size of the list and endMakerAllowed is false; or greater than the\n      * size of the list\n      */\n-    protected Node getNode(int index, boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+    protected Node<E> getNode(int index, boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n         // Check the index is within the bounds\n         if (index < 0) {\n             throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                     \"list (\" + size + \").\");\n         }\n         // Search the list and get the node\n-        Node node;\n+        Node<E> node;\n         if (index < (size / 2)) {\n             // Search forwards\n             node = header.next;\n     //-----------------------------------------------------------------------\n     /**\n      * Creates an iterator for the sublist.\n-     * \n+     *\n      * @param subList  the sublist to get an iterator for\n      */\n-    protected Iterator createSubListIterator(LinkedSubList subList) {\n+    protected Iterator<E> createSubListIterator(LinkedSubList<E> subList) {\n         return createSubListListIterator(subList, 0);\n     }\n \n     /**\n      * Creates a list iterator for the sublist.\n-     * \n+     *\n      * @param subList  the sublist to get an iterator for\n      * @param fromIndex  the index to start from, relative to the sublist\n      */\n-    protected ListIterator createSubListListIterator(LinkedSubList subList, int fromIndex) {\n-        return new LinkedSubListIterator(subList, fromIndex);\n+    protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n+        return new LinkedSubListIterator<E>(subList, fromIndex);\n     }\n \n     //-----------------------------------------------------------------------\n     protected void doWriteObject(ObjectOutputStream outputStream) throws IOException {\n         // Write the size so we know how many nodes to read back\n         outputStream.writeInt(size());\n-        for (Iterator itr = iterator(); itr.hasNext();) {\n+        for (Iterator<E> itr = iterator(); itr.hasNext();) {\n             outputStream.writeObject(itr.next());\n         }\n     }\n      * The first serializable subclass must call this method from\n      * <code>readObject</code>.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected void doReadObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n         init();\n         int size = inputStream.readInt();\n         for (int i = 0; i < size; i++) {\n-            add(inputStream.readObject());\n+            add((E) inputStream.readObject());\n         }\n     }\n \n      * From Commons Collections 3.1, all access to the <code>value</code> property\n      * is via the methods on this class.\n      */\n-    protected static class Node {\n+    protected static class Node<E> {\n \n         /** A pointer to the node before this node */\n-        protected Node previous;\n+        protected Node<E> previous;\n         /** A pointer to the node after this node */\n-        protected Node next;\n+        protected Node<E> next;\n         /** The object contained within this node */\n-        protected Object value;\n+        protected E value;\n \n         /**\n          * Constructs a new header node.\n \n         /**\n          * Constructs a new node.\n-         * \n+         *\n          * @param value  the value to store\n          */\n-        protected Node(Object value) {\n+        protected Node(E value) {\n             super();\n             this.value = value;\n         }\n-        \n+\n         /**\n          * Constructs a new node.\n-         * \n+         *\n          * @param previous  the previous node in the list\n          * @param next  the next node in the list\n          * @param value  the value to store\n          */\n-        protected Node(Node previous, Node next, Object value) {\n+        protected Node(Node<E> previous, Node<E> next, E value) {\n             super();\n             this.previous = previous;\n             this.next = next;\n             this.value = value;\n         }\n-        \n+\n         /**\n          * Gets the value of the node.\n-         * \n+         *\n          * @return the value\n          * @since Commons Collections 3.1\n          */\n-        protected Object getValue() {\n+        protected E getValue() {\n             return value;\n         }\n-        \n+\n         /**\n          * Sets the value of the node.\n-         * \n+         *\n          * @param value  the value\n          * @since Commons Collections 3.1\n          */\n-        protected void setValue(Object value) {\n+        protected void setValue(E value) {\n             this.value = value;\n         }\n-        \n+\n         /**\n          * Gets the previous node.\n-         * \n+         *\n          * @return the previous node\n          * @since Commons Collections 3.1\n          */\n-        protected Node getPreviousNode() {\n+        protected Node<E> getPreviousNode() {\n             return previous;\n         }\n-        \n+\n         /**\n          * Sets the previous node.\n-         * \n+         *\n          * @param previous  the previous node\n          * @since Commons Collections 3.1\n          */\n-        protected void setPreviousNode(Node previous) {\n+        protected void setPreviousNode(Node<E> previous) {\n             this.previous = previous;\n         }\n-        \n+\n         /**\n          * Gets the next node.\n-         * \n+         *\n          * @return the next node\n          * @since Commons Collections 3.1\n          */\n-        protected Node getNextNode() {\n+        protected Node<E> getNextNode() {\n             return next;\n         }\n-        \n+\n         /**\n          * Sets the next node.\n-         * \n+         *\n          * @param next  the next node\n          * @since Commons Collections 3.1\n          */\n-        protected void setNextNode(Node next) {\n+        protected void setNextNode(Node<E> next) {\n             this.next = next;\n         }\n     }\n     /**\n      * A list iterator over the linked list.\n      */\n-    protected static class LinkedListIterator implements ListIterator, OrderedIterator {\n-        \n+    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n+\n         /** The parent list */\n-        protected final AbstractLinkedList parent;\n+        protected final AbstractLinkedList<E> parent;\n \n         /**\n          * The node that will be returned by {@link #next()}. If this is equal\n          * to {@link AbstractLinkedList#header} then there are no more values to return.\n          */\n-        protected Node next;\n+        protected Node<E> next;\n \n         /**\n          * The index of {@link #next}.\n          * Should be accessed through {@link #getLastNodeReturned()} to enforce\n          * this behaviour.\n          */\n-        protected Node current;\n+        protected Node<E> current;\n \n         /**\n          * The modification count that the list is expected to have. If the list\n \n         /**\n          * Create a ListIterator for a list.\n-         * \n+         *\n          * @param parent  the parent list\n          * @param fromIndex  the index to start at\n          */\n-        protected LinkedListIterator(AbstractLinkedList parent, int fromIndex) throws IndexOutOfBoundsException {\n+        protected LinkedListIterator(AbstractLinkedList<E> parent, int fromIndex) throws IndexOutOfBoundsException {\n             super();\n             this.parent = parent;\n             this.expectedModCount = parent.modCount;\n         /**\n          * Checks the modification count of the list is the value that this\n          * object expects.\n-         * \n+         *\n          * @throws ConcurrentModificationException If the list's modification\n          * count isn't the value that was expected.\n          */\n \n         /**\n          * Gets the last node returned.\n-         * \n+         *\n          * @throws IllegalStateException If {@link #next()} or\n          * {@link #previous()} haven't been called, or if the node has been removed\n          * with {@link #remove()} or a new node added with {@link #add(Object)}.\n          */\n-        protected Node getLastNodeReturned() throws IllegalStateException {\n+        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n             if (current == null) {\n                 throw new IllegalStateException();\n             }\n             return next != parent.header;\n         }\n \n-        public Object next() {\n+        public E next() {\n             checkModCount();\n             if (!hasNext()) {\n                 throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n             }\n-            Object value = next.getValue();\n+            E value = next.getValue();\n             current = next;\n             next = next.next;\n             nextIndex++;\n             return next.previous != parent.header;\n         }\n \n-        public Object previous() {\n+        public E previous() {\n             checkModCount();\n             if (!hasPrevious()) {\n                 throw new NoSuchElementException(\"Already at start of list.\");\n             }\n             next = next.previous;\n-            Object value = next.getValue();\n+            E value = next.getValue();\n             current = next;\n             nextIndex--;\n             return value;\n             expectedModCount++;\n         }\n \n-        public void set(Object obj) {\n+        public void set(E obj) {\n             checkModCount();\n             getLastNodeReturned().setValue(obj);\n         }\n \n-        public void add(Object obj) {\n+        public void add(E obj) {\n             checkModCount();\n             parent.addNodeBefore(next, obj);\n             current = null;\n     /**\n      * A list iterator over the linked sub list.\n      */\n-    protected static class LinkedSubListIterator extends LinkedListIterator {\n-        \n+    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n+\n         /** The parent list */\n-        protected final LinkedSubList sub;\n-        \n-        protected LinkedSubListIterator(LinkedSubList sub, int startIndex) {\n+        protected final LinkedSubList<E> sub;\n+\n+        protected LinkedSubListIterator(LinkedSubList<E> sub, int startIndex) {\n             super(sub.parent, startIndex + sub.offset);\n             this.sub = sub;\n         }\n             return (super.nextIndex() - sub.offset);\n         }\n \n-        public void add(Object obj) {\n+        public void add(E obj) {\n             super.add(obj);\n             sub.expectedModCount = parent.modCount;\n             sub.size++;\n         }\n-        \n+\n         public void remove() {\n             super.remove();\n             sub.expectedModCount = parent.modCount;\n             sub.size--;\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * The sublist implementation for AbstractLinkedList.\n      */\n-    protected static class LinkedSubList extends AbstractList {\n+    protected static class LinkedSubList<E> extends AbstractList<E> {\n         /** The main list */\n-        AbstractLinkedList parent;\n+        AbstractLinkedList<E> parent;\n         /** Offset from the main list */\n         int offset;\n         /** Sublist size */\n         /** Sublist modCount */\n         int expectedModCount;\n \n-        protected LinkedSubList(AbstractLinkedList parent, int fromIndex, int toIndex) {\n+        protected LinkedSubList(AbstractLinkedList<E> parent, int fromIndex, int toIndex) {\n             if (fromIndex < 0) {\n                 throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n             }\n             return size;\n         }\n \n-        public Object get(int index) {\n+        public E get(int index) {\n             rangeCheck(index, size);\n             checkModCount();\n             return parent.get(index + offset);\n         }\n \n-        public void add(int index, Object obj) {\n+        public void add(int index, E obj) {\n             rangeCheck(index, size + 1);\n             checkModCount();\n             parent.add(index + offset, obj);\n             LinkedSubList.this.modCount++;\n         }\n \n-        public Object remove(int index) {\n+        public E remove(int index) {\n             rangeCheck(index, size);\n             checkModCount();\n-            Object result = parent.remove(index + offset);\n+            E result = parent.remove(index + offset);\n             expectedModCount = parent.modCount;\n             size--;\n             LinkedSubList.this.modCount++;\n             return result;\n         }\n \n-        public boolean addAll(Collection coll) {\n+        public boolean addAll(Collection<? extends E> coll) {\n             return addAll(size, coll);\n         }\n \n-        public boolean addAll(int index, Collection coll) {\n+        public boolean addAll(int index, Collection<? extends E> coll) {\n             rangeCheck(index, size + 1);\n             int cSize = coll.size();\n             if (cSize == 0) {\n             return true;\n         }\n \n-        public Object set(int index, Object obj) {\n+        public E set(int index, E obj) {\n             rangeCheck(index, size);\n             checkModCount();\n             return parent.set(index + offset, obj);\n \n         public void clear() {\n             checkModCount();\n-            Iterator it = iterator();\n+            Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 it.next();\n                 it.remove();\n             }\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<E> iterator() {\n             checkModCount();\n             return parent.createSubListIterator(this);\n         }\n \n-        public ListIterator listIterator(final int index) {\n+        public ListIterator<E> listIterator(final int index) {\n             rangeCheck(index, size + 1);\n             checkModCount();\n             return parent.createSubListListIterator(this, index);\n         }\n \n-        public List subList(int fromIndexInclusive, int toIndexExclusive) {\n-            return new LinkedSubList(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n+        public List<E> subList(int fromIndexInclusive, int toIndexExclusive) {\n+            return new LinkedSubList<E>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n         }\n \n         protected void rangeCheck(int index, int beyond) {\n             }\n         }\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/list/AbstractSerializableListDecorator.java\n+++ b/src/java/org/apache/commons/collections/list/AbstractSerializableListDecorator.java\n  * @author Stephen Colebourne\n  * @since Commons Collections 3.1\n  */\n-public abstract class AbstractSerializableListDecorator\n-        extends AbstractListDecorator\n+public abstract class AbstractSerializableListDecorator<E>\n+        extends AbstractListDecorator<E>\n         implements Serializable {\n \n     /** Serialization version */\n     /**\n      * Constructor.\n      */\n-    protected AbstractSerializableListDecorator(List list) {\n+    protected AbstractSerializableListDecorator(List<E> list) {\n         super(list);\n     }\n \n      * @throws IOException\n      * @throws ClassNotFoundException\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        collection = (Collection) in.readObject();\n+        collection = (Collection<E>) in.readObject();\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n  * @author Simon Kitching\n  * @author Stephen Colebourne\n  */\n-public class CursorableLinkedList extends AbstractLinkedList implements Serializable {\n+public class CursorableLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n \n     /** Ensure serialization compatibility */\n     private static final long serialVersionUID = 8836393098519411393L;\n \n     /** A list of the cursor currently open on this list */\n-    protected transient List cursors = new ArrayList();\n+    protected transient List<WeakReference<Cursor<E>>> cursors;\n \n     //-----------------------------------------------------------------------\n     /**\n      * \n      * @param coll  the collection to copy\n      */\n-    public CursorableLinkedList(Collection coll) {\n+    public CursorableLinkedList(Collection<E> coll) {\n         super(coll);\n     }\n \n      */\n     protected void init() {\n         super.init();\n-        cursors = new ArrayList();\n+        cursors = new ArrayList<WeakReference<Cursor<E>>>();\n     }\n \n     //-----------------------------------------------------------------------\n      * \n      * @return a new iterator that does <b>not</b> support concurrent modification\n      */\n-    public Iterator iterator() {\n+    public Iterator<E> iterator() {\n         return super.listIterator(0);\n     }\n \n      * \n      * @return a new cursor iterator\n      */\n-    public ListIterator listIterator() {\n+    public ListIterator<E> listIterator() {\n         return cursor(0);\n     }\n \n      * @param fromIndex  the index to start from\n      * @return a new cursor iterator\n      */\n-    public ListIterator listIterator(int fromIndex) {\n+    public ListIterator<E> listIterator(int fromIndex) {\n         return cursor(fromIndex);\n     }\n \n      *\n      * @return a new cursor iterator\n      */\n-    public CursorableLinkedList.Cursor cursor() {\n+    public CursorableLinkedList.Cursor<E> cursor() {\n         return cursor(0);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      *      (index &lt; 0 || index &gt; size()).\n      */\n-    public CursorableLinkedList.Cursor cursor(int fromIndex) {\n-        Cursor cursor = new Cursor(this, fromIndex);\n+    public CursorableLinkedList.Cursor<E> cursor(int fromIndex) {\n+        Cursor<E> cursor = new Cursor<E>(this, fromIndex);\n         registerCursor(cursor);\n         return cursor;\n     }\n      * @param node  node to update\n      * @param value  new value of the node\n      */\n-    protected void updateNode(Node node, Object value) {\n+    protected void updateNode(Node<E> node, E value) {\n         super.updateNode(node, value);\n         broadcastNodeChanged(node);\n     }\n      * @param insertBeforeNode  node to insert before\n      * @throws NullPointerException if either node is null\n      */\n-    protected void addNode(Node nodeToInsert, Node insertBeforeNode) {\n+    protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n         super.addNode(nodeToInsert, insertBeforeNode);\n         broadcastNodeInserted(nodeToInsert);\n     }\n      * @param node  the node to remove\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void removeNode(Node node) {\n+    protected void removeNode(Node<E> node) {\n         super.removeNode(node);\n         broadcastNodeRemoved(node);\n     }\n     protected void removeAllNodes() {\n         if (size() > 0) {\n             // superclass implementation would break all the iterators\n-            Iterator it = iterator();\n+            Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 it.next();\n                 it.remove();\n      * \n      * @param cursor  the cursor to register\n      */\n-    protected void registerCursor(Cursor cursor) {\n+    protected void registerCursor(Cursor<E> cursor) {\n         // We take this opportunity to clean the cursors list\n         // of WeakReference objects to garbage-collected cursors.\n-        for (Iterator it = cursors.iterator(); it.hasNext();) {\n-            WeakReference ref = (WeakReference) it.next();\n+        for (Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            WeakReference<Cursor<E>> ref = it.next();\n             if (ref.get() == null) {\n                 it.remove();\n             }\n         }\n-        cursors.add(new WeakReference(cursor));\n+        cursors.add(new WeakReference<Cursor<E>>(cursor));\n     }\n \n     /**\n      * \n      * @param cursor  the cursor to deregister\n      */\n-    protected void unregisterCursor(Cursor cursor) {\n-        for (Iterator it = cursors.iterator(); it.hasNext();) {\n-            WeakReference ref = (WeakReference) it.next();\n-            Cursor cur = (Cursor) ref.get();\n+    protected void unregisterCursor(Cursor<E> cursor) {\n+        for (Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cur = ref.get();\n             if (cur == null) {\n                 // some other unrelated cursor object has been \n                 // garbage-collected; let's take the opportunity to\n                 // clean up the cursors list anyway..\n                 it.remove();\n-\n             } else if (cur == cursor) {\n                 ref.clear();\n                 it.remove();\n      * \n      * @param node  the node that was changed\n      */\n-    protected void broadcastNodeChanged(Node node) {\n-        Iterator it = cursors.iterator();\n+    protected void broadcastNodeChanged(Node<E> node) {\n+        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n         while (it.hasNext()) {\n-            WeakReference ref = (WeakReference) it.next();\n-            Cursor cursor = (Cursor) ref.get();\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cursor = ref.get();\n             if (cursor == null) {\n                 it.remove(); // clean up list\n             } else {\n      * \n      * @param node  the node that was changed\n      */\n-    protected void broadcastNodeRemoved(Node node) {\n-        Iterator it = cursors.iterator();\n+    protected void broadcastNodeRemoved(Node<E> node) {\n+        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n         while (it.hasNext()) {\n-            WeakReference ref = (WeakReference) it.next();\n-            Cursor cursor = (Cursor) ref.get();\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cursor = ref.get();\n             if (cursor == null) {\n                 it.remove(); // clean up list\n             } else {\n      * \n      * @param node  the node that was changed\n      */\n-    protected void broadcastNodeInserted(Node node) {\n-        Iterator it = cursors.iterator();\n+    protected void broadcastNodeInserted(Node<E> node) {\n+        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n         while (it.hasNext()) {\n-            WeakReference ref = (WeakReference) it.next();\n-            Cursor cursor = (Cursor) ref.get();\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cursor = ref.get();\n             if (cursor == null) {\n                 it.remove(); // clean up list\n             } else {\n      * @param subList  the sublist to get an iterator for\n      * @param fromIndex  the index to start from, relative to the sublist\n      */\n-    protected ListIterator createSubListListIterator(LinkedSubList subList, int fromIndex) {\n-        SubCursor cursor = new SubCursor(subList, fromIndex);\n+    protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n+        SubCursor<E> cursor = new SubCursor<E>(subList, fromIndex);\n         registerCursor(cursor);\n         return cursor;\n     }\n      * An extended <code>ListIterator</code> that allows concurrent changes to\n      * the underlying list.\n      */\n-    public static class Cursor extends AbstractLinkedList.LinkedListIterator {\n+    public static class Cursor<E> extends AbstractLinkedList.LinkedListIterator<E> {\n         /** Is the cursor valid (not closed) */\n         boolean valid = true;\n         /** Is the next index valid */\n          * \n          * @param index  the index to start from\n          */\n-        protected Cursor(CursorableLinkedList parent, int index) {\n+        protected Cursor(CursorableLinkedList<E> parent, int index) {\n             super(parent, index);\n             valid = true;\n         }\n          * \n          * @param obj  the object to add\n          */\n-        public void add(Object obj) {\n+        public void add(E obj) {\n             // overridden, as the nodeInserted() method updates the iterator state\n             super.add(obj);\n             // matches the (next.previous == node) clause in nodeInserted()\n                     nextIndex = parent.size();\n                 } else {\n                     int pos = 0;\n-                    Node temp = parent.header.next;\n+                    Node<E> temp = parent.header.next;\n                     while (temp != next) {\n                         pos++;\n                         temp = temp.next;\n          * \n          * @param node  the node that changed\n          */\n-        protected void nodeChanged(Node node) {\n+        protected void nodeChanged(Node<E> node) {\n             // do nothing\n         }\n \n          * \n          * @param node  the node that was removed\n          */\n-        protected void nodeRemoved(Node node) {\n+        protected void nodeRemoved(Node<E> node) {\n             if (node == next && node == current) {\n                 // state where next() followed by previous()\n                 next = node.next;\n          * \n          * @param node  the node that was added\n          */\n-        protected void nodeInserted(Node node) {\n+        protected void nodeInserted(Node<E> node) {\n             if (node.previous == current) {\n                 next = node;\n             } else if (next.previous == node) {\n          */\n         public void close() {\n             if (valid) {\n-                ((CursorableLinkedList) parent).unregisterCursor(this);\n+                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n                 valid = false;\n             }\n         }\n      *\n      * @since Commons Collections 3.2\n      */\n-    protected static class SubCursor extends Cursor {\n+    protected static class SubCursor<E> extends Cursor<E> {\n \n         /** The parent list */\n-        protected final LinkedSubList sub;\n+        protected final LinkedSubList<E> sub;\n \n         /**\n          * Constructs a new cursor.\n          * \n          * @param index  the index to start from\n          */\n-        protected SubCursor(LinkedSubList sub, int index) {\n-            super((CursorableLinkedList) sub.parent, index + sub.offset);\n+        protected SubCursor(LinkedSubList<E> sub, int index) {\n+            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n             this.sub = sub;\n         }\n \n             return (super.nextIndex() - sub.offset);\n         }\n \n-        public void add(Object obj) {\n+        public void add(E obj) {\n             super.add(obj);\n             sub.expectedModCount = parent.modCount;\n             sub.size++;\n--- a/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class NodeCachingLinkedList extends AbstractLinkedList implements Serializable {\n+public class NodeCachingLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 6897789178562232073L;\n      * Cached nodes are stored in a singly-linked list with\n      * <code>next</code> pointing to the next element.\n      */\n-    protected transient Node firstCachedNode;\n+    protected transient Node<E> firstCachedNode;\n     \n     /**\n      * The size of the cache.\n      * \n      * @param coll  the collection to copy\n      */\n-    public NodeCachingLinkedList(Collection coll) {\n+    public NodeCachingLinkedList(Collection<E> coll) {\n         super(coll);\n         this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n     }\n      *\n      * @return a node, or <code>null</code> if there are no nodes in the cache.\n      */\n-    protected Node getNodeFromCache() {\n+    protected Node<E> getNodeFromCache() {\n         if (cacheSize == 0) {\n             return null;\n         }\n-        Node cachedNode = firstCachedNode;\n+        Node<E> cachedNode = firstCachedNode;\n         firstCachedNode = cachedNode.next;\n         cachedNode.next = null; // This should be changed anyway, but defensively\n                                 // set it to null.                    \n      * \n      * @param node  the node to add to the cache\n      */\n-    protected void addNodeToCache(Node node) {\n+    protected void addNodeToCache(Node<E> node) {\n         if (isCacheFull()) {\n             // don't cache the node.\n             return;\n         }\n         // clear the node's contents and add it to the cache.\n-        Node nextCachedNode = firstCachedNode;\n+        Node<E> nextCachedNode = firstCachedNode;\n         node.previous = null;\n         node.next = nextCachedNode;\n         node.setValue(null);\n      * @param value  value of the new node\n      * @return the newly created node\n      */\n-    protected Node createNode(Object value) {\n-        Node cachedNode = getNodeFromCache();\n+    protected Node<E> createNode(E value) {\n+        Node<E> cachedNode = getNodeFromCache();\n         if (cachedNode == null) {\n             return super.createNode(value);\n-        } else {\n-            cachedNode.setValue(value);\n-            return cachedNode;\n-        }\n+        }\n+        cachedNode.setValue(value);\n+        return cachedNode;\n     }\n \n     /**\n      * \n      * @param node  the node to remove\n      */\n-    protected void removeNode(Node node) {\n+    protected void removeNode(Node<E> node) {\n         super.removeNode(node);\n         addNodeToCache(node);\n     }\n         // {@link AbstractLinkedList.removeAllNodes()} removes the\n         // nodes by removing references directly from {@link #header}.\n         int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n-        Node node = header.next;\n+        Node<E> node = header.next;\n         for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n-            Node oldNode = node;\n+            Node<E> oldNode = node;\n             node = node.next;\n             addNodeToCache(oldNode);\n         }\n--- a/src/java/org/apache/commons/collections/list/SetUniqueList.java\n+++ b/src/java/org/apache/commons/collections/list/SetUniqueList.java\n  * @author Stephen Colebourne\n  * @author Tom Dunham\n  */\n-public class SetUniqueList extends AbstractSerializableListDecorator {\n+public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 7196982186153478694L;\n     /**\n      * Internal Set to maintain uniqueness.\n      */\n-    protected final Set set;\n+    protected final Set<E> set;\n \n     /**\n      * Factory method to create a SetList using the supplied list to retain order.\n      * <p>\n      * If the list contains duplicates, these are removed (first indexed one kept).\n      * A <code>HashSet</code> is used for the set behaviour.\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static SetUniqueList decorate(List list) {\n+    public static <E> SetUniqueList<E> decorate(List<E> list) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n         if (list.isEmpty()) {\n-            return new SetUniqueList(list, new HashSet());\n-        } else {\n-            List temp = new ArrayList(list);\n-            list.clear();\n-            SetUniqueList sl = new SetUniqueList(list, new HashSet());\n-            sl.addAll(temp);\n-            return sl;\n-        }\n+            return new SetUniqueList<E>(list, new HashSet<E>());\n+        }\n+        List<E> temp = new ArrayList<E>(list);\n+        list.clear();\n+        SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n+        sl.addAll(temp);\n+        return sl;\n     }\n \n     //-----------------------------------------------------------------------\n      * Constructor that wraps (not copies) the List and specifies the set to use.\n      * <p>\n      * The set and list must both be correctly initialised to the same elements.\n-     * \n+     *\n      * @param set  the set to decorate, must not be null\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if set or list is null\n      */\n-    protected SetUniqueList(List list, Set set) {\n+    protected SetUniqueList(List<E> list, Set<E> set) {\n         super(list);\n         if (set == null) {\n             throw new IllegalArgumentException(\"Set must not be null\");\n     //-----------------------------------------------------------------------\n     /**\n      * Gets an unmodifiable view as a Set.\n-     * \n+     *\n      * @return an unmodifiable set view\n      */\n-    public Set asSet() {\n+    public Set<E> asSet() {\n         return UnmodifiableSet.decorate(set);\n     }\n \n      * The <code>List</code> interface requires that this method returns\n      * <code>true</code> always. However this class may return <code>false</code>\n      * because of the <code>Set</code> behaviour.\n-     * \n+     *\n      * @param object the object to add\n      * @return true if object was added\n      */\n-    public boolean add(Object object) {\n+    public boolean add(E object) {\n         // gets initial size\n         final int sizeBefore = size();\n \n      * <i>(Violation)</i>\n      * The <code>List</code> interface makes the assumption that the element is\n      * always inserted. This may not happen with this implementation.\n-     * \n+     *\n      * @param index  the index to insert at\n      * @param object  the object to add\n      */\n-    public void add(int index, Object object) {\n+    public void add(int index, E object) {\n         // adds element if it is not contained already\n         if (set.contains(object) == false) {\n             super.add(index, object);\n      * <i>(Violation)</i>\n      * The <code>List</code> interface makes the assumption that the elements\n      * are always inserted. This may not happen with this implementation.\n-     * \n+     *\n      * @param coll  the collection to add in iterator order\n      * @return true if this collection changed\n      */\n-    public boolean addAll(Collection coll) {\n+    public boolean addAll(Collection<? extends E> coll) {\n         return addAll(size(), coll);\n     }\n \n      * <i>(Violation)</i>\n      * The <code>List</code> interface makes the assumption that the elements\n      * are always inserted. This may not happen with this implementation.\n-     * \n+     *\n      * @param index  the index to insert at\n      * @param coll  the collection to add in iterator order\n      * @return true if this collection changed\n      */\n-    public boolean addAll(int index, Collection coll) {\n-        // gets initial size\n-        final int sizeBefore = size();\n-\n-        // adds all elements\n-        for (final Iterator it = coll.iterator(); it.hasNext();) {\n-            int sizeBeforeAddNext = size();\n-            add(index, it.next());\n-            // if it was inserted, then increase the target index\n-            if (sizeBeforeAddNext != size()) {\n-              index++;\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        HashSet<E> temp = new HashSet<E>(coll);\n+        temp.removeAll(set);\n+        if (temp.isEmpty()) {\n+            return false;\n+        }\n+        for (E e : coll) {\n+            if (temp.contains(e)) {\n+                add(index, e);\n+                index++;\n             }\n         }\n-\n-        // compares sizes to detect if collection changed\n-        return sizeBefore != size();\n+        return true;\n     }\n \n     //-----------------------------------------------------------------------\n      * Afterwards, any previous duplicate is removed\n      * If the object is not already in the list then a normal set occurs.\n      * If it is present, then the old version is removed.\n-     * \n+     *\n      * @param index  the index to insert at\n      * @param object  the object to set\n      * @return the previous object\n      */\n-    public Object set(int index, Object object) {\n+    public E set(int index, E object) {\n         int pos = indexOf(object);\n-        Object removed = super.set(index, object);\n+        E removed = super.set(index, object);\n \n         if (pos != -1 && pos != index) {\n             // the object is already in the uniq list\n         return result;\n     }\n \n-    public Object remove(int index) {\n-        Object result = super.remove(index);\n+    public E remove(int index) {\n+        E result = super.remove(index);\n         set.remove(result);\n         return result;\n     }\n \n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         boolean result = super.removeAll(coll);\n         set.removeAll(coll);\n         return result;\n     }\n \n-    public boolean retainAll(Collection coll) {\n+    public boolean retainAll(Collection<?> coll) {\n         boolean result = super.retainAll(coll);\n         set.retainAll(coll);\n         return result;\n         return set.contains(object);\n     }\n \n-    public boolean containsAll(Collection coll) {\n+    public boolean containsAll(Collection<?> coll) {\n         return set.containsAll(coll);\n     }\n \n-    public Iterator iterator() {\n-        return new SetListIterator(super.iterator(), set);\n-    }\n-\n-    public ListIterator listIterator() {\n-        return new SetListListIterator(super.listIterator(), set);\n-    }\n-\n-    public ListIterator listIterator(int index) {\n-        return new SetListListIterator(super.listIterator(index), set);\n-    }\n-\n-    public List subList(int fromIndex, int toIndex) {\n-        List superSubList = super.subList(fromIndex, toIndex);\n-        Set subSet = createSetBasedOnList(set, superSubList);\n-        return new SetUniqueList(superSubList, subSet);\n-    }\n-\n-    protected Set createSetBasedOnList(Set set, List list) {\n-        Set subSet = null;\n-        if(set.getClass().equals(HashSet.class)) {\n-            subSet = new HashSet();\n+    public Iterator<E> iterator() {\n+        return new SetListIterator<E>(super.iterator(), set);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return new SetListListIterator<E>(super.listIterator(), set);\n+    }\n+\n+    public ListIterator<E> listIterator(int index) {\n+        return new SetListListIterator<E>(super.listIterator(index), set);\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> superSubList = super.subList(fromIndex, toIndex);\n+        Set<E> subSet = createSetBasedOnList(set, superSubList);\n+        return new SetUniqueList<E>(superSubList, subSet);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n+        Set<E> subSet = null;\n+        if (set.getClass().equals(HashSet.class)) {\n+            subSet = new HashSet<E>();\n         } else {\n             try {\n-                subSet = (Set) set.getClass().newInstance();\n-            } catch(InstantiationException ie) {\n-                subSet = new HashSet();\n-            } catch(IllegalAccessException iae) {\n-                subSet = new HashSet();\n+                subSet = (Set<E>) set.getClass().newInstance();\n+            } catch (InstantiationException ie) {\n+                subSet = new HashSet<E>();\n+            } catch (IllegalAccessException iae) {\n+                subSet = new HashSet<E>();\n             }\n         }\n         subSet.addAll(list);\n     /**\n      * Inner class iterator.\n      */\n-    static class SetListIterator extends AbstractIteratorDecorator {\n-        \n-        protected final Set set;\n-        protected Object last = null;\n-        \n-        protected SetListIterator(Iterator it, Set set) {\n+    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListIterator(Iterator<E> it, Set<E> set) {\n             super(it);\n             this.set = set;\n         }\n-        \n-        public Object next() {\n+\n+        public E next() {\n             last = super.next();\n             return last;\n         }\n             last = null;\n         }\n     }\n-    \n+\n     /**\n      * Inner class iterator.\n      */\n-    static class SetListListIterator extends AbstractListIteratorDecorator {\n-        \n-        protected final Set set;\n-        protected Object last = null;\n-        \n-        protected SetListListIterator(ListIterator it, Set set) {\n+    static class SetListListIterator<E> extends AbstractListIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListListIterator(ListIterator<E> it, Set<E> set) {\n             super(it);\n             this.set = set;\n         }\n-        \n-        public Object next() {\n+\n+        public E next() {\n             last = super.next();\n             return last;\n         }\n \n-        public Object previous() {\n+        public E previous() {\n             last = super.previous();\n             return last;\n         }\n             last = null;\n         }\n \n-        public void add(Object object) {\n+        public void add(E object) {\n             if (set.contains(object) == false) {\n                 super.add(object);\n                 set.add(object);\n             }\n         }\n-        \n-        public void set(Object object) {\n+\n+        public void set(E object) {\n             throw new UnsupportedOperationException(\"ListIterator does not support set\");\n         }\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/list/TransformedList.java\n+++ b/src/java/org/apache/commons/collections/list/TransformedList.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedList extends TransformedCollection implements List {\n+public class TransformedList<E> extends TransformedCollection<E> implements List<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 1077193035000013141L;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if list or transformer is null\n      */\n-    public static List decorate(List list, Transformer transformer) {\n-        return new TransformedList(list, transformer);\n+    public static <E> List<E> decorate(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedList<E>(list, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if list or transformer is null\n      * @since Commons Collections 3.3\n      */\n+    // TODO: Generics\n     public static List decorateTransform(List list, Transformer transformer) {\n         TransformedList decorated = new TransformedList(list, transformer);\n         if (transformer != null && list != null && list.size() > 0) {\n             Object[] values = list.toArray();\n             list.clear();\n             for(int i=0; i<values.length; i++) {\n-                decorated.getCollection().add(transformer.transform(values[i]));\n+                decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n         return decorated;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if list or transformer is null\n      */\n-    protected TransformedList(List list, Transformer transformer) {\n+    protected TransformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n         super(list, transformer);\n     }\n \n      * \n      * @return the decorated list\n      */\n-    protected List getList() {\n-        return (List) collection;\n+    protected List<E> getList() {\n+        return (List<E>) collection;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object get(int index) {\n+    public E get(int index) {\n         return getList().get(index);\n     }\n \n         return getList().lastIndexOf(object);\n     }\n \n-    public Object remove(int index) {\n+    public E remove(int index) {\n         return getList().remove(index);\n     }\n \n     //-----------------------------------------------------------------------\n-    public void add(int index, Object object) {\n+    public void add(int index, E object) {\n         object = transform(object);\n         getList().add(index, object);\n     }\n \n-    public boolean addAll(int index, Collection coll) {\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n         coll = transform(coll);\n         return getList().addAll(index, coll);\n     }\n \n-    public ListIterator listIterator() {\n+    public ListIterator<E> listIterator() {\n         return listIterator(0);\n     }\n \n-    public ListIterator listIterator(int i) {\n+    public ListIterator<E> listIterator(int i) {\n         return new TransformedListIterator(getList().listIterator(i));\n     }\n \n-    public Object set(int index, Object object) {\n+    public E set(int index, E object) {\n         object = transform(object);\n         return getList().set(index, object);\n     }\n \n-    public List subList(int fromIndex, int toIndex) {\n-        List sub = getList().subList(fromIndex, toIndex);\n-        return new TransformedList(sub, transformer);\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> sub = getList().subList(fromIndex, toIndex);\n+        return new TransformedList<E>(sub, transformer);\n     }\n \n     /**\n      * Inner class Iterator for the TransformedList\n      */\n-    protected class TransformedListIterator extends AbstractListIteratorDecorator {\n-        \n-        protected TransformedListIterator(ListIterator iterator) {\n+    protected class TransformedListIterator extends AbstractListIteratorDecorator<E> {\n+\n+        protected TransformedListIterator(ListIterator<E> iterator) {\n             super(iterator);\n         }\n-        \n-        public void add(Object object) {\n+\n+        public void add(E object) {\n             object = transform(object);\n             iterator.add(object);\n         }\n-        \n-        public void set(Object object) {\n+\n+        public void set(E object) {\n             object = transform(object);\n             iterator.set(object);\n         }\n--- a/src/java/org/apache/commons/collections/list/TreeList.java\n+++ b/src/java/org/apache/commons/collections/list/TreeList.java\n  * <p>\n  * <code>LinkedList</code> is rarely a good choice of implementation.\n  * <code>TreeList</code> is almost always a good replacement for it, although it\n- * does use sligtly more memory.\n+ * does use slightly more memory.\n  *\n  * @since Commons Collections 3.1\n  * @version $Revision$ $Date$\n  * @author Joerg Schmuecker\n  * @author Stephen Colebourne\n  */\n-public class TreeList extends AbstractList {\n+public class TreeList<E> extends AbstractList<E> {\n //    add; toArray; iterator; insert; get; indexOf; remove\n //    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n //   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n //  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n \n     /** The root node in the AVL tree */\n-    private AVLNode root;\n+    private AVLNode<E> root;\n \n     /** The current size of the list */\n     private int size;\n \n     /**\n      * Constructs a new empty list that copies the specified list.\n-     * \n+     *\n      * @param coll  the collection to copy\n      * @throws NullPointerException if the collection is null\n      */\n-    public TreeList(Collection coll) {\n+    public TreeList(Collection<E> coll) {\n         super();\n         addAll(coll);\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the element at the specified index.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the element at the specified index\n      */\n-    public Object get(int index) {\n+    public E get(int index) {\n         checkInterval(index, 0, size() - 1);\n         return root.get(index).getValue();\n     }\n \n     /**\n      * Gets the current size of the list.\n-     * \n+     *\n      * @return the current size\n      */\n     public int size() {\n \n     /**\n      * Gets an iterator over the list.\n-     * \n+     *\n      * @return an iterator over the list\n      */\n-    public Iterator iterator() {\n+    public Iterator<E> iterator() {\n         // override to go 75% faster\n         return listIterator(0);\n     }\n \n     /**\n      * Gets a ListIterator over the list.\n-     * \n+     *\n      * @return the new iterator\n      */\n-    public ListIterator listIterator() {\n+    public ListIterator<E> listIterator() {\n         // override to go 75% faster\n         return listIterator(0);\n     }\n \n     /**\n      * Gets a ListIterator over the list.\n-     * \n+     *\n      * @param fromIndex  the index to start from\n      * @return the new iterator\n      */\n-    public ListIterator listIterator(int fromIndex) {\n+    public ListIterator<E> listIterator(int fromIndex) {\n         // override to go 75% faster\n         // cannot use EmptyIterator as iterator.add() must work\n         checkInterval(fromIndex, 0, size());\n-        return new TreeListIterator(this, fromIndex);\n+        return new TreeListIterator<E>(this, fromIndex);\n     }\n \n     /**\n      * Searches for the index of an object in the list.\n-     * \n+     *\n      * @return the index of the object, -1 if not found\n      */\n     public int indexOf(Object object) {\n \n     /**\n      * Searches for the presence of an object in the list.\n-     * \n+     *\n      * @return true if the object is found\n      */\n     public boolean contains(Object object) {\n \n     /**\n      * Converts the list into an array.\n-     * \n+     *\n      * @return the list as an array\n      */\n     public Object[] toArray() {\n     //-----------------------------------------------------------------------\n     /**\n      * Adds a new element to the list.\n-     * \n+     *\n      * @param index  the index to add before\n      * @param obj  the element to add\n      */\n-    public void add(int index, Object obj) {\n+    public void add(int index, E obj) {\n         modCount++;\n         checkInterval(index, 0, size());\n         if (root == null) {\n-            root = new AVLNode(index, obj, null, null);\n+            root = new AVLNode<E>(index, obj, null, null);\n         } else {\n             root = root.insert(index, obj);\n         }\n \n     /**\n      * Sets the element at the specified index.\n-     * \n+     *\n      * @param index  the index to set\n      * @param obj  the object to store at the specified index\n      * @return the previous object at that index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object set(int index, Object obj) {\n+    public E set(int index, E obj) {\n         checkInterval(index, 0, size() - 1);\n-        AVLNode node = root.get(index);\n-        Object result = node.value;\n+        AVLNode<E> node = root.get(index);\n+        E result = node.value;\n         node.setValue(obj);\n         return result;\n     }\n \n     /**\n      * Removes the element at the specified index.\n-     * \n+     *\n      * @param index  the index to remove\n      * @return the previous object at that index\n      */\n-    public Object remove(int index) {\n+    public E remove(int index) {\n         modCount++;\n         checkInterval(index, 0, size() - 1);\n-        Object result = get(index);\n+        E result = get(index);\n         root = root.remove(index);\n         size--;\n         return result;\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether the index is valid.\n-     * \n+     *\n      * @param index  the index to check\n      * @param startIndex  the first allowed index\n      * @param endIndex  the last allowed index\n      * The Faedelung calculation stores a flag for both the left and right child\n      * to indicate if they are a child (false) or a link as in linked list (true).\n      */\n-    static class AVLNode {\n+    static class AVLNode<E> {\n         /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n-        private AVLNode left;\n+        private AVLNode<E> left;\n         /** Flag indicating that left reference is not a subtree but the predecessor. */\n         private boolean leftIsPrevious;\n         /** The right child node or the successor if {@link #rightIsNext}. */\n-        private AVLNode right;\n+        private AVLNode<E> right;\n         /** Flag indicating that right reference is not a subtree but the successor. */\n         private boolean rightIsNext;\n         /** How many levels of left/right are below this one. */\n         /** The relative position, root holds absolute position. */\n         private int relativePosition;\n         /** The stored element. */\n-        private Object value;\n+        private E value;\n \n         /**\n          * Constructs a new node with a relative position.\n-         * \n+         *\n          * @param relativePosition  the relative position of the node\n          * @param obj  the value for the ndoe\n          * @param rightFollower the node with the value following this one\n          * @param leftFollower the node with the value leading this one\n          */\n-        private AVLNode(int relativePosition, Object obj, AVLNode rightFollower, AVLNode leftFollower) {\n+        private AVLNode(int relativePosition, E obj, AVLNode<E> rightFollower, AVLNode<E> leftFollower) {\n             this.relativePosition = relativePosition;\n             value = obj;\n             rightIsNext = true;\n \n         /**\n          * Gets the value.\n-         * \n+         *\n          * @return the value of this node\n          */\n-        Object getValue() {\n+        E getValue() {\n             return value;\n         }\n \n         /**\n          * Sets the value.\n-         * \n+         *\n          * @param obj  the value to store\n          */\n-        void setValue(Object obj) {\n+        void setValue(E obj) {\n             this.value = obj;\n         }\n \n          * Locate the element with the given index relative to the\n          * offset of the parent of this node.\n          */\n-        AVLNode get(int index) {\n+        AVLNode<E> get(int index) {\n             int indexRelativeToMe = index - relativePosition;\n \n             if (indexRelativeToMe == 0) {\n                 return this;\n             }\n \n-            AVLNode nextNode = ((indexRelativeToMe < 0) ? getLeftSubTree() : getRightSubTree());\n+            AVLNode<E> nextNode = ((indexRelativeToMe < 0) ? getLeftSubTree() : getRightSubTree());\n             if (nextNode == null) {\n                 return null;\n             }\n \n         /**\n          * Stores the node and its children into the array specified.\n-         * \n+         *\n          * @param array the array to be filled\n          * @param index the index of this node\n          */\n \n         /**\n          * Gets the next node in the list after this one.\n-         * \n+         *\n          * @return the next node\n          */\n-        AVLNode next() {\n+        AVLNode<E> next() {\n             if (rightIsNext || right == null) {\n                 return right;\n             }\n \n         /**\n          * Gets the node in the list before this one.\n-         * \n+         *\n          * @return the previous node\n          */\n-        AVLNode previous() {\n+        AVLNode<E> previous() {\n             if (leftIsPrevious || left == null) {\n                 return left;\n             }\n         }\n \n         /**\n-         * Inserts a node at the position index.  \n-         * \n-         * @param index is the index of the position relative to the position of \n+         * Inserts a node at the position index.\n+         *\n+         * @param index is the index of the position relative to the position of\n          * the parent node.\n          * @param obj is the object to be stored in the position.\n          */\n-        AVLNode insert(int index, Object obj) {\n+        AVLNode<E> insert(int index, E obj) {\n             int indexRelativeToMe = index - relativePosition;\n \n             if (indexRelativeToMe <= 0) {\n                 return insertOnLeft(indexRelativeToMe, obj);\n-            } else {\n-                return insertOnRight(indexRelativeToMe, obj);\n-            }\n-        }\n-\n-        private AVLNode insertOnLeft(int indexRelativeToMe, Object obj) {\n-            AVLNode ret = this;\n+            }\n+            return insertOnRight(indexRelativeToMe, obj);\n+        }\n+\n+        private AVLNode<E> insertOnLeft(int indexRelativeToMe, E obj) {\n+            AVLNode<E> ret = this;\n \n             if (getLeftSubTree() == null) {\n-                setLeft(new AVLNode(-1, obj, this, left), null);\n+                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n             } else {\n                 setLeft(left.insert(indexRelativeToMe, obj), null);\n             }\n             return ret;\n         }\n \n-        private AVLNode insertOnRight(int indexRelativeToMe, Object obj) {\n-            AVLNode ret = this;\n+        private AVLNode<E> insertOnRight(int indexRelativeToMe, E obj) {\n+            AVLNode<E> ret = this;\n \n             if (getRightSubTree() == null) {\n-                setRight(new AVLNode(+1, obj, right, this), null);\n+                setRight(new AVLNode<E>(+1, obj, right, this), null);\n             } else {\n                 setRight(right.insert(indexRelativeToMe, obj), null);\n             }\n         /**\n          * Gets the left node, returning null if its a faedelung.\n          */\n-        private AVLNode getLeftSubTree() {\n+        private AVLNode<E> getLeftSubTree() {\n             return (leftIsPrevious ? null : left);\n         }\n \n         /**\n          * Gets the right node, returning null if its a faedelung.\n          */\n-        private AVLNode getRightSubTree() {\n+        private AVLNode<E> getRightSubTree() {\n             return (rightIsNext ? null : right);\n         }\n \n         /**\n          * Gets the rightmost child of this node.\n-         * \n+         *\n          * @return the rightmost child (greatest index)\n          */\n-        private AVLNode max() {\n+        private AVLNode<E> max() {\n             return (getRightSubTree() == null) ? this : right.max();\n         }\n \n         /**\n          * Gets the leftmost child of this node.\n-         * \n+         *\n          * @return the leftmost child (smallest index)\n          */\n-        private AVLNode min() {\n+        private AVLNode<E> min() {\n             return (getLeftSubTree() == null) ? this : left.min();\n         }\n \n         /**\n          * Removes the node at a given position.\n-         * \n-         * @param index is the index of the element to be removed relative to the position of \n+         *\n+         * @param index is the index of the element to be removed relative to the position of\n          * the parent node of the current node.\n          */\n-        AVLNode remove(int index) {\n+        AVLNode<E> remove(int index) {\n             int indexRelativeToMe = index - relativePosition;\n \n             if (indexRelativeToMe == 0) {\n             return balance();\n         }\n \n-        private AVLNode removeMax() {\n+        private AVLNode<E> removeMax() {\n             if (getRightSubTree() == null) {\n                 return removeSelf();\n             }\n             return balance();\n         }\n \n-        private AVLNode removeMin() {\n+        private AVLNode<E> removeMin() {\n             if (getLeftSubTree() == null) {\n                 return removeSelf();\n             }\n          *\n          * @return the node that replaces this one in the parent\n          */\n-        private AVLNode removeSelf() {\n+        private AVLNode<E> removeSelf() {\n             if (getRightSubTree() == null && getLeftSubTree() == null) {\n                 return null;\n             }\n \n             if (heightRightMinusLeft() > 0) {\n                 // more on the right, so delete from the right\n-                AVLNode rightMin = right.min();\n+                AVLNode<E> rightMin = right.min();\n                 value = rightMin.value;\n                 if (leftIsPrevious) {\n                     left = rightMin.left;\n                 }\n             } else {\n                 // more on the left or equal, so delete from the left\n-                AVLNode leftMax = left.max();\n+                AVLNode<E> leftMax = left.max();\n                 value = leftMax.value;\n                 if (rightIsNext) {\n                     right = leftMax.right;\n                 }\n-                AVLNode leftPrevious = left.left;\n+                AVLNode<E> leftPrevious = left.left;\n                 left = left.removeMax();\n                 if (left == null) {\n                     // special case where left that was deleted was a double link\n         /**\n          * Balances according to the AVL algorithm.\n          */\n-        private AVLNode balance() {\n+        private AVLNode<E> balance() {\n             switch (heightRightMinusLeft()) {\n                 case 1 :\n                 case 0 :\n         /**\n          * Gets the relative position.\n          */\n-        private int getOffset(AVLNode node) {\n+        private int getOffset(AVLNode<E> node) {\n             if (node == null) {\n                 return 0;\n             }\n         /**\n          * Sets the relative position.\n          */\n-        private int setOffset(AVLNode node, int newOffest) {\n+        private int setOffset(AVLNode<E> node, int newOffest) {\n             if (node == null) {\n                 return 0;\n             }\n         /**\n          * Returns the height of the node or -1 if the node is null.\n          */\n-        private int getHeight(AVLNode node) {\n+        private int getHeight(AVLNode<E> node) {\n             return (node == null ? -1 : node.height);\n         }\n \n             return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n         }\n \n-        private AVLNode rotateLeft() {\n-            AVLNode newTop = right; // can't be faedelung!\n-            AVLNode movedNode = getRightSubTree().getLeftSubTree();\n+        private AVLNode<E> rotateLeft() {\n+            AVLNode<E> newTop = right; // can't be faedelung!\n+            AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n \n             int newTopPosition = relativePosition + getOffset(newTop);\n             int myNewPosition = -newTop.relativePosition;\n             return newTop;\n         }\n \n-        private AVLNode rotateRight() {\n-            AVLNode newTop = left; // can't be faedelung\n-            AVLNode movedNode = getLeftSubTree().getRightSubTree();\n+        private AVLNode<E> rotateRight() {\n+            AVLNode<E> newTop = left; // can't be faedelung\n+            AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n \n             int newTopPosition = relativePosition + getOffset(newTop);\n             int myNewPosition = -newTop.relativePosition;\n          * @param node  the new left subtree node\n          * @param previous  the previous node in the linked list\n          */\n-        private void setLeft(AVLNode node, AVLNode previous) {\n+        private void setLeft(AVLNode<E> node, AVLNode<E> previous) {\n             leftIsPrevious = (node == null);\n             left = (leftIsPrevious ? previous : node);\n             recalcHeight();\n          * @param node  the new left subtree node\n          * @param next  the next node in the linked list\n          */\n-        private void setRight(AVLNode node, AVLNode next) {\n+        private void setRight(AVLNode<E> node, AVLNode<E> next) {\n             rightIsNext = (node == null);\n             right = (rightIsNext ? next : node);\n             recalcHeight();\n //            }\n //            return count + left.checkLeftSubNode();\n //        }\n-//        \n+//\n //        private int checkRightSubNode() {\n //            AVLNode right = getRightSubTree();\n //            if (right == null) {\n     /**\n      * A list iterator over the linked list.\n      */\n-    static class TreeListIterator implements ListIterator, OrderedIterator {\n+    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n         /** The parent list */\n-        protected final TreeList parent;\n+        protected final TreeList<E> parent;\n         /**\n          * Cache of the next node that will be returned by {@link #next()}.\n          */\n-        protected AVLNode next;\n+        protected AVLNode<E> next;\n         /**\n          * The index of the next node to be returned.\n          */\n          * Cache of the last node that was returned by {@link #next()}\n          * or {@link #previous()}.\n          */\n-        protected AVLNode current;\n+        protected AVLNode<E> current;\n         /**\n          * The index of the last node that was returned.\n          */\n \n         /**\n          * Create a ListIterator for a list.\n-         * \n+         *\n          * @param parent  the parent list\n          * @param fromIndex  the index to start at\n          */\n-        protected TreeListIterator(TreeList parent, int fromIndex) throws IndexOutOfBoundsException {\n+        protected TreeListIterator(TreeList<E> parent, int fromIndex) throws IndexOutOfBoundsException {\n             super();\n             this.parent = parent;\n             this.expectedModCount = parent.modCount;\n         /**\n          * Checks the modification count of the list is the value that this\n          * object expects.\n-         * \n+         *\n          * @throws ConcurrentModificationException If the list's modification\n          * count isn't the value that was expected.\n          */\n             return (nextIndex < parent.size());\n         }\n \n-        public Object next() {\n+        public E next() {\n             checkModCount();\n             if (!hasNext()) {\n                 throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n             if (next == null) {\n                 next = parent.root.get(nextIndex);\n             }\n-            Object value = next.getValue();\n+            E value = next.getValue();\n             current = next;\n             currentIndex = nextIndex++;\n             next = next.next();\n             return (nextIndex > 0);\n         }\n \n-        public Object previous() {\n+        public E previous() {\n             checkModCount();\n             if (!hasPrevious()) {\n                 throw new NoSuchElementException(\"Already at start of list.\");\n             } else {\n                 next = next.previous();\n             }\n-            Object value = next.getValue();\n+            E value = next.getValue();\n             current = next;\n             currentIndex = --nextIndex;\n             return value;\n             expectedModCount++;\n         }\n \n-        public void set(Object obj) {\n+        public void set(E obj) {\n             checkModCount();\n             if (current == null) {\n                 throw new IllegalStateException();\n             current.setValue(obj);\n         }\n \n-        public void add(Object obj) {\n+        public void add(E obj) {\n             checkModCount();\n             parent.add(nextIndex, obj);\n             current = null;\n--- a/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n  * @author Stephen Colebourne\n  * @author Christian Siefkes\n  */\n-public class AbstractHashedMap extends AbstractMap implements IterableMap {\n-    \n+public class AbstractHashedMap<K, V> extends AbstractMap<K, V> implements IterableMap<K, V> {\n+\n     protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n     protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n     protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n     protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n     protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n     protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n-    \n+\n     /** The default capacity to use */\n     protected static final int DEFAULT_CAPACITY = 16;\n     /** The default threshold to use */\n     protected static final int MAXIMUM_CAPACITY = 1 << 30;\n     /** An object for masking null */\n     protected static final Object NULL = new Object();\n-    \n+\n     /** Load factor, normally 0.75 */\n     protected transient float loadFactor;\n     /** The size of the map */\n     protected transient int size;\n     /** Map entries */\n-    protected transient HashEntry[] data;\n+    protected transient HashEntry<K, V>[] data;\n     /** Size at which to rehash */\n     protected transient int threshold;\n     /** Modification count for iterators */\n     protected transient int modCount;\n     /** Entry set */\n-    protected transient EntrySet entrySet;\n+    protected transient EntrySet<K, V> entrySet;\n     /** Key set */\n-    protected transient KeySet keySet;\n+    protected transient KeySet<K> keySet;\n     /** Values */\n-    protected transient Values values;\n+    protected transient Values<V> values;\n \n     /**\n      * Constructor only used in deserialization, do not use otherwise.\n \n     /**\n      * Constructor which performs no validation on the passed in parameters.\n-     * \n+     *\n      * @param initialCapacity  the initial capacity, must be a power of two\n      * @param loadFactor  the load factor, must be &gt; 0.0f and generally &lt; 1.0f\n      * @param threshold  the threshold, must be sensible\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected AbstractHashedMap(int initialCapacity, float loadFactor, int threshold) {\n         super();\n         this.loadFactor = loadFactor;\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * default load factor. \n+     * default load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is less than one\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @throws IllegalArgumentException if the initial capacity is less than one\n      * @throws IllegalArgumentException if the load factor is less than or equal to zero\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected AbstractHashedMap(int initialCapacity, float loadFactor) {\n         super();\n         if (initialCapacity < 1) {\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    protected AbstractHashedMap(Map map) {\n+    protected AbstractHashedMap(Map<K, V> map) {\n         this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n         _putAll(map);\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the key specified.\n-     * \n+     *\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key) {\n+    public V get(Object key) {\n         key = convertKey(key);\n         int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                 return entry.getValue();\n \n     /**\n      * Gets the size of the map.\n-     * \n+     *\n      * @return the size\n      */\n     public int size() {\n \n     /**\n      * Checks whether the map is currently empty.\n-     * \n+     *\n      * @return true if the map is currently size zero\n      */\n     public boolean isEmpty() {\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether the map contains the specified key.\n-     * \n+     *\n      * @param key  the key to search for\n      * @return true if the map contains the key\n      */\n     public boolean containsKey(Object key) {\n         key = convertKey(key);\n         int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                 return true;\n \n     /**\n      * Checks whether the map contains the specified value.\n-     * \n+     *\n      * @param value  the value to search for\n      * @return true if the map contains the value\n      */\n     public boolean containsValue(Object value) {\n         if (value == null) {\n             for (int i = 0, isize = data.length; i < isize; i++) {\n-                HashEntry entry = data[i];\n+                HashEntry<K, V> entry = data[i];\n                 while (entry != null) {\n                     if (entry.getValue() == null) {\n                         return true;\n             }\n         } else {\n             for (int i = 0, isize = data.length; i < isize; i++) {\n-                HashEntry entry = data[i];\n+                HashEntry<K, V> entry = data[i];\n                 while (entry != null) {\n                     if (isEqualValue(value, entry.getValue())) {\n                         return true;\n     //-----------------------------------------------------------------------\n     /**\n      * Puts a key-value mapping into this map.\n-     * \n+     *\n      * @param key  the key to add\n      * @param value  the value to add\n      * @return the value previously mapped to this key, null if none\n      */\n-    public Object put(Object key, Object value) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n+    public V put(K key, V value) {\n+        Object convertedKey = convertKey(key);\n+        int hashCode = hash(convertedKey);\n         int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n+        HashEntry<K, V> entry = data[index];\n         while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                Object oldValue = entry.getValue();\n+            if (entry.hashCode == hashCode && isEqualKey(convertedKey, entry.key)) {\n+                V oldValue = entry.getValue();\n                 updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n-        \n+\n         addMapping(index, hashCode, key, value);\n         return null;\n     }\n      * <p>\n      * This implementation iterates around the specified map and\n      * uses {@link #put(Object, Object)}.\n-     * \n+     *\n      * @param map  the map to add\n      * @throws NullPointerException if the map is null\n      */\n-    public void putAll(Map map) {\n+    public void putAll(Map<? extends K, ? extends V> map) {\n         _putAll(map);\n     }\n \n      * @param map  the map to add\n      * @throws NullPointerException if the map is null\n      */\n-    private void _putAll(Map map) {\n+    private void _putAll(Map<? extends K, ? extends V> map) {\n         int mapSize = map.size();\n         if (mapSize == 0) {\n             return;\n         }\n         int newSize = (int) ((size + mapSize) / loadFactor + 1);\n         ensureCapacity(calculateNewCapacity(newSize));\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+        for (Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n \n     /**\n      * Removes the specified mapping from this map.\n-     * \n+     *\n      * @param key  the mapping to remove\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         key = convertKey(key);\n         int hashCode = hash(key);\n         int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        HashEntry previous = null;\n+        HashEntry<K, V> entry = data[index];\n+        HashEntry<K, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                Object oldValue = entry.getValue();\n+                V oldValue = entry.getValue();\n                 removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n      */\n     public void clear() {\n         modCount++;\n-        HashEntry[] data = this.data;\n+        HashEntry<K, V>[] data = this.data;\n         for (int i = data.length - 1; i >= 0; i--) {\n             data[i] = null;\n         }\n      * <p>\n      * The reverse conversion can be changed, if required, by overriding the\n      * getKey() method in the hash entry.\n-     * \n+     *\n      * @param key  the key convert\n      * @return the converted key\n      */\n     protected Object convertKey(Object key) {\n         return (key == null ? NULL : key);\n     }\n-    \n+\n     /**\n      * Gets the hash code for the key specified.\n      * This implementation uses the additional hashing routine from JDK1.4.\n      * Subclasses can override this to return alternate hash codes.\n-     * \n+     *\n      * @param key  the key to get a hash code for\n      * @return the hash code\n      */\n         h ^=  (h >>> 10);\n         return h;\n     }\n-    \n+\n     /**\n      * Compares two keys, in internal converted form, to see if they are equal.\n      * This implementation uses the equals method and assumes neither key is null.\n      * Subclasses can override this to match differently.\n-     * \n+     *\n      * @param key1  the first key to compare passed in from outside\n      * @param key2  the second key extracted from the entry via <code>entry.key</code>\n      * @return true if equal\n     protected boolean isEqualKey(Object key1, Object key2) {\n         return (key1 == key2 || key1.equals(key2));\n     }\n-    \n+\n     /**\n      * Compares two values, in external form, to see if they are equal.\n      * This implementation uses the equals method and assumes neither value is null.\n      * Subclasses can override this to match differently.\n-     * \n+     *\n      * @param value1  the first value to compare passed in from outside\n      * @param value2  the second value extracted from the entry via <code>getValue()</code>\n      * @return true if equal\n     protected boolean isEqualValue(Object value1, Object value2) {\n         return (value1 == value2 || value1.equals(value2));\n     }\n-    \n+\n     /**\n      * Gets the index into the data storage for the hashCode specified.\n      * This implementation uses the least significant bits of the hashCode.\n      * Subclasses can override this to return alternate bucketing.\n-     * \n+     *\n      * @param hashCode  the hash code to use\n      * @param dataSize  the size of the data to pick a bucket from\n      * @return the bucket index\n     protected int hashIndex(int hashCode, int dataSize) {\n         return hashCode & (dataSize - 1);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the entry mapped to the key specified.\n      * This method exists for subclasses that may need to perform a multi-step\n      * process accessing the entry. The public methods in this class don't use this\n      * method to gain a small performance boost.\n-     * \n+     *\n      * @param key  the key\n      * @return the entry, null if no match\n      */\n-    protected HashEntry getEntry(Object key) {\n+    protected HashEntry<K, V> getEntry(Object key) {\n         key = convertKey(key);\n         int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                 return entry;\n      * <p>\n      * This implementation calls <code>setValue()</code> on the entry.\n      * Subclasses could override to handle changes to the map.\n-     * \n+     *\n      * @param entry  the entry to update\n      * @param newValue  the new value to store\n      */\n-    protected void updateEntry(HashEntry entry, Object newValue) {\n+    protected void updateEntry(HashEntry<K, V> entry, V newValue) {\n         entry.setValue(newValue);\n     }\n-    \n+\n     /**\n      * Reuses an existing key-value mapping, storing completely new data.\n      * <p>\n      * This implementation sets all the data fields on the entry.\n      * Subclasses could populate additional entry fields.\n-     * \n+     *\n      * @param entry  the entry to update, not null\n      * @param hashIndex  the index in the data array\n      * @param hashCode  the hash code of the key to add\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void reuseEntry(HashEntry entry, int hashIndex, int hashCode, Object key, Object value) {\n+    protected void reuseEntry(HashEntry<K, V> entry, int hashIndex, int hashCode, K key, V value) {\n         entry.next = data[hashIndex];\n         entry.hashCode = hashCode;\n         entry.key = key;\n         entry.value = value;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Adds a new key-value mapping into this map.\n      * and <code>checkCapacity()</code>.\n      * It also handles changes to <code>modCount</code> and <code>size</code>.\n      * Subclasses could override to fully control adds to the map.\n-     * \n+     *\n      * @param hashIndex  the index into the data array to store at\n      * @param hashCode  the hash code of the key to add\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n+    protected void addMapping(int hashIndex, int hashCode, K key, V value) {\n         modCount++;\n-        HashEntry entry = createEntry(data[hashIndex], hashCode, key, value);\n+        HashEntry<K, V> entry = createEntry(data[hashIndex], hashCode, key, value);\n         addEntry(entry, hashIndex);\n         size++;\n         checkCapacity();\n     }\n-    \n+\n     /**\n      * Creates an entry to store the key-value data.\n      * <p>\n      * This implementation creates a new HashEntry instance.\n      * Subclasses can override this to return a different storage class,\n      * or implement caching.\n-     * \n+     *\n      * @param next  the next entry in sequence\n      * @param hashCode  the hash code to use\n      * @param key  the key to store\n      * @param value  the value to store\n      * @return the newly created entry\n      */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new HashEntry(next, hashCode, key, value);\n-    }\n-    \n+    protected HashEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new HashEntry<K, V>(next, hashCode, convertKey(key), value);\n+    }\n+\n     /**\n      * Adds an entry into this map.\n      * <p>\n      * @param entry  the entry to add\n      * @param hashIndex  the index into the data array to store at\n      */\n-    protected void addEntry(HashEntry entry, int hashIndex) {\n+    protected void addEntry(HashEntry<K, V> entry, int hashIndex) {\n         data[hashIndex] = entry;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Removes a mapping from the map.\n      * This implementation calls <code>removeEntry()</code> and <code>destroyEntry()</code>.\n      * It also handles changes to <code>modCount</code> and <code>size</code>.\n      * Subclasses could override to fully control removals from the map.\n-     * \n+     *\n      * @param entry  the entry to remove\n      * @param hashIndex  the index into the data structure\n      * @param previous  the previous entry in the chain\n      */\n-    protected void removeMapping(HashEntry entry, int hashIndex, HashEntry previous) {\n+    protected void removeMapping(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n         modCount++;\n         removeEntry(entry, hashIndex, previous);\n         size--;\n         destroyEntry(entry);\n     }\n-    \n+\n     /**\n      * Removes an entry from the chain stored in a particular index.\n      * <p>\n      * This implementation removes the entry from the data storage table.\n      * The size is not updated.\n      * Subclasses could override to handle changes to the map.\n-     * \n+     *\n      * @param entry  the entry to remove\n      * @param hashIndex  the index into the data structure\n      * @param previous  the previous entry in the chain\n      */\n-    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n+    protected void removeEntry(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n         if (previous == null) {\n             data[hashIndex] = entry.next;\n         } else {\n             previous.next = entry.next;\n         }\n     }\n-    \n+\n     /**\n      * Kills an entry ready for the garbage collector.\n      * <p>\n      * This implementation prepares the HashEntry for garbage collection.\n      * Subclasses can override this to implement caching (override clear as well).\n-     * \n+     *\n      * @param entry  the entry to destroy\n      */\n-    protected void destroyEntry(HashEntry entry) {\n+    protected void destroyEntry(HashEntry<K, V> entry) {\n         entry.next = null;\n         entry.key = null;\n         entry.value = null;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Checks the capacity of the map and enlarges it if necessary.\n             }\n         }\n     }\n-    \n+\n     /**\n      * Changes the size of the data structure to the capacity proposed.\n-     * \n+     *\n      * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected void ensureCapacity(int newCapacity) {\n         int oldCapacity = data.length;\n         if (newCapacity <= oldCapacity) {\n                     oldEntries[i] = null;  // gc\n                     do {\n                         HashEntry next = entry.next;\n-                        int index = hashIndex(entry.hashCode, newCapacity);  \n+                        int index = hashIndex(entry.hashCode, newCapacity);\n                         entry.next = newEntries[index];\n                         newEntries[index] = entry;\n                         entry = next;\n     /**\n      * Calculates the new capacity of the map.\n      * This implementation normalizes the capacity to a power of two.\n-     * \n+     *\n      * @param proposedCapacity  the proposed capacity\n      * @return the normalized new capacity\n      */\n         }\n         return newCapacity;\n     }\n-    \n+\n     /**\n      * Calculates the new threshold of the map, where it will be resized.\n      * This implementation uses the load factor.\n-     * \n+     *\n      * @param newCapacity  the new capacity\n      * @param factor  the load factor\n      * @return the new resize threshold\n     protected int calculateThreshold(int newCapacity, float factor) {\n         return (int) (newCapacity * factor);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the <code>next</code> field from a <code>HashEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n-     * \n+     *\n      * @param entry  the entry to query, must not be null\n      * @return the <code>next</code> field of the entry\n      * @throws NullPointerException if the entry is null\n      * @since Commons Collections 3.1\n      */\n-    protected HashEntry entryNext(HashEntry entry) {\n+    protected HashEntry<K, V> entryNext(HashEntry<K, V> entry) {\n         return entry.next;\n     }\n-    \n+\n     /**\n      * Gets the <code>hashCode</code> field from a <code>HashEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n-     * \n+     *\n      * @param entry  the entry to query, must not be null\n      * @return the <code>hashCode</code> field of the entry\n      * @throws NullPointerException if the entry is null\n      * @since Commons Collections 3.1\n      */\n-    protected int entryHashCode(HashEntry entry) {\n+    protected int entryHashCode(HashEntry<K, V> entry) {\n         return entry.hashCode;\n     }\n-    \n+\n     /**\n      * Gets the <code>key</code> field from a <code>HashEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n-     * \n+     *\n      * @param entry  the entry to query, must not be null\n      * @return the <code>key</code> field of the entry\n      * @throws NullPointerException if the entry is null\n      * @since Commons Collections 3.1\n      */\n-    protected Object entryKey(HashEntry entry) {\n-        return entry.key;\n-    }\n-    \n+    protected K entryKey(HashEntry<K, V> entry) {\n+        return entry.getKey();\n+    }\n+\n     /**\n      * Gets the <code>value</code> field from a <code>HashEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n-     * \n+     *\n      * @param entry  the entry to query, must not be null\n      * @return the <code>value</code> field of the entry\n      * @throws NullPointerException if the entry is null\n      * @since Commons Collections 3.1\n      */\n-    protected Object entryValue(HashEntry entry) {\n-        return entry.value;\n-    }\n-    \n+    protected V entryValue(HashEntry<K, V> entry) {\n+        return entry.getValue();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets an iterator over the map.\n      * methods to get the key and value, and set the value.\n      * It avoids the need to create an entrySet/keySet/values object.\n      * It also avoids creating the Map.Entry object.\n-     * \n+     *\n      * @return the map iterator\n      */\n-    public MapIterator mapIterator() {\n+    public MapIterator<K, V> mapIterator() {\n         if (size == 0) {\n-            return EmptyMapIterator.INSTANCE;\n-        }\n-        return new HashMapIterator(this);\n+            return EmptyMapIterator.<K, V>getInstance();\n+        }\n+        return new HashMapIterator<K, V>(this);\n     }\n \n     /**\n      * MapIterator implementation.\n      */\n-    protected static class HashMapIterator extends HashIterator implements MapIterator {\n-        \n-        protected HashMapIterator(AbstractHashedMap parent) {\n+    protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V> {\n+\n+        protected HashMapIterator(AbstractHashedMap<K, V> parent) {\n             super(parent);\n         }\n \n-        public Object next() {\n+        public K next() {\n             return super.nextEntry().getKey();\n         }\n \n-        public Object getKey() {\n-            HashEntry current = currentEntry();\n+        public K getKey() {\n+            HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             return current.getKey();\n         }\n \n-        public Object getValue() {\n-            HashEntry current = currentEntry();\n+        public V getValue() {\n+            HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n \n-        public Object setValue(Object value) {\n-            HashEntry current = currentEntry();\n+        public V setValue(V value) {\n+            HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             return current.setValue(value);\n         }\n     }\n-    \n-    //-----------------------------------------------------------------------    \n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the entrySet view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the entries, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the entrySet view\n      */\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         if (entrySet == null) {\n-            entrySet = new EntrySet(this);\n+            entrySet = new EntrySet<K, V>(this);\n         }\n         return entrySet;\n     }\n-    \n+\n     /**\n      * Creates an entry set iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @return the entrySet iterator\n      */\n-    protected Iterator createEntrySetIterator() {\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n         if (size() == 0) {\n-            return EmptyIterator.INSTANCE;\n-        }\n-        return new EntrySetIterator(this);\n+            return EmptyIterator.<Map.Entry<K, V>>getInstance();\n+        }\n+        return new EntrySetIterator<K, V>(this);\n     }\n \n     /**\n      * EntrySet implementation.\n      */\n-    protected static class EntrySet extends AbstractSet {\n+    protected static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n         /** The parent map */\n-        protected final AbstractHashedMap parent;\n-        \n-        protected EntrySet(AbstractHashedMap parent) {\n+        protected final AbstractHashedMap<K, V> parent;\n+\n+        protected EntrySet(AbstractHashedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         public int size() {\n             return parent.size();\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n-        \n+\n         public boolean contains(Object entry) {\n             if (entry instanceof Map.Entry) {\n-                Map.Entry e = (Map.Entry) entry;\n-                Entry match = parent.getEntry(e.getKey());\n+                Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n+                Entry<K, V> match = parent.getEntry(e.getKey());\n                 return (match != null && match.equals(e));\n             }\n             return false;\n         }\n-        \n+\n         public boolean remove(Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             if (contains(obj) == false) {\n                 return false;\n             }\n-            Map.Entry entry = (Map.Entry) obj;\n-            Object key = entry.getKey();\n-            parent.remove(key);\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            parent.remove(entry.getKey());\n             return true;\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<Map.Entry<K, V>> iterator() {\n             return parent.createEntrySetIterator();\n         }\n     }\n     /**\n      * EntrySet iterator.\n      */\n-    protected static class EntrySetIterator extends HashIterator {\n-        \n-        protected EntrySetIterator(AbstractHashedMap parent) {\n+    protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        protected EntrySetIterator(AbstractHashedMap<K, V> parent) {\n             super(parent);\n         }\n \n-        public Object next() {\n+        public Map.Entry<K, V> next() {\n             return super.nextEntry();\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the keySet view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the keys, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the keySet view\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         if (keySet == null) {\n-            keySet = new KeySet(this);\n+            keySet = new KeySet<K>(this);\n         }\n         return keySet;\n     }\n     /**\n      * Creates a key set iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @return the keySet iterator\n      */\n-    protected Iterator createKeySetIterator() {\n+    protected Iterator<K> createKeySetIterator() {\n         if (size() == 0) {\n-            return EmptyIterator.INSTANCE;\n-        }\n-        return new KeySetIterator(this);\n+            return EmptyIterator.<K>getInstance();\n+        }\n+        return new KeySetIterator<K>(this);\n     }\n \n     /**\n      * KeySet implementation.\n      */\n-    protected static class KeySet extends AbstractSet {\n+    protected static class KeySet<K> extends AbstractSet<K> {\n         /** The parent map */\n-        protected final AbstractHashedMap parent;\n-        \n-        protected KeySet(AbstractHashedMap parent) {\n+        protected final AbstractHashedMap<K, ?> parent;\n+\n+        protected KeySet(AbstractHashedMap<K, ?> parent) {\n             super();\n             this.parent = parent;\n         }\n         public int size() {\n             return parent.size();\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n-        \n+\n         public boolean contains(Object key) {\n             return parent.containsKey(key);\n         }\n-        \n+\n         public boolean remove(Object key) {\n             boolean result = parent.containsKey(key);\n             parent.remove(key);\n             return result;\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<K> iterator() {\n             return parent.createKeySetIterator();\n         }\n     }\n     /**\n      * KeySet iterator.\n      */\n-    protected static class KeySetIterator extends EntrySetIterator {\n-        \n-        protected KeySetIterator(AbstractHashedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n+    protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySetIterator(AbstractHashedMap<K, ?> parent) {\n+            super((AbstractHashedMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n             return super.nextEntry().getKey();\n         }\n     }\n-    \n-    //-----------------------------------------------------------------------    \n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Gets the values view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the values, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the values view\n      */\n-    public Collection values() {\n+    public Collection<V> values() {\n         if (values == null) {\n-            values = new Values(this);\n+            values = new Values<V>(this);\n         }\n         return values;\n     }\n     /**\n      * Creates a values iterator.\n      * Subclasses can override this to return iterators with different properties.\n-     * \n+     *\n      * @return the values iterator\n      */\n-    protected Iterator createValuesIterator() {\n+    protected Iterator<V> createValuesIterator() {\n         if (size() == 0) {\n-            return EmptyIterator.INSTANCE;\n-        }\n-        return new ValuesIterator(this);\n+            return EmptyIterator.<V>getInstance();\n+        }\n+        return new ValuesIterator<V>(this);\n     }\n \n     /**\n      * Values implementation.\n      */\n-    protected static class Values extends AbstractCollection {\n+    protected static class Values<V> extends AbstractCollection<V> {\n         /** The parent map */\n-        protected final AbstractHashedMap parent;\n-        \n-        protected Values(AbstractHashedMap parent) {\n+        protected final AbstractHashedMap<?, V> parent;\n+\n+        protected Values(AbstractHashedMap<?, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         public int size() {\n             return parent.size();\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n-        \n+\n         public boolean contains(Object value) {\n             return parent.containsValue(value);\n         }\n-        \n-        public Iterator iterator() {\n+\n+        public Iterator<V> iterator() {\n             return parent.createValuesIterator();\n         }\n     }\n     /**\n      * Values iterator.\n      */\n-    protected static class ValuesIterator extends HashIterator {\n-        \n-        protected ValuesIterator(AbstractHashedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n+    protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(AbstractHashedMap<?, V> parent) {\n+            super((AbstractHashedMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n             return super.nextEntry().getValue();\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * HashEntry used to store the data.\n      * The <code>entryXxx()</code> methods on <code>AbstractHashedMap</code> exist\n      * to provide the necessary access.\n      */\n-    protected static class HashEntry implements Map.Entry, KeyValue {\n+    protected static class HashEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n         /** The next entry in the hash chain */\n-        protected HashEntry next;\n+        protected HashEntry<K, V> next;\n         /** The hash code of the key */\n         protected int hashCode;\n         /** The key */\n         protected Object key;\n         /** The value */\n         protected Object value;\n-        \n-        protected HashEntry(HashEntry next, int hashCode, Object key, Object value) {\n+\n+        protected HashEntry(HashEntry<K, V> next, int hashCode, Object key, V value) {\n             super();\n             this.next = next;\n             this.hashCode = hashCode;\n             this.key = key;\n             this.value = value;\n         }\n-        \n-        public Object getKey() {\n-            return (key == NULL ? null : key);\n-        }\n-        \n-        public Object getValue() {\n-            return value;\n-        }\n-        \n-        public Object setValue(Object value) {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public K getKey() {\n+            if (key == NULL) {\n+                return null;\n+            }\n+            return (K) key;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V getValue() {\n+            return (V) value;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V setValue(V value) {\n             Object old = this.value;\n             this.value = value;\n-            return old;\n-        }\n-        \n+            return (V) old;\n+        }\n+\n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry other = (Map.Entry) obj;\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n             return\n                 (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                 (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n         }\n-        \n+\n         public int hashCode() {\n             return (getKey() == null ? 0 : getKey().hashCode()) ^\n-                   (getValue() == null ? 0 : getValue().hashCode()); \n-        }\n-        \n+                   (getValue() == null ? 0 : getValue().hashCode());\n+        }\n+\n         public String toString() {\n             return new StringBuffer().append(getKey()).append('=').append(getValue()).toString();\n         }\n     }\n-    \n+\n     /**\n      * Base Iterator\n      */\n-    protected static abstract class HashIterator implements Iterator {\n-        \n+    protected static abstract class HashIterator<K, V> {\n+\n         /** The parent map */\n-        protected final AbstractHashedMap parent;\n+        protected final AbstractHashedMap<K, V> parent;\n         /** The current index into the array of buckets */\n         protected int hashIndex;\n         /** The last returned entry */\n-        protected HashEntry last;\n+        protected HashEntry<K, V> last;\n         /** The next entry */\n-        protected HashEntry next;\n+        protected HashEntry<K, V> next;\n         /** The modification count expected */\n         protected int expectedModCount;\n-        \n-        protected HashIterator(AbstractHashedMap parent) {\n+\n+        protected HashIterator(AbstractHashedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n-            HashEntry[] data = parent.data;\n+            HashEntry<K, V>[] data = parent.data;\n             int i = data.length;\n-            HashEntry next = null;\n+            HashEntry<K, V> next = null;\n             while (i > 0 && next == null) {\n                 next = data[--i];\n             }\n             return (next != null);\n         }\n \n-        protected HashEntry nextEntry() { \n+        protected HashEntry<K, V> nextEntry() {\n             if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            HashEntry newCurrent = next;\n+            HashEntry<K, V> newCurrent = next;\n             if (newCurrent == null)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n-            HashEntry[] data = parent.data;\n+            HashEntry<K, V>[] data = parent.data;\n             int i = hashIndex;\n-            HashEntry n = newCurrent.next;\n+            HashEntry<K, V> n = newCurrent.next;\n             while (n == null && i > 0) {\n                 n = data[--i];\n             }\n             return newCurrent;\n         }\n \n-        protected HashEntry currentEntry() {\n+        protected HashEntry<K, V> currentEntry() {\n             return last;\n         }\n-        \n+\n         public void remove() {\n             if (last == null) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n         public String toString() {\n             if (last != null) {\n                 return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n-            } else {\n-                return \"Iterator[]\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Writes the map data to the stream. This method must be overridden if a\n      * Subclasses may override if they have a specific field that must be present\n      * on read before this implementation will work. Generally, the read determines\n      * what must be serialized here, if anything.\n-     * \n+     *\n      * @param out  the output stream\n      */\n     protected void doWriteObject(ObjectOutputStream out) throws IOException {\n         out.writeFloat(loadFactor);\n         out.writeInt(data.length);\n         out.writeInt(size);\n-        for (MapIterator it = mapIterator(); it.hasNext();) {\n+        for (MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());\n             out.writeObject(it.getValue());\n         }\n      * <p>\n      * Subclasses may override if the subclass has a specific field that must be present\n      * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n-     * \n+     *\n      * @param in  the input stream\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         loadFactor = in.readFloat();\n         int capacity = in.readInt();\n         threshold = calculateThreshold(capacity, loadFactor);\n         data = new HashEntry[capacity];\n         for (int i = 0; i < size; i++) {\n-            Object key = in.readObject();\n-            Object value = in.readObject();\n+            K key = (K) in.readObject();\n+            V value = (V) in.readObject();\n             put(key, value);\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Clones the map without cloning the keys or values.\n      *\n      * @return a shallow clone\n      */\n-    protected Object clone() {\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap<K, V> clone() {\n         try {\n-            AbstractHashedMap cloned = (AbstractHashedMap) super.clone();\n+            AbstractHashedMap<K, V> cloned = (AbstractHashedMap<K, V>) super.clone();\n             cloned.data = new HashEntry[data.length];\n             cloned.entrySet = null;\n             cloned.keySet = null;\n             cloned.init();\n             cloned.putAll(this);\n             return cloned;\n-            \n         } catch (CloneNotSupportedException ex) {\n             return null;  // should never happen\n         }\n     }\n-    \n+\n     /**\n      * Compares this map with another.\n-     * \n+     *\n      * @param obj  the object to compare to\n      * @return true if equal\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n \n     /**\n      * Gets the standard Map hashCode.\n-     * \n+     *\n      * @return the hash code defined in the Map interface\n      */\n     public int hashCode() {\n         int total = 0;\n-        Iterator it = createEntrySetIterator();\n+        Iterator<Map.Entry<K, V>> it = createEntrySetIterator();\n         while (it.hasNext()) {\n             total += it.next().hashCode();\n         }\n \n     /**\n      * Gets the map as a String.\n-     * \n+     *\n      * @return a string version of the map\n      */\n     public String toString() {\n         StringBuffer buf = new StringBuffer(32 * size());\n         buf.append('{');\n \n-        MapIterator it = mapIterator();\n+        MapIterator<K, V> it = mapIterator();\n         boolean hasNext = it.hasNext();\n         while (hasNext) {\n-            Object key = it.next();\n-            Object value = it.getValue();\n+            K key = it.next();\n+            V value = it.getValue();\n             buf.append(key == this ? \"(this Map)\" : key)\n                .append('=')\n                .append(value == this ? \"(this Map)\" : value);\n--- a/src/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n  *\n  * @author Stephen Colebourne\n  */\n-abstract class AbstractInputCheckedMapDecorator\n-        extends AbstractMapDecorator {\n+abstract class AbstractInputCheckedMapDecorator<K, V>\n+        extends AbstractMapDecorator<K, V> {\n \n     /**\n      * Constructor only used in deserialization, do not use otherwise.\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected AbstractInputCheckedMapDecorator(Map map) {\n+    protected AbstractInputCheckedMapDecorator(Map<K, V> map) {\n         super(map);\n     }\n \n      * @throws ClassCastException if the class of the specified value is invalid\n      * @throws NullPointerException if the specified value is null and nulls are invalid\n      */\n-    protected abstract Object checkSetValue(Object value);\n+    protected abstract V checkSetValue(V value);\n \n     /**\n      * Hook method called to determine if <code>checkSetValue</code> has any effect.\n     }\n \n     //-----------------------------------------------------------------------\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         if (isSetValueChecking()) {\n             return new EntrySet(map.entrySet(), this);\n-        } else {\n-            return map.entrySet();\n         }\n+        return map.entrySet();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Implementation of an entry set that checks additions via setValue.\n      */\n-    static class EntrySet extends AbstractSetDecorator {\n+    @SuppressWarnings(\"serial\")\n+    private class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>> {\n         \n         /** The parent map */\n-        private final AbstractInputCheckedMapDecorator parent;\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n \n-        protected EntrySet(Set set, AbstractInputCheckedMapDecorator parent) {\n+        protected EntrySet(Set<Map.Entry<K, V>> set, AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(set);\n             this.parent = parent;\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<Map.Entry<K, V>> iterator() {\n             return new EntrySetIterator(collection.iterator(), parent);\n         }\n         \n+        @SuppressWarnings(\"unchecked\")\n         public Object[] toArray() {\n             Object[] array = collection.toArray();\n             for (int i = 0; i < array.length; i++) {\n-                array[i] = new MapEntry((Map.Entry) array[i], parent);\n+                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n             }\n             return array;\n         }\n         \n-        public Object[] toArray(Object array[]) {\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] array) {\n             Object[] result = array;\n             if (array.length > 0) {\n                 // we must create a new array to handle multi-threaded situations\n             }\n             result = collection.toArray(result);\n             for (int i = 0; i < result.length; i++) {\n-                result[i] = new MapEntry((Map.Entry) result[i], parent);\n+                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n             }\n \n             // check to see if result should be returned straight\n             if (result.length > array.length) {\n-                return result;\n+                return (T[]) result;\n             }\n \n             // copy back into input array to fulfil the method contract\n     /**\n      * Implementation of an entry set iterator that checks additions via setValue.\n      */\n-    static class EntrySetIterator extends AbstractIteratorDecorator {\n-        \n+    private class EntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n         /** The parent map */\n-        private final AbstractInputCheckedMapDecorator parent;\n-        \n-        protected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) {\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected EntrySetIterator(Iterator<Map.Entry<K, V>> iterator, AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n-        \n-        public Object next() {\n-            Map.Entry entry = (Map.Entry) iterator.next();\n+\n+        public Map.Entry<K, V> next() {\n+            Map.Entry<K, V> entry = iterator.next();\n             return new MapEntry(entry, parent);\n         }\n     }\n     /**\n      * Implementation of a map entry that checks additions via setValue.\n      */\n-    static class MapEntry extends AbstractMapEntryDecorator {\n+    private class MapEntry extends AbstractMapEntryDecorator<K, V> {\n \n         /** The parent map */\n-        private final AbstractInputCheckedMapDecorator parent;\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n \n-        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) {\n+        protected MapEntry(Map.Entry<K, V> entry, AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(entry);\n             this.parent = parent;\n         }\n \n-        public Object setValue(Object value) {\n+        public V setValue(V value) {\n             value = parent.checkSetValue(value);\n             return entry.setValue(value);\n         }\n--- a/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedIterator;\n import org.apache.commons.collections.OrderedMap;\n import org.apache.commons.collections.OrderedMapIterator;\n  * @author java util LinkedHashMap\n  * @author Stephen Colebourne\n  */\n-public class AbstractLinkedMap extends AbstractHashedMap implements OrderedMap {\n+public abstract class AbstractLinkedMap<K, V> extends AbstractHashedMap<K, V> implements OrderedMap<K, V> {\n     \n     /** Header in the linked list */\n-    protected transient LinkEntry header;\n+    protected transient LinkEntry<K, V> header;\n \n     /**\n      * Constructor only used in deserialization, do not use otherwise.\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    protected AbstractLinkedMap(Map map) {\n+    protected AbstractLinkedMap(Map<K, V> map) {\n         super(map);\n     }\n \n      * the map entry object.\n      */\n     protected void init() {\n-        header = (LinkEntry) createEntry(null, -1, null, null);\n+        header = createEntry(null, -1, null, null);\n         header.before = header.after = header;\n     }\n \n     public boolean containsValue(Object value) {\n         // override uses faster iterator\n         if (value == null) {\n-            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n+            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n                 if (entry.getValue() == null) {\n                     return true;\n                 }\n             }\n         } else {\n-            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n+            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n                 if (isEqualValue(value, entry.getValue())) {\n                     return true;\n                 }\n      * \n      * @return the eldest key\n      */\n-    public Object firstKey() {\n+    public K firstKey() {\n         if (size == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n         }\n      * \n      * @return the most recently inserted key\n      */\n-    public Object lastKey() {\n+    public K lastKey() {\n         if (size == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n         }\n      * @param key  the key to get after\n      * @return the next key\n      */\n-    public Object nextKey(Object key) {\n-        LinkEntry entry = (LinkEntry) getEntry(key);\n+    public K nextKey(Object key) {\n+        LinkEntry<K, V> entry = getEntry(key);\n         return (entry == null || entry.after == header ? null : entry.after.getKey());\n+    }\n+\n+    protected LinkEntry<K, V> getEntry(Object key) {\n+        return (LinkEntry<K, V>) super.getEntry(key);\n     }\n \n     /**\n      * @param key  the key to get before\n      * @return the previous key\n      */\n-    public Object previousKey(Object key) {\n-        LinkEntry entry = (LinkEntry) getEntry(key);\n+    public K previousKey(Object key) {\n+        LinkEntry<K, V> entry = getEntry(key);\n         return (entry == null || entry.before == header ? null : entry.before.getKey());\n     }\n \n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    protected LinkEntry getEntry(int index) {\n+    protected LinkEntry<K, V> getEntry(int index) {\n         if (index < 0) {\n             throw new IndexOutOfBoundsException(\"Index \" + index + \" is less than zero\");\n         }\n         if (index >= size) {\n             throw new IndexOutOfBoundsException(\"Index \" + index + \" is invalid for size \" + size);\n         }\n-        LinkEntry entry;\n+        LinkEntry<K, V> entry;\n         if (index < (size / 2)) {\n             // Search forwards\n             entry = header.after;\n      * This implementation adds the entry to the data storage table and\n      * to the end of the linked list.\n      * \n-     * @param entry  the entry to add\n+     * @param link  the entry to add\n      * @param hashIndex  the index into the data array to store at\n      */\n-    protected void addEntry(HashEntry entry, int hashIndex) {\n-        LinkEntry link = (LinkEntry) entry;\n+    protected void addEntry(HashEntry<K, V> entry, int hashIndex) {\n+        LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n         link.after  = header;\n         link.before = header.before;\n         header.before.after = link;\n         header.before = link;\n-        data[hashIndex] = entry;\n-    }\n-    \n+        data[hashIndex] = link;\n+    }\n+\n     /**\n      * Creates an entry to store the data.\n      * <p>\n      * @param value  the value to store\n      * @return the newly created entry\n      */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new LinkEntry(next, hashCode, key, value);\n-    }\n-    \n+    protected LinkEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new LinkEntry<K, V>(next, hashCode, convertKey(key), value);\n+    }\n+\n     /**\n      * Removes an entry from the map and the linked list.\n      * <p>\n      * @param hashIndex  the index into the data structure\n      * @param previous  the previous entry in the chain\n      */\n-    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n-        LinkEntry link = (LinkEntry) entry;\n+    protected void removeEntry(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n+        LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n         link.before.after = link.after;\n         link.after.before = link.before;\n         link.after = null;\n         link.before = null;\n         super.removeEntry(entry, hashIndex, previous);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the <code>before</code> field from a <code>LinkEntry</code>.\n      * @throws NullPointerException if the entry is null\n      * @since Commons Collections 3.1\n      */\n-    protected LinkEntry entryBefore(LinkEntry entry) {\n+    protected LinkEntry<K, V> entryBefore(LinkEntry<K, V> entry) {\n         return entry.before;\n     }\n-    \n+\n     /**\n      * Gets the <code>after</code> field from a <code>LinkEntry</code>.\n      * Used in subclasses that have no visibility of the field.\n      * @throws NullPointerException if the entry is null\n      * @since Commons Collections 3.1\n      */\n-    protected LinkEntry entryAfter(LinkEntry entry) {\n+    protected LinkEntry<K, V> entryAfter(LinkEntry<K, V> entry) {\n         return entry.after;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n-     * Gets an iterator over the map.\n-     * Changes made to the iterator affect this map.\n-     * <p>\n-     * A MapIterator returns the keys in the map. It also provides convenient\n-     * methods to get the key and value, and set the value.\n-     * It avoids the need to create an entrySet/keySet/values object.\n-     * \n-     * @return the map iterator\n-     */\n-    public MapIterator mapIterator() {\n+     * {@inheritDoc}\n+     */\n+    public OrderedMapIterator<K, V> mapIterator() {\n         if (size == 0) {\n-            return EmptyOrderedMapIterator.INSTANCE;\n-        }\n-        return new LinkMapIterator(this);\n-    }\n-\n-    /**\n-     * Gets a bidirectional iterator over the map.\n-     * Changes made to the iterator affect this map.\n-     * <p>\n-     * A MapIterator returns the keys in the map. It also provides convenient\n-     * methods to get the key and value, and set the value.\n-     * It avoids the need to create an entrySet/keySet/values object.\n-     * \n-     * @return the map iterator\n-     */\n-    public OrderedMapIterator orderedMapIterator() {\n-        if (size == 0) {\n-            return EmptyOrderedMapIterator.INSTANCE;\n-        }\n-        return new LinkMapIterator(this);\n+            return EmptyOrderedMapIterator.<K, V>getInstance();\n+        }\n+        return new LinkMapIterator<K, V>(this);\n     }\n \n     /**\n      * MapIterator implementation.\n      */\n-    protected static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n-        \n-        protected LinkMapIterator(AbstractLinkedMap parent) {\n+    protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n+            OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+        protected LinkMapIterator(AbstractLinkedMap<K, V> parent) {\n             super(parent);\n         }\n \n-        public Object next() {\n+        public K next() {\n             return super.nextEntry().getKey();\n         }\n \n-        public Object previous() {\n+        public K previous() {\n             return super.previousEntry().getKey();\n         }\n \n-        public Object getKey() {\n-            HashEntry current = currentEntry();\n+        public K getKey() {\n+            LinkEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             return current.getKey();\n         }\n \n-        public Object getValue() {\n-            HashEntry current = currentEntry();\n+        public V getValue() {\n+            LinkEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n \n-        public Object setValue(Object value) {\n-            HashEntry current = currentEntry();\n+        public V setValue(V value) {\n+            LinkEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             return current.setValue(value);\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------    \n     /**\n      * Creates an entry set iterator.\n      * \n      * @return the entrySet iterator\n      */\n-    protected Iterator createEntrySetIterator() {\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n         if (size() == 0) {\n-            return EmptyOrderedIterator.INSTANCE;\n-        }\n-        return new EntrySetIterator(this);\n+            return EmptyOrderedIterator.<Map.Entry<K, V>>getInstance();\n+        }\n+        return new EntrySetIterator<K, V>(this);\n     }\n \n     /**\n      * EntrySet iterator.\n      */\n-    protected static class EntrySetIterator extends LinkIterator {\n-        \n-        protected EntrySetIterator(AbstractLinkedMap parent) {\n+    protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n+            OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>> {\n+\n+        protected EntrySetIterator(AbstractLinkedMap<K, V> parent) {\n             super(parent);\n         }\n \n-        public Object next() {\n+        public Map.Entry<K, V> next() {\n             return super.nextEntry();\n         }\n \n-        public Object previous() {\n+        public Map.Entry<K, V> previous() {\n             return super.previousEntry();\n         }\n     }\n      * \n      * @return the keySet iterator\n      */\n-    protected Iterator createKeySetIterator() {\n+    protected Iterator<K> createKeySetIterator() {\n         if (size() == 0) {\n-            return EmptyOrderedIterator.INSTANCE;\n-        }\n-        return new KeySetIterator(this);\n+            return EmptyOrderedIterator.<K>getInstance();\n+        }\n+        return new KeySetIterator<K>(this);\n     }\n \n     /**\n      * KeySet iterator.\n      */\n-    protected static class KeySetIterator extends EntrySetIterator {\n+    protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n+            OrderedIterator<K>, ResettableIterator<K> {\n         \n-        protected KeySetIterator(AbstractLinkedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySetIterator(AbstractLinkedMap<K, ?> parent) {\n+            super((AbstractLinkedMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n             return super.nextEntry().getKey();\n         }\n \n-        public Object previous() {\n+        public K previous() {\n             return super.previousEntry().getKey();\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------    \n     /**\n      * Creates a values iterator.\n      * \n      * @return the values iterator\n      */\n-    protected Iterator createValuesIterator() {\n+    protected Iterator<V> createValuesIterator() {\n         if (size() == 0) {\n-            return EmptyOrderedIterator.INSTANCE;\n-        }\n-        return new ValuesIterator(this);\n+            return EmptyOrderedIterator.<V>getInstance();\n+        }\n+        return new ValuesIterator<V>(this);\n     }\n \n     /**\n      * Values iterator.\n      */\n-    protected static class ValuesIterator extends LinkIterator {\n-        \n-        protected ValuesIterator(AbstractLinkedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n+    protected static class ValuesIterator<V> extends LinkIterator<Object, V> implements\n+            OrderedIterator<V>, ResettableIterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(AbstractLinkedMap<?, V> parent) {\n+            super((AbstractLinkedMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n             return super.nextEntry().getValue();\n         }\n \n-        public Object previous() {\n+        public V previous() {\n             return super.previousEntry().getValue();\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * LinkEntry that stores the data.\n      * The <code>entryXxx()</code> methods on <code>AbstractLinkedMap</code> exist\n      * to provide the necessary access.\n      */\n-    protected static class LinkEntry extends HashEntry {\n+    protected static class LinkEntry<K, V> extends HashEntry<K, V> {\n         /** The entry before this one in the order */\n-        protected LinkEntry before;\n+        protected LinkEntry<K, V> before;\n         /** The entry after this one in the order */\n-        protected LinkEntry after;\n-        \n+        protected LinkEntry<K, V> after;\n+\n         /**\n          * Constructs a new entry.\n          * \n          * @param key  the key\n          * @param value  the value\n          */\n-        protected LinkEntry(HashEntry next, int hashCode, Object key, Object value) {\n+        protected LinkEntry(HashEntry<K, V> next, int hashCode, Object key, V value) {\n             super(next, hashCode, key, value);\n         }\n     }\n-    \n+\n     /**\n      * Base Iterator that iterates in link order.\n      */\n-    protected static abstract class LinkIterator\n-            implements OrderedIterator, ResettableIterator {\n-                \n+    protected static abstract class LinkIterator<K, V> {\n+\n         /** The parent map */\n-        protected final AbstractLinkedMap parent;\n+        protected final AbstractLinkedMap<K, V> parent;\n         /** The current (last returned) entry */\n-        protected LinkEntry last;\n+        protected LinkEntry<K, V> last;\n         /** The next entry */\n-        protected LinkEntry next;\n+        protected LinkEntry<K, V> next;\n         /** The modification count expected */\n         protected int expectedModCount;\n-        \n-        protected LinkIterator(AbstractLinkedMap parent) {\n+\n+        protected LinkIterator(AbstractLinkedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             this.next = parent.header.after;\n         public boolean hasNext() {\n             return (next != parent.header);\n         }\n-        \n+\n         public boolean hasPrevious() {\n             return (next.before != parent.header);\n         }\n \n-        protected LinkEntry nextEntry() {\n+        protected LinkEntry<K, V> nextEntry() {\n             if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n             return last;\n         }\n \n-        protected LinkEntry previousEntry() {\n+        protected LinkEntry<K, V> previousEntry() {\n             if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            LinkEntry previous = next.before;\n+            LinkEntry<K, V> previous = next.before;\n             if (previous == parent.header)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n             }\n             last = previous;\n             return last;\n         }\n-        \n-        protected LinkEntry currentEntry() {\n+\n+        protected LinkEntry<K, V> currentEntry() {\n             return last;\n         }\n-        \n+\n         public void remove() {\n             if (last == null) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             last = null;\n             expectedModCount = parent.modCount;\n         }\n-        \n+\n         public void reset() {\n             last = null;\n             next = parent.header.after;\n         public String toString() {\n             if (last != null) {\n                 return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n-            } else {\n-                return \"Iterator[]\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n }\n--- a/src/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n  * <code>ResettableIterator</code> and calling <code>reset()</code>.\n  * <p>\n  * This implementation is not synchronized.\n- * You can use {@link java.util.Collections#synchronizedMap} to \n+ * You can use {@link java.util.Collections#synchronizedMap} to\n  * provide synchronized access to a <code>ReferenceMap</code>.\n  *\n  * @see java.lang.ref.Reference\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractReferenceMap extends AbstractHashedMap {\n-\n-    /** Constant indicating that hard references should be used */\n-    public static final int HARD = 0;\n-\n-    /** Constant indicating that soft references should be used */\n-    public static final int SOFT = 1;\n-\n-    /** Constant indicating that weak references should be used */\n-    public static final int WEAK = 2;\n-\n-    /**\n-     * The reference type for keys.  Must be HARD, SOFT, WEAK.\n-     * @serial\n-     */\n-    protected int keyType;\n-\n-    /**\n-     * The reference type for values.  Must be HARD, SOFT, WEAK.\n-     * @serial\n-     */\n-    protected int valueType;\n+public abstract class AbstractReferenceMap<K, V> extends AbstractHashedMap<K, V> {\n+\n+    /**\n+     * Reference type enum.\n+     */\n+    public static enum ReferenceStrength {\n+        HARD(0), SOFT(1), WEAK(2);\n+\n+        /** value */\n+        public final int value;\n+\n+        /**\n+         * Resolve enum from int.\n+         * @param value\n+         * @return ReferenceType\n+         * @throws IllegalArgumentException if the specified value is invalid.\n+         */\n+        public static ReferenceStrength resolve(int value) {\n+            switch (value) {\n+            case 0:\n+                return HARD;\n+            case 1:\n+                return SOFT;\n+            case 2:\n+                return WEAK;\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private ReferenceStrength(int value) {\n+            this.value = value;\n+        }\n+\n+    }\n+\n+    /**\n+     * The reference type for keys.\n+     */\n+    protected ReferenceStrength keyType;\n+\n+    /**\n+     * The reference type for values.\n+     */\n+    protected ReferenceStrength valueType;\n \n     /**\n      * Should the value be automatically purged when the associated key has been collected?\n      * ReferenceQueue used to eliminate stale mappings.\n      * See purge.\n      */\n-    private transient ReferenceQueue queue;\n+    private transient ReferenceQueue<Object> queue;\n \n     //-----------------------------------------------------------------------\n     /**\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n-     * @param purgeValues  should the value be automatically purged when the \n-     *   key is garbage collected \n+     * @param purgeValues  should the value be automatically purged when the\n+     *   key is garbage collected\n      */\n     protected AbstractReferenceMap(\n-            int keyType, int valueType, int capacity, \n+            ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n             float loadFactor, boolean purgeValues) {\n         super(capacity, loadFactor);\n-        verify(\"keyType\", keyType);\n-        verify(\"valueType\", valueType);\n         this.keyType = keyType;\n         this.valueType = valueType;\n         this.purgeValues = purgeValues;\n      * Initialise this subclass during construction, cloning or deserialization.\n      */\n     protected void init() {\n-        queue = new ReferenceQueue();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Checks the type int is a valid value.\n-     * \n-     * @param name  the name for error messages\n-     * @param type  the type value to check\n-     * @throws IllegalArgumentException if the value if invalid\n-     */\n-    private static void verify(String name, int type) {\n-        if ((type < HARD) || (type > WEAK)) {\n-            throw new IllegalArgumentException(name + \" must be HARD, SOFT, WEAK.\");\n-        }\n+        queue = new ReferenceQueue<Object>();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Gets the size of the map.\n-     * \n+     *\n      * @return the size\n      */\n     public int size() {\n \n     /**\n      * Checks whether the map is currently empty.\n-     * \n+     *\n      * @return true if the map is currently size zero\n      */\n     public boolean isEmpty() {\n \n     /**\n      * Checks whether the map contains the specified key.\n-     * \n+     *\n      * @param key  the key to search for\n      * @return true if the map contains the key\n      */\n     public boolean containsKey(Object key) {\n         purgeBeforeRead();\n-        Entry entry = getEntry(key);\n+        Entry<K, V> entry = getEntry(key);\n         if (entry == null) {\n             return false;\n         }\n \n     /**\n      * Checks whether the map contains the specified value.\n-     * \n+     *\n      * @param value  the value to search for\n      * @return true if the map contains the value\n      */\n \n     /**\n      * Gets the value mapped to the key specified.\n-     * \n+     *\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key) {\n+    public V get(Object key) {\n         purgeBeforeRead();\n-        Entry entry = getEntry(key);\n+        Entry<K, V> entry = getEntry(key);\n         if (entry == null) {\n             return null;\n         }\n     /**\n      * Puts a key-value mapping into this map.\n      * Neither the key nor the value may be null.\n-     * \n+     *\n      * @param key  the key to add, must not be null\n      * @param value  the value to add, must not be null\n      * @return the value previously mapped to this key, null if none\n      * @throws NullPointerException if either the key or value is null\n      */\n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         if (key == null) {\n             throw new NullPointerException(\"null keys not allowed\");\n         }\n         purgeBeforeWrite();\n         return super.put(key, value);\n     }\n-    \n+\n     /**\n      * Removes the specified mapping from this map.\n-     * \n+     *\n      * @param key  the mapping to remove\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         if (key == null) {\n             return null;\n         }\n     /**\n      * Gets a MapIterator over the reference map.\n      * The iterator only returns valid key/value pairs.\n-     * \n+     *\n      * @return a map iterator\n      */\n-    public MapIterator mapIterator() {\n-        return new ReferenceMapIterator(this);\n+    public MapIterator<K, V> mapIterator() {\n+        return new ReferenceMapIterator<K, V>(this);\n     }\n \n     /**\n      *\n      * @return a set view of this map's entries\n      */\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         if (entrySet == null) {\n-            entrySet = new ReferenceEntrySet(this);\n+            entrySet = new ReferenceEntrySet<K, V>(this);\n         }\n         return entrySet;\n     }\n      *\n      * @return a set view of this map's keys\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         if (keySet == null) {\n-            keySet = new ReferenceKeySet(this);\n+            keySet = new ReferenceKeySet<K>(this);\n         }\n         return keySet;\n     }\n      *\n      * @return a set view of this map's values\n      */\n-    public Collection values() {\n+    public Collection<V> values() {\n         if (values == null) {\n-            values = new ReferenceValues(this);\n+            values = new ReferenceValues<V>(this);\n         }\n         return values;\n     }\n      * background thread.\n      */\n     protected void purge() {\n-        Reference ref = queue.poll();\n+        Reference<?> ref = queue.poll();\n         while (ref != null) {\n             purge(ref);\n             ref = queue.poll();\n \n     /**\n      * Purges the specified reference.\n-     * \n+     *\n      * @param ref  the reference to purge\n      */\n-    protected void purge(Reference ref) {\n+    protected void purge(Reference<?> ref) {\n         // The hashCode of the reference is the hashCode of the\n-        // mapping key, even if the reference refers to the \n+        // mapping key, even if the reference refers to the\n         // mapping value...\n         int hash = ref.hashCode();\n         int index = hashIndex(hash, data.length);\n-        HashEntry previous = null;\n-        HashEntry entry = data[index];\n+        HashEntry<K, V> previous = null;\n+        HashEntry<K, V> entry = data[index];\n         while (entry != null) {\n-            if (((ReferenceEntry) entry).purge(ref)) {\n+            if (((ReferenceEntry<K, V>) entry).purge(ref)) {\n                 if (previous == null) {\n                     data[index] = entry.next;\n                 } else {\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the entry mapped to the key specified.\n-     * \n+     *\n      * @param key  the key\n      * @return the entry, null if no match\n      */\n-    protected HashEntry getEntry(Object key) {\n+    protected HashEntry<K, V> getEntry(Object key) {\n         if (key == null) {\n             return null;\n-        } else {\n-            return super.getEntry(key);\n-        }\n+        }\n+        return super.getEntry(key);\n     }\n \n     /**\n      * Gets the hash code for a MapEntry.\n      * Subclasses can override this, for example to use the identityHashCode.\n-     * \n+     *\n      * @param key  the key to get a hash code for, may be null\n      * @param value  the value to get a hash code for, may be null\n      * @return the hash code, as per the MapEntry specification\n      */\n     protected int hashEntry(Object key, Object value) {\n         return (key == null ? 0 : key.hashCode()) ^\n-               (value == null ? 0 : value.hashCode()); \n-    }\n-    \n+               (value == null ? 0 : value.hashCode());\n+    }\n+\n     /**\n      * Compares two keys, in internal converted form, to see if they are equal.\n      * <p>\n      * This implementation converts the key from the entry to a real reference\n      * before comparison.\n-     * \n+     *\n      * @param key1  the first key to compare passed in from outside\n      * @param key2  the second key extracted from the entry via <code>entry.key</code>\n      * @return true if equal\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected boolean isEqualKey(Object key1, Object key2) {\n-        key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n+        key2 = (keyType == ReferenceStrength.HARD ? key2 : ((Reference<K>) key2).get());\n         return (key1 == key2 || key1.equals(key2));\n     }\n-    \n+\n     /**\n      * Creates a ReferenceEntry instead of a HashEntry.\n-     * \n+     *\n      * @param next  the next entry in sequence\n      * @param hashCode  the hash code to use\n      * @param key  the key to store\n      * @param value  the value to store\n      * @return the newly created entry\n      */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new ReferenceEntry(this, next, hashCode, key, value);\n+    protected ReferenceEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new ReferenceEntry<K, V>(this, next, hashCode, key, value);\n     }\n \n     /**\n      * Creates an entry set iterator.\n-     * \n+     *\n      * @return the entrySet iterator\n      */\n-    protected Iterator createEntrySetIterator() {\n-        return new ReferenceEntrySetIterator(this);\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        return new ReferenceEntrySetIterator<K, V>(this);\n     }\n \n     /**\n      * Creates an key set iterator.\n-     * \n+     *\n      * @return the keySet iterator\n      */\n-    protected Iterator createKeySetIterator() {\n-        return new ReferenceKeySetIterator(this);\n+    protected Iterator<K> createKeySetIterator() {\n+        return new ReferenceKeySetIterator<K>(this);\n     }\n \n     /**\n      * Creates an values iterator.\n-     * \n+     *\n      * @return the values iterator\n      */\n-    protected Iterator createValuesIterator() {\n-        return new ReferenceValuesIterator(this);\n+    protected Iterator<V> createValuesIterator() {\n+        return new ReferenceValuesIterator<V>(this);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * EntrySet implementation.\n      */\n-    static class ReferenceEntrySet extends EntrySet {\n-        \n-        protected ReferenceEntrySet(AbstractHashedMap parent) {\n+    static class ReferenceEntrySet<K, V> extends EntrySet<K, V> {\n+\n+        protected ReferenceEntrySet(AbstractHashedMap<K, V> parent) {\n             super(parent);\n         }\n \n             return toArray(new Object[0]);\n         }\n \n-        public Object[] toArray(Object[] arr) {\n+        public <T> T[] toArray(T[] arr) {\n             // special implementation to handle disappearing entries\n-            ArrayList list = new ArrayList();\n-            Iterator iterator = iterator();\n-            while (iterator.hasNext()) {\n-                Entry e = (Entry) iterator.next();\n-                list.add(new DefaultMapEntry(e.getKey(), e.getValue()));\n+            ArrayList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>();\n+            for (Map.Entry<K, V> entry : this) {\n+                list.add(new DefaultMapEntry<K, V>(entry));\n             }\n             return list.toArray(arr);\n         }\n     /**\n      * KeySet implementation.\n      */\n-    static class ReferenceKeySet extends KeySet {\n-        \n-        protected ReferenceKeySet(AbstractHashedMap parent) {\n+    static class ReferenceKeySet<K> extends KeySet<K> {\n+\n+        protected ReferenceKeySet(AbstractHashedMap<K, ?> parent) {\n             super(parent);\n         }\n \n             return toArray(new Object[0]);\n         }\n \n-        public Object[] toArray(Object[] arr) {\n+        public <T> T[] toArray(T[] arr) {\n             // special implementation to handle disappearing keys\n-            List list = new ArrayList(parent.size());\n-            for (Iterator it = iterator(); it.hasNext(); ) {\n-                list.add(it.next());\n+            List<K> list = new ArrayList<K>(parent.size());\n+            for (K key : this) {\n+                list.add(key);\n             }\n             return list.toArray(arr);\n         }\n     /**\n      * Values implementation.\n      */\n-    static class ReferenceValues extends Values {\n-        \n-        protected ReferenceValues(AbstractHashedMap parent) {\n+    static class ReferenceValues<V> extends Values<V> {\n+\n+        protected ReferenceValues(AbstractHashedMap<?, V> parent) {\n             super(parent);\n         }\n \n             return toArray(new Object[0]);\n         }\n \n-        public Object[] toArray(Object[] arr) {\n+        public <T> T[] toArray(T[] arr) {\n             // special implementation to handle disappearing values\n-            List list = new ArrayList(parent.size());\n-            for (Iterator it = iterator(); it.hasNext(); ) {\n-                list.add(it.next());\n+            List<V> list = new ArrayList<V>(parent.size());\n+            for (V value : this) {\n+                list.add(value);\n             }\n             return list.toArray(arr);\n         }\n      * <p>\n      * If getKey() or getValue() returns null, it means\n      * the mapping is stale and should be removed.\n-     * \n+     *\n      * @since Commons Collections 3.1\n      */\n-    protected static class ReferenceEntry extends HashEntry {\n+    protected static class ReferenceEntry<K, V> extends HashEntry<K, V> {\n         /** The parent map */\n-        protected final AbstractReferenceMap parent;\n+        protected final AbstractReferenceMap<K, V> parent;\n \n         /**\n          * Creates a new entry object for the ReferenceMap.\n-         * \n+         *\n          * @param parent  the parent map\n          * @param next  the next entry in the hash bucket\n          * @param hashCode  the hash code of the key\n          * @param key  the key\n          * @param value  the value\n          */\n-        public ReferenceEntry(AbstractReferenceMap parent, HashEntry next, int hashCode, Object key, Object value) {\n+        public ReferenceEntry(AbstractReferenceMap<K, V> parent, HashEntry<K, V> next, int hashCode, K key, V value) {\n             super(next, hashCode, null, null);\n             this.parent = parent;\n             this.key = toReference(parent.keyType, key, hashCode);\n         /**\n          * Gets the key from the entry.\n          * This method dereferences weak and soft keys and thus may return null.\n-         * \n+         *\n          * @return the key, which may be null if it was garbage collected\n          */\n-        public Object getKey() {\n-            return (parent.keyType > HARD) ? ((Reference) key).get() : key;\n+        @SuppressWarnings(\"unchecked\")\n+        public K getKey() {\n+            return (K) ((parent.keyType == ReferenceStrength.HARD) ? key : ((Reference<K>) key).get());\n         }\n \n         /**\n          * Gets the value from the entry.\n          * This method dereferences weak and soft value and thus may return null.\n-         * \n+         *\n          * @return the value, which may be null if it was garbage collected\n          */\n-        public Object getValue() {\n-            return (parent.valueType > HARD) ? ((Reference) value).get() : value;\n+        @SuppressWarnings(\"unchecked\")\n+        public V getValue() {\n+            return (V) ((parent.valueType == ReferenceStrength.HARD) ? value : ((Reference<V>) value).get());\n         }\n \n         /**\n          * Sets the value of the entry.\n-         * \n+         *\n          * @param obj  the object to store\n          * @return the previous value\n          */\n-        public Object setValue(Object obj) {\n-            Object old = getValue();\n-            if (parent.valueType > HARD) {\n-                ((Reference)value).clear();\n+        @SuppressWarnings(\"unchecked\")\n+        public V setValue(V obj) {\n+            V old = getValue();\n+            if (parent.valueType != ReferenceStrength.HARD) {\n+                ((Reference<V>) value).clear();\n             }\n             value = toReference(parent.valueType, obj, hashCode);\n             return old;\n          * <p>\n          * This implementation uses <code>isEqualKey</code> and\n          * <code>isEqualValue</code> on the main map for comparison.\n-         * \n+         *\n          * @param obj  the other map entry to compare to\n          * @return true if equal, false if not\n          */\n+        @SuppressWarnings(\"unchecked\")\n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            \n+\n             Map.Entry entry = (Map.Entry)obj;\n             Object entryKey = entry.getKey();  // convert to hard reference\n             Object entryValue = entry.getValue();  // convert to hard reference\n          * Gets the hashcode of the entry using temporary hard references.\n          * <p>\n          * This implementation uses <code>hashEntry</code> on the main map.\n-         * \n+         *\n          * @return the hashcode of the entry\n          */\n         public int hashCode() {\n          *    this number might be different from referent.hashCode() if\n          *    the referent represents a value and not a key\n          */\n-        protected Object toReference(int type, Object referent, int hash) {\n-            switch (type) {\n-                case HARD: return referent;\n-                case SOFT: return new SoftRef(hash, referent, parent.queue);\n-                case WEAK: return new WeakRef(hash, referent, parent.queue);\n-                default: throw new Error();\n-            }\n+        protected <T> Object toReference(ReferenceStrength type, T referent, int hash) {\n+            if (type == ReferenceStrength.HARD) {\n+                return referent;\n+            }\n+            if (type == ReferenceStrength.SOFT) {\n+                return new SoftRef<T>(hash, referent, parent.queue);\n+            }\n+            if (type == ReferenceStrength.WEAK) {\n+                return new WeakRef<T>(hash, referent, parent.queue);\n+            }\n+            throw new Error();\n         }\n \n         /**\n          * @param ref  the reference to purge\n          * @return true or false\n          */\n-        boolean purge(Reference ref) {\n-            boolean r = (parent.keyType > HARD) && (key == ref);\n-            r = r || ((parent.valueType > HARD) && (value == ref));\n+        boolean purge(Reference<?> ref) {\n+            boolean r = (parent.keyType != ReferenceStrength.HARD) && (key == ref);\n+            r = r || ((parent.valueType != ReferenceStrength.HARD) && (value == ref));\n             if (r) {\n-                if (parent.keyType > HARD) {\n-                    ((Reference)key).clear();\n+                if (parent.keyType != ReferenceStrength.HARD) {\n+                    ((Reference<?>) key).clear();\n                 }\n-                if (parent.valueType > HARD) {\n-                    ((Reference)value).clear();\n+                if (parent.valueType != ReferenceStrength.HARD) {\n+                    ((Reference<?>) value).clear();\n                 } else if (parent.purgeValues) {\n                     value = null;\n                 }\n \n         /**\n          * Gets the next entry in the bucket.\n-         * \n+         *\n          * @return the next entry in the bucket\n          */\n-        protected ReferenceEntry next() {\n-            return (ReferenceEntry) next;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * The EntrySet iterator.\n-     */\n-    static class ReferenceEntrySetIterator implements Iterator {\n+        protected ReferenceEntry<K, V> next() {\n+            return (ReferenceEntry<K, V>) next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Base iterator class.\n+     */\n+    static class ReferenceBaseIterator<K, V> {\n         /** The parent map */\n-        final AbstractReferenceMap parent;\n-        \n+        final AbstractReferenceMap<K, V> parent;\n+\n         // These fields keep track of where we are in the table.\n         int index;\n-        ReferenceEntry entry;\n-        ReferenceEntry previous;\n+        ReferenceEntry<K, V> entry;\n+        ReferenceEntry<K, V> previous;\n \n         // These Object fields provide hard references to the\n         // current and next entry; this assures that if hasNext()\n         // returns true, next() will actually return a valid element.\n-        Object nextKey, nextValue;\n-        Object currentKey, currentValue;\n+        K currentKey, nextKey;\n+        V currentValue, nextValue;\n \n         int expectedModCount;\n \n-        public ReferenceEntrySetIterator(AbstractReferenceMap parent) {\n+        public ReferenceBaseIterator(AbstractReferenceMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             index = (parent.size() != 0 ? parent.data.length : 0);\n         public boolean hasNext() {\n             checkMod();\n             while (nextNull()) {\n-                ReferenceEntry e = entry;\n+                ReferenceEntry<K, V> e = entry;\n                 int i = index;\n                 while ((e == null) && (i > 0)) {\n                     i--;\n-                    e = (ReferenceEntry) parent.data[i];\n+                    e = (ReferenceEntry<K, V>) parent.data[i];\n                 }\n                 entry = e;\n                 index = i;\n             return (nextKey == null) || (nextValue == null);\n         }\n \n-        protected ReferenceEntry nextEntry() {    \n+        protected ReferenceEntry<K, V> nextEntry() {\n             checkMod();\n             if (nextNull() && !hasNext()) {\n                 throw new NoSuchElementException();\n             return previous;\n         }\n \n-        protected ReferenceEntry currentEntry() {\n+        protected ReferenceEntry<K, V> currentEntry() {\n             checkMod();\n             return previous;\n-        }\n-        \n-        public Object next() {\n-            return nextEntry();\n         }\n \n         public void remove() {\n     }\n \n     /**\n+     * The EntrySet iterator.\n+     */\n+    static class ReferenceEntrySetIterator<K, V> extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        public ReferenceEntrySetIterator(AbstractReferenceMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+    }\n+\n+    /**\n      * The keySet iterator.\n      */\n-    static class ReferenceKeySetIterator extends ReferenceEntrySetIterator {\n-        \n-        ReferenceKeySetIterator(AbstractReferenceMap parent) {\n+    static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReferenceKeySetIterator(AbstractReferenceMap<K, ?> parent) {\n+            super((AbstractReferenceMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+    }\n+\n+    /**\n+     * The values iterator.\n+     */\n+    static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReferenceValuesIterator(AbstractReferenceMap<?, V> parent) {\n+            super((AbstractReferenceMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return nextEntry().getValue();\n+        }\n+    }\n+\n+    /**\n+     * The MapIterator implementation.\n+     */\n+    static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V> {\n+\n+        protected ReferenceMapIterator(AbstractReferenceMap<K, V> parent) {\n             super(parent);\n         }\n-        \n-        public Object next() {\n+\n+        public K next() {\n             return nextEntry().getKey();\n         }\n-    }\n-\n-    /**\n-     * The values iterator.\n-     */\n-    static class ReferenceValuesIterator extends ReferenceEntrySetIterator {\n-        \n-        ReferenceValuesIterator(AbstractReferenceMap parent) {\n-            super(parent);\n-        }\n-        \n-        public Object next() {\n-            return nextEntry().getValue();\n-        }\n-    }\n-\n-    /**\n-     * The MapIterator implementation.\n-     */\n-    static class ReferenceMapIterator extends ReferenceEntrySetIterator implements MapIterator {\n-        \n-        protected ReferenceMapIterator(AbstractReferenceMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n-            return nextEntry().getKey();\n-        }\n-\n-        public Object getKey() {\n-            HashEntry current = currentEntry();\n+\n+        public K getKey() {\n+            HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             return current.getKey();\n         }\n \n-        public Object getValue() {\n-            HashEntry current = currentEntry();\n+        public V getValue() {\n+            HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n \n-        public Object setValue(Object value) {\n-            HashEntry current = currentEntry();\n+        public V setValue(V value) {\n+            HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             return current.setValue(value);\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     // These two classes store the hashCode of the key of\n     // of the mapping, so that after they're dequeued a quick\n     /**\n      * A soft reference holder.\n      */\n-    static class SoftRef extends SoftReference {\n+    static class SoftRef<T> extends SoftReference<T> {\n         /** the hashCode of the key (even if the reference points to a value) */\n         private int hash;\n \n-        public SoftRef(int hash, Object r, ReferenceQueue q) {\n+        public SoftRef(int hash, T r, ReferenceQueue<? super T> q) {\n             super(r, q);\n             this.hash = hash;\n         }\n     /**\n      * A weak reference holder.\n      */\n-    static class WeakRef extends WeakReference {\n+    static class WeakRef<T> extends WeakReference<T> {\n         /** the hashCode of the key (even if the reference points to a value) */\n         private int hash;\n \n-        public WeakRef(int hash, Object r, ReferenceQueue q) {\n+        public WeakRef(int hash, T r, ReferenceQueue<? super T> q) {\n             super(r, q);\n             this.hash = hash;\n         }\n      * Subclasses may override if they have a specific field that must be present\n      * on read before this implementation will work. Generally, the read determines\n      * what must be serialized here, if anything.\n-     * \n+     *\n      * @param out  the output stream\n      */\n     protected void doWriteObject(ObjectOutputStream out) throws IOException {\n-        out.writeInt(keyType);\n-        out.writeInt(valueType);\n+        out.writeInt(keyType.value);\n+        out.writeInt(valueType.value);\n         out.writeBoolean(purgeValues);\n         out.writeFloat(loadFactor);\n         out.writeInt(data.length);\n-        for (MapIterator it = mapIterator(); it.hasNext();) {\n+        for (MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());\n             out.writeObject(it.getValue());\n         }\n      * <p>\n      * Subclasses may override if the subclass has a specific field that must be present\n      * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n-     * \n+     *\n      * @param in  the input stream\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        this.keyType = in.readInt();\n-        this.valueType = in.readInt();\n+        this.keyType = ReferenceStrength.resolve(in.readInt());\n+        this.valueType = ReferenceStrength.resolve(in.readInt());\n         this.purgeValues = in.readBoolean();\n         this.loadFactor = in.readFloat();\n         int capacity = in.readInt();\n         init();\n         data = new HashEntry[capacity];\n         while (true) {\n-            Object key = in.readObject();\n+            K key = (K) in.readObject();\n             if (key == null) {\n                 break;\n             }\n-            Object value = in.readObject();\n+            V value = (V) in.readObject();\n             put(key, value);\n         }\n         threshold = calculateThreshold(data.length, loadFactor);\n--- a/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java\n+++ b/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java\n  *\n  * @author Commons-Collections team\n  */\n-public class CaseInsensitiveMap extends AbstractHashedMap implements Serializable, Cloneable {\n+public class CaseInsensitiveMap<K, V> extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n \n     /** Serialisation version */\n     private static final long serialVersionUID = -7074655917369299456L;\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public CaseInsensitiveMap(Map map) {\n+    public CaseInsensitiveMap(Map<K, V> map) {\n         super(map);\n     }\n \n                 chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));\n             }\n             return new String(chars);\n-        } else {\n-            return AbstractHashedMap.NULL;\n         }\n+        return AbstractHashedMap.NULL;\n     }   \n \n     //-----------------------------------------------------------------------\n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n-        return super.clone();\n+    public CaseInsensitiveMap<K, V> clone() {\n+        return (CaseInsensitiveMap<K, V>) super.clone();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.util.Collection;\n-import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n import java.util.SortedMap;\n \n import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.collections.collection.UnmodifiableCollection;\n import org.apache.commons.collections.set.UnmodifiableSet;\n \n  * @author Stephen Colebourne\n  * @author Paul Jack\n  */\n-public class FixedSizeSortedMap\n-        extends AbstractSortedMapDecorator\n-        implements SortedMap, BoundedMap, Serializable {\n+public class FixedSizeSortedMap<K, V>\n+        extends AbstractSortedMapDecorator<K, V>\n+        implements SortedMap<K, V>, BoundedMap<K, V>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 3126019624511683653L;\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static SortedMap decorate(SortedMap map) {\n-        return new FixedSizeSortedMap(map);\n+    public static <K, V> SortedMap<K, V> decorate(SortedMap<K, V> map) {\n+        return new FixedSizeSortedMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected FixedSizeSortedMap(SortedMap map) {\n+    protected FixedSizeSortedMap(SortedMap<K, V> map) {\n         super(map);\n     }\n \n      * \n      * @return the decorated map\n      */\n-    protected SortedMap getSortedMap() {\n-        return (SortedMap) map;\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Read the map in using a custom routine.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map) in.readObject();\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         if (map.containsKey(key) == false) {\n             throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n         }\n         return map.put(key, value);\n     }\n \n-    public void putAll(Map mapToCopy) {\n-        for (Iterator it = mapToCopy.keySet().iterator(); it.hasNext(); ) {\n-            if (mapToCopy.containsKey(it.next()) == false) {\n-                throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n-            }\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        if (CollectionUtils.isSubCollection(mapToCopy.keySet(), keySet())) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n         }\n         map.putAll(mapToCopy);\n     }\n         throw new UnsupportedOperationException(\"Map is fixed size\");\n     }\n \n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         throw new UnsupportedOperationException(\"Map is fixed size\");\n     }\n \n-    public Set entrySet() {\n-        Set set = map.entrySet();\n-        return UnmodifiableSet.decorate(set);\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return UnmodifiableSet.decorate(map.entrySet());\n     }\n \n-    public Set keySet() {\n-        Set set = map.keySet();\n-        return UnmodifiableSet.decorate(set);\n+    public Set<K> keySet() {\n+        return UnmodifiableSet.decorate(map.keySet());\n     }\n \n-    public Collection values() {\n-        Collection coll = map.values();\n-        return UnmodifiableCollection.decorate(coll);\n+    public Collection<V> values() {\n+        return UnmodifiableCollection.decorate(map.values());\n     }\n \n     //-----------------------------------------------------------------------\n-    public SortedMap subMap(Object fromKey, Object toKey) {\n-        SortedMap map = getSortedMap().subMap(fromKey, toKey);\n-        return new FixedSizeSortedMap(map);\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().subMap(fromKey, toKey));\n     }\n \n-    public SortedMap headMap(Object toKey) {\n-        SortedMap map = getSortedMap().headMap(toKey);\n-        return new FixedSizeSortedMap(map);\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().headMap(toKey));\n     }\n \n-    public SortedMap tailMap(Object fromKey) {\n-        SortedMap map = getSortedMap().tailMap(fromKey);\n-        return new FixedSizeSortedMap(map);\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().tailMap(fromKey));\n     }\n \n     public boolean isFull() {\n--- a/src/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/java/org/apache/commons/collections/map/Flat3Map.java\n  * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Stephen Colebourne\n  */\n-public class Flat3Map implements IterableMap, Serializable, Cloneable {\n+public class Flat3Map<K, V> implements IterableMap<K, V>, Serializable, Cloneable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -6701087419741928296L;\n     /** Hash, used while in flat mode */\n     private transient int hash3;\n     /** Key, used while in flat mode */\n-    private transient Object key1;\n+    private transient K key1;\n     /** Key, used while in flat mode */\n-    private transient Object key2;\n+    private transient K key2;\n     /** Key, used while in flat mode */\n-    private transient Object key3;\n+    private transient K key3;\n     /** Value, used while in flat mode */\n-    private transient Object value1;\n+    private transient V value1;\n     /** Value, used while in flat mode */\n-    private transient Object value2;\n+    private transient V value2;\n     /** Value, used while in flat mode */\n-    private transient Object value3;\n+    private transient V value3;\n     /** Map, used while in delegate mode */\n-    private transient AbstractHashedMap delegateMap;\n+    private transient AbstractHashedMap<K, V> delegateMap;\n \n     /**\n      * Constructor.\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public Flat3Map(Map map) {\n+    public Flat3Map(Map<? extends K, ? extends V> map) {\n         super();\n         putAll(map);\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the value mapped to the key specified.\n-     * \n+     *\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key) {\n+    public V get(Object key) {\n         if (delegateMap != null) {\n             return delegateMap.get(key);\n         }\n \n     /**\n      * Gets the size of the map.\n-     * \n+     *\n      * @return the size\n      */\n     public int size() {\n \n     /**\n      * Checks whether the map is currently empty.\n-     * \n+     *\n      * @return true if the map is currently size zero\n      */\n     public boolean isEmpty() {\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether the map contains the specified key.\n-     * \n+     *\n      * @param key  the key to search for\n      * @return true if the map contains the key\n      */\n \n     /**\n      * Checks whether the map contains the specified value.\n-     * \n+     *\n      * @param value  the value to search for\n      * @return true if the map contains the key\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Puts a key-value mapping into this map.\n-     * \n+     *\n      * @param key  the key to add\n      * @param value  the value to add\n      * @return the value previously mapped to this key, null if none\n      */\n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         if (delegateMap != null) {\n             return delegateMap.put(key, value);\n         }\n             switch (size) {  // drop through\n                 case 3:\n                     if (key3 == null) {\n-                        Object old = value3;\n+                        V old = value3;\n                         value3 = value;\n                         return old;\n                     }\n                 case 2:\n                     if (key2 == null) {\n-                        Object old = value2;\n+                        V old = value2;\n                         value2 = value;\n                         return old;\n                     }\n                 case 1:\n                     if (key1 == null) {\n-                        Object old = value1;\n+                        V old = value1;\n                         value1 = value;\n                         return old;\n                     }\n                 switch (size) {  // drop through\n                     case 3:\n                         if (hash3 == hashCode && key.equals(key3)) {\n-                            Object old = value3;\n+                            V old = value3;\n                             value3 = value;\n                             return old;\n                         }\n                     case 2:\n                         if (hash2 == hashCode && key.equals(key2)) {\n-                            Object old = value2;\n+                            V old = value2;\n                             value2 = value;\n                             return old;\n                         }\n                     case 1:\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            Object old = value1;\n+                            V old = value1;\n                             value1 = value;\n                             return old;\n                         }\n                 }\n             }\n         }\n-        \n+\n         // add new mapping\n         switch (size) {\n             default:\n \n     /**\n      * Puts all the values from the specified map into this map.\n-     * \n+     *\n      * @param map  the map to add\n      * @throws NullPointerException if the map is null\n      */\n-    public void putAll(Map map) {\n+    public void putAll(Map<? extends K, ? extends V> map) {\n         int size = map.size();\n         if (size == 0) {\n             return;\n             return;\n         }\n         if (size < 4) {\n-            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n+            for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n                 put(entry.getKey(), entry.getValue());\n             }\n         } else {\n             case 1:\n                 delegateMap.put(key1, value1);\n         }\n-        \n+\n         size = 0;\n         hash1 = hash2 = hash3 = 0;\n         key1 = key2 = key3 = null;\n      * @return a new AbstractHashedMap or subclass\n      * @since Commons Collections 3.1\n      */\n-    protected AbstractHashedMap createDelegateMap() {\n-        return new HashedMap();\n+    protected AbstractHashedMap<K, V> createDelegateMap() {\n+        return new HashedMap<K, V>();\n     }\n \n     /**\n      * Removes the specified mapping from this map.\n-     * \n+     *\n      * @param key  the mapping to remove\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         if (delegateMap != null) {\n             return delegateMap.remove(key);\n         }\n             switch (size) {  // drop through\n                 case 3:\n                     if (key3 == null) {\n-                        Object old = value3;\n+                        V old = value3;\n                         hash3 = 0;\n                         key3 = null;\n                         value3 = null;\n                         return old;\n                     }\n                     if (key2 == null) {\n-                        Object old = value2;\n+                        V old = value2;\n                         hash2 = hash3;\n                         key2 = key3;\n                         value2 = value3;\n                         return old;\n                     }\n                     if (key1 == null) {\n-                        Object old = value1;\n+                        V old = value1;\n                         hash1 = hash3;\n                         key1 = key3;\n                         value1 = value3;\n                     return null;\n                 case 2:\n                     if (key2 == null) {\n-                        Object old = value2;\n+                        V old = value2;\n                         hash2 = 0;\n                         key2 = null;\n                         value2 = null;\n                         return old;\n                     }\n                     if (key1 == null) {\n-                        Object old = value1;\n+                        V old = value1;\n                         hash1 = hash2;\n                         key1 = key2;\n                         value1 = value2;\n                     return null;\n                 case 1:\n                     if (key1 == null) {\n-                        Object old = value1;\n+                        V old = value1;\n                         hash1 = 0;\n                         key1 = null;\n                         value1 = null;\n                 switch (size) {  // drop through\n                     case 3:\n                         if (hash3 == hashCode && key.equals(key3)) {\n-                            Object old = value3;\n+                            V old = value3;\n                             hash3 = 0;\n                             key3 = null;\n                             value3 = null;\n                             return old;\n                         }\n                         if (hash2 == hashCode && key.equals(key2)) {\n-                            Object old = value2;\n+                            V old = value2;\n                             hash2 = hash3;\n                             key2 = key3;\n                             value2 = value3;\n                             return old;\n                         }\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            Object old = value1;\n+                            V old = value1;\n                             hash1 = hash3;\n                             key1 = key3;\n                             value1 = value3;\n                         return null;\n                     case 2:\n                         if (hash2 == hashCode && key.equals(key2)) {\n-                            Object old = value2;\n+                            V old = value2;\n                             hash2 = 0;\n                             key2 = null;\n                             value2 = null;\n                             return old;\n                         }\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            Object old = value1;\n+                            V old = value1;\n                             hash1 = hash2;\n                             key1 = key2;\n                             value1 = value2;\n                         return null;\n                     case 1:\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            Object old = value1;\n+                            V old = value1;\n                             hash1 = 0;\n                             key1 = null;\n                             value1 = null;\n      * methods to get the key and value, and set the value.\n      * It avoids the need to create an entrySet/keySet/values object.\n      * It also avoids creating the Map Entry object.\n-     * \n+     *\n      * @return the map iterator\n      */\n-    public MapIterator mapIterator() {\n+    public MapIterator<K, V> mapIterator() {\n         if (delegateMap != null) {\n             return delegateMap.mapIterator();\n         }\n         if (size == 0) {\n-            return EmptyMapIterator.INSTANCE;\n-        }\n-        return new FlatMapIterator(this);\n+            return EmptyMapIterator.<K, V>getInstance();\n+        }\n+        return new FlatMapIterator<K, V>(this);\n     }\n \n     /**\n      * FlatMapIterator\n      */\n-    static class FlatMapIterator implements MapIterator, ResettableIterator {\n-        private final Flat3Map parent;\n+    static class FlatMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+        private final Flat3Map<K, V> parent;\n         private int nextIndex = 0;\n         private boolean canRemove = false;\n-        \n-        FlatMapIterator(Flat3Map parent) {\n+\n+        FlatMapIterator(Flat3Map<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n             return (nextIndex < parent.size);\n         }\n \n-        public Object next() {\n+        public K next() {\n             if (hasNext() == false) {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n             canRemove = false;\n         }\n \n-        public Object getKey() {\n+        public K getKey() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n-        public Object setValue(Object value) {\n+        public V setValue(V value) {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n-            Object old = getValue();\n+            V old = getValue();\n             switch (nextIndex) {\n-                case 3: \n+                case 3:\n                     parent.value3 = value;\n                     break;\n                 case 2:\n             }\n             return old;\n         }\n-        \n+\n         public void reset() {\n             nextIndex = 0;\n             canRemove = false;\n         }\n-        \n+\n         public String toString() {\n             if (canRemove) {\n                 return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n-            } else {\n-                return \"Iterator[]\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n     /**\n      * Gets the entrySet view of the map.\n      * Changes made to the view affect this map.\n-     * The Map Entry is not an independent object and changes as the \n+     * The Map Entry is not an independent object and changes as the\n      * iterator progresses.\n      * To simply iterate through the entries, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the entrySet view\n      */\n-    public Set entrySet() {\n+    public Set<Map.Entry<K, V>> entrySet() {\n         if (delegateMap != null) {\n             return delegateMap.entrySet();\n         }\n-        return new EntrySet(this);\n-    }\n-    \n+        return new EntrySet<K, V>(this);\n+    }\n+\n     /**\n      * EntrySet\n      */\n-    static class EntrySet extends AbstractSet {\n-        private final Flat3Map parent;\n-        \n-        EntrySet(Flat3Map parent) {\n+    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        private final Flat3Map<K, V> parent;\n+\n+        EntrySet(Flat3Map<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         public int size() {\n             return parent.size();\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n-        \n+\n         public boolean remove(Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry entry = (Map.Entry) obj;\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n             Object key = entry.getKey();\n             boolean result = parent.containsKey(key);\n             parent.remove(key);\n             return result;\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<Map.Entry<K, V>> iterator() {\n             if (parent.delegateMap != null) {\n                 return parent.delegateMap.entrySet().iterator();\n             }\n             if (parent.size() == 0) {\n-                return EmptyIterator.INSTANCE;\n-            }\n-            return new EntrySetIterator(parent);\n-        }\n-    }\n-\n-    /**\n-     * EntrySetIterator and MapEntry\n-     */\n-    static class EntrySetIterator implements Iterator, Map.Entry {\n-        private final Flat3Map parent;\n+                return EmptyIterator.<Map.Entry<K, V>>getInstance();\n+            }\n+            return new EntrySetIterator<K, V>(parent);\n+        }\n+    }\n+\n+    static abstract class EntryIterator<K, V> implements Map.Entry<K, V> {\n+        private final Flat3Map<K, V> parent;\n         private int nextIndex = 0;\n-        private boolean canRemove = false;\n-        \n-        EntrySetIterator(Flat3Map parent) {\n-            super();\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Create a new Flat3Map.EntryIterator.\n+         */\n+        public EntryIterator(Flat3Map<K, V> parent) {\n             this.parent = parent;\n         }\n \n             return (nextIndex < parent.size);\n         }\n \n-        public Object next() {\n+        public Map.Entry<K, V> nextEntry() {\n             if (hasNext() == false) {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n             canRemove = false;\n         }\n \n-        public Object getKey() {\n+        public K getKey() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n-        public Object setValue(Object value) {\n+        public V setValue(V value) {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n-            Object old = getValue();\n+            V old = getValue();\n             switch (nextIndex) {\n-                case 3: \n+                case 3:\n                     parent.value3 = value;\n                     break;\n                 case 2:\n             }\n             return old;\n         }\n-        \n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        EntrySetIterator(Flat3Map<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n         public boolean equals(Object obj) {\n             if (canRemove == false) {\n                 return false;\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry other = (Map.Entry) obj;\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n             Object key = getKey();\n             Object value = getValue();\n             return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                    (value == null ? other.getValue() == null : value.equals(other.getValue()));\n         }\n-        \n+\n         public int hashCode() {\n             if (canRemove == false) {\n                 return 0;\n             return (key == null ? 0 : key.hashCode()) ^\n                    (value == null ? 0 : value.hashCode());\n         }\n-        \n+\n         public String toString() {\n             if (canRemove) {\n                 return getKey() + \"=\" + getValue();\n-            } else {\n-                return \"\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"\";\n+        }\n+    }\n+\n     /**\n      * Gets the keySet view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the keys, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the keySet view\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         if (delegateMap != null) {\n             return delegateMap.keySet();\n         }\n-        return new KeySet(this);\n+        return new KeySet<K>(this);\n     }\n \n     /**\n      * KeySet\n      */\n-    static class KeySet extends AbstractSet {\n-        private final Flat3Map parent;\n-        \n-        KeySet(Flat3Map parent) {\n+    static class KeySet<K> extends AbstractSet<K> {\n+        private final Flat3Map<K, ?> parent;\n+\n+        KeySet(Flat3Map<K, ?> parent) {\n             super();\n             this.parent = parent;\n         }\n         public int size() {\n             return parent.size();\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n-        \n+\n         public boolean contains(Object key) {\n             return parent.containsKey(key);\n         }\n             return result;\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<K> iterator() {\n             if (parent.delegateMap != null) {\n                 return parent.delegateMap.keySet().iterator();\n             }\n             if (parent.size() == 0) {\n-                return EmptyIterator.INSTANCE;\n-            }\n-            return new KeySetIterator(parent);\n+                return EmptyIterator.<K>getInstance();\n+            }\n+            return new KeySetIterator<K>(parent);\n         }\n     }\n \n     /**\n      * KeySetIterator\n      */\n-    static class KeySetIterator extends EntrySetIterator {\n-        \n-        KeySetIterator(Flat3Map parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n-            super.next();\n+    static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K>{\n+\n+        @SuppressWarnings(\"unchecked\")\n+        KeySetIterator(Flat3Map<K, ?> parent) {\n+            super((Flat3Map<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            nextEntry();\n             return getKey();\n         }\n     }\n-    \n+\n     /**\n      * Gets the values view of the map.\n      * Changes made to the view affect this map.\n      * To simply iterate through the values, use {@link #mapIterator()}.\n-     * \n+     *\n      * @return the values view\n      */\n-    public Collection values() {\n+    public Collection<V> values() {\n         if (delegateMap != null) {\n             return delegateMap.values();\n         }\n-        return new Values(this);\n+        return new Values<V>(this);\n     }\n \n     /**\n      * Values\n      */\n-    static class Values extends AbstractCollection {\n-        private final Flat3Map parent;\n-        \n-        Values(Flat3Map parent) {\n+    static class Values<V> extends AbstractCollection<V> {\n+        private final Flat3Map<?, V> parent;\n+\n+        Values(Flat3Map<?, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         public int size() {\n             return parent.size();\n         }\n-        \n+\n         public void clear() {\n             parent.clear();\n         }\n-        \n+\n         public boolean contains(Object value) {\n             return parent.containsValue(value);\n         }\n \n-        public Iterator iterator() {\n+        public Iterator<V> iterator() {\n             if (parent.delegateMap != null) {\n                 return parent.delegateMap.values().iterator();\n             }\n             if (parent.size() == 0) {\n-                return EmptyIterator.INSTANCE;\n-            }\n-            return new ValuesIterator(parent);\n+                return EmptyIterator.<V>getInstance();\n+            }\n+            return new ValuesIterator<V>(parent);\n         }\n     }\n \n     /**\n      * ValuesIterator\n      */\n-    static class ValuesIterator extends EntrySetIterator {\n-        \n-        ValuesIterator(Flat3Map parent) {\n-            super(parent);\n-        }\n-\n-        public Object next() {\n-            super.next();\n+    static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ValuesIterator(Flat3Map<?, V> parent) {\n+            super((Flat3Map<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            nextEntry();\n             return getValue();\n         }\n     }\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeInt(size());\n-        for (MapIterator it = mapIterator(); it.hasNext();) {\n+        for (MapIterator<?, ?> it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());  // key\n             out.writeObject(it.getValue());  // value\n         }\n     /**\n      * Read the map in using a custom routine.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         int count = in.readInt();\n             delegateMap = createDelegateMap();\n         }\n         for (int i = count; i > 0; i--) {\n-            put(in.readObject(), in.readObject());\n+            put((K) in.readObject(), (V) in.readObject());\n         }\n     }\n \n      * @return a shallow clone\n      * @since Commons Collections 3.1\n      */\n-    public Object clone() {\n+    @SuppressWarnings(\"unchecked\")\n+    public Flat3Map<K, V> clone() {\n         try {\n-            Flat3Map cloned = (Flat3Map) super.clone();\n+            Flat3Map<K, V> cloned = (Flat3Map<K, V>) super.clone();\n             if (cloned.delegateMap != null) {\n-                cloned.delegateMap = (HashedMap) cloned.delegateMap.clone();\n+                cloned.delegateMap = (HashedMap<K, V>) cloned.delegateMap.clone();\n             }\n             return cloned;\n         } catch (CloneNotSupportedException ex) {\n \n     /**\n      * Compares this map with another.\n-     * \n+     *\n      * @param obj  the object to compare to\n      * @return true if equal\n      */\n         if (obj instanceof Map == false) {\n             return false;\n         }\n-        Map other = (Map) obj;\n+        Map<?, ?> other = (Map<?, ?>) obj;\n         if (size != other.size()) {\n             return false;\n         }\n \n     /**\n      * Gets the standard Map hashCode.\n-     * \n+     *\n      * @return the hash code defined in the Map interface\n      */\n     public int hashCode() {\n \n     /**\n      * Gets the map as a String.\n-     * \n+     *\n      * @return a string version of the map\n      */\n     public String toString() {\n--- a/src/java/org/apache/commons/collections/map/HashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/HashedMap.java\n  * A <code>Map</code> implementation that is a general purpose alternative\n  * to <code>HashMap</code>.\n  * <p>\n- * This implementation improves on the JDK1.4 HashMap by adding the \n+ * This implementation improves on the JDK1.4 HashMap by adding the\n  * {@link org.apache.commons.collections.MapIterator MapIterator}\n  * functionality and many methods for subclassing.\n  * <p>\n  * <strong>Note that HashedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Stephen Colebourne\n  */\n-public class HashedMap\n-        extends AbstractHashedMap implements Serializable, Cloneable {\n+public class HashedMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n \n     /** Serialisation version */\n     private static final long serialVersionUID = -1788199231038721040L;\n-    \n+\n     /**\n      * Constructs a new empty map with default size and load factor.\n      */\n     }\n \n     /**\n-     * Constructs a new, empty map with the specified initial capacity. \n+     * Constructs a new, empty map with the specified initial capacity.\n      *\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is less than one\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public HashedMap(Map map) {\n+    public HashedMap(Map<K, V> map) {\n         super(map);\n     }\n \n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n-        return super.clone();\n+    public HashedMap<K, V> clone() {\n+        return (HashedMap<K, V>) super.clone();\n     }\n-    \n+\n     /**\n      * Write the map out using a custom routine.\n      */\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/map/IdentityMap.java\n+++ b/src/java/org/apache/commons/collections/map/IdentityMap.java\n  * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since Commons Collections 3.0\n  * @author java util HashMap\n  * @author Stephen Colebourne\n  */\n-public class IdentityMap\n-        extends AbstractHashedMap implements Serializable, Cloneable {\n+public class IdentityMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n \n     /** Serialisation version */\n     private static final long serialVersionUID = 2028493495224302329L;\n     }\n \n     /**\n-     * Constructs a new, empty map with the specified initial capacity. \n+     * Constructs a new, empty map with the specified initial capacity.\n      *\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is less than one\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public IdentityMap(Map map) {\n+    public IdentityMap(Map<K, V> map) {\n         super(map);\n     }\n \n     /**\n      * Gets the hash code for the key specified.\n      * This implementation uses the identity hash code.\n-     * \n+     *\n      * @param key  the key to get a hash code for\n      * @return the hash code\n      */\n     protected int hash(Object key) {\n         return System.identityHashCode(key);\n     }\n-    \n+\n     /**\n      * Compares two keys for equals.\n      * This implementation uses <code>==</code>.\n-     * \n+     *\n      * @param key1  the first key to compare\n      * @param key2  the second key to compare\n      * @return true if equal by identity\n     protected boolean isEqualKey(Object key1, Object key2) {\n         return (key1 == key2);\n     }\n-    \n+\n     /**\n      * Compares two values for equals.\n      * This implementation uses <code>==</code>.\n-     * \n+     *\n      * @param value1  the first value to compare\n      * @param value2  the second value to compare\n      * @return true if equal by identity\n     protected boolean isEqualValue(Object value1, Object value2) {\n         return (value1 == value2);\n     }\n-    \n+\n     /**\n      * Creates an entry to store the data.\n      * This implementation creates an IdentityEntry instance.\n-     * \n+     *\n      * @param next  the next entry in sequence\n      * @param hashCode  the hash code to use\n      * @param key  the key to store\n      * @param value  the value to store\n      * @return the newly created entry\n      */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new IdentityEntry(next, hashCode, key, value);\n+    protected IdentityEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new IdentityEntry<K, V>(next, hashCode, key, value);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * HashEntry\n      */\n-    protected static class IdentityEntry extends HashEntry {\n-        \n-        protected IdentityEntry(HashEntry next, int hashCode, Object key, Object value) {\n+    protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n+\n+        protected IdentityEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n             super(next, hashCode, key, value);\n         }\n-        \n+\n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry other = (Map.Entry) obj;\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n             return\n                 (getKey() == other.getKey()) &&\n                 (getValue() == other.getValue());\n         }\n-        \n+\n         public int hashCode() {\n             return System.identityHashCode(getKey()) ^\n                    System.identityHashCode(getValue());\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Clones the map without cloning the keys or values.\n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n-        return super.clone();\n+    public IdentityMap<K, V> clone() {\n+        return (IdentityMap<K, V>) super.clone();\n     }\n-    \n+\n     /**\n      * Write the map out using a custom routine.\n      */\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/map/LRUMap.java\n  * <p>\n  * The map implements <code>OrderedMap</code> and entries may be queried using\n  * the bidirectional <code>OrderedMapIterator</code>. The order returned is\n- * least recently used to most recently used. Iterators from map views can \n+ * least recently used to most recently used. Iterators from map views can\n  * also be cast to <code>OrderedIterator</code> if required.\n  * <p>\n  * All the available iterators can be reset back to the start by casting to\n  * <strong>Note that LRUMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * <code>NullPointerException</code>'s when accessed by concurrent threads.\n  *\n  * @since Commons Collections 3.0 (previously in main package v1.0)\n  * @author Mike Pettypiece\n  * @author Mario Ivankovits\n  */\n-public class LRUMap\n-        extends AbstractLinkedMap implements BoundedMap, Serializable, Cloneable {\n-    \n+public class LRUMap<K, V>\n+        extends AbstractLinkedMap<K, V> implements BoundedMap<K, V>, Serializable, Cloneable {\n+\n     /** Serialisation version */\n     private static final long serialVersionUID = -612114643488955218L;\n     /** Default maximum size */\n     protected static final int DEFAULT_MAX_SIZE = 100;\n-    \n+\n     /** Maximum size */\n     private transient int maxSize;\n     /** Scan behaviour */\n \n     /**\n      * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n+     * load factor.\n      *\n      * @param maxSize  the maximum size of the map\n      * @param loadFactor  the load factor\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the map is empty\n      */\n-    public LRUMap(Map map) {\n+    public LRUMap(Map<K, V> map) {\n         this(map, false);\n     }\n \n      * @throws IllegalArgumentException if the map is empty\n      * @since Commons Collections 3.1\n      */\n-    public LRUMap(Map map, boolean scanUntilRemovable) {\n+    public LRUMap(Map<K, V> map, boolean scanUntilRemovable) {\n         this(map.size(), DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n         putAll(map);\n     }\n      * <p>\n      * This operation changes the position of the key in the map to the\n      * most recently used position (first).\n-     * \n+     *\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key) {\n-        LinkEntry entry = (LinkEntry) getEntry(key);\n+    public V get(Object key) {\n+        LinkEntry<K, V> entry = getEntry(key);\n         if (entry == null) {\n             return null;\n         }\n      * Moves an entry to the MRU position at the end of the list.\n      * <p>\n      * This implementation moves the updated entry to the end of the list.\n-     * \n+     *\n      * @param entry  the entry to update\n      */\n-    protected void moveToMRU(LinkEntry entry) {\n+    protected void moveToMRU(LinkEntry<K, V> entry) {\n         if (entry.after != header) {\n             modCount++;\n             // remove\n                 \" (please report this to dev@commons.apache.org)\");\n         }\n     }\n-    \n+\n     /**\n      * Updates an existing key-value mapping.\n      * <p>\n      * This implementation moves the updated entry to the top of the list\n      * using {@link #moveToMRU(AbstractLinkedMap.LinkEntry)}.\n-     * \n+     *\n      * @param entry  the entry to update\n      * @param newValue  the new value to store\n      */\n-    protected void updateEntry(HashEntry entry, Object newValue) {\n-        moveToMRU((LinkEntry) entry);  // handles modCount\n+    protected void updateEntry(HashEntry<K, V> entry, V newValue) {\n+        moveToMRU((LinkEntry<K, V>) entry);  // handles modCount\n         entry.setValue(newValue);\n     }\n-    \n+\n     /**\n      * Adds a new key-value mapping into this map.\n      * <p>\n      * From Commons Collections 3.1 this method uses {@link #isFull()} rather\n      * than accessing <code>size</code> and <code>maxSize</code> directly.\n      * It also handles the scanUntilRemovable functionality.\n-     * \n+     *\n      * @param hashIndex  the index into the data array to store at\n      * @param hashCode  the hash code of the key to add\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n+    protected void addMapping(int hashIndex, int hashCode, K key, V value) {\n         if (isFull()) {\n-            LinkEntry reuse = header.after;\n+            LinkEntry<K, V> reuse = header.after;\n             boolean removeLRUEntry = false;\n             if (scanUntilRemovable) {\n                 while (reuse != header && reuse != null) {\n             } else {\n                 removeLRUEntry = removeLRU(reuse);\n             }\n-            \n+\n             if (removeLRUEntry) {\n                 if (reuse == null) {\n                     throw new IllegalStateException(\n             super.addMapping(hashIndex, hashCode, key, value);\n         }\n     }\n-    \n+\n     /**\n      * Reuses an entry by removing it and moving it to a new place in the map.\n      * <p>\n      * This method uses {@link #removeEntry}, {@link #reuseEntry} and {@link #addEntry}.\n-     * \n+     *\n      * @param entry  the entry to reuse\n      * @param hashIndex  the index into the data array to store at\n      * @param hashCode  the hash code of the key to add\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void reuseMapping(LinkEntry entry, int hashIndex, int hashCode, Object key, Object value) {\n+    protected void reuseMapping(LinkEntry<K, V> entry, int hashIndex, int hashCode, K key, V value) {\n         // find the entry before the entry specified in the hash table\n         // remember that the parameters (except the first) refer to the new entry,\n         // not the old one\n         try {\n             int removeIndex = hashIndex(entry.hashCode, data.length);\n-            HashEntry[] tmp = data;  // may protect against some sync issues\n-            HashEntry loop = tmp[removeIndex];\n-            HashEntry previous = null;\n+            HashEntry<K, V>[] tmp = data;  // may protect against some sync issues\n+            HashEntry<K, V> loop = tmp[removeIndex];\n+            HashEntry<K, V> previous = null;\n             while (loop != entry && loop != null) {\n                 previous = loop;\n                 loop = loop.next;\n                     \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n                     \" If so, then please report this to dev@commons.apache.org as a bug.\");\n             }\n-            \n+\n             // reuse the entry\n             modCount++;\n             removeEntry(entry, removeIndex, previous);\n                     \" If so, then please report this to dev@commons.apache.org as a bug.\");\n         }\n     }\n-    \n+\n     /**\n      * Subclass method to control removal of the least recently used entry from the map.\n      * <p>\n      * <p>\n      * NOTE: Commons Collections 3.0 passed the wrong entry to this method.\n      * This is fixed in version 3.1 onwards.\n-     * \n+     *\n      * @param entry  the entry to be removed\n      */\n-    protected boolean removeLRU(LinkEntry entry) {\n+    protected boolean removeLRU(LinkEntry<K, V> entry) {\n         return true;\n     }\n \n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n-        return super.clone();\n-    }\n-    \n+    public LRUMap<K, V> clone() {\n+        return (LRUMap<K, V>) super.clone();\n+    }\n+\n     /**\n      * Write the map out using a custom routine.\n      */\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n-    \n+\n     /**\n      * Writes the data necessary for <code>put()</code> to work in deserialization.\n      */\n         maxSize = in.readInt();\n         super.doReadObject(in);\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class LinkedMap\n-        extends AbstractLinkedMap implements Serializable, Cloneable {\n+public class LinkedMap<K, V> extends AbstractLinkedMap<K, V> implements Serializable, Cloneable {\n \n     /** Serialisation version */\n     private static final long serialVersionUID = 9077234323521161066L;\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public LinkedMap(Map map) {\n+    public LinkedMap(Map<K, V> map) {\n         super(map);\n     }\n \n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n-        return super.clone();\n+    public LinkedMap<K, V> clone() {\n+        return (LinkedMap<K, V>) super.clone();\n     }\n     \n     /**\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object get(int index) {\n+    public K get(int index) {\n         return getEntry(index).getKey();\n     }\n     \n      * @return the value at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object getValue(int index) {\n+    public V getValue(int index) {\n         return getEntry(index).getValue();\n     }\n     \n     public int indexOf(Object key) {\n         key = convertKey(key);\n         int i = 0;\n-        for (LinkEntry entry = header.after; entry != header; entry = entry.after, i++) {\n+        for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after, i++) {\n             if (isEqualKey(key, entry.key)) {\n                 return i;\n             }\n      *  or <code>null</code> if none existed\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object remove(int index) {\n+    public V remove(int index) {\n         return remove(get(index));\n     }\n \n      * @see #keySet()\n      * @return The ordered list of keys.  \n      */\n-    public List asList() {\n-        return new LinkedMapList(this);\n+    public List<K> asList() {\n+        return new LinkedMapList<K>(this);\n     }\n \n     /**\n      * List view of map.\n      */\n-    static class LinkedMapList extends AbstractList {\n-        \n-        final LinkedMap parent;\n-        \n-        LinkedMapList(LinkedMap parent) {\n+    static class LinkedMapList<K> extends AbstractList<K> {\n+\n+        final LinkedMap<K, ?> parent;\n+\n+        LinkedMapList(LinkedMap<K, ?> parent) {\n             this.parent = parent;\n         }\n-        \n+\n         public int size() {\n             return parent.size();\n         }\n-    \n-        public Object get(int index) {\n+\n+        public K get(int index) {\n             return parent.get(index);\n         }\n-        \n+\n         public boolean contains(Object obj) {\n             return parent.containsKey(obj);\n         }\n         public int indexOf(Object obj) {\n             return parent.indexOf(obj);\n         }\n-        \n+\n         public int lastIndexOf(Object obj) {\n             return parent.indexOf(obj);\n         }\n-        \n-        public boolean containsAll(Collection coll) {\n+\n+        public boolean containsAll(Collection<?> coll) {\n             return parent.keySet().containsAll(coll);\n         }\n-        \n-        public Object remove(int index) {\n-            throw new UnsupportedOperationException();\n-        }\n-        \n+\n+        public K remove(int index) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n         public boolean remove(Object obj) {\n             throw new UnsupportedOperationException();\n         }\n-        \n-        public boolean removeAll(Collection coll) {\n-            throw new UnsupportedOperationException();\n-        }\n-        \n-        public boolean retainAll(Collection coll) {\n-            throw new UnsupportedOperationException();\n-        }\n-        \n+\n+        public boolean removeAll(Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean retainAll(Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n         public void clear() {\n             throw new UnsupportedOperationException();\n         }\n-        \n+\n         public Object[] toArray() {\n             return parent.keySet().toArray();\n         }\n \n-        public Object[] toArray(Object[] array) {\n+        public <T> T[] toArray(T[] array) {\n             return parent.keySet().toArray(array);\n         }\n-        \n-        public Iterator iterator() {\n+\n+        public Iterator<K> iterator() {\n             return UnmodifiableIterator.decorate(parent.keySet().iterator());\n         }\n-        \n-        public ListIterator listIterator() {\n+\n+        public ListIterator<K> listIterator() {\n             return UnmodifiableListIterator.decorate(super.listIterator());\n         }\n-        \n-        public ListIterator listIterator(int fromIndex) {\n+\n+        public ListIterator<K> listIterator(int fromIndex) {\n             return UnmodifiableListIterator.decorate(super.listIterator(fromIndex));\n         }\n-        \n-        public List subList(int fromIndexInclusive, int toIndexExclusive) {\n+\n+        public List<K> subList(int fromIndexInclusive, int toIndexExclusive) {\n             return UnmodifiableList.decorate(super.subList(fromIndexInclusive, toIndexExclusive));\n         }\n     }\n-    \n+\n }\n--- a/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n package org.apache.commons.collections.map;\n \n import java.io.Serializable;\n-import java.util.Collection;\n-import java.util.Iterator;\n import java.util.Map;\n-import java.util.Set;\n \n import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.MapIterator;\n  *\n  * @author Stephen Colebourne\n  */\n-public class MultiKeyMap\n-        implements IterableMap, Serializable {\n+public class MultiKeyMap<K, V> extends AbstractMapDecorator<MultiKey<? extends K>, V>\n+        implements IterableMap<MultiKey<? extends K>, V>, Serializable {\n \n     /** Serialisation version */\n     private static final long serialVersionUID = -1788199231038721040L;\n \n     /** The decorated map */\n-    protected final AbstractHashedMap map;\n+    //keep this member around for serialization BC with older Collections releases assuming we want to do that\n+    protected AbstractHashedMap<MultiKey<? extends K>, V> map;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param map  the map to decorate, not null\n      * @throws IllegalArgumentException if the map is null or not empty\n      */\n-    public static MultiKeyMap decorate(AbstractHashedMap map) {\n+    public static <K, V> MultiKeyMap<K, V> decorate(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n         if (map.size() > 0) {\n             throw new IllegalArgumentException(\"Map must be empty\");\n         }\n-        return new MultiKeyMap(map);\n+        return new MultiKeyMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------    \n      * Constructs a new MultiKeyMap that decorates a <code>HashedMap</code>.\n      */\n     public MultiKeyMap() {\n-        super();\n-        map = new HashedMap();\n+        this(new HashedMap<MultiKey<? extends K>, V>());\n     }\n \n     /**\n      *\n      * @param map  the map to decorate\n      */\n-    protected MultiKeyMap(AbstractHashedMap map) {\n-        super();\n+    protected MultiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+        super(map);\n         this.map = map;\n     }\n \n      * @param key2  the second key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key1, Object key2) {\n+    public V get(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 return true;\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public Object put(Object key1, Object key2, Object value) {\n+    public V put(K key1, K key2, V value) {\n         int hashCode = hash(key1, key2);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n-                Object oldValue = entry.getValue();\n-                map.updateEntry(entry, value);\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n-        \n-        map.addMapping(index, hashCode, new MultiKey(key1, key2), value);\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2), value);\n         return null;\n     }\n \n      * @param key2  the second key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key1, Object key2) {\n+    public V remove(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n-        AbstractHashedMap.HashEntry previous = null;\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n-                Object oldValue = entry.getValue();\n-                map.removeMapping(entry, index, previous);\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key2  the second key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2) {\n-        MultiKey multi = (MultiKey) entry.getKey();\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            Object key1, Object key2) {\n+        MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 2 &&\n-            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n-            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)));\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key1 != null && key2.equals(multi.getKey(1)));\n     }\n \n     //-----------------------------------------------------------------------\n      * @param key3  the third key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key1, Object key2, Object key3) {\n+    public V get(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 return true;\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public Object put(Object key1, Object key2, Object key3, Object value) {\n+    public V put(K key1, K key2, K key3, V value) {\n         int hashCode = hash(key1, key2, key3);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n-                Object oldValue = entry.getValue();\n-                map.updateEntry(entry, value);\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n-        \n-        map.addMapping(index, hashCode, new MultiKey(key1, key2, key3), value);\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3), value);\n         return null;\n     }\n \n      * @param key3  the third key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key1, Object key2, Object key3) {\n+    public V remove(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n-        AbstractHashedMap.HashEntry previous = null;\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n-                Object oldValue = entry.getValue();\n-                map.removeMapping(entry, index, previous);\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key3  the third key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2, Object key3) {\n-        MultiKey multi = (MultiKey) entry.getKey();\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry, Object key1, Object key2, Object key3) {\n+        MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 3 &&\n-            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n-            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n-            (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)));\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2)));\n     }\n \n     //-----------------------------------------------------------------------\n      * @param key4  the fourth key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key1, Object key2, Object key3, Object key4) {\n+    public V get(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 return true;\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public Object put(Object key1, Object key2, Object key3, Object key4, Object value) {\n+    public V put(K key1, K key2, K key3, K key4, V value) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n-                Object oldValue = entry.getValue();\n-                map.updateEntry(entry, value);\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n-        \n-        map.addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4), value);\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3, key4), value);\n         return null;\n     }\n \n      * @param key4  the fourth key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key1, Object key2, Object key3, Object key4) {\n+    public V remove(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n-        AbstractHashedMap.HashEntry previous = null;\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n-                Object oldValue = entry.getValue();\n-                map.removeMapping(entry, index, previous);\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key4  the fourth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2, Object key3, Object key4) {\n-        MultiKey multi = (MultiKey) entry.getKey();\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry, Object key1, Object key2, Object key3, Object key4) {\n+        MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 4 &&\n-            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n-            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n-            (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n-            (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)));\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n+            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3)));\n     }\n \n     //-----------------------------------------------------------------------\n      * @param key5  the fifth key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+    public V get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 return true;\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public Object put(Object key1, Object key2, Object key3, Object key4, Object key5, Object value) {\n+    public V put(K key1, K key2, K key3, K key4, K key5, V value) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n-                Object oldValue = entry.getValue();\n-                map.updateEntry(entry, value);\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n-        \n-        map.addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4, key5), value);\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3, key4, key5), value);\n         return null;\n     }\n \n      * @param key5  the fifth key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public Object remove(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+    public V remove(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        int index = map.hashIndex(hashCode, map.data.length);\n-        AbstractHashedMap.HashEntry entry = map.data[index];\n-        AbstractHashedMap.HashEntry previous = null;\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n-                Object oldValue = entry.getValue();\n-                map.removeMapping(entry, index, previous);\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key5  the fifth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2, Object key3, Object key4, Object key5) {\n-        MultiKey multi = (MultiKey) entry.getKey();\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 5 &&\n-            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n-            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n-            (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n-            (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3))) &&\n-            (key5 == null ? multi.getKey(4) == null : key5.equals(multi.getKey(4)));\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n+            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3))) &&\n+            (key5 == multi.getKey(4) || key5 != null && key5.equals(multi.getKey(4)));\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public boolean removeAll(Object key1) {\n         boolean modified = false;\n-        MapIterator it = mapIterator();\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey multi = (MultiKey) it.next();\n+            MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 1 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {\n                 it.remove();\n      */\n     public boolean removeAll(Object key1, Object key2) {\n         boolean modified = false;\n-        MapIterator it = mapIterator();\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey multi = (MultiKey) it.next();\n+            MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 2 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                 (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {\n      */\n     public boolean removeAll(Object key1, Object key2, Object key3) {\n         boolean modified = false;\n-        MapIterator it = mapIterator();\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey multi = (MultiKey) it.next();\n+            MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 3 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                 (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n      */\n     public boolean removeAll(Object key1, Object key2, Object key3, Object key4) {\n         boolean modified = false;\n-        MapIterator it = mapIterator();\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey multi = (MultiKey) it.next();\n+            MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 4 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                 (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n      * \n      * @param key  the key to check\n      */\n-    protected void checkKey(Object key) {\n+    protected void checkKey(MultiKey<?> key) {\n         if (key == null) {\n             throw new NullPointerException(\"Key must not be null\");\n-        }\n-        if (key instanceof MultiKey == false) {\n-            throw new ClassCastException(\"Key must be a MultiKey\");\n         }\n     }\n \n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n-        return new MultiKeyMap((AbstractHashedMap) map.clone());\n+    public MultiKeyMap<K, V> clone() {\n+        return new MultiKeyMap<K, V>(decorated().clone());\n     }\n \n     /**\n      * @throws NullPointerException if the key is null\n      * @throws ClassCastException if the key is not a MultiKey\n      */\n-    public Object put(Object key, Object value) {\n+    public V put(MultiKey<? extends K> key, V value) {\n         checkKey(key);\n-        return map.put(key, value);\n+        return super.put(key, value);\n     }\n \n     /**\n      * @throws NullPointerException if the mapToCopy or any key within is null\n      * @throws ClassCastException if any key in mapToCopy is not a MultiKey\n      */\n-    public void putAll(Map mapToCopy) {\n-        for (Iterator it = mapToCopy.keySet().iterator(); it.hasNext();) {\n-            Object key = it.next();\n+    @Override\n+    public void putAll(Map<? extends MultiKey<? extends K>, ? extends V> mapToCopy) {\n+        for (MultiKey<? extends K> key : mapToCopy.keySet()) {\n             checkKey(key);\n         }\n-        map.putAll(mapToCopy);\n+        super.putAll(mapToCopy);\n     }\n \n     //-----------------------------------------------------------------------\n-    public MapIterator mapIterator() {\n-        return map.mapIterator();\n-    }\n-\n-    public int size() {\n-        return map.size();\n-    }\n-\n-    public boolean isEmpty() {\n-        return map.isEmpty();\n-    }\n-\n-    public boolean containsKey(Object key) {\n-        return map.containsKey(key);\n-    }\n-\n-    public boolean containsValue(Object value) {\n-        return map.containsValue(value);\n-    }\n-\n-    public Object get(Object key) {\n-        return map.get(key);\n-    }\n-\n-    public Object remove(Object key) {\n-        return map.remove(key);\n-    }\n-\n-    public void clear() {\n-        map.clear();\n-    }\n-\n-    public Set keySet() {\n-        return map.keySet();\n-    }\n-\n-    public Collection values() {\n-        return map.values();\n-    }\n-\n-    public Set entrySet() {\n-        return map.entrySet();\n-    }\n-\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        }\n-        return map.equals(obj);\n-    }\n-\n-    public int hashCode() {\n-        return map.hashCode();\n-    }\n-\n-    public String toString() {\n-        return map.toString();\n-    }\n-\n+    public MapIterator<MultiKey<? extends K>, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected AbstractHashedMap<MultiKey<? extends K>, V> decorated() {\n+        return map;\n+    }\n }\n--- a/src/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n  * @author Stephen Colebourne\n  * @author Paul Jack\n  */\n-public class PredicatedSortedMap\n-        extends PredicatedMap\n-        implements SortedMap {\n+public class PredicatedSortedMap<K, V> extends PredicatedMap<K, V> implements SortedMap<K, V> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 3359846175935304332L;\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static SortedMap decorate(SortedMap map, Predicate keyPredicate, Predicate valuePredicate) {\n-        return new PredicatedSortedMap(map, keyPredicate, valuePredicate);\n+    public static <K, V> SortedMap<K, V> decorate(SortedMap<K, V> map,\n+            Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    protected PredicatedSortedMap(SortedMap map, Predicate keyPredicate, Predicate valuePredicate) {\n+    protected PredicatedSortedMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n+            Predicate<? super V> valuePredicate) {\n         super(map, keyPredicate, valuePredicate);\n     }\n \n      * \n      * @return the decorated map\n      */\n-    protected SortedMap getSortedMap() {\n-        return (SortedMap) map;\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object firstKey() {\n+    public K firstKey() {\n         return getSortedMap().firstKey();\n     }\n \n-    public Object lastKey() {\n+    public K lastKey() {\n         return getSortedMap().lastKey();\n     }\n \n-    public Comparator comparator() {\n+    public Comparator<? super K> comparator() {\n         return getSortedMap().comparator();\n     }\n \n-    public SortedMap subMap(Object fromKey, Object toKey) {\n-        SortedMap map = getSortedMap().subMap(fromKey, toKey);\n-        return new PredicatedSortedMap(map, keyPredicate, valuePredicate);\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n-    public SortedMap headMap(Object toKey) {\n-        SortedMap map = getSortedMap().headMap(toKey);\n-        return new PredicatedSortedMap(map, keyPredicate, valuePredicate);\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n-    public SortedMap tailMap(Object fromKey) {\n-        SortedMap map = getSortedMap().tailMap(fromKey);\n-        return new PredicatedSortedMap(map, keyPredicate, valuePredicate);\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class ReferenceIdentityMap extends AbstractReferenceMap implements Serializable {\n+public class ReferenceIdentityMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -1266190134568365852L;\n      * use hard references to keys and soft references to values.\n      */\n     public ReferenceIdentityMap() {\n-        super(HARD, SOFT, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n+                DEFAULT_LOAD_FACTOR, false);\n     }\n \n     /**\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n      */\n-    public ReferenceIdentityMap(int keyType, int valueType) {\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n     }\n \n      * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceIdentityMap(int keyType, int valueType, boolean purgeValues) {\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n+            boolean purgeValues) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n     }\n \n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      */\n-    public ReferenceIdentityMap(int keyType, int valueType, int capacity, float loadFactor) {\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n+            int capacity, float loadFactor) {\n         super(keyType, valueType, capacity, loadFactor, false);\n     }\n \n      * @param purgeValues  should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceIdentityMap(int keyType, int valueType, int capacity,\n-                        float loadFactor, boolean purgeValues) {\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n+            int capacity, float loadFactor, boolean purgeValues) {\n         super(keyType, valueType, capacity, loadFactor, purgeValues);\n     }\n \n      * @return true if equal by identity\n      */\n     protected boolean isEqualKey(Object key1, Object key2) {\n-        key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n-        return (key1 == key2);\n+        key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<?>) key2).get();\n+        return key1 == key2;\n     }\n \n     /**\n      * @return true if equal by identity\n      */\n     protected boolean isEqualValue(Object value1, Object value2) {\n-        return (value1 == value2);\n+        return value1 == value2;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/collections/map/ReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceMap.java\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  */\n-public class ReferenceMap extends AbstractReferenceMap implements Serializable {\n+public class ReferenceMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 1555089888138299607L;\n      * use hard references to keys and soft references to values.\n      */\n     public ReferenceMap() {\n-        super(HARD, SOFT, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n+                DEFAULT_LOAD_FACTOR, false);\n     }\n \n     /**\n      * @param valueType  the type of reference to use for values;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n      */\n-    public ReferenceMap(int keyType, int valueType) {\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n     }\n \n      * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceMap(int keyType, int valueType, boolean purgeValues) {\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, boolean purgeValues) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n     }\n \n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      */\n-    public ReferenceMap(int keyType, int valueType, int capacity, float loadFactor) {\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n+            float loadFactor) {\n         super(keyType, valueType, capacity, loadFactor, false);\n     }\n \n      * @param purgeValues  should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceMap(int keyType, int valueType, int capacity,\n-                        float loadFactor, boolean purgeValues) {\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n+            float loadFactor, boolean purgeValues) {\n         super(keyType, valueType, capacity, loadFactor, purgeValues);\n     }\n \n--- a/src/java/org/apache/commons/collections/map/SingletonMap.java\n+++ b/src/java/org/apache/commons/collections/map/SingletonMap.java\n \n import org.apache.commons.collections.BoundedMap;\n import org.apache.commons.collections.KeyValue;\n-import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedMap;\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.ResettableIterator;\n  *\n  * @author Stephen Colebourne\n  */\n-public class SingletonMap\n-        implements OrderedMap, BoundedMap, KeyValue, Serializable, Cloneable {\n+public class SingletonMap<K, V>\n+        implements OrderedMap<K, V>, BoundedMap<K, V>, KeyValue<K, V>, Serializable, Cloneable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -8931271118676803261L;\n \n     /** Singleton key */\n-    private final Object key;\n+    private final K key;\n     /** Singleton value */\n-    private Object value;\n+    private V value;\n \n     /**\n      * Constructor that creates a map of <code>null</code> to <code>null</code>.\n      * @param key  the key to use\n      * @param value  the value to use\n      */\n-    public SingletonMap(Object key, Object value) {\n+    public SingletonMap(K key, V value) {\n         super();\n         this.key = key;\n         this.value = value;\n      *\n      * @param keyValue  the key value pair to use\n      */\n-    public SingletonMap(KeyValue keyValue) {\n+    public SingletonMap(KeyValue<K, V> keyValue) {\n         super();\n         this.key = keyValue.getKey();\n         this.value = keyValue.getValue();\n      *\n      * @param mapEntry  the mapEntry to use\n      */\n-    public SingletonMap(Map.Entry mapEntry) {\n+    public SingletonMap(Map.Entry<K, V> mapEntry) {\n         super();\n         this.key = mapEntry.getKey();\n         this.value = mapEntry.getValue();\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the size is not 1\n      */\n-    public SingletonMap(Map map) {\n+    public SingletonMap(Map<K, V> map) {\n         super();\n         if (map.size() != 1) {\n             throw new IllegalArgumentException(\"The map size must be 1\");\n         }\n-        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n         this.key = entry.getKey();\n         this.value = entry.getValue();\n     }\n      *\n      * @return the key \n      */\n-    public Object getKey() {\n+    public K getKey() {\n         return key;\n     }\n \n      *\n      * @return the value\n      */\n-    public Object getValue() {\n+    public V getValue() {\n         return value;\n     }\n \n      * @param value  the new value to set\n      * @return the old value\n      */\n-    public Object setValue(Object value) {\n-        Object old = this.value;\n+    public V setValue(V value) {\n+        V old = this.value;\n         this.value = value;\n         return old;\n     }\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public Object get(Object key) {\n+    public V get(Object key) {\n         if (isEqualKey(key)) {\n             return value;\n         }\n      * @return the value previously mapped to this key, null if none\n      * @throws IllegalArgumentException if the key does not match\n      */\n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         if (isEqualKey(key)) {\n             return setValue(value);\n         }\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the key does not match\n      */\n-    public void putAll(Map map) {\n+    public void putAll(Map<? extends K, ? extends V> map) {\n         switch (map.size()) {\n             case 0:\n                 return;\n-            \n+\n             case 1:\n-                Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n+                Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n                 put(entry.getKey(), entry.getValue());\n                 return;\n-            \n+\n             default:\n                 throw new IllegalArgumentException(\"The map size must be 0 or 1\");\n         }\n     }\n-\n+    \n     /**\n      * Unsupported operation.\n      * \n      * @return the value mapped to the removed key, null if key not in map\n      * @throws UnsupportedOperationException always\n      */\n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n      * \n      * @return the entrySet view\n      */\n-    public Set entrySet() {\n-        Map.Entry entry = new TiedMapEntry(this, getKey());\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(this, getKey());\n         return Collections.singleton(entry);\n     }\n     \n      * \n      * @return the keySet view\n      */\n-    public Set keySet() {\n+    public Set<K> keySet() {\n         return Collections.singleton(key);\n     }\n \n      * \n      * @return the values view\n      */\n-    public Collection values() {\n-        return new SingletonValues(this);\n-    }\n-\n-    /**\n-     * Gets an iterator over the map.\n-     * Changes made to the iterator using <code>setValue</code> affect this map.\n-     * The <code>remove</code> method is unsupported.\n-     * <p>\n-     * A MapIterator returns the keys in the map. It also provides convenient\n-     * methods to get the key and value, and set the value.\n-     * It avoids the need to create an entrySet/keySet/values object.\n-     * It also avoids creating the Map Entry object.\n-     * \n-     * @return the map iterator\n-     */\n-    public MapIterator mapIterator() {\n-        return new SingletonMapIterator(this);\n-    }\n-\n-    // OrderedMap\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Obtains an <code>OrderedMapIterator</code> over the map.\n-     * <p>\n-     * A ordered map iterator is an efficient way of iterating over maps\n-     * in both directions.\n-     * \n-     * @return an ordered map iterator\n-     */\n-    public OrderedMapIterator orderedMapIterator() {\n-        return new SingletonMapIterator(this);\n+    public Collection<V> values() {\n+        return new SingletonValues<V>(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new SingletonMapIterator<K, V>(this);\n     }\n \n     /**\n      * \n      * @return the key\n      */\n-    public Object firstKey() {\n+    public K firstKey() {\n         return getKey();\n     }\n \n      * \n      * @return the key\n      */\n-    public Object lastKey() {\n+    public K lastKey() {\n         return getKey();\n     }\n \n      * @param key  the next key\n      * @return null always\n      */\n-    public Object nextKey(Object key) {\n+    public K nextKey(K key) {\n         return null;\n     }\n \n      * @param key  the next key\n      * @return null always\n      */\n-    public Object previousKey(Object key) {\n+    public K previousKey(K key) {\n         return null;\n     }\n \n     /**\n      * SingletonMapIterator.\n      */\n-    static class SingletonMapIterator implements OrderedMapIterator, ResettableIterator {\n-        private final SingletonMap parent;\n+    static class SingletonMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+        private final SingletonMap<K, V> parent;\n         private boolean hasNext = true;\n         private boolean canGetSet = false;\n         \n-        SingletonMapIterator(SingletonMap parent) {\n+        SingletonMapIterator(SingletonMap<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n             return hasNext;\n         }\n \n-        public Object next() {\n+        public K next() {\n             if (hasNext == false) {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n             return (hasNext == false);\n         }\n \n-        public Object previous() {\n+        public K previous() {\n             if (hasNext == true) {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n             }\n             throw new UnsupportedOperationException();\n         }\n \n-        public Object getKey() {\n+        public K getKey() {\n             if (canGetSet == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             return parent.getKey();\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             if (canGetSet == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return parent.getValue();\n         }\n \n-        public Object setValue(Object value) {\n+        public V setValue(V value) {\n             if (canGetSet == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n         public String toString() {\n             if (hasNext) {\n                 return \"Iterator[]\";\n-            } else {\n-                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n             }\n+            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n         }\n     }\n     \n      * Values implementation for the SingletonMap.\n      * This class is needed as values is a view that must update as the map updates.\n      */\n-    static class SingletonValues extends AbstractSet implements Serializable {\n+    static class SingletonValues<V> extends AbstractSet<V> implements Serializable {\n         private static final long serialVersionUID = -3689524741863047872L;\n-        private final SingletonMap parent;\n-\n-        SingletonValues(SingletonMap parent) {\n+        private final SingletonMap<?, V> parent;\n+\n+        SingletonValues(SingletonMap<?, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         public void clear() {\n             throw new UnsupportedOperationException();\n         }\n-        public Iterator iterator() {\n-            return new SingletonIterator(parent.getValue(), false);\n+        public Iterator<V> iterator() {\n+            return new SingletonIterator<V>(parent.getValue(), false);\n         }\n     }\n     \n      *\n      * @return a shallow clone\n      */\n-    public Object clone() {\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> clone() {\n         try {\n-            SingletonMap cloned = (SingletonMap) super.clone();\n-            return cloned;\n+            return (SingletonMap<K, V>) super.clone();\n         } catch (CloneNotSupportedException ex) {\n             throw new InternalError();\n         }\n      * @param obj  the object to compare to\n      * @return true if equal\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n--- a/src/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n+++ b/src/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableEntrySet\n-        extends AbstractSetDecorator implements Unmodifiable {\n+public final class UnmodifiableEntrySet<K, V>\n+        extends AbstractSetDecorator<Map.Entry<K, V>> implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1678353579659253473L;\n \n     /**\n      * Factory method to create an unmodifiable set of Map Entry objects.\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static Set decorate(Set set) {\n+    public static <K, V> Set<Map.Entry<K, V>> decorate(Set<Map.Entry<K, V>> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n-        return new UnmodifiableEntrySet(set);\n+        return new UnmodifiableEntrySet<K, V>(set);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    private UnmodifiableEntrySet(Set set) {\n+    private UnmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n         super(set);\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add(Object object) {\n+    public boolean add(Map.Entry<K, V> object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean addAll(Collection coll) {\n+    public boolean addAll(Collection<? extends Map.Entry<K, V>> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean retainAll(Collection coll) {\n+    public boolean retainAll(Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     //-----------------------------------------------------------------------\n-    public Iterator iterator() {\n+    public Iterator<Map.Entry<K, V>> iterator() {\n         return new UnmodifiableEntrySetIterator(collection.iterator());\n     }\n     \n+    @SuppressWarnings(\"unchecked\")\n     public Object[] toArray() {\n         Object[] array = collection.toArray();\n         for (int i = 0; i < array.length; i++) {\n-            array[i] = new UnmodifiableEntry((Map.Entry) array[i]);\n+            array[i] = new UnmodifiableEntry((Map.Entry<K, V>) array[i]);\n         }\n         return array;\n     }\n     \n-    public Object[] toArray(Object array[]) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n         Object[] result = array;\n         if (array.length > 0) {\n             // we must create a new array to handle multi-threaded situations\n         }\n         result = collection.toArray(result);\n         for (int i = 0; i < result.length; i++) {\n-            result[i] = new UnmodifiableEntry((Map.Entry) result[i]);\n+            result[i] = new UnmodifiableEntry((Map.Entry<K, V>) result[i]);\n         }\n \n         // check to see if result should be returned straight\n         if (result.length > array.length) {\n-            return result;\n+            return (T[]) result;\n         }\n \n-        // copy back into input array to fulfil the method contract\n+        // copy back into input array to fulfill the method contract\n         System.arraycopy(result, 0, array, 0, result.length);\n         if (array.length > result.length) {\n             array[result.length] = null;\n     /**\n      * Implementation of an entry set iterator.\n      */\n-    final static class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator {\n-        \n-        protected UnmodifiableEntrySetIterator(Iterator iterator) {\n+    private class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        protected UnmodifiableEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {\n             super(iterator);\n         }\n-        \n-        public Object next() {\n-            Map.Entry entry = (Map.Entry) iterator.next();\n-            return new UnmodifiableEntry(entry);\n+\n+        public Map.Entry<K, V> next() {\n+            return new UnmodifiableEntry(iterator.next());\n         }\n-        \n+\n         public void remove() {\n             throw new UnsupportedOperationException();\n         }\n     /**\n      * Implementation of a map entry that is unmodifiable.\n      */\n-    final static class UnmodifiableEntry extends AbstractMapEntryDecorator {\n+    private class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V> {\n \n-        protected UnmodifiableEntry(Map.Entry entry) {\n+        protected UnmodifiableEntry(Map.Entry<K, V> entry) {\n             super(entry);\n         }\n \n-        public Object setValue(Object obj) {\n+        public V setValue(V obj) {\n             throw new UnsupportedOperationException();\n         }\n     }\n--- a/src/java/org/apache/commons/collections/map/UnmodifiableMap.java\n+++ b/src/java/org/apache/commons/collections/map/UnmodifiableMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableMap\n-        extends AbstractMapDecorator\n-        implements IterableMap, Unmodifiable, Serializable {\n+public final class UnmodifiableMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements IterableMap<K, V>, Unmodifiable, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 2737023427269031941L;\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static Map decorate(Map map) {\n+    public static <K, V> Map<K, V> decorate(Map<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n-        return new UnmodifiableMap(map);\n+        return new UnmodifiableMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableMap(Map map) {\n+    private UnmodifiableMap(Map<K, V> map) {\n         super(map);\n     }\n \n      * @throws ClassNotFoundException\n      * @since Commons Collections 3.1\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        map = (Map) in.readObject();\n+        map = (Map<K, V>) in.readObject();\n     }\n \n     //-----------------------------------------------------------------------\n         throw new UnsupportedOperationException();\n     }\n \n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public void putAll(Map mapToCopy) {\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public MapIterator mapIterator() {\n+    public MapIterator<K, V> mapIterator() {\n         if (map instanceof IterableMap) {\n-            MapIterator it = ((IterableMap) map).mapIterator();\n-            return UnmodifiableMapIterator.decorate(it);\n-        } else {\n-            MapIterator it = new EntrySetMapIterator(map);\n+            MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n             return UnmodifiableMapIterator.decorate(it);\n         }\n+        MapIterator<K, V> it = new EntrySetMapIterator<K, V>(map);\n+        return UnmodifiableMapIterator.decorate(it);\n     }\n \n-    public Set entrySet() {\n-        Set set = super.entrySet();\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.decorate(set);\n     }\n \n-    public Set keySet() {\n-        Set set = super.keySet();\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n         return UnmodifiableSet.decorate(set);\n     }\n \n-    public Collection values() {\n-        Collection coll = super.values();\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n         return UnmodifiableCollection.decorate(coll);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/AbstractSerializableSetDecorator.java\n+++ b/src/java/org/apache/commons/collections/set/AbstractSerializableSetDecorator.java\n  * @author Stephen Colebourne\n  * @since Commons Collections 3.1\n  */\n-public abstract class AbstractSerializableSetDecorator\n-        extends AbstractSetDecorator\n+public abstract class AbstractSerializableSetDecorator<E>\n+        extends AbstractSetDecorator<E>\n         implements Serializable {\n \n     /** Serialization version */\n     /**\n      * Constructor.\n      */\n-    protected AbstractSerializableSetDecorator(Set set) {\n+    protected AbstractSerializableSetDecorator(Set<E> set) {\n         super(set);\n     }\n \n      * @throws IOException\n      * @throws ClassNotFoundException\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        collection = (Collection) in.readObject();\n+        collection = (Collection<E>) in.readObject();\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/set/CompositeSet.java\n+++ b/src/java/org/apache/commons/collections/set/CompositeSet.java\n package org.apache.commons.collections.set;\n \n import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n \n import org.apache.commons.collections.CollectionUtils;\n  *\n  * @author Brian McCallister\n  */\n-public class CompositeSet extends CompositeCollection implements Set {\n+public class CompositeSet<E> extends CompositeCollection<E> implements Set<E> {\n+\n     /**\n      * Create an empty CompositeSet\n      */\n     public CompositeSet() {\n         super();\n     }\n-    \n+\n     /**\n      * Create a CompositeSet with just <code>set</code> composited\n      * @param set The initial set in the composite\n      */\n-    public CompositeSet(Set set) {\n+    public CompositeSet(Set<E> set) {\n         super(set);\n     }\n-    \n+\n     /**\n      * Create a composite set with sets as the initial set of composited Sets\n      */\n-    public CompositeSet(Set[] sets) {\n+    public CompositeSet(Set<E>[] sets) {\n         super(sets);\n     }\n-    \n+\n     /**\n      * Add a Set to this composite\n      *\n      * @see org.apache.commons.collections.collection.CompositeCollection.CollectionMutator\n      * @see SetMutator\n      */\n-    public synchronized void addComposited(Collection c) {\n+    public synchronized void addComposited(Collection<E> c) {\n         if (!(c instanceof Set)) {\n             throw new IllegalArgumentException(\"Collections added must implement java.util.Set\");\n         }\n-        \n-        for (Iterator i = this.getCollections().iterator(); i.hasNext();) {\n-            Set set = (Set) i.next();\n-            Collection intersects = CollectionUtils.intersection(set, c);\n+\n+        for (Set<E> set : getCollections()) {\n+            Collection<E> intersects = CollectionUtils.intersection(set, c);\n             if (intersects.size() > 0) {\n                 if (this.mutator == null) {\n                     throw new UnsupportedOperationException(\n                     throw new UnsupportedOperationException(\n                         \"Collision adding composited collection to a CompositeSet with a CollectionMutator instead of a SetMutator\");\n                 }\n-                ((SetMutator) this.mutator).resolveCollision(this, set, (Set) c, intersects);\n+                getMutator().resolveCollision(this, set, (Set<E>) c, intersects);\n                 if (CollectionUtils.intersection(set, c).size() > 0) {\n                     throw new IllegalArgumentException(\n                         \"Attempt to add illegal entry unresolved by SetMutator.resolveCollision()\");\n                 }\n             }\n         }\n-        super.addComposited(new Collection[]{c});\n-    }\n-    \n+        super.addComposited(c);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public List<? extends Set<E>> getCollections() {\n+        return (List<Set<E>>) super.getCollections();\n+    }\n+\n     /**\n      * Add two sets to this composite\n      *\n      * @throws IllegalArgumentException if c or d does not implement java.util.Set\n      */\n-    public synchronized void addComposited(Collection c, Collection d) {\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized void addComposited(Collection<E> c, Collection<E> d) {\n         if (!(c instanceof Set)) throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n         if (!(d instanceof Set)) throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n-        this.addComposited(new Set[]{(Set) c, (Set) d});\n-    }\n-    \n+        this.addComposited(new Set[] { (Set<? extends E>) c, (Set<? extends E>) d });\n+    }\n+\n     /**\n      * Add an array of sets to this composite\n      * @param comps\n      * @throws IllegalArgumentException if any of the collections in comps do not implement Set\n      */\n-    public synchronized void addComposited(Collection[] comps) {\n+    public synchronized void addComposited(Collection<E>[] comps) {\n         for (int i = comps.length - 1; i >= 0; --i) {\n             this.addComposited(comps[i]);\n         }\n     }\n-    \n+\n     /**\n      * This can receive either a <code>CompositeCollection.CollectionMutator</code>\n      * or a <code>CompositeSet.SetMutator</code>. If a\n      * composited sets will throw IllegalArgumentException\n      * <p>\n      */\n-    public void setMutator(CollectionMutator mutator) {\n+    public void setMutator(CollectionMutator<E> mutator) {\n         super.setMutator(mutator);\n     }\n-    \n+\n     /* Set operations */\n-    \n+\n     /**\n      * If a <code>CollectionMutator</code> is defined for this CompositeSet then this\n      * method will be called anyway.\n      * @return true if the object is removed, false otherwise\n      */\n     public boolean remove(Object obj) {\n-        for (Iterator i = this.getCollections().iterator(); i.hasNext();) {\n-            Set set = (Set) i.next();\n+        for (Set<? extends E> set : getCollections()) {\n             if (set.contains(obj)) return set.remove(obj);\n         }\n         return false;\n     }\n-    \n-    \n+\n     /**\n      * @see Set#equals\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj instanceof Set) {\n             Set set = (Set) obj;\n-            if (set.containsAll(this) && set.size() == this.size()) {\n-                return true;\n-            }\n+            return set.containsAll(this) && set.size() == this.size();\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * @see Set#hashCode\n      */\n     public int hashCode() {\n         int code = 0;\n-        for (Iterator i = this.iterator(); i.hasNext();) {\n-            Object next = i.next();\n-            code += (next != null ? next.hashCode() : 0);\n+        for (E e : this) {\n+            code += (e == null ? 0 : e.hashCode());\n         }\n         return code;\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected SetMutator<E> getMutator() {\n+        return (SetMutator<E>) super.getMutator();\n+    }\n+\n     /**\n      * Define callbacks for mutation operations.\n      * <p>\n      * Defining remove() on implementations of SetMutator is pointless\n      * as they are never called by CompositeSet.\n      */\n-    public static interface SetMutator extends CompositeCollection.CollectionMutator {\n+    public static interface SetMutator<E> extends CompositeCollection.CollectionMutator<E> {\n+\n         /**\n          * <p>\n          * Called when a Set is added to the CompositeSet and there is a\n          * @param added the Set being added to the composite\n          * @param intersects the intersection of th existing and added sets\n          */\n-        public void resolveCollision(CompositeSet comp, Set existing, Set added, Collection intersects);\n+        public void resolveCollision(CompositeSet<E> comp, Set<E> existing, Set<E> added, Collection<E> intersects);\n     }\n }\n--- a/src/java/org/apache/commons/collections/set/MapBackedSet.java\n+++ b/src/java/org/apache/commons/collections/set/MapBackedSet.java\n  *\n  * @author Stephen Colebourne\n  */\n-public final class MapBackedSet implements Set, Serializable {\n+public final class MapBackedSet<E, V> implements Set<E>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 6723912213766056587L;\n \n     /** The map being used as the backing store */\n-    protected final Map map;\n+    protected final Map<E, ? super V> map;\n+\n     /** The dummyValue to use */\n-    protected final Object dummyValue;\n+    protected final V dummyValue;\n \n     /**\n      * Factory method to create a set from a map.\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static Set decorate(Map map) {\n+    public static <E, V> Set<E> decorate(Map<E, ? super V> map) {\n         return decorate(map, null);\n     }\n \n      * @param dummyValue  the dummy value to use\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static Set decorate(Map map, Object dummyValue) {\n+    public static <E, V> Set<E> decorate(Map<E, ? super V> map, V dummyValue) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"The map must not be null\");\n         }\n-        return new MapBackedSet(map, dummyValue);\n+        return new MapBackedSet<E, V>(map, dummyValue);\n     }\n \n     //-----------------------------------------------------------------------\n      * @param dummyValue  the dummy value to use\n      * @throws IllegalArgumentException if map is null\n      */\n-    private MapBackedSet(Map map, Object dummyValue) {\n+    private MapBackedSet(Map<E, ? super V> map, V dummyValue) {\n         super();\n         this.map = map;\n         this.dummyValue = dummyValue;\n         return map.isEmpty();\n     }\n \n-    public Iterator iterator() {\n+    public Iterator<E> iterator() {\n         return map.keySet().iterator();\n     }\n \n         return map.containsKey(obj);\n     }\n \n-    public boolean containsAll(Collection coll) {\n+    public boolean containsAll(Collection<?> coll) {\n         return map.keySet().containsAll(coll);\n     }\n \n-    public boolean add(Object obj) {\n+    public boolean add(E obj) {\n         int size = map.size();\n         map.put(obj, dummyValue);\n         return (map.size() != size);\n     }\n \n-    public boolean addAll(Collection coll) {\n+    public boolean addAll(Collection<? extends E> coll) {\n         int size = map.size();\n-        for (Iterator it = coll.iterator(); it.hasNext();) {\n-            Object obj = it.next();\n-            map.put(obj, dummyValue);\n+        for (E e : coll) {\n+            map.put(e, dummyValue);\n         }\n         return (map.size() != size);\n     }\n         return (map.size() != size);\n     }\n \n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         return map.keySet().removeAll(coll);\n     }\n \n-    public boolean retainAll(Collection coll) {\n+    public boolean retainAll(Collection<?> coll) {\n         return map.keySet().retainAll(coll);\n     }\n \n         return map.keySet().toArray();\n     }\n \n-    public Object[] toArray(Object[] array) {\n+    public <T> T[] toArray(T[] array) {\n         return map.keySet().toArray(array);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/TransformedSet.java\n+++ b/src/java/org/apache/commons/collections/set/TransformedSet.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedSet extends TransformedCollection implements Set {\n+public class TransformedSet<E> extends TransformedCollection<E> implements Set<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 306127383500410386L;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static Set decorate(Set set, Transformer transformer) {\n-        return new TransformedSet(set, transformer);\n+    public static <E> Set<E> decorate(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSet<E>(set, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if set or transformer is null\n      * @since Commons Collections 3.3\n      */\n+    // TODO: Generics\n     public static Set decorateTransform(Set set, Transformer transformer) {\n         TransformedSet decorated = new TransformedSet(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             Object[] values = set.toArray();\n             set.clear();\n             for(int i=0; i<values.length; i++) {\n-                decorated.getCollection().add(transformer.transform(values[i]));\n+                decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n         return decorated;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    protected TransformedSet(Set set, Transformer transformer) {\n+    protected TransformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n         super(set, transformer);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/TransformedSortedSet.java\n+++ b/src/java/org/apache/commons/collections/set/TransformedSortedSet.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedSortedSet extends TransformedSet implements SortedSet {\n+public class TransformedSortedSet<E> extends TransformedSet<E> implements SortedSet<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -1675486811351124386L;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static SortedSet decorate(SortedSet set, Transformer transformer) {\n-        return new TransformedSortedSet(set, transformer);\n+    public static <E> SortedSet<E> decorate(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSortedSet<E>(set, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException if set or transformer is null\n      * @since Commons Collections 3.3\n      */\n+     // TODO: Generics\n     public static SortedSet decorateTransform(SortedSet set, Transformer transformer) {\n         TransformedSortedSet decorated = new TransformedSortedSet(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             Object[] values = set.toArray();\n             set.clear();\n             for(int i=0; i<values.length; i++) {\n-                decorated.getCollection().add(transformer.transform(values[i]));\n+                decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n         return decorated;\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    protected TransformedSortedSet(SortedSet set, Transformer transformer) {\n+    protected TransformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n         super(set, transformer);\n     }\n \n      * \n      * @return the decorated set\n      */\n-    protected SortedSet getSortedSet() {\n-        return (SortedSet) collection;\n+    protected SortedSet<E> getSortedSet() {\n+        return (SortedSet<E>) collection;\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object first() {\n+    public E first() {\n         return getSortedSet().first();\n     }\n \n-    public Object last() {\n+    public E last() {\n         return getSortedSet().last();\n     }\n \n-    public Comparator comparator() {\n+    public Comparator<? super E> comparator() {\n         return getSortedSet().comparator();\n     }\n \n     //-----------------------------------------------------------------------\n-    public SortedSet subSet(Object fromElement, Object toElement) {\n-        SortedSet set = getSortedSet().subSet(fromElement, toElement);\n-        return new TransformedSortedSet(set, transformer);\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n     }\n \n-    public SortedSet headSet(Object toElement) {\n-        SortedSet set = getSortedSet().headSet(toElement);\n-        return new TransformedSortedSet(set, transformer);\n+    public SortedSet<E> headSet(E toElement) {\n+        SortedSet<E> set = getSortedSet().headSet(toElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n     }\n \n-    public SortedSet tailSet(Object fromElement) {\n-        SortedSet set = getSortedSet().tailSet(fromElement);\n-        return new TransformedSortedSet(set, transformer);\n+    public SortedSet<E> tailSet(E fromElement) {\n+        SortedSet<E> set = getSortedSet().tailSet(fromElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/AbstractTestObject.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestObject.java\n         Object o = makeObject();\n         if (o instanceof Serializable && isTestSerialization()) {\n             byte[] objekt = writeExternalFormToBytes((Serializable) o);\n-            Object p = readExternalFormFromBytes(objekt);\n+            readExternalFormFromBytes(objekt);\n         }\n     }\n \n--- a/src/test/org/apache/commons/collections/BulkTest.java\n+++ b/src/test/org/apache/commons/collections/BulkTest.java\n      *  @return  a {@link TestSuite} containing all the simple and bulk tests\n      *    defined by that class\n      */\n-    public static TestSuite makeSuite(Class c) {\n+    public static TestSuite makeSuite(Class<? extends BulkTest> c) {\n         if (Modifier.isAbstract(c.getModifiers())) {\n             throw new IllegalArgumentException(\"Class must not be abstract.\");\n         }\n class BulkTestSuiteMaker {\n \n     /** The class that defines simple and bulk tests methods. */\n-    private Class startingClass;\n+    private Class<? extends BulkTest> startingClass;\n \n     /** List of ignored simple test names. */\n-    private List ignored;\n+    private List<String> ignored;\n    \n     /** The TestSuite we're currently populating.  Can change over time. */\n     private TestSuite result;\n      *\n      *  @param startingClass  the starting class\n      */     \n-    public BulkTestSuiteMaker(Class startingClass) {\n+    public BulkTestSuiteMaker(Class<? extends BulkTest> startingClass) {\n         this.startingClass = startingClass;\n     }\n \n          result.setName(prefix);\n \n          BulkTest bulk = makeFirstTestCase(startingClass);\n-         ignored = new ArrayList();\n+         ignored = new ArrayList<String>();\n          String[] s = bulk.ignoredTests();\n          if (s != null) {\n              ignored.addAll(Arrays.asList(s));\n      *    tests for us to append\n      */\n     void make(BulkTest bulk) {\n-        Class c = bulk.getClass();\n+        Class<? extends BulkTest> c = bulk.getClass();\n         Method[] all = c.getMethods();\n         for (int i = 0; i < all.length; i++) {\n             if (isTest(all[i])) addTest(bulk, all[i]);\n      *  @param c  the class\n      *  @return the name of that class, minus any package names\n      */\n-    private static String getBaseName(Class c) {\n+    private static String getBaseName(Class<?> c) {\n         String name = c.getName();\n         int p = name.lastIndexOf('.');\n         if (p > 0) {\n     // These three methods are used to create a valid BulkTest instance\n     // from a class.\n \n-    private static Constructor getTestCaseConstructor(Class c) {\n+    private static <T> Constructor<T> getTestCaseConstructor(Class<T> c) {\n         try {\n             return c.getConstructor(new Class[] { String.class });\n         } catch (NoSuchMethodException e) {\n         }\n     }\n \n-    private static BulkTest makeTestCase(Class c, Method m) {\n-        Constructor con = getTestCaseConstructor(c);\n+    private static <T extends BulkTest> BulkTest makeTestCase(Class<T> c, Method m) {\n+        Constructor<T> con = getTestCaseConstructor(c);\n         try {\n-            return (BulkTest)con.newInstance(new Object[] {m.getName()});\n+            return (BulkTest) con.newInstance(new Object[] { m.getName() });\n         } catch (InvocationTargetException e) {\n             e.printStackTrace();\n             throw new RuntimeException(); // FIXME;\n         }\n     }\n \n-    private static BulkTest makeFirstTestCase(Class c) {\n+    private static <T extends BulkTest> BulkTest makeFirstTestCase(Class<T> c) {\n         Method[] all = c.getMethods();\n         for (int i = 0; i < all.length; i++) {\n             if (isTest(all[i])) return makeTestCase(c, all[i]);\n--- a/src/test/org/apache/commons/collections/LocalTestNode.java\n+++ b/src/test/org/apache/commons/collections/LocalTestNode.java\n  *\n  * @author Marc Johnson (marcj at users dot sourceforge dot net)\n  */\n-class LocalTestNode implements Comparable {\n+class LocalTestNode<K extends Comparable<K>, V extends Comparable<V>> implements Comparable<LocalTestNode<K, V>> {\n \n-    private Comparable key;\n-    private Comparable value;\n+    private K key;\n+    private V value;\n+\n+    static LocalTestNode<Integer, String> createLocalTestNode(final int key) {\n+        return new LocalTestNode<Integer, String>(key, String.valueOf(key));\n+    }\n \n     /**\n      * construct a LocalTestNode\n      *\n      * @param key value used to create the key and value\n      */\n-    LocalTestNode(final int key) {\n-        this.key   = new Integer(key);\n-        this.value = String.valueOf(key);\n+    private LocalTestNode(K key, V value) {\n+        this.key = key;\n+        this.value = value;\n     }\n \n     /**\n      * @param key the unique key associated with the current node.\n      */\n-    void setKey(Comparable key) {\n+    void setKey(K key) {\n         this.key = key;\n     }\n \n     /**\n      * @return the unique key associated with the current node\n      */\n-    Comparable getKey() {\n+    K getKey() {\n         return key;\n     }\n \n     /**\n      * @param value the unique value associated with the current node.\n      */\n-    void setValue(Comparable value) {\n+    void setValue(V value) {\n         this.value = value;\n     }\n \n     /**\n      * @return the unique value associated with the current node\n      */\n-    Comparable getValue() {\n+    V getValue() {\n         return value;\n     }\n \n      * @return a negative integer, zero, or a positive integer\n      *  as this object is less than, equal to, or greater than the specified object.\n      */\n-    public int compareTo(Object o) {\n+    public int compareTo(LocalTestNode<K, V> other) {\n \n-        LocalTestNode other = (LocalTestNode) o;\n-        int           rval  = getKey().compareTo(other.getKey());\n+        int rval = getKey().compareTo(other.getKey());\n \n         if (rval == 0) {\n             rval = getValue().compareTo(other.getValue());\n      *\n      * @return true if equal\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object o) {\n \n         if (o == null) {\n--- a/src/test/org/apache/commons/collections/TestArrayList.java\n+++ b/src/test/org/apache/commons/collections/TestArrayList.java\n  *\n  * @author Jason van Zyl\n  */\n-public abstract class TestArrayList extends AbstractTestList {\n-    \n-    protected ArrayList list = null;\n-    \n+public abstract class TestArrayList<E> extends AbstractTestList<E> {\n+\n     public TestArrayList(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public void setUp() {\n-        list = (ArrayList) makeEmptyList();\n-    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract ArrayList<E> makeObject();\n \n     //-----------------------------------------------------------------------\n     public void testNewArrayList() {\n+        ArrayList<E> list = makeObject();\n         assertTrue(\"New list is empty\", list.isEmpty());\n         assertEquals(\"New list has size zero\", 0, list.size());\n \n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSearch() {\n-        list.add(\"First Item\");\n-        list.add(\"Last Item\");\n+        ArrayList<E> list = makeObject();\n+        list.add((E) \"First Item\");\n+        list.add((E) \"Last Item\");\n         assertEquals(\"First item is 'First Item'\", \"First Item\", list.get(0));\n         assertEquals(\"Last Item is 'Last Item'\", \"Last Item\", list.get(1));\n     }\n--- a/src/test/org/apache/commons/collections/TestArrayStack.java\n+++ b/src/test/org/apache/commons/collections/TestArrayStack.java\n package org.apache.commons.collections;\n \n import java.util.EmptyStackException;\n-import java.util.List;\n \n import junit.framework.Test;\n \n  *\n  * @author Craig McClanahan\n  */\n-public class TestArrayStack extends TestArrayList {\n+public class TestArrayStack<E> extends TestArrayList<E> {\n     \n-    protected ArrayStack stack = null;\n-\n     public TestArrayStack(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public List makeEmptyList() {\n-        return new ArrayStack();\n-    }\n-\n-    public void setUp() {\n-        stack = (ArrayStack) makeEmptyList();\n-        list = stack;\n+    public ArrayStack<E> makeObject() {\n+        return new ArrayStack<E>();\n     }\n \n     //-----------------------------------------------------------------------\n     public void testNewStack() {\n-\n+        ArrayStack<E> stack = makeObject();\n         assertTrue(\"New stack is empty\", stack.empty());\n         assertEquals(\"New stack has size zero\", 0, stack.size());\n \n \n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testPushPeekPop() {\n+        ArrayStack<E> stack = makeObject();\n \n-        stack.push(\"First Item\");\n+        stack.push((E) \"First Item\");\n         assertTrue(\"Stack is not empty\", !stack.empty());\n         assertEquals(\"Stack size is one\", 1, stack.size());\n         assertEquals(\"Top item is 'First Item'\",\n                      \"First Item\", (String) stack.peek());\n         assertEquals(\"Stack size is one\", 1, stack.size());\n \n-        stack.push(\"Second Item\");\n+        stack.push((E) \"Second Item\");\n         assertEquals(\"Stack size is two\", 2, stack.size());\n         assertEquals(\"Top item is 'Second Item'\",\n                      \"Second Item\", (String) stack.peek());\n \n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSearch() {\n+        ArrayStack<E> stack = makeObject();\n \n-        stack.push(\"First Item\");\n-        stack.push(\"Second Item\");\n+        stack.push((E) \"First Item\");\n+        stack.push((E) \"Second Item\");\n         assertEquals(\"Top item is 'Second Item'\",\n                      1, stack.search(\"Second Item\"));\n         assertEquals(\"Next Item is 'First Item'\",\n--- a/src/test/org/apache/commons/collections/TestBufferUtils.java\n+++ b/src/test/org/apache/commons/collections/TestBufferUtils.java\n     }\n \n     public void testpredicatedBuffer() {\n-        Predicate predicate = new Predicate() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n             public boolean evaluate(Object o) {\n                 return o instanceof String;\n             }\n         };\n-        Buffer buffer = BufferUtils.predicatedBuffer(new ArrayStack(), predicate);\n+        Buffer<Object> buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), predicate);\n         assertTrue(\"returned object should be a PredicatedBuffer\",\n             buffer instanceof PredicatedBuffer);\n         try {\n-            buffer = BufferUtils.predicatedBuffer(new ArrayStack(), null);\n+            buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n--- a/src/test/org/apache/commons/collections/TestEnumerationUtils.java\n+++ b/src/test/org/apache/commons/collections/TestEnumerationUtils.java\n     public static final String TO_LIST_FIXTURE = \"this is a test\";\n     \n     public void testToListWithStringTokenizer() {\n-        List expectedList1 = new ArrayList();\n+        List<String> expectedList1 = new ArrayList<String>();\n         StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n              while (st.hasMoreTokens()) {\n                  expectedList1.add(st.nextToken());\n-             }        \n-        List expectedList2 = new ArrayList();\n+             }\n+        List<String> expectedList2 = new ArrayList<String>();\n         expectedList2.add(\"this\");\n         expectedList2.add(\"is\");\n         expectedList2.add(\"a\");\n         expectedList2.add(\"test\");\n-        List actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n+        List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n         Assert.assertEquals(expectedList1, expectedList2);\n         Assert.assertEquals(expectedList1, actualList);\n         Assert.assertEquals(expectedList2, actualList);\n     }\n \n     public void testToListWithHashtable() {\n-        Hashtable expected = new Hashtable();\n+        Hashtable<String, Integer> expected = new Hashtable<String, Integer>();\n         expected.put(\"one\", new Integer(1));\n         expected.put(\"two\", new Integer(2));\n         expected.put(\"three\", new Integer(3));\n         // validate elements.\n-        List actualEltList = EnumerationUtils.toList(expected.elements());\n+        List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n         Assert.assertEquals(expected.size(), actualEltList.size());\n         Assert.assertTrue(actualEltList.contains(new Integer(1)));\n         Assert.assertTrue(actualEltList.contains(new Integer(2)));\n         Assert.assertTrue(actualEltList.contains(new Integer(3)));\n-        List expectedEltList = new ArrayList();\n+        List<Integer> expectedEltList = new ArrayList<Integer>();\n         expectedEltList.add(new Integer(1));\n         expectedEltList.add(new Integer(2));\n         expectedEltList.add(new Integer(3));\n         Assert.assertTrue(actualEltList.containsAll(expectedEltList));\n \n         // validate keys.\n-        List actualKeyList = EnumerationUtils.toList(expected.keys());\n+        List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n         Assert.assertEquals(expected.size(), actualEltList.size());\n         Assert.assertTrue(actualKeyList.contains(\"one\"));\n         Assert.assertTrue(actualKeyList.contains(\"two\"));\n         Assert.assertTrue(actualKeyList.contains(\"three\"));\n-        List expectedKeyList = new ArrayList();\n+        List<String> expectedKeyList = new ArrayList<String>();\n         expectedKeyList.add(\"one\");\n         expectedKeyList.add(\"two\");\n         expectedKeyList.add(\"three\");\n--- a/src/test/org/apache/commons/collections/TestLinkedList.java\n+++ b/src/test/org/apache/commons/collections/TestLinkedList.java\n  *\n  * @author Rich Dougherty\n  */\n-public abstract class TestLinkedList extends AbstractTestList {\n+public abstract class TestLinkedList<T> extends AbstractTestList<T> {\n \n     public TestLinkedList(String testName) {\n         super(testName);\n     }\n \n-    public List makeEmptyList() {\n-        return makeEmptyLinkedList();\n-    }\n-\n-    public List makeFullList() {\n-        return makeFullLinkedList();\n-    }\n-\n-    /**\n-     *  Return a new, empty {@link LinkedList} to be used for testing.\n-     *\n-     *  @return an empty list for testing.\n-     */\n-    protected abstract LinkedList makeEmptyLinkedList();\n-\n-    /**\n-     *  Return a new, full {@link List} to be used for testing.\n-     *\n-     *  @return a full list for testing\n-     */\n-    protected LinkedList makeFullLinkedList() {\n-        // only works if list supports optional \"addAll(Collection)\" \n-        LinkedList list = makeEmptyLinkedList();\n-        list.addAll(Arrays.asList(getFullElements()));\n-        return list;\n-    }\n+    public abstract LinkedList<T> makeObject();\n \n     /**\n      *  Returns the {@link #collection} field cast to a {@link LinkedList}.\n      *\n      *  @return the collection field as a List\n      */\n-    protected LinkedList getLinkedList() {\n-        return (LinkedList)collection;\n+    public LinkedList<T> getCollection() {\n+        return (LinkedList<T>) super.getCollection();\n     }\n \n     /**\n      *\n      *  @return the confirmed field as a List\n      */\n-    protected LinkedList getConfirmedLinkedList() {\n-        return (LinkedList)confirmed;\n+    protected LinkedList<T> getConfirmedLinkedList() {\n+        return (LinkedList<T>) getConfirmed();\n     }\n \n     /**\n      *  Tests {@link LinkedList#addFirst(Object)}.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testLinkedListAddFirst() {\n         if (!isAddSupported()) return;\n-        Object o = \"hello\";\n-\n-        resetEmpty();\n-        getLinkedList().addFirst(o);\n+        T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addFirst(o);\n         getConfirmedLinkedList().addFirst(o);\n         verify();\n \n         resetFull();\n-        getLinkedList().addFirst(o);\n+        getCollection().addFirst(o);\n         getConfirmedLinkedList().addFirst(o);\n         verify();\n     }\n     /**\n      *  Tests {@link LinkedList#addLast(Object)}.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testLinkedListAddLast() {\n         if (!isAddSupported()) return;\n-        Object o = \"hello\";\n-\n-        resetEmpty();\n-        getLinkedList().addLast(o);\n+        T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addLast(o);\n         getConfirmedLinkedList().addLast(o);\n         verify();\n \n         resetFull();\n-        getLinkedList().addLast(o);\n+        getCollection().addLast(o);\n         getConfirmedLinkedList().addLast(o);\n         verify();\n     }\n     public void testLinkedListGetFirst() {\n         resetEmpty();\n         try {\n-            getLinkedList().getFirst();\n+            getCollection().getFirst();\n             fail(\"getFirst() should throw a NoSuchElementException for an \" +\n                     \"empty list.\");\n         } catch (NoSuchElementException e) {\n         verify();\n \n         resetFull();\n-        Object first = getLinkedList().getFirst();\n+        Object first = getCollection().getFirst();\n         Object confirmedFirst = getConfirmedLinkedList().getFirst();\n         assertEquals(\"Result returned by getFirst() was wrong.\",\n                 confirmedFirst, first);\n     public void testLinkedListGetLast() {\n         resetEmpty();\n         try {\n-            getLinkedList().getLast();\n+            getCollection().getLast();\n             fail(\"getLast() should throw a NoSuchElementException for an \" +\n                     \"empty list.\");\n         } catch (NoSuchElementException e) {\n         verify();\n         \n         resetFull();\n-        Object last = getLinkedList().getLast();\n+        Object last = getCollection().getLast();\n         Object confirmedLast = getConfirmedLinkedList().getLast();\n         assertEquals(\"Result returned by getLast() was wrong.\",\n                 confirmedLast, last);\n \n         resetEmpty();\n         try {\n-            getLinkedList().removeFirst();\n+            getCollection().removeFirst();\n             fail(\"removeFirst() should throw a NoSuchElementException for \" +\n                     \"an empty list.\");\n         } catch (NoSuchElementException e) {\n         verify();\n         \n         resetFull();\n-        Object first = getLinkedList().removeFirst();\n+        Object first = getCollection().removeFirst();\n         Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n         assertEquals(\"Result returned by removeFirst() was wrong.\",\n                 confirmedFirst, first);\n \n         resetEmpty();\n         try {\n-            getLinkedList().removeLast();\n+            getCollection().removeLast();\n             fail(\"removeLast() should throw a NoSuchElementException for \" +\n                     \"an empty list.\");\n         } catch (NoSuchElementException e) {\n         verify();\n \n         resetFull();\n-        Object last = getLinkedList().removeLast();\n+        Object last = getCollection().removeLast();\n         Object confirmedLast = getConfirmedLinkedList().removeLast();\n         assertEquals(\"Result returned by removeLast() was wrong.\",\n                 confirmedLast, last);\n     /**\n      *  Returns an empty {@link LinkedList}.\n      */\n-    public Collection makeConfirmedCollection() {\n-        return new LinkedList();\n+    public Collection<T> makeConfirmedCollection() {\n+        return new LinkedList<T>();\n     }\n \n     /**\n      *  Returns a full {@link LinkedList}.\n      */\n-    public Collection makeConfirmedFullCollection() {\n-        List list = new LinkedList();\n+    public Collection<T> makeConfirmedFullCollection() {\n+        List<T> list = new LinkedList<T>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/org/apache/commons/collections/TestSetUtils.java\n+++ b/src/test/org/apache/commons/collections/TestSetUtils.java\n \n     public void testNothing() {\n     }\n-    \n+\n     public void testpredicatedSet() {\n-        Predicate predicate = new Predicate() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n             public boolean evaluate(Object o) {\n                 return o instanceof String;\n             }\n         };\n-        Set set = SetUtils.predicatedSet(new HashSet(), predicate);\n-        assertTrue(\"returned object should be a PredicatedSet\",\n-            set instanceof PredicatedSet);\n+        Set<Object> set = SetUtils.predicatedSet(new HashSet<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedSet\", set instanceof PredicatedSet);\n         try {\n-            set = SetUtils.predicatedSet(new HashSet(), null);\n+            set = SetUtils.predicatedSet(new HashSet<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n     }\n \n     public void testEquals() {\n-        Collection data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n-        \n-        Set a = new HashSet( data );\n-        Set b = new HashSet( data );\n-        \n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        Set<String> a = new HashSet<String>(data);\n+        Set<String> b = new HashSet<String>(data);\n+\n         assertEquals(true, a.equals(b));\n         assertEquals(true, SetUtils.isEqualSet(a, b));\n         a.clear();\n         assertEquals(false, SetUtils.isEqualSet(null, b));\n         assertEquals(true, SetUtils.isEqualSet(null, null));\n     }\n-    \n+\n     public void testHashCode() {\n-        Collection data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n-            \n-        Set a = new HashSet( data );\n-        Set b = new HashSet( data );\n-        \n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        Set<String> a = new HashSet<String>(data);\n+        Set<String> b = new HashSet<String>(data);\n+\n         assertEquals(true, a.hashCode() == b.hashCode());\n         assertEquals(true, a.hashCode() == SetUtils.hashCodeForSet(a));\n         assertEquals(true, b.hashCode() == SetUtils.hashCodeForSet(b));\n         a.clear();\n         assertEquals(false, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n         assertEquals(0, SetUtils.hashCodeForSet(null));\n-    }   \n+    }\n \n }\n--- a/src/test/org/apache/commons/collections/TestTreeMap.java\n+++ b/src/test/org/apache/commons/collections/TestTreeMap.java\n  *\n  * @author Jason van Zyl\n  */\n-public abstract class TestTreeMap extends AbstractTestMap {\n-    \n+public abstract class TestTreeMap<K, V> extends AbstractTestMap<K, V> {\n+\n     public TestTreeMap(String testName) {\n         super(testName);\n     }\n         return false;\n     }\n \n-    protected TreeMap map = null;\n-\n-    public void setUp() {\n-        map = (TreeMap) makeEmptyMap();\n-    }\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract TreeMap<K, V> makeObject();\n \n     public void testNewMap() {\n+        TreeMap<K, V> map = makeObject();\n         assertTrue(\"New map is empty\", map.isEmpty());\n         assertEquals(\"New map has size zero\", 0, map.size());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSearch() {\n-        map.put(\"first\", \"First Item\");\n-        map.put(\"second\", \"Second Item\");\n+        TreeMap<K, V> map = makeObject();\n+        map.put((K) \"first\", (V) \"First Item\");\n+        map.put((K) \"second\", (V) \"Second Item\");\n         assertEquals(\"Top item is 'Second Item'\",\n             \"First Item\", map.get(\"first\"));\n         assertEquals(\"Next Item is 'First Item'\",\n             \"Second Item\", map.get(\"second\"));\n     }\n+\n }\n--- a/src/test/org/apache/commons/collections/TestTypedCollection.java\n+++ b/src/test/org/apache/commons/collections/TestTypedCollection.java\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class TestTypedCollection extends BulkTest {\n+public abstract class TestTypedCollection<T> extends BulkTest {\n \n     public TestTypedCollection(String name) {\n         super(name);\n     }\n \n+    protected abstract Collection<T> typedCollection();\n \n-    protected abstract Collection typedCollection();\n-\n-    protected Class getType() {\n-        return String.class;\n+    @SuppressWarnings(\"unchecked\")\n+    protected Class<T> getType() {\n+        return (Class<T>) String.class;\n     }\n \n-\n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Collection c = typedCollection();\n+        Collection<T> c = typedCollection();\n         Integer i = new Integer(3);\n         try {\n-            c.add(i);\n+            c.add((T) i);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n     }\n \n \n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        Collection c = typedCollection();\n-        List elements = new ArrayList();\n+        Collection<T> c = typedCollection();\n+        List<Object> elements = new ArrayList<Object>();\n         elements.add(\"one\");\n         elements.add(\"two\");\n         elements.add(new Integer(3));\n         elements.add(\"four\");\n         try {\n-            c.addAll(elements);\n+            c.addAll((Collection<? extends T>) elements);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n--- a/src/test/org/apache/commons/collections/bag/AbstractTestSortedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/AbstractTestSortedBag.java\n  */\n package org.apache.commons.collections.bag;\n \n+import org.apache.commons.collections.SortedBag;\n+\n /**\n  * Abstract test class for\n  * {@link org.apache.commons.collections.SortedBag SortedBag}\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestSortedBag extends AbstractTestBag {\n+public abstract class AbstractTestSortedBag<T> extends AbstractTestBag<T> {\n \n     public AbstractTestSortedBag(String testName) {\n         super(testName);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBag<T> makeObject();\n+\n     // TODO: Add the SortedBag tests!\n }\n--- a/src/test/org/apache/commons/collections/bag/TestHashBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestHashBag.java\n  *\n  * @author Chuck Burdick\n  */\n-public class TestHashBag extends AbstractTestBag {\n+public class TestHashBag<T> extends AbstractTestBag<T> {\n     \n     public TestHashBag(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Bag makeBag() {\n-        return new HashBag();\n+    public Bag<T> makeObject() {\n+        return new HashBag<T>();\n     }\n     \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/bag/TestPredicatedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestPredicatedBag.java\n \n import org.apache.commons.collections.Bag;\n import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.PredicateUtils;\n+import org.apache.commons.collections.functors.TruePredicate;\n \n /**\n  * Extension of {@link AbstractTestBag} for exercising the {@link PredicatedBag}\n  *\n  * @author Phil Steitz\n  */\n-public class TestPredicatedBag extends AbstractTestBag {\n-    \n+public class TestPredicatedBag<T> extends AbstractTestBag<T> {\n+\n     public TestPredicatedBag(String testName) {\n         super(testName);\n     }\n         String[] testCaseName = { TestPredicatedBag.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n+\n     //--------------------------------------------------------------------------\n \n-    protected Predicate stringPredicate() {\n-        return new Predicate() {\n-            public boolean evaluate(Object o) {\n+    protected Predicate<T> stringPredicate() {\n+        return new Predicate<T>() {\n+            public boolean evaluate(T o) {\n                 return o instanceof String;\n             }\n         };\n-    }   \n-    \n-    protected Predicate truePredicate = PredicateUtils.truePredicate();\n-    \n-    protected Bag decorateBag(HashBag bag, Predicate predicate) {\n+    }\n+\n+    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n+\n+    protected Bag<T> decorateBag(HashBag<T> bag, Predicate<T> predicate) {\n         return PredicatedBag.decorate(bag, predicate);\n     }\n \n-    public Bag makeBag() {\n-        return decorateBag(new HashBag(), truePredicate);\n+    public Bag<T> makeObject() {\n+        return decorateBag(new HashBag<T>(), truePredicate);\n     }\n-    \n-    protected Bag makeTestBag() {\n-        return decorateBag(new HashBag(), stringPredicate());\n+\n+    protected Bag<T> makeTestBag() {\n+        return decorateBag(new HashBag<T>(), stringPredicate());\n     }\n-    \n+\n     //--------------------------------------------------------------------------\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testlegalAddRemove() {\n-        Bag bag = makeTestBag();\n+        Bag<T> bag = makeTestBag();\n         assertEquals(0, bag.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\"};\n+        T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n         for (int i = 0; i < els.length; i++) {\n             bag.add(els[i]);\n             assertEquals(i + 1, bag.size());\n             assertEquals(true, bag.contains(els[i]));\n         }\n-        Set set = ((PredicatedBag) bag).uniqueSet();\n+        Set<T> set = ((PredicatedBag<T>) bag).uniqueSet();\n         assertTrue(\"Unique set contains the first element\",set.contains(els[0]));\n-        assertEquals(true, bag.remove(els[0])); \n-        set = ((PredicatedBag) bag).uniqueSet();\n+        assertEquals(true, bag.remove(els[0]));\n+        set = ((PredicatedBag<T>) bag).uniqueSet();\n         assertTrue(\"Unique set now does not contain the first element\",\n-            !set.contains(els[0])); \n+            !set.contains(els[0]));\n     }\n- \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Bag bag = makeTestBag();\n+        Bag<T> bag = makeTestBag();\n         Integer i = new Integer(3);\n         try {\n-            bag.add(i);\n+            bag.add((T) i);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !bag.contains(i));   \n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !bag.contains(i));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalDecorate() {\n-        HashBag elements = new HashBag();\n+        HashBag<Object> elements = new HashBag<Object>();\n         elements.add(\"one\");\n         elements.add(\"two\");\n         elements.add(new Integer(3));\n         elements.add(\"four\");\n         try {\n-            Bag bag = decorateBag(elements, stringPredicate());\n+            decorateBag((HashBag<T>) elements, stringPredicate());\n             fail(\"Bag contains an element that should fail the predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n         try {\n-            Bag bag = decorateBag(new HashBag(), null);\n+            decorateBag(new HashBag<T>(), null);\n             fail(\"Expectiing IllegalArgumentException for null predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n-        }              \n+        }\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/bag/TestTransformedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestTransformedBag.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n /**\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedBag extends AbstractTestBag {\n-    \n+public class TestTransformedBag<T> extends AbstractTestBag<T> {\n+\n     public TestTransformedBag(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Bag makeBag() {\n-        return TransformedBag.decorate(new HashBag(), TestTransformedCollection.NOOP_TRANSFORMER);\n+    @SuppressWarnings(\"unchecked\")\n+    public Bag<T> makeObject() {\n+        return TransformedBag.decorate(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n-        Bag bag = TransformedBag.decorate(new HashBag(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        //T had better be Object!\n+        Bag<T> bag = TransformedBag.decorate(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n-            bag.add(els[i]);\n+            bag.add((T) els[i]);\n             assertEquals(i + 1, bag.size());\n             assertEquals(true, bag.contains(new Integer((String) els[i])));\n             assertEquals(false, bag.contains(els[i]));\n         }\n-        \n+\n         assertEquals(false, bag.remove(els[0]));\n         assertEquals(true, bag.remove(new Integer((String) els[0])));\n     }\n \n+    // TODO: Generics\n     public void testTransformedBag_decorateTransform() {\n         Bag originalBag = new HashBag();\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n--- a/src/test/org/apache/commons/collections/bag/TestTransformedSortedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestTransformedSortedBag.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.SortedBag;\n+import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n /**\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedSortedBag extends AbstractTestSortedBag {\n-    \n+public class TestTransformedSortedBag<T> extends AbstractTestSortedBag<T> {\n+\n     public TestTransformedSortedBag(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Bag makeBag() {\n-        return TransformedSortedBag.decorate(new TreeBag(), TestTransformedCollection.NOOP_TRANSFORMER);\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedBag<T> makeObject() {\n+        return TransformedSortedBag.decorate(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n-        Bag bag = TransformedSortedBag.decorate(new TreeBag(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        SortedBag<T> bag = TransformedSortedBag.decorate(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n-            bag.add(els[i]);\n+            bag.add((T) els[i]);\n             assertEquals(i + 1, bag.size());\n             assertEquals(true, bag.contains(new Integer((String) els[i])));\n         }\n-        \n+\n         assertEquals(true, bag.remove(new Integer((String) els[0])));\n-        \n+\n     }\n \n     public void testTransformedBag_decorateTransform() {\n--- a/src/test/org/apache/commons/collections/bag/TestTreeBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestTreeBag.java\n  *\n  * @author Chuck Burdick\n  */\n-public class TestTreeBag extends AbstractTestBag {\n-    \n-   public TestTreeBag(String testName) {\n-      super(testName);\n-   }\n+public class TestTreeBag<T> extends AbstractTestSortedBag<T> {\n \n-   public static Test suite() {\n-      return new TestSuite(TestTreeBag.class);\n-   }\n+    public TestTreeBag(String testName) {\n+        super(testName);\n+    }\n \n-   public static void main(String args[]) {\n-      String[] testCaseName = { TestTreeBag.class.getName() };\n-      junit.textui.TestRunner.main(testCaseName);\n-   }\n+    public static Test suite() {\n+        return new TestSuite(TestTreeBag.class);\n+    }\n \n-   public Bag makeBag() {\n-      return new TreeBag();\n-   }\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestTreeBag.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n \n-   public SortedBag setupBag() {\n-      SortedBag bag = (SortedBag)makeBag();\n-      bag.add(\"C\");\n-      bag.add(\"A\");\n-      bag.add(\"B\");\n-      bag.add(\"D\");\n-      return bag;\n-   }\n+    public SortedBag<T> makeObject() {\n+        return new TreeBag<T>();\n+    }\n \n-   public void testOrdering() {\n-      Bag bag = setupBag();\n-      assertEquals(\"Should get elements in correct order\",\n-                   \"A\", bag.toArray()[0]);\n-      assertEquals(\"Should get elements in correct order\",\n-                   \"B\", bag.toArray()[1]);\n-      assertEquals(\"Should get elements in correct order\",\n-                   \"C\", bag.toArray()[2]);\n-      assertEquals(\"Should get first key\",\n-                   \"A\", ((SortedBag)bag).first());\n-      assertEquals(\"Should get last key\",\n-                   \"D\", ((SortedBag)bag).last());\n-   }\n-\n+   // TODO: Generics (for example... is this even needed?)\n    public void testCollections265() {\n        Bag bag = new TreeBag();\n        try {\n        }\n    }\n    \n-   public String getCompatibilityVersion() {\n-       return \"3\";\n-   }\n-    \n-//   public void testCreate() throws Exception {\n-//       Bag bag = makeBag();\n-//       writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/TreeBag.emptyCollection.version3.obj\");\n-//       bag = makeBag();\n-//       bag.add(\"A\");\n-//       bag.add(\"A\");\n-//       bag.add(\"B\");\n-//       bag.add(\"B\");\n-//       bag.add(\"C\");\n-//       writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/TreeBag.fullCollection.version3.obj\");\n-//   }\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedBag<T> setupBag() {\n+        SortedBag<T> bag = makeObject();\n+        bag.add((T) \"C\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"D\");\n+        return bag;\n+    }\n+\n+    public void testOrdering() {\n+        Bag<T> bag = setupBag();\n+        assertEquals(\"Should get elements in correct order\", \"A\", bag.toArray()[0]);\n+        assertEquals(\"Should get elements in correct order\", \"B\", bag.toArray()[1]);\n+        assertEquals(\"Should get elements in correct order\", \"C\", bag.toArray()[2]);\n+        assertEquals(\"Should get first key\", \"A\", ((SortedBag<T>) bag).first());\n+        assertEquals(\"Should get last key\", \"D\", ((SortedBag<T>) bag).last());\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //   public void testCreate() throws Exception {\n+    //       Bag bag = makeBag();\n+    //       writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/TreeBag.emptyCollection.version3.obj\");\n+    //       bag = makeBag();\n+    //       bag.add(\"A\");\n+    //       bag.add(\"A\");\n+    //       bag.add(\"B\");\n+    //       bag.add(\"B\");\n+    //       bag.add(\"C\");\n+    //       writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/TreeBag.fullCollection.version3.obj\");\n+    //   }\n }\n--- a/src/test/org/apache/commons/collections/bidimap/AbstractTestOrderedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/AbstractTestOrderedBidiMap.java\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestOrderedBidiMap extends AbstractTestBidiMap {\n+public abstract class AbstractTestOrderedBidiMap<K, V> extends AbstractTestBidiMap<K, V> {\n \n     public AbstractTestOrderedBidiMap(String testName) {\n         super(testName);\n     //-----------------------------------------------------------------------\n     public void testFirstKey() {\n         resetEmpty();\n-        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        OrderedBidiMap<K, V> bidi = getMap();\n         try {\n             bidi.firstKey();\n             fail();\n         } catch (NoSuchElementException ex) {}\n-        \n-        resetFull();\n-        bidi = (OrderedBidiMap) map;\n-        Object confirmedFirst = confirmed.keySet().iterator().next();\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedFirst = confirmed.keySet().iterator().next();\n         assertEquals(confirmedFirst, bidi.firstKey());\n     }\n-    \n+\n     public void testLastKey() {\n         resetEmpty();\n-        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        OrderedBidiMap<K, V> bidi = getMap();\n         try {\n             bidi.lastKey();\n             fail();\n         } catch (NoSuchElementException ex) {}\n-        \n-        resetFull();\n-        bidi = (OrderedBidiMap) map;\n-        Object confirmedLast = null;\n-        for (Iterator it = confirmed.keySet().iterator(); it.hasNext();) {\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedLast = null;\n+        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n             confirmedLast = it.next();\n         }\n         assertEquals(confirmedLast, bidi.lastKey());\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     public void testNextKey() {\n         resetEmpty();\n-        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;\n         assertEquals(null, bidi.nextKey(getOtherKeys()[0]));\n         if (isAllowNullKey() == false) {\n             try {\n         } else {\n             assertEquals(null, bidi.nextKey(null));\n         }\n-        \n-        resetFull();\n-        bidi = (OrderedBidiMap) map;\n-        Iterator it = confirmed.keySet().iterator();\n-        Object confirmedLast = it.next();\n+\n+        resetFull();\n+        bidi = (OrderedBidiMap<K, V>) map;\n+        Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            Object confirmedObject = it.next();\n+            K confirmedObject = it.next();\n             assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n         assertEquals(null, bidi.nextKey(confirmedLast));\n-        \n+\n         if (isAllowNullKey() == false) {\n             try {\n                 bidi.nextKey(null);\n             assertEquals(null, bidi.nextKey(null));\n         }\n     }\n-    \n+\n     public void testPreviousKey() {\n         resetEmpty();\n-        OrderedBidiMap bidi = (OrderedBidiMap) map;\n+        OrderedBidiMap<K, V> bidi = getMap();\n         assertEquals(null, bidi.previousKey(getOtherKeys()[0]));\n         if (isAllowNullKey() == false) {\n             try {\n         } else {\n             assertEquals(null, bidi.previousKey(null));\n         }\n-        \n-        resetFull();\n-        bidi = (OrderedBidiMap) map;\n-        List list = new ArrayList(confirmed.keySet());\n+\n+        resetFull();\n+        bidi = getMap();\n+        List<K> list = new ArrayList<K>(confirmed.keySet());\n         Collections.reverse(list);\n-        Iterator it = list.iterator();\n-        Object confirmedLast = it.next();\n+        Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            Object confirmedObject = it.next();\n+            K confirmedObject = it.next();\n             assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n         assertEquals(null, bidi.previousKey(confirmedLast));\n-        \n+\n         if (isAllowNullKey() == false) {\n             try {\n                 bidi.previousKey(null);\n             assertEquals(null, bidi.previousKey(null));\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public BulkTest bulkTestOrderedMapIterator() {\n         return new TestBidiOrderedMapIterator();\n     }\n-    \n-    public class TestBidiOrderedMapIterator extends AbstractTestMapIterator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> getMap() {\n+        return (OrderedBidiMap<K, V>) super.getMap();\n+    }\n+\n+    public class TestBidiOrderedMapIterator extends AbstractTestMapIterator<K, V> {\n         public TestBidiOrderedMapIterator() {\n             super(\"TestBidiOrderedMapIterator\");\n         }\n-        \n-        public Object[] addSetValues() {\n+\n+        public V[] addSetValues() {\n             return AbstractTestOrderedBidiMap.this.getNewSampleValues();\n         }\n-        \n+\n         public boolean supportsRemove() {\n             return AbstractTestOrderedBidiMap.this.isRemoveSupported();\n         }\n             return AbstractTestOrderedBidiMap.this.isSetValueSupported();\n         }\n \n-        public MapIterator makeEmptyMapIterator() {\n+        public MapIterator<K, V> makeEmptyIterator() {\n             resetEmpty();\n-            return ((OrderedBidiMap) AbstractTestOrderedBidiMap.this.map).orderedMapIterator();\n-        }\n-\n-        public MapIterator makeFullMapIterator() {\n+            return AbstractTestOrderedBidiMap.this.getMap().mapIterator();\n+        }\n+\n+        public MapIterator<K, V> makeObject() {\n             resetFull();\n-            return ((OrderedBidiMap) AbstractTestOrderedBidiMap.this.map).orderedMapIterator();\n-        }\n-        \n-        public Map getMap() {\n+            return AbstractTestOrderedBidiMap.this.getMap().mapIterator();\n+        }\n+\n+        public Map<K, V> getMap() {\n             // assumes makeFullMapIterator() called first\n             return AbstractTestOrderedBidiMap.this.map;\n         }\n-        \n-        public Map getConfirmedMap() {\n+\n+        public Map<K, V> getConfirmedMap() {\n             // assumes makeFullMapIterator() called first\n             return AbstractTestOrderedBidiMap.this.confirmed;\n         }\n-        \n+\n         public void verify() {\n             super.verify();\n             AbstractTestOrderedBidiMap.this.verify();\n         }\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/bidimap/AbstractTestSortedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/AbstractTestSortedBidiMap.java\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestSortedBidiMap extends AbstractTestOrderedBidiMap {\n-\n-    protected List sortedKeys = new ArrayList();\n-    protected List sortedValues = new ArrayList();\n-    protected SortedSet sortedNewValues = new TreeSet();\n+public abstract class AbstractTestSortedBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestOrderedBidiMap<K, V> {\n+\n+    protected List<K> sortedKeys = new ArrayList<K>();\n+    protected List<V> sortedValues = new ArrayList<V>();\n+    protected SortedSet<V> sortedNewValues = new TreeSet<V>();\n \n     public AbstractTestSortedBidiMap(String testName) {\n         super(testName);\n         sortedKeys.addAll(Arrays.asList(getSampleKeys()));\n         Collections.sort(sortedKeys);\n         sortedKeys = Collections.unmodifiableList(sortedKeys);\n-        \n-        Map map = new TreeMap();\n-        for (int i = 0; i < getSampleKeys().length; i++) {\n-            map.put(getSampleKeys()[i], getSampleValues()[i]);\n-        }\n+\n+        Map<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+\n         sortedValues.addAll(map.values());\n         sortedValues = Collections.unmodifiableList(sortedValues);\n-        \n+\n         sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n     }\n \n-    public AbstractTestSortedBidiMap() {\n-        super();\n-        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n-        Collections.sort(sortedKeys);\n-        sortedKeys = Collections.unmodifiableList(sortedKeys);\n-        \n-        Map map = new TreeMap();\n-        for (int i = 0; i < getSampleKeys().length; i++) {\n-            map.put(getSampleValues()[i], getSampleKeys()[i]);\n-        }\n-        sortedValues.addAll(map.values());\n-        sortedValues = Collections.unmodifiableList(sortedValues);\n-        \n-        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n-    }\n+//    public AbstractTestSortedBidiMap() {\n+//        super();\n+//        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n+//        Collections.sort(sortedKeys);\n+//        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+//\n+//        Map map = new TreeMap();\n+//        for (int i = 0; i < getSampleKeys().length; i++) {\n+//            map.put(getSampleValues()[i], getSampleKeys()[i]);\n+//        }\n+//        sortedValues.addAll(map.values());\n+//        sortedValues = Collections.unmodifiableList(sortedValues);\n+//\n+//        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+//    }\n \n     //-----------------------------------------------------------------------\n     public boolean isAllowNullKey() {\n         return false;\n     }\n+\n     public boolean isAllowNullValue() {\n         return false;\n     }\n-    public Map makeConfirmedMap() {\n-        return new TreeMap();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBidiMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        return (SortedBidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n     }\n \n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     public void testBidiHeadMapContains() {\n         // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object toKey = it.next();\n-        Object second = it.next();\n-        Object firstValue = sm.get(first);\n-        Object secondValue = sm.get(second);\n-        \n-        SortedMap head = sm.headMap(toKey);\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K toKey = it.next();\n+        K second = it.next();\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> head = sm.headMap(toKey);\n         assertEquals(1, head.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, head.containsKey(first));\n         assertEquals(true, sm.containsValue(secondValue));\n         assertEquals(false, head.containsValue(secondValue));\n     }\n-                \n+\n     //-----------------------------------------------------------------------\n     public void testBidiClearByHeadMap() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        Object firstValue = sm.get(first);\n-        Object secondValue = sm.get(second);\n-        Object toKeyValue = sm.get(toKey);\n-        \n-        SortedMap sub = sm.headMap(toKey);\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+        V toKeyValue = sm.get(toKey);\n+\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n         int size = sm.size();\n         assertEquals(2, sub.size());\n         sub.clear();\n         assertEquals(0, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(size - 2, sm.inverseBidiMap().size());\n-        \n+\n         assertEquals(false, sm.containsKey(first));\n         assertEquals(false, sm.containsValue(firstValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(first));\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n-        \n+\n         assertEquals(false, sm.containsKey(second));\n         assertEquals(false, sm.containsValue(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(second));\n         assertEquals(false, sub.containsKey(second));\n         assertEquals(false, sub.containsValue(secondValue));\n-        \n+\n         assertEquals(true, sm.containsKey(toKey));\n         assertEquals(true, sm.containsValue(toKeyValue));\n         assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByHeadMap() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        int size = sm.size();\n-        SortedMap sub = sm.headMap(toKey);\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n         assertEquals(2, sub.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n-        \n-        Object firstValue = sub.remove(first);\n+\n+        V firstValue = sub.remove(first);\n         assertEquals(1, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(size - 1, sm.inverseBidiMap().size());\n         assertEquals(false, sm.inverseBidiMap().containsValue(first));\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n-        \n-        Object secondValue = sub.remove(second);\n+\n+        V secondValue = sub.remove(second);\n         assertEquals(0, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(size - 2, sm.inverseBidiMap().size());\n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByHeadMapEntrySet() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        int size = sm.size();\n-        SortedMap sub = sm.headMap(toKey);\n-        Set set = sub.entrySet();\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n         assertEquals(2, sub.size());\n         assertEquals(2, set.size());\n-        \n-        Iterator it2 = set.iterator();\n-        Map.Entry firstEntry = cloneMapEntry((Map.Entry) it2.next());\n-        Map.Entry secondEntry = cloneMapEntry((Map.Entry) it2.next());\n+\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, set.contains(firstEntry));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n         assertEquals(true, set.contains(secondEntry));\n-        \n+\n         set.remove(firstEntry);\n         assertEquals(1, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(false, sub.containsKey(firstEntry.getKey()));\n         assertEquals(false, sub.containsValue(firstEntry.getValue()));\n         assertEquals(false, set.contains(firstEntry));\n-        \n+\n         set.remove(secondEntry);\n         assertEquals(0, sub.size());\n         assertEquals(size - 2, sm.size());\n     //-----------------------------------------------------------------------\n     public void testBidiTailMapContains() {\n         // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object fromKey = it.next();\n-        Object second = it.next();\n-        Object firstValue = sm.get(first);\n-        Object fromKeyValue = sm.get(fromKey);\n-        Object secondValue = sm.get(second);\n-        \n-        SortedMap sub = sm.tailMap(fromKey);\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n         assertEquals(sm.size() - 1, sub.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(false, sub.containsKey(first));\n     //-----------------------------------------------------------------------\n     public void testBidiClearByTailMap() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object first = it.next();\n-        Object fromKey = it.next();\n-        Object second = it.next();\n-        \n-        Object firstValue = sm.get(first);\n-        Object fromKeyValue = sm.get(fromKey);\n-        Object secondValue = sm.get(second);\n-        \n-        SortedMap sub = sm.tailMap(fromKey);\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n         int size = sm.size();\n         assertEquals(size - 3, sub.size());\n         sub.clear();\n         assertEquals(0, sub.size());\n         assertEquals(3, sm.size());\n         assertEquals(3, sm.inverseBidiMap().size());\n-        \n+\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sm.containsValue(firstValue));\n         assertEquals(true, sm.inverseBidiMap().containsKey(firstValue));\n         assertEquals(true, sm.inverseBidiMap().containsValue(first));\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n-        \n+\n         assertEquals(false, sm.containsKey(fromKey));\n         assertEquals(false, sm.containsValue(fromKeyValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n         assertEquals(false, sub.containsKey(fromKey));\n         assertEquals(false, sub.containsValue(fromKeyValue));\n-        \n+\n         assertEquals(false, sm.containsKey(second));\n         assertEquals(false, sm.containsValue(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n         assertEquals(false, sub.containsValue(secondValue));\n     }\n \n-    //-----------------------------------------------------------------------                \n+    //-----------------------------------------------------------------------\n     public void testBidiRemoveByTailMap() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        \n-        int size = sm.size();\n-        SortedMap sub = sm.tailMap(fromKey);\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n-        \n+\n         Object firstValue = sub.remove(first);\n         assertEquals(size - 3, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(false, sm.inverseBidiMap().containsValue(first));\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n-        \n+\n         Object secondValue = sub.remove(second);\n         assertEquals(size - 4, sub.size());\n         assertEquals(size - 2, sm.size());\n     //-----------------------------------------------------------------------\n     public void testBidiRemoveByTailMapEntrySet() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        \n-        int size = sm.size();\n-        SortedMap sub = sm.tailMap(fromKey);\n-        Set set = sub.entrySet();\n-        Iterator it2 = set.iterator();\n-        Object fromEntry = it2.next();\n-        Map.Entry firstEntry = cloneMapEntry((Map.Entry) it2.next());\n-        Map.Entry secondEntry = cloneMapEntry((Map.Entry) it2.next());\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, set.contains(firstEntry));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n         assertEquals(true, set.contains(secondEntry));\n-        \n+\n         set.remove(firstEntry);\n         assertEquals(size - 3, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(false, sub.containsKey(firstEntry.getKey()));\n         assertEquals(false, sub.containsValue(firstEntry.getValue()));\n         assertEquals(false, set.contains(firstEntry));\n-        \n+\n         set.remove(secondEntry);\n         assertEquals(size - 4, sub.size());\n         assertEquals(size - 2, sm.size());\n     //-----------------------------------------------------------------------\n     public void testBidiSubMapContains() {\n         // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object fromKey = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        Object third = it.next();\n-        Object firstValue = sm.get(first);\n-        Object fromKeyValue = sm.get(fromKey);\n-        Object secondValue = sm.get(second);\n-        Object thirdValue = sm.get(third);\n-        \n-        SortedMap sub = sm.subMap(fromKey, toKey);\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+        K third = it.next();\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+        V thirdValue = sm.get(third);\n+\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n         assertEquals(2, sub.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(false, sub.containsKey(first));\n     //-----------------------------------------------------------------------\n     public void testBidiClearBySubMap() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        Object fromKeyValue = sm.get(fromKey);\n-        Object firstValue = sm.get(first);\n-        Object secondValue = sm.get(second);\n-        Object toKeyValue = sm.get(toKey);\n-        \n-        SortedMap sub = sm.subMap(fromKey, toKey);\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        V fromKeyValue = sm.get(fromKey);\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+        V toKeyValue = sm.get(toKey);\n+\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n         int size = sm.size();\n         assertEquals(3, sub.size());\n         sub.clear();\n         assertEquals(0, sub.size());\n         assertEquals(size - 3, sm.size());\n         assertEquals(size - 3, sm.inverseBidiMap().size());\n-        \n+\n         assertEquals(false, sm.containsKey(fromKey));\n         assertEquals(false, sm.containsValue(fromKeyValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n         assertEquals(false, sub.containsKey(fromKey));\n         assertEquals(false, sub.containsValue(fromKeyValue));\n-        \n+\n         assertEquals(false, sm.containsKey(first));\n         assertEquals(false, sm.containsValue(firstValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(first));\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n-        \n+\n         assertEquals(false, sm.containsKey(second));\n         assertEquals(false, sm.containsValue(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(second));\n         assertEquals(false, sub.containsKey(second));\n         assertEquals(false, sub.containsValue(secondValue));\n-        \n+\n         assertEquals(true, sm.containsKey(toKey));\n         assertEquals(true, sm.containsValue(toKeyValue));\n         assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n     //-----------------------------------------------------------------------\n     public void testBidiRemoveBySubMap() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        int size = sm.size();\n-        SortedMap sub = sm.subMap(fromKey, toKey);\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n-        \n-        Object firstValue = sub.remove(first);\n+\n+        V firstValue = sub.remove(first);\n         assertEquals(2, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(size - 1, sm.inverseBidiMap().size());\n         assertEquals(false, sm.inverseBidiMap().containsValue(first));\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n-        \n-        Object secondValue = sub.remove(second);\n+\n+        V secondValue = sub.remove(second);\n         assertEquals(1, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(size - 2, sm.inverseBidiMap().size());\n     //-----------------------------------------------------------------------\n     public void testBidiRemoveBySubMapEntrySet() {\n         if (isRemoveSupported() == false) return;\n-        \n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        int size = sm.size();\n-        SortedMap sub = sm.subMap(fromKey, toKey);\n-        Set set = sub.entrySet();\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n         assertEquals(3, set.size());\n-        Iterator it2 = set.iterator();\n-        Object fromEntry = it2.next();\n-        Map.Entry firstEntry = cloneMapEntry((Map.Entry) it2.next());\n-        Map.Entry secondEntry = cloneMapEntry((Map.Entry) it2.next());\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, set.contains(firstEntry));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n         assertEquals(true, set.contains(secondEntry));\n-        \n+\n         set.remove(firstEntry);\n         assertEquals(2, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(false, sub.containsKey(firstEntry.getKey()));\n         assertEquals(false, sub.containsValue(firstEntry.getValue()));\n         assertEquals(false, set.contains(firstEntry));\n-        \n+\n         set.remove(secondEntry);\n         assertEquals(1, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(false, set.contains(secondEntry));\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     public BulkTest bulkTestHeadMap() {\n-        return new AbstractTestSortedMap.TestHeadMap(this);\n+        return new AbstractTestSortedMap.TestHeadMap<K, V>(this);\n     }\n \n     public BulkTest bulkTestTailMap() {\n-        return new AbstractTestSortedMap.TestTailMap(this);\n+        return new AbstractTestSortedMap.TestTailMap<K, V>(this);\n     }\n \n     public BulkTest bulkTestSubMap() {\n-        return new AbstractTestSortedMap.TestSubMap(this);\n+        return new AbstractTestSortedMap.TestSubMap<K, V>(this);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/bidimap/TestAbstractOrderedBidiMapDecorator.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestAbstractOrderedBidiMapDecorator.java\n  */\n package org.apache.commons.collections.bidimap;\n \n-import java.util.Map;\n+import java.util.SortedMap;\n import java.util.TreeMap;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.BidiMap;\n import org.apache.commons.collections.OrderedBidiMap;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  */\n-public class TestAbstractOrderedBidiMapDecorator\n-        extends AbstractTestOrderedBidiMap {\n+public class TestAbstractOrderedBidiMapDecorator<K, V>\n+        extends AbstractTestOrderedBidiMap<K, V> {\n \n     public TestAbstractOrderedBidiMapDecorator(String testName) {\n         super(testName);\n         return new TestSuite(TestAbstractOrderedBidiMapDecorator.class);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return new TestOrderedBidiMap();\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return new TestOrderedBidiMap<K, V>();\n     }\n \n-    public Map makeConfirmedMap() {\n-        return new TreeMap();\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n     }\n \n     public boolean isAllowNullKey() {\n     /**\n      * Simple class to actually test.\n      */\n-    private static final class TestOrderedBidiMap extends AbstractOrderedBidiMapDecorator {\n-            \n-        private TestOrderedBidiMap inverse = null;\n+    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {\n+\n+        private TestOrderedBidiMap<V, K> inverse = null;\n \n         public TestOrderedBidiMap() {\n-            super(new DualTreeBidiMap());\n+            super(new DualTreeBidiMap<K, V>());\n         }\n-        \n-        public TestOrderedBidiMap(OrderedBidiMap map) {\n+\n+        public TestOrderedBidiMap(OrderedBidiMap<K, V> map) {\n             super(map);\n         }\n-        \n-        public BidiMap inverseBidiMap() {\n+\n+        public OrderedBidiMap<V, K> inverseBidiMap() {\n             if (inverse == null) {\n-                inverse = new TestOrderedBidiMap((OrderedBidiMap) getBidiMap().inverseBidiMap());\n+                inverse = new TestOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n                 inverse.inverse = this;\n             }\n             return inverse;\n--- a/src/test/org/apache/commons/collections/bidimap/TestDualHashBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestDualHashBidiMap.java\n import junit.framework.Test;\n import junit.textui.TestRunner;\n \n-import org.apache.commons.collections.BidiMap;\n import org.apache.commons.collections.BulkTest;\n \n /**\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public class TestDualHashBidiMap extends AbstractTestBidiMap {\n+public class TestDualHashBidiMap<K, V> extends AbstractTestBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n         super(testName);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return new DualHashBidiMap();\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualHashBidiMap<K, V> makeObject() {\n+        return new DualHashBidiMap<K, V>();\n     }\n \n     /**\n      * Override to prevent infinite recursion of tests.\n      */\n     public String[] ignoredTests() {\n-        return new String[] {\"TestDualHashBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+        return new String[] { \"TestDualHashBidiMap.bulkTestInverseMap.bulkTestInverseMap\" };\n     }\n     \n //    public void testCreate() throws Exception {\n--- a/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap.java\n import junit.framework.Test;\n import junit.textui.TestRunner;\n \n-import org.apache.commons.collections.BidiMap;\n import org.apache.commons.collections.BulkTest;\n \n /**\n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n  */\n-public class TestDualTreeBidiMap extends AbstractTestSortedBidiMap {\n+public class TestDualTreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestSortedBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n         super(testName);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return new DualTreeBidiMap();\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>();\n     }\n \n     /**\n--- a/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap2.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap2.java\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.TreeMap;\n \n import junit.framework.Test;\n import junit.textui.TestRunner;\n \n-import org.apache.commons.collections.BidiMap;\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.SortedBidiMap;\n import org.apache.commons.collections.comparators.ComparableComparator;\n  * @author Stephen Colebourne\n  * @author Jonas Van Poucke\n  */\n-public class TestDualTreeBidiMap2 extends AbstractTestSortedBidiMap {\n+public class TestDualTreeBidiMap2<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestSortedBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n         super(testName);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return new DualTreeBidiMap(new ReverseComparator(ComparableComparator.getInstance()));\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>(\n+                new ReverseComparator<K>(ComparableComparator.<K> getInstance()),\n+                new ReverseComparator<V>(ComparableComparator.<V> getInstance()));\n     }\n \n-    public Map makeConfirmedMap() {\n-        return new TreeMap(new ReverseComparator(ComparableComparator.getInstance()));\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new ReverseComparator<K>(ComparableComparator.<K>getInstance()));\n     }\n \n     public void testComparator() {\n         resetEmpty();\n-        SortedBidiMap bidi = (SortedBidiMap) map;\n+        SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n         assertNotNull(bidi.comparator());\n         assertTrue(bidi.comparator() instanceof ReverseComparator);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSerializeDeserializeCheckComparator() throws Exception {\n         SortedBidiMap obj = (SortedBidiMap) makeObject();\n         if (obj instanceof Serializable && isTestSerialization()) {\n     }\n \n     public void testSortOrder() throws Exception {\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        SortedBidiMap<K, V> sm = makeFullMap();\n \n         // Sort by the comparator used in the makeEmptyBidiMap() method\n-        List newSortedKeys = Arrays.asList(getSampleKeys());\n-        Collections.sort(newSortedKeys, new ReverseComparator(ComparableComparator.getInstance()));\n+        List<K> newSortedKeys = Arrays.asList(getSampleKeys());\n+        Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>getInstance()));\n         newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n \n-        Iterator mapIter = sm.keySet().iterator();\n-        Iterator expectedIter = newSortedKeys.iterator();\n+        Iterator<K> mapIter = sm.keySet().iterator();\n+        Iterator<K> expectedIter = newSortedKeys.iterator();\n         while (expectedIter.hasNext()) {\n-            Object expectedKey = expectedIter.next();\n-            Object mapKey = mapIter.next();\n+            K expectedKey = expectedIter.next();\n+            K mapKey = mapIter.next();\n             assertNotNull(\"key in sorted list may not be null\", expectedKey);\n             assertNotNull(\"key in map may not be null\", mapKey);\n             assertEquals(\"key from sorted list and map must be equal\", expectedKey, mapKey);\n--- a/src/test/org/apache/commons/collections/bidimap/TestTreeBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestTreeBidiMap.java\n  */\n package org.apache.commons.collections.bidimap;\n \n-import java.util.Map;\n import java.util.TreeMap;\n \n import junit.framework.Test;\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTreeBidiMap extends AbstractTestOrderedBidiMap {\n+public class TestTreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestOrderedBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n         super(testName);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return new TreeBidiMap();\n+    public BidiMap<K, V> makeObject() {\n+        return new TreeBidiMap<K, V>();\n     }\n     \n-    public Map makeConfirmedMap() {\n-        return new TreeMap();\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n     }\n \n     /**\n--- a/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableBidiMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableBidiMap extends AbstractTestBidiMap {\n+public class TestUnmodifiableBidiMap<K, V> extends AbstractTestBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestUnmodifiableBidiMap.class);\n     }\n         super(testName);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return UnmodifiableBidiMap.decorate(new DualHashBidiMap());\n+    public BidiMap<K, V> makeObject() {\n+        return UnmodifiableBidiMap.decorate(new DualHashBidiMap<K, V>());\n     }\n-    public BidiMap makeFullBidiMap() {\n-        BidiMap bidi = new DualHashBidiMap();\n-        for (int i = 0; i < entries.length; i++) {\n-            bidi.put(entries[i][0], entries[i][1]);\n-        }\n-        return UnmodifiableBidiMap.decorate(bidi);\n-    }\n-    public Map makeFullMap() {\n-        BidiMap bidi = new DualHashBidiMap();\n+\n+    public BidiMap<K, V> makeFullMap() {\n+        BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n         addSampleMappings(bidi);\n         return UnmodifiableBidiMap.decorate(bidi);\n     }\n-    \n-    public Map makeConfirmedMap() {\n-        return new HashMap();\n+\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n     }\n \n     /**\n     public boolean isPutAddSupported() {\n         return false;\n     }\n+\n     public boolean isPutChangeSupported() {\n         return false;\n     }\n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableOrderedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableOrderedBidiMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableOrderedBidiMap extends AbstractTestOrderedBidiMap {\n+public class TestUnmodifiableOrderedBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestOrderedBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestUnmodifiableOrderedBidiMap.class);\n     }\n         super(testName);\n     }\n \n-    public BidiMap makeEmptyBidiMap() {\n-        return UnmodifiableOrderedBidiMap.decorate(new TreeBidiMap());\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return UnmodifiableOrderedBidiMap.decorate(new TreeBidiMap<K, V>());\n     }\n-    public BidiMap makeFullBidiMap() {\n-        OrderedBidiMap bidi = new TreeBidiMap();\n-        for (int i = 0; i < entries.length; i++) {\n-            bidi.put(entries[i][0], entries[i][1]);\n-        }\n-        return UnmodifiableOrderedBidiMap.decorate(bidi);\n-    }\n-    public Map makeFullMap() {\n-        OrderedBidiMap bidi = new TreeBidiMap();\n+\n+    public BidiMap<K, V> makeFullMap() {\n+        OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n         addSampleMappings(bidi);\n         return UnmodifiableOrderedBidiMap.decorate(bidi);\n     }\n-    \n-    public Map makeConfirmedMap() {\n-        return new TreeMap();\n+\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n     }\n \n     /**\n     public String[] ignoredTests() {\n         return new String[] {\"TestUnmodifiableOrderedBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n     }\n-    \n+\n     public boolean isAllowNullKey() {\n         return false;\n     }\n+\n     public boolean isAllowNullValue() {\n         return false;\n     }\n+\n     public boolean isPutAddSupported() {\n         return false;\n     }\n+\n     public boolean isPutChangeSupported() {\n         return false;\n     }\n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableSortedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableSortedBidiMap.java\n  */\n package org.apache.commons.collections.bidimap;\n \n-import java.util.Map;\n+import java.util.SortedMap;\n import java.util.TreeMap;\n \n import junit.framework.Test;\n import junit.textui.TestRunner;\n \n-import org.apache.commons.collections.BidiMap;\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.SortedBidiMap;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableSortedBidiMap extends AbstractTestSortedBidiMap {\n+public class TestUnmodifiableSortedBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestSortedBidiMap<K, V> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestUnmodifiableSortedBidiMap.class);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    public BidiMap makeEmptyBidiMap() {\n-        return UnmodifiableSortedBidiMap.decorate(new DualTreeBidiMap());\n+    public SortedBidiMap<K, V> makeObject() {\n+        return UnmodifiableSortedBidiMap.decorate(new DualTreeBidiMap<K, V>());\n     }\n-    public BidiMap makeFullBidiMap() {\n-        SortedBidiMap bidi = new DualTreeBidiMap();\n-        for (int i = 0; i < entries.length; i++) {\n-            bidi.put(entries[i][0], entries[i][1]);\n-        }\n-        return UnmodifiableSortedBidiMap.decorate(bidi);\n-    }\n-    public Map makeFullMap() {\n-        SortedBidiMap bidi = new DualTreeBidiMap();\n+\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n         addSampleMappings(bidi);\n         return UnmodifiableSortedBidiMap.decorate(bidi);\n     }\n-    \n-    public Map makeConfirmedMap() {\n-        return new TreeMap();\n+\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n     }\n \n     public boolean isSubMapViewsSerializable() {\n         // TreeMap sub map views have a bug in deserialization.\n         return false;\n     }\n+\n     public String[] ignoredTests() {\n         // Override to prevent infinite recursion of tests.\n         return new String[] {\"TestUnmodifiableSortedBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n     public boolean isAllowNullKey() {\n         return false;\n     }\n+\n     public boolean isAllowNullValue() {\n         return false;\n     }\n+\n     public boolean isPutAddSupported() {\n         return false;\n     }\n+\n     public boolean isPutChangeSupported() {\n         return false;\n     }\n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n import java.util.Set;\n \n /**\n- * Extension of {@link AbstractTestObject} for exercising the {@link BlockingBuffer} implementation.\n+ * Extension of {@link AbstractTestObject} for exercising the\n+ * {@link BlockingBuffer} implementation.\n  *\n  * @author Janek Bogucki\n  * @author Phil Steitz\n  * @version $Revision$\n  * @since Commons Collections 3.0\n  */\n-public class TestBlockingBuffer extends AbstractTestObject {\n-\n-    public TestBlockingBuffer( String testName ) {\n-        super( testName );\n+public class TestBlockingBuffer<E> extends AbstractTestObject {\n+\n+    public TestBlockingBuffer(String testName) {\n+        super(testName);\n     }\n \n     public static Test suite() {\n-        return new TestSuite( TestBlockingBuffer.class );\n-    }\n-\n-    public static void main( String args[] ) {\n-        String[] testCaseName = {TestBlockingBuffer.class.getName()};\n-        junit.textui.TestRunner.main( testCaseName );\n-    }\n-\n-    public Object makeObject() {\n-        return BlockingBuffer.decorate( new MyBuffer() );\n+        return new TestSuite(TestBlockingBuffer.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestBlockingBuffer.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public Buffer<E> makeObject() {\n+        return BlockingBuffer.decorate(new MyBuffer<E>());\n     }\n \n     public boolean isEqualsCheckable() {\n \n     //-----------------------------------------------------------------------\n \n-    /**\n-     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add(Object)}.\n+    @SuppressWarnings(\"unchecked\")\n+    protected E makeElement() {\n+        return (E) new Object();\n+    }\n+    \n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#add(Object)}.\n      */\n     public void testGetWithAdd() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n-        new DelayedAdd( blockingBuffer, obj ).start();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame( obj, blockingBuffer.get() );\n+        assertSame(obj, blockingBuffer.get());\n     }\n \n     public void testGetWithAddTimeout() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 500 );\n-        Object obj = new Object();\n-        new DelayedAdd( blockingBuffer, obj, 100 ).start();\n+        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 500);\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj, 100).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame( obj, blockingBuffer.get() );\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}.\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)}.\n      */\n     public void testGetWithAddAll() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n-        new DelayedAddAll( blockingBuffer, obj ).start();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame( obj, blockingBuffer.get() );\n+        assertSame(obj, blockingBuffer.get());\n     }\n \n     public void testGetWithAddAllTimeout() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 500 );\n-        Object obj = new Object();\n-        new DelayedAddAll( blockingBuffer, obj, 100 ).start();\n+        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 500);\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj, 100).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame( obj, blockingBuffer.get() );\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add(Object)}.\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#add(Object)}.\n      */\n     public void testRemoveWithAdd() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n-        new DelayedAdd( blockingBuffer, obj ).start();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame( obj, blockingBuffer.remove() );\n+        assertSame(obj, blockingBuffer.remove());\n     }\n \n     public void testRemoveWithAddTimeout() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 100 );\n-        Object obj = new Object();\n-        new DelayedAdd( blockingBuffer, obj, 500 ).start();\n+        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 100);\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj, 500).start();\n         try {\n             blockingBuffer.remove();\n-        }\n-        catch( BufferUnderflowException e ) {\n-        }\n-    }\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}.\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)}.\n      */\n     public void testRemoveWithAddAll() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n-        new DelayedAddAll( blockingBuffer, obj ).start();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n-        assertSame( obj, blockingBuffer.remove() );\n+        assertSame(obj, blockingBuffer.remove());\n     }\n \n     public void testRemoveWithAddAllTimeout() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer(), 100 );\n-        Object obj = new Object();\n-        new DelayedAddAll( blockingBuffer, obj, 500 ).start();\n+        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 100);\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj, 500).start();\n         try {\n             blockingBuffer.remove();\n-        }\n-        catch( BufferUnderflowException e ) {\n-        }\n-    }\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#add(Object)} using multiple read\n-     * threads.\n-     * <p/>\n-     * Two read threads should block on an empty buffer until one object is added then both threads should complete.\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#add(Object)} using multiple read threads. <p/> Two\n+     * read threads should block on an empty buffer until one object is added\n+     * then both threads should complete.\n      */\n     public void testBlockedGetWithAdd() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n \n         // run methods will get and compare -- must wait for add\n-        Thread thread1 = new ReadThread( blockingBuffer, obj );\n-        Thread thread2 = new ReadThread( blockingBuffer, obj );\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n         thread1.start();\n         thread2.start();\n \n         delay();\n \n         // notifyAll should allow both read threads to complete\n-        blockingBuffer.add( obj );\n+        blockingBuffer.add(obj);\n \n         // allow notified threads to complete \n         delay();\n \n         // There should not be any threads waiting.\n-        if( thread1.isAlive() || thread2.isAlive() ) {\n-            fail( \"Live thread(s) when both should be dead.\" );\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#get()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)} using\n-     * multiple read threads.\n-     * <p/>\n-     * Two read threads should block on an empty buffer until a singleton is added then both threads should complete.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * singleton is added then both threads should complete.\n      */\n     public void testBlockedGetWithAddAll() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n \n         // run methods will get and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread( blockingBuffer, obj );\n-        Thread thread2 = new ReadThread( blockingBuffer, obj );\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n         thread1.start();\n         thread2.start();\n \n         delay();\n \n         // notifyAll should allow both read threads to complete\n-        blockingBuffer.addAll( Collections.singleton( obj ) );\n+        blockingBuffer.addAll(Collections.singleton(obj));\n \n         // allow notified threads to complete \n         delay();\n \n         // There should not be any threads waiting.\n-        if( thread1.isAlive() || thread2.isAlive() ) {\n-            fail( \"Live thread(s) when both should be dead.\" );\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n         }\n     }\n \n      * Tests interrupted {@link BlockingBuffer#get()}.\n      */\n     public void testInterruptedGet() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n \n         // spawn a read thread to wait on the empty buffer\n-        ArrayList exceptionList = new ArrayList();\n-        Thread thread = new ReadThread( blockingBuffer, obj, exceptionList );\n+        ArrayList<String> exceptionList = new ArrayList<String>();\n+        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList);\n         thread.start();\n \n         // Interrupting the thread should cause it to throw BufferUnderflowException\n \n         // Chill, so thread can throw and add message to exceptionList\n         delay();\n-        assertTrue( \"Thread interrupt should have led to underflow\",\n-                    exceptionList.contains( \"BufferUnderFlow\" ) );\n-        if( thread.isAlive() ) {\n-            fail( \"Read thread has hung.\" );\n-        }\n-\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#add(Object)} using multiple read\n-     * threads.\n-     * <p/>\n-     * Two read threads should block on an empty buffer until one object is added then one thread should complete. The\n-     * remaining thread should complete after the addition of a second object.\n+        assertTrue(\"Thread interrupt should have led to underflow\", exceptionList\n+                .contains(\"BufferUnderFlow\"));\n+        if (thread.isAlive()) {\n+            fail(\"Read thread has hung.\");\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#add(Object)} using multiple read threads. <p/> Two\n+     * read threads should block on an empty buffer until one object is added\n+     * then one thread should complete. The remaining thread should complete\n+     * after the addition of a second object.\n      */\n     public void testBlockedRemoveWithAdd() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n \n         // run methods will remove and compare -- must wait for add\n-        Thread thread1 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n-        Thread thread2 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n         thread1.start();\n         thread2.start();\n \n         // give hungry read threads ample time to hang\n         delay();\n-        blockingBuffer.add( obj );\n+        blockingBuffer.add(obj);\n \n         // allow notified threads to complete \n         delay();\n \n         // There should be one thread waiting.\n-        assertTrue( \"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive() );\n-        blockingBuffer.add( obj );\n+        assertTrue(\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+        blockingBuffer.add(obj);\n \n         // allow notified thread to complete \n         delay();\n \n         // There should not be any threads waiting.\n-        if( thread1.isAlive() || thread2.isAlive() ) {\n-            fail( \"Live thread(s) when both should be dead.\" );\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}\n-     * using multiple read threads.\n-     * <p/>\n-     * Two read threads should block on an empty buffer until a singleton collection is added then one thread should\n-     * complete. The remaining thread should complete after the addition of a second singleton.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * singleton collection is added then one thread should complete. The\n+     * remaining thread should complete after the addition of a second\n+     * singleton.\n      */\n     public void testBlockedRemoveWithAddAll1() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n \n         // run methods will remove and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n-        Thread thread2 = new ReadThread( blockingBuffer, obj, null, \"remove\" );\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n         thread1.start();\n         thread2.start();\n \n         // give hungry read threads ample time to hang\n         delay();\n-        blockingBuffer.addAll( Collections.singleton( obj ) );\n+        blockingBuffer.addAll(Collections.singleton(obj));\n \n         // allow notified threads to complete \n         delay();\n \n         // There should be one thread waiting.\n-        assertTrue( \"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive() );\n-        blockingBuffer.addAll( Collections.singleton( obj ) );\n+        assertTrue(\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+        blockingBuffer.addAll(Collections.singleton(obj));\n \n         // allow notified thread to complete \n         delay();\n \n         // There should not be any threads waiting.\n-        if( thread1.isAlive() || thread2.isAlive() ) {\n-            fail( \"Live thread(s) when both should be dead.\" );\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n-    /**\n-     * Tests {@link BlockingBuffer#remove()} in combination with {@link BlockingBuffer#addAll(java.util.Collection)}\n-     * using multiple read threads.\n-     * <p/>\n-     * Two read threads should block on an empty buffer until a collection with two distinct objects is added then both\n-     * threads should complete. Each thread should have read a different object.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * collection with two distinct objects is added then both threads should\n+     * complete. Each thread should have read a different object.\n      */\n     public void testBlockedRemoveWithAddAll2() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj1 = new Object();\n-        Object obj2 = new Object();\n-        Set objs = Collections.synchronizedSet( new HashSet() );\n-        objs.add( obj1 );\n-        objs.add( obj2 );\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj1 = makeElement();\n+        E obj2 = makeElement();\n+        Set<E> objs = Collections.synchronizedSet(new HashSet<E>());\n+        objs.add(obj1);\n+        objs.add(obj2);\n \n         // run methods will remove and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread( blockingBuffer, objs, \"remove\" );\n-        Thread thread2 = new ReadThread( blockingBuffer, objs, \"remove\" );\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n         thread1.start();\n         thread2.start();\n \n         // give hungry read threads ample time to hang\n         delay();\n-        blockingBuffer.addAll( objs );\n+        blockingBuffer.addAll(objs);\n \n         // allow notified threads to complete \n         delay();\n-        assertEquals( \"Both objects were removed\", 0, objs.size() );\n+        assertEquals(\"Both objects were removed\", 0, objs.size());\n \n         // There should not be any threads waiting.\n-        if( thread1.isAlive() || thread2.isAlive() ) {\n-            fail( \"Live thread(s) when both should be dead.\" );\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n         }\n     }\n \n      * Tests interrupted remove.\n      */\n     public void testInterruptedRemove() {\n-        Buffer blockingBuffer = BlockingBuffer.decorate( new MyBuffer() );\n-        Object obj = new Object();\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n \n         // spawn a read thread to wait on the empty buffer\n-        ArrayList exceptionList = new ArrayList();\n-        Thread thread = new ReadThread( blockingBuffer, obj, exceptionList, \"remove\" );\n+        ArrayList<String> exceptionList = new ArrayList<String>();\n+        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList, \"remove\");\n         thread.start();\n \n         // Interrupting the thread should cause it to throw BufferUnderflowException\n \n         // Chill, so thread can throw and add message to exceptionList\n         delay();\n-        assertTrue( \"Thread interrupt should have led to underflow\",\n-                    exceptionList.contains( \"BufferUnderFlow\" ) );\n-        if( thread.isAlive() ) {\n-            fail( \"Read thread has hung.\" );\n+        assertTrue(\"Thread interrupt should have led to underflow\", exceptionList\n+                .contains(\"BufferUnderFlow\"));\n+        if (thread.isAlive()) {\n+            fail(\"Read thread has hung.\");\n         }\n \n     }\n \n     public void testTimeoutGet() {\n-        final BlockingBuffer buffer = new BlockingBuffer( new MyBuffer() );\n+        final BlockingBuffer<E> buffer = new BlockingBuffer<E>(new MyBuffer<E>());\n         try {\n-            buffer.get( 100 );\n-            fail( \"Get should have timed out.\" );\n-        }\n-        catch( BufferUnderflowException e ) {\n+            buffer.get(100);\n+            fail(\"Get should have timed out.\");\n+        } catch (BufferUnderflowException e) {\n         }\n     }\n \n     public void testTimeoutRemove() {\n-        final BlockingBuffer buffer = new BlockingBuffer( new MyBuffer() );\n+        final BlockingBuffer<E> buffer = new BlockingBuffer<E>(new MyBuffer<E>());\n         try {\n-            buffer.remove( 100 );\n-            fail( \"Get should have timed out.\" );\n-        }\n-        catch( BufferUnderflowException e ) {\n-        }\n-    }\n-\n-    protected static class DelayedAdd extends Thread {\n-\n-        Buffer buffer;\n-\n-        Object obj;\n+            buffer.remove(100);\n+            fail(\"Get should have timed out.\");\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    protected static class DelayedAdd<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        E obj;\n \n         long delay = 1000;\n \n-        public DelayedAdd( Buffer buffer, Object obj, long delay ) {\n+        public DelayedAdd(Buffer<E> buffer, E obj, long delay) {\n             this.buffer = buffer;\n             this.obj = obj;\n             this.delay = delay;\n         }\n \n-        DelayedAdd( Buffer buffer, Object obj ) {\n+        DelayedAdd(Buffer<E> buffer, E obj) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         public void run() {\n             try {\n                 // wait for other thread to block on get() or remove()\n-                Thread.sleep( delay );\n+                Thread.sleep(delay);\n+            } catch (InterruptedException e) {\n             }\n-            catch( InterruptedException e ) {\n-            }\n-            buffer.add( obj );\n-        }\n-    }\n-\n-    protected static class DelayedAddAll extends Thread {\n-\n-        Buffer buffer;\n-\n-        Object obj;\n+            buffer.add(obj);\n+        }\n+    }\n+\n+    protected static class DelayedAddAll<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        E obj;\n \n         long delay = 100;\n \n-        public DelayedAddAll( Buffer buffer, Object obj, long delay ) {\n+        public DelayedAddAll(Buffer<E> buffer, E obj, long delay) {\n             this.buffer = buffer;\n             this.obj = obj;\n             this.delay = delay;\n         }\n \n-        DelayedAddAll( Buffer buffer, Object obj ) {\n+        DelayedAddAll(Buffer<E> buffer, E obj) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         public void run() {\n             try {\n                 // wait for other thread to block on get() or remove()\n-                Thread.sleep( delay );\n+                Thread.sleep(delay);\n+            } catch (InterruptedException e) {\n             }\n-            catch( InterruptedException e ) {\n-            }\n-            buffer.addAll( Collections.singleton( obj ) );\n-        }\n-    }\n-\n-    protected static class ReadThread extends Thread {\n-\n-        Buffer buffer;\n+            buffer.addAll(Collections.singleton(obj));\n+        }\n+    }\n+\n+    protected static class ReadThread<E> extends Thread {\n+\n+        Buffer<E> buffer;\n \n         Object obj;\n \n-        ArrayList exceptionList = null;\n+        ArrayList<String> exceptionList = null;\n \n         String action = \"get\";\n \n-        Set objs;\n-\n-        ReadThread( Buffer buffer, Object obj ) {\n+        Set<E> objs;\n+\n+        ReadThread(Buffer<E> buffer, Object obj) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         }\n \n-        ReadThread( Buffer buffer, Object obj, ArrayList exceptionList ) {\n+        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             this.exceptionList = exceptionList;\n         }\n \n-        ReadThread( Buffer buffer, Object obj, ArrayList exceptionList, String action ) {\n+        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList, String action) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             this.action = action;\n         }\n \n-        ReadThread( Buffer buffer, Set objs, String action ) {\n+        ReadThread(Buffer<E> buffer, Set<E> objs, String action) {\n             super();\n             this.buffer = buffer;\n             this.objs = objs;\n \n         public void run() {\n             try {\n-                if( action == \"get\" ) {\n-                    assertSame( obj, buffer.get() );\n-                }\n-                else {\n-                    if( null != obj ) {\n-                        assertSame( obj, buffer.remove() );\n-                    }\n-                    else {\n-                        assertTrue( objs.remove( buffer.remove() ) );\n+                if (action == \"get\") {\n+                    assertSame(obj, buffer.get());\n+                } else {\n+                    if (null != obj) {\n+                        assertSame(obj, buffer.remove());\n+                    } else {\n+                        assertTrue(objs.remove(buffer.remove()));\n                     }\n                 }\n+            } catch (BufferUnderflowException ex) {\n+                exceptionList.add(\"BufferUnderFlow\");\n             }\n-            catch( BufferUnderflowException ex ) {\n-                exceptionList.add( \"BufferUnderFlow\" );\n-            }\n-        }\n-    }\n-\n-    protected static class MyBuffer extends LinkedList implements Buffer {\n-\n-        public Object get() {\n-            if( isEmpty() ) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    protected static class MyBuffer<E> extends LinkedList<E> implements Buffer<E> {\n+\n+        public E get() {\n+            if (isEmpty()) {\n                 throw new BufferUnderflowException();\n             }\n-            return get( 0 );\n-        }\n-\n-        public Object remove() {\n-            if( isEmpty() ) {\n+            return get(0);\n+        }\n+\n+        public E remove() {\n+            if (isEmpty()) {\n                 throw new BufferUnderflowException();\n             }\n-            return remove( 0 );\n+            return remove(0);\n         }\n     }\n \n     private void delay() {\n         try {\n             Thread.sleep( 200 );\n-        }\n-        catch( InterruptedException e ) {\n+        } catch (InterruptedException e) {\n         }\n     }\n \n         return \"3.1\";\n     }\n \n-//    public void testCreate() throws Exception {\n-//        Buffer buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n-//        writeExternalFormToDisk((java.io.Serializable) buffer,\n-//        \"D:/dev/collections/data/test/BlockingBuffer.emptyCollection.version3.1.obj\");\n-//        buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n-//        buffer.add(\"A\");\n-//        buffer.add(\"B\");\n-//        buffer.add(\"C\");\n-//        writeExternalFormToDisk((java.io.Serializable) buffer,\n-//        \"D:/dev/collections/data/test/BlockingBuffer.fullCollection.version3.1.obj\");\n-//    }\n+    //    public void testCreate() throws Exception {\n+    //        Buffer buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n+    //        writeExternalFormToDisk((java.io.Serializable) buffer,\n+    //        \"D:/dev/collections/data/test/BlockingBuffer.emptyCollection.version3.1.obj\");\n+    //        buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n+    //        buffer.add(\"A\");\n+    //        buffer.add(\"B\");\n+    //        buffer.add(\"C\");\n+    //        writeExternalFormToDisk((java.io.Serializable) buffer,\n+    //        \"D:/dev/collections/data/test/BlockingBuffer.fullCollection.version3.1.obj\");\n+    //    }\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-public class TestBoundedBuffer extends AbstractTestObject {\n+public class TestBoundedBuffer<E> extends AbstractTestObject {\n \n     public TestBoundedBuffer(String testName) {\n         super(testName);\n         return false;\n     }\n \n-    public Object makeObject() {\n-        return BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n+    public Buffer<E> makeObject() {\n+        return BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 1);\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testMaxSize() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 2, 500);\n-        BoundedCollection bc = (BoundedCollection) bounded;\n+        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 2, 500);\n+        BoundedCollection<?> bc = (BoundedCollection<?>) bounded;\n         assertEquals(2, bc.maxSize());\n         assertEquals(false, bc.isFull());\n-        bounded.add(\"A\");\n+        bounded.add((E) \"A\");\n         assertEquals(false, bc.isFull());\n-        bounded.add(\"B\");\n+        bounded.add((E) \"B\");\n         assertEquals(true, bc.isFull());\n         bounded.remove();\n         assertEquals(false, bc.isFull());\n         try {\n-            BoundedBuffer.decorate(new UnboundedFifoBuffer(), 0);\n+            BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 0);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         try {\n-            BoundedBuffer.decorate(new UnboundedFifoBuffer(), -1);\n+            BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), -1);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testAddToFullBufferNoTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n-        bounded.add( \"Hello\" );\n-        try {\n-            bounded.add(\"World\");\n-            fail();\n-        } catch (BufferOverflowException e) {\n-        }\n-    }\n-\n+        final Buffer<E> bounded = makeObject();\n+        bounded.add((E) \"Hello\");\n+        try {\n+            bounded.add((E) \"World\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddAllToFullBufferNoTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n-        bounded.add( \"Hello\" );\n-        try {\n-            bounded.addAll(Collections.singleton(\"World\"));\n-            fail();\n-        } catch (BufferOverflowException e) {\n-        }\n-    }\n-\n+        final Buffer<E> bounded = makeObject();\n+        bounded.add((E) \"Hello\");\n+        try {\n+            bounded.addAll(Collections.singleton((E) \"World\"));\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddAllToEmptyBufferExceedMaxSizeNoTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n-        try {\n-            bounded.addAll(Collections.nCopies(2, \"test\"));\n-            fail();\n-        } catch (BufferOverflowException e) {\n-        }\n-    }\n-\n+        final Buffer<E> bounded = makeObject();\n+        try {\n+            bounded.addAll(Collections.nCopies(2, (E) \"test\"));\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddToFullBufferRemoveViaIterator() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1, 500);\n-        bounded.add( \"Hello\" );\n-        new DelayedIteratorRemove( bounded, 200 ).start();\n-        bounded.add( \"World\" );\n-        assertEquals( 1, bounded.size() );\n-        assertEquals( \"World\", bounded.get() );\n-\n-    }\n-\n+        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 1, 500);\n+        bounded.add((E) \"Hello\");\n+        new DelayedIteratorRemove(bounded, 200).start();\n+        bounded.add((E) \"World\");\n+        assertEquals(1, bounded.size());\n+        assertEquals(\"World\", bounded.get());\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddAllToFullBufferRemoveViaIterator() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 2, 500);\n-        bounded.add( \"Hello\" );\n-        bounded.add( \"World\" );\n-        new DelayedIteratorRemove( bounded, 200, 2 ).start();\n-        bounded.addAll( Arrays.asList( new String[] { \"Foo\", \"Bar\" } ) );\n-        assertEquals( 2, bounded.size() );\n-        assertEquals( \"Foo\", bounded.remove() );\n-        assertEquals( \"Bar\", bounded.remove() );\n-    }\n-\n+        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 2, 500);\n+        bounded.add((E) \"Hello\");\n+        bounded.add((E) \"World\");\n+        new DelayedIteratorRemove(bounded, 200, 2).start();\n+        bounded.addAll(Arrays.asList((E[]) new String[] { \"Foo\", \"Bar\" }));\n+        assertEquals(2, bounded.size());\n+        assertEquals(\"Foo\", bounded.remove());\n+        assertEquals(\"Bar\", bounded.remove());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddToFullBufferWithTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1, 500);\n-        bounded.add( \"Hello\" );\n-        new DelayedRemove( bounded, 200 ).start();\n-        bounded.add( \"World\" );\n-        assertEquals( 1, bounded.size() );\n-        assertEquals( \"World\", bounded.get() );\n-        try {\n-            bounded.add( \"!\" );\n-            fail();\n-        }\n-        catch( BufferOverflowException e ) {\n-        }\n-    }\n-\n+        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 1, 500);\n+        bounded.add((E) \"Hello\");\n+        new DelayedRemove(bounded, 200).start();\n+        bounded.add((E) \"World\");\n+        assertEquals(1, bounded.size());\n+        assertEquals(\"World\", bounded.get());\n+        try {\n+            bounded.add((E) \"!\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddAllToFullBufferWithTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 2, 500);\n-        bounded.add( \"Hello\" );\n-        bounded.add( \"World\" );\n-        new DelayedRemove( bounded, 200, 2 ).start();\n-\n-        bounded.addAll( Arrays.asList( new String[] { \"Foo\", \"Bar\" } ) );\n-        assertEquals( 2, bounded.size() );\n-        assertEquals( \"Foo\", bounded.get() );\n-        try {\n-            bounded.add( \"!\" );\n-            fail();\n-        }\n-        catch( BufferOverflowException e ) {\n+        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 2, 500);\n+        bounded.add((E) \"Hello\");\n+        bounded.add((E) \"World\");\n+        new DelayedRemove(bounded, 200, 2).start();\n+\n+        bounded.addAll(Arrays.asList((E[]) new String[] { \"Foo\", \"Bar\" }));\n+        assertEquals(2, bounded.size());\n+        assertEquals(\"Foo\", bounded.get());\n+        try {\n+            bounded.add((E) \"!\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n         }\n     }\n \n     private class DelayedIteratorRemove extends Thread {\n \n-        private final Buffer buffer;\n+        private final Buffer<?> buffer;\n \n         private final long delay;\n \n         private final int nToRemove;\n \n-        public DelayedIteratorRemove(Buffer buffer, long delay, int nToRemove) {\n+        public DelayedIteratorRemove(Buffer<?> buffer, long delay, int nToRemove) {\n             this.buffer = buffer;\n             this.delay = delay;\n             this.nToRemove = nToRemove;\n         }\n \n-        public DelayedIteratorRemove(Buffer buffer, long delay) {\n+        public DelayedIteratorRemove(Buffer<?> buffer, long delay) {\n             this(buffer, delay, 1);\n         }\n \n         public void run() {\n             try {\n                 Thread.sleep(delay);\n-                Iterator iter = buffer.iterator();\n+                Iterator<?> iter = buffer.iterator();\n                 for (int i = 0; i < nToRemove; ++i) {\n                     iter.next();\n                     iter.remove();\n \n     private class DelayedRemove extends Thread {\n \n-        private final Buffer buffer;\n+        private final Buffer<?> buffer;\n \n         private final long delay;\n \n         private final int nToRemove;\n \n-        public DelayedRemove(Buffer buffer, long delay, int nToRemove) {\n+        public DelayedRemove(Buffer<?> buffer, long delay, int nToRemove) {\n             this.buffer = buffer;\n             this.delay = delay;\n             this.nToRemove = nToRemove;\n         }\n \n-        public DelayedRemove(Buffer buffer, long delay) {\n+        public DelayedRemove(Buffer<?> buffer, long delay) {\n             this(buffer, delay, 1);\n         }\n \n             }\n         }\n     }\n-}\n+}\n--- a/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java\n package org.apache.commons.collections.buffer;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Iterator;\n+import java.util.List;\n \n import junit.framework.Test;\n \n  *\n  * @author Paul Jack\n  */\n-public class TestBoundedFifoBuffer extends AbstractTestCollection {\n+public class TestBoundedFifoBuffer<E> extends AbstractTestCollection<E> {\n \n     public TestBoundedFifoBuffer(String n) {\n         super(n);\n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Runs through the regular verifications, but also verifies that \n+     *  Runs through the regular verifications, but also verifies that\n      *  the buffer contains the same elements in the same sequence as the\n      *  list.\n      */\n     public void verify() {\n         super.verify();\n-        Iterator iterator1 = collection.iterator();\n-        Iterator iterator2 = confirmed.iterator();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n         while (iterator2.hasNext()) {\n             assertTrue(iterator1.hasNext());\n-            Object o1 = iterator1.next();\n-            Object o2 = iterator2.next();\n+            E o1 = iterator1.next();\n+            E o2 = iterator2.next();\n             assertEquals(o1, o2);\n         }\n     }\n         return false;\n     }\n \n-    //-----------------------------------------------------------------------  \n+    //-----------------------------------------------------------------------\n     /**\n      *  Returns an empty ArrayList.\n      *\n      *  @return an empty ArrayList\n      */\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n \n     /**\n      *\n      *  @return a full ArrayList\n      */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection c = makeConfirmedCollection();\n+    public List<E> makeConfirmedFullCollection() {\n+        List<E> c = makeConfirmedCollection();\n         c.addAll(java.util.Arrays.asList(getFullElements()));\n         return c;\n     }\n \n     /**\n-     *  Returns an empty BoundedFifoBuffer that won't overflow.  \n-     *  \n+     *  Returns an empty BoundedFifoBuffer that won't overflow.\n+     *\n      *  @return an empty BoundedFifoBuffer\n      */\n-    public Collection makeCollection() {\n-        return new BoundedFifoBuffer(100);\n-    }\n-\n-    //-----------------------------------------------------------------------  \n+    public BoundedFifoBuffer<E> makeObject() {\n+        return new BoundedFifoBuffer<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Tests that the removal operation actually removes the first element.\n      */\n     public void testBoundedFifoBufferRemove() {\n         resetFull();\n-        int size = confirmed.size();\n+        int size = getConfirmed().size();\n         for (int i = 0; i < size; i++) {\n-            Object o1 = ((BoundedFifoBuffer)collection).remove();\n-            Object o2 = ((ArrayList)confirmed).remove(0);\n+            E o1 = getCollection().remove();\n+            E o2 = getConfirmed().remove(0);\n             assertEquals(\"Removed objects should be equal\", o1, o2);\n             verify();\n         }\n \n         try {\n-            ((BoundedFifoBuffer)collection).remove();\n+            getCollection().remove();\n             fail(\"Empty buffer should raise Underflow.\");\n         } catch (BufferUnderflowException e) {\n             // expected\n      */\n     public void testConstructorException1() {\n         try {\n-            new BoundedFifoBuffer(0);\n+            new BoundedFifoBuffer<E>(0);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     }\n-    \n+\n     /**\n      * Tests that the constructor correctly throws an exception.\n      */\n     public void testConstructorException2() {\n         try {\n-            new BoundedFifoBuffer(-20);\n+            new BoundedFifoBuffer<E>(-20);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n      */\n     public void testConstructorException3() {\n         try {\n-            new BoundedFifoBuffer(null);\n+            new BoundedFifoBuffer<E>(null);\n         } catch (NullPointerException ex) {\n             return;\n         }\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }\n-    \n+\n     // BZ 33071 -- gets start=end=1 before removal of interior element\n+    @SuppressWarnings(\"unchecked\")\n     public void testShift() {\n-        BoundedFifoBuffer fifo = new BoundedFifoBuffer(3);\n-        fifo.add(\"a\");\n-        fifo.add(\"b\");\n-        fifo.add(\"c\");\n+        BoundedFifoBuffer<E> fifo = new BoundedFifoBuffer<E>(3);\n+        fifo.add((E) \"a\");\n+        fifo.add((E) \"b\");\n+        fifo.add((E) \"c\");\n         fifo.remove();\n-        fifo.add(\"e\");\n+        fifo.add((E) \"e\");\n         fifo.remove(\"c\");\n     }\n \n //        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/BoundedFifoBuffer.fullCollection.version3.1.obj\");\n //    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public BoundedFifoBuffer<E> getCollection() {\n+        return (BoundedFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer2.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer2.java\n \n import junit.framework.Test;\n \n-import org.apache.commons.collections.BoundedCollection;\n import org.apache.commons.collections.BufferOverflowException;\n import org.apache.commons.collections.BulkTest;\n \n  *\n  * @author Unknown\n  */\n-public class TestBoundedFifoBuffer2 extends TestBoundedFifoBuffer {\n+public class TestBoundedFifoBuffer2<E> extends TestBoundedFifoBuffer<E> {\n \n     public TestBoundedFifoBuffer2(String n) {\n         super(n);\n      *\n      *  @return a full BoundedFifoBuffer\n      */\n-    public Collection makeFullCollection() {\n-        return new BoundedFifoBuffer(Arrays.asList(getFullElements()));\n+    public Collection<E> makeFullCollection() {\n+        return new BoundedFifoBuffer<E>(Arrays.asList(getFullElements()));\n     }\n-\n \n     /**\n      *  Overridden to skip the add tests.  All of them would fail with a \n         return false;\n     }\n \n-\n     /**\n      *  Overridden because the add operations raise BufferOverflowException\n      *  instead of UnsupportedOperationException.\n     public void testUnsupportedAdd() {\n     }\n \n-\n     /**\n      *  Tests to make sure the add operations raise BufferOverflowException.\n      */\n     public void testBufferOverflow() {\n         resetFull();\n         try {\n-            collection.add(getOtherElements()[0]);\n+            getCollection().add(getOtherElements()[0]);\n             fail(\"add should raise BufferOverflow.\");\n         } catch (BufferOverflowException e) {\n             // expected\n         verify();\n \n         try {\n-            collection.addAll(Arrays.asList(getOtherElements()));\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n             fail(\"addAll should raise BufferOverflow.\");\n         } catch (BufferOverflowException e) {\n             // expected\n     /**\n      * Tests is full\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testIsFull() {\n         resetFull();\n-        assertEquals(true, ((BoundedCollection) collection).isFull());\n-        ((BoundedFifoBuffer) collection).remove();\n-        assertEquals(false, ((BoundedCollection) collection).isFull());\n-        ((BoundedFifoBuffer) collection).add(\"jj\");\n-        assertEquals(true, ((BoundedCollection) collection).isFull());\n+        assertEquals(true, getCollection().isFull());\n+        getCollection().remove();\n+        assertEquals(false, getCollection().isFull());\n+        getCollection().add((E) \"jj\");\n+        assertEquals(true, getCollection().isFull());\n     }\n \n     /**\n      * Tests max size\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testMaxSize() {\n         resetFull();\n-        assertEquals(getFullElements().length, ((BoundedCollection) collection).maxSize());\n-        ((BoundedFifoBuffer) collection).remove();\n-        assertEquals(getFullElements().length, ((BoundedCollection) collection).maxSize());\n-        ((BoundedFifoBuffer) collection).add(\"jj\");\n-        assertEquals(getFullElements().length, ((BoundedCollection) collection).maxSize());\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+        getCollection().remove();\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+        getCollection().add((E) \"jj\");\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestCircularFifoBuffer extends AbstractTestCollection {\n+public class TestCircularFifoBuffer<E> extends AbstractTestCollection<E> {\n \n     public TestCircularFifoBuffer(String n) {\n         super(n);\n \n     //-----------------------------------------------------------------------\n     /**\n-     *  Runs through the regular verifications, but also verifies that \n+     *  Runs through the regular verifications, but also verifies that\n      *  the buffer contains the same elements in the same sequence as the\n      *  list.\n      */\n     public void verify() {\n         super.verify();\n-        Iterator iterator1 = collection.iterator();\n-        Iterator iterator2 = confirmed.iterator();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n         while (iterator2.hasNext()) {\n             assertTrue(iterator1.hasNext());\n             Object o1 = iterator1.next();\n      *\n      * @return an empty ArrayList\n      */\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n \n     /**\n      *\n      * @return a full ArrayList\n      */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection c = makeConfirmedCollection();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> c = makeConfirmedCollection();\n         c.addAll(java.util.Arrays.asList(getFullElements()));\n         return c;\n     }\n \n     /**\n-     * Returns an empty BoundedFifoBuffer that won't overflow.  \n-     *  \n+     * Returns an empty BoundedFifoBuffer that won't overflow.\n+     *\n      * @return an empty BoundedFifoBuffer\n      */\n-    public Collection makeCollection() {\n-        return new CircularFifoBuffer(100);\n+    public Collection<E> makeObject() {\n+        return new CircularFifoBuffer<E>(100);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Tests that the removal operation actually removes the first element.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testCircularFifoBufferCircular() {\n-        List list = new ArrayList();\n-        list.add(\"A\");\n-        list.add(\"B\");\n-        list.add(\"C\");\n-        Buffer buf = new CircularFifoBuffer(list);\n-        \n+        List<E> list = new ArrayList<E>();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        Buffer<E> buf = new CircularFifoBuffer<E>(list);\n+\n         assertEquals(true, buf.contains(\"A\"));\n         assertEquals(true, buf.contains(\"B\"));\n         assertEquals(true, buf.contains(\"C\"));\n-        \n-        buf.add(\"D\");\n-        \n+\n+        buf.add((E) \"D\");\n+\n         assertEquals(false, buf.contains(\"A\"));\n         assertEquals(true, buf.contains(\"B\"));\n         assertEquals(true, buf.contains(\"C\"));\n         assertEquals(true, buf.contains(\"D\"));\n-        \n+\n         assertEquals(\"B\", buf.get());\n         assertEquals(\"B\", buf.remove());\n         assertEquals(\"C\", buf.remove());\n      */\n     public void testCircularFifoBufferRemove() {\n         resetFull();\n-        int size = confirmed.size();\n+        int size = getConfirmed().size();\n         for (int i = 0; i < size; i++) {\n-            Object o1 = ((CircularFifoBuffer) collection).remove();\n-            Object o2 = ((ArrayList) confirmed).remove(0);\n+            Object o1 = getCollection().remove();\n+            Object o2 = getConfirmed().remove(0);\n             assertEquals(\"Removed objects should be equal\", o1, o2);\n             verify();\n         }\n \n         try {\n-            ((CircularFifoBuffer) collection).remove();\n+            getCollection().remove();\n             fail(\"Empty buffer should raise Underflow.\");\n         } catch (BufferUnderflowException e) {\n             // expected\n      */\n     public void testConstructorException1() {\n         try {\n-            new CircularFifoBuffer(0);\n+            new CircularFifoBuffer<E>(0);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n      */\n     public void testConstructorException2() {\n         try {\n-            new CircularFifoBuffer(-20);\n+            new CircularFifoBuffer<E>(-20);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     }\n-    \n+\n     /**\n      * Tests that the constructor correctly throws an exception.\n      */\n     public void testConstructorException3() {\n         try {\n-            new CircularFifoBuffer(null);\n+            new CircularFifoBuffer<E>(null);\n         } catch (NullPointerException ex) {\n             return;\n         }\n         fail();\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError1() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n         assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n-        \n+\n         fifo.remove(\"3\");\n         assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n-        \n+\n         fifo.remove(\"4\");\n         assertEquals(\"[1, 2, 5]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError2() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");\n-        fifo.add(\"6\");\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+        fifo.add((E) \"6\");\n+\n         assertEquals(5, fifo.size());\n         assertEquals(\"[2, 3, 4, 5, 6]\", fifo.toString());\n-        \n+\n         fifo.remove(\"3\");\n         assertEquals(\"[2, 4, 5, 6]\", fifo.toString());\n-        \n+\n         fifo.remove(\"4\");\n         assertEquals(\"[2, 5, 6]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError3() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n         assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n-        \n+\n         fifo.remove(\"3\");\n         assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n-        \n-        fifo.add(\"6\");\n-        fifo.add(\"7\");\n+\n+        fifo.add((E) \"6\");\n+        fifo.add((E) \"7\");\n         assertEquals(\"[2, 4, 5, 6, 7]\", fifo.toString());\n-        \n+\n         fifo.remove(\"4\");\n         assertEquals(\"[2, 5, 6, 7]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError4() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");  // end=0\n-        fifo.add(\"6\");  // end=1\n-        fifo.add(\"7\");  // end=2\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n         assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n-        \n+\n         fifo.remove(\"4\");  // remove element in middle of array, after start\n         assertEquals(\"[3, 5, 6, 7]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError5() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");  // end=0\n-        fifo.add(\"6\");  // end=1\n-        fifo.add(\"7\");  // end=2\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n         assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n-        \n+\n         fifo.remove(\"5\");  // remove element at last pos in array\n         assertEquals(\"[3, 4, 6, 7]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError6() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");  // end=0\n-        fifo.add(\"6\");  // end=1\n-        fifo.add(\"7\");  // end=2\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n         assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n-        \n+\n         fifo.remove(\"6\");  // remove element at position zero in array\n         assertEquals(\"[3, 4, 5, 7]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError7() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");  // end=0\n-        fifo.add(\"6\");  // end=1\n-        fifo.add(\"7\");  // end=2\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n         assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n-        \n+\n         fifo.remove(\"7\");  // remove element at position one in array\n         assertEquals(\"[3, 4, 5, 6]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError8() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");  // end=0\n-        fifo.add(\"6\");  // end=1\n-        fifo.add(\"7\");  // end=2\n-        fifo.add(\"8\");  // end=3\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n         assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n-        \n+\n         fifo.remove(\"7\");  // remove element at position one in array, need to shift 8\n         assertEquals(\"[4, 5, 6, 8]\", fifo.toString());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveError9() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer fifo = new CircularFifoBuffer(5);\n-        fifo.add(\"1\");\n-        fifo.add(\"2\");\n-        fifo.add(\"3\");\n-        fifo.add(\"4\");\n-        fifo.add(\"5\");  // end=0\n-        fifo.add(\"6\");  // end=1\n-        fifo.add(\"7\");  // end=2\n-        fifo.add(\"8\");  // end=3\n-        \n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n         assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n-        \n+\n         fifo.remove(\"8\");  // remove element at position two in array\n         assertEquals(\"[4, 5, 6, 7]\", fifo.toString());\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testRepeatedSerialization() throws Exception {\n         // bug 31433\n-        CircularFifoBuffer b = new CircularFifoBuffer(2);\n-        b.add(\"a\");\n+        CircularFifoBuffer<E> b = new CircularFifoBuffer<E>(2);\n+        b.add((E) \"a\");\n         assertEquals(1, b.size());\n         assertEquals(true, b.contains(\"a\"));\n-        \n+\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         new ObjectOutputStream(bos).writeObject(b);\n-        \n-        CircularFifoBuffer b2 = (CircularFifoBuffer) new ObjectInputStream(\n+\n+        CircularFifoBuffer<E> b2 = (CircularFifoBuffer<E>) new ObjectInputStream(\n             new ByteArrayInputStream(bos.toByteArray())).readObject();\n-        \n+\n         assertEquals(1, b2.size());\n         assertEquals(true, b2.contains(\"a\"));\n-        b2.add(\"b\");\n+        b2.add((E) \"b\");\n         assertEquals(2, b2.size());\n         assertEquals(true, b2.contains(\"a\"));\n         assertEquals(true, b2.contains(\"b\"));\n-        \n+\n         bos = new ByteArrayOutputStream();\n         new ObjectOutputStream(bos).writeObject(b2);\n-        \n-        CircularFifoBuffer b3 = (CircularFifoBuffer) new ObjectInputStream(\n+\n+        CircularFifoBuffer<E> b3 = (CircularFifoBuffer<E>) new ObjectInputStream(\n             new ByteArrayInputStream(bos.toByteArray())).readObject();\n-        \n+\n         assertEquals(2, b3.size());\n         assertEquals(true, b3.contains(\"a\"));\n         assertEquals(true, b3.contains(\"b\"));\n-        b3.add(\"c\");\n+        b3.add((E) \"c\");\n         assertEquals(2, b3.size());\n         assertEquals(true, b3.contains(\"b\"));\n         assertEquals(true, b3.contains(\"c\"));\n //        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/CircularFifoBuffer.fullCollection.version3.1.obj\");\n //    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CircularFifoBuffer<E> getCollection() {\n+        return (CircularFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n import org.apache.commons.collections.collection.TestPredicatedCollection;\n \n /**\n- * Extension of {@link TestPredicatedCollection} for exercising the \n+ * Extension of {@link TestPredicatedCollection} for exercising the\n  * {@link PredicatedBuffer} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestPredicatedBuffer extends TestPredicatedCollection {\n-    \n+public class TestPredicatedBuffer<E> extends TestPredicatedCollection<E> {\n+\n     public TestPredicatedBuffer(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestPredicatedBuffer.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestPredicatedBuffer.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n+\n     //---------------------------------------------------------------\n-    \n-    protected Buffer decorateBuffer(Buffer buffer, Predicate predicate) {\n+\n+    protected Buffer<E> decorateCollection(Buffer<E> buffer, Predicate<E> predicate) {\n         return PredicatedBuffer.decorate(buffer, predicate);\n     }\n-    \n-    public Collection makeCollection() {\n-        return decorateBuffer(new ArrayStack(), truePredicate);\n+\n+    public Buffer<E> makeObject() {\n+        return decorateCollection(new ArrayStack<E>(), truePredicate);\n     }\n-    \n-    public Collection makeConfirmedCollection() {\n-        return new ArrayStack();\n+\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n     }\n-    \n-    public Collection makeConfirmedFullCollection() {\n-        ArrayStack list = new ArrayStack();\n+\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n         list.addAll(java.util.Arrays.asList(getFullElements()));\n         return list;\n     }\n-    \n+\n     //------------------------------------------------------------\n-    \n-    public Buffer makeTestBuffer() {\n-        return decorateBuffer(new ArrayStack(), testPredicate);\n+\n+    public Buffer<E> makeTestBuffer() {\n+        return decorateCollection(new ArrayStack<E>(), testPredicate);\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testGet() {\n-        Buffer buffer = makeTestBuffer();\n+        Buffer<E> buffer = makeTestBuffer();\n         try {\n-            Object o = buffer.get();\n+            buffer.get();\n             fail(\"Expecting BufferUnderflowException\");\n         } catch (BufferUnderflowException ex) {\n             // expected\n         }\n-        buffer.add(\"one\");\n-        buffer.add(\"two\");\n-        buffer.add(\"three\");\n+        buffer.add((E) \"one\");\n+        buffer.add((E) \"two\");\n+        buffer.add((E) \"three\");\n         assertEquals(\"Buffer get\", \"three\", buffer.get());\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemove() {\n-        Buffer buffer = makeTestBuffer();\n-        buffer.add(\"one\");\n+        Buffer<E> buffer = makeTestBuffer();\n+        buffer.add((E) \"one\");\n         assertEquals(\"Buffer get\", \"one\", buffer.remove());\n         try {\n             buffer.remove();\n             fail(\"Expecting BufferUnderflowException\");\n         } catch (BufferUnderflowException ex) {\n             // expected\n-        }      \n+        }\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/buffer/TestPriorityBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestPriorityBuffer.java\n  * @author Michael A. Smith\n  * @author Steve Phelps\n  */\n-public class TestPriorityBuffer extends AbstractTestCollection {\n+public class TestPriorityBuffer<E> extends AbstractTestCollection<E> {\n \n     public static void main(String[] args) {\n         junit.textui.TestRunner.run(suite());\n         super(testName);\n     }\n \n-    //-----------------------------------------------------------------------  \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void verify() {\n         super.verify();\n-        PriorityBuffer heap = (PriorityBuffer) collection;\n-\n-        Comparator c = heap.comparator;\n+        PriorityBuffer<E> heap = getCollection();\n+\n+        Comparator<? super E> c = heap.comparator;\n         if (c == null) {\n-            c = ComparatorUtils.naturalComparator();\n+            c = ComparatorUtils.NATURAL_COMPARATOR;\n         }\n         if (!heap.ascendingOrder) {\n             c = ComparatorUtils.reversedComparator(c);\n         }\n \n-        Object[] tree = heap.elements;\n+        E[] tree = heap.elements;\n         for (int i = 1; i <= heap.size; i++) {\n-            Object parent = tree[i];\n+            E parent = tree[i];\n             if (i * 2 <= heap.size) {\n                 assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n             }\n         }\n     }\n \n-    //-----------------------------------------------------------------------  \n+    //-----------------------------------------------------------------------\n     /**\n      * Overridden because BinaryBuffer isn't fail fast.\n      * @return false\n         return false;\n     }\n \n-    //-----------------------------------------------------------------------  \n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n-    }\n-\n-    public Collection makeConfirmedFullCollection() {\n-        ArrayList list = new ArrayList();\n+    //-----------------------------------------------------------------------\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     /**\n      * Return a new, empty {@link Object} to used for testing.\n      */\n-    public Collection makeCollection() {\n-        return new PriorityBuffer();\n-    }\n-\n-    //-----------------------------------------------------------------------  \n-    public Object[] getFullElements() {\n-        return getFullNonNullStringElements();\n-    }\n-\n-    public Object[] getOtherElements() {\n-        return getOtherNonNullStringElements();\n-    }\n-\n-    //-----------------------------------------------------------------------  \n+    public Buffer<E> makeObject() {\n+        return new PriorityBuffer<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) getFullNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherElements() {\n+        return (E[]) getOtherNonNullStringElements();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testBufferEmpty() {\n         resetEmpty();\n-        Buffer buffer = (Buffer) collection;\n+        Buffer<E> buffer = getCollection();\n \n         assertEquals(0, buffer.size());\n         assertEquals(true, buffer.isEmpty());\n             fail();\n         } catch (BufferUnderflowException ex) {}\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testBasicOps() {\n-        PriorityBuffer heap = new PriorityBuffer();\n-\n-        heap.add(\"a\");\n-        heap.add(\"c\");\n-        heap.add(\"e\");\n-        heap.add(\"b\");\n-        heap.add(\"d\");\n-        heap.add(\"n\");\n-        heap.add(\"m\");\n-        heap.add(\"l\");\n-        heap.add(\"k\");\n-        heap.add(\"j\");\n-        heap.add(\"i\");\n-        heap.add(\"h\");\n-        heap.add(\"g\");\n-        heap.add(\"f\");\n+        PriorityBuffer<E> heap = new PriorityBuffer<E>();\n+        heap.add((E) \"a\");\n+        heap.add((E) \"c\");\n+        heap.add((E) \"e\");\n+        heap.add((E) \"b\");\n+        heap.add((E) \"d\");\n+        heap.add((E) \"n\");\n+        heap.add((E) \"m\");\n+        heap.add((E) \"l\");\n+        heap.add((E) \"k\");\n+        heap.add((E) \"j\");\n+        heap.add((E) \"i\");\n+        heap.add((E) \"h\");\n+        heap.add((E) \"g\");\n+        heap.add((E) \"f\");\n \n         assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n \n         } catch (BufferUnderflowException ex) {}\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testBasicComparatorOps() {\n-        PriorityBuffer heap = new PriorityBuffer(new ReverseComparator(new ComparableComparator()));\n+        PriorityBuffer<E> heap = new PriorityBuffer<E>(new ReverseComparator<E>((Comparator<E>) ComparableComparator.INSTANCE));\n \n         assertTrue(\"heap should be empty after create\", heap.isEmpty());\n \n             fail(\"NoSuchElementException should be thrown if remove is called before any elements are added\");\n         } catch (BufferUnderflowException ex) {}\n \n-        heap.add(\"a\");\n-        heap.add(\"c\");\n-        heap.add(\"e\");\n-        heap.add(\"b\");\n-        heap.add(\"d\");\n-        heap.add(\"n\");\n-        heap.add(\"m\");\n-        heap.add(\"l\");\n-        heap.add(\"k\");\n-        heap.add(\"j\");\n-        heap.add(\"i\");\n-        heap.add(\"h\");\n-        heap.add(\"g\");\n-        heap.add(\"f\");\n+        heap.add((E) \"a\");\n+        heap.add((E) \"c\");\n+        heap.add((E) \"e\");\n+        heap.add((E) \"b\");\n+        heap.add((E) \"d\");\n+        heap.add((E) \"n\");\n+        heap.add((E) \"m\");\n+        heap.add((E) \"l\");\n+        heap.add((E) \"k\");\n+        heap.add((E) \"j\");\n+        heap.add((E) \"i\");\n+        heap.add((E) \"h\");\n+        heap.add((E) \"g\");\n+        heap.add((E) \"f\");\n \n         assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n \n     }\n \n     /**\n-     * Illustrates bad internal heap state reported in Bugzilla PR #235818. \n-     */  \n+     * Illustrates bad internal heap state reported in Bugzilla PR #235818.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddRemove() {\n         resetEmpty();\n-        PriorityBuffer heap = (PriorityBuffer) collection;\n-        heap.add(new Integer(0));\n-        heap.add(new Integer(2));\n-        heap.add(new Integer(4));\n-        heap.add(new Integer(3));\n-        heap.add(new Integer(8));\n-        heap.add(new Integer(10));\n-        heap.add(new Integer(12));\n-        heap.add(new Integer(3));\n-        confirmed.addAll(heap);\n+        PriorityBuffer heap = getCollection();\n+        heap.add(0);\n+        heap.add(2);\n+        heap.add(4);\n+        heap.add(3);\n+        heap.add(8);\n+        heap.add(10);\n+        heap.add(12);\n+        heap.add(3);\n+        getConfirmed().addAll(heap);\n         // System.out.println(heap);\n-        Object obj = new Integer(10);\n-        heap.remove(obj);\n-        confirmed.remove(obj);\n+        heap.remove(10);\n+        getConfirmed().remove(10);\n         // System.out.println(heap);\n         verify();\n     }\n-    \n+\n     /**\n      * Generate heaps staring with Integers from 0 - heapSize - 1.\n      * Then perform random add / remove operations, checking\n         int heapSize = 100;\n         int operations = 20;\n         Random randGenerator = new Random();\n-        PriorityBuffer h = null;\n-        for(int i=0; i < iterations; i++) {\n-            if (i < iterations / 2) {          \n-                h = new PriorityBuffer(true);\n+        PriorityBuffer<Integer> h = null;\n+        for (int i = 0; i < iterations; i++) {\n+            if (i < iterations / 2) {\n+                h = new PriorityBuffer<Integer>(true);\n             } else {\n-                h = new PriorityBuffer(false);\n-            }\n-            for(int r = 0; r < heapSize; r++) {\n-                h.add( new Integer( randGenerator.nextInt(heapSize)) );\n-            }\n-            for( int r = 0; r < operations; r++ ) {\n+                h = new PriorityBuffer<Integer>(false);\n+            }\n+            for (int r = 0; r < heapSize; r++) {\n+                h.add(randGenerator.nextInt(heapSize));\n+            }\n+            for (int r = 0; r < operations; r++) {\n                 h.remove(new Integer(r));\n-                h.add(new Integer(randGenerator.nextInt(heapSize)));\n+                h.add(randGenerator.nextInt(heapSize));\n             }\n             checkOrder(h);\n         }\n     }\n-     \n+\n     /**\n      * Pops all elements from the heap and verifies that the elements come off\n      * in the correct order.  NOTE: this method empties the heap.\n      */\n-    protected void checkOrder(PriorityBuffer h) {\n+    protected void checkOrder(PriorityBuffer<?> h) {\n         Integer lastNum = null;\n         Integer num = null;\n         while (!h.isEmpty()) {\n             num = null;\n         }\n     }\n-    \n+\n     /**\n      * Returns a string showing the contents of the heap formatted as a tree.\n-     * Makes no attempt at padding levels or handling wrapping. \n-     */\n-    protected String showTree(PriorityBuffer h) {\n+     * Makes no attempt at padding levels or handling wrapping.\n+     */\n+    protected String showTree(PriorityBuffer<?> h) {\n         int count = 1;\n         StringBuffer buffer = new StringBuffer();\n         for (int offset = 1; count < h.size() + 1; offset *= 2) {\n             for (int i = offset; i < offset * 2; i++) {\n-                if (i < h.elements.length && h.elements[i] != null) \n+                if (i < h.elements.length && h.elements[i] != null)\n                     buffer.append(h.elements[i] + \" \");\n                 count++;\n             }\n      * Generates 500 randomly initialized heaps of size 100\n      * and tests that after serializing and restoring them to a byte array\n      * that the following conditions hold:\n-     * \n-     *  - the size of the restored heap is the same \n+     *\n+     *  - the size of the restored heap is the same\n      *      as the size of the orignal heap\n-     *  \n+     *\n      *  - all elements in the original heap are present in the restored heap\n-     *  \n-     *  - the heap order of the restored heap is intact as \n+     *\n+     *  - the heap order of the restored heap is intact as\n      *      verified by checkOrder()\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testSerialization() {\n         int iterations = 500;\n         int heapSize = 100;\n         Random randGenerator = new Random();\n         for (int i = 0; i < iterations; i++) {\n             if (i < iterations / 2) {\n-                h = new PriorityBuffer(true);\n+                h = new PriorityBuffer<E>(true);\n             } else {\n-                h = new PriorityBuffer(false);\n+                h = new PriorityBuffer<E>(false);\n             }\n             for (int r = 0; r < heapSize; r++) {\n                 h.add(new Integer(randGenerator.nextInt(heapSize)));\n             }\n             assertTrue(h.size() == heapSize);\n-            PriorityBuffer h1 = serializeAndRestore(h);\n+            PriorityBuffer<?> h1 = serializeAndRestore(h);\n             assertTrue(h1.size() == heapSize);\n-            Iterator hit = h.iterator();\n+            Iterator<?> hit = h.iterator();\n             while (hit.hasNext()) {\n                 Integer n = (Integer) hit.next();\n                 assertTrue(h1.contains(n));\n         }\n     }\n \n-    public PriorityBuffer serializeAndRestore(PriorityBuffer h) {\n-        PriorityBuffer h1 = null;\n+    public PriorityBuffer<?> serializeAndRestore(PriorityBuffer<E> h) {\n+        PriorityBuffer<?> h1 = null;\n         try {\n             byte[] objekt = writeExternalFormToBytes(h);\n-            h1 = (PriorityBuffer) readExternalFormFromBytes(objekt);\n+            h1 = (PriorityBuffer<?>) readExternalFormFromBytes(objekt);\n         } catch (IOException e) {\n             e.printStackTrace();\n             fail(e.toString());\n //        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/PriorityBuffer.fullCollection.version3.2.obj\");\n //    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public PriorityBuffer<E> getCollection() {\n+        return (PriorityBuffer<E>) super.getCollection();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n import org.apache.commons.collections.collection.AbstractTestCollection;\n \n /**\n- * Extension of {@link AbstractTestCollection} for exercising the \n+ * Extension of {@link AbstractTestCollection} for exercising the\n  * {@link SynchronizedBuffer} implementation.\n  *\n  * @since Commons Collections 3.1\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class TestSynchronizedBuffer extends AbstractTestCollection {\n-    \n+public class TestSynchronizedBuffer<E> extends AbstractTestCollection<E> {\n+\n     public TestSynchronizedBuffer(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestSynchronizedBuffer.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestSynchronizedBuffer.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    //-----------------------------------------------------------------------    \n-    public Collection makeCollection() {\n-        return SynchronizedBuffer.decorate(new UnboundedFifoBuffer());\n+    //-----------------------------------------------------------------------\n+    public Buffer<E> makeObject() {\n+        return SynchronizedBuffer.decorate(new UnboundedFifoBuffer<E>());\n     }\n-    \n-    public Collection makeFullCollection() {\n-        Buffer buffer = new UnboundedFifoBuffer();\n+\n+    public Collection<E> makeFullCollection() {\n+        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n         buffer.addAll(Arrays.asList(getFullElements()));\n         return SynchronizedBuffer.decorate(buffer);\n     }\n-    \n-    public Collection makeConfirmedCollection() {\n-        ArrayStack list = new ArrayStack();\n-        return list;\n+\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        ArrayStack list = new ArrayStack();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     public boolean isNullSupported() {\n         return false;\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }\n--- a/src/test/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n     }\n \n     public void testTransformedBuffer() {\n-        Buffer buffer = TransformedBuffer.decorate(new ArrayStack(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Buffer<Object> buffer = TransformedBuffer.decorate(new ArrayStack<Object>(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, buffer.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             buffer.add(els[i]);\n             assertEquals(i + 1, buffer.size());\n--- a/src/test/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Iterator;\n+import java.util.List;\n \n import junit.framework.Test;\n \n  *\n  * @author Unknown\n  */\n-public class TestUnboundedFifoBuffer extends AbstractTestCollection {\n+public class TestUnboundedFifoBuffer<E> extends AbstractTestCollection<E> {\n \n     public TestUnboundedFifoBuffer(String n) {\n         super(n);\n      */\n     public void verify() {\n         super.verify();\n-        Iterator iterator1 = collection.iterator();\n-        Iterator iterator2 = confirmed.iterator();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n         while (iterator2.hasNext()) {\n             assertTrue(iterator1.hasNext());\n             Object o1 = iterator1.next();\n      *\n      *  @return an empty ArrayList\n      */\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n \n     /**\n      *\n      *  @return a full ArrayList\n      */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection c = makeConfirmedCollection();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> c = makeConfirmedCollection();\n         c.addAll(java.util.Arrays.asList(getFullElements()));\n         return c;\n     }\n      *\n      *  @return an empty UnboundedFifoBuffer\n      */\n-    public Collection makeCollection() {\n-        return new UnboundedFifoBuffer(5);\n+    public Collection<E> makeObject() {\n+        return new UnboundedFifoBuffer<E>(5);\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testUnboundedFifoBufferRemove() {\n         resetFull();\n-        int size = confirmed.size();\n+        int size = getConfirmed().size();\n         for (int i = 0; i < size; i++) {\n-            Object o1 = ((UnboundedFifoBuffer)collection).remove();\n-            Object o2 = ((ArrayList)confirmed).remove(0);\n+            E o1 = getCollection().remove();\n+            E o2 = getConfirmed().remove(0);\n             assertEquals(\"Removed objects should be equal\", o1, o2);\n             verify();\n         }\n      */\n     public void testConstructorException1() {\n         try {\n-            new UnboundedFifoBuffer(0);\n+            new UnboundedFifoBuffer<E>(0);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n      */\n     public void testConstructorException2() {\n         try {\n-            new UnboundedFifoBuffer(-20);\n+            new UnboundedFifoBuffer<E>(-20);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateAdd() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(2);\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(2);\n         assertEquals(3, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(0, test.tail);\n-        test.add(\"A\");\n+        test.add((E) \"A\");\n         assertEquals(3, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(1, test.tail);\n-        test.add(\"B\");\n+        test.add((E) \"B\");\n         assertEquals(3, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(2, test.tail);\n-        test.add(\"C\");  // forces buffer increase\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(3, test.tail);\n-        test.add(\"D\");\n+        test.add((E) \"C\");  // forces buffer increase\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        test.add((E) \"D\");\n         assertEquals(5, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(4, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateAddWithWrap() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(0, test.tail);\n-        test.add(\"A\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(1, test.tail);\n-        test.add(\"B\");\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"A\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(1, test.tail);\n+        test.add((E) \"B\");\n         assertEquals(4, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(2, test.tail);\n-        test.add(\"C\");\n+        test.add((E) \"C\");\n         assertEquals(4, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(3, test.tail);\n         assertEquals(4, test.buffer.length);\n         assertEquals(2, test.head);\n         assertEquals(3, test.tail);\n-        test.add(\"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(2, test.head);\n-        assertEquals(0, test.tail);\n-        test.add(\"E\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(2, test.head);\n-        assertEquals(1, test.tail);\n-    }\n-\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateRemove1() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(4);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(3, test.tail);\n-        \n-        test.remove(\"A\");\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(3, test.tail);\n-        \n-        test.add(\"D\");\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.remove(\"A\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.add((E) \"D\");\n         assertEquals(5, test.buffer.length);\n         assertEquals(1, test.head);\n         assertEquals(4, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateRemove2() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(4);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n         assertEquals(5, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(3, test.tail);\n         assertEquals(0, test.head);\n         assertEquals(2, test.tail);\n         \n-        test.add(\"D\");\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(3, test.tail);\n-    }\n-\n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemove1() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(4);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(3, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         it.next();\n         it.remove();\n         assertEquals(5, test.buffer.length);\n         assertEquals(1, test.head);\n         assertEquals(3, test.tail);\n         \n-        test.add(\"D\");\n+        test.add((E) \"D\");\n         assertEquals(5, test.buffer.length);\n         assertEquals(1, test.head);\n         assertEquals(4, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemove2() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(4);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n-        \n-        Iterator it = test.iterator();\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        \n+        Iterator<E> it = test.iterator();\n         it.next();\n         it.next();\n         it.remove();\n         assertEquals(0, test.head);\n         assertEquals(2, test.tail);\n         \n-        test.add(\"D\");\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(3, test.tail);\n-    }\n-\n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithTailAtEnd1() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n-        test.remove(\"A\");\n-        test.add(\"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(0, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         assertEquals(\"B\", it.next());\n         it.remove();\n         assertEquals(4, test.buffer.length);\n         assertEquals(0, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithTailAtEnd2() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n-        test.remove(\"A\");\n-        test.add(\"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(0, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         assertEquals(\"B\", it.next());\n         assertEquals(\"C\", it.next());\n         it.remove();\n         assertEquals(3, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithTailAtEnd3() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n-        test.remove(\"A\");\n-        test.add(\"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(0, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         assertEquals(\"B\", it.next());\n         assertEquals(\"C\", it.next());\n         assertEquals(\"D\", it.next());\n         assertEquals(3, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithWrap1() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n         test.remove(\"A\");\n         test.remove(\"B\");\n-        test.add(\"D\");\n-        test.add(\"E\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(2, test.head);\n-        assertEquals(1, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         assertEquals(\"C\", it.next());\n         it.remove();\n         assertEquals(4, test.buffer.length);\n         assertEquals(1, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithWrap2() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n         test.remove(\"A\");\n         test.remove(\"B\");\n-        test.add(\"D\");\n-        test.add(\"E\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(2, test.head);\n-        assertEquals(1, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         assertEquals(\"C\", it.next());\n         assertEquals(\"D\", it.next());\n         it.remove();\n         assertEquals(0, test.tail);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithWrap3() {\n-        UnboundedFifoBuffer test = new UnboundedFifoBuffer(3);\n-        test.add(\"A\");\n-        test.add(\"B\");\n-        test.add(\"C\");\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n         test.remove(\"A\");\n         test.remove(\"B\");\n-        test.add(\"D\");\n-        test.add(\"E\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(2, test.head);\n-        assertEquals(1, test.tail);\n-        \n-        Iterator it = test.iterator();\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n         assertEquals(\"C\", it.next());\n         assertEquals(\"D\", it.next());\n         assertEquals(\"E\", it.next());\n //        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnboundedFifoBuffer.fullCollection.version3.1.obj\");\n //    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnboundedFifoBuffer<E> getCollection() {\n+        return (UnboundedFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n import org.apache.commons.collections.collection.AbstractTestCollection;\n \n /**\n- * Extension of {@link AbstractTestCollection} for exercising the \n+ * Extension of {@link AbstractTestCollection} for exercising the\n  * {@link UnmodifiableBuffer} implementation.\n  *\n  * @since Commons Collections 3.1\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableBuffer extends AbstractTestCollection {\n-    \n+public class TestUnmodifiableBuffer<E> extends AbstractTestCollection<E> {\n+\n     public TestUnmodifiableBuffer(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableBuffer.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableBuffer.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    //-----------------------------------------------------------------------    \n-    public Collection makeCollection() {\n-        return UnmodifiableBuffer.decorate(new UnboundedFifoBuffer());\n+    //-----------------------------------------------------------------------\n+    public Collection<E> makeObject() {\n+        return UnmodifiableBuffer.decorate(new UnboundedFifoBuffer<E>());\n     }\n-    \n-    public Collection makeFullCollection() {\n-        Buffer buffer = new UnboundedFifoBuffer();\n+\n+    public Collection<E> makeFullCollection() {\n+        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n         buffer.addAll(Arrays.asList(getFullElements()));\n         return UnmodifiableBuffer.decorate(buffer);\n     }\n-    \n-    public Collection makeConfirmedCollection() {\n-        ArrayStack list = new ArrayStack();\n-        return list;\n+\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        ArrayStack list = new ArrayStack();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     public boolean isAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isNullSupported() {\n         return false;\n     }\n-    \n+\n     public void testBufferRemove() {\n         resetEmpty();\n-        Buffer buffer = (Buffer) collection;\n         try {\n-            buffer.remove();\n+            getCollection().remove();\n             fail();\n         } catch (UnsupportedOperationException ex) {}\n     }\n //        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableBuffer.fullCollection.version3.1.obj\");\n //    }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Buffer<E> getCollection() {\n+        return (Buffer<E>) super.getCollection();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/comparators/TestBooleanComparator.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestBooleanComparator.java\n  *\n  * @author Rodney Waldhoff\n  */\n-public class TestBooleanComparator extends AbstractTestComparator {\n+public class TestBooleanComparator extends AbstractTestComparator<Boolean> {\n \n     // conventional\n     // ------------------------------------------------------------------------\n     // collections testing framework\n     // ------------------------------------------------------------------------\n \n-    public Comparator makeComparator() {\n+    public Comparator<Boolean> makeObject() {\n         return new BooleanComparator();\n     }\n \n-    public List getComparableObjectsOrdered() {\n-        List list = new ArrayList();\n+    public List<Boolean> getComparableObjectsOrdered() {\n+        List<Boolean> list = new ArrayList<Boolean>();\n         list.add(new Boolean(false));\n         list.add(Boolean.FALSE);\n         list.add(new Boolean(false));\n         list.add(Boolean.TRUE);\n         list.add(new Boolean(true));\n-        list.add(Boolean.TRUE);\n+        list.add(true);\n         return list;\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n     public void testConstructors() {\n         allTests(false,new BooleanComparator());\n         allTests(false,new BooleanComparator(false));\n-        allTests(true,new BooleanComparator(true));        \n+        allTests(true,new BooleanComparator(true));\n     }\n-    \n+\n     public void testStaticFactoryMethods() {\n         allTests(false,BooleanComparator.getFalseFirstComparator());\n         allTests(false,BooleanComparator.getBooleanComparator(false));\n         allTests(true,BooleanComparator.getTrueFirstComparator());\n         allTests(true,BooleanComparator.getBooleanComparator(true));\n     }\n-    \n+\n     public void testEqualsCompatibleInstance() {\n         assertEquals(new BooleanComparator(),new BooleanComparator(false));\n         assertEquals(new BooleanComparator(false),new BooleanComparator(false));\n         assertTrue(!(new BooleanComparator().equals(new BooleanComparator(true))));\n         assertTrue(!(new BooleanComparator(true).equals(new BooleanComparator(false))));\n     }\n-    \n+\n     // utilities\n     // ------------------------------------------------------------------------\n \n \n     protected void trueFirstTests(BooleanComparator comp) {\n         assertNotNull(comp);\n-        assertEquals(0,comp.compare(Boolean.TRUE,Boolean.TRUE));\n-        assertEquals(0,comp.compare(Boolean.FALSE,Boolean.FALSE));\n-        assertTrue(comp.compare(Boolean.FALSE,Boolean.TRUE) > 0);\n-        assertTrue(comp.compare(Boolean.TRUE,Boolean.FALSE) < 0);\n-\n-        assertEquals(0,comp.compare((Object)(Boolean.TRUE),(Object)(Boolean.TRUE)));\n-        assertEquals(0,comp.compare((Object)(Boolean.FALSE),(Object)(Boolean.FALSE)));\n-        assertTrue(comp.compare((Object)(Boolean.FALSE),(Object)(Boolean.TRUE)) > 0);\n-        assertTrue(comp.compare((Object)(Boolean.TRUE),(Object)(Boolean.FALSE)) < 0);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) > 0);\n+        assertTrue(comp.compare(true, false) < 0);\n     }\n \n     protected void falseFirstTests(BooleanComparator comp) {\n         assertNotNull(comp);\n-        assertEquals(0,comp.compare(Boolean.TRUE,Boolean.TRUE));\n-        assertEquals(0,comp.compare(Boolean.FALSE,Boolean.FALSE));\n-        assertTrue(comp.compare(Boolean.FALSE,Boolean.TRUE) < 0);\n-        assertTrue(comp.compare(Boolean.TRUE,Boolean.FALSE) > 0);\n-\n-        assertEquals(0,comp.compare((Object)(Boolean.TRUE),(Object)(Boolean.TRUE)));\n-        assertEquals(0,comp.compare((Object)(Boolean.FALSE),(Object)(Boolean.FALSE)));\n-        assertTrue(comp.compare((Object)(Boolean.FALSE),(Object)(Boolean.TRUE)) < 0);\n-        assertTrue(comp.compare((Object)(Boolean.TRUE),(Object)(Boolean.FALSE)) > 0);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) < 0);\n+        assertTrue(comp.compare(true, false) > 0);\n     }\n \n     protected void orderIndependentTests(BooleanComparator comp) {\n         nullArgumentTests(comp);\n-        nonBooleanArgumentTests(comp);\n-        nullAndNonBooleanArgumentsTests(comp);\n     }\n-    \n+\n     protected void nullArgumentTests(BooleanComparator comp) {\n         assertNotNull(comp);\n         try {\n             // expected\n         }\n     }\n-    \n-    protected void nonBooleanArgumentTests(BooleanComparator comp) {\n-        assertNotNull(comp);\n-        try {\n-            comp.compare(\"string\",\"string\");\n-            fail(\"Expected ClassCastException\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        }\n-        try {\n-            comp.compare(Boolean.TRUE,\"string\");\n-            fail(\"Expected ClassCastException\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        }\n-        try {\n-            comp.compare(\"string\",Boolean.TRUE);\n-            fail(\"Expected ClassCastException\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        }\n-        try {\n-            comp.compare(\"string\",new Integer(3));\n-            fail(\"Expected ClassCastException\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        }\n-        try {\n-            comp.compare(new Integer(3),\"string\");\n-            fail(\"Expected ClassCastException\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        }\n-    }\n-    \n-    protected void nullAndNonBooleanArgumentsTests(BooleanComparator comp) {\n-        assertNotNull(comp);\n-        try {\n-            comp.compare(null,\"string\");\n-            fail(\"Expected ClassCast or NullPointer Exception\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(NullPointerException e) {\n-            // expected\n-        }\n-        try {\n-            comp.compare(\"string\",null);\n-            fail(\"Expected ClassCast or NullPointer Exception\");\n-        } catch(ClassCastException e) {\n-            // expected\n-        } catch(NullPointerException e) {\n-            // expected\n-        }\n-    }\n \n }\n--- a/src/test/org/apache/commons/collections/comparators/TestComparableComparator.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestComparableComparator.java\n  *\n  * @author Unknown\n  */\n-public class TestComparableComparator extends AbstractTestComparator {\n+public class TestComparableComparator extends AbstractTestComparator<Integer> {\n \n     public TestComparableComparator(String testName) {\n         super(testName);\n         return new TestSuite(TestComparableComparator.class);\n     }\n \n-    public Comparator makeComparator() {\n-        return new ComparableComparator();\n+    public Comparator<Integer> makeObject() {\n+        return new ComparableComparator<Integer>();\n     }\n \n-    public List getComparableObjectsOrdered() {\n-        List list = new LinkedList();\n-        list.add(new Integer(1));\n-        list.add(new Integer(2));\n-        list.add(new Integer(3));\n-        list.add(new Integer(4));\n-        list.add(new Integer(5));\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        list.add(5);\n         return list;\n     }\n \n--- a/src/test/org/apache/commons/collections/comparators/TestComparatorChain.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestComparatorChain.java\n  *\n  * @author Unknown\n  */\n-public class TestComparatorChain extends AbstractTestComparator {\n+public class TestComparatorChain extends AbstractTestComparator<TestComparatorChain.PseudoRow> {\n \n     public TestComparatorChain(String testName) {\n         super(testName);\n         return new TestSuite(TestComparatorChain.class);\n     }\n \n-    public Comparator makeComparator() {\n-        ComparatorChain chain = new ComparatorChain(new ColumnComparator(0));\n-        chain.addComparator(new ColumnComparator(1),true); // reverse the second column\n-        chain.addComparator(new ColumnComparator(2),false);\n+    public Comparator<PseudoRow> makeObject() {\n+        ComparatorChain<PseudoRow> chain = new ComparatorChain<PseudoRow>(new ColumnComparator(0));\n+        chain.addComparator(new ColumnComparator(1), true); // reverse the second column\n+        chain.addComparator(new ColumnComparator(2), false);\n         return chain;\n     }\n \n     public void testNoopComparatorChain() {\n-        ComparatorChain chain = new ComparatorChain();\n-        Integer i1 = new Integer(4);\n-        Integer i2 = new Integer(6);\n-        chain.addComparator(new ComparableComparator());\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        chain.addComparator(new ComparableComparator<Integer>());\n \n         int correctValue = i1.compareTo(i2);\n-        assertTrue(\"Comparison returns the right order\",chain.compare(i1,i2) == correctValue);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n     }\n \n     public void testBadNoopComparatorChain() {\n-        ComparatorChain chain = new ComparatorChain();\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n         Integer i1 = new Integer(4);\n         Integer i2 = new Integer(6);\n         try {\n             chain.compare(i1,i2);\n             fail(\"An exception should be thrown when a chain contains zero comparators.\");\n         } catch (UnsupportedOperationException e) {\n-\n         }\n     }\n \n     public void testListComparatorChain() {\n-        List list = new LinkedList();\n-        list.add(new ComparableComparator());\n-        ComparatorChain chain = new ComparatorChain(list);\n+        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        list.add(new ComparableComparator<Integer>());\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n         Integer i1 = new Integer(4);\n         Integer i2 = new Integer(6);\n \n         int correctValue = i1.compareTo(i2);\n-        assertTrue(\"Comparison returns the right order\",chain.compare(i1,i2) == correctValue);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n     }\n \n     public void testBadListComparatorChain() {\n-        List list = new LinkedList();\n-        ComparatorChain chain = new ComparatorChain(list);\n+        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n         Integer i1 = new Integer(4);\n         Integer i2 = new Integer(6);\n         try {\n-            chain.compare(i1,i2);\n+            chain.compare(i1, i2);\n             fail(\"An exception should be thrown when a chain contains zero comparators.\");\n         } catch (UnsupportedOperationException e) {\n-\n-        }\n-    }\n-\n+        }\n+    }\n \n     public void testComparatorChainOnMinvaluedCompatator() {\n         // -1 * Integer.MIN_VALUE is less than 0,\n         // test that ComparatorChain handles this edge case correctly\n-        ComparatorChain chain = new ComparatorChain();\n-        chain.addComparator(\n-            new Comparator() {\n-                public int compare(Object a, Object b) {\n-                    int result = ((Comparable)a).compareTo(b);\n-                    if(result < 0) {\n-                        return Integer.MIN_VALUE;\n-                    } else if(result > 0) {\n-                        return Integer.MAX_VALUE;\n-                    } else {\n-                        return 0;\n-                    }\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        chain.addComparator(new Comparator<Integer>() {\n+            public int compare(Integer a, Integer b) {\n+                int result = a.compareTo(b);\n+                if (result < 0) {\n+                    return Integer.MIN_VALUE;\n                 }\n-            }, true);\n-\n-        assertTrue(chain.compare(new Integer(4), new Integer(5)) > 0);            \n-        assertTrue(chain.compare(new Integer(5), new Integer(4)) < 0);            \n-        assertTrue(chain.compare(new Integer(4), new Integer(4)) == 0);            \n-    }\n-\n-    public List getComparableObjectsOrdered() {\n-        List list = new LinkedList();\n+                if (result > 0) {\n+                    return Integer.MAX_VALUE;\n+                }\n+                return 0;\n+            }\n+        }, true);\n+\n+        assertTrue(chain.compare(new Integer(4), new Integer(5)) > 0);\n+        assertTrue(chain.compare(new Integer(5), new Integer(4)) < 0);\n+        assertTrue(chain.compare(new Integer(4), new Integer(4)) == 0);\n+    }\n+\n+    public List<PseudoRow> getComparableObjectsOrdered() {\n+        List<PseudoRow> list = new LinkedList<PseudoRow>();\n         // this is the correct order assuming a\n         // \"0th forward, 1st reverse, 2nd forward\" sort\n-        list.add(new PseudoRow(1,2,3));\n-        list.add(new PseudoRow(2,3,5));\n-        list.add(new PseudoRow(2,2,4));\n-        list.add(new PseudoRow(2,2,8));\n-        list.add(new PseudoRow(3,1,0));\n-        list.add(new PseudoRow(4,4,4));\n-        list.add(new PseudoRow(4,4,7));\n+        list.add(new PseudoRow(1, 2, 3));\n+        list.add(new PseudoRow(2, 3, 5));\n+        list.add(new PseudoRow(2, 2, 4));\n+        list.add(new PseudoRow(2, 2, 8));\n+        list.add(new PseudoRow(3, 1, 0));\n+        list.add(new PseudoRow(4, 4, 4));\n+        list.add(new PseudoRow(4, 4, 7));\n         return list;\n     }\n \n+    @SuppressWarnings(\"serial\")\n     public static class PseudoRow implements Serializable {\n \n         public int cols[] = new int[3];\n \n             if (getColumn(1) != row.getColumn(1)) {\n                 return false;\n-            }            \n-            \n+            }\n+\n             if (getColumn(2) != row.getColumn(2)) {\n                 return false;\n             }\n \n     }\n \n-    public static class ColumnComparator implements Comparator,Serializable {\n+    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {\n+        private static final long serialVersionUID = -2284880866328872105L;\n \n         protected int colIndex = 0;\n \n             this.colIndex = colIndex;\n         }\n \n-        public int compare(Object o1, Object o2) {\n-\n-            int col1 = ( (PseudoRow) o1).getColumn(colIndex);\n-            int col2 = ( (PseudoRow) o2).getColumn(colIndex);\n+        public int compare(PseudoRow o1, PseudoRow o2) {\n+\n+            int col1 = o1.getColumn(colIndex);\n+            int col2 = o2.getColumn(colIndex);\n \n             if (col1 > col2) {\n                 return 1;\n-            } else if (col1 < col2) {\n+            }\n+            if (col1 < col2) {\n                 return -1;\n             }\n-\n             return 0;\n         }\n-        \n+\n         public int hashCode() {\n             return colIndex;\n         }\n-        \n+\n         public boolean equals(Object that) {\n-            if(that instanceof ColumnComparator) {\n-                return colIndex == ((ColumnComparator)that).colIndex;\n-            } else {\n-                return false;\n-            }\n-        }\n-        \n-        private static final long serialVersionUID = -2284880866328872105L;\n+            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/collections/comparators/TestFixedOrderComparator.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestFixedOrderComparator.java\n  *\n  * @version $Revision$ $Date$\n  *\n- * @author David Leppik \n+ * @author David Leppik\n  * @author Stephen Colebourne\n  */\n public class TestFixedOrderComparator extends TestCase {\n-\n \n     /**\n      * Top cities of the world, by population including metro areas.\n         return new TestSuite(TestFixedOrderComparator.class);\n     }\n \n-    public static void main(String args[]) { \n+    public static void main(String args[]) {\n         junit.textui.TestRunner.run(suite());\n     }\n \n     // The tests\n     //\n \n-    /** \n-     * Tests that the constructor plus add method compares items properly. \n+    /**\n+     * Tests that the constructor plus add method compares items properly.\n      */\n     public void testConstructorPlusAdd() {\n-        FixedOrderComparator comparator = new FixedOrderComparator();\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n         for (int i = 0; i < topCities.length; i++) {\n             comparator.add(topCities[i]);\n         }\n         assertComparatorYieldsOrder(keys, comparator);\n     }\n \n-    /** \n-     * Tests that the array constructor compares items properly. \n+    /**\n+     * Tests that the array constructor compares items properly.\n      */\n     public void testArrayConstructor() {\n         String[] keys = (String[]) topCities.clone();\n         String[] topCitiesForTest = (String[]) topCities.clone();\n-        FixedOrderComparator comparator = new FixedOrderComparator(topCitiesForTest);\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n         assertComparatorYieldsOrder(keys, comparator);\n         // test that changing input after constructor has no effect\n         topCitiesForTest[0] = \"Brighton\";\n     }\n \n     /**\n-     * Tests the list constructor. \n+     * Tests the list constructor.\n      */\n     public void testListConstructor() {\n         String[] keys = (String[]) topCities.clone();\n-        List topCitiesForTest = new LinkedList(Arrays.asList(topCities));\n-        FixedOrderComparator comparator = new FixedOrderComparator(topCitiesForTest);\n+        List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n         assertComparatorYieldsOrder(keys, comparator);\n         // test that changing input after constructor has no effect\n         topCitiesForTest.set(0, \"Brighton\");\n      * Tests addAsEqual method.\n      */\n     public void testAddAsEqual() {\n-        FixedOrderComparator comparator = new FixedOrderComparator(topCities);\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n         comparator.addAsEqual(\"New York\", \"Minneapolis\");\n         assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n         assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n         assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n     }\n \n-    /** \n+    /**\n      * Tests whether or not updates are disabled after a comparison is made.\n      */\n     public void testLock() {\n-        FixedOrderComparator comparator = new FixedOrderComparator(topCities);\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n         assertEquals(false, comparator.isLocked());\n         comparator.compare(\"New York\", \"Tokyo\");\n         assertEquals(true, comparator.isLocked());\n     }\n \n     public void testUnknownObjectBehavior() {\n-        FixedOrderComparator comparator = new FixedOrderComparator(topCities);\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n         try {\n             comparator.compare(\"New York\", \"Minneapolis\");\n             fail(\"Should have thrown a IllegalArgumentException\");\n         } catch (IllegalArgumentException e) {\n             // success-- ignore\n         }\n-        assertEquals(FixedOrderComparator.UNKNOWN_THROW_EXCEPTION, comparator.getUnknownObjectBehavior());\n-\n-        comparator = new FixedOrderComparator(topCities);\n-        comparator.setUnknownObjectBehavior(FixedOrderComparator.UNKNOWN_BEFORE);\n-        assertEquals(FixedOrderComparator.UNKNOWN_BEFORE, comparator.getUnknownObjectBehavior());\n-        LinkedList keys = new LinkedList(Arrays.asList(topCities));\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());\n+        LinkedList<String> keys = new LinkedList<String>(Arrays.asList(topCities));\n         keys.addFirst(\"Minneapolis\");\n         assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n-        \n+\n         assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n         assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n         assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n \n-        comparator = new FixedOrderComparator(topCities);\n-        comparator.setUnknownObjectBehavior(FixedOrderComparator.UNKNOWN_AFTER);\n-        keys = new LinkedList(Arrays.asList(topCities));\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n+        keys = new LinkedList<String>(Arrays.asList(topCities));\n         keys.add(\"Minneapolis\");\n         assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n-        \n+\n         assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n         assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n         assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n-        \n-    }\n-    \n+\n+    }\n+\n     //\n     // Helper methods\n     //\n-    \n+\n     /** Shuffles the keys and asserts that the comparator sorts them back to\n      * their original order.\n      */\n-    private void assertComparatorYieldsOrder(Object[] orderedObjects, \n-                                             Comparator comparator) {\n-        Object[] keys = (Object[]) orderedObjects.clone();\n-        \n+    @SuppressWarnings(\"unused\")\n+    private void assertComparatorYieldsOrder(String[] orderedObjects,\n+                                             Comparator<String> comparator) {\n+        String[] keys = orderedObjects.clone();\n+\n         // shuffle until the order changes.  It's extremely rare that\n         // this requires more than one shuffle.\n \n             shuffle: {\n                 Random rand = new Random();\n                 for (int i = keys.length-1; i > 0; i--) {\n-                        Object swap = keys[i];\n+                        String swap = keys[i];\n                         int j = rand.nextInt(i+1);\n                         keys[i] = keys[j];\n-                        keys[j] = swap;     \n+                        keys[j] = swap;\n                     }\n             }\n-        \n+\n             testShuffle: {\n                 for (int i = 0; i < keys.length && !isInNewOrder; i++) {\n                     if( !orderedObjects[i].equals(keys[i])) {\n                 }\n             }\n         }\n-        \n+\n         // The real test:  sort and make sure they come out right.\n-        \n+\n         Arrays.sort(keys, comparator);\n \n         for (int i = 0; i < orderedObjects.length; i++) {\n             assertEquals(orderedObjects[i], keys[i]);\n         }\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/comparators/TestReverseComparator.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestReverseComparator.java\n  *\n  * @author Unknown\n  */\n-public class TestReverseComparator extends AbstractTestComparator {\n+public class TestReverseComparator extends AbstractTestComparator<Integer> {\n \n     public TestReverseComparator(String testName) {\n         super(testName);\n     }\n \n     /**\n-     * For the purposes of this test, return a \n+     * For the purposes of this test, return a\n      * ReverseComparator that wraps the java.util.Collections.reverseOrder()\n      * Comparator.  The resulting comparator should\n      * sort according to natural Order.  (Note: we wrap\n      * a Comparator taken from the JDK so that we can\n      * save a \"canonical\" form in SVN.\n-     * \n+     *\n      * @return Comparator that returns \"natural\" order\n      */\n-    public Comparator makeComparator() {\n-        return new ReverseComparator(Collections.reverseOrder());\n+    public Comparator<Integer> makeObject() {\n+        return new ReverseComparator<Integer>(Collections.<Integer>reverseOrder());\n     }\n \n-    public List getComparableObjectsOrdered() {\n-        List list = new LinkedList();\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n         list.add(new Integer(1));\n         list.add(new Integer(2));\n         list.add(new Integer(3));\n         return list;\n     }\n \n-    /** \n+    /**\n      * Override this inherited test since Collections.reverseOrder\n      * doesn't adhere to the \"soft\" Comparator contract, and we've\n      * already \"cannonized\" the comparator returned by makeComparator.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testSerializeDeserializeThenCompare() throws Exception {\n         Comparator comp = new ReverseComparator(new ComparableComparator());\n \n         ObjectOutputStream out = new ObjectOutputStream(buffer);\n         out.writeObject(comp);\n         out.close();\n-            \n+\n         ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n         Object dest = in.readObject();\n         in.close();\n--- a/src/test/org/apache/commons/collections/iterators/AbstractTestIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestIterator.java\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestIterator extends AbstractTestObject {\n+public abstract class AbstractTestIterator<E> extends AbstractTestObject {\n \n     /**\n      * JUnit constructor.\n      * \n      * @return an empty iterator\n      */\n-    public abstract Iterator makeEmptyIterator();\n-\n-    /**\n-     * Implement this method to return an iterator over a collection with elements.\n-     * \n-     * @return a full iterator\n-     */\n-    public abstract Iterator makeFullIterator();\n+    public abstract Iterator<E> makeEmptyIterator();\n \n     /**\n      * Implements the abstract superclass method to return the full iterator.\n      * \n      * @return a full iterator\n      */\n-    public Object makeObject() {\n-        return makeFullIterator();\n-    }\n+    public abstract Iterator<E> makeObject();\n \n     /**\n      * Whether or not we are testing an iterator that can be empty.\n             return;\n         }\n \n-        Iterator it = makeEmptyIterator();\n+        Iterator<E> it = makeEmptyIterator();\n         \n         // hasNext() should return false\n         assertEquals(\"hasNext() should return false for empty iterators\", false, it.hasNext());\n             return;\n         }\n \n-        Iterator it = makeFullIterator();\n+        Iterator<E> it = makeObject();\n \n         // hasNext() must be true (ensure makeFullIterator is correct!)\n         assertEquals(\"hasNext() should return true for at least one element\", true, it.hasNext());\n      * Test remove behaviour.\n      */\n     public void testRemove() {\n-        Iterator it = makeFullIterator();\n+        Iterator<E> it = makeObject();\n         \n         if (supportsRemove() == false) {\n             // check for UnsupportedOperationException if not supported\n--- a/src/test/org/apache/commons/collections/iterators/AbstractTestListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestListIterator.java\n package org.apache.commons.collections.iterators;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n  * @author Rodney Waldhoff\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestListIterator extends AbstractTestIterator {\n+public abstract class AbstractTestListIterator<E> extends AbstractTestIterator<E> {\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractTestListIterator(String testName) {\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Implement this method to return a list iterator over an empty collection.\n-     * \n+     * Implements the abstract superclass method to return the list iterator.\n+     *\n      * @return an empty iterator\n      */\n-    public abstract ListIterator makeEmptyListIterator();\n-\n-    /**\n-     * Implement this method to return a list iterator over a collection with elements.\n-     * \n+    public abstract ListIterator<E> makeEmptyIterator();\n+\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     *\n      * @return a full iterator\n      */\n-    public abstract ListIterator makeFullListIterator();\n-\n-    /**\n-     * Implements the abstract superclass method to return the list iterator.\n-     * \n-     * @return an empty iterator\n-     */\n-    public Iterator makeEmptyIterator() {\n-        return makeEmptyListIterator();\n-    }\n-\n-    /**\n-     * Implements the abstract superclass method to return the list iterator.\n-     * \n-     * @return a full iterator\n-     */\n-    public Iterator makeFullIterator() {\n-        return makeFullListIterator();\n-    }\n+    public abstract ListIterator<E> makeObject();\n \n     /**\n      * Whether or not we are testing an iterator that supports add().\n      * Default is true.\n-     * \n+     *\n      * @return true if Iterator supports add\n      */\n     public boolean supportsAdd() {\n     /**\n      * Whether or not we are testing an iterator that supports set().\n      * Default is true.\n-     * \n+     *\n      * @return true if Iterator supports set\n      */\n     public boolean supportsSet() {\n      * The value to be used in the add and set tests.\n      * Default is null.\n      */\n-    public Object addSetValue() {\n+    public E addSetValue() {\n         return null;\n     }\n \n             return;\n         }\n \n-        ListIterator it = makeEmptyListIterator();\n-        \n+        ListIterator<E> it = makeEmptyIterator();\n+\n         assertEquals(false, it.hasNext());\n         assertEquals(0, it.nextIndex());\n         assertEquals(false, it.hasPrevious());\n         assertEquals(-1, it.previousIndex());\n-        \n+\n         // next() should throw a NoSuchElementException\n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n         } catch (NoSuchElementException e) {\n         }\n-        \n+\n         // previous() should throw a NoSuchElementException\n         try {\n             it.previous();\n         } catch (NoSuchElementException e) {\n         }\n     }\n-    \n+\n     /**\n      * Test navigation through the iterator.\n      */\n     public void testWalkForwardAndBack() {\n-        ArrayList list = new ArrayList();\n-        ListIterator it = makeFullListIterator();\n+        ArrayList<E> list = new ArrayList<E>();\n+        ListIterator<E> it = makeObject();\n         while (it.hasNext()) {\n             list.add(it.next());\n         }\n-        \n+\n         // check state at end\n         assertEquals(false, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n             fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n         } catch (NoSuchElementException e) {\n         }\n-        \n+\n         // loop back through comparing\n         for (int i = list.size() - 1; i >= 0; i--) {\n             assertEquals(i + 1, it.nextIndex());\n             assertEquals(i, it.previousIndex());\n-        \n+\n             Object obj = list.get(i);\n             assertEquals(obj, it.previous());\n         }\n-        \n+\n         // check state at start\n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n         } catch (NoSuchElementException e) {\n         }\n     }\n-    \n+\n     /**\n      * Test add behaviour.\n      */\n     public void testAdd() {\n-        ListIterator it = makeFullListIterator();\n-        \n-        Object addValue = addSetValue();\n+        ListIterator<E> it = makeObject();\n+\n+        E addValue = addSetValue();\n         if (supportsAdd() == false) {\n             // check for UnsupportedOperationException if not supported\n             try {\n             } catch (UnsupportedOperationException ex) {}\n             return;\n         }\n-        \n+\n         // add at start should be OK, added should be previous\n-        it = makeFullListIterator();\n+        it = makeObject();\n         it.add(addValue);\n         assertEquals(addValue, it.previous());\n \n         // add at start should be OK, added should not be next\n-        it = makeFullListIterator();\n+        it = makeObject();\n         it.add(addValue);\n         assertTrue(addValue != it.next());\n \n         // add in middle and at end should be OK\n-        it = makeFullListIterator();\n+        it = makeObject();\n         while (it.hasNext()) {\n             it.next();\n             it.add(addValue);\n             // check add OK\n             assertEquals(addValue, it.previous());\n             it.next();\n-        }        \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Test set behaviour.\n      */\n     public void testSet() {\n-        ListIterator it = makeFullListIterator();\n-        \n+        ListIterator<E> it = makeObject();\n+\n         if (supportsSet() == false) {\n             // check for UnsupportedOperationException if not supported\n             try {\n             } catch (UnsupportedOperationException ex) {}\n             return;\n         }\n-        \n+\n         // should throw IllegalStateException before next() called\n         try {\n             it.set(addSetValue());\n             fail();\n         } catch (IllegalStateException ex) {}\n-        \n+\n         // set after next should be fine\n         it.next();\n         it.set(addSetValue());\n-        \n+\n         // repeated set calls should be fine\n         it.set(addSetValue());\n \n     }\n-    \n+\n     public void testRemoveThenSet() {\n-        ListIterator it = makeFullListIterator();\n+        ListIterator<E> it = makeObject();\n         if (supportsRemove() && supportsSet()) {\n             it.next();\n             it.remove();\n     }\n \n     public void testAddThenSet() {\n-        ListIterator it = makeFullListIterator();        \n+        ListIterator<E> it = makeObject();\n         // add then set\n         if (supportsAdd() && supportsSet()) {\n             it.next();\n             }\n         }\n     }\n-    \n+\n     /**\n      * Test remove after add behaviour.\n      */\n     public void testAddThenRemove() {\n-        ListIterator it = makeFullListIterator();\n-        \n+        ListIterator<E> it = makeObject();\n+\n         // add then remove\n         if (supportsAdd() && supportsRemove()) {\n             it.next();\n             }\n         }\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestMapIterator.java\n package org.apache.commons.collections.iterators;\n \n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Set;\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestMapIterator extends AbstractTestIterator {\n+public abstract class AbstractTestMapIterator<K, V> extends AbstractTestIterator<K> {\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractTestMapIterator(String testName) {\n     //-----------------------------------------------------------------------\n     /**\n      * Implement this method to return a map iterator over an empty map.\n-     * \n+     *\n      * @return an empty iterator\n      */\n-    public abstract MapIterator makeEmptyMapIterator();\n+    public abstract MapIterator<K, V> makeEmptyIterator();\n \n     /**\n      * Implement this method to return a map iterator over a map with elements.\n-     * \n+     *\n      * @return a full iterator\n      */\n-    public abstract MapIterator makeFullMapIterator();\n+    public abstract MapIterator<K, V> makeObject();\n \n     /**\n      * Implement this method to return the map which contains the same data as the\n      * iterator.\n-     * \n+     *\n      * @return a full map which can be updated\n      */\n-    public abstract Map getMap();\n-    \n+    public abstract Map<K, V> getMap();\n+\n     /**\n      * Implement this method to return the confirmed map which contains the same\n      * data as the iterator.\n-     * \n+     *\n      * @return a full map which can be updated\n      */\n-    public abstract Map getConfirmedMap();\n-    \n-    /**\n-     * Implements the abstract superclass method to return the list iterator.\n-     * \n-     * @return an empty iterator\n-     */\n-    public final Iterator makeEmptyIterator() {\n-        return makeEmptyMapIterator();\n-    }\n-\n-    /**\n-     * Implements the abstract superclass method to return the list iterator.\n-     * \n-     * @return a full iterator\n-     */\n-    public final Iterator makeFullIterator() {\n-        return makeFullMapIterator();\n-    }\n+    public abstract Map<K, V> getConfirmedMap();\n \n     /**\n      * Whether or not we are testing an iterator that supports setValue().\n      * Default is true.\n-     * \n+     *\n      * @return true if Iterator supports set\n      */\n     public boolean supportsSetValue() {\n     /**\n      * Whether the get operation on the map structurally modifies the map,\n      * such as with LRUMap. Default is false.\n-     * \n+     *\n      * @return true if the get method structurally modifies the map\n      */\n     public boolean isGetStructuralModify() {\n         return false;\n     }\n-    \n+\n     /**\n      * The values to be used in the add and set tests.\n      * Default is two strings.\n      */\n-    public Object[] addSetValues() {\n-        return new Object[] {\"A\", \"B\"};\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] addSetValues() {\n+        return (V[]) new Object[] { \"A\", \"B\" };\n     }\n \n     //-----------------------------------------------------------------------\n             return;\n         }\n \n-        MapIterator it = makeEmptyMapIterator();\n-        Map map = getMap();\n+        MapIterator<K, V> it = makeEmptyIterator();\n         assertEquals(false, it.hasNext());\n-        \n+\n         // next() should throw a NoSuchElementException\n         try {\n             it.next();\n             fail();\n         } catch (NoSuchElementException ex) {}\n-        \n+\n         // getKey() should throw an IllegalStateException\n         try {\n             it.getKey();\n             fail();\n         } catch (IllegalStateException ex) {}\n-        \n+\n         // getValue() should throw an IllegalStateException\n         try {\n             it.getValue();\n             fail();\n         } catch (IllegalStateException ex) {}\n-        \n+\n         if (supportsSetValue() == false) {\n             // setValue() should throw an UnsupportedOperationException/IllegalStateException\n             try {\n             return;\n         }\n \n-        MapIterator it = makeFullMapIterator();\n-        Map map = getMap();\n-        assertEquals(true, it.hasNext());\n-        \n-        assertEquals(true, it.hasNext());\n-        Set set = new HashSet();\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+        assertEquals(true, it.hasNext());\n+\n+        assertEquals(true, it.hasNext());\n+        Set<K> set = new HashSet<K>();\n         while (it.hasNext()) {\n             // getKey\n-            Object key = it.next();\n+            K key = it.next();\n             assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n             assertTrue(\"Key must be in map\",  map.containsKey(key));\n             assertTrue(\"Key must be unique\", set.add(key));\n-            \n+\n             // getValue\n-            Object value = it.getValue();\n+            V value = it.getValue();\n             if (isGetStructuralModify() == false) {\n                 assertSame(\"Value must be mapped to key\", map.get(key), value);\n             }\n             verify();\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testMapIteratorSet() {\n         if (supportsFullIterator() == false) {\n             return;\n         }\n \n-        Object newValue = addSetValues()[0];\n-        Object newValue2 = (addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1]);\n-        MapIterator it = makeFullMapIterator();\n-        Map map = getMap();\n-        Map confirmed = getConfirmedMap();\n-        assertEquals(true, it.hasNext());\n-        Object key = it.next();\n-        Object value = it.getValue();\n-        \n+        V newValue = addSetValues()[0];\n+        V newValue2 = (addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1]);\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+        Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+        V value = it.getValue();\n+\n         if (supportsSetValue() == false) {\n             try {\n                 it.setValue(newValue);\n             } catch (UnsupportedOperationException ex) {}\n             return;\n         }\n-        Object old = it.setValue(newValue);\n+        V old = it.setValue(newValue);\n         confirmed.put(key, newValue);\n         assertSame(\"Key must not change after setValue\", key, it.getKey());\n         assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n         assertSame(\"setValue must return old value\", value, old);\n         assertEquals(\"Map must contain key\", true, map.containsKey(key));\n         // test against confirmed, as map may contain value twice\n-        assertEquals(\"Map must not contain old value\", \n+        assertEquals(\"Map must not contain old value\",\n             confirmed.containsValue(old), map.containsValue(old));\n         assertEquals(\"Map must contain new value\", true, map.containsValue(newValue));\n         verify();\n-        \n+\n         it.setValue(newValue);  // same value - should be OK\n         confirmed.put(key, newValue);\n         assertSame(\"Key must not change after setValue\", key, it.getKey());\n         assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n         verify();\n-        \n+\n         it.setValue(newValue2);  // new value\n         confirmed.put(key, newValue2);\n         assertSame(\"Key must not change after setValue\", key, it.getKey());\n \n     //-----------------------------------------------------------------------\n     public void testRemove() { // override\n-        MapIterator it = makeFullMapIterator();\n-        Map map = getMap();\n-        Map confirmed = getConfirmedMap();\n-        assertEquals(true, it.hasNext());\n-        Object key = it.next();\n-        \n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+        Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n         if (supportsRemove() == false) {\n             try {\n                 it.remove();\n             }\n             return;\n         }\n-        \n+\n         it.remove();\n         confirmed.remove(key);\n         assertEquals(false, map.containsKey(key));\n         verify();\n-        \n+\n         try {\n             it.remove();  // second remove fails\n         } catch (IllegalStateException ex) {\n         if (supportsSetValue() == false || supportsRemove() == false) {\n             return;\n         }\n-        Object newValue = addSetValues()[0];\n-        MapIterator it = makeFullMapIterator();\n-        Map map = getMap();\n-        Map confirmed = getConfirmedMap();\n-        \n-        assertEquals(true, it.hasNext());\n-        Object key = it.next();\n-        \n+        V newValue = addSetValues()[0];\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n         it.setValue(newValue);\n         it.remove();\n         confirmed.remove(key);\n         verify();\n-        \n+\n         try {\n             it.setValue(newValue);\n             fail();\n         if (supportsRemove() == false) {\n             return;\n         }\n-        MapIterator it = makeFullMapIterator();\n-        Map map = getMap();\n-        Map confirmed = getConfirmedMap();\n-        \n-        assertEquals(true, it.hasNext());\n-        Object key = it.next();\n-        \n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n         it.remove();\n         confirmed.remove(key);\n         verify();\n-        \n+\n         try {\n             it.getKey();\n             fail();\n         if (supportsRemove() == false) {\n             return;\n         }\n-        MapIterator it = makeFullMapIterator();\n-        Map map = getMap();\n-        Map confirmed = getConfirmedMap();\n-        \n-        assertEquals(true, it.hasNext());\n-        Object key = it.next();\n-        \n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n         it.remove();\n         confirmed.remove(key);\n         verify();\n-        \n+\n         try {\n             it.getValue();\n             fail();\n--- a/src/test/org/apache/commons/collections/iterators/AbstractTestOrderedMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/AbstractTestOrderedMapIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestOrderedMapIterator extends AbstractTestMapIterator {\n+public abstract class AbstractTestOrderedMapIterator<K, V> extends AbstractTestMapIterator<K, V> {\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractTestOrderedMapIterator(String testName) {\n     }\n \n     //-----------------------------------------------------------------------\n-    public final OrderedMapIterator makeEmptyOrderedMapIterator() {\n-        return (OrderedMapIterator) makeEmptyMapIterator();\n-    }\n+    public abstract OrderedMapIterator<K, V> makeEmptyIterator();\n \n-    public final OrderedMapIterator makeFullOrderedMapIterator() {\n-        return (OrderedMapIterator) makeFullMapIterator();\n-    }\n-    \n+    public abstract OrderedMapIterator<K, V> makeObject();\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Test that the empty list iterator contract is correct.\n         }\n \n         super.testEmptyMapIterator();\n-        \n-        OrderedMapIterator it = makeEmptyOrderedMapIterator();\n-        Map map = getMap();\n+\n+        OrderedMapIterator<K, V> it = makeEmptyIterator();\n         assertEquals(false, it.hasPrevious());\n         try {\n             it.previous();\n         }\n \n         super.testFullMapIterator();\n-        \n-        OrderedMapIterator it = makeFullOrderedMapIterator();\n-        Map map = getMap();\n-        \n+\n+        OrderedMapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+\n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n-        Set set = new HashSet();\n+        Set<K> set = new HashSet<K>();\n         while (it.hasNext()) {\n             // getKey\n-            Object key = it.next();\n+            K key = it.next();\n             assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n             assertTrue(\"Key must be in map\",  map.containsKey(key));\n             assertTrue(\"Key must be unique\", set.add(key));\n-            \n+\n             // getValue\n-            Object value = it.getValue();\n+            V value = it.getValue();\n             if (isGetStructuralModify() == false) {\n                 assertSame(\"Value must be mapped to key\", map.get(key), value);\n             }\n             assertTrue(\"Value must be in map\",  map.containsValue(value));\n \n             assertEquals(true, it.hasPrevious());\n-            \n+\n             verify();\n         }\n         while (it.hasPrevious()) {\n             assertSame(\"it.previous() should equals getKey()\", key, it.getKey());\n             assertTrue(\"Key must be in map\",  map.containsKey(key));\n             assertTrue(\"Key must be unique\", set.remove(key));\n-            \n+\n             // getValue\n             Object value = it.getValue();\n             if (isGetStructuralModify() == false) {\n             assertTrue(\"Value must be in map\",  map.containsValue(value));\n \n             assertEquals(true, it.hasNext());\n-            \n+\n             verify();\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Test that the iterator order matches the keySet order.\n             return;\n         }\n \n-        OrderedMapIterator it = makeFullOrderedMapIterator();\n-        Map map = getMap();\n-        \n-        assertEquals(\"keySet() not consistent\", new ArrayList(map.keySet()), new ArrayList(map.keySet()));\n-        \n-        Iterator it2 = map.keySet().iterator();\n+        OrderedMapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+\n+        assertEquals(\"keySet() not consistent\", new ArrayList<K>(map.keySet()), new ArrayList<K>(map.keySet()));\n+\n+        Iterator<K> it2 = map.keySet().iterator();\n         assertEquals(true, it.hasNext());\n         assertEquals(true, it2.hasNext());\n-        List list = new ArrayList();\n+        List<K> list = new ArrayList<K>();\n         while (it.hasNext()) {\n-            Object key = it.next();\n+            K key = it.next();\n             assertEquals(it2.next(), key);\n             list.add(key);\n         }\n         assertEquals(map.size(), list.size());\n         while (it.hasPrevious()) {\n-            Object key = it.previous();\n+            K key = it.previous();\n             assertEquals(list.get(list.size() - 1), key);\n             list.remove(list.size() - 1);\n         }\n         assertEquals(0, list.size());\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/iterators/TestArrayIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestArrayIterator.java\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public class TestArrayIterator extends AbstractTestIterator {\n+public class TestArrayIterator<E> extends AbstractTestIterator<E> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n \n         super(testName);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return new ArrayIterator(new Object[0]);\n+    public ArrayIterator<E> makeEmptyIterator() {\n+        return new ArrayIterator<E>(new Object[0]);\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new ArrayIterator(testArray);\n+    public ArrayIterator<E> makeObject() {\n+        return new ArrayIterator<E>(testArray);\n     }\n \n     public boolean supportsRemove() {\n         return false;\n     }\n \n-\n     public void testIterator() {\n-        Iterator iter = (Iterator) makeFullIterator();\n+        Iterator<E> iter = makeObject();\n         for (int i = 0; i < testArray.length; i++) {\n             Object testValue = testArray[i];\n-            Object iterValue = iter.next();\n+            E iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n \n         try {\n-            Object testValue = iter.next();\n+            iter.next();\n         } catch (Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n \n     public void testNullArray() {\n         try {\n-            Iterator iter = new ArrayIterator(null);\n-\n+            new ArrayIterator<Object>(null);\n             fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n \n-        ArrayIterator iter = new ArrayIterator();\n+        ArrayIterator<Object> iter = new ArrayIterator<Object>();\n         try {\n             iter.setArray(null);\n \n     }\n     \n     public void testReset() {\n-        ArrayIterator it = (ArrayIterator) makeFullIterator();\n+        ArrayIterator<E> it = makeObject();\n         it.next();\n         it.reset();\n         assertEquals(\"One\", it.next());\n--- a/src/test/org/apache/commons/collections/iterators/TestArrayIterator2.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestArrayIterator2.java\n  * @author Morgan Delagrange\n  * @author James Strachan\n  */\n-public class TestArrayIterator2 extends AbstractTestIterator {\n+public class TestArrayIterator2<E> extends AbstractTestIterator<E> {\n \n     protected int[] testArray = { 2, 4, 6, 8 };\n \n         super(testName);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return new ArrayIterator(new int[0]);\n+    public ArrayIterator<E> makeEmptyIterator() {\n+        return new ArrayIterator<E>(new int[0]);\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new ArrayIterator(testArray);\n+    public ArrayIterator<E> makeObject() {\n+        return new ArrayIterator<E>(testArray);\n     }\n \n-    /*\n-     * We use these <code>makeArrayIterator</code> factory methods instead of\n-     * directly calling the constructor so as to allow subclasses\n-     * (e.g. TestArrayListIterator2) to use the existing test code.\n-     * \n-     * @return ArrayIterator\n-     */\n-    public ArrayIterator makeArrayIterator() {\n-        return (ArrayIterator) makeEmptyIterator();\n+    public ArrayIterator<E> makeArrayIterator(Object array) {\n+        return new ArrayIterator<E>(array);\n     }\n-    public ArrayIterator makeArrayIterator(Object array) {\n-        return new ArrayIterator(array);\n+\n+    public ArrayIterator<E> makeArrayIterator(Object array, int index) {\n+        return new ArrayIterator<E>(array, index);\n     }\n-    public ArrayIterator makeArrayIterator(Object array, int index) {\n-        return new ArrayIterator(array, index);\n-    }\n-    public ArrayIterator makeArrayIterator(Object array, int start, int end) {\n-        return new ArrayIterator(array, start, end);\n+\n+    public ArrayIterator<E> makeArrayIterator(Object array, int start, int end) {\n+        return new ArrayIterator<E>(array, start, end);\n     }\n \n     public boolean supportsRemove() {\n         return false;\n     }\n \n-\n     public void testIterator() {\n-        Iterator iter = (Iterator) makeFullIterator();\n+        Iterator<E> iter = makeObject();\n         for (int i = 0; i < testArray.length; i++) {\n             Integer testValue = new Integer(testArray[i]);\n             Number iterValue = (Number) iter.next();\n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n \n         try {\n-            Object testValue = iter.next();\n+            iter.next();\n         } catch (Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n     }\n \n     // proves that an ArrayIterator set with the constructor has the same number of elements\n-    // as an ArrayIterator set with setArray(Object) \n+    // as an ArrayIterator set with setArray(Object)\n     public void testSetArray() {\n-        Iterator iter1 = makeArrayIterator(testArray);\n+        Iterator<E> iter1 = makeArrayIterator(testArray);\n         int count1 = 0;\n         while (iter1.hasNext()) {\n             ++count1;\n \n         assertEquals(\"the count should be right using the constructor\", count1, testArray.length);\n \n-        ArrayIterator iter2 = makeArrayIterator();\n+        ArrayIterator<E> iter2 = makeObject();\n         iter2.setArray(testArray);\n         int count2 = 0;\n         while (iter2.hasNext()) {\n     }\n \n     public void testIndexedArray() {\n-        Iterator iter = makeArrayIterator(testArray, 2);\n+        Iterator<E> iter = makeArrayIterator(testArray, 2);\n         int count = 0;\n         while (iter.hasNext()) {\n             ++count;\n--- a/src/test/org/apache/commons/collections/iterators/TestArrayListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestArrayListIterator.java\n package org.apache.commons.collections.iterators;\n \n import java.util.Arrays;\n-import java.util.Iterator;\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n  * @version $Revision$ $Date$\n  * @author Neil O'Toole\n  */\n-public class TestArrayListIterator extends TestArrayIterator {\n+public class TestArrayListIterator<E> extends TestArrayIterator<E> {\n \n     public TestArrayListIterator(String testName) {\n         super(testName);\n         return new TestSuite(TestArrayListIterator.class);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return new ArrayListIterator(new Object[0]);\n+    public ArrayListIterator<E> makeEmptyIterator() {\n+        return new ArrayListIterator<E>(new Object[0]);\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new ArrayListIterator(testArray);\n+    public ArrayListIterator<E> makeObject() {\n+        return new ArrayListIterator<E>(testArray);\n     }\n \n-    public ListIterator makeArrayListIterator(Object array) {\n-        return new ArrayListIterator(array);\n+    public ArrayListIterator<E> makeArrayListIterator(Object array) {\n+        return new ArrayListIterator<E>(array);\n     }\n \n     public boolean supportsRemove() {\n      * <code>previous()</code>.\n      */\n     public void testListIterator() {\n-        ListIterator iter = (ListIterator) makeFullIterator();\n+        ListIterator<E> iter = makeObject();\n \n         // TestArrayIterator#testIterator() has already tested the iterator forward,\n         //  now we need to test it in reverse\n         assertTrue(\"Iterator should now be empty\", !iter.hasPrevious());\n \n         try {\n-            Object testValue = iter.previous();\n+            iter.previous();\n         } catch (Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n     /**\n      * Tests the {@link java.util.ListIterator#set} operation.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testListIteratorSet() {\n         String[] testData = new String[] { \"a\", \"b\", \"c\" };\n \n         String[] result = new String[] { \"0\", \"1\", \"2\" };\n \n-        ListIterator iter = (ListIterator) makeArrayListIterator(testData);\n+        ListIterator<E> iter = makeArrayListIterator(testData);\n         int x = 0;\n \n         while (iter.hasNext()) {\n             iter.next();\n-            iter.set(Integer.toString(x));\n+            iter.set((E) Integer.toString(x));\n             x++;\n         }\n \n         iter = makeArrayListIterator(testArray);\n \n         try {\n-            iter.set(\"should fail\");\n+            iter.set((E) \"should fail\");\n             fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n         } catch (IllegalStateException e) {\n             // expected\n--- a/src/test/org/apache/commons/collections/iterators/TestArrayListIterator2.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestArrayListIterator2.java\n  */\n package org.apache.commons.collections.iterators;\n \n-import java.util.Iterator;\n-\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n  * @version $Revision$ $Date$\n  * @author Neil O'Toole\n  */\n-public class TestArrayListIterator2 extends TestArrayIterator2 {\n+public class TestArrayListIterator2<E> extends TestArrayIterator2<E> {\n \n     public TestArrayListIterator2(String testName) {\n         super(testName);\n         return new TestSuite(TestArrayListIterator2.class);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return new ArrayListIterator(new int[0]);\n+    public ArrayListIterator<E> makeEmptyIterator() {\n+        return new ArrayListIterator<E>(new int[0]);\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new ArrayListIterator(testArray);\n+    public ArrayListIterator<E> makeObject() {\n+        return new ArrayListIterator<E>(testArray);\n     }\n \n-    public ArrayIterator makeArrayIterator() {\n-        return (ArrayIterator) makeEmptyIterator();\n+    public ArrayListIterator<E> makeArrayListIterator(Object array) {\n+        return new ArrayListIterator<E>(array);\n     }\n \n-    public ArrayIterator makeArrayIterator(Object array) {\n-        return new ArrayListIterator(array);\n+    public ArrayListIterator<E> makeArrayListIterator(Object array, int index) {\n+        return new ArrayListIterator<E>(array, index);\n     }\n \n-    public ArrayIterator makeArrayIterator(Object array, int index) {\n-        return new ArrayListIterator(array, index);\n-    }\n-\n-    public ArrayIterator makeArrayIterator(Object array, int start, int end) {\n-        return new ArrayListIterator(array, start, end);\n+    public ArrayListIterator<E> makeArrayListIterator(Object array, int start, int end) {\n+        return new ArrayListIterator<E>(array, start, end);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/iterators/TestCollatingIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestCollatingIterator.java\n \n import java.util.ArrayList;\n import java.util.Comparator;\n-import java.util.Iterator;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n  * @version $Revision$ $Date$\n  * @author Rodney Waldhoff\n  */\n-public class TestCollatingIterator extends AbstractTestIterator {\n+public class TestCollatingIterator extends AbstractTestIterator<Integer> {\n \n     //------------------------------------------------------------ Conventional\n-    \n+\n     public TestCollatingIterator(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestCollatingIterator.class);\n     }\n \n     //--------------------------------------------------------------- Lifecycle\n \n-    private Comparator comparator = null;\n-    private ArrayList evens = null; \n-    private ArrayList odds = null; \n-    private ArrayList fib = null; \n+    private Comparator<Integer> comparator = null;\n+    private ArrayList<Integer> evens = null;\n+    private ArrayList<Integer> odds = null;\n+    private ArrayList<Integer> fib = null;\n \n     public void setUp() throws Exception {\n         super.setUp();\n-        comparator = new ComparableComparator();\n-        evens = new ArrayList();\n-        odds = new ArrayList();\n-        for(int i=0;i<20;i++) {\n-            if(0 == i%2) {\n-                evens.add(new Integer(i));\n+        comparator = new ComparableComparator<Integer>();\n+        evens = new ArrayList<Integer>();\n+        odds = new ArrayList<Integer>();\n+        for (int i = 0; i < 20; i++) {\n+            if (0 == i % 2) {\n+                evens.add(i);\n             } else {\n-                odds.add(new Integer(i));\n+                odds.add(i);\n             }\n         }\n-        fib = new ArrayList();\n-        fib.add(new Integer(1));\n-        fib.add(new Integer(1));\n-        fib.add(new Integer(2));\n-        fib.add(new Integer(3));\n-        fib.add(new Integer(5));\n-        fib.add(new Integer(8));\n-        fib.add(new Integer(13));\n-        fib.add(new Integer(21));\n-    }       \n+        fib = new ArrayList<Integer>();\n+        fib.add(1);\n+        fib.add(1);\n+        fib.add(2);\n+        fib.add(3);\n+        fib.add(5);\n+        fib.add(8);\n+        fib.add(13);\n+        fib.add(21);\n+    }\n \n     //---------------------------------------------------- TestIterator Methods\n-    \n-    public Iterator makeEmptyIterator() {\n-        return new CollatingIterator(comparator);\n-    }\n-\n-    public Iterator makeFullIterator() {\n-        CollatingIterator iter = new CollatingIterator(comparator);\n+\n+    public CollatingIterator<Integer> makeEmptyIterator() {\n+        return new CollatingIterator<Integer>(comparator);\n+    }\n+\n+    public CollatingIterator<Integer> makeObject() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         iter.addIterator(odds.iterator());\n         iter.addIterator(fib.iterator());\n     //------------------------------------------------------------------- Tests\n \n     public void testGetSetComparator() {\n-        CollatingIterator iter = new CollatingIterator();\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>();\n         assertNull(iter.getComparator());\n         iter.setComparator(comparator);\n-        assertSame(comparator,iter.getComparator());\n+        assertSame(comparator, iter.getComparator());\n         iter.setComparator(null);\n         assertNull(iter.getComparator());\n     }\n \n     public void testIterateEven() {\n-        CollatingIterator iter = new CollatingIterator(comparator);\n-        iter.addIterator(evens.iterator());\n-        for(int i=0;i<evens.size();i++) {\n-            assertTrue(iter.hasNext());\n-            assertEquals(evens.get(i),iter.next());\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        for (int i = 0; i < evens.size(); i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n             assertEquals(0,iter.getIteratorIndex());\n         }\n         assertTrue(!iter.hasNext());\n     }\n \n     public void testIterateEvenOdd() {\n-        CollatingIterator iter = new CollatingIterator(comparator,evens.iterator(),odds.iterator());\n-        for(int i=0;i<20;i++) {\n-            assertTrue(iter.hasNext());\n-            assertEquals(new Integer(i),iter.next());\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, evens.iterator(), odds.iterator());\n+        for (int i = 0; i < 20; i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(new Integer(i), iter.next());\n             assertEquals(i % 2,iter.getIteratorIndex());\n         }\n         assertTrue(!iter.hasNext());\n     }\n \n     public void testIterateOddEven() {\n-        CollatingIterator iter = new CollatingIterator(comparator,odds.iterator(),evens.iterator());\n-        for(int i=0;i<20;i++) {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, odds.iterator(), evens.iterator());\n+        for (int i = 0; i < 20; i++) {\n             assertTrue(iter.hasNext());\n             assertEquals(new Integer(i),iter.next());\n             assertEquals((i % 2) == 0 ? 1 : 0,iter.getIteratorIndex());\n     }\n \n     public void testIterateEvenEven() {\n-        CollatingIterator iter = new CollatingIterator(comparator);\n-        iter.addIterator(evens.iterator());\n-        iter.addIterator(evens.iterator());\n-        for(int i=0;i<evens.size();i++) {\n-            assertTrue(iter.hasNext());\n-            assertEquals(evens.get(i),iter.next());\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(evens.iterator());\n+        for (int i = 0; i < evens.size(); i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n             assertEquals(0,iter.getIteratorIndex());\n             assertTrue(iter.hasNext());\n-            assertEquals(evens.get(i),iter.next());\n+            assertEquals(evens.get(i), iter.next());\n             assertEquals(1,iter.getIteratorIndex());\n         }\n         assertTrue(!iter.hasNext());\n     }\n \n-\n     public void testIterateFibEvenOdd() {\n-        CollatingIterator iter = new CollatingIterator(comparator);\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(fib.iterator());\n         iter.addIterator(evens.iterator());\n         iter.addIterator(odds.iterator());\n-        \n+\n         assertEquals(new Integer(0),iter.next());  // even   0\n         assertEquals(1,iter.getIteratorIndex());\n         assertEquals(new Integer(1),iter.next());  // fib    1\n     }\n \n     public void testRemoveFromSingle() {\n-        CollatingIterator iter = new CollatingIterator(comparator);\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         int expectedSize = evens.size();\n-        while(iter.hasNext()) {\n-            Integer val = (Integer)(iter.next());\n-            if(val.intValue() % 4 == 0) {\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            Integer val = (Integer) o;\n+            if (val.intValue() % 4 == 0) {\n                 expectedSize--;\n                 iter.remove();\n             }\n     }\n \n     public void testRemoveFromDouble() {\n-        CollatingIterator iter = new CollatingIterator(comparator);\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         iter.addIterator(odds.iterator());\n         int expectedSize = evens.size() + odds.size();\n-        while(iter.hasNext()) {\n-            Integer val = (Integer)(iter.next());\n-            if(val.intValue() % 4 == 0 || val.intValue() % 3 == 0 ) {\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            Integer val = (Integer) o;\n+            if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {\n                 expectedSize--;\n                 iter.remove();\n             }\n         }\n-        assertEquals(expectedSize,(evens.size() + odds.size()));\n-    }   \n+        assertEquals(expectedSize, (evens.size() + odds.size()));\n+    }\n \n }\n \n--- a/src/test/org/apache/commons/collections/iterators/TestFilterListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestFilterListIterator.java\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    private ArrayList list = null;\n-    private ArrayList odds = null;\n-    private ArrayList evens = null;\n-    private ArrayList threes = null;\n-    private ArrayList fours = null;\n-    private ArrayList sixes = null;\n-    private Predicate truePred = null;\n-    private Predicate falsePred = null;\n-    private Predicate evenPred = null;\n-    private Predicate oddPred = null;\n-    private Predicate threePred = null;\n-    private Predicate fourPred = null;\n+    private ArrayList<Integer> list = null;\n+    private ArrayList<Integer> odds = null;\n+    private ArrayList<Integer> evens = null;\n+    private ArrayList<Integer> threes = null;\n+    private ArrayList<Integer> fours = null;\n+    private ArrayList<Integer> sixes = null;\n+    private Predicate<Integer> truePred = null;\n+    private Predicate<Integer> falsePred = null;\n+    private Predicate<Integer> evenPred = null;\n+    private Predicate<Integer> oddPred = null;\n+    private Predicate<Integer> threePred = null;\n+    private Predicate<Integer> fourPred = null;\n     private Random random = new Random();\n \n     public void setUp() {\n-        list = new ArrayList();\n-        odds = new ArrayList();\n-        evens = new ArrayList();\n-        threes = new ArrayList();\n-        fours = new ArrayList();\n-        sixes = new ArrayList();\n-        for(int i=0;i<20;i++) {\n+        list = new ArrayList<Integer>();\n+        odds = new ArrayList<Integer>();\n+        evens = new ArrayList<Integer>();\n+        threes = new ArrayList<Integer>();\n+        fours = new ArrayList<Integer>();\n+        sixes = new ArrayList<Integer>();\n+        for (int i = 0; i < 20; i++) {\n             list.add(new Integer(i));\n-            if(i%2 == 0) { evens.add(new Integer(i)); }\n-            if(i%2 == 1) { odds.add(new Integer(i)); }\n-            if(i%3 == 0) { threes.add(new Integer(i)); }\n-            if(i%4 == 0) { fours.add(new Integer(i)); }\n-            if(i%6 == 0) { sixes.add(new Integer(i)); }\n-        }\n-\n-        truePred = new Predicate() {\n-            public boolean evaluate(Object x) { \n+            if (i % 2 == 0) { evens.add(new Integer(i)); }\n+            if (i % 2 == 1) { odds.add(new Integer(i)); }\n+            if (i % 3 == 0) { threes.add(new Integer(i)); }\n+            if (i % 4 == 0) { fours.add(new Integer(i)); }\n+            if (i % 6 == 0) { sixes.add(new Integer(i)); }\n+        }\n+\n+        truePred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n                 return true;\n             }\n         };\n \n-        falsePred = new Predicate() {\n-            public boolean evaluate(Object x) { \n+        falsePred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n                 return true;\n             }\n         };\n \n-        evenPred = new Predicate() {\n-            public boolean evaluate(Object x) { \n-                return (((Integer)x).intValue()%2 == 0);\n-            }\n-        };\n-\n-        oddPred = new Predicate() {\n-            public boolean evaluate(Object x) { \n-                return (((Integer)x).intValue()%2 == 1);\n-            }\n-        };\n-\n-        threePred = new Predicate() {\n-            public boolean evaluate(Object x) { \n-                return (((Integer)x).intValue()%3 == 0);\n-            }\n-        };\n-\n-        fourPred = new Predicate() {\n-            public boolean evaluate(Object x) { \n-                return (((Integer)x).intValue()%4 == 0);\n+        evenPred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 2 == 0;\n+            }\n+        };\n+\n+        oddPred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 2 == 1;\n+            }\n+        };\n+\n+        threePred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 3 == 0;\n+            }\n+        };\n+\n+        fourPred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 4 == 0;\n             }\n         };\n \n \n     public void testManual() {\n         // do this one \"by hand\" as a sanity check\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),threePred);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n         \n-        assertEquals(new Integer(0),filtered.next());\n-        assertEquals(new Integer(3),filtered.next());\n-        assertEquals(new Integer(6),filtered.next());\n-        assertEquals(new Integer(9),filtered.next());\n-        assertEquals(new Integer(12),filtered.next());\n-        assertEquals(new Integer(15),filtered.next());\n-        assertEquals(new Integer(18),filtered.next());\n-\n-        assertEquals(new Integer(18),filtered.previous());\n-        assertEquals(new Integer(15),filtered.previous());\n-        assertEquals(new Integer(12),filtered.previous());\n-        assertEquals(new Integer(9),filtered.previous());\n-        assertEquals(new Integer(6),filtered.previous());\n-        assertEquals(new Integer(3),filtered.previous());\n-        assertEquals(new Integer(0),filtered.previous());\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(18), filtered.next());\n+\n+        assertEquals(new Integer(18), filtered.previous());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(0), filtered.previous());\n     \n         assertTrue(!filtered.hasPrevious());\n \n-        assertEquals(new Integer(0),filtered.next());\n-        assertEquals(new Integer(3),filtered.next());\n-        assertEquals(new Integer(6),filtered.next());\n-        assertEquals(new Integer(9),filtered.next());\n-        assertEquals(new Integer(12),filtered.next());\n-        assertEquals(new Integer(15),filtered.next());\n-        assertEquals(new Integer(18),filtered.next());\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(18), filtered.next());\n \n         assertTrue(!filtered.hasNext());\n \n-        assertEquals(new Integer(18),filtered.previous());\n-        assertEquals(new Integer(15),filtered.previous());\n-        assertEquals(new Integer(12),filtered.previous());\n-        assertEquals(new Integer(9),filtered.previous());\n-        assertEquals(new Integer(6),filtered.previous());\n-        assertEquals(new Integer(3),filtered.previous());\n-        assertEquals(new Integer(0),filtered.previous());\n-\n-        assertEquals(new Integer(0),filtered.next());\n-        assertEquals(new Integer(0),filtered.previous());\n-        assertEquals(new Integer(0),filtered.next());\n-        \n-        assertEquals(new Integer(3),filtered.next());\n-        assertEquals(new Integer(6),filtered.next());\n-        assertEquals(new Integer(6),filtered.previous());\n-        assertEquals(new Integer(3),filtered.previous());\n-        assertEquals(new Integer(3),filtered.next());\n-        assertEquals(new Integer(6),filtered.next());\n-\n-        assertEquals(new Integer(9),filtered.next());\n-        assertEquals(new Integer(12),filtered.next());\n-        assertEquals(new Integer(15),filtered.next());\n-        assertEquals(new Integer(15),filtered.previous());\n-        assertEquals(new Integer(12),filtered.previous());\n-        assertEquals(new Integer(9),filtered.previous());\n-\n+        assertEquals(new Integer(18), filtered.previous());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(0), filtered.previous());\n+\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(0), filtered.previous());\n+        assertEquals(new Integer(0), filtered.next());\n+\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n     }\n \n     public void testTruePredicate() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),truePred);\n-        walkLists(list,filtered);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+        walkLists(list, filtered);\n     }\n     \n     public void testFalsePredicate() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),falsePred);\n-        walkLists(new ArrayList(),filtered);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), falsePred);\n+        walkLists(new ArrayList<Integer>(), filtered);\n     }\n \n     public void testEvens() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),evenPred);\n-        walkLists(evens,filtered);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), evenPred);\n+        walkLists(evens, filtered);\n     }\n     \n     public void testOdds() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),oddPred);\n-        walkLists(odds,filtered);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), oddPred);\n+        walkLists(odds, filtered);\n     }\n \n     public void testThrees() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),threePred);\n-        walkLists(threes,filtered);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        walkLists(threes, filtered);\n     }\n \n     public void testFours() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),fourPred);\n-        walkLists(fours,filtered);\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        walkLists(fours, filtered);\n     }\n \n     public void testNestedSixes() {\n-        FilterListIterator filtered = new FilterListIterator(\n-                                        new FilterListIterator(list.listIterator(),threePred),\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), threePred),\n                                         evenPred\n                                       );\n-        walkLists(sixes,filtered);\n+        walkLists(sixes, filtered);\n     }\n \n     public void testNestedSixes2() {\n-        FilterListIterator filtered = new FilterListIterator(\n-                                        new FilterListIterator(list.listIterator(),evenPred),\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), evenPred),\n                                         threePred\n                                       );\n-        walkLists(sixes,filtered);\n+        walkLists(sixes, filtered);\n     }\n \n     public void testNestedSixes3() {        \n-        FilterListIterator filtered = new FilterListIterator(\n-                                        new FilterListIterator(list.listIterator(),threePred),\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), threePred),\n                                         evenPred\n                                       );\n-        walkLists(sixes,new FilterListIterator(filtered,truePred));\n+        walkLists(sixes, new FilterListIterator<Integer>(filtered, truePred));\n     }\n \n     public void testNextChangesPrevious() {\n         {\n-            FilterListIterator filtered = new FilterListIterator(list.listIterator(),threePred);\n-            nextNextPrevious(threes.listIterator(),filtered);\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            nextNextPrevious(threes.listIterator(), filtered);\n         }\n     \n         {\n-            FilterListIterator filtered = new FilterListIterator(list.listIterator(),truePred);\n-            nextNextPrevious(list.listIterator(),filtered);\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            nextNextPrevious(list.listIterator(), filtered);\n         }\n     }\n \n     public void testPreviousChangesNext() {\n         {\n-            FilterListIterator filtered = new FilterListIterator(list.listIterator(),threePred);\n-            ListIterator expected = threes.listIterator();\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            ListIterator<Integer> expected = threes.listIterator();\n             walkForward(expected,filtered);\n             previousPreviousNext(expected,filtered);\n         }\n         {\n-            FilterListIterator filtered = new FilterListIterator(list.listIterator(),truePred);\n-            ListIterator expected = list.listIterator();\n-            walkForward(expected,filtered);\n-            previousPreviousNext(expected,filtered);\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            ListIterator<Integer> expected = list.listIterator();\n+            walkForward(expected, filtered);\n+            previousPreviousNext(expected, filtered);\n         }\n     }\n \n     public void testFailingHasNextBug() {\n-        FilterListIterator filtered = new FilterListIterator(list.listIterator(),fourPred);\n-        ListIterator expected = fours.listIterator();\n-        while(expected.hasNext()) {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        ListIterator<Integer> expected = fours.listIterator();\n+        while (expected.hasNext()) {\n             expected.next();\n             filtered.next();\n         }\n         assertTrue(filtered.hasPrevious());\n         assertTrue(!filtered.hasNext());\n-        assertEquals(expected.previous(),filtered.previous());\n+        assertEquals(expected.previous(), filtered.previous());\n     }\n \n     // Utilities\n \n-    private void walkForward(ListIterator expected, ListIterator testing) {\n-        while(expected.hasNext()) {\n-            assertEquals(expected.nextIndex(),testing.nextIndex());\n-            assertEquals(expected.previousIndex(),testing.previousIndex());\n+    private void walkForward(ListIterator<?> expected, ListIterator<?> testing) {\n+        while (expected.hasNext()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n             assertTrue(testing.hasNext());\n-            assertEquals(expected.next(),testing.next());\n-        }\n-    }\n-\n-    private void walkBackward(ListIterator expected, ListIterator testing) {\n-        while(expected.hasPrevious()) {\n-            assertEquals(expected.nextIndex(),testing.nextIndex());\n-            assertEquals(expected.previousIndex(),testing.previousIndex());\n+            assertEquals(expected.next(), testing.next());\n+        }\n+    }\n+\n+    private void walkBackward(ListIterator<?> expected, ListIterator<?> testing) {\n+        while (expected.hasPrevious()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n             assertTrue(testing.hasPrevious());\n-            assertEquals(expected.previous(),testing.previous());\n-        }\n-    }\n-\n-    private void nextNextPrevious(ListIterator expected, ListIterator testing) {\n+            assertEquals(expected.previous(), testing.previous());\n+        }\n+    }\n+\n+    private void nextNextPrevious(ListIterator<?> expected, ListIterator<?> testing) {\n         // calls to next() should change the value returned by previous()\n         // even after previous() has been set by a call to hasPrevious()\n-        assertEquals(expected.next(),testing.next());\n-        assertEquals(expected.hasPrevious(),testing.hasPrevious());\n+        assertEquals(expected.next(), testing.next());\n+        assertEquals(expected.hasPrevious(), testing.hasPrevious());\n         Object expecteda = expected.next();\n         Object testinga = testing.next();\n-        assertEquals(expecteda,testinga);\n+        assertEquals(expecteda, testinga);\n         Object expectedb = expected.previous();\n         Object testingb = testing.previous();\n-        assertEquals(expecteda,expectedb);\n-        assertEquals(testinga,testingb);\n-    }\n-\n-    private void previousPreviousNext(ListIterator expected, ListIterator testing) {\n+        assertEquals(expecteda, expectedb);\n+        assertEquals(testinga, testingb);\n+    }\n+\n+    private void previousPreviousNext(ListIterator<?> expected, ListIterator<?> testing) {\n         // calls to previous() should change the value returned by next()\n         // even after next() has been set by a call to hasNext()\n-        assertEquals(expected.previous(),testing.previous());\n-        assertEquals(expected.hasNext(),testing.hasNext());\n+        assertEquals(expected.previous(), testing.previous());\n+        assertEquals(expected.hasNext(), testing.hasNext());\n         Object expecteda = expected.previous();\n         Object testinga = testing.previous();\n-        assertEquals(expecteda,testinga);\n+        assertEquals(expecteda, testinga);\n         Object expectedb = expected.next();\n         Object testingb = testing.next();\n-        assertEquals(expecteda,testingb);\n-        assertEquals(expecteda,expectedb);\n-        assertEquals(testinga,testingb);\n-    }\n-\n-    private void walkLists(List list, ListIterator testing) {\n-        ListIterator expected = list.listIterator();\n+        assertEquals(expecteda, testingb);\n+        assertEquals(expecteda, expectedb);\n+        assertEquals(testinga, testingb);\n+    }\n+\n+    private <E> void walkLists(List<E> list, ListIterator<E> testing) {\n+        ListIterator<E> expected = list.listIterator();\n \n         // walk all the way forward\n         walkForward(expected,testing);\n         walkBackward(expected,testing);\n \n         // forward,back,forward\n-        while(expected.hasNext()) {\n-            assertEquals(expected.nextIndex(),testing.nextIndex());\n-            assertEquals(expected.previousIndex(),testing.previousIndex());\n+        while (expected.hasNext()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n             assertTrue(testing.hasNext());\n-            assertEquals(expected.next(),testing.next());\n+            assertEquals(expected.next(), testing.next());\n             assertTrue(testing.hasPrevious());\n-            assertEquals(expected.previous(),testing.previous());\n+            assertEquals(expected.previous(), testing.previous());\n             assertTrue(testing.hasNext());\n-            assertEquals(expected.next(),testing.next());\n-        }\n-\n+            assertEquals(expected.next(), testing.next());\n+        }\n \n         // walk all the way back\n-        walkBackward(expected,testing);\n-\n-        for(int i=0;i<list.size();i++) {\n+        walkBackward(expected, testing);\n+\n+        for (int i = 0; i < list.size(); i++) {\n             // walk forward i\n-            for(int j=0;j<i;j++) {\n-                assertEquals(expected.nextIndex(),testing.nextIndex());\n-                assertEquals(expected.previousIndex(),testing.previousIndex());\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n                 assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n                 assertTrue(testing.hasNext());\n-                assertEquals(expected.next(),testing.next());\n+                assertEquals(expected.next(), testing.next());\n             }\n             // walk back i/2\n-            for(int j=0;j<i/2;j++) {\n-                assertEquals(expected.nextIndex(),testing.nextIndex());\n-                assertEquals(expected.previousIndex(),testing.previousIndex());\n+            for (int j = 0; j < i / 2; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n                 assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n                 assertTrue(testing.hasPrevious());\n-                assertEquals(expected.previous(),testing.previous());\n+                assertEquals(expected.previous(), testing.previous());\n             }\n             // walk forward i/2\n-            for(int j=0;j<i/2;j++) {\n-                assertEquals(expected.nextIndex(),testing.nextIndex());\n-                assertEquals(expected.previousIndex(),testing.previousIndex());\n+            for (int j = 0; j < i / 2; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n                 assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n                 assertTrue(testing.hasNext());\n-                assertEquals(expected.next(),testing.next());\n+                assertEquals(expected.next(), testing.next());\n             }\n             // walk back i\n-            for(int j=0;j<i;j++) {\n-                assertEquals(expected.nextIndex(),testing.nextIndex());\n-                assertEquals(expected.previousIndex(),testing.previousIndex());\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n                 assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n                 assertTrue(testing.hasPrevious());\n-                assertEquals(expected.previous(),testing.previous());\n+                assertEquals(expected.previous(), testing.previous());\n             }\n         }\n \n         // random walk\n         StringBuffer walkdescr = new StringBuffer(500);\n-        for(int i=0;i<500;i++) {\n-            if(random.nextBoolean()) {\n+        for (int i = 0; i < 500; i++) {\n+            if (random.nextBoolean()) {\n                 // step forward\n                 walkdescr.append(\"+\");\n-                if(expected.hasNext()) {\n-                    assertEquals(walkdescr.toString(),expected.next(),testing.next());\n+                if (expected.hasNext()) {\n+                    assertEquals(walkdescr.toString(), expected.next(), testing.next());\n                 }\n             } else {\n                 // step backward\n                 walkdescr.append(\"-\");\n-                if(expected.hasPrevious()) {\n-                    assertEquals(walkdescr.toString(),expected.previous(),testing.previous());\n+                if (expected.hasPrevious()) {\n+                    assertEquals(walkdescr.toString(), expected.previous(), testing.previous());\n                 }\n             }\n-            assertEquals(walkdescr.toString(),expected.nextIndex(),testing.nextIndex());\n-            assertEquals(walkdescr.toString(),expected.previousIndex(),testing.previousIndex());\n+            assertEquals(walkdescr.toString(), expected.nextIndex(), testing.nextIndex());\n+            assertEquals(walkdescr.toString(), expected.previousIndex(), testing.previousIndex());\n         }\n \n     }\n--- a/src/test/org/apache/commons/collections/iterators/TestIteratorChain.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestIteratorChain.java\n  * @author Mauricio S. Moura\n  * @author Morgan Delagrange\n  */\n-public class TestIteratorChain extends AbstractTestIterator {\n+public class TestIteratorChain extends AbstractTestIterator<String> {\n \n     protected String[] testArray = {\n         \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n     };\n \n-    protected List list1 = null;\n-    protected List list2 = null;\n-    protected List list3 = null;\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n \n     public static Test suite() {\n         return new TestSuite(TestIteratorChain.class);\n     }\n \n     public void setUp() {\n-        list1 = new ArrayList();\n+        list1 = new ArrayList<String>();\n         list1.add(\"One\");\n         list1.add(\"Two\");\n         list1.add(\"Three\");\n-        list2 = new ArrayList();\n+        list2 = new ArrayList<String>();\n         list2.add(\"Four\");\n-        list3 = new ArrayList();\n+        list3 = new ArrayList<String>();\n         list3.add(\"Five\");\n         list3.add(\"Six\");        \n     }\n \n-    public Iterator makeEmptyIterator() {\n-        ArrayList list = new ArrayList();\n-        return new IteratorChain(list.iterator());\n+    public IteratorChain<String> makeEmptyIterator() {\n+        ArrayList<String> list = new ArrayList<String>();\n+        return new IteratorChain<String>(list.iterator());\n     }\n \n-    public Iterator makeFullIterator() {\n-        IteratorChain chain = new IteratorChain();\n+    public IteratorChain<String> makeObject() {\n+        IteratorChain<String> chain = new IteratorChain<String>();\n \n         chain.addIterator(list1.iterator());\n         chain.addIterator(list2.iterator());\n     }\n \n     public void testIterator() {\n-        Iterator iter = (Iterator) makeFullIterator();\n-        for ( int i = 0; i < testArray.length; i++ ) {\n+        Iterator<String> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n             Object testValue = testArray[i];            \n             Object iterValue = iter.next();\n \n             assertEquals( \"Iteration value is correct\", testValue, iterValue );\n         }\n \n-        assertTrue(\"Iterator should now be empty\", ! iter.hasNext() );\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n \n         try {\n-            Object testValue = iter.next();\n+            iter.next();\n         } catch (Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\", \n                        e.getClass().equals((new NoSuchElementException()).getClass()));\n \n     public void testRemoveFromFilteredIterator() {\n \n-        final Predicate myPredicate = new Predicate() {\n-            public boolean evaluate( Object object ) {\n-                Integer i = (Integer) object;\n-                if (i.compareTo(new Integer(4)) < 0)\n-                    return true;\n-                return false;\n+        final Predicate<Integer> myPredicate = new Predicate<Integer>() {\n+            public boolean evaluate(Integer i) {\n+                return i.compareTo(new Integer(4)) < 0;\n             }\n         };\n \n-        List list1 = new ArrayList();\n-        List list2 = new ArrayList();\n+        List<Integer> list1 = new ArrayList<Integer>();\n+        List<Integer> list2 = new ArrayList<Integer>();\n \n         list1.add(new Integer(1));\n         list1.add(new Integer(2));\n         list2.add(new Integer(3));\n         list2.add(new Integer(4)); // will be ignored by the predicate\n \n-        Iterator it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate );\n-        Iterator it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate );\n+        Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n+        Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n \n-        Iterator it = IteratorUtils.chainedIterator(it1, it2);\n+        Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n         while (it.hasNext()) {\n             it.next();\n             it.remove();\n         }\n-        assertEquals( 0, list1.size() );\n-        assertEquals( 1, list2.size() );\n-\n+        assertEquals(0, list1.size());\n+        assertEquals(1, list2.size());\n     }\n     \n     public void testRemove() {\n-        Iterator iter = (Iterator) makeFullIterator();\n+        Iterator<String> iter = makeObject();\n \n         try {\n             iter.remove();\n \n         }\n \n-        for ( int i = 0; i < testArray.length; i++ ) {\n-            Object testValue = testArray[i];            \n-            Object iterValue = iter.next();\n+        for (int i = 0; i < testArray.length; i++) {\n+            String testValue = testArray[i];            \n+            String iterValue = iter.next();\n \n-            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n \n-            if (! iterValue.equals(\"Four\")) {\n+            if (!iterValue.equals(\"Four\")) {\n                 iter.remove();\n             }\n         }\n     }\n \n     public void testFirstIteratorIsEmptyBug() {\n-        List empty = new ArrayList();\n-        List notEmpty = new ArrayList();\n+        List<String> empty = new ArrayList<String>();\n+        List<String> notEmpty = new ArrayList<String>();\n         notEmpty.add(\"A\");\n         notEmpty.add(\"B\");\n         notEmpty.add(\"C\");\n-        IteratorChain chain = new IteratorChain();\n+        IteratorChain<String> chain = new IteratorChain<String>();\n         chain.addIterator(empty.iterator());\n         chain.addIterator(notEmpty.iterator());\n         assertTrue(\"should have next\",chain.hasNext());\n     }\n     \n     public void testEmptyChain() {\n-        IteratorChain chain = new IteratorChain();\n+        IteratorChain<Object> chain = new IteratorChain<Object>();\n         assertEquals(false, chain.hasNext());\n         try {\n             chain.next();\n--- a/src/test/org/apache/commons/collections/iterators/TestLoopingIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestLoopingIterator.java\n      */\n     public void testConstructorEx() throws Exception {\n         try {\n-            new LoopingIterator(null);\n+            new LoopingIterator<Object>(null);\n             fail();\n         } catch (NullPointerException ex) {\n         }\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping0() throws Exception {\n-        List list = new ArrayList();\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<Object> list = new ArrayList<Object>();\n+        LoopingIterator<Object> loop = new LoopingIterator<Object>(list);\n         assertTrue(\"hasNext should return false\", loop.hasNext() == false);\n \n         try {\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping1() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\" }));\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<String> list = Arrays.asList(new String[] { \"a\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         assertEquals(\"a\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping2() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         assertEquals(\"a\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping3() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         assertEquals(\"a\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testRemoving1() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n         assertEquals(\"list should have 3 elements.\", 3, list.size());\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testReset() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertEquals(\"a\", loop.next());\n         assertEquals(\"b\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testSize() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingIterator loop = new LoopingIterator(list);\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertEquals(3, loop.size());\n         loop.next();\n--- a/src/test/org/apache/commons/collections/iterators/TestLoopingListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestLoopingListIterator.java\n      */\n     public void testConstructorEx() throws Exception {\n         try {\n-            new LoopingListIterator(null);\n+            new LoopingListIterator<Object>(null);\n             fail();\n         } catch (NullPointerException ex) {\n         }\n      * Tests whether an empty looping list iterator works.\n      */\n     public void testLooping0() throws Exception {\n-        List list = new ArrayList();\n-        LoopingListIterator loop = new LoopingListIterator(list);\n+        List<Object> list = new ArrayList<Object>();\n+        LoopingListIterator<Object> loop = new LoopingListIterator<Object>(list);\n         assertFalse(loop.hasNext());\n         assertFalse(loop.hasPrevious());\n         \n      * one element.\n      */\n     public void testLooping1() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a>\n+        List<String> list = Arrays.asList(new String[] { \"a\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a>\n \n         assertTrue(loop.hasNext());\n         assertEquals(\"a\", loop.next());     // <a>\n      * elements.\n      */\n     public void testLooping2() throws Exception {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n \n         assertTrue(loop.hasNext());\n         assertEquals(\"a\", loop.next());     // a <b>\n      * the begin/end boundary of the list.\n      */\n     public void testJoggingNotOverBoundary() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n     \n         // Try jogging back and forth between the elements, but not\n         // over the begin/end boundary.\n      * begin/end boundary of the list.\n      */\n     public void testJoggingOverBoundary() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n     \n         // Try jogging back and forth between the elements, but not\n         // over the begin/end boundary.\n      * Tests removing an element from a wrapped ArrayList.\n      */\n     public void testRemovingElementsAndIteratingForward() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertTrue(loop.hasNext());\n         assertEquals(\"a\", loop.next()); // a <b> c\n      * Tests removing an element from a wrapped ArrayList.\n      */\n     public void testRemovingElementsAndIteratingBackwards() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertTrue(loop.hasPrevious());\n         assertEquals(\"c\", loop.previous()); // a b <c>\n      * Tests the reset method.\n      */\n     public void testReset() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertEquals(\"a\", loop.next()); // a <b> c\n         assertEquals(\"b\", loop.next()); // a b <c>\n      * Tests the add method.\n      */\n     public void testAdd() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <b> e f\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <b> e f\n \n         loop.add(\"a\");                      // <a> b e f\n         assertEquals(\"b\", loop.next());     // a <b> e f\n         assertEquals(\"f\", loop.next());     // <a> b c d e f\n         assertEquals(\"a\", loop.next());     // a <b> c d e f\n \n-        list = new ArrayList(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n-        loop = new LoopingListIterator(list); // <b> e f        \n+        list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        loop = new LoopingListIterator<String>(list); // <b> e f        \n \n         loop.add(\"a\");                      // a <b> e f\n         assertEquals(\"a\", loop.previous()); // a b e <f>\n      * Tests nextIndex and previousIndex.\n      */\n     public void testNextAndPreviousIndex() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <a> b c\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertEquals(0, loop.nextIndex());\n         assertEquals(2, loop.previousIndex());\n      * Tests using the set method to change elements.\n      */\n     public void testSet() {\n-        List list = new ArrayList(Arrays.asList(new String[] { \"q\", \"r\", \"z\" }));\n-        LoopingListIterator loop = new LoopingListIterator(list); // <q> r z\n+        List<String> list = Arrays.asList(new String[] { \"q\", \"r\", \"z\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <q> r z\n \n         assertEquals(\"z\", loop.previous()); // q r <z>\n         loop.set(\"c\");                      // q r <c>\n--- a/src/test/org/apache/commons/collections/iterators/TestObjectArrayIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestObjectArrayIterator.java\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public class TestObjectArrayIterator extends AbstractTestIterator {\n+public class TestObjectArrayIterator<E> extends AbstractTestIterator<E> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n \n         super(testName);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return new ObjectArrayIterator(new Object[0]);\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayIterator<E>((E[]) new Object[0]);\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new ObjectArrayIterator(testArray);\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayIterator<E> makeObject() {\n+        return new ObjectArrayIterator<E>((E[]) testArray);\n     }\n \n-    public ObjectArrayIterator makeArrayIterator() {\n-        return new ObjectArrayIterator();\n+    public ObjectArrayIterator<E> makeArrayIterator() {\n+        return new ObjectArrayIterator<E>();\n     }\n \n-    public ObjectArrayIterator makeArrayIterator(Object[] array) {\n-        return new ObjectArrayIterator(array);\n+    public ObjectArrayIterator<E> makeArrayIterator(E[] array) {\n+        return new ObjectArrayIterator<E>(array);\n     }\n \n-    public ObjectArrayIterator makeArrayIterator(Object[] array, int index) {\n-        return new ObjectArrayIterator(array, index);\n+    public ObjectArrayIterator<E> makeArrayIterator(E[] array, int index) {\n+        return new ObjectArrayIterator<E>(array, index);\n     }\n \n-    public ObjectArrayIterator makeArrayIterator(Object[] array, int start, int end) {\n-        return new ObjectArrayIterator(array, start, end);\n+    public ObjectArrayIterator<E> makeArrayIterator(E[] array, int start, int end) {\n+        return new ObjectArrayIterator<E>(array, start, end);\n     }\n \n     public boolean supportsRemove() {\n     }\n \n     public void testIterator() {\n-        Iterator iter = (Iterator) makeFullIterator();\n+        Iterator<E> iter = makeObject();\n         for (int i = 0; i < testArray.length; i++) {\n             Object testValue = testArray[i];\n-            Object iterValue = iter.next();\n+            E iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n \n         try {\n-            Object testValue = iter.next();\n+            iter.next();\n         } catch (Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n \n     public void testNullArray() {\n         try {\n-            Iterator iter = makeArrayIterator(null);\n+            makeArrayIterator(null);\n \n             fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n \n-        ObjectArrayIterator iter = makeArrayIterator();\n+        ObjectArrayIterator<E> iter = makeArrayIterator();\n         try {\n             iter.setArray(null);\n \n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testDoubleSet() {\n-        ObjectArrayIterator it = makeArrayIterator();\n-        it.setArray(new String[0]);\n+        ObjectArrayIterator<E> it = makeArrayIterator();\n+        it.setArray((E[]) new String[0]);\n         try {\n-            it.setArray(new String[0]);\n+            it.setArray((E[]) new String[0]);\n             fail();\n         } catch (IllegalStateException ex) {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testReset() {\n-        ObjectArrayIterator it = makeArrayIterator(testArray);\n+        ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);\n         it.next();\n         it.reset();\n         assertEquals(\"One\", it.next());\n--- a/src/test/org/apache/commons/collections/iterators/TestObjectArrayListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestObjectArrayListIterator.java\n package org.apache.commons.collections.iterators;\n \n import java.util.Arrays;\n-import java.util.Iterator;\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n  *\n  * @author Neil O'Toole\n  */\n-public class TestObjectArrayListIterator extends TestObjectArrayIterator {\n+public class TestObjectArrayListIterator<E> extends TestObjectArrayIterator<E> {\n \n     public TestObjectArrayListIterator(String testName) {\n         super(testName);\n         return new TestSuite(TestObjectArrayListIterator.class);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return new ObjectArrayListIterator(new Object[0]);\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayListIterator<E>((E[]) new Object[0]);\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new ObjectArrayListIterator(testArray);\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeObject() {\n+        return new ObjectArrayListIterator<E>((E[]) testArray);\n     }\n \n-    public ListIterator makeArrayListIterator(Object[] array) {\n-        return new ObjectArrayListIterator(array);\n+    public ObjectArrayListIterator<E> makeArrayListIterator(E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n     }\n \n     /**\n      * <code>previous()</code>.\n      */\n     public void testListIterator() {\n-        ListIterator iter = (ListIterator) makeFullIterator();\n+        ListIterator<E> iter = makeObject();\n \n         // TestArrayIterator#testIterator() has already tested the iterator forward,\n         //  now we need to test it in reverse\n         assertTrue(\"Iterator should now be empty\", !iter.hasPrevious());\n \n         try {\n-            Object testValue = iter.previous();\n+            iter.previous();\n         } catch (Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n     /**\n      * Tests the {@link java.util.ListIterator#set} operation.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testListIteratorSet() {\n         String[] testData = new String[] { \"a\", \"b\", \"c\" };\n \n         String[] result = new String[] { \"0\", \"1\", \"2\" };\n \n-        ListIterator iter = (ListIterator) makeArrayListIterator(testData);\n+        ListIterator<E> iter = makeArrayListIterator((E[]) testData);\n         int x = 0;\n \n         while (iter.hasNext()) {\n             iter.next();\n-            iter.set(Integer.toString(x));\n+            iter.set((E) Integer.toString(x));\n             x++;\n         }\n \n         assertTrue(\"The two arrays should have the same value, i.e. {0,1,2}\", Arrays.equals(testData, result));\n \n         // a call to set() before a call to next() or previous() should throw an IllegalStateException\n-        iter = makeArrayListIterator(testArray);\n+        iter = makeArrayListIterator((E[]) testArray);\n \n         try {\n-            iter.set(\"should fail\");\n+            iter.set((E) \"should fail\");\n             fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n         } catch (IllegalStateException e) {\n             // expected\n--- a/src/test/org/apache/commons/collections/iterators/TestObjectArrayListIterator2.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestObjectArrayListIterator2.java\n  */\n package org.apache.commons.collections.iterators;\n \n-import java.util.ListIterator;\n-\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestObjectArrayListIterator2 extends AbstractTestListIterator {\n+public class TestObjectArrayListIterator2<E> extends AbstractTestListIterator<E> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n-    \n+\n     public TestObjectArrayListIterator2(String testName) {\n         super(testName);\n     }\n         return new TestSuite(TestObjectArrayListIterator2.class);\n     }\n \n-    public ListIterator makeEmptyListIterator() {\n-        return new ObjectArrayListIterator(new Object[0]);\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayListIterator<E>((E[]) new Object[0]);\n     }\n \n-    public ListIterator makeFullListIterator() {\n-        return new ObjectArrayListIterator(testArray);\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeObject() {\n+        return new ObjectArrayListIterator<E>((E[]) testArray);\n     }\n \n-    public ListIterator makeArrayListIterator(Object[] array) {\n-        return new ObjectArrayListIterator(array);\n+    public ObjectArrayListIterator<E> makeArrayListIterator(E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n     }\n \n     public boolean supportsAdd() {\n         return false;\n     }\n-    \n+\n     public boolean supportsRemove() {\n         return false;\n     }\n--- a/src/test/org/apache/commons/collections/iterators/TestObjectGraphIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestObjectGraphIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestObjectGraphIterator extends AbstractTestIterator {\n+public class TestObjectGraphIterator extends AbstractTestIterator<Object> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" };\n \n-    protected List list1 = null;\n-    protected List list2 = null;\n-    protected List list3 = null;\n-    protected List iteratorList = null;\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+    protected List<Iterator<String>> iteratorList = null;\n \n     public TestObjectGraphIterator(String testName) {\n         super(testName);\n     }\n \n     public void setUp() {\n-        list1 = new ArrayList();\n+        list1 = new ArrayList<String>();\n         list1.add(\"One\");\n         list1.add(\"Two\");\n         list1.add(\"Three\");\n-        list2 = new ArrayList();\n+        list2 = new ArrayList<String>();\n         list2.add(\"Four\");\n-        list3 = new ArrayList();\n+        list3 = new ArrayList<String>();\n         list3.add(\"Five\");\n         list3.add(\"Six\");\n-        iteratorList = new ArrayList();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public Iterator makeEmptyIterator() {\n-        ArrayList list = new ArrayList();\n-        return new ObjectGraphIterator(list.iterator(), null);\n-    }\n-\n-    public Iterator makeFullIterator() {\n-        return new ObjectGraphIterator(iteratorList.iterator(), null);\n+        iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public ObjectGraphIterator<Object> makeEmptyIterator() {\n+        ArrayList<Object> list = new ArrayList<Object>();\n+        return new ObjectGraphIterator<Object>(list.iterator());\n+    }\n+\n+    public ObjectGraphIterator<Object> makeObject() {\n+        return new ObjectGraphIterator<Object>(iteratorList.iterator());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testIteratorConstructor_null1() {\n-        Iterator it = new ObjectGraphIterator(null);\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n \n         assertEquals(false, it.hasNext());\n         try {\n     }\n \n     public void testIteratorConstructor_null_next() {\n-        Iterator it = new ObjectGraphIterator(null);\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n         try {\n             it.next();\n             fail();\n     }\n \n     public void testIteratorConstructor_null_remove() {\n-        Iterator it = new ObjectGraphIterator(null);\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n         try {\n             it.remove();\n             fail();\n \n     //-----------------------------------------------------------------------\n     public void testIteratorConstructorIteration_Empty() {\n-        List iteratorList = new ArrayList();\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator());\n+        List<Iterator<Object>> iteratorList = new ArrayList<Iterator<Object>>();\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         assertEquals(false, it.hasNext());\n         try {\n     }\n \n     public void testIteratorConstructorIteration_Simple() {\n-        List iteratorList = new ArrayList();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator());\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n     }\n \n     public void testIteratorConstructorIteration_SimpleNoHasNext() {\n-        List iteratorList = new ArrayList();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator());\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(testArray[i], it.next());\n     }\n \n     public void testIteratorConstructorIteration_WithEmptyIterators() {\n-        List iteratorList = new ArrayList();\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        iteratorList.add(list3.iterator());\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator());\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n     }\n \n     public void testIteratorConstructorRemove() {\n-        List iteratorList = new ArrayList();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator());\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(testArray[i], it.next());\n \n     //-----------------------------------------------------------------------\n     public void testIteration_IteratorOfIterators() {\n-        List iteratorList = new ArrayList();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator(), null);\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n     }\n \n     public void testIteration_IteratorOfIteratorsWithEmptyIterators() {\n-        List iteratorList = new ArrayList();\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        iteratorList.add(list3.iterator());\n-        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n-        Iterator it = new ObjectGraphIterator(iteratorList.iterator(), null);\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n \n     //-----------------------------------------------------------------------\n     public void testIteration_RootNull() {\n-        Iterator it = new ObjectGraphIterator(null, null);\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null, null);\n \n         assertEquals(false, it.hasNext());\n         try {\n \n     public void testIteration_RootNoTransformer() {\n         Forest forest = new Forest();\n-        Iterator it = new ObjectGraphIterator(forest, null);\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, null);\n \n         assertEquals(true, it.hasNext());\n         assertSame(forest, it.next());\n     public void testIteration_Transformed1() {\n         Forest forest = new Forest();\n         Leaf l1 = forest.addTree().addBranch().addLeaf();\n-        Iterator it = new ObjectGraphIterator(forest, new LeafFinder());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n \n         assertEquals(true, it.hasNext());\n         assertSame(l1, it.next());\n         Branch b1 = forest.getTree(0).addBranch();\n         Branch b2 = forest.getTree(0).addBranch();\n         Branch b3 = forest.getTree(2).addBranch();\n-        Branch b4 = forest.getTree(2).addBranch();\n+        /* Branch b4 = */ forest.getTree(2).addBranch();\n         Branch b5 = forest.getTree(2).addBranch();\n         Leaf l1 = b1.addLeaf();\n         Leaf l2 = b1.addLeaf();\n         Leaf l4 = b3.addLeaf();\n         Leaf l5 = b5.addLeaf();\n \n-        Iterator it = new ObjectGraphIterator(forest, new LeafFinder());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n \n         assertEquals(true, it.hasNext());\n         assertSame(l1, it.next());\n         Branch b2 = forest.getTree(1).addBranch();\n         Branch b3 = forest.getTree(2).addBranch();\n         Branch b4 = forest.getTree(2).addBranch();\n-        Branch b5 = forest.getTree(2).addBranch();\n+        /* Branch b5 = */ forest.getTree(2).addBranch();\n         Leaf l1 = b1.addLeaf();\n         Leaf l2 = b1.addLeaf();\n         Leaf l3 = b2.addLeaf();\n         Leaf l4 = b3.addLeaf();\n         Leaf l5 = b4.addLeaf();\n \n-        Iterator it = new ObjectGraphIterator(forest, new LeafFinder());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n \n         assertEquals(true, it.hasNext());\n         assertSame(l1, it.next());\n     }\n \n     //-----------------------------------------------------------------------\n-    static class LeafFinder implements Transformer {\n+    static class LeafFinder implements Transformer<Object, Object> {\n         public Object transform(Object input) {\n             if (input instanceof Forest) {\n                 return ((Forest) input).treeIterator();\n \n     //-----------------------------------------------------------------------\n     static class Forest {\n-        List trees = new ArrayList();\n+        List<Tree> trees = new ArrayList<Tree>();\n \n         Tree addTree() {\n             trees.add(new Tree());\n             return (Tree) trees.get(index);\n         }\n \n-        Iterator treeIterator() {\n+        Iterator<Tree> treeIterator() {\n             return trees.iterator();\n         }\n     }\n \n     static class Tree {\n-        List branches = new ArrayList();\n+        List<Branch> branches = new ArrayList<Branch>();\n \n         Branch addBranch() {\n             branches.add(new Branch());\n             return (Branch) branches.get(index);\n         }\n \n-        Iterator branchIterator() {\n+        Iterator<Branch> branchIterator() {\n             return branches.iterator();\n         }\n     }\n \n     static class Branch {\n-        List leaves = new ArrayList();\n+        List<Leaf> leaves = new ArrayList<Leaf>();\n \n         Leaf addLeaf() {\n             leaves.add(new Leaf());\n             return (Leaf) leaves.get(index);\n         }\n \n-        Iterator leafIterator() {\n+        Iterator<Leaf> leafIterator() {\n             return leaves.iterator();\n         }\n     }\n--- a/src/test/org/apache/commons/collections/iterators/TestReverseListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestReverseListIterator.java\n  *\n  * @version $Revision: $ $Date$\n  */\n-public class TestReverseListIterator extends AbstractTestListIterator {\n+public class TestReverseListIterator<E> extends AbstractTestListIterator<E> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\" };\n \n         super(testName);\n     }\n \n-    public ListIterator makeEmptyListIterator() {\n-        List list = new ArrayList();\n-        return new ReverseListIterator(list);\n+    public ListIterator<E> makeEmptyIterator() {\n+        return new ReverseListIterator<E>(new ArrayList<E>());\n     }\n \n-    public ListIterator makeFullListIterator() {\n-        List list = new ArrayList(Arrays.asList(testArray));\n-        return new ReverseListIterator(list);\n+    @SuppressWarnings(\"unchecked\")\n+    public ReverseListIterator<E> makeObject() {\n+        List<E> list = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+        return new ReverseListIterator<E>(list);\n     }\n \n     // overrides\n     //-----------------------------------------------------------------------\n     public void testEmptyListIteratorIsIndeedEmpty() {\n-        ListIterator it = makeEmptyListIterator();\n-        \n+        ListIterator<E> it = makeEmptyIterator();\n+\n         assertEquals(false, it.hasNext());\n         assertEquals(-1, it.nextIndex());  // reversed index\n         assertEquals(false, it.hasPrevious());\n         assertEquals(0, it.previousIndex());  // reversed index\n-        \n+\n         // next() should throw a NoSuchElementException\n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n         } catch (NoSuchElementException e) {\n         }\n-        \n+\n         // previous() should throw a NoSuchElementException\n         try {\n             it.previous();\n     }\n \n     public void testWalkForwardAndBack() {\n-        ArrayList list = new ArrayList();\n-        ListIterator it = makeFullListIterator();\n+        ArrayList<E> list = new ArrayList<E>();\n+        ListIterator<E> it = makeObject();\n         while (it.hasNext()) {\n             list.add(it.next());\n         }\n-        \n+\n         // check state at end\n         assertEquals(false, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n-        \n+\n         // this had to be commented out, as there is a bug in the JDK before JDK1.5\n         // where calling previous at the start of an iterator would push the cursor\n         // back to an invalid negative value\n //            fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n //        } catch (NoSuchElementException e) {\n //        }\n-        \n+\n         // loop back through comparing\n         for (int i = list.size() - 1; i >= 0; i--) {\n             assertEquals(\"\" + i, list.size() - i - 2, it.nextIndex());  // reversed index\n             assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index\n-            \n+\n             Object obj = list.get(i);\n             assertEquals(obj, it.previous());\n         }\n-        \n+\n         // check state at start\n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n \n     //-----------------------------------------------------------------------\n     public void testReverse() {\n-        ListIterator it = makeFullListIterator();\n+        ListIterator<E> it = makeObject();\n         assertEquals(true, it.hasNext());\n         assertEquals(3, it.nextIndex());\n         assertEquals(false, it.hasPrevious());\n     }\n \n     public void testReset() {\n-        ResettableListIterator it = (ResettableListIterator) makeFullListIterator();\n+        ResettableListIterator<E> it = makeObject();\n         assertEquals(\"Four\", it.next());\n         it.reset();\n         assertEquals(\"Four\", it.next());\n--- a/src/test/org/apache/commons/collections/iterators/TestSingletonIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestSingletonIterator.java\n  *\n  * @author James Strachan\n  */\n-public class TestSingletonIterator extends AbstractTestIterator {\n+public class TestSingletonIterator<E> extends AbstractTestIterator<E> {\n \n     private static final Object testValue = \"foo\";\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestSingletonIterator.class);\n     }\n-    \n+\n     public TestSingletonIterator(String testName) {\n         super(testName);\n     }\n-    \n+\n     /**\n-     * Returns a SingletonIterator from which \n+     * Returns a SingletonIterator from which\n      * the element has already been removed.\n      */\n-    public Iterator makeEmptyIterator() {\n-        SingletonIterator iter = (SingletonIterator)makeFullIterator();\n+    public SingletonIterator<E> makeEmptyIterator() {\n+        SingletonIterator<E> iter = makeObject();\n         iter.next();\n-        iter.remove();        \n+        iter.remove();\n         iter.reset();\n         return iter;\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new SingletonIterator( testValue );\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeObject() {\n+        return new SingletonIterator<E>((E) testValue);\n     }\n \n     public boolean supportsRemove() {\n     }\n \n     public void testIterator() {\n-        Iterator iter = (Iterator) makeObject();\n+        Iterator<E> iter = makeObject();\n         assertTrue(\"Iterator has a first item\", iter.hasNext());\n \n-        Object iterValue = iter.next();\n+        E iterValue = iter.next();\n         assertEquals(\"Iteration value is correct\", testValue, iterValue);\n \n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n                 e.getClass().equals((new NoSuchElementException()).getClass()));\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testSingletonIteratorRemove() {\n-        ResettableIterator iter = new SingletonIterator(\"xyzzy\");\n+        ResettableIterator<E> iter = new SingletonIterator<E>((E) \"xyzzy\");\n         assertTrue(iter.hasNext());\n         assertEquals(\"xyzzy\",iter.next());\n         iter.remove();\n         iter.reset();\n         assertTrue(! iter.hasNext());\n     }\n-    \n+\n     public void testReset() {\n-        ResettableIterator it = (ResettableIterator) makeObject();\n-        \n+        ResettableIterator<E> it = makeObject();\n+\n         assertEquals(true, it.hasNext());\n         assertEquals(testValue, it.next());\n         assertEquals(false, it.hasNext());\n \n         it.reset();\n-        \n+\n         assertEquals(true, it.hasNext());\n         assertEquals(testValue, it.next());\n         assertEquals(false, it.hasNext());\n-        \n+\n         it.reset();\n         it.reset();\n-        \n+\n         assertEquals(true, it.hasNext());\n     }\n-    \n+\n }\n--- a/src/test/org/apache/commons/collections/iterators/TestSingletonIterator2.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestSingletonIterator2.java\n  *\n  * @author James Strachan\n  */\n-public class TestSingletonIterator2 extends AbstractTestIterator {\n+public class TestSingletonIterator2<E> extends AbstractTestIterator<E> {\n \n     private static final Object testValue = \"foo\";\n \n     }\n \n     //-----------------------------------------------------------------------\n-    public Iterator makeEmptyIterator() {\n-        SingletonIterator iter = new SingletonIterator(testValue);\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeEmptyIterator() {\n+        SingletonIterator<E> iter = new SingletonIterator<E>((E) testValue);\n         iter.next();\n         iter.remove();\n         iter.reset();\n         return iter;\n     }\n \n-    public Iterator makeFullIterator() {\n-        return new SingletonIterator(testValue, false);\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeObject() {\n+        return new SingletonIterator<E>((E) testValue, false);\n     }\n \n     public boolean supportsRemove() {\n \n     //-----------------------------------------------------------------------\n     public void testIterator() {\n-        Iterator iter = (Iterator) makeObject();\n+        Iterator<E> iter = makeObject();\n         assertTrue(\"Iterator has a first item\", iter.hasNext());\n \n-        Object iterValue = iter.next();\n+        E iterValue = iter.next();\n         assertEquals(\"Iteration value is correct\", testValue, iterValue);\n \n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n     }\n \n     public void testReset() {\n-        ResettableIterator it = (ResettableIterator) makeObject();\n+        ResettableIterator<E> it = makeObject();\n \n         assertEquals(true, it.hasNext());\n         assertEquals(testValue, it.next());\n--- a/src/test/org/apache/commons/collections/iterators/TestUniqueFilterIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUniqueFilterIterator.java\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public class TestUniqueFilterIterator extends AbstractTestIterator {\n+public class TestUniqueFilterIterator<E> extends AbstractTestIterator<E> {\n \n     protected String[] testArray = {\n         \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n     };\n \n-    protected List list1 = null;\n+    protected List<E> list1 = null;\n \n     public static Test suite() {\n         return new TestSuite(TestUniqueFilterIterator.class);\n         super(testName);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void setUp() {\n-        list1 = new ArrayList();\n-        list1.add(\"One\");\n-        list1.add(\"Two\");\n-        list1.add(\"Three\");\n-        list1.add(\"Two\");\n-        list1.add(\"One\");\n-        list1.add(\"Four\");\n-        list1.add(\"Five\");\n-        list1.add(\"Five\");\n-        list1.add(\"Six\");\n-        list1.add(\"Five\");\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+        list1.add((E) \"Five\");\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        ArrayList list = new ArrayList();\n-        return new UniqueFilterIterator(list.iterator());\n+    public UniqueFilterIterator<E> makeEmptyIterator() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        return new UniqueFilterIterator<E>(list.iterator());\n     }\n \n-    public Iterator makeFullIterator() {\n-        Iterator i = list1.iterator();\n-\n-        return new UniqueFilterIterator(i);\n+    public UniqueFilterIterator<E> makeObject() {\n+        Iterator<E> i = list1.iterator();\n+        return new UniqueFilterIterator<E>(i);\n     }\n \n     public void testIterator() {\n-        Iterator iter = (Iterator) makeFullIterator();\n-        for ( int i = 0; i < testArray.length; i++ ) {\n+        Iterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n             Object testValue = testArray[i];            \n-            Object iterValue = iter.next();\n+            E iterValue = iter.next();\n \n             assertEquals( \"Iteration value is correct\", testValue, iterValue );\n         }\n         assertTrue(\"Iterator should now be empty\", ! iter.hasNext() );\n \n         try {\n-            Object testValue = iter.next();\n+            iter.next();\n         } catch (Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\", \n                        e.getClass().equals((new NoSuchElementException()).getClass()));\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableIterator extends AbstractTestIterator {\n+public class TestUnmodifiableIterator<E> extends AbstractTestIterator<E> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n-    protected List testList = new ArrayList(Arrays.asList(testArray));\n+    protected List<E> testList;\n \n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableIterator.class);\n         super(testName);\n     }\n \n-    public Iterator makeEmptyIterator() {\n-        return UnmodifiableIterator.decorate(Collections.EMPTY_LIST.iterator());\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n     }\n \n-    public Iterator makeFullIterator() {\n+    public Iterator<E> makeEmptyIterator() {\n+        return UnmodifiableIterator.decorate(Collections.<E>emptyList().iterator());\n+    }\n+\n+    public Iterator<E> makeObject() {\n         return UnmodifiableIterator.decorate(testList.iterator());\n     }\n \n     public void testIterator() {\n         assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        Iterator it = makeFullIterator();\n+        Iterator<E> it = makeObject();\n         assertSame(it, UnmodifiableIterator.decorate(it));\n-        \n+\n         it = testList.iterator();\n         assertTrue(it != UnmodifiableIterator.decorate(it));\n-        \n+\n         try {\n             UnmodifiableIterator.decorate(null);\n             fail();\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableListIterator.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableListIterator extends AbstractTestListIterator {\n+public class TestUnmodifiableListIterator<E> extends AbstractTestListIterator<E> {\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n-    protected List testList = new ArrayList(Arrays.asList(testArray));\n+    protected List<E> testList;\n \n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableListIterator.class);\n         super(testName);\n     }\n \n-    public ListIterator makeEmptyListIterator() {\n-        return UnmodifiableListIterator.decorate(Collections.EMPTY_LIST.listIterator());\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n     }\n \n-    public ListIterator makeFullListIterator() {\n+    public ListIterator<E> makeEmptyIterator() {\n+        return UnmodifiableListIterator.decorate(Collections.<E>emptyList().listIterator());\n+    }\n+\n+    public ListIterator<E> makeObject() {\n         return UnmodifiableListIterator.decorate(testList.listIterator());\n     }\n \n \n     //-----------------------------------------------------------------------\n     public void testListIterator() {\n-        assertTrue(makeEmptyListIterator() instanceof Unmodifiable);\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        ListIterator it = makeFullListIterator();\n+        ListIterator<E> it = makeObject();\n         assertSame(it, UnmodifiableListIterator.decorate(it));\n-        \n+\n         it = testList.listIterator();\n         assertTrue(it != UnmodifiableListIterator.decorate(it));\n-        \n+\n         try {\n             UnmodifiableListIterator.decorate(null);\n             fail();\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.Unmodifiable;\n import org.apache.commons.collections.bidimap.DualHashBidiMap;\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableMapIterator extends AbstractTestMapIterator {\n+public class TestUnmodifiableMapIterator<K, V> extends AbstractTestMapIterator<K, V> {\n \n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableMapIterator.class);\n         super(testName);\n     }\n \n-    public MapIterator makeEmptyMapIterator() {\n-        return UnmodifiableMapIterator.decorate(new DualHashBidiMap().mapIterator());\n+    public MapIterator<K, V> makeEmptyIterator() {\n+        return UnmodifiableMapIterator.decorate(new DualHashBidiMap<K, V>().mapIterator());\n     }\n \n-    public MapIterator makeFullMapIterator() {\n-        return UnmodifiableMapIterator.decorate(((BidiMap) getMap()).mapIterator());\n+    public MapIterator<K, V> makeObject() {\n+        return UnmodifiableMapIterator.decorate(getMap().mapIterator());\n     }\n-    \n-    public Map getMap() {\n-        Map testMap = new DualHashBidiMap();\n-        testMap.put(\"A\", \"a\");\n-        testMap.put(\"B\", \"b\");\n-        testMap.put(\"C\", \"c\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public IterableMap<K, V> getMap() {\n+        IterableMap<K, V> testMap = new DualHashBidiMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V)\"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n         return testMap;\n     }\n \n-    public Map getConfirmedMap() {\n-        Map testMap = new HashMap();\n-        testMap.put(\"A\", \"a\");\n-        testMap.put(\"B\", \"b\");\n-        testMap.put(\"C\", \"c\");\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> getConfirmedMap() {\n+        Map<K, V> testMap = new HashMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V)\"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n         return testMap;\n     }\n \n     public boolean supportsSetValue() {\n         return false;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testMapIterator() {\n-        assertTrue(makeEmptyMapIterator() instanceof Unmodifiable);\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        MapIterator it = makeFullMapIterator();\n+        MapIterator<K, V> it = makeObject();\n         assertSame(it, UnmodifiableMapIterator.decorate(it));\n-        \n-        it = ((BidiMap) getMap()).mapIterator() ;\n+\n+        it = getMap().mapIterator() ;\n         assertTrue(it != UnmodifiableMapIterator.decorate(it));\n-        \n+\n         try {\n             UnmodifiableMapIterator.decorate(null);\n             fail();\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableOrderedMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableOrderedMapIterator.java\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedMap;\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.Unmodifiable;\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableOrderedMapIterator extends AbstractTestOrderedMapIterator {\n+public class TestUnmodifiableOrderedMapIterator<K, V> extends AbstractTestOrderedMapIterator<K, V> {\n \n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableOrderedMapIterator.class);\n         super(testName);\n     }\n \n-    public MapIterator makeEmptyMapIterator() {\n+    public OrderedMapIterator<K, V> makeEmptyIterator() {\n         return UnmodifiableOrderedMapIterator.decorate(\n-            ListOrderedMap.decorate(new HashMap()).orderedMapIterator());\n+                ListOrderedMap.decorate(new HashMap<K, V>()).mapIterator());\n     }\n \n-    public MapIterator makeFullMapIterator() {\n-        return UnmodifiableOrderedMapIterator.decorate(\n-            ((OrderedMap) getMap()).orderedMapIterator());\n+    public OrderedMapIterator<K, V> makeObject() {\n+        return UnmodifiableOrderedMapIterator.decorate(getMap().mapIterator());\n     }\n-    \n-    public Map getMap() {\n-        Map testMap = ListOrderedMap.decorate(new HashMap());\n-        testMap.put(\"A\", \"a\");\n-        testMap.put(\"B\", \"b\");\n-        testMap.put(\"C\", \"c\");\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public OrderedMap<K, V> getMap() {\n+        OrderedMap<K, V> testMap = ListOrderedMap.decorate(new HashMap<K, V>());\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V) \"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n         return testMap;\n     }\n \n-    public Map getConfirmedMap() {\n-        Map testMap = new TreeMap();\n-        testMap.put(\"A\", \"a\");\n-        testMap.put(\"B\", \"b\");\n-        testMap.put(\"C\", \"c\");\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> getConfirmedMap() {\n+        Map<K, V> testMap = new TreeMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V) \"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n         return testMap;\n     }\n \n     public boolean supportsSetValue() {\n         return false;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testOrderedMapIterator() {\n-        assertTrue(makeEmptyOrderedMapIterator() instanceof Unmodifiable);\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        OrderedMapIterator it = makeFullOrderedMapIterator();\n+        OrderedMapIterator<K, V> it = makeObject();\n         assertSame(it, UnmodifiableOrderedMapIterator.decorate(it));\n-        \n-        it = ((OrderedMap) getMap()).orderedMapIterator() ;\n+\n+        it = getMap().mapIterator() ;\n         assertTrue(it != UnmodifiableOrderedMapIterator.decorate(it));\n-        \n+\n         try {\n             UnmodifiableOrderedMapIterator.decorate(null);\n             fail();\n--- a/src/test/org/apache/commons/collections/keyvalue/AbstractTestMapEntry.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/AbstractTestMapEntry.java\n  *\n  * @author Neil O'Toole\n  */\n-public abstract class AbstractTestMapEntry extends TestCase {\n+public abstract class AbstractTestMapEntry<K, V> extends TestCase {\n     \n     protected final String key = \"name\";\n     protected final String value = \"duke\";\n      * This implementation simply calls {@link #makeMapEntry(Object, Object)}\n      * with null for key and value. Subclasses can override this method if desired.\n      */\n-    public Map.Entry makeMapEntry() {\n+    public Map.Entry<K, V> makeMapEntry() {\n         return makeMapEntry(null, null);\n     }\n \n      * Subclasses should override this method to return a Map.Entry\n      * of the type being tested.\n      */\n-    public abstract Map.Entry makeMapEntry(Object key, Object value);\n+    public abstract Map.Entry<K, V> makeMapEntry(K key, V value);\n \n     /**\n      * Makes a Map.Entry of a type that's known to work correctly.\n      */\n-    public Map.Entry makeKnownMapEntry() {\n+    public Map.Entry<K, V> makeKnownMapEntry() {\n         return makeKnownMapEntry(null, null);\n     }\n \n     /**\n      * Makes a Map.Entry of a type that's known to work correctly.\n      */\n-    public Map.Entry makeKnownMapEntry(Object key, Object value) {\n-        Map map = new HashMap(1);\n+    public Map.Entry<K, V> makeKnownMapEntry(K key, V value) {\n+        Map<K, V> map = new HashMap<K, V>(1);\n         map.put(key, value);\n-        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n         return entry;\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testAccessorsAndMutators() {\n-        Map.Entry entry = makeMapEntry(key, value);\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n \n         assertTrue(entry.getKey() == key);\n \n-        entry.setValue(value);\n+        entry.setValue((V) value);\n         assertTrue(entry.getValue() == value);\n \n         // check that null doesn't do anything funny\n      *\n      */\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSelfReferenceHandling() {\n         // test that #setValue does not permit\n         //  the MapEntry to contain itself (and thus cause infinite recursion\n         //  in #hashCode and #toString)\n \n-        Map.Entry entry = makeMapEntry();\n+        Map.Entry<K, V> entry = makeMapEntry();\n \n         try {\n-            entry.setValue(entry);\n+            entry.setValue((V) entry);\n             fail(\"Should throw an IllegalArgumentException\");\n         } catch (IllegalArgumentException iae) {\n             // expected to happen...\n      */\n     public abstract void testConstructors();\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testEqualsAndHashCode() {\n         // 1. test with object data\n-        Map.Entry e1 = makeMapEntry(key, value);\n-        Map.Entry e2 = makeKnownMapEntry(key, value);\n+        Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);\n+        Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);\n \n         assertTrue(e1.equals(e1));\n         assertTrue(e2.equals(e1));\n         assertTrue(e1.hashCode() == e2.hashCode());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testToString() {\n-        Map.Entry entry = makeMapEntry(key, value);\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n         assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n \n         // test with nulls\n--- a/src/test/org/apache/commons/collections/keyvalue/TestDefaultKeyValue.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/TestDefaultKeyValue.java\n  *\n  * @author Neil O'Toole\n  */\n-public class TestDefaultKeyValue extends TestCase {\n+public class TestDefaultKeyValue<K, V> extends TestCase {\n     \n     private final String key = \"name\";\n     private final String value = \"duke\";\n      * Subclasses should override this method to return a DefaultKeyValue\n      * of the type being tested.\n      */\n-    protected DefaultKeyValue makeDefaultKeyValue() {\n-        return new DefaultKeyValue(null, null);\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue() {\n+        return new DefaultKeyValue<K, V>(null, null);\n     }\n \n     /**\n      * Subclasses should override this method to return a DefaultKeyValue\n      * of the type being tested.\n      */\n-    protected DefaultKeyValue makeDefaultKeyValue(Object key, Object value) {\n-        return new DefaultKeyValue(key, value);\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue(K key, V value) {\n+        return new DefaultKeyValue<K, V>(key, value);\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testAccessorsAndMutators() {\n-        DefaultKeyValue kv = makeDefaultKeyValue();\n-\n-        kv.setKey(key);\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        kv.setKey((K) key);\n         assertTrue(kv.getKey() == key);\n \n-        kv.setValue(value);\n+        kv.setValue((V) value);\n         assertTrue(kv.getValue() == value);\n \n         // check that null doesn't do anything funny\n \n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSelfReferenceHandling() {\n         // test that #setKey and #setValue do not permit\n         //  the KVP to contain itself (and thus cause infinite recursion\n         //  in #hashCode and #toString)\n \n-        DefaultKeyValue kv = makeDefaultKeyValue();\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n \n         try {\n-            kv.setKey(kv);\n+            kv.setKey((K) kv);\n             fail(\"Should throw an IllegalArgumentException\");\n         } catch (IllegalArgumentException iae) {\n             // expected to happen...\n         }\n \n         try {\n-            kv.setValue(kv);\n+            kv.setValue((V) kv);\n             fail(\"Should throw an IllegalArgumentException\");\n         } catch (IllegalArgumentException iae) {\n             // expected to happen...\n     /**\n      * Subclasses should override this method to test their own constructors.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testConstructors() {\n         // 1. test default constructor\n-        DefaultKeyValue kv = new DefaultKeyValue();\n+        DefaultKeyValue<K, V> kv = new DefaultKeyValue<K, V>();\n         assertTrue(kv.getKey() == null && kv.getValue() == null);\n \n         // 2. test key-value constructor\n-        kv = new DefaultKeyValue(key, value);\n+        kv = new DefaultKeyValue<K, V>((K) key, (V) value);\n         assertTrue(kv.getKey() == key && kv.getValue() == value);\n \n         // 3. test copy constructor\n-        DefaultKeyValue kv2 = new DefaultKeyValue(kv);\n+        DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<K, V>(kv);\n         assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n \n         // test that the KVPs are independent\n         assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n \n         // 4. test Map.Entry constructor\n-        Map map = new HashMap();\n-        map.put(key, value);\n-        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n-\n-        kv = new DefaultKeyValue(entry);\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) key, (V) value);\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        kv = new DefaultKeyValue<K, V>(entry);\n         assertTrue(kv.getKey() == key && kv.getValue() == value);\n \n         // test that the KVP is independent of the Map.Entry\n \n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testEqualsAndHashCode() {\n         // 1. test with object data\n-        DefaultKeyValue kv = makeDefaultKeyValue(key, value);\n-        DefaultKeyValue kv2 = makeDefaultKeyValue(key, value);\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);\n \n         assertTrue(kv.equals(kv));\n         assertTrue(kv.equals(kv2));\n         assertTrue(kv.hashCode() == kv2.hashCode());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testToString() {\n-        DefaultKeyValue kv = makeDefaultKeyValue(key, value);\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n         assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n \n         // test with nulls\n         assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testToMapEntry() {\n-        DefaultKeyValue kv = makeDefaultKeyValue(key, value);\n-\n-        Map map = new HashMap();\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+\n+        Map<K, V> map = new HashMap<K, V>();\n         map.put(kv.getKey(), kv.getValue());\n-        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n \n         assertTrue(entry.equals(kv.toMapEntry()));\n         assertTrue(entry.hashCode() == kv.hashCode());\n--- a/src/test/org/apache/commons/collections/keyvalue/TestDefaultMapEntry.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/TestDefaultMapEntry.java\n  *\n  * @author Neil O'Toole\n  */\n-public class TestDefaultMapEntry extends AbstractTestMapEntry {\n+public class TestDefaultMapEntry<K, V> extends AbstractTestMapEntry<K, V> {\n \n     public TestDefaultMapEntry(String testName) {\n         super(testName);\n-\n     }\n \n     public static void main(String[] args) {\n      * Subclasses should override this method to return a Map.Entry\n      * of the type being tested.\n      */\n-    public Map.Entry makeMapEntry() {\n-        return new DefaultMapEntry(null, null);\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new DefaultMapEntry<K, V>(null, null);\n     }\n \n     /**\n      * Subclasses should override this method to return a Map.Entry\n      * of the type being tested.\n      */\n-    public Map.Entry makeMapEntry(Object key, Object value) {\n-        return new DefaultMapEntry(key, value);\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        return new DefaultMapEntry<K, V>(key, value);\n     }\n \n     //-----------------------------------------------------------------------\n      * Subclasses should override this method.\n      *\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testConstructors() {\n         // 1. test key-value constructor\n-        Map.Entry entry = new DefaultMapEntry(key, value);\n+        Map.Entry<K, V> entry = new DefaultMapEntry<K, V>((K) key, (V) value);\n         assertSame(key, entry.getKey());\n         assertSame(value, entry.getValue());\n \n         // 2. test pair constructor\n-        KeyValue pair = new DefaultKeyValue(key, value);\n+        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n         assertSame(key, pair.getKey());\n         assertSame(value, pair.getValue());\n \n         // 3. test copy constructor\n-        Map.Entry entry2 = new DefaultMapEntry(entry);\n+        Map.Entry<K, V> entry2 = new DefaultMapEntry<K, V>(entry);\n         assertSame(key, entry2.getKey());\n         assertSame(value, entry2.getValue());\n \n         assertSame(value, entry2.getValue());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSelfReferenceHandling() {\n-        Map.Entry entry = makeMapEntry();\n+        Map.Entry<K, V> entry = makeMapEntry();\n \n         try {\n-            entry.setValue(entry);\n+            entry.setValue((V) entry);\n             assertSame(entry, entry.getValue());\n \n         } catch (Exception e) {\n--- a/src/test/org/apache/commons/collections/keyvalue/TestTiedMapEntry.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/TestTiedMapEntry.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTiedMapEntry extends AbstractTestMapEntry {\n+public class TestTiedMapEntry<K, V> extends AbstractTestMapEntry<K, V> {\n \n     public TestTiedMapEntry(String testName) {\n         super(testName);\n-\n     }\n \n     public static void main(String[] args) {\n     /**\n      * Gets the instance to test\n      */\n-    public Map.Entry makeMapEntry(Object key, Object value) {\n-        Map map = new HashMap();\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        Map<K, V> map = new HashMap<K, V>();\n         map.put(key, value);\n-        return new TiedMapEntry(map, key);\n+        return new TiedMapEntry<K, V>(map, key);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Tests the constructors.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testSetValue() {\n-        Map map = new HashMap();\n-        map.put(\"A\", \"a\");\n-        map.put(\"B\", \"b\");\n-        map.put(\"C\", \"c\");\n-        Map.Entry entry = new TiedMapEntry(map, \"A\");\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"A\", (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        map.put((K) \"C\", (V) \"c\");\n+        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(map, (K) \"A\");\n         assertSame(\"A\", entry.getKey());\n         assertSame(\"a\", entry.getValue());\n-        assertSame(\"a\", entry.setValue(\"x\"));\n+        assertSame(\"a\", entry.setValue((V) \"x\"));\n         assertSame(\"A\", entry.getKey());\n         assertSame(\"x\", entry.getValue());\n-        \n-        entry = new TiedMapEntry(map, \"B\");\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"B\");\n         assertSame(\"B\", entry.getKey());\n         assertSame(\"b\", entry.getValue());\n-        assertSame(\"b\", entry.setValue(\"y\"));\n+        assertSame(\"b\", entry.setValue((V) \"y\"));\n         assertSame(\"B\", entry.getKey());\n         assertSame(\"y\", entry.getValue());\n-        \n-        entry = new TiedMapEntry(map, \"C\");\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"C\");\n         assertSame(\"C\", entry.getKey());\n         assertSame(\"c\", entry.getValue());\n-        assertSame(\"c\", entry.setValue(\"z\"));\n+        assertSame(\"c\", entry.setValue((V) \"z\"));\n         assertSame(\"C\", entry.getKey());\n         assertSame(\"z\", entry.getValue());\n     }\n--- a/src/test/org/apache/commons/collections/keyvalue/TestUnmodifiableMapEntry.java\n+++ b/src/test/org/apache/commons/collections/keyvalue/TestUnmodifiableMapEntry.java\n  *\n  * @author Neil O'Toole\n  */\n-public class TestUnmodifiableMapEntry extends AbstractTestMapEntry {\n+public class TestUnmodifiableMapEntry<K, V> extends AbstractTestMapEntry<K, V> {\n \n     public TestUnmodifiableMapEntry(String testName) {\n         super(testName);\n-\n     }\n \n     public static void main(String[] args) {\n      * Subclasses should override this method to return a Map.Entry\n      * of the type being tested.\n      */\n-    public Map.Entry makeMapEntry() {\n-        return new UnmodifiableMapEntry(null, null);\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new UnmodifiableMapEntry<K, V>(null, null);\n     }\n \n     /**\n      * Subclasses should override this method to return a Map.Entry\n      * of the type being tested.\n      */\n-    public Map.Entry makeMapEntry(Object key, Object value) {\n-        return new UnmodifiableMapEntry(key, value);\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        return new UnmodifiableMapEntry<K, V>(key, value);\n     }\n \n     //-----------------------------------------------------------------------\n      * Subclasses should override this method.\n      *\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testConstructors() {\n         // 1. test key-value constructor\n-        Map.Entry entry = new UnmodifiableMapEntry(key, value);\n+        Map.Entry<K, V> entry = new UnmodifiableMapEntry<K, V>((K) key, (V) value);\n         assertSame(key, entry.getKey());\n         assertSame(value, entry.getValue());\n \n         // 2. test pair constructor\n-        KeyValue pair = new DefaultKeyValue(key, value);\n-        entry = new UnmodifiableMapEntry(pair);\n+        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        entry = new UnmodifiableMapEntry<K, V>(pair);\n         assertSame(key, entry.getKey());\n         assertSame(value, entry.getValue());\n \n         // 3. test copy constructor\n-        Map.Entry entry2 = new UnmodifiableMapEntry(entry);\n+        Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<K, V>(entry);\n         assertSame(key, entry2.getKey());\n         assertSame(value, entry2.getValue());\n \n         assertTrue(entry instanceof Unmodifiable);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testAccessorsAndMutators() {\n-        Map.Entry entry = makeMapEntry(key, value);\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n \n         assertSame(key, entry.getKey());\n         assertSame(value, entry.getValue());\n     }\n \n     public void testUnmodifiable() {\n-        Map.Entry entry = makeMapEntry();\n+        Map.Entry<K, V> entry = makeMapEntry();\n         try {\n             entry.setValue(null);\n             fail();\n-\n         } catch (UnsupportedOperationException ex) {}\n     }\n \n--- a/src/test/org/apache/commons/collections/list/TestAbstractLinkedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestAbstractLinkedList.java\n  * @author David Hay\n  * @author Phil Steitz\n  */\n-public abstract class TestAbstractLinkedList extends AbstractTestList {\n-    \n+public abstract class TestAbstractLinkedList<E> extends AbstractTestList<E> {\n+\n     public TestAbstractLinkedList(String testName) {\n         super(testName);\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveFirst() {\n         resetEmpty();\n-        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        AbstractLinkedList<E> list = getCollection();\n         if (isRemoveSupported() == false) {\n             try {\n                 list.removeFirst();\n             } catch (UnsupportedOperationException ex) {}\n-        } \n-        \n-        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n-        assertEquals( \"value1\", list.removeFirst() );\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value1\", list.removeFirst());\n         checkNodes();\n-        list.addLast( \"value3\");\n+        list.addLast((E) \"value3\");\n         checkNodes();\n-        assertEquals( \"value2\", list.removeFirst() );\n-        assertEquals( \"value3\", list.removeFirst() );\n+        assertEquals(\"value2\", list.removeFirst());\n+        assertEquals(\"value3\", list.removeFirst());\n         checkNodes();\n-        list.addLast( \"value4\" );\n+        list.addLast((E) \"value4\");\n         checkNodes();\n-        assertEquals( \"value4\", list.removeFirst() );\n+        assertEquals(\"value4\", list.removeFirst());\n         checkNodes();\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveLast() {\n         resetEmpty();\n-        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        AbstractLinkedList<E> list = getCollection();\n         if (isRemoveSupported() == false) {\n             try {\n                 list.removeLast();\n             } catch (UnsupportedOperationException ex) {}\n-        } \n-        \n-        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n-        assertEquals( \"value2\", list.removeLast() );\n-        list.addFirst( \"value3\");\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value2\", list.removeLast());\n+        list.addFirst((E) \"value3\");\n         checkNodes();\n-        assertEquals( \"value1\", list.removeLast() );\n-        assertEquals( \"value3\", list.removeLast() );\n-        list.addFirst( \"value4\" );\n+        assertEquals(\"value1\", list.removeLast());\n+        assertEquals(\"value3\", list.removeLast());\n+        list.addFirst((E) \"value4\");\n         checkNodes();\n-        assertEquals( \"value4\", list.removeFirst() );\n+        assertEquals(\"value4\", list.removeFirst());\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testAddNodeAfter() {\n         resetEmpty();\n-        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        AbstractLinkedList<E> list = getCollection();\n         if (isAddSupported() == false) {\n             try {\n                 list.addFirst(null);\n             } catch (UnsupportedOperationException ex) {}\n-        } \n-        \n-        list.addFirst(\"value1\");\n-        list.addNodeAfter(list.getNode(0,false),\"value2\");\n+        }\n+\n+        list.addFirst((E) \"value1\");\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value2\");\n         assertEquals(\"value1\", list.getFirst());\n         assertEquals(\"value2\", list.getLast());\n         list.removeFirst();\n         checkNodes();\n-        list.addNodeAfter(list.getNode(0,false),\"value3\");\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value3\");\n         checkNodes();\n         assertEquals(\"value2\", list.getFirst());\n         assertEquals(\"value3\", list.getLast());\n-        list.addNodeAfter(list.getNode(0, false),\"value4\");\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value4\");\n         checkNodes();\n         assertEquals(\"value2\", list.getFirst());\n         assertEquals(\"value3\", list.getLast());\n         assertEquals(\"value4\", list.get(1));\n-        list.addNodeAfter(list.getNode(2, false), \"value5\");\n+        list.addNodeAfter(list.getNode(2, false), (E) \"value5\");\n         checkNodes();\n         assertEquals(\"value2\", list.getFirst());\n         assertEquals(\"value4\", list.get(1));\n         assertEquals(\"value3\", list.get(2));\n         assertEquals(\"value5\", list.getLast());\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveNode() {\n         resetEmpty();\n         if (isAddSupported() == false || isRemoveSupported() == false) return;\n-        AbstractLinkedList list = (AbstractLinkedList) collection;\n-        \n-        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n+        AbstractLinkedList<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n         list.removeNode(list.getNode(0, false));\n         checkNodes();\n         assertEquals(\"value2\", list.getFirst());\n         assertEquals(\"value2\", list.getLast());\n-        list.addFirst(\"value1\");\n-        list.addFirst(\"value0\");\n+        list.addFirst((E) \"value1\");\n+        list.addFirst((E) \"value0\");\n         checkNodes();\n         list.removeNode(list.getNode(1, false));\n         assertEquals(\"value0\", list.getFirst());\n         assertEquals(\"value0\", list.getLast());\n         checkNodes();\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testGetNode() {\n         resetEmpty();\n-        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        AbstractLinkedList<E> list = getCollection();\n         // get marker\n         assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n         try {\n-            Object obj = list.getNode(0, false);\n+            list.getNode(0, false);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n         } catch (IndexOutOfBoundsException ex) {\n             // expected\n         }\n-        list.addAll( Arrays.asList( new String[]{\"value1\", \"value2\"}));\n+        list.addAll( Arrays.asList((E[]) new String[]{\"value1\", \"value2\"}));\n         checkNodes();\n-        list.addFirst(\"value0\");\n+        list.addFirst((E) \"value0\");\n         checkNodes();\n         list.removeNode(list.getNode(1, false));\n         checkNodes();\n         try {\n-            Object obj = list.getNode(2, false);\n+            list.getNode(2, false);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n         } catch (IndexOutOfBoundsException ex) {\n             // expected\n         }\n         try {\n-            Object obj = list.getNode(-1, false);\n+            list.getNode(-1, false);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n         } catch (IndexOutOfBoundsException ex) {\n             // expected\n         }\n          try {\n-            Object obj = list.getNode(3, true);\n+            list.getNode(3, true);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n         } catch (IndexOutOfBoundsException ex) {\n             // expected\n-        }       \n+        }\n     }\n-    \n+\n     protected void checkNodes() {\n-        AbstractLinkedList list = (AbstractLinkedList) collection;\n+        AbstractLinkedList<E> list = getCollection();\n         for (int i = 0; i < list.size; i++) {\n             assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n             if (i < list.size - 1) {\n-                assertEquals(list.getNode(i + 1, false).previous, \n-                    list.getNode(i, false));  \n+                assertEquals(list.getNode(i + 1, false).previous,\n+                    list.getNode(i, false));\n             }\n         }\n     }\n-        \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public AbstractLinkedList<E> getCollection() {\n+        return (AbstractLinkedList<E>) super.getCollection();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/list/TestFixedSizeList.java\n+++ b/src/test/org/apache/commons/collections/list/TestFixedSizeList.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestFixedSizeList extends AbstractTestList {\n+public class TestFixedSizeList<E> extends AbstractTestList<E> {\n \n     public TestFixedSizeList(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public List makeEmptyList() {\n-        return FixedSizeList.decorate(new ArrayList());\n+    public List<E> makeObject() {\n+        return FixedSizeList.decorate(new ArrayList<E>());\n     }\n \n-    public List makeFullList() {\n-        List list = new ArrayList();\n+    public List<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return FixedSizeList.decorate(list);\n     }\n-    \n+\n     public boolean isAddSupported() {\n         return false;\n     }\n--- a/src/test/org/apache/commons/collections/list/TestGrowthList.java\n+++ b/src/test/org/apache/commons/collections/list/TestGrowthList.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestGrowthList extends AbstractTestList {\n+public class TestGrowthList<E> extends AbstractTestList<E> {\n \n     public TestGrowthList(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public List makeEmptyList() {\n-        return new GrowthList();\n+    public List<E> makeObject() {\n+        return new GrowthList<E>();\n     }\n \n-    public List makeFullList() {\n-        List list = new ArrayList();\n+    public List<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return GrowthList.decorate(list);\n     }\n     //-----------------------------------------------------------------------\n     public void testGrowthAdd() {\n         Integer one = new Integer(1);\n-        GrowthList grower = new GrowthList();\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.add(1, one);\n         assertEquals(2, grower.size());\n     public void testGrowthAddAll() {\n         Integer one = new Integer(1);\n         Integer two = new Integer(2);\n-        Collection coll = new ArrayList();\n+        Collection<Integer> coll = new ArrayList<Integer>();\n         coll.add(one);\n         coll.add(two);\n-        GrowthList grower = new GrowthList();\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.addAll(1, coll);\n         assertEquals(3, grower.size());\n \n     public void testGrowthSet1() {\n         Integer one = new Integer(1);\n-        GrowthList grower = new GrowthList();\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.set(1, one);\n         assertEquals(2, grower.size());\n \n     public void testGrowthSet2() {\n         Integer one = new Integer(1);\n-        GrowthList grower = new GrowthList();\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.set(0, one);\n         assertEquals(1, grower.size());\n      * Override.\n      */\n     public void testListAddByIndexBoundsChecking() {\n-        List list;\n-        Object element = getOtherElements()[0];\n+        List<E> list;\n+        E element = getOtherElements()[0];\n         try {\n-            list = makeEmptyList();\n+            list = makeObject();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n         } catch (IndexOutOfBoundsException e) {\n      * Override.\n      */\n     public void testListAddByIndexBoundsChecking2() {\n-        List list;\n-        Object element = getOtherElements()[0];\n+        List<E> list;\n+        E element = getOtherElements()[0];\n         try {\n-            list = makeFullList();\n+            list = makeFullCollection();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n         } catch (IndexOutOfBoundsException e) {\n      * Override.\n      */\n     public void testListSetByIndexBoundsChecking() {\n-        List list = makeEmptyList();\n-        Object element = getOtherElements()[0];\n+        List<E> list = makeObject();\n+        E element = getOtherElements()[0];\n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n      * Override.\n      */\n     public void testListSetByIndexBoundsChecking2() {\n-        List list = makeFullList();\n-        Object element = getOtherElements()[0];\n+        List<E> list = makeFullCollection();\n+        E element = getOtherElements()[0];\n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n--- a/src/test/org/apache/commons/collections/list/TestNodeCachingLinkedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestNodeCachingLinkedList.java\n \n import java.util.Arrays;\n import java.util.LinkedList;\n-import java.util.List;\n \n import junit.framework.Test;\n \n  * @author Jeff Varszegi\n  * @author Phil Steitz\n  */\n-public class TestNodeCachingLinkedList extends TestAbstractLinkedList {\n+public class TestNodeCachingLinkedList<E> extends TestAbstractLinkedList<E> {\n \n     public TestNodeCachingLinkedList(String testName) {\n         super(testName);\n         return BulkTest.makeSuite(TestNodeCachingLinkedList.class);\n     }\n \n-    //-----------------------------------------------------------------------    \n-    public List makeEmptyList() {\n-        return new NodeCachingLinkedList();\n+    //-----------------------------------------------------------------------\n+    public NodeCachingLinkedList<E> makeObject() {\n+        return new NodeCachingLinkedList<E>();\n     }\n \n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testShrinkCache() {\n         if (isRemoveSupported() == false || isAddSupported() == false) return;\n         resetEmpty();\n-        NodeCachingLinkedList list = (NodeCachingLinkedList) collection;\n-        \n-        list.addAll( Arrays.asList( new String[]{\"1\", \"2\", \"3\", \"4\"}));\n-        list.removeAllNodes();        // Will dump all 4 elements into cache\n-        ((NodeCachingLinkedList) list).setMaximumCacheSize(2); // shrink cache\n-        list.addAll( Arrays.asList( new String[]{\"1\", \"2\", \"3\", \"4\"}));\n+        NodeCachingLinkedList<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        list.removeAllNodes(); // Will dump all 4 elements into cache\n+        list.setMaximumCacheSize(2); // shrink cache\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n         checkNodes();\n         list.removeNode(list.getNode(0, false)); // no room in cache\n-        list.removeNode(list.getNode(0, false)); \n-        list.removeNode(list.getNode(0, false)); \n-        checkNodes();    \n-        list.addAll( Arrays.asList( new String[]{\"1\", \"2\", \"3\", \"4\"}));\n-        checkNodes();     \n-    }       \n-    \n+        list.removeNode(list.getNode(0, false));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        checkNodes();\n+    }\n+\n     //-----------------------------------------------------------------------\n     public static void compareSpeed() {\n-        NodeCachingLinkedList ncll = new NodeCachingLinkedList();\n-        LinkedList ll = new LinkedList();\n-        \n+        NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<Object>();\n+        LinkedList<Object> ll = new LinkedList<Object>();\n+\n         Object o1 = new Object();\n         Object o2 = new Object();\n-        \n+\n         int loopCount = 4000000;\n-        \n+\n         long startTime, endTime;\n-        \n+\n         System.out.println(\"Testing relative execution time of commonly-used methods...\");\n-        \n-        startTime = System.currentTimeMillis();   \n+\n+        startTime = System.currentTimeMillis();\n         for(int x = loopCount; x > 0; x--) {\n             // unrolled a few times to minimize effect of loop\n             ll.addFirst(o1);\n             ll.add(o1);\n             ll.remove(0);\n         }\n-        endTime = System.currentTimeMillis();   \n+        endTime = System.currentTimeMillis();\n         System.out.println(\"Time with LinkedList: \" + (endTime - startTime) + \" ms\");\n \n-        startTime = System.currentTimeMillis();   \n+        startTime = System.currentTimeMillis();\n         for(int x = loopCount; x > 0; x--) {\n             ncll.addFirst(o1);\n             ncll.addLast(o2);\n             ncll.add(o1);\n             ncll.remove(0);\n         }\n-        endTime = System.currentTimeMillis();   \n+        endTime = System.currentTimeMillis();\n         System.out.println(\"Time with NodeCachingLinkedList: \" + (endTime - startTime) + \" ms\");\n \n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk((java.io.Serializable) collection,\n //        writeExternalFormToDisk((java.io.Serializable) collection,\n //            \"D:/dev/collections/data/test/NodeCachingLinkedList.fullCollection.version3.obj\");\n //    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public NodeCachingLinkedList<E> getCollection() {\n+        return (NodeCachingLinkedList<E>) super.getCollection();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/list/TestPredicatedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestPredicatedList.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.PredicateUtils;\n+import org.apache.commons.collections.functors.TruePredicate;\n \n /**\n  * Extension of {@link AbstractTestList} for exercising the \n  *\n  * @author Phil Steitz\n  */\n-public class TestPredicatedList extends AbstractTestList {\n-    \n+public class TestPredicatedList<E> extends AbstractTestList<E> {\n+\n     public TestPredicatedList(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestPredicatedList.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestPredicatedList.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n+\n  //-------------------------------------------------------------------\n-    \n-    protected Predicate truePredicate = PredicateUtils.truePredicate();\n-    \n-    protected List decorateList(List list, Predicate predicate) {\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected List<E> decorateList(List<E> list, Predicate<E> predicate) {\n         return PredicatedList.decorate(list, predicate);\n     }\n-    \n-    public List makeEmptyList() {\n-        return decorateList(new ArrayList(), truePredicate);\n+\n+    public List<E> makeObject() {\n+        return decorateList(new ArrayList<E>(), truePredicate);\n     }\n-    \n-    public Object[] getFullElements() {\n-        return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n     }\n-    \n-//--------------------------------------------------------------------   \n-    \n-     protected Predicate testPredicate =  \n-        new Predicate() {\n-            public boolean evaluate(Object o) {\n+\n+//--------------------------------------------------------------------\n+\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n                 return o instanceof String;\n             }\n-        };      \n-    \n-    public List makeTestList() {\n-        return decorateList(new ArrayList(), testPredicate);\n+        };\n+\n+    public List<E> makeTestList() {\n+        return decorateList(new ArrayList<E>(), testPredicate);\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        List list = makeTestList();\n+        List<E> list = makeTestList();\n         Integer i = new Integer(3);\n         try {\n-            list.add(i);\n+            list.add((E) i);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        assertTrue(\"Collection shouldn't contain illegal element\", \n-         !list.contains(i));   \n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !list.contains(i));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        List list = makeTestList();\n-        List elements = new ArrayList();\n-        elements.add(\"one\");\n-        elements.add(\"two\");\n-        elements.add(new Integer(3));\n-        elements.add(\"four\");\n+        List<E> list = makeTestList();\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n         try {\n-            list.addAll(0,elements);\n+            list.addAll(0, elements);\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        assertTrue(\"List shouldn't contain illegal element\", \n-         !list.contains(\"one\"));   \n-        assertTrue(\"List shouldn't contain illegal element\", \n-         !list.contains(\"two\"));   \n-        assertTrue(\"List shouldn't contain illegal element\", \n-         !list.contains(new Integer(3)));   \n-        assertTrue(\"List shouldn't contain illegal element\", \n-         !list.contains(\"four\"));   \n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"one\"));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"two\"));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(new Integer(3)));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"four\"));\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testIllegalSet() {\n-        List list = makeTestList();\n+        List<E> list = makeTestList();\n         try {\n-            list.set(0,new Integer(3));\n+            list.set(0, (E) new Integer(3));\n             fail(\"Integer should fail string predicate.\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testLegalAddAll() {\n-        List list = makeTestList();\n-        list.add(\"zero\");\n-        List elements = new ArrayList();\n-        elements.add(\"one\");\n-        elements.add(\"two\");\n-        elements.add(\"three\");\n+        List<E> list = makeTestList();\n+        list.add((E) \"zero\");\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) \"three\");\n         list.addAll(1,elements);\n-        assertTrue(\"List should contain legal element\", \n-         list.contains(\"zero\"));   \n-        assertTrue(\"List should contain legal element\", \n-         list.contains(\"one\"));   \n-        assertTrue(\"List should contain legal element\", \n-         list.contains(\"two\"));   \n-        assertTrue(\"List should contain legal element\", \n-         list.contains(\"three\"));   \n-    }       \n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"zero\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"one\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"two\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"three\"));\n+    }\n \n     public String getCompatibilityVersion() {\n         return \"3.1\";\n--- a/src/test/org/apache/commons/collections/list/TestSetUniqueList.java\n+++ b/src/test/org/apache/commons/collections/list/TestSetUniqueList.java\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n  * @author Matthew Hawthorne\n  * @author Tom Dunham\n  */\n-public class TestSetUniqueList extends AbstractTestList {\n+public class TestSetUniqueList<E> extends AbstractTestList<E> {\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n \n     //-----------------------------------------------------------------------\n-    public List makeEmptyList() {\n-        return new SetUniqueList(new ArrayList(), new HashSet());\n+    public List<E> makeObject() {\n+        return new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n     }\n \n     public void testListIteratorSet() {\n         // override to block\n         resetFull();\n-        ListIterator it = getList().listIterator();\n+        ListIterator<E> it = getCollection().listIterator();\n         it.next();\n         try {\n             it.set(null);\n             fail();\n         } catch (UnsupportedOperationException ex) {}\n     }\n-    \n-    public Object[] getFullNonNullElements() {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n         // override to avoid duplicate \"One\"\n-        return new Object[] {\n-            new String(\"\"),\n-            new String(\"One\"),\n-            new Integer(2),\n-            \"Three\",\n-            new Integer(4),\n-            new Double(5),\n-            new Float(6),\n-            \"Seven\",\n-            \"Eight\",\n-            new String(\"Nine\"),\n-            new Integer(10),\n-            new Short((short)11),\n-            new Long(12),\n-            \"Thirteen\",\n-            \"14\",\n-            \"15\",\n-            new Byte((byte)16)\n+        return (E[]) new Object[] {\n+                new String(\"\"),\n+                new String(\"One\"),\n+                new Integer(2),\n+                \"Three\",\n+                new Integer(4),\n+                new Double(5),\n+                new Float(6),\n+                \"Seven\",\n+                \"Eight\",\n+                new String(\"Nine\"),\n+                new Integer(10),\n+                new Short((short)11),\n+                new Long(12),\n+                \"Thirteen\",\n+                \"14\",\n+                \"15\",\n+                new Byte((byte)16)\n         };\n     }\n-    \n+\n     public void testListIteratorAdd() {\n         // override to cope with Set behaviour\n         resetEmpty();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Object[] elements = getOtherElements();  // changed here\n-        ListIterator iter1 = list1.listIterator();\n-        ListIterator iter2 = list2.listIterator();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        E[] elements = getOtherElements();  // changed here\n+        ListIterator<E> iter1 = list1.listIterator();\n+        ListIterator<E> iter2 = list2.listIterator();\n \n         for (int i = 0; i < elements.length; i++) {\n             iter1.add(elements[i]);\n         }\n \n         resetFull();\n-        iter1 = getList().listIterator();\n-        iter2 = getConfirmedList().listIterator();\n+        iter1 = getCollection().listIterator();\n+        iter2 = getConfirmed().listIterator();\n         for (int i = 0; i < elements.length; i++) {\n             iter1.next();\n             iter2.next();\n             super.verify();  // changed here\n         }\n     }\n-    \n+\n     public void testCollectionAddAll() {\n         // override for set behaviour\n         resetEmpty();\n-        Object[] elements = getFullElements();\n-        boolean r = collection.addAll(Arrays.asList(elements));\n-        confirmed.addAll(Arrays.asList(elements));\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Empty collection should change after addAll\", r);\n         for (int i = 0; i < elements.length; i++) {\n             assertTrue(\"Collection should contain added element\",\n-                       collection.contains(elements[i]));\n+                    getCollection().contains(elements[i]));\n         }\n \n         resetFull();\n-        int size = collection.size();\n+        int size = getCollection().size();\n         elements = getOtherElements();\n-        r = collection.addAll(Arrays.asList(elements));\n-        confirmed.addAll(Arrays.asList(elements));\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Full collection should change after addAll\", r);\n         for (int i = 0; i < elements.length; i++) {\n             assertTrue(\"Full collection should contain added element \" + i,\n-                       collection.contains(elements[i]));\n-        }\n-        assertEquals(\"Size should increase after addAll\", \n-                     size + elements.length, collection.size());\n-    }\n-\n+                    getCollection().contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\",\n+                size + elements.length, getCollection().size());\n+    }\n+\n+    // TODO: Generics\n     public void testIntCollectionAddAll() {\n       // make a SetUniqueList with one element\n       List list = new SetUniqueList(new ArrayList(), new HashSet());\n       // add two new unique elements at index 0\n       final Integer firstNewElement = new Integer(2);\n       final Integer secondNewElement = new Integer(3);\n-      collection = Arrays.asList(new Integer[] {firstNewElement, secondNewElement});\n+      Collection collection = Arrays.asList(new Integer[] {firstNewElement, secondNewElement});\n       list.addAll(0, collection);\n       assertEquals(\"Unique elements should be added.\", 3, list.size());\n       assertEquals(\"First new element should be at index 0\", firstNewElement, list.get(0));\n       assertEquals(\"Third new element should be at index 0\", thirdNewElement, list.get(0));\n     }\n     \n+    @SuppressWarnings(\"unchecked\")\n     public void testListSetByIndex() {\n         // override for set behaviour\n         resetFull();\n-        int size = collection.size();\n-        getList().set(0, new Long(1000));\n-        assertEquals(size, collection.size());\n-\n-        getList().set(2, new Long(1000));\n-        assertEquals(size - 1, collection.size());\n-        assertEquals(new Long(1000), getList().get(1));  // set into 2, but shifted down to 1\n-    }\n-    \n+        int size = getCollection().size();\n+        getCollection().set(0, (E) new Long(1000));\n+        assertEquals(size, getCollection().size());\n+\n+        getCollection().set(2, (E) new Long(1000));\n+        assertEquals(size - 1, getCollection().size());\n+        assertEquals(new Long(1000), getCollection().get(1));  // set into 2, but shifted down to 1\n+    }\n+\n     boolean extraVerify = true;\n     public void testCollectionIteratorRemove() {\n         try {\n             extraVerify = true;\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void verify() {\n         super.verify();\n-        \n+\n         if (extraVerify) {\n-            int size = collection.size();\n-            getList().add(new Long(1000));\n-            assertEquals(size + 1, collection.size());\n-\n-            getList().add(new Long(1000));\n-            assertEquals(size + 1, collection.size());\n-            assertEquals(new Long(1000), getList().get(size));\n-        \n-            getList().remove(size);\n-        }\n-    }\n-    \n+            int size = getCollection().size();\n+            getCollection().add((E) new Long(1000));\n+            assertEquals(size + 1, getCollection().size());\n+\n+            getCollection().add((E) new Long(1000));\n+            assertEquals(size + 1, getCollection().size());\n+            assertEquals(new Long(1000), getCollection().get(size));\n+\n+            getCollection().remove(size);\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testFactory() {\n-        Integer[] array = new Integer[] {new Integer(1), new Integer(2), new Integer(1)};\n-        ArrayList list = new ArrayList(Arrays.asList(array));\n-        final SetUniqueList lset = SetUniqueList.decorate(list);\n+        Integer[] array = new Integer[] { new Integer(1), new Integer(2), new Integer(1) };\n+        ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(array));\n+        final SetUniqueList<Integer> lset = SetUniqueList.decorate(list);\n \n         assertEquals(\"Duplicate element was added.\", 2, lset.size());\n         assertEquals(new Integer(1), lset.get(0));\n         assertEquals(new Integer(2), list.get(1));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testAdd() {\n-        final SetUniqueList lset = new SetUniqueList(new ArrayList(), new HashSet());\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n \n         // Duplicate element\n-        final Object obj = new Integer(1);\n+        final E obj = (E) new Integer(1);\n         lset.add(obj);\n         lset.add(obj);\n         assertEquals(\"Duplicate element was added.\", 1, lset.size());\n \n         // Unique element\n-        lset.add(new Integer(2));\n+        lset.add((E) new Integer(2));\n         assertEquals(\"Unique element was not added.\", 2, lset.size());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testAddAll() {\n-        final SetUniqueList lset = new SetUniqueList(new ArrayList(), new HashSet());\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n \n         lset.addAll(\n-            Arrays.asList(new Integer[] { new Integer(1), new Integer(1)}));\n+            Arrays.asList((E[]) new Integer[] { new Integer(1), new Integer(1)}));\n \n         assertEquals(\"Duplicate element was added.\", 1, lset.size());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSet() {\n-        final SetUniqueList lset = new SetUniqueList(new ArrayList(), new HashSet());\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n \n         // Duplicate element\n-        final Object obj1 = new Integer(1);\n-        final Object obj2 = new Integer(2);\n-        final Object obj3 = new Integer(3);\n+        final E obj1 = (E) new Integer(1);\n+        final E obj2 = (E) new Integer(2);\n+        final E obj3 = (E) new Integer(3);\n \n         lset.add(obj1);\n         lset.add(obj2);\n         assertSame(obj1, lset.get(0));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testListIterator() {\n-        final SetUniqueList lset = new SetUniqueList(new ArrayList(), new HashSet());\n-\n-        final Object obj1 = new Integer(1);\n-        final Object obj2 = new Integer(2);\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        final E obj1 = (E) new Integer(1);\n+        final E obj2 = (E) new Integer(2);\n         lset.add(obj1);\n         lset.add(obj2);\n \n         // Attempts to add a duplicate object\n-        for (final ListIterator it = lset.listIterator(); it.hasNext();) {\n+        for (final ListIterator<E> it = lset.listIterator(); it.hasNext();) {\n             it.next();\n \n             if (!it.hasNext()) {\n         assertEquals(\"Duplicate element was added\", 2, lset.size());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testUniqueListReInsert() {\n-        List l = SetUniqueList.decorate(new LinkedList());\n-        l.add(new Object());\n-        l.add(new Object());\n-        \n-        Object a = l.get(0);\n-        \n+        List<E> l = SetUniqueList.decorate(new LinkedList<E>());\n+        l.add((E) new Object());\n+        l.add((E) new Object());\n+\n+        E a = l.get(0);\n+\n         // duplicate is removed\n-        l.set(0, l.get(1)); \n+        l.set(0, l.get(1));\n         assertEquals(1, l.size());\n-        \n-        // old object is added back in \n-        l.add(1, a); \n+\n+        // old object is added back in\n+        l.add(1, a);\n         assertEquals(2, l.size());\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testUniqueListDoubleInsert() {\n-        List l = SetUniqueList.decorate(new LinkedList());\n-        l.add(new Object());\n-        l.add(new Object());\n-        \n+        List<E> l = SetUniqueList.decorate(new LinkedList<E>());\n+        l.add((E) new Object());\n+        l.add((E) new Object());\n+\n         // duplicate is removed\n-        l.set(0, l.get(1)); \n+        l.set(0, l.get(1));\n         assertEquals(1, l.size());\n-        \n+\n         // duplicate should be removed again\n         l.add(1, l.get(0));\n         assertEquals(1, l.size());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSetDownwardsInList() {\n         /*\n          * Checks the following semantics\n          * set(0,b): [b]->a\n          * So UniqList contains [b] and a is returned\n          */\n-        ArrayList l = new ArrayList();\n-        HashSet s = new HashSet();\n-        final SetUniqueList ul = new SetUniqueList(l, s);\n-\n-        Object a = new Object();\n-        Object b = new Object();\n+        ArrayList<E> l = new ArrayList<E>();\n+        HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        E a = (E) new Object();\n+        E b = (E) new Object();\n         ul.add(a);\n         ul.add(b);\n         assertEquals(a, l.get(0));\n         assertEquals(b, l.get(1));\n-        assertTrue(s.contains(a)); \n+        assertTrue(s.contains(a));\n         assertTrue(s.contains(b));\n-        \n+\n         assertEquals(a, ul.set(0, b));\n         assertEquals(1, s.size());\n         assertEquals(1, l.size());\n         assertFalse(s.contains(a));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSetInBiggerList() {\n         /*\n          * Checks the following semantics\n          * set(0,b): [b,c]->a\n          * So UniqList contains [b,c] and a is returned\n          */\n-        ArrayList l = new ArrayList();\n-        HashSet s = new HashSet();\n-        final SetUniqueList ul = new SetUniqueList(l, s);\n-\n-        Object a = new Object();\n-        Object b = new Object();\n-        Object c = new Object();\n+        ArrayList<E> l = new ArrayList<E>();\n+        HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        E a = (E) new Object();\n+        E b = (E) new Object();\n+        E c = (E) new Object();\n \n         ul.add(a);\n         ul.add(b);\n         assertEquals(a, l.get(0));\n         assertEquals(b, l.get(1));\n         assertEquals(c, l.get(2));\n-        assertTrue(s.contains(a)); \n+        assertTrue(s.contains(a));\n         assertTrue(s.contains(b));\n         assertTrue(s.contains(c));\n-        \n+\n         assertEquals(a, ul.set(0, b));\n         assertEquals(2, s.size());\n         assertEquals(2, l.size());\n         assertFalse(s.contains(a));\n         assertTrue(s.contains(b));\n         assertTrue(s.contains(c));\n-    }    \n-\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testSetUpwardsInList() {\n         /*\n          * Checks the following semantics\n          * set(1,a): [a,c]->b\n          * So UniqList contains [a,c] and b is returned\n          */\n-        ArrayList l = new ArrayList();\n-        HashSet s = new HashSet();\n-        final SetUniqueList ul = new SetUniqueList(l, s);\n-\n-        Object a = new String(\"A\");\n-        Object b = new String(\"B\");\n-        Object c = new String(\"C\");\n+        ArrayList<E> l = new ArrayList<E>();\n+        HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        E a = (E) new String(\"A\");\n+        E b = (E) new String(\"B\");\n+        E c = (E) new String(\"C\");\n \n         ul.add(a);\n         ul.add(b);\n         assertEquals(a, l.get(0));\n         assertEquals(b, l.get(1));\n         assertEquals(c, l.get(2));\n-        assertTrue(s.contains(a)); \n+        assertTrue(s.contains(a));\n         assertTrue(s.contains(b));\n         assertTrue(s.contains(c));\n-        \n+\n         assertEquals(b, ul.set(1, a));\n         assertEquals(2, s.size());\n         assertEquals(2, l.size());\n //        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SetUniqueList.fullCollection.version3.1.obj\");\n //    }\n \n+    // TODO: Generics\n     public void testCollections304() {\n         List list = new LinkedList();\n         SetUniqueList decoratedList = SetUniqueList.decorate(list);\n         assertEquals(4, decoratedList.size());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testCollections307() {\n-        List list = new ArrayList();\n-        List uniqueList = SetUniqueList.decorate(list);\n+        List<E> list = new ArrayList<E>();\n+        List<E> uniqueList = SetUniqueList.decorate(list);\n \n         String hello = \"Hello\";\n         String world = \"World\";\n-        uniqueList.add(hello);\n-        uniqueList.add(world);\n-\n-        List subList = list.subList(0, 0);\n-        List subUniqueList = uniqueList.subList(0, 0);\n+        uniqueList.add((E) hello);\n+        uniqueList.add((E) world);\n+\n+        List<E> subList = list.subList(0, 0);\n+        List<E> subUniqueList = uniqueList.subList(0, 0);\n \n         assertFalse(subList.contains(world)); // passes\n         assertFalse(subUniqueList.contains(world)); // fails\n \n-        List worldList = new ArrayList();\n-        worldList.add(world);\n+        List<E> worldList = new ArrayList<E>();\n+        worldList.add((E) world);\n         assertFalse(subList.contains(\"World\")); // passes\n         assertFalse(subUniqueList.contains(\"World\")); // fails\n \n-        // repeat the test with a different class than HashSet; \n+        // repeat the test with a different class than HashSet;\n         // which means subclassing SetUniqueList below\n-        list = new ArrayList();\n-        uniqueList = new SetUniqueList307(list, new java.util.TreeSet());\n-\n-        uniqueList.add(hello);\n-        uniqueList.add(world);\n+        list = new ArrayList<E>();\n+        uniqueList = new SetUniqueList307(list, new java.util.TreeSet<E>());\n+\n+        uniqueList.add((E) hello);\n+        uniqueList.add((E) world);\n \n         subList = list.subList(0, 0);\n         subUniqueList = uniqueList.subList(0, 0);\n         assertFalse(subList.contains(world)); // passes\n         assertFalse(subUniqueList.contains(world)); // fails\n \n-        worldList = new ArrayList();\n-        worldList.add(world);\n+        worldList = new ArrayList<E>();\n+        worldList.add((E) world);\n         assertFalse(subList.contains(\"World\")); // passes\n         assertFalse(subUniqueList.contains(\"World\")); // fails\n     }\n \n-    class SetUniqueList307 extends SetUniqueList {\n-        public SetUniqueList307(List list, Set set) {\n+    @SuppressWarnings(\"serial\")\n+    class SetUniqueList307 extends SetUniqueList<E> {\n+        public SetUniqueList307(List<E> list, Set<E> set) {\n             super(list, set);\n         }\n     }\n--- a/src/test/org/apache/commons/collections/list/TestSynchronizedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestSynchronizedList.java\n package org.apache.commons.collections.list;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.List;\n \n import junit.framework.Test;\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestSynchronizedList extends AbstractTestList {\n-    \n+public class TestSynchronizedList<E> extends AbstractTestList<E> {\n+\n     public TestSynchronizedList(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n \n-    public List makeEmptyList() {\n-        return SynchronizedList.decorate(new ArrayList());\n+    public List<E> makeObject() {\n+        return SynchronizedList.decorate(new ArrayList<E>());\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/list/TestTransformedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestTransformedList.java\n \n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collection;\n import java.util.List;\n import java.util.ListIterator;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n /**\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedList extends AbstractTestList {\n-    \n+public class TestTransformedList<E> extends AbstractTestList<E> {\n+\n     public TestTransformedList(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        List list = new ArrayList();\n+    public List<E> makeConfirmedFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n-    \n-    public List makeEmptyList() {\n-        return TransformedList.decorate(new ArrayList(), TestTransformedCollection.NOOP_TRANSFORMER);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public List<E> makeObject() {\n+        return TransformedList.decorate(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n-    public List makeFullList() {\n-        List list = new ArrayList();\n+    @SuppressWarnings(\"unchecked\")\n+    public List<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return TransformedList.decorate(list, TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedList.decorate(list, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testTransformedList() {\n-        List list = TransformedList.decorate(new ArrayList(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        List<E> list = TransformedList.decorate(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, list.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n             list.add(els[i]);\n             assertEquals(i + 1, list.size());\n             assertEquals(true, list.contains(new Integer((String) els[i])));\n             assertEquals(false, list.contains(els[i]));\n         }\n-        \n+\n         assertEquals(false, list.remove(els[0]));\n         assertEquals(true, list.remove(new Integer((String) els[0])));\n-        \n+\n         list.clear();\n         for (int i = 0; i < els.length; i++) {\n             list.add(0, els[i]);\n             assertEquals(i + 1, list.size());\n             assertEquals(new Integer((String) els[i]), list.get(0));\n         }\n-        \n-        list.set(0, \"22\");\n+\n+        list.set(0, (E) \"22\");\n         assertEquals(new Integer(22), list.get(0));\n-        \n-        ListIterator it = list.listIterator();\n+\n+        ListIterator<E> it = list.listIterator();\n         it.next();\n-        it.set(\"33\");\n+        it.set((E) \"33\");\n         assertEquals(new Integer(33), list.get(0));\n-        it.add(\"44\");\n+        it.add((E) \"44\");\n         assertEquals(new Integer(44), list.get(1));\n-        \n-        List adds = new ArrayList();\n-        adds.add(\"1\");\n-        adds.add(\"2\");\n+\n+        List<E> adds = new ArrayList<E>();\n+        adds.add((E) \"1\");\n+        adds.add((E) \"2\");\n         list.clear();\n         list.addAll(adds);\n         assertEquals(new Integer(1), list.get(0));\n         assertEquals(new Integer(2), list.get(1));\n-        \n+\n         adds.clear();\n-        adds.add(\"3\");\n+        adds.add((E) \"3\");\n         list.addAll(1, adds);\n         assertEquals(new Integer(1), list.get(0));\n         assertEquals(new Integer(3), list.get(1));\n--- a/src/test/org/apache/commons/collections/list/TestUnmodifiableList.java\n+++ b/src/test/org/apache/commons/collections/list/TestUnmodifiableList.java\n import junit.framework.TestSuite;\n \n /**\n- * Extension of {@link AbstractTestList} for exercising the \n+ * Extension of {@link AbstractTestList} for exercising the\n  * {@link UnmodifiableList} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestUnmodifiableList extends AbstractTestList {\n-    \n+public class TestUnmodifiableList<E> extends AbstractTestList<E> {\n+\n     public TestUnmodifiableList(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableList.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableList.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    //-----------------------------------------------------------------------    \n-    public List makeEmptyList() {\n-        return UnmodifiableList.decorate(new ArrayList());\n+    //-----------------------------------------------------------------------\n+    public UnmodifiableList<E> makeObject() {\n+        return new UnmodifiableList<E>(new ArrayList<E>());\n     }\n-    \n-    public List makeFullList() {\n-        ArrayList list = new ArrayList();\n+\n+    public UnmodifiableList<E> makeFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return UnmodifiableList.decorate(list);\n+        return new UnmodifiableList<E>(list);\n     }\n-    \n+\n     public boolean isSetSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n-    //-----------------------------------------------------------------------    \n-    protected UnmodifiableList list = null;\n-    protected ArrayList array = null;\n-    \n+\n+    //-----------------------------------------------------------------------\n+    protected UnmodifiableList<E> list;\n+    protected ArrayList<E> array;\n+\n+    @SuppressWarnings(\"unchecked\")\n     protected void setupList() {\n-        list = (UnmodifiableList) makeFullList();\n-        array = new ArrayList();\n-        array.add(new Integer(1));\n+        list = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) new Integer(1));\n     }\n-    \n-    /** \n+\n+    /**\n      * Verify that base list and sublists are not modifiable\n      */\n     public void testUnmodifiable() {\n         setupList();\n-        verifyUnmodifiable(list); \n+        verifyUnmodifiable(list);\n         verifyUnmodifiable(list.subList(0, 2));\n-    } \n-        \n-    protected void verifyUnmodifiable(List list) {\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected void verifyUnmodifiable(List<E> list) {\n         try {\n-            list.add(0, new Integer(0));\n+            list.add(0, (E) new Integer(0));\n             fail(\"Expecting UnsupportedOperationException.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n-        } \n+        }\n         try {\n-            list.add(new Integer(0));\n+            list.add((E) new Integer(0));\n              fail(\"Expecting UnsupportedOperationException.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n             // expected\n         }\n         try {\n-            list.set(0, new Integer(0));\n+            list.set(0, (E) new Integer(0));\n              fail(\"Expecting UnsupportedOperationException.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n     }\n-    \n+\n     /**\n      * Verify that iterator is not modifiable\n      */\n     public void testUnmodifiableIterator() {\n         setupList();\n-        Iterator iterator = list.iterator();\n+        Iterator<E> iterator = list.iterator();\n         try {\n-            Object obj = iterator.next();\n+            iterator.next();\n             iterator.remove();\n             fail(\"Expecting UnsupportedOperationException.\");\n         } catch (UnsupportedOperationException e) {\n--- a/src/test/org/apache/commons/collections/map/AbstractTestOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/AbstractTestOrderedMap.java\n import java.util.TreeMap;\n \n import org.apache.commons.collections.BulkTest;\n-import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.comparators.NullComparator;\n import org.apache.commons.collections.iterators.AbstractTestOrderedMapIterator;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestOrderedMap extends AbstractTestIterableMap {\n+public abstract class AbstractTestOrderedMap<K, V> extends AbstractTestIterableMap<K, V> {\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test name\n      */\n     public AbstractTestOrderedMap(String testName) {\n         super(testName);\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract OrderedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        return (OrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * OrderedMap uses TreeMap as its known comparison.\n-     * \n+     *\n      * @return a map that is known to be valid\n      */\n-    public Map makeConfirmedMap() {\n-        return new TreeMap(new NullComparator());\n-    }\n-    \n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new NullComparator<K>());\n+    }\n+\n     /**\n      * The only confirmed collection we have that is ordered is the sorted one.\n      * Thus, sort the keys.\n      */\n-    public Object[] getSampleKeys() {\n-        List list = new ArrayList(Arrays.asList(super.getSampleKeys()));\n-        Collections.sort(list, new NullComparator());\n-        return list.toArray();\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        List<K> list = new ArrayList<K>(Arrays.asList(super.getSampleKeys()));\n+        Collections.sort(list, new NullComparator<K>());\n+        return (K[]) list.toArray();\n     }\n \n     //-----------------------------------------------------------------------\n     public void testFirstKey() {\n         resetEmpty();\n-        OrderedMap ordered = (OrderedMap) map;\n+        OrderedMap<K, V> ordered = getMap();\n         try {\n             ordered.firstKey();\n             fail();\n         } catch (NoSuchElementException ex) {}\n-        \n-        resetFull();\n-        ordered = (OrderedMap) map;\n-        Object confirmedFirst = confirmed.keySet().iterator().next();\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedFirst = confirmed.keySet().iterator().next();\n         assertEquals(confirmedFirst, ordered.firstKey());\n     }\n-    \n+\n     public void testLastKey() {\n         resetEmpty();\n-        OrderedMap ordered = (OrderedMap) map;\n+        OrderedMap<K, V> ordered = getMap();\n         try {\n             ordered.lastKey();\n             fail();\n         } catch (NoSuchElementException ex) {}\n-        \n-        resetFull();\n-        ordered = (OrderedMap) map;\n-        Object confirmedLast = null;\n-        for (Iterator it = confirmed.keySet().iterator(); it.hasNext();) {\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedLast = null;\n+        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n             confirmedLast = it.next();\n         }\n         assertEquals(confirmedLast, ordered.lastKey());\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     public void testNextKey() {\n         resetEmpty();\n-        OrderedMap ordered = (OrderedMap) map;\n+        OrderedMap<K, V> ordered = getMap();\n         assertEquals(null, ordered.nextKey(getOtherKeys()[0]));\n-        if (isAllowNullKey() == false) {\n+        if (!isAllowNullKey()) {\n             try {\n                 assertEquals(null, ordered.nextKey(null)); // this is allowed too\n             } catch (NullPointerException ex) {}\n         } else {\n             assertEquals(null, ordered.nextKey(null));\n         }\n-        \n-        resetFull();\n-        ordered = (OrderedMap) map;\n-        Iterator it = confirmed.keySet().iterator();\n-        Object confirmedLast = it.next();\n+\n+        resetFull();\n+        ordered = getMap();\n+        Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            Object confirmedObject = it.next();\n+            K confirmedObject = it.next();\n             assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n         assertEquals(null, ordered.nextKey(confirmedLast));\n-        \n+\n         if (isAllowNullKey() == false) {\n             try {\n                 ordered.nextKey(null);\n             assertEquals(null, ordered.nextKey(null));\n         }\n     }\n-    \n+\n     public void testPreviousKey() {\n         resetEmpty();\n-        OrderedMap ordered = (OrderedMap) map;\n+        OrderedMap<K, V> ordered = getMap();\n         assertEquals(null, ordered.previousKey(getOtherKeys()[0]));\n         if (isAllowNullKey() == false) {\n             try {\n         } else {\n             assertEquals(null, ordered.previousKey(null));\n         }\n-        \n-        resetFull();\n-        ordered = (OrderedMap) map;\n-        List list = new ArrayList(confirmed.keySet());\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(confirmed.keySet());\n         Collections.reverse(list);\n-        Iterator it = list.iterator();\n-        Object confirmedLast = it.next();\n+        Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            Object confirmedObject = it.next();\n+            K confirmedObject = it.next();\n             assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n         assertEquals(null, ordered.previousKey(confirmedLast));\n-        \n+\n         if (isAllowNullKey() == false) {\n             try {\n                 ordered.previousKey(null);\n             }\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public BulkTest bulkTestOrderedMapIterator() {\n         return new InnerTestOrderedMapIterator();\n     }\n-    \n-    public class InnerTestOrderedMapIterator extends AbstractTestOrderedMapIterator {\n+\n+    public class InnerTestOrderedMapIterator extends AbstractTestOrderedMapIterator<K, V> {\n         public InnerTestOrderedMapIterator() {\n             super(\"InnerTestOrderedMapIterator\");\n         }\n-        \n+\n         public boolean supportsRemove() {\n             return AbstractTestOrderedMap.this.isRemoveSupported();\n         }\n         public boolean isGetStructuralModify() {\n             return AbstractTestOrderedMap.this.isGetStructuralModify();\n         }\n-        \n+\n         public boolean supportsSetValue() {\n             return AbstractTestOrderedMap.this.isSetValueSupported();\n         }\n \n-        public MapIterator makeEmptyMapIterator() {\n+        public OrderedMapIterator<K, V> makeEmptyIterator() {\n             resetEmpty();\n-            return ((OrderedMap) AbstractTestOrderedMap.this.map).orderedMapIterator();\n-        }\n-\n-        public MapIterator makeFullMapIterator() {\n+            return AbstractTestOrderedMap.this.getMap().mapIterator();\n+        }\n+\n+        public OrderedMapIterator<K, V> makeObject() {\n             resetFull();\n-            return ((OrderedMap) AbstractTestOrderedMap.this.map).orderedMapIterator();\n-        }\n-        \n-        public Map getMap() {\n+            return AbstractTestOrderedMap.this.getMap().mapIterator();\n+        }\n+\n+        public OrderedMap<K, V> getMap() {\n             // assumes makeFullMapIterator() called first\n-            return AbstractTestOrderedMap.this.map;\n-        }\n-        \n-        public Map getConfirmedMap() {\n+            return AbstractTestOrderedMap.this.getMap();\n+        }\n+\n+        public Map<K, V> getConfirmedMap() {\n             // assumes makeFullMapIterator() called first\n-            return AbstractTestOrderedMap.this.confirmed;\n-        }\n-        \n+            return AbstractTestOrderedMap.this.getConfirmed();\n+        }\n+\n         public void verify() {\n             super.verify();\n             AbstractTestOrderedMap.this.verify();\n         }\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> getMap() {\n+        return (OrderedMap<K, V>) super.getMap();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/AbstractTestSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/AbstractTestSortedMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestSortedMap extends AbstractTestMap {\n+public abstract class AbstractTestSortedMap<K, V> extends AbstractTestMap<K, V> {\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test name\n      */\n     public AbstractTestSortedMap(String testName) {\n         super(testName);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Can't sort null keys.\n-     * \n+     *\n      * @return false\n      */\n     public boolean isAllowNullKey() {\n \n     /**\n      * SortedMap uses TreeMap as its known comparison.\n-     * \n+     *\n      * @return a map that is known to be valid\n      */\n-    public Map makeConfirmedMap() {\n-        return new TreeMap();\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n     }\n \n     //-----------------------------------------------------------------------\n     public void testComparator() {\n-        SortedMap sm = (SortedMap) makeFullMap();\n+//        SortedMap<K, V> sm = makeFullMap();\n         // no tests I can think of\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        return (SortedMap<K, V>) super.makeFullMap();\n+    }\n+\n     public void testFirstKey() {\n-        SortedMap sm = (SortedMap) makeFullMap();\n+        SortedMap<K, V> sm = makeFullMap();\n         assertSame(sm.keySet().iterator().next(), sm.firstKey());\n     }\n-    \n+\n     public void testLastKey() {\n-        SortedMap sm = (SortedMap) makeFullMap();\n-        Object obj = null;\n-        for (Iterator it = sm.keySet().iterator(); it.hasNext();) {\n-            obj = (Object) it.next();\n+        SortedMap<K, V> sm = makeFullMap();\n+        K obj = null;\n+        for (Iterator<K> it = sm.keySet().iterator(); it.hasNext();) {\n+            obj = it.next();\n         }\n         assertSame(obj, sm.lastKey());\n     }\n-    \n-    //-----------------------------------------------------------------------    \n+\n+    //-----------------------------------------------------------------------\n     public BulkTest bulkTestHeadMap() {\n-        return new TestHeadMap(this);\n+        return new TestHeadMap<K, V>(this);\n     }\n \n     public BulkTest bulkTestTailMap() {\n-        return new TestTailMap(this);\n+        return new TestTailMap<K, V>(this);\n     }\n \n     public BulkTest bulkTestSubMap() {\n-        return new TestSubMap(this);\n-    }\n-\n-    public static abstract class TestViewMap extends AbstractTestSortedMap {\n-        protected final AbstractTestMap main;\n-        protected final List subSortedKeys = new ArrayList();\n-        protected final List subSortedValues = new ArrayList();\n-        protected final List subSortedNewValues = new ArrayList();\n-        \n-        public TestViewMap(String name, AbstractTestMap main) {\n+        return new TestSubMap<K, V>(this);\n+    }\n+\n+    public static abstract class TestViewMap <K, V> extends AbstractTestSortedMap<K, V> {\n+        protected final AbstractTestMap<K, V> main;\n+        protected final List<K> subSortedKeys = new ArrayList<K>();\n+        protected final List<V> subSortedValues = new ArrayList<V>();\n+        protected final List<V> subSortedNewValues = new ArrayList<V>();\n+\n+        public TestViewMap(String name, AbstractTestMap<K, V> main) {\n             super(name);\n             this.main = main;\n         }\n         public BulkTest bulkTestSubMap() {\n             return null;  // block infinite recursion\n         }\n-        \n-        public Object[] getSampleKeys() {\n-            return subSortedKeys.toArray();\n-        }\n-        public Object[] getSampleValues() {\n-            return subSortedValues.toArray();\n-        }\n-        public Object[] getNewSampleValues() {\n-            return subSortedNewValues.toArray();\n-        }\n-        \n+\n+        @SuppressWarnings(\"unchecked\")\n+        public K[] getSampleKeys() {\n+            return (K[]) subSortedKeys.toArray();\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getSampleValues() {\n+            return (V[]) subSortedValues.toArray();\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getNewSampleValues() {\n+            return (V[]) subSortedNewValues.toArray();\n+        }\n+\n         public boolean isAllowNullKey() {\n             return main.isAllowNullKey();\n         }\n //            super.testFullMapCompatibility();\n //        }\n     }\n-    \n-    public static class TestHeadMap extends TestViewMap {\n+\n+    public static class TestHeadMap<K, V> extends TestViewMap<K, V> {\n         static final int SUBSIZE = 6;\n-        final Object toKey;\n-        \n-        public TestHeadMap(AbstractTestMap main) {\n+        final K toKey;\n+\n+        public TestHeadMap(AbstractTestMap<K, V> main) {\n             super(\"SortedMap.HeadMap\", main);\n-            SortedMap sm = (SortedMap) main.makeFullMap();\n-            for (Iterator it = sm.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n                 this.subSortedKeys.add(entry.getKey());\n                 this.subSortedValues.add(entry.getValue());\n             }\n             this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n         }\n-        public Map makeEmptyMap() {\n+        public SortedMap<K, V> makeObject() {\n             // done this way so toKey is correctly set in the returned map\n-            return ((SortedMap) main.makeEmptyMap()).headMap(toKey);\n-        }\n-        public Map makeFullMap() {\n-            return ((SortedMap) main.makeFullMap()).headMap(toKey);\n+            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n+        }\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n         }\n         public void testHeadMapOutOfRange() {\n             if (isPutAddSupported() == false) return;\n             resetEmpty();\n             try {\n-                ((SortedMap) map).put(toKey, subSortedValues.get(0));\n+                getMap().put(toKey, subSortedValues.get(0));\n                 fail();\n             } catch (IllegalArgumentException ex) {}\n             verify();\n //                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj\");\n //        }\n     }\n-    \n-    public static class TestTailMap extends TestViewMap {\n+\n+    public static class TestTailMap <K, V> extends TestViewMap<K, V> {\n         static final int SUBSIZE = 6;\n-        final Object fromKey;\n-        final Object invalidKey;\n-        \n-        public TestTailMap(AbstractTestMap main) {\n+        final K fromKey;\n+        final K invalidKey;\n+\n+        public TestTailMap(AbstractTestMap<K, V> main) {\n             super(\"SortedMap.TailMap\", main);\n-            SortedMap sm = (SortedMap) main.makeFullMap();\n-            for (Iterator it = sm.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n                 this.subSortedKeys.add(entry.getKey());\n                 this.subSortedValues.add(entry.getValue());\n             }\n             this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n         }\n-        public Map makeEmptyMap() {\n+        public SortedMap<K, V> makeObject() {\n             // done this way so toKey is correctly set in the returned map\n-            return ((SortedMap) main.makeEmptyMap()).tailMap(fromKey);\n-        }\n-        public Map makeFullMap() {\n-            return ((SortedMap) main.makeFullMap()).tailMap(fromKey);\n+            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n+        }\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n         }\n         public void testTailMapOutOfRange() {\n             if (isPutAddSupported() == false) return;\n             resetEmpty();\n             try {\n-                ((SortedMap) map).put(invalidKey, subSortedValues.get(0));\n+                getMap().put(invalidKey, subSortedValues.get(0));\n                 fail();\n             } catch (IllegalArgumentException ex) {}\n             verify();\n //                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj\");\n //        }\n     }\n-    \n-    public static class TestSubMap extends TestViewMap {\n+\n+    public static class TestSubMap<K, V> extends TestViewMap<K, V> {\n         static final int SUBSIZE = 3;\n-        final Object fromKey;\n-        final Object toKey;\n-        \n-        public TestSubMap(AbstractTestMap main) {\n+        final K fromKey;\n+        final K toKey;\n+\n+        public TestSubMap(AbstractTestMap<K, V> main) {\n             super(\"SortedMap.SubMap\", main);\n-            SortedMap sm = (SortedMap) main.makeFullMap();\n-            for (Iterator it = sm.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n                 this.subSortedKeys.add(entry.getKey());\n                 this.subSortedValues.add(entry.getValue());\n             }\n             this.fromKey = this.subSortedKeys.get(SUBSIZE);\n             this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n-            \n+\n             this.subSortedKeys.subList(0, SUBSIZE).clear();\n             this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n-            \n+\n             this.subSortedValues.subList(0, SUBSIZE).clear();\n             this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n-            \n+\n             this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n                 SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n         }\n-        \n-        public Map makeEmptyMap() {\n+\n+        public SortedMap<K, V> makeObject() {\n             // done this way so toKey is correctly set in the returned map\n-            return ((SortedMap) main.makeEmptyMap()).subMap(fromKey, toKey);\n-        }\n-        public Map makeFullMap() {\n-            return ((SortedMap) main.makeFullMap()).subMap(fromKey, toKey);\n+            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n+        }\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n         }\n         public void testSubMapOutOfRange() {\n             if (isPutAddSupported() == false) return;\n             resetEmpty();\n             try {\n-                ((SortedMap) map).put(toKey, subSortedValues.get(0));\n+                getMap().put(toKey, subSortedValues.get(0));\n                 fail();\n             } catch (IllegalArgumentException ex) {}\n             verify();\n //                \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj\");\n //        }\n     }\n-    \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getMap() {\n+        return (SortedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getConfirmed() {\n+        return (SortedMap<K, V>) super.getConfirmed();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestCaseInsensitiveMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestCaseInsensitiveMap.java\n  *\n  * @author Commons-Collections team\n  */\n-public class TestCaseInsensitiveMap extends AbstractTestIterableMap {\n+public class TestCaseInsensitiveMap<K, V> extends AbstractTestIterableMap<K, V> {\n \n     public TestCaseInsensitiveMap(String testName) {\n         super(testName);\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestCaseInsensitiveMap.class);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new CaseInsensitiveMap();\n+    public CaseInsensitiveMap<K, V> makeObject() {\n+        return new CaseInsensitiveMap<K, V>();\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n-   \n+\n     //-------------------------------------------------------------------------\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testCaseInsensitive() {\n-        Map map = new CaseInsensitiveMap();\n-        map.put(\"One\", \"One\");\n-        map.put(\"Two\", \"Two\");\n-        assertEquals(\"One\", (String) map.get(\"one\"));\n-        assertEquals(\"One\", (String) map.get(\"oNe\"));\n-        map.put(\"two\", \"Three\");\n-        assertEquals(\"Three\", (String) map.get(\"Two\"));\n-    } \n-    \n+        Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        assertEquals(\"One\", map.get(\"one\"));\n+        assertEquals(\"One\", map.get(\"oNe\"));\n+        map.put((K) \"two\", (V) \"Three\");\n+        assertEquals(\"Three\", map.get(\"Two\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testNullHandling() {\n-        Map map = new CaseInsensitiveMap();\n-        map.put(\"One\", \"One\");\n-        map.put(\"Two\", \"Two\");\n-        map.put(null, \"Three\");\n-        assertEquals(\"Three\", (String) map.get(null));\n-        map.put(null, \"Four\");\n-        assertEquals(\"Four\", (String) map.get(null));\n-        Set keys = map.keySet();\n+        Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        map.put(null, (V) \"Three\");\n+        assertEquals(\"Three\", map.get(null));\n+        map.put(null, (V) \"Four\");\n+        assertEquals(\"Four\", map.get(null));\n+        Set<K> keys = map.keySet();\n         assertTrue(keys.contains(\"one\"));\n         assertTrue(keys.contains(\"two\"));\n         assertTrue(keys.contains(null));\n         assertEquals(3, keys.size());\n     }\n-        \n+\n     public void testPutAll() {\n-        Map map = new HashMap();\n+        Map<Object, String> map = new HashMap<Object, String>();\n         map.put(\"One\", \"One\");\n         map.put(\"Two\", \"Two\");\n         map.put(\"one\", \"Three\");\n         map.put(null, \"Four\");\n         map.put(new Integer(20), \"Five\");\n-        Map caseInsensitiveMap = new CaseInsensitiveMap(map);\n+        Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<Object, String>(map);\n         assertEquals(4, caseInsensitiveMap.size()); // ones collapsed\n-        Set keys = caseInsensitiveMap.keySet();\n+        Set<Object> keys = caseInsensitiveMap.keySet();\n         assertTrue(keys.contains(\"one\"));\n         assertTrue(keys.contains(\"two\"));\n         assertTrue(keys.contains(null));\n         assertTrue(keys.contains(Integer.toString(20)));\n         assertEquals(4, keys.size());\n-        assertTrue(!caseInsensitiveMap.containsValue(\"One\") \n+        assertTrue(!caseInsensitiveMap.containsValue(\"One\")\n             || !caseInsensitiveMap.containsValue(\"Three\")); // ones collaped\n         assertEquals(\"Four\", caseInsensitiveMap.get(null));\n-    } \n+    }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        CaseInsensitiveMap map = new CaseInsensitiveMap(10);\n-        map.put(\"1\", \"1\");\n-        Map cloned = (Map) map.clone();\n+        CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        CaseInsensitiveMap<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n-    \n+\n     /*\n     public void testCreate() throws Exception {\n         resetEmpty();\n--- a/src/test/org/apache/commons/collections/map/TestFixedSizeSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestFixedSizeSortedMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import java.util.Map;\n import java.util.SortedMap;\n import java.util.TreeMap;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestFixedSizeSortedMap extends AbstractTestSortedMap {\n+public class TestFixedSizeSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n \n     public TestFixedSizeSortedMap(String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Map makeEmptyMap() {\n-        return FixedSizeSortedMap.decorate(new TreeMap());\n+    public SortedMap<K, V> makeObject() {\n+        return FixedSizeSortedMap.decorate(new TreeMap<K, V>());\n     }\n \n-    public Map makeFullMap() {\n-        SortedMap map = new TreeMap();\n+    public SortedMap<K, V> makeFullMap() {\n+        SortedMap<K, V> map = new TreeMap<K, V>();\n         addSampleMappings(map);\n         return FixedSizeSortedMap.decorate(map);\n     }\n-    \n+\n     public boolean isSubMapViewsSerializable() {\n         // TreeMap sub map views have a bug in deserialization.\n         return false;\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk(\n--- a/src/test/org/apache/commons/collections/map/TestFlat3Map.java\n+++ b/src/test/org/apache/commons/collections/map/TestFlat3Map.java\n import junit.textui.TestRunner;\n \n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestFlat3Map extends AbstractTestIterableMap {\n+public class TestFlat3Map<K, V> extends AbstractTestIterableMap<K, V> {\n \n     private static final Integer ONE = new Integer(1);\n     private static final Integer TWO = new Integer(2);\n     private static final String TEN = \"10\";\n     private static final String TWENTY = \"20\";\n     private static final String THIRTY = \"30\";\n-        \n+\n     public TestFlat3Map(String testName) {\n         super(testName);\n     }\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestFlat3Map.class);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new Flat3Map();\n+    public Flat3Map<K, V> makeObject() {\n+        return new Flat3Map<K, V>();\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testEquals1() {\n-        Flat3Map map1 = new Flat3Map();\n-        map1.put(\"a\", \"testA\");\n-        map1.put(\"b\", \"testB\");\n-        Flat3Map map2 = new Flat3Map();\n-        map2.put(\"a\", \"testB\");\n-        map2.put(\"b\", \"testA\");\n+        Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"b\", (V) \"testA\");\n         assertEquals(false, map1.equals(map2));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testEquals2() {\n-        Flat3Map map1 = new Flat3Map();\n-        map1.put(\"a\", \"testA\");\n-        map1.put(\"b\", \"testB\");\n-        Flat3Map map2 = new Flat3Map();\n-        map2.put(\"a\", \"testB\");\n-        map2.put(\"c\", \"testA\");\n+        Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"c\", (V) \"testA\");\n         assertEquals(false, map1.equals(map2));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testClone2() {\n-        Flat3Map map = new Flat3Map();\n+        Flat3Map<K, V> map = makeObject();\n         assertEquals(0, map.size());\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n         assertEquals(2, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n         assertSame(TEN, map.get(ONE));\n         assertSame(TWENTY, map.get(TWO));\n \n-        // clone works (size = 2)        \n-        Flat3Map cloned = (Flat3Map) map.clone();\n+        // clone works (size = 2)\n+        Flat3Map<K, V> cloned = map.clone();\n         assertEquals(2, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n         assertEquals(true, cloned.containsKey(TWO));\n         assertSame(TEN, cloned.get(ONE));\n         assertSame(TWENTY, cloned.get(TWO));\n-        \n+\n         // change original doesn't change clone\n-        map.put(TEN, ONE);\n-        map.put(TWENTY, TWO);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n         assertEquals(4, map.size());\n         assertEquals(2, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n         assertEquals(true, cloned.containsKey(TWO));\n         assertSame(TEN, cloned.get(ONE));\n         assertSame(TWENTY, cloned.get(TWO));\n-    }        \n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testClone4() {\n-        Flat3Map map = new Flat3Map();\n+        Flat3Map<K, V> map = makeObject();\n         assertEquals(0, map.size());\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(TEN, ONE);\n-        map.put(TWENTY, TWO);\n-        \n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n         // clone works (size = 4)\n-        Flat3Map cloned = (Flat3Map) map.clone();\n+        Flat3Map<K, V> cloned = map.clone();\n         assertEquals(4, map.size());\n         assertEquals(4, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n         assertSame(TWENTY, cloned.get(TWO));\n         assertSame(ONE, cloned.get(TEN));\n         assertSame(TWO, cloned.get(TWENTY));\n-        \n+\n         // change original doesn't change clone\n         map.clear();\n         assertEquals(0, map.size());\n         assertSame(ONE, cloned.get(TEN));\n         assertSame(TWO, cloned.get(TWENTY));\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testSerialisation0() throws Exception {\n-        Flat3Map map = new Flat3Map();\n+        Flat3Map<K, V> map = makeObject();\n         ByteArrayOutputStream bout = new ByteArrayOutputStream();\n         ObjectOutputStream out = new ObjectOutputStream(bout);\n         out.writeObject(map);\n         assertEquals(0, map.size());\n         assertEquals(0, ser.size());\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testSerialisation2() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        \n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+\n         ByteArrayOutputStream bout = new ByteArrayOutputStream();\n         ObjectOutputStream out = new ObjectOutputStream(bout);\n         out.writeObject(map);\n         assertEquals(TEN, ser.get(ONE));\n         assertEquals(TWENTY, ser.get(TWO));\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testSerialisation4() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(TEN, ONE);\n-        map.put(TWENTY, TWO);\n-        \n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n         ByteArrayOutputStream bout = new ByteArrayOutputStream();\n         ObjectOutputStream out = new ObjectOutputStream(bout);\n         out.writeObject(map);\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testEntryIteratorSetValue1() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(THREE, THIRTY);\n-        \n-        Iterator it = map.entrySet().iterator();\n-        Map.Entry entry = (Map.Entry) it.next();\n-        entry.setValue(\"NewValue\");\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n         assertEquals(THIRTY, map.get(THREE));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testEntryIteratorSetValue2() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(THREE, THIRTY);\n-        \n-        Iterator it = map.entrySet().iterator();\n-        it.next();\n-        Map.Entry entry = (Map.Entry) it.next();\n-        entry.setValue(\"NewValue\");\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n         assertEquals(THIRTY, map.get(THREE));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testEntryIteratorSetValue3() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(THREE, THIRTY);\n-        \n-        Iterator it = map.entrySet().iterator();\n-        it.next();\n-        it.next();\n-        Map.Entry entry = (Map.Entry) it.next();\n-        entry.setValue(\"NewValue\");\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        it.next();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testMapIteratorSetValue1() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(THREE, THIRTY);\n-        \n-        MapIterator it = map.mapIterator();\n-        it.next();\n-        it.setValue(\"NewValue\");\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n         assertEquals(THIRTY, map.get(THREE));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testMapIteratorSetValue2() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(THREE, THIRTY);\n-        \n-        MapIterator it = map.mapIterator();\n-        it.next();\n-        it.next();\n-        it.setValue(\"NewValue\");\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n         assertEquals(THIRTY, map.get(THREE));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testMapIteratorSetValue3() throws Exception {\n-        Flat3Map map = new Flat3Map();\n-        map.put(ONE, TEN);\n-        map.put(TWO, TWENTY);\n-        map.put(THREE, THIRTY);\n-        \n-        MapIterator it = map.mapIterator();\n-        it.next();\n-        it.next();\n-        it.next();\n-        it.setValue(\"NewValue\");\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n         assertEquals(true, map.containsKey(TWO));\n     public BulkTest bulkTestMapIterator() {\n         return new TestFlatMapIterator();\n     }\n-    \n-    public class TestFlatMapIterator extends AbstractTestMapIterator {\n+\n+    public class TestFlatMapIterator extends AbstractTestMapIterator<K, V> {\n         public TestFlatMapIterator() {\n             super(\"TestFlatMapIterator\");\n         }\n-        \n-        public Object[] addSetValues() {\n+\n+        public V[] addSetValues() {\n             return TestFlat3Map.this.getNewSampleValues();\n         }\n-        \n+\n         public boolean supportsRemove() {\n             return TestFlat3Map.this.isRemoveSupported();\n         }\n             return TestFlat3Map.this.isSetValueSupported();\n         }\n \n-        public MapIterator makeEmptyMapIterator() {\n+        public MapIterator<K, V> makeEmptyIterator() {\n             resetEmpty();\n-            return ((Flat3Map) TestFlat3Map.this.map).mapIterator();\n-        }\n-\n-        public MapIterator makeFullMapIterator() {\n+            return TestFlat3Map.this.getMap().mapIterator();\n+        }\n+\n+        public MapIterator<K, V> makeObject() {\n             resetFull();\n-            return ((Flat3Map) TestFlat3Map.this.map).mapIterator();\n-        }\n-        \n-        public Map getMap() {\n+            return TestFlat3Map.this.getMap().mapIterator();\n+        }\n+\n+        public IterableMap<K, V> getMap() {\n             // assumes makeFullMapIterator() called first\n-            return TestFlat3Map.this.map;\n-        }\n-        \n-        public Map getConfirmedMap() {\n+            return TestFlat3Map.this.getMap();\n+        }\n+\n+        public Map<K, V> getConfirmedMap() {\n             // assumes makeFullMapIterator() called first\n-            return TestFlat3Map.this.confirmed;\n-        }\n-        \n+            return TestFlat3Map.this.getConfirmed();\n+        }\n+\n         public void verify() {\n             super.verify();\n             TestFlat3Map.this.verify();\n         }\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }\n--- a/src/test/org/apache/commons/collections/map/TestHashedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestHashedMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import java.util.Map;\n-\n import junit.framework.Test;\n import junit.textui.TestRunner;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestHashedMap extends AbstractTestIterableMap {\n+public class TestHashedMap<K, V> extends AbstractTestIterableMap<K, V> {\n \n     public TestHashedMap(String testName) {\n         super(testName);\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestHashedMap.class);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new HashedMap();\n+    public HashedMap<K, V> makeObject() {\n+        return new HashedMap<K, V>();\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        HashedMap map = new HashedMap(10);\n-        map.put(\"1\", \"1\");\n-        Map cloned = (Map) map.clone();\n+        HashedMap<K, V> map = new HashedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        HashedMap<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n \n     public void testInternalState() {\n-        HashedMap map = new HashedMap(42, 0.75f);\n+        HashedMap<K, V> map = new HashedMap<K, V>(42, 0.75f);\n         assertEquals(0.75f, map.loadFactor, 0.1f);\n         assertEquals(0, map.size);\n         assertEquals(64, map.data.length);\n--- a/src/test/org/apache/commons/collections/map/TestIdentityMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestIdentityMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestIdentityMap extends AbstractTestObject {\n-    \n+public class TestIdentityMap<K, V> extends AbstractTestObject {\n+\n     private static final Integer I1A = new Integer(1);\n     private static final Integer I1B = new Integer(1);\n     private static final Integer I2A = new Integer(2);\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestIdentityMap.class);\n //        return BulkTest.makeSuite(TestIdentityMap.class);  // causes race condition!\n     }\n-    \n-    public Object makeObject() {\n-        return new IdentityMap();\n+\n+    public IdentityMap<K, V> makeObject() {\n+        return new IdentityMap<K, V>();\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testBasics() {\n-        IterableMap map = new IdentityMap();\n+        IterableMap<K, V> map = new IdentityMap<K, V>();\n         assertEquals(0, map.size());\n-        \n-        map.put(I1A, I2A);\n+\n+        map.put((K) I1A, (V) I2A);\n         assertEquals(1, map.size());\n         assertSame(I2A, map.get(I1A));\n         assertSame(null, map.get(I1B));\n         assertEquals(false, map.containsKey(I1B));\n         assertEquals(true, map.containsValue(I2A));\n         assertEquals(false, map.containsValue(I2B));\n-        \n-        map.put(I1A, I2B);\n+\n+        map.put((K) I1A, (V) I2B);\n         assertEquals(1, map.size());\n         assertSame(I2B, map.get(I1A));\n         assertSame(null, map.get(I1B));\n         assertEquals(false, map.containsKey(I1B));\n         assertEquals(false, map.containsValue(I2A));\n         assertEquals(true, map.containsValue(I2B));\n-        \n-        map.put(I1B, I2B);\n+\n+        map.put((K) I1B, (V) I2B);\n         assertEquals(2, map.size());\n         assertSame(I2B, map.get(I1A));\n         assertSame(I2B, map.get(I1B));\n         assertEquals(false, map.containsValue(I2A));\n         assertEquals(true, map.containsValue(I2B));\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testHashEntry() {\n-        IterableMap map = new IdentityMap();\n-        \n-        map.put(I1A, I2A);\n-        map.put(I1B, I2A);\n-        \n-        Map.Entry entry1 = (Map.Entry) map.entrySet().iterator().next();\n-        Iterator it = map.entrySet().iterator();\n-        Map.Entry entry2 = (Map.Entry) it.next();\n-        Map.Entry entry3 = (Map.Entry) it.next();\n-        \n+        IterableMap<K, V> map = new IdentityMap<K, V>();\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry2 = it.next();\n+        Map.Entry<K, V> entry3 = it.next();\n+\n         assertEquals(true, entry1.equals(entry2));\n         assertEquals(true, entry2.equals(entry1));\n         assertEquals(false, entry1.equals(entry3));\n     }\n-    \n+\n     /**\n      * Compare the current serialized form of the Map\n      * against the canonical version in SVN.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testEmptyMapCompatibility() throws IOException, ClassNotFoundException {\n         // test to make sure the canonical form has been preserved\n-        Map map = (Map) makeObject();\n+        Map<K, V> map = makeObject();\n         if (map instanceof Serializable && !skipSerializedCanonicalTests()) {\n             Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n             assertEquals(\"Map is empty\", 0, map2.size());\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        IdentityMap map = new IdentityMap(10);\n-        map.put(\"1\", \"1\");\n-        Map cloned = (Map) map.clone();\n+        IdentityMap<K, V> map = new IdentityMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        Map map = new IdentityMap();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.emptyCollection.version3.obj\");\n--- a/src/test/org/apache/commons/collections/map/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLRUMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestLRUMap extends AbstractTestOrderedMap {\n+public class TestLRUMap<K, V> extends AbstractTestOrderedMap<K, V> {\n \n     public TestLRUMap(String testName) {\n         super(testName);\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestLRUMap.class);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new LRUMap();\n+    public LRUMap<K, V> makeObject() {\n+        return new LRUMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> makeFullMap() {\n+        return (LRUMap<K, V>) super.makeFullMap();\n     }\n \n     public boolean isGetStructuralModify() {\n         return true;\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n     //-----------------------------------------------------------------------\n     public void testLRU() {\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        Iterator it = null;\n-        \n-        LRUMap map = new LRUMap(2);\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> kit;\n+        Iterator<V> vit;\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(2);\n         assertEquals(0, map.size());\n         assertEquals(false, map.isFull());\n         assertEquals(2, map.maxSize());\n-        \n+\n         map.put(keys[0], values[0]);\n         assertEquals(1, map.size());\n         assertEquals(false, map.isFull());\n         assertEquals(2, map.maxSize());\n-        \n+\n         map.put(keys[1], values[1]);\n         assertEquals(2, map.size());\n         assertEquals(true, map.isFull());\n         assertEquals(2, map.maxSize());\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[1], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n \n         map.put(keys[2], values[2]);\n         assertEquals(2, map.size());\n         assertEquals(true, map.isFull());\n         assertEquals(2, map.maxSize());\n-        it = map.keySet().iterator();\n-        assertSame(keys[1], it.next());\n-        assertSame(keys[2], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[1], it.next());\n-        assertSame(values[2], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[2], vit.next());\n \n         map.put(keys[2], values[0]);\n         assertEquals(2, map.size());\n         assertEquals(true, map.isFull());\n         assertEquals(2, map.maxSize());\n-        it = map.keySet().iterator();\n-        assertSame(keys[1], it.next());\n-        assertSame(keys[2], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[1], it.next());\n-        assertSame(values[0], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[0], vit.next());\n \n         map.put(keys[1], values[3]);\n         assertEquals(2, map.size());\n         assertEquals(true, map.isFull());\n         assertEquals(2, map.maxSize());\n-        it = map.keySet().iterator();\n-        assertSame(keys[2], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[3], it.next());\n-    }\n-    \n-    //-----------------------------------------------------------------------    \n+        kit = map.keySet().iterator();\n+        assertSame(keys[2], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testReset() {\n         resetEmpty();\n-        OrderedMap ordered = (OrderedMap) map;\n-        ((ResettableIterator) ordered.mapIterator()).reset();\n-        \n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n         resetFull();\n-        ordered = (OrderedMap) map;\n-        List list = new ArrayList(ordered.keySet());\n-        ResettableIterator it = (ResettableIterator) ordered.mapIterator();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(ordered.keySet());\n+        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n         assertSame(list.get(0), it.next());\n         assertSame(list.get(1), it.next());\n         it.reset();\n         assertSame(list.get(0), it.next());\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testAccessOrder() {\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        Iterator it = null;\n-        \n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> kit = null;\n+        Iterator<V> vit = null;\n+\n         resetEmpty();\n         map.put(keys[0], values[0]);\n         map.put(keys[1], values[1]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[1], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n \n         // no change to order\n         map.put(keys[1], values[1]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[1], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n \n         // no change to order\n         map.put(keys[1], values[2]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[2], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[2], vit.next());\n \n         // change to order\n         map.put(keys[0], values[3]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[1], it.next());\n-        assertSame(keys[0], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[2], it.next());\n-        assertSame(values[3], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n \n         // change to order\n         map.get(keys[1]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[3], it.next());\n-        assertSame(values[2], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[3], vit.next());\n+        assertSame(values[2], vit.next());\n \n         // change to order\n         map.get(keys[0]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[1], it.next());\n-        assertSame(keys[0], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[2], it.next());\n-        assertSame(values[3], it.next());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n \n         // no change to order\n         map.get(keys[0]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[1], it.next());\n-        assertSame(keys[0], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[2], it.next());\n-        assertSame(values[3], it.next());\n-    }\n-    \n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        LRUMap map = new LRUMap(10);\n-        map.put(\"1\", \"1\");\n-        Map cloned = (Map) map.clone();\n+        LRUMap<K, V> map = new LRUMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRU() {\n         MockLRUMapSubclass map = new MockLRUMapSubclass(2);\n         assertNull(map.entry);\n-        map.put(\"A\", \"a\");\n+        map.put((K) \"A\", \"a\");\n         assertNull(map.entry);\n-        map.put(\"B\", \"b\");\n+        map.put((K) \"B\", \"b\");\n         assertNull(map.entry);\n-        map.put(\"C\", \"c\");  // removes oldest, which is A=a\n+        map.put((K) \"C\", \"c\");  // removes oldest, which is A=a\n         assertNotNull(map.entry);\n         assertEquals(\"A\", map.key);\n         assertEquals(\"a\", map.value);\n         assertEquals(true, map.containsKey(\"B\"));\n         assertEquals(true, map.containsKey(\"C\"));\n     }\n-    \n-    static class MockLRUMapSubclass extends LRUMap {\n-        LinkEntry entry;\n-        Object key;\n-        Object value;\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {\n+        LinkEntry<K, V> entry;\n+        K key;\n+        V value;\n \n         MockLRUMapSubclass(int size) {\n             super(size);\n         }\n \n-        protected boolean removeLRU(LinkEntry entry) {\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n             this.entry = entry;\n             this.key = entry.getKey();\n             this.value = entry.getValue();\n             return true;\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRUBlocksRemove() {\n-        MockLRUMapSubclassBlocksRemove map = new MockLRUMapSubclassBlocksRemove(2, false);\n+        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, false);\n         assertEquals(0, map.size());\n-        map.put(\"A\", \"a\");\n+        map.put((K) \"A\", (V) \"a\");\n         assertEquals(1, map.size());\n-        map.put(\"B\", \"b\");\n+        map.put((K) \"B\", (V) \"b\");\n         assertEquals(2, map.size());\n-        map.put(\"C\", \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n         assertEquals(3, map.size());\n         assertEquals(2, map.maxSize());\n         assertEquals(true, map.containsKey(\"A\"));\n         assertEquals(true, map.containsKey(\"C\"));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRUBlocksRemoveScan() {\n-        MockLRUMapSubclassBlocksRemove map = new MockLRUMapSubclassBlocksRemove(2, true);\n+        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, true);\n         assertEquals(0, map.size());\n-        map.put(\"A\", \"a\");\n+        map.put((K) \"A\", (V) \"a\");\n         assertEquals(1, map.size());\n-        map.put(\"B\", \"b\");\n+        map.put((K) \"B\", (V) \"b\");\n         assertEquals(2, map.size());\n-        map.put(\"C\", \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n         assertEquals(3, map.size());\n         assertEquals(2, map.maxSize());\n         assertEquals(true, map.containsKey(\"A\"));\n         assertEquals(true, map.containsKey(\"B\"));\n         assertEquals(true, map.containsKey(\"C\"));\n     }\n-    \n-    static class MockLRUMapSubclassBlocksRemove extends LRUMap {\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n         MockLRUMapSubclassBlocksRemove(int size, boolean scanUntilRemove) {\n             super(size, scanUntilRemove);\n         }\n \n-        protected boolean removeLRU(LinkEntry entry) {\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n             return false;\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRUFirstBlocksRemove() {\n-        MockLRUMapSubclassFirstBlocksRemove map = new MockLRUMapSubclassFirstBlocksRemove(2);\n+        MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<K, V>(2);\n         assertEquals(0, map.size());\n-        map.put(\"A\", \"a\");\n+        map.put((K) \"A\", (V) \"a\");\n         assertEquals(1, map.size());\n-        map.put(\"B\", \"b\");\n+        map.put((K) \"B\", (V) \"b\");\n         assertEquals(2, map.size());\n-        map.put(\"C\", \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n         assertEquals(2, map.size());\n         assertEquals(2, map.maxSize());\n         assertEquals(true, map.containsKey(\"A\"));\n         assertEquals(true, map.containsKey(\"C\"));\n     }\n \n-    static class MockLRUMapSubclassFirstBlocksRemove extends LRUMap {\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n         MockLRUMapSubclassFirstBlocksRemove(int size) {\n             super(size, true);\n         }\n \n-        protected boolean removeLRU(LinkEntry entry) {\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n             if (\"a\".equals(entry.getValue())) {\n                 return false;\n             } else {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalState_Buckets() {\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n         SingleHashCode one = new SingleHashCode(\"1\");\n         SingleHashCode five = new SingleHashCode(\"5\");\n         SingleHashCode six = new SingleHashCode(\"6\");\n \n-        LRUMap map = new LRUMap(3, 1.0f);\n+        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n         int hashIndex = map.hashIndex(map.hash(one), 4);\n-        map.put(one, \"A\");\n-        map.put(two, \"B\");\n-        map.put(three, \"C\");\n-        \n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n         assertEquals(4, map.data.length);\n         assertEquals(3, map.size);\n         assertEquals(null, map.header.next);\n         assertEquals(three, map.data[hashIndex].key);\n         assertEquals(two, map.data[hashIndex].next.key);\n         assertEquals(one, map.data[hashIndex].next.next.key);\n-        \n-        map.put(four, \"D\");  // reuses last in next list\n-        \n+\n+        map.put((K) four, (V) \"D\");  // reuses last in next list\n+\n         assertEquals(4, map.data.length);\n         assertEquals(3, map.size);\n         assertEquals(null, map.header.next);\n         assertEquals(four, map.data[hashIndex].key);\n         assertEquals(three, map.data[hashIndex].next.key);\n         assertEquals(two, map.data[hashIndex].next.next.key);\n-        \n+\n         map.get(three);\n-        \n+\n         assertEquals(4, map.data.length);\n         assertEquals(3, map.size);\n         assertEquals(null, map.header.next);\n         assertEquals(four, map.data[hashIndex].key);\n         assertEquals(three, map.data[hashIndex].next.key);\n         assertEquals(two, map.data[hashIndex].next.next.key);\n-        \n-        map.put(five, \"E\");  // reuses last in next list\n-        \n+\n+        map.put((K) five, (V) \"E\");  // reuses last in next list\n+\n         assertEquals(4, map.data.length);\n         assertEquals(3, map.size);\n         assertEquals(null, map.header.next);\n         assertEquals(five, map.data[hashIndex].key);\n         assertEquals(four, map.data[hashIndex].next.key);\n         assertEquals(three, map.data[hashIndex].next.next.key);\n-        \n+\n         map.get(three);\n         map.get(five);\n-        \n+\n         assertEquals(4, map.data.length);\n         assertEquals(3, map.size);\n         assertEquals(null, map.header.next);\n         assertEquals(five, map.data[hashIndex].key);\n         assertEquals(four, map.data[hashIndex].next.key);\n         assertEquals(three, map.data[hashIndex].next.next.key);\n-        \n-        map.put(six, \"F\");  // reuses middle in next list\n-        \n+\n+        map.put((K) six, (V) \"F\");  // reuses middle in next list\n+\n         assertEquals(4, map.data.length);\n         assertEquals(3, map.size);\n         assertEquals(null, map.header.next);\n         assertEquals(three, map.data[hashIndex].next.next.key);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testInternalState_getEntry_int() {\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n         SingleHashCode one = new SingleHashCode(\"1\");\n         SingleHashCode two = new SingleHashCode(\"2\");\n         SingleHashCode three = new SingleHashCode(\"3\");\n-        SingleHashCode four = new SingleHashCode(\"4\");\n-        SingleHashCode five = new SingleHashCode(\"5\");\n-        SingleHashCode six = new SingleHashCode(\"6\");\n-\n-        LRUMap map = new LRUMap(3, 1.0f);\n-        int hashIndex = map.hashIndex(map.hash(one), 4);\n-        map.put(one, \"A\");\n-        map.put(two, \"B\");\n-        map.put(three, \"C\");\n-        \n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n         assertEquals(one, map.getEntry(0).key);\n         assertEquals(two, map.getEntry(1).key);\n         assertEquals(three, map.getEntry(2).key);\n //        resetFull();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.fullCollection.version3.obj\");\n //    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> getMap() {\n+        return (LRUMap<K, V>) super.getMap();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestLinkedMap extends AbstractTestOrderedMap {\n+public class TestLinkedMap<K, V> extends AbstractTestOrderedMap<K, V> {\n \n     public TestLinkedMap(String testName) {\n         super(testName);\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestLinkedMap.class);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new LinkedMap();\n+    public LinkedMap<K, V> makeObject() {\n+        return new LinkedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> makeFullMap() {\n+        return (LinkedMap<K, V>) super.makeFullMap();\n     }\n \n     public String getCompatibilityVersion() {\n         return \"3\";\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testReset() {\n         resetEmpty();\n-        OrderedMap ordered = (OrderedMap) map;\n-        ((ResettableIterator) ordered.mapIterator()).reset();\n-        \n-        resetFull();\n-        ordered = (OrderedMap) map;\n-        List list = new ArrayList(ordered.keySet());\n-        ResettableIterator it = (ResettableIterator) ordered.mapIterator();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(ordered.keySet());\n+        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n         assertSame(list.get(0), it.next());\n         assertSame(list.get(1), it.next());\n         it.reset();\n         assertSame(list.get(0), it.next());\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testInsertionOrder() {\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        Iterator it = null;\n-        \n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> keyIter;\n+        Iterator<V> valueIter;\n+\n         resetEmpty();\n         map.put(keys[0], values[0]);\n         map.put(keys[1], values[1]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[1], it.next());\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n \n         // no change to order\n         map.put(keys[1], values[1]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[1], it.next());\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n \n         // no change to order\n         map.put(keys[1], values[2]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[0], it.next());\n-        assertSame(values[2], it.next());\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n \n         // no change to order\n         map.put(keys[0], values[3]);\n-        it = map.keySet().iterator();\n-        assertSame(keys[0], it.next());\n-        assertSame(keys[1], it.next());\n-        it = map.values().iterator();\n-        assertSame(values[3], it.next());\n-        assertSame(values[2], it.next());\n-    }\n-    \n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[3], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testGetByIndex() {\n         resetEmpty();\n-        LinkedMap lm = (LinkedMap) map;\n+        LinkedMap<K, V> lm = getMap();\n         try {\n             lm.get(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lm.get(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lm = (LinkedMap) map;\n+\n+        resetFull();\n+        lm = getMap();\n         try {\n             lm.get(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lm.get(lm.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         int i = 0;\n-        for (MapIterator it = lm.mapIterator(); it.hasNext(); i++) {\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n             assertSame(it.next(), lm.get(i));\n         }\n     }\n \n     public void testGetValueByIndex() {\n         resetEmpty();\n-        LinkedMap lm = (LinkedMap) map;\n+        LinkedMap<K, V> lm = getMap();\n         try {\n             lm.getValue(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lm.getValue(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lm = (LinkedMap) map;\n+\n+        resetFull();\n+        lm = getMap();\n         try {\n             lm.getValue(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lm.getValue(lm.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         int i = 0;\n-        for (MapIterator it = lm.mapIterator(); it.hasNext(); i++) {\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n             it.next();\n             assertSame(it.getValue(), lm.getValue(i));\n         }\n \n     public void testIndexOf() {\n         resetEmpty();\n-        LinkedMap lm = (LinkedMap) map;\n+        LinkedMap<K, V> lm = getMap();\n         assertEquals(-1, lm.indexOf(getOtherKeys()));\n-        \n-        resetFull();\n-        lm = (LinkedMap) map;\n-        List list = new ArrayList();\n-        for (MapIterator it = lm.mapIterator(); it.hasNext();) {\n+\n+        resetFull();\n+        lm = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n \n     public void testRemoveByIndex() {\n         resetEmpty();\n-        LinkedMap lm = (LinkedMap) map;\n+        LinkedMap<K, V> lm = getMap();\n         try {\n             lm.remove(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lm.remove(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lm = (LinkedMap) map;\n+\n+        resetFull();\n+        lm = getMap();\n         try {\n             lm.remove(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lm.remove(lm.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        List list = new ArrayList();\n-        for (MapIterator it = lm.mapIterator(); it.hasNext();) {\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n             assertEquals(false, lm.containsKey(key));\n         }\n     }\n-    \n+\n     public BulkTest bulkTestListView() {\n         return new TestListView();\n     }\n-    \n-    public class TestListView extends AbstractTestList {\n-        \n+\n+    public class TestListView extends AbstractTestList<K> {\n+\n         TestListView() {\n             super(\"TestListView\");\n         }\n \n-        public List makeEmptyList() {\n-            return ((LinkedMap) TestLinkedMap.this.makeEmptyMap()).asList();\n-        }\n-        \n-        public List makeFullList() {\n-            return ((LinkedMap) TestLinkedMap.this.makeFullMap()).asList();\n-        }\n-        \n-        public Object[] getFullElements() {\n+        public List<K> makeObject() {\n+            return TestLinkedMap.this.makeObject().asList();\n+        }\n+\n+        public List<K> makeFullCollection() {\n+            return TestLinkedMap.this.makeFullMap().asList();\n+        }\n+\n+        public K[] getFullElements() {\n             return TestLinkedMap.this.getSampleKeys();\n         }\n         public boolean isAddSupported() {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        LinkedMap map = new LinkedMap(10);\n-        map.put(\"1\", \"1\");\n-        Map cloned = (Map) map.clone();\n+        LinkedMap<K, V> map = new LinkedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n //        resetFull();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.fullCollection.version3.obj\");\n //    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> getMap() {\n+        return (LinkedMap<K, V>) super.getMap();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n  * @author Stephen Colebourne\n  * @author Matt Benson\n  */\n-public class TestListOrderedMap extends AbstractTestOrderedMap {\n+public class TestListOrderedMap<K, V> extends AbstractTestOrderedMap<K, V> {\n \n     public TestListOrderedMap(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n-        return ListOrderedMap.decorate(new HashMap());\n-    }\n-    \n+    public ListOrderedMap<K, V> makeObject() {\n+        return (ListOrderedMap<K, V>) ListOrderedMap.decorate(new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testGetByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.get(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n+\n+        resetFull();\n+        lom = getMap();\n         try {\n             lom.get(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(lom.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         int i = 0;\n-        for (MapIterator it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             assertSame(it.next(), lom.get(i));\n         }\n     }\n \n     public void testGetValueByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.getValue(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n+\n+        resetFull();\n+        lom = getMap();\n         try {\n             lom.getValue(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(lom.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         int i = 0;\n-        for (MapIterator it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             it.next();\n             assertSame(it.getValue(), lom.getValue(i));\n         }\n \n     public void testIndexOf() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         assertEquals(-1, lom.indexOf(getOtherKeys()));\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n-        List list = new ArrayList();\n-        for (MapIterator it = lom.mapIterator(); it.hasNext();) {\n+\n+        resetFull();\n+        lom = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testSetValueByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n-        try {\n-            lom.setValue(0, \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n-        try {\n-            lom.setValue(-1, \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n-        try {\n-            lom.setValue(-1, \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n-        try {\n-            lom.setValue(lom.size(), \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n-        \n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.setValue(0, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(lom.size(), (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n         for (int i = 0; i < lom.size(); i++) {\n-            Object value = lom.getValue(i);\n+            V value = lom.getValue(i);\n             Object input = new Integer(i);\n-            assertEquals(value, lom.setValue(i, input));\n+            assertEquals(value, lom.setValue(i, (V) input));\n             assertEquals(input, lom.getValue(i));\n         }\n     }\n \n     public void testRemoveByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.remove(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n+\n+        resetFull();\n+        lom = getMap();\n         try {\n             lom.remove(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(lom.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        List list = new ArrayList();\n-        for (MapIterator it = lom.mapIterator(); it.hasNext();) {\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testPut_intObjectObject() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n-        \n-        try {\n-            lom.put(1, \"testInsert1\", \"testInsert1v\");\n+        ListOrderedMap<K, V> lom = getMap();\n+\n+        try {\n+            lom.put(1, (K) \"testInsert1\", (V) \"testInsert1v\");\n             fail(\"should not be able to insert at pos 1 in empty Map\");\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n-            lom.put(-1, \"testInsert-1\", \"testInsert-1v\");\n+            lom.put(-1, (K) \"testInsert-1\", (V) \"testInsert-1v\");\n             fail(\"should not be able to insert at pos -1 in empty Map\");\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         // put where key doesn't exist\n-        lom.put(0, \"testInsert1\", \"testInsert1v\");\n+        lom.put(0, (K) \"testInsert1\", (V) \"testInsert1v\");\n         assertEquals(\"testInsert1v\", lom.getValue(0));\n-        \n-        lom.put(\"testInsertPut\", \"testInsertPutv\");\n+\n+        lom.put((K) \"testInsertPut\", (V) \"testInsertPutv\");\n         assertEquals(\"testInsert1v\", lom.getValue(0));\n         assertEquals(\"testInsertPutv\", lom.getValue(1));\n-        \n-        lom.put(0, \"testInsert0\", \"testInsert0v\");\n+\n+        lom.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n         assertEquals(\"testInsert0v\", lom.getValue(0));\n         assertEquals(\"testInsert1v\", lom.getValue(1));\n         assertEquals(\"testInsertPutv\", lom.getValue(2));\n-        \n-        lom.put(3, \"testInsert3\", \"testInsert3v\");\n+\n+        lom.put(3, (K) \"testInsert3\", (V) \"testInsert3v\");\n         assertEquals(\"testInsert0v\", lom.getValue(0));\n         assertEquals(\"testInsert1v\", lom.getValue(1));\n         assertEquals(\"testInsertPutv\", lom.getValue(2));\n         assertEquals(\"testInsert3v\", lom.getValue(3));\n-        \n-        // put in a full map        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n-        ListOrderedMap lom2 = new ListOrderedMap();\n+\n+        // put in a full map\n+        resetFull();\n+        lom = getMap();\n+        ListOrderedMap<K, V> lom2 = new ListOrderedMap<K, V>();\n         lom2.putAll(lom);\n-        \n-        lom2.put(0, \"testInsert0\", \"testInsert0v\");\n+\n+        lom2.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n         assertEquals(\"testInsert0v\", lom2.getValue(0));\n         for (int i = 0; i < lom.size(); i++) {\n             assertEquals(lom2.getValue(i + 1), lom.getValue(i));\n         }\n-        \n+\n         // put where key does exist\n         Integer i1 = new Integer(1);\n         Integer i1b = new Integer(1);\n         Integer i2 = new Integer(2);\n         Integer i3 = new Integer(3);\n-        \n-        resetEmpty();\n-        lom = (ListOrderedMap) map;\n-        lom.put(i1, \"1\");\n-        lom.put(i2, \"2\");\n-        lom.put(i3, \"3\");\n-        lom.put(0, i1, \"One\");\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1, (V) \"One\");\n         assertEquals(3, lom.size());\n         assertEquals(3, lom.map.size());\n         assertEquals(3, lom.insertOrder.size());\n         assertEquals(\"One\", lom.getValue(0));\n         assertSame(i1, lom.get(0));\n-        \n-        resetEmpty();\n-        lom = (ListOrderedMap) map;\n-        lom.put(i1, \"1\");\n-        lom.put(i2, \"2\");\n-        lom.put(i3, \"3\");\n-        lom.put(0, i1b, \"One\");\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1b, (V) \"One\");\n         assertEquals(3, lom.size());\n         assertEquals(3, lom.map.size());\n         assertEquals(3, lom.insertOrder.size());\n         assertEquals(\"2\", lom.getValue(1));\n         assertEquals(\"3\", lom.getValue(2));\n         assertSame(i1b, lom.get(0));\n-        \n-        resetEmpty();\n-        lom = (ListOrderedMap) map;\n-        lom.put(i1, \"1\");\n-        lom.put(i2, \"2\");\n-        lom.put(i3, \"3\");\n-        lom.put(1, i1b, \"One\");\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(1, (K) i1b, (V) \"One\");\n         assertEquals(3, lom.size());\n         assertEquals(3, lom.map.size());\n         assertEquals(3, lom.insertOrder.size());\n         assertEquals(\"One\", lom.getValue(0));\n         assertEquals(\"2\", lom.getValue(1));\n         assertEquals(\"3\", lom.getValue(2));\n-        \n-        resetEmpty();\n-        lom = (ListOrderedMap) map;\n-        lom.put(i1, \"1\");\n-        lom.put(i2, \"2\");\n-        lom.put(i3, \"3\");\n-        lom.put(2, i1b, \"One\");\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(2, (K) i1b, (V) \"One\");\n         assertEquals(3, lom.size());\n         assertEquals(3, lom.map.size());\n         assertEquals(3, lom.insertOrder.size());\n         assertEquals(\"2\", lom.getValue(0));\n         assertEquals(\"One\", lom.getValue(1));\n         assertEquals(\"3\", lom.getValue(2));\n-        \n-        resetEmpty();\n-        lom = (ListOrderedMap) map;\n-        lom.put(i1, \"1\");\n-        lom.put(i2, \"2\");\n-        lom.put(i3, \"3\");\n-        lom.put(3, i1b, \"One\");\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(3, (K) i1b, (V) \"One\");\n         assertEquals(3, lom.size());\n         assertEquals(3, lom.map.size());\n         assertEquals(3, lom.insertOrder.size());\n     //-----------------------------------------------------------------------\n     public void testValueList_getByIndex() {\n         resetFull();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         for (int i = 0; i < lom.size(); i++) {\n-            Object expected = lom.getValue(i);\n+            V expected = lom.getValue(i);\n             assertEquals(expected, lom.valueList().get(i));\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testValueList_setByIndex() {\n         resetFull();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         for (int i = 0; i < lom.size(); i++) {\n             Object input = new Integer(i);\n-            Object expected = lom.getValue(i);\n-            assertEquals(expected, lom.valueList().set(i, input));\n+            V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().set(i, (V) input));\n             assertEquals(input, lom.getValue(i));\n             assertEquals(input, lom.valueList().get(i));\n         }\n \n     public void testValueList_removeByIndex() {\n         resetFull();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         while (lom.size() > 1) {\n-            Object expected = lom.getValue(1);\n+            V expected = lom.getValue(1);\n             assertEquals(expected, lom.valueList().remove(1));\n         }\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    public class TestKeyListView extends AbstractTestList {\n+    public class TestKeyListView extends AbstractTestList<K> {\n         TestKeyListView() {\n             super(\"TestKeyListView\");\n         }\n \n-        public List makeEmptyList() {\n-            return ((ListOrderedMap) TestListOrderedMap.this.makeEmptyMap()).keyList();\n-        }\n-        public List makeFullList() {\n-            return ((ListOrderedMap) TestListOrderedMap.this.makeFullMap()).keyList();\n-        }\n-\n-        public Object[] getFullElements() {\n+        public List<K> makeObject() {\n+            return TestListOrderedMap.this.makeObject().keyList();\n+        }\n+        public List<K> makeFullCollection() {\n+            return TestListOrderedMap.this.makeFullMap().keyList();\n+        }\n+\n+        public K[] getFullElements() {\n             return TestListOrderedMap.this.getSampleKeys();\n         }\n         public boolean isAddSupported() {\n     }\n \n     //-----------------------------------------------------------------------\n-    public class TestValueListView extends AbstractTestList {\n+    public class TestValueListView extends AbstractTestList<V> {\n         TestValueListView() {\n             super(\"TestValueListView\");\n         }\n \n-        public List makeEmptyList() {\n-            return ((ListOrderedMap) TestListOrderedMap.this.makeEmptyMap()).valueList();\n-        }\n-        public List makeFullList() {\n-            return ((ListOrderedMap) TestListOrderedMap.this.makeFullMap()).valueList();\n-        }\n-\n-        public Object[] getFullElements() {\n+        public List<V> makeObject() {\n+            return TestListOrderedMap.this.makeObject().valueList();\n+        }\n+        public List<V> makeFullCollection() {\n+            return TestListOrderedMap.this.makeFullMap().valueList();\n+        }\n+\n+        public V[] getFullElements() {\n             return TestListOrderedMap.this.getSampleValues();\n         }\n         public boolean isAddSupported() {\n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n //    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestListOrderedMap2.java\n+++ b/src/test/org/apache/commons/collections/map/TestListOrderedMap2.java\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n \n import junit.framework.Test;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestListOrderedMap2 extends AbstractTestOrderedMap {\n+public class TestListOrderedMap2<K, V> extends AbstractTestOrderedMap<K, V> {\n \n     public TestListOrderedMap2(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new ListOrderedMap();\n-    }\n-    \n+    public ListOrderedMap<K, V> makeObject() {\n+        return new ListOrderedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testGetByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.get(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n+\n+        resetFull();\n+        lom = getMap();\n         try {\n             lom.get(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(lom.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         int i = 0;\n-        for (MapIterator it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             assertSame(it.next(), lom.get(i));\n         }\n     }\n \n     public void testGetValueByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.getValue(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n+\n+        resetFull();\n+        lom = getMap();\n         try {\n             lom.getValue(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(lom.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n+\n         int i = 0;\n-        for (MapIterator it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             it.next();\n             assertSame(it.getValue(), lom.getValue(i));\n         }\n \n     public void testIndexOf() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         assertEquals(-1, lom.indexOf(getOtherKeys()));\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n-        List list = new ArrayList();\n-        for (MapIterator it = lom.mapIterator(); it.hasNext();) {\n+\n+        resetFull();\n+        lom = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n \n     public void testRemoveByIndex() {\n         resetEmpty();\n-        ListOrderedMap lom = (ListOrderedMap) map;\n+        ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.remove(0);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        resetFull();\n-        lom = (ListOrderedMap) map;\n+\n+        resetFull();\n+        lom = getMap();\n         try {\n             lom.remove(-1);\n         } catch (IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(lom.size());\n         } catch (IndexOutOfBoundsException ex) {}\n-        \n-        List list = new ArrayList();\n-        for (MapIterator it = lom.mapIterator(); it.hasNext();) {\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n             assertEquals(false, lom.containsKey(key));\n         }\n     }\n-    \n+\n     public BulkTest bulkTestListView() {\n         return new TestListView();\n     }\n-    \n-    public class TestListView extends AbstractTestList {\n-        \n+\n+    public class TestListView extends AbstractTestList<K> {\n+\n         TestListView() {\n             super(\"TestListView\");\n         }\n \n-        public List makeEmptyList() {\n-            return ((ListOrderedMap) TestListOrderedMap2.this.makeEmptyMap()).asList();\n-        }\n-        \n-        public List makeFullList() {\n-            return ((ListOrderedMap) TestListOrderedMap2.this.makeFullMap()).asList();\n-        }\n-        \n-        public Object[] getFullElements() {\n+        public List<K> makeObject() {\n+            return TestListOrderedMap2.this.makeObject().asList();\n+        }\n+\n+        public List<K> makeFullCollection() {\n+            return TestListOrderedMap2.this.makeFullMap().asList();\n+        }\n+\n+        public K[] getFullElements() {\n             return TestListOrderedMap2.this.getSampleKeys();\n         }\n         public boolean isAddSupported() {\n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n //    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        // TODO Auto-generated method stub\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestMultiKeyMap extends AbstractTestIterableMap {\n-    \n+public class TestMultiKeyMap<K, V> extends AbstractTestIterableMap<MultiKey<? extends K>, V> {\n+\n     static final Integer I1 = new Integer(1);\n     static final Integer I2 = new Integer(2);\n     static final Integer I3 = new Integer(3);\n         return BulkTest.makeSuite(TestMultiKeyMap.class);\n     }\n \n-    public Map makeEmptyMap() {\n-        return new MultiKeyMap();\n-    }\n-\n-    public Object[] getSampleKeys() {\n+    public MultiKeyMap<K, V> makeObject() {\n+        return new MultiKeyMap<K, V>();\n+    }\n+\n+    public MultiKey<K>[] getSampleKeys() {\n         return getMultiKeyKeys();\n     }\n \n-    private MultiKey[] getMultiKeyKeys() {\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiKey<K>[] getMultiKeyKeys() {\n         return new MultiKey[] {\n             new MultiKey(I1, I2),\n             new MultiKey(I2, I3),\n         };\n     }\n \n-    public Object[] getSampleValues() {\n-        return new Object[] {\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] {\n             \"2A\", \"2B\", \"2C\",\n             \"3D\", \"3E\", \"3F\",\n             \"4G\", \"4H\", \"4I\",\n         };\n     }\n \n-    public Object[] getNewSampleValues() {\n-        return new Object[] {\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] {\n             \"1a\", \"1b\", \"1c\",\n             \"2d\", \"2e\", \"2f\",\n             \"3g\", \"3h\", \"3i\",\n         };\n     }\n \n-    public Object[] getOtherKeys() {\n-        return new Object[] {\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey<K>[] getOtherKeys() {\n+        return (MultiKey<K>[]) new MultiKey[] {\n             new MultiKey(I1, I7),\n             new MultiKey(I1, I8),\n             new MultiKey(I2, I4),\n             new MultiKey(I2, I5),\n         };\n     }\n-    \n+\n     public boolean isAllowNullKey() {\n         return false;\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testNullHandling() {\n         resetFull();\n         assertEquals(null, map.get(null));\n             map.put(null, null);\n             fail();\n         } catch (NullPointerException ex) {}\n-        assertEquals(null, map.put(new MultiKey(null, null), null));\n+        assertEquals(null, map.put(new MultiKey<K>(null, null), null));\n         try {\n-            map.put(null, new Object());\n+            map.put(null, (V) new Object());\n             fail();\n         } catch (NullPointerException ex) {}\n     }\n     //-----------------------------------------------------------------------\n     public void testMultiKeyGet() {\n         resetFull();\n-        MultiKeyMap multimap = (MultiKeyMap) map;\n-        MultiKey[] keys = getMultiKeyKeys();\n-        Object[] values = getSampleValues();\n-        \n+        MultiKeyMap<K, V> multimap = getMap();\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n         for (int i = 0; i < keys.length; i++) {\n-            MultiKey key = keys[i];\n-            Object value = values[i];\n-            \n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n             switch (key.size()) {\n                 case 2:\n                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n             }\n         }\n     }\n-    \n+\n     public void testMultiKeyContainsKey() {\n         resetFull();\n-        MultiKeyMap multimap = (MultiKeyMap) map;\n-        MultiKey[] keys = getMultiKeyKeys();\n-        Object[] values = getSampleValues();\n-        \n+        MultiKeyMap<K, V> multimap = getMap();\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+\n         for (int i = 0; i < keys.length; i++) {\n-            MultiKey key = keys[i];\n-            Object value = values[i];\n-            \n+            MultiKey<K> key = keys[i];\n+\n             switch (key.size()) {\n                 case 2:\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n             }\n         }\n     }\n-    \n+\n     public void testMultiKeyPut() {\n-        MultiKey[] keys = getMultiKeyKeys();\n-        Object[] values = getSampleValues();\n-        \n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n         for (int i = 0; i < keys.length; i++) {\n-            MultiKeyMap multimap = new MultiKeyMap();\n-            \n-            MultiKey key = keys[i];\n-            Object value = values[i];\n-            \n+            MultiKeyMap<K, V> multimap = new MultiKeyMap<K, V>();\n+\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n             switch (key.size()) {\n                 case 2:\n                 assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));\n                 assertEquals(1, multimap.size());\n                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n-                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1))));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1))));\n                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));\n                 assertEquals(1, multimap.size());\n                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));\n                 assertEquals(1, multimap.size());\n                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n-                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1), key.getKey(2))));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2))));\n                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));\n                 assertEquals(1, multimap.size());\n                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n                 assertEquals(1, multimap.size());\n                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n-                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n                 assertEquals(1, multimap.size());\n                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                 assertEquals(1, multimap.size());\n                 assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n-                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n                 assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));\n                 assertEquals(1, multimap.size());\n                 assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n             }\n         }\n     }\n-    \n+\n     public void testMultiKeyRemove() {\n-        MultiKey[] keys = getMultiKeyKeys();\n-        Object[] values = getSampleValues();\n-        \n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n         for (int i = 0; i < keys.length; i++) {\n             resetFull();\n-            MultiKeyMap multimap = (MultiKeyMap) map;\n+            MultiKeyMap<K, V> multimap = getMap();\n             int size = multimap.size();\n-            \n-            MultiKey key = keys[i];\n-            Object value = values[i];\n-            \n+\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n             switch (key.size()) {\n                 case 2:\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n             }\n         }\n     }\n-    \n+\n     public void testMultiKeyRemoveAll1() {\n         resetFull();\n-        MultiKeyMap multimap = (MultiKeyMap) map;\n+        MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n-        \n+\n         multimap.removeAll(I1);\n         assertEquals(8, multimap.size());\n-        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey key = (MultiKey) it.next();\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n             assertEquals(false, I1.equals(key.getKey(0)));\n         }\n     }\n-    \n+\n     public void testMultiKeyRemoveAll2() {\n         resetFull();\n-        MultiKeyMap multimap = (MultiKeyMap) map;\n+        MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n-        \n+\n         multimap.removeAll(I2, I3);\n         assertEquals(9, multimap.size());\n-        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey key = (MultiKey) it.next();\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n             assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n         }\n     }\n-    \n+\n     public void testMultiKeyRemoveAll3() {\n         resetFull();\n-        MultiKeyMap multimap = (MultiKeyMap) map;\n+        MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n-        \n+\n         multimap.removeAll(I1, I1, I2);\n         assertEquals(9, multimap.size());\n-        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey key = (MultiKey) it.next();\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n         }\n     }\n-    \n+\n     public void testMultiKeyRemoveAll4() {\n         resetFull();\n-        MultiKeyMap multimap = (MultiKeyMap) map;\n+        MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n-        \n+\n         multimap.removeAll(I1, I1, I2, I3);\n         assertEquals(10, multimap.size());\n-        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey key = (MultiKey) it.next();\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        MultiKeyMap map = new MultiKeyMap();\n-        map.put(new MultiKey(I1, I2), \"1-2\");\n-        Map cloned = (Map) map.clone();\n+        MultiKeyMap<K, V> map = new MultiKeyMap<K, V>();\n+        map.put(new MultiKey<K>((K) I1, (K) I2), (V) \"1-2\");\n+        Map<MultiKey<? extends K>, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n-        assertSame(map.get(new MultiKey(I1, I2)), cloned.get(new MultiKey(I1, I2)));\n+        assertSame(map.get(new MultiKey<K>((K) I1, (K) I2)), cloned.get(new MultiKey<K>((K) I1, (K) I2)));\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testLRUMultiKeyMap() {\n-        MultiKeyMap map = MultiKeyMap.decorate(new LRUMap(2));\n-        map.put(I1, I2, \"1-2\");\n-        map.put(I1, I3, \"1-3\");\n+        MultiKeyMap<K, V> map = MultiKeyMap.decorate(new LRUMap<MultiKey<? extends K>, V>(2));\n+        map.put((K) I1, (K) I2, (V) \"1-2\");\n+        map.put((K) I1, (K) I3, (V) \"1-1\");\n         assertEquals(2, map.size());\n-        map.put(I1, I4, \"1-4\");\n+        map.put((K) I1, (K) I4, (V) \"1-4\");\n         assertEquals(2, map.size());\n         assertEquals(true, map.containsKey(I1, I3));\n         assertEquals(true, map.containsKey(I1, I4));\n         assertEquals(false, map.containsKey(I1, I2));\n-        \n-        MultiKeyMap cloned = (MultiKeyMap) map.clone();\n+\n+        MultiKeyMap<K, V> cloned = map.clone();\n         assertEquals(2, map.size());\n         assertEquals(true, cloned.containsKey(I1, I3));\n         assertEquals(true, cloned.containsKey(I1, I4));\n         assertEquals(false, cloned.containsKey(I1, I2));\n-        cloned.put(I1, I5, \"1-5\");\n+        cloned.put((K) I1, (K) I5, (V) \"1-5\");\n         assertEquals(2, cloned.size());\n         assertEquals(true, cloned.containsKey(I1, I4));\n         assertEquals(true, cloned.containsKey(I1, I5));\n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/MultiKeyMap.fullCollection.version3.1.obj\");\n //    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public MultiKeyMap<K, V> getMap() {\n+        return (MultiKeyMap<K, V>) super.getMap();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestPredicatedSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestPredicatedSortedMap.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.Predicate;\n-import org.apache.commons.collections.PredicateUtils;\n+import org.apache.commons.collections.functors.TruePredicate;\n \n /**\n- * Extension of {@link TestPredicatedMap} for exercising the \n+ * Extension of {@link TestPredicatedMap} for exercising the\n  * {@link PredicatedSortedMap} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestPredicatedSortedMap extends AbstractTestSortedMap{\n-    \n-    protected static final Predicate truePredicate = PredicateUtils.truePredicate();\n-    protected static final Predicate testPredicate = new Predicate() {\n+public class TestPredicatedSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n         public boolean evaluate(Object o) {\n             return (o instanceof String);\n         }\n     };\n-    \n+\n     public TestPredicatedSortedMap(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestPredicatedSortedMap.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestPredicatedSortedMap.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n     //-----------------------------------------------------------------------\n-    protected SortedMap decorateMap(SortedMap map, Predicate keyPredicate, \n-        Predicate valuePredicate) {\n+    protected SortedMap<K, V> decorateMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n+        Predicate<? super V> valuePredicate) {\n         return PredicatedSortedMap.decorate(map, keyPredicate, valuePredicate);\n     }\n-    \n-    public Map makeEmptyMap() {\n-        return decorateMap(new TreeMap(), truePredicate, truePredicate);\n+\n+    public SortedMap<K, V> makeObject() {\n+        return decorateMap(new TreeMap<K, V>(), truePredicate, truePredicate);\n     }\n-   \n-    public Map makeTestMap() {\n-        return decorateMap(new TreeMap(), testPredicate, testPredicate);\n-    } \n-    \n-    public SortedMap makeTestSortedMap() {\n-        return decorateMap(new TreeMap(), testPredicate, testPredicate);\n+\n+    public SortedMap<K, V> makeTestMap() {\n+        return decorateMap(new TreeMap<K, V>(), testPredicate, testPredicate);\n     }\n-    \n+\n     public boolean isSubMapViewsSerializable() {\n         // TreeMap sub map views have a bug in deserialization.\n         return false;\n \n     // from TestPredicatedMap\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testEntrySet() {\n-        SortedMap map = makeTestSortedMap();\n+        SortedMap<K, V> map = makeTestMap();\n         assertTrue(\"returned entryset should not be null\",\n             map.entrySet() != null);\n-        map = decorateMap(new TreeMap(), null, null);\n-        map.put(\"oneKey\", \"oneValue\");\n+        map = decorateMap(new TreeMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n         assertTrue(\"returned entryset should contain one entry\",\n-            map.entrySet().size() == 1); \n+            map.entrySet().size() == 1);\n         map = decorateMap(map, null, null);\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testPut() {\n-        Map map = makeTestMap();\n+        Map<K, V> map = makeTestMap();\n         try {\n-            map.put(\"Hi\", new Integer(3));\n+            map.put((K) \"Hi\", (V) new Integer(3));\n             fail(\"Illegal value should raise IllegalArgument\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n-            map.put(new Integer(3), \"Hi\");\n+            map.put((K) new Integer(3), (V) \"Hi\");\n             fail(\"Illegal key should raise IllegalArgument\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         assertTrue(!map.containsKey(new Integer(3)));\n         assertTrue(!map.containsValue(new Integer(3)));\n \n-        Map map2 = new HashMap();\n-        map2.put(\"A\", \"a\");\n-        map2.put(\"B\", \"b\");\n-        map2.put(\"C\", \"c\");\n-        map2.put(\"c\", new Integer(3));\n+        Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n \n         try {\n             map.putAll(map2);\n             // expected\n         }\n \n-        map.put(\"E\", \"e\");\n-        Iterator iterator = map.entrySet().iterator();\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n         try {\n-            Map.Entry entry = (Map.Entry)iterator.next();\n-            entry.setValue(new Integer(3));\n+            Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n             fail(\"Illegal value should raise IllegalArgument\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n-        map.put(\"F\", \"f\");\n+\n+        map.put((K) \"F\", (V) \"f\");\n         iterator = map.entrySet().iterator();\n-        Map.Entry entry = (Map.Entry)iterator.next();\n-        entry.setValue(\"x\");\n-        \n+        Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testSortOrder() {\n-        SortedMap map = makeTestSortedMap();\n-        map.put(\"A\",  \"a\");\n-        map.put(\"B\", \"b\");\n+        SortedMap<K, V> map = makeTestMap();\n+        map.put((K) \"A\",  (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n         try {\n-            map.put(null, \"c\");\n+            map.put(null, (V) \"c\");\n             fail(\"Null key should raise IllegalArgument\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        map.put(\"C\", \"c\");\n+        map.put((K) \"C\", (V) \"c\");\n         try {\n-            map.put(\"D\", null);\n+            map.put((K) \"D\", null);\n             fail(\"Null value should raise IllegalArgument\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n         assertEquals(\"First key should be A\", \"A\", map.firstKey());\n         assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n-        assertEquals(\"First key in tail map should be B\", \n-            \"B\", map.tailMap(\"B\").firstKey());\n-        assertEquals(\"Last key in head map should be B\", \n-            \"B\", map.headMap(\"C\").lastKey());\n+        assertEquals(\"First key in tail map should be B\",\n+            \"B\", map.tailMap((K) \"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\",\n+            \"B\", map.headMap((K) \"C\").lastKey());\n         assertEquals(\"Last key in submap should be B\",\n-            \"B\", map.subMap(\"A\",\"C\").lastKey());\n-        \n-        Comparator c = map.comparator();\n-        assertTrue(\"natural order, so comparator should be null\", \n+           \"B\", map.subMap((K) \"A\",(K) \"C\").lastKey());\n+\n+        Comparator<? super K> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\",\n             c == null);\n     }\n \n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/PredicatedSortedMap.fullCollection.version3.1.obj\");\n //    }\n-}\n+}\n--- a/src/test/org/apache/commons/collections/map/TestReferenceIdentityMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestReferenceIdentityMap.java\n \n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.map.AbstractReferenceMap.ReferenceStrength;\n \n /**\n- * Tests for ReferenceIdentityMap. \n+ * Tests for ReferenceIdentityMap.\n  *\n  * @version $Revision$\n  *\n  * @author Stephen Colebourne\n  * @author Guilhem Lavaux\n  */\n-public class TestReferenceIdentityMap extends AbstractTestIterableMap {\n+public class TestReferenceIdentityMap<K, V> extends AbstractTestIterableMap<K, V> {\n \n     private static final Integer I1A = new Integer(1);\n     private static final Integer I1B = new Integer(1);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n-        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n-        return map;\n-    }\n-    \n-    public Map makeConfirmedMap() {\n+    public ReferenceIdentityMap<K, V> makeObject() {\n+        return new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    public Map<K, V> makeConfirmedMap() {\n         // Testing against another [collections] class generally isn't a good idea,\n-        // but the alternative is a JDK1.4 dependency in the tests\n-        return new IdentityMap();\n+        // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.\n+        // arguably ReferenceIdentityMap should do the same but that's a later discussion.\n+        return new IdentityMap<K, V>();\n     }\n \n     public boolean isAllowNullKey() {\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testBasics() {\n-        IterableMap map = new ReferenceIdentityMap(ReferenceIdentityMap.HARD, ReferenceIdentityMap.HARD);\n+        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n         assertEquals(0, map.size());\n-        \n-        map.put(I1A, I2A);\n+\n+        map.put((K) I1A, (V) I2A);\n         assertEquals(1, map.size());\n         assertSame(I2A, map.get(I1A));\n         assertSame(null, map.get(I1B));\n         assertEquals(false, map.containsKey(I1B));\n         assertEquals(true, map.containsValue(I2A));\n         assertEquals(false, map.containsValue(I2B));\n-        \n-        map.put(I1A, I2B);\n+\n+        map.put((K) I1A, (V) I2B);\n         assertEquals(1, map.size());\n         assertSame(I2B, map.get(I1A));\n         assertSame(null, map.get(I1B));\n         assertEquals(false, map.containsKey(I1B));\n         assertEquals(false, map.containsValue(I2A));\n         assertEquals(true, map.containsValue(I2B));\n-        \n-        map.put(I1B, I2B);\n+\n+        map.put((K) I1B, (V) I2B);\n         assertEquals(2, map.size());\n         assertSame(I2B, map.get(I1A));\n         assertSame(I2B, map.get(I1B));\n         assertEquals(false, map.containsValue(I2A));\n         assertEquals(true, map.containsValue(I2B));\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testHashEntry() {\n-        IterableMap map = new ReferenceIdentityMap(ReferenceIdentityMap.HARD, ReferenceIdentityMap.HARD);\n-        \n-        map.put(I1A, I2A);\n-        map.put(I1B, I2A);\n-        \n-        Map.Entry entry1 = (Map.Entry) map.entrySet().iterator().next();\n-        Iterator it = map.entrySet().iterator();\n-        Map.Entry entry2 = (Map.Entry) it.next();\n-        Map.Entry entry3 = (Map.Entry) it.next();\n-        \n+        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry2 = it.next();\n+        Map.Entry<K, V> entry3 = it.next();\n+\n         assertEquals(true, entry1.equals(entry2));\n         assertEquals(true, entry2.equals(entry1));\n         assertEquals(false, entry1.equals(entry3));\n     }\n-    \n-    \n+\n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testNullHandling() {\n         resetFull();\n-        assertEquals(null, map.get(null));\n-        assertEquals(false, map.containsKey(null));\n-        assertEquals(false, map.containsValue(null));\n-        assertEquals(null, map.remove(null));\n-        assertEquals(false, map.entrySet().contains(null));\n-        assertEquals(false, map.keySet().contains(null));\n-        assertEquals(false, map.values().contains(null));\n+        assertEquals(null, getMap().get(null));\n+        assertEquals(false, getMap().containsKey(null));\n+        assertEquals(false, getMap().containsValue(null));\n+        assertEquals(null, getMap().remove(null));\n+        assertEquals(false, getMap().entrySet().contains(null));\n+        assertEquals(false, getMap().keySet().contains(null));\n+        assertEquals(false, getMap().values().contains(null));\n         try {\n-            map.put(null, null);\n+            getMap().put(null, null);\n             fail();\n         } catch (NullPointerException ex) {}\n         try {\n-            map.put(new Object(), null);\n+            getMap().put((K) new Object(), null);\n             fail();\n         } catch (NullPointerException ex) {}\n         try {\n-            map.put(null, new Object());\n+            getMap().put(null, (V) new Object());\n             fail();\n         } catch (NullPointerException ex) {}\n     }\n     }\n */\n \n-    WeakReference keyReference;\n-    WeakReference valueReference;\n-\n-    public Map buildRefMap() {\n-        Object key = new Object();\n-        Object value = new Object();\n-        \n-        keyReference = new WeakReference(key);\n-        valueReference = new WeakReference(value);\n-        \n-        Map testMap = new ReferenceIdentityMap(ReferenceMap.WEAK, ReferenceMap.HARD, true);\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildRefMap() {\n+        K key = (K) new Object();\n+        V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        Map<K, V> testMap = new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n         testMap.put(key, value);\n- \n+\n         assertEquals(\"In map\", value, testMap.get(key));\n         assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n         assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n     /** Tests whether purge values setting works */\n     public void testPurgeValues() throws Exception {\n         // many thanks to Juozas Baliuka for suggesting this method\n-        Map testMap = buildRefMap();\n-        \n+        Map<K, V> testMap = buildRefMap();\n+\n         int iterations = 0;\n         int bytz = 2;\n-        while(true) {\n+        while (true) {\n             System.gc();\n-            if(iterations++ > 50){\n+            if (iterations++ > 50) {\n                 fail(\"Max iterations reached before resource released.\");\n             }\n             testMap.isEmpty();\n-            if( \n+            if (\n                 keyReference.get() == null &&\n                 valueReference.get() == null) {\n                 break;\n-                \n+\n             } else {\n                 // create garbage:\n+                @SuppressWarnings(\"unused\")\n                 byte[] b =  new byte[bytz];\n                 bytz = bytz * 2;\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"unused\")\n     private static void gc() {\n         try {\n             // trigger GC\n--- a/src/test/org/apache/commons/collections/map/TestReferenceMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestReferenceMap.java\n import junit.framework.Test;\n \n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.map.AbstractReferenceMap.ReferenceStrength;\n \n /**\n- * Tests for ReferenceMap. \n+ * Tests for ReferenceMap.\n  *\n  * @version $Revision$ $Date$\n  *\n  * @author Paul Jack\n  * @author Guilhem Lavaux\n  */\n-public class TestReferenceMap extends AbstractTestIterableMap {\n+public class TestReferenceMap<K, V> extends AbstractTestIterableMap<K, V> {\n \n     public TestReferenceMap(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n-        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n-        return map;\n+    public ReferenceMap<K, V> makeObject() {\n+        return new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n     }\n \n     public boolean isAllowNullKey() {\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testNullHandling() {\n         resetFull();\n         assertEquals(null, map.get(null));\n             fail();\n         } catch (NullPointerException ex) {}\n         try {\n-            map.put(new Object(), null);\n+            map.put((K) new Object(), null);\n             fail();\n         } catch (NullPointerException ex) {}\n         try {\n-            map.put(null, new Object());\n+            map.put(null, (V) new Object());\n             fail();\n         } catch (NullPointerException ex) {}\n     }\n     }\n */\n \n-    WeakReference keyReference;\n-    WeakReference valueReference;\n-\n-    public Map buildRefMap() {\n-        Object key = new Object();\n-        Object value = new Object();\n-        \n-        keyReference = new WeakReference(key);\n-        valueReference = new WeakReference(value);\n-        \n-        Map testMap = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.HARD, true);\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildRefMap() {\n+        K key = (K) new Object();\n+        V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        Map<K, V> testMap = new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n         testMap.put(key, value);\n- \n+\n         assertEquals(\"In map\", value, testMap.get(key));\n         assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n         assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n     /** Tests whether purge values setting works */\n     public void testPurgeValues() throws Exception {\n         // many thanks to Juozas Baliuka for suggesting this method\n-        Map testMap = buildRefMap();\n+        Map<K, V> testMap = buildRefMap();\n \n         int iterations = 0;\n         int bytz = 2;\n-        while(true) {\n+        while (true) {\n             System.gc();\n-            if(iterations++ > 50){\n+            if (iterations++ > 50) {\n                 fail(\"Max iterations reached before resource released.\");\n             }\n             testMap.isEmpty();\n-            if( \n-                keyReference.get() == null &&\n-                valueReference.get() == null) {\n+            if (keyReference.get() == null && valueReference.get() == null) {\n                 break;\n-                \n+\n             } else {\n                 // create garbage:\n-                byte[] b =  new byte[bytz];\n+                @SuppressWarnings(\"unused\")\n+                byte[] b = new byte[bytz];\n                 bytz = bytz * 2;\n             }\n         }\n     }\n \n+    @SuppressWarnings(\"unused\")\n     private static void gc() {\n         try {\n             // trigger GC\n--- a/src/test/org/apache/commons/collections/map/TestSingletonMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestSingletonMap.java\n package org.apache.commons.collections.map;\n \n import java.util.HashMap;\n-import java.util.Map;\n \n import junit.framework.Test;\n import junit.textui.TestRunner;\n import org.apache.commons.collections.BoundedMap;\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.OrderedMap;\n \n /**\n  * JUnit tests.\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestSingletonMap extends AbstractTestOrderedMap {\n+public class TestSingletonMap<K, V> extends AbstractTestOrderedMap<K, V> {\n \n     private static final Integer ONE = new Integer(1);\n     private static final Integer TWO = new Integer(2);\n     private static final String TEN = \"10\";\n-    private static final String TWENTY = \"20\";\n-        \n+\n     public TestSingletonMap(String testName) {\n         super(testName);\n     }\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestSingletonMap.class);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Map makeEmptyMap() {\n+    public OrderedMap<K, V> makeObject() {\n         // need an empty singleton map, but thats not possible\n         // use a ridiculous fake instead to make the tests pass\n-        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap()));\n+        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap<K, V>()));\n     }\n-    \n+\n     public String[] ignoredTests() {\n         // the ridiculous map above still doesn't pass these tests\n         // but its not relevant, so we ignore them\n         };\n     }\n \n-\n-    public Map makeFullMap() {\n-        return new SingletonMap(ONE, TWO);\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> makeFullMap() {\n+        return new SingletonMap<K, V>((K) ONE, (V) TWO);\n     }\n \n     public boolean isPutAddSupported() {\n         return false;\n     }\n \n-    public Object[] getSampleKeys() {\n-        return new Object[] {ONE};\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        return (K[]) new Object[] { ONE };\n     }\n \n-    public Object[] getSampleValues() {\n-        return new Object[] {TWO};\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] { TWO };\n     }\n \n-    public Object[] getNewSampleValues() {\n-        return new Object[] {TEN};\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] { TEN };\n     }\n \n     //-----------------------------------------------------------------------\n     public void testClone() {\n-        SingletonMap map = new SingletonMap(ONE, TWO);\n+        SingletonMap<K, V> map = makeFullMap();\n         assertEquals(1, map.size());\n-        SingletonMap cloned = (SingletonMap) map.clone();\n+        SingletonMap<K, V> cloned = map.clone();\n         assertEquals(1, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n         assertEquals(true, cloned.containsValue(TWO));\n     }\n \n     public void testKeyValue() {\n-        SingletonMap map = new SingletonMap(ONE, TWO);\n+        SingletonMap<K, V> map = makeFullMap();\n         assertEquals(1, map.size());\n         assertEquals(ONE, map.getKey());\n         assertEquals(TWO, map.getValue());\n     }\n \n     public void testBoundedMap() {\n-        SingletonMap map = new SingletonMap(ONE, TWO);\n+        SingletonMap<K, V> map = makeFullMap();\n         assertEquals(1, map.size());\n         assertEquals(true, map.isFull());\n         assertEquals(1, map.maxSize());\n //    public BulkTest bulkTestMapIterator() {\n //        return new TestFlatMapIterator();\n //    }\n-//    \n+//\n //    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator {\n //        public TestFlatMapIterator() {\n //            super(\"TestFlatMapIterator\");\n //        }\n-//        \n+//\n //        public Object[] addSetValues() {\n //            return TestSingletonMap.this.getNewSampleValues();\n //        }\n-//        \n+//\n //        public boolean supportsRemove() {\n //            return TestSingletonMap.this.isRemoveSupported();\n //        }\n //            resetFull();\n //            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n //        }\n-//        \n+//\n //        public Map getMap() {\n //            // assumes makeFullMapIterator() called first\n //            return TestSingletonMap.this.map;\n //        }\n-//        \n+//\n //        public Map getConfirmedMap() {\n //            // assumes makeFullMapIterator() called first\n //            return TestSingletonMap.this.confirmed;\n //        }\n-//        \n+//\n //        public void verify() {\n //            super.verify();\n //            TestSingletonMap.this.verify();\n //        }\n //    }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }\n--- a/src/test/org/apache/commons/collections/map/TestTransformedSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestTransformedSortedMap.java\n import junit.framework.Test;\n \n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.TransformerUtils;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedSortedMap extends AbstractTestSortedMap {\n-    \n+public class TestTransformedSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n     public TestTransformedSortedMap(String testName) {\n         super(testName);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    public Map makeEmptyMap() {\n-        return TransformedSortedMap.decorate(new TreeMap(), TransformerUtils.nopTransformer(), TransformerUtils.nopTransformer());\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedMap<K, V> makeObject() {\n+        return TransformedSortedMap.decorate(new TreeMap<K, V>(),\n+                (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),\n+                (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());\n     }\n \n     public boolean isSubMapViewsSerializable() {\n         return false;\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testTransformedMap() {\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n \n-        Map map = TransformedSortedMap.decorate(new TreeMap(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER, null);\n+        SortedMap<K, V> map = TransformedSortedMap\n+                .decorate(\n+                        new TreeMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n-            map.put(els[i], els[i]);\n+            map.put((K) els[i], (V) els[i]);\n             assertEquals(i + 1, map.size());\n             assertEquals(true, map.containsKey(new Integer((String) els[i])));\n             try {\n             assertEquals(true, map.containsValue(els[i]));\n             assertEquals(els[i], map.get(new Integer((String) els[i])));\n         }\n-        \n+\n         try {\n             map.remove(els[0]);\n             fail();\n         } catch (ClassCastException ex) {}\n         assertEquals(els[0], map.remove(new Integer((String) els[0])));\n-        \n-        map = TransformedSortedMap.decorate(new TreeMap(), null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+\n+        map = TransformedSortedMap\n+                .decorate(\n+                        new TreeMap<K, V>(),\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n-            map.put(els[i], els[i]);\n+            map.put((K) els[i], (V) els[i]);\n             assertEquals(i + 1, map.size());\n             assertEquals(true, map.containsValue(new Integer((String) els[i])));\n             assertEquals(false, map.containsValue(els[i]));\n         }\n \n         assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n-        \n-        Set entrySet = map.entrySet();\n-        Map.Entry[] array = (Map.Entry[]) entrySet.toArray(new Map.Entry[0]);\n-        array[0].setValue(\"66\");\n+\n+        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        Map.Entry<K, V>[] array = (Map.Entry<K, V>[]) entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n         assertEquals(new Integer(66), array[0].getValue());\n         assertEquals(new Integer(66), map.get(array[0].getKey()));\n-        \n-        Map.Entry entry = (Map.Entry) entrySet.iterator().next();\n-        entry.setValue(\"88\");\n+\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        entry.setValue((V) \"88\");\n         assertEquals(new Integer(88), entry.getValue());\n         assertEquals(new Integer(88), map.get(entry.getKey()));\n     }\n \n     //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testFactory_Decorate() {\n-        SortedMap base = new TreeMap();\n-        base.put(\"A\", \"1\");\n-        base.put(\"B\", \"2\");\n-        base.put(\"C\", \"3\");\n-        \n-        SortedMap trans = TransformedSortedMap.decorate(base, null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        SortedMap<K, V> trans = TransformedSortedMap\n+                .decorate(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n         assertEquals(\"1\", trans.get(\"A\"));\n         assertEquals(\"2\", trans.get(\"B\"));\n         assertEquals(\"3\", trans.get(\"C\"));\n-        trans.put(\"D\", \"4\");\n+        trans.put((K) \"D\", (V) \"4\");\n         assertEquals(new Integer(4), trans.get(\"D\"));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testFactory_decorateTransform() {\n-        SortedMap base = new TreeMap();\n-        base.put(\"A\", \"1\");\n-        base.put(\"B\", \"2\");\n-        base.put(\"C\", \"3\");\n-        \n-        SortedMap trans = TransformedSortedMap.decorateTransform(base, null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        SortedMap<K, V> trans = TransformedSortedMap\n+                .decorateTransform(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n         assertEquals(new Integer(1), trans.get(\"A\"));\n         assertEquals(new Integer(2), trans.get(\"B\"));\n         assertEquals(new Integer(3), trans.get(\"C\"));\n-        trans.put(\"D\", \"4\");\n+        trans.put((K) \"D\", (V) \"4\");\n         assertEquals(new Integer(4), trans.get(\"D\"));\n     }\n \n--- a/src/test/org/apache/commons/collections/map/TestUnmodifiableMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestUnmodifiableMap.java\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.Unmodifiable;\n \n /**\n- * Extension of {@link AbstractTestMap} for exercising the \n+ * Extension of {@link AbstractTestMap} for exercising the\n  * {@link UnmodifiableMap} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestUnmodifiableMap extends AbstractTestIterableMap{\n-    \n+public class TestUnmodifiableMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n     public TestUnmodifiableMap(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableMap.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableMap.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n+\n     //-------------------------------------------------------------------\n-    \n-    public Map makeEmptyMap() {\n-        return UnmodifiableMap.decorate(new HashMap());\n+\n+    public IterableMap<K, V> makeObject() {\n+        return (IterableMap<K, V>) UnmodifiableMap.decorate(new HashMap<K, V>());\n     }\n-    \n+\n     public boolean isPutChangeSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isPutAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n-    public Map makeFullMap() {\n-        Map m = new HashMap();\n+\n+    public IterableMap<K, V> makeFullMap() {\n+        Map<K, V> m = new HashMap<K, V>();\n         addSampleMappings(m);\n-        return UnmodifiableMap.decorate(m);\n+        return (IterableMap<K, V>) UnmodifiableMap.decorate(m);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testUnmodifiable() {\n-        assertTrue(makeEmptyMap() instanceof Unmodifiable);\n+        assertTrue(makeObject() instanceof Unmodifiable);\n         assertTrue(makeFullMap() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        Map map = makeFullMap();\n+        Map<K, V> map = makeFullMap();\n         assertSame(map, UnmodifiableMap.decorate(map));\n-        \n+\n         try {\n             UnmodifiableMap.decorate(null);\n             fail();\n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/UnmodifiableMap.fullCollection.version3.1.obj\");\n //    }\n-}\n+}\n--- a/src/test/org/apache/commons/collections/map/TestUnmodifiableOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestUnmodifiableOrderedMap.java\n package org.apache.commons.collections.map;\n \n import java.util.HashMap;\n-import java.util.Map;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n import org.apache.commons.collections.Unmodifiable;\n \n /**\n- * Extension of {@link AbstractTestOrderedMap} for exercising the \n+ * Extension of {@link AbstractTestOrderedMap} for exercising the\n  * {@link UnmodifiableOrderedMap} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableOrderedMap extends AbstractTestOrderedMap {\n-    \n+public class TestUnmodifiableOrderedMap<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n     public TestUnmodifiableOrderedMap(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableOrderedMap.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableOrderedMap.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n+\n     //-------------------------------------------------------------------\n-    \n-    public Map makeEmptyMap() {\n-        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap()));\n+\n+    public OrderedMap<K, V> makeObject() {\n+        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap<K, V>()));\n     }\n-    \n+\n     public boolean isPutChangeSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isPutAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n-    public Map makeFullMap() {\n-        OrderedMap m = ListOrderedMap.decorate(new HashMap());\n+\n+    public OrderedMap<K, V> makeFullMap() {\n+        OrderedMap<K, V> m = ListOrderedMap.decorate(new HashMap<K, V>());\n         addSampleMappings(m);\n         return UnmodifiableOrderedMap.decorate(m);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testUnmodifiable() {\n-        assertTrue(makeEmptyMap() instanceof Unmodifiable);\n+        assertTrue(makeObject() instanceof Unmodifiable);\n         assertTrue(makeFullMap() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        Map map = makeFullMap();\n-        assertSame(map, UnmodifiableOrderedMap.decorate((OrderedMap) map));\n-        \n+        OrderedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableOrderedMap.decorate(map));\n+\n         try {\n             UnmodifiableOrderedMap.decorate(null);\n             fail();\n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/UnmodifiableOrderedMap.fullCollection.version3.1.obj\");\n //    }\n-}\n+}\n--- a/src/test/org/apache/commons/collections/map/TestUnmodifiableSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestUnmodifiableSortedMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import java.util.Map;\n import java.util.SortedMap;\n import java.util.TreeMap;\n \n import org.apache.commons.collections.Unmodifiable;\n \n /**\n- * Extension of {@link AbstractTestSortedMap} for exercising the \n+ * Extension of {@link AbstractTestSortedMap} for exercising the\n  * {@link UnmodifiableSortedMap} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestUnmodifiableSortedMap extends AbstractTestSortedMap {\n-    \n+public class TestUnmodifiableSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n     public TestUnmodifiableSortedMap(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return new TestSuite(TestUnmodifiableSortedMap.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableSortedMap.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n+\n     //-------------------------------------------------------------------\n-    \n-    public Map makeEmptyMap() {\n-        return UnmodifiableSortedMap.decorate(new TreeMap());\n+\n+    public SortedMap<K, V> makeObject() {\n+        return UnmodifiableSortedMap.decorate(new TreeMap<K, V>());\n     }\n-    \n+\n     public boolean isPutChangeSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isPutAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-    \n-    public Map makeFullMap() {\n-        SortedMap m = new TreeMap();\n+\n+    public SortedMap<K, V> makeFullMap() {\n+        SortedMap<K, V> m = new TreeMap<K, V>();\n         addSampleMappings(m);\n         return UnmodifiableSortedMap.decorate(m);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testUnmodifiable() {\n-        assertTrue(makeEmptyMap() instanceof Unmodifiable);\n+        assertTrue(makeObject() instanceof Unmodifiable);\n         assertTrue(makeFullMap() instanceof Unmodifiable);\n     }\n-    \n+\n     public void testDecorateFactory() {\n-        Map map = makeFullMap();\n-        assertSame(map, UnmodifiableSortedMap.decorate((SortedMap) map));\n-        \n+        SortedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableSortedMap.decorate(map));\n+\n         try {\n             UnmodifiableSortedMap.decorate(null);\n             fail();\n //            (java.io.Serializable) map,\n //            \"D:/dev/collections/data/test/UnmodifiableSortedMap.fullCollection.version3.1.obj\");\n //    }\n-}\n+}\n--- a/src/test/org/apache/commons/collections/set/AbstractTestSet.java\n+++ b/src/test/org/apache/commons/collections/set/AbstractTestSet.java\n  *\n  * @author Paul Jack\n  */\n-public abstract class AbstractTestSet extends AbstractTestCollection {\n+public abstract class AbstractTestSet<E> extends AbstractTestCollection<E> {\n \n     /**\n      * JUnit constructor.\n     public void verify() {\n         super.verify();\n         \n-        assertEquals(\"Sets should be equal\", confirmed, collection);\n+        assertEquals(\"Sets should be equal\", getConfirmed(), getCollection());\n         assertEquals(\"Sets should have equal hashCodes\", \n-                     confirmed.hashCode(), collection.hashCode());\n-        Collection set = makeConfirmedCollection();\n-        Iterator iterator = collection.iterator();\n+                     getConfirmed().hashCode(), getCollection().hashCode());\n+        Collection<E> set = makeConfirmedCollection();\n+        Iterator<E> iterator = getCollection().iterator();\n         while (iterator.hasNext()) {\n-            assertTrue(\"Set.iterator should only return unique elements\", \n-                       set.add(iterator.next()));\n+            assertTrue(\"Set.iterator should only return unique elements\", set.add(iterator.next()));\n         }\n     }\n \n      *\n      * @return a confirmed empty collection\n      */\n-    public Collection makeConfirmedCollection() {\n-        return new HashSet();\n+    public Collection<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n     }\n \n     /**\n      *\n      * @return a confirmed full collection\n      */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection set = makeConfirmedCollection();\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> set = makeConfirmedCollection();\n         set.addAll(Arrays.asList(getFullElements()));\n         return set;\n     }\n      *\n      * @return an empty set\n      */\n-    public abstract Set makeEmptySet();\n+    public abstract Set<E> makeObject();\n \n     /**\n      * Makes a full set by first creating an empty set and then adding\n      *\n      * @return a full set\n      */\n-    public Set makeFullSet() {\n-        Set set = makeEmptySet();\n+    public Set<E> makeFullCollection() {\n+        Set<E> set = makeObject();\n         set.addAll(Arrays.asList(getFullElements()));\n         return set;\n-    }\n-\n-    /**\n-     * Makes an empty collection by invoking {@link #makeEmptySet()}.  \n-     *\n-     * @return an empty collection\n-     */\n-    public final Collection makeCollection() {\n-        return makeEmptySet();\n-    }\n-\n-    /**\n-     * Makes a full collection by invoking {@link #makeFullSet()}.\n-     *\n-     * @return a full collection\n-     */\n-    public final Collection makeFullCollection() {\n-        return makeFullSet();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Return the {@link AbstractTestCollection#collection} fixture, but cast as a Set.  \n      */\n-    public Set getSet() {\n-        return (Set)collection;\n+    public Set<E> getCollection() {\n+        return (Set<E>) super.getCollection();\n     }\n \n     /**\n      * Return the {@link AbstractTestCollection#confirmed} fixture, but cast as a Set.\n      */\n-    public Set getConfirmedSet() {\n-        return (Set)confirmed;\n+    public Set<E> getConfirmed() {\n+        return (Set<E>) super.getConfirmed();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Tests {@link Set#equals(Object)}.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testSetEquals() {\n         resetEmpty();\n-        assertEquals(\"Empty sets should be equal\", \n-                     getSet(), getConfirmedSet());\n+        assertEquals(\"Empty sets should be equal\", getCollection(), getConfirmed());\n         verify();\n \n-        Collection set2 = makeConfirmedCollection();\n-        set2.add(\"foo\");\n-        assertTrue(\"Empty set shouldn't equal nonempty set\", \n-                   !getSet().equals(set2));\n+        Collection<E> set2 = makeConfirmedCollection();\n+        set2.add((E) \"foo\");\n+        assertTrue(\"Empty set shouldn't equal nonempty set\", !getCollection().equals(set2));\n \n         resetFull();\n-        assertEquals(\"Full sets should be equal\", getSet(), getConfirmedSet());\n+        assertEquals(\"Full sets should be equal\", getCollection(), getConfirmed());\n         verify();\n \n         set2.clear();\n         set2.addAll(Arrays.asList(getOtherElements()));\n-        assertTrue(\"Sets with different contents shouldn't be equal\", \n-                   !getSet().equals(set2));\n+        assertTrue(\"Sets with different contents shouldn't be equal\", !getCollection().equals(set2));\n     }\n \n     /**\n     public void testSetHashCode() {\n         resetEmpty();\n         assertEquals(\"Empty sets have equal hashCodes\", \n-                     getSet().hashCode(), getConfirmedSet().hashCode());\n+                getCollection().hashCode(), getConfirmed().hashCode());\n \n         resetFull();\n         assertEquals(\"Equal sets have equal hashCodes\", \n-                     getSet().hashCode(), getConfirmedSet().hashCode());\n+                getCollection().hashCode(), getConfirmed().hashCode());\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/set/AbstractTestSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/AbstractTestSortedSet.java\n  */\n package org.apache.commons.collections.set;\n \n-import java.util.Collection;\n import java.util.Iterator;\n-import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n \n  * @author Stephen Colebourne\n  * @author Dieter Wimberger\n  */\n-public abstract class AbstractTestSortedSet extends AbstractTestSet {\n+public abstract class AbstractTestSortedSet<E> extends AbstractTestSet<E> {\n \n     /**\n      * JUnit constructor.\n         \n         // Check that iterator returns elements in order and first() and last()\n         // are consistent\n-        Iterator colliter = collection.iterator();\n-        Iterator confiter = confirmed.iterator();\n-        Object first = null;\n-        Object last = null;\n+        Iterator<E> colliter = getCollection().iterator();\n+        Iterator<E> confiter = getConfirmed().iterator();\n+        E first = null;\n+        E last = null;\n         while (colliter.hasNext()) {\n             if (first == null) {\n                 first = colliter.next();\n             }  \n             assertEquals(\"Element appears to be out of order.\", last, confiter.next());\n         }\n-        if (collection.size() > 0) {\n+        if (getCollection().size() > 0) {\n             assertEquals(\"Incorrect element returned by first().\", first,\n-                ((SortedSet) collection).first());\n+                getCollection().first());\n             assertEquals(\"Incorrect element returned by last().\", last,\n-                ((SortedSet) collection).last());\n+                getCollection().last());\n         }\n     }\n \n         return false;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedSet<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> makeFullCollection() {\n+        return (SortedSet<E>) super.makeFullCollection();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns an empty {@link TreeSet} for use in modification testing.\n      *\n      * @return a confirmed empty collection\n      */\n-    public Collection makeConfirmedCollection() {\n-        return new TreeSet();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Return the {@link AbstractTestCollection#confirmed} fixture, but cast as a\n-     * SortedSet.\n-     */\n-    public SortedSet getConfirmedSortedSet() {\n-        return (SortedSet) confirmed;\n-    }\n+    public SortedSet<E> makeConfirmedCollection() {\n+        return new TreeSet<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n      * Override to return comparable objects.\n      */\n-    public Object[] getFullNonNullElements() {\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n         Object[] elements = new Object[30];\n \n         for (int i = 0; i < 30; i++) {\n             elements[i] = new Integer(i + i + 1);\n         }\n-        return elements;\n+        return (E[]) elements;\n     }\n \n     /**\n      * Override to return comparable objects.\n      */\n-    public Object[] getOtherNonNullElements() {\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n         Object[] elements = new Object[30];\n         for (int i = 0; i < 30; i++) {\n             elements[i] = new Integer(i + i + 2);\n         }\n-        return elements;\n+        return (E[]) elements;\n     }\n \n     //-----------------------------------------------------------------------\n         return new TestSortedSetSubSet(lobound, false);\n     }\n \n-    public class TestSortedSetSubSet extends AbstractTestSortedSet {\n+    public class TestSortedSetSubSet extends AbstractTestSortedSet<E> {\n \n         private int m_Type;\n         private int m_LowBound;\n         private int m_HighBound;\n-        private Object[] m_FullElements;\n-        private Object[] m_OtherElements;\n-\n+        private E[] m_FullElements;\n+        private E[] m_OtherElements;\n+\n+        @SuppressWarnings(\"unchecked\")\n         public TestSortedSetSubSet(int bound, boolean head) {\n             super(\"TestSortedSetSubSet\");\n             if (head) {\n                 //System.out.println(\"HEADSET\");\n                 m_Type = TYPE_HEADSET;\n                 m_HighBound = bound;\n-                m_FullElements = new Object[bound];\n+                m_FullElements = (E[]) new Object[bound];\n                 System.arraycopy(AbstractTestSortedSet.this.getFullElements(), 0, m_FullElements, 0, bound);\n-                m_OtherElements = new Object[bound - 1];\n+                m_OtherElements = (E[]) new Object[bound - 1];\n                 System.arraycopy(//src src_pos dst dst_pos length\n                 AbstractTestSortedSet.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);\n                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                 m_LowBound = bound;\n                 Object[] allelements = AbstractTestSortedSet.this.getFullElements();\n                 //System.out.println(\"bound = \"+bound +\"::length=\"+allelements.length);\n-                m_FullElements = new Object[allelements.length - bound];\n+                m_FullElements = (E[]) new Object[allelements.length - bound];\n                 System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);\n-                m_OtherElements = new Object[allelements.length - bound - 1];\n+                m_OtherElements = (E[]) new Object[allelements.length - bound - 1];\n                 System.arraycopy(//src src_pos dst dst_pos length\n                 AbstractTestSortedSet.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);\n                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n \n         } //type\n \n+        @SuppressWarnings(\"unchecked\")\n         public TestSortedSetSubSet(int lobound, int hibound) {\n             super(\"TestSortedSetSubSet\");\n             //System.out.println(\"SUBSET\");\n             m_HighBound = hibound;\n             int length = hibound - lobound;\n             //System.out.println(\"Low=\" + lobound + \"::High=\" + hibound + \"::Length=\" + length);\n-            m_FullElements = new Object[length];\n+            m_FullElements = (E[]) new Object[length];\n             System.arraycopy(AbstractTestSortedSet.this.getFullElements(), lobound, m_FullElements, 0, length);\n-            m_OtherElements = new Object[length - 1];\n+            m_OtherElements = (E[]) new Object[length - 1];\n             System.arraycopy(//src src_pos dst dst_pos length\n             AbstractTestSortedSet.this.getOtherElements(), lobound, m_OtherElements, 0, length - 1);\n \n             return AbstractTestSortedSet.this.isFailFastSupported();\n         }\n \n-        public Object[] getFullElements() {\n+        public E[] getFullElements() {\n             return m_FullElements;\n         }\n-        public Object[] getOtherElements() {\n+        public E[] getOtherElements() {\n             return m_OtherElements;\n         }\n \n-        private SortedSet getSubSet(SortedSet set) {\n-            Object[] elements = AbstractTestSortedSet.this.getFullElements();\n+        private SortedSet<E> getSubSet(SortedSet<E> set) {\n+            E[] elements = AbstractTestSortedSet.this.getFullElements();\n             switch (m_Type) {\n                 case TYPE_SUBSET :\n                     return set.subSet(elements[m_LowBound], elements[m_HighBound]);\n             }\n         }\n \n-        public Set makeEmptySet() {\n-            SortedSet s = (SortedSet) AbstractTestSortedSet.this.makeEmptySet();\n-            return getSubSet(s);\n-        }\n-\n-        public Set makeFullSet() {\n-            SortedSet s = (SortedSet) AbstractTestSortedSet.this.makeFullCollection();\n-            return getSubSet(s);\n+        public SortedSet<E> makeObject() {\n+            return getSubSet(AbstractTestSortedSet.this.makeObject());\n+        }\n+\n+        public SortedSet<E> makeFullCollection() {\n+            return getSubSet(AbstractTestSortedSet.this.makeFullCollection());\n         }\n         \n         public boolean isTestSerialization() {\n \n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> getCollection() {\n+        return (SortedSet<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> getConfirmed() {\n+        return (SortedSet<E>) super.getConfirmed();\n+    }\n }\n--- a/src/test/org/apache/commons/collections/set/TestListOrderedSet2.java\n+++ b/src/test/org/apache/commons/collections/set/TestListOrderedSet2.java\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Set;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n  * @author Henning P. Schmiedehausen\n  * @author Stephen Colebourne\n  */\n-public class TestListOrderedSet2 extends AbstractTestSet {\n+public class TestListOrderedSet2<E> extends AbstractTestSet<E> {\n+\n+    private static final Integer ZERO = new Integer(0);\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n \n     public TestListOrderedSet2(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Set makeEmptySet() {\n-        return new ListOrderedSet();\n+    public ListOrderedSet<E> makeObject() {\n+        return new ListOrderedSet<E>();\n     }\n \n-    protected Set setupSet() {\n-        Set set = makeEmptySet();\n+    @SuppressWarnings(\"unchecked\")\n+    protected ListOrderedSet<E> setupSet() {\n+        ListOrderedSet<E> set = makeObject();\n \n         for (int i = 0; i < 10; i++) {\n-            set.add(Integer.toString(i));\n+            set.add((E) Integer.toString(i));\n         }\n         return set;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testOrdering() {\n-        Set set = setupSet();\n-        Iterator it = set.iterator();\n+        ListOrderedSet<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n \n         for (int i = 0; i < 10; i++) {\n             assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n         }\n \n         for (int i = 0; i < 10; i++) {\n-            set.add(Integer.toString(i));\n+            set.add((E) Integer.toString(i));\n         }\n \n         assertEquals(\"Size of set is wrong!\", 10, set.size());\n             assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n         }\n     }\n-    \n-    private static final Integer ZERO = new Integer(0);\n-    private static final Integer ONE = new Integer(1);\n-    private static final Integer TWO = new Integer(2);\n-    private static final Integer THREE = new Integer(3);\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testListAddRemove() {\n-        ListOrderedSet set = (ListOrderedSet) makeEmptySet();\n-        List view = set.asList();\n-        set.add(ZERO);\n-        set.add(ONE);\n-        set.add(TWO);\n-        \n+        ListOrderedSet<E> set = makeObject();\n+        List<E> view = set.asList();\n+        set.add((E) ZERO);\n+        set.add((E) ONE);\n+        set.add((E) TWO);\n+\n         assertEquals(3, set.size());\n         assertSame(ZERO, set.get(0));\n         assertSame(ONE, set.get(1));\n         assertSame(ZERO, view.get(0));\n         assertSame(ONE, view.get(1));\n         assertSame(TWO, view.get(2));\n-        \n+\n         assertEquals(0, set.indexOf(ZERO));\n         assertEquals(1, set.indexOf(ONE));\n         assertEquals(2, set.indexOf(TWO));\n-        \n+\n         set.remove(1);\n         assertEquals(2, set.size());\n         assertSame(ZERO, set.get(0));\n         assertEquals(2, view.size());\n         assertSame(ZERO, view.get(0));\n         assertSame(TWO, view.get(1));\n-    }        \n-    \n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testListAddIndexed() {\n-        ListOrderedSet set = (ListOrderedSet) makeEmptySet();\n-        List view = set.asList();\n-        set.add(ZERO);\n-        set.add(TWO);\n-        \n-        set.add(1, ONE);\n+        ListOrderedSet<E> set = makeObject();\n+        set.add((E) ZERO);\n+        set.add((E) TWO);\n+\n+        set.add(1, (E) ONE);\n         assertEquals(3, set.size());\n         assertSame(ZERO, set.get(0));\n         assertSame(ONE, set.get(1));\n         assertSame(TWO, set.get(2));\n-        \n-        set.add(0, ONE);\n+\n+        set.add(0, (E) ONE);\n         assertEquals(3, set.size());\n         assertSame(ZERO, set.get(0));\n         assertSame(ONE, set.get(1));\n         assertSame(TWO, set.get(2));\n-        \n-        List list = new ArrayList();\n-        list.add(ZERO);\n-        list.add(TWO);\n-        \n+\n+        List<E> list = new ArrayList<E>();\n+        list.add((E) ZERO);\n+        list.add((E) TWO);\n+\n         set.addAll(0, list);\n         assertEquals(3, set.size());\n         assertSame(ZERO, set.get(0));\n         assertSame(ONE, set.get(1));\n         assertSame(TWO, set.get(2));\n-        \n-        list.add(0, THREE); // list = [3,0,2]\n+\n+        list.add(0, (E) THREE); // list = [3,0,2]\n         set.remove(TWO);    //  set = [0,1]\n         set.addAll(1, list);\n         assertEquals(4, set.size());\n         assertSame(TWO, set.get(2));\n         assertSame(ONE, set.get(3));\n     }\n-    \n+\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }\n--- a/src/test/org/apache/commons/collections/set/TestMapBackedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestMapBackedSet.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestMapBackedSet extends AbstractTestSet {\n+public class TestMapBackedSet<E> extends AbstractTestSet<E> {\n \n     public TestMapBackedSet(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Set makeEmptySet() {\n-        return MapBackedSet.decorate(new HashedMap());\n+    public Set<E> makeObject() {\n+        return MapBackedSet.decorate(new HashedMap<E, Object>());\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/set/TestMapBackedSet2.java\n+++ b/src/test/org/apache/commons/collections/set/TestMapBackedSet2.java\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestMapBackedSet2 extends AbstractTestSet {\n+public class TestMapBackedSet2<E> extends AbstractTestSet<E> {\n \n     public TestMapBackedSet2(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Set makeEmptySet() {\n-        return MapBackedSet.decorate(new LinkedMap());\n+    public Set<E> makeObject() {\n+        return MapBackedSet.decorate(new LinkedMap<E, Object>());\n     }\n \n-    protected Set setupSet() {\n-        Set set = makeEmptySet();\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> setupSet() {\n+        Set<E> set = makeObject();\n \n         for (int i = 0; i < 10; i++) {\n-            set.add(Integer.toString(i));\n+            set.add((E) Integer.toString(i));\n         }\n         return set;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testOrdering() {\n-        Set set = setupSet();\n-        Iterator it = set.iterator();\n+        Set<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n \n         for (int i = 0; i < 10; i++) {\n             assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n         }\n \n         for (int i = 0; i < 10; i++) {\n-            set.add(Integer.toString(i));\n+            set.add((E) Integer.toString(i));\n         }\n \n         assertEquals(\"Size of set is wrong!\", 10, set.size());\n--- a/src/test/org/apache/commons/collections/set/TestSynchronizedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestSynchronizedSet.java\n import org.apache.commons.collections.BulkTest;\n \n /**\n- * Extension of {@link AbstractTestSet} for exercising the \n+ * Extension of {@link AbstractTestSet} for exercising the\n  * {@link SynchronizedSet} implementation.\n  *\n  * @since Commons Collections 3.1\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestSynchronizedSet extends AbstractTestSet{\n-    \n+public class TestSynchronizedSet<E> extends AbstractTestSet<E> {\n+\n     public TestSynchronizedSet(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestSynchronizedSet.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestSynchronizedSet.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n-   //-------------------------------------------------------------------      \n-    public Set makeEmptySet() {\n-        return SynchronizedSet.decorate(new HashSet());\n+\n+   //-------------------------------------------------------------------\n+    public Set<E> makeObject() {\n+        return SynchronizedSet.decorate(new HashSet<E>());\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/set/TestSynchronizedSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestSynchronizedSortedSet.java\n  */\n package org.apache.commons.collections.set;\n \n-import java.util.Set;\n+import java.util.SortedSet;\n import java.util.TreeSet;\n \n import junit.framework.Test;\n import org.apache.commons.collections.BulkTest;\n \n /**\n- * Extension of {@link AbstractTestSet} for exercising the \n+ * Extension of {@link AbstractTestSet} for exercising the\n  * {@link SynchronizedSortedSet} implementation.\n  *\n  * @since Commons Collections 3.1\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestSynchronizedSortedSet extends AbstractTestSortedSet{\n-    \n+public class TestSynchronizedSortedSet<E> extends AbstractTestSortedSet<E> {\n+\n     public TestSynchronizedSortedSet(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestSynchronizedSortedSet.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestSynchronizedSortedSet.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n-   //-------------------------------------------------------------------      \n-    public Set makeEmptySet() {\n-        return SynchronizedSortedSet.decorate(new TreeSet());\n+\n+   //-------------------------------------------------------------------\n+    public SortedSet<E> makeObject() {\n+        return SynchronizedSortedSet.decorate(new TreeSet<E>());\n     }\n \n     public String getCompatibilityVersion() {\n--- a/src/test/org/apache/commons/collections/set/TestTransformedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestTransformedSet.java\n package org.apache.commons.collections.set;\n \n import java.util.Arrays;\n-import java.util.Collection;\n import java.util.HashSet;\n import java.util.Set;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n /**\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedSet extends AbstractTestSet {\n-    \n+public class TestTransformedSet<E> extends AbstractTestSet<E> {\n+\n     public TestTransformedSet(String testName) {\n         super(testName);\n     }\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Collection makeConfirmedCollection() {\n-        return new HashSet();\n+    public Set<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n     }\n \n-    public Collection makeConfirmedFullCollection() {\n-        Set set = new HashSet();\n+    public Set<E> makeConfirmedFullCollection() {\n+        Set<E> set = new HashSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return set;\n     }\n-    \n-    public Set makeEmptySet() {\n-        return TransformedSet.decorate(new HashSet(), TestTransformedCollection.NOOP_TRANSFORMER);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> makeObject() {\n+        return TransformedSet.decorate(new HashSet<E>(),\n+                (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n-    public Set makeFullSet() {\n-        Set list = new HashSet();\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> makeFullCollection() {\n+        Set<E> list = new HashSet<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return TransformedSet.decorate(list, TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSet.decorate(list,\n+                (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n-        Set set = TransformedSet.decorate(new HashSet(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Set<E> set = TransformedSet.decorate(new HashSet<E>(),\n+                (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             set.add(els[i]);\n             assertEquals(i + 1, set.size());\n             assertEquals(true, set.contains(new Integer((String) els[i])));\n             assertEquals(false, set.contains(els[i]));\n         }\n-        \n+\n         assertEquals(false, set.remove(els[0]));\n         assertEquals(true, set.remove(new Integer((String) els[0])));\n-        \n+\n     }\n \n     public void testTransformedSet_decorateTransform() {\n--- a/src/test/org/apache/commons/collections/set/TestTransformedSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestTransformedSortedSet.java\n import junit.framework.Test;\n \n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n /**\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestTransformedSortedSet extends AbstractTestSortedSet {\n-    \n+public class TestTransformedSortedSet<E> extends AbstractTestSortedSet<E> {\n+\n     public TestTransformedSortedSet(String testName) {\n         super(testName);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    public Set makeEmptySet() {\n-        return TransformedSortedSet.decorate(new TreeSet(), TestTransformedCollection.NOOP_TRANSFORMER);\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedSet<E> makeObject() {\n+        return TransformedSortedSet.decorate(new TreeSet<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n-    public Set makeFullSet() {\n-        SortedSet set = new TreeSet();\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedSet<E> makeFullCollection() {\n+        SortedSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return TransformedSortedSet.decorate(set, TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedSet.decorate(set, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n-    \n-    //-----------------------------------------------------------------------   \n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n-        Set set = TransformedSortedSet.decorate(new TreeSet(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        SortedSet<E> set = TransformedSortedSet.decorate(new TreeSet<E>(),\n+                (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             set.add(els[i]);\n             assertEquals(i + 1, set.size());\n             assertEquals(true, set.contains(new Integer((String) els[i])));\n         }\n-        \n+\n         assertEquals(true, set.remove(new Integer((String) els[0])));\n-        \n-    } \n+    }\n \n     public void testTransformedSet_decorateTransform() {\n         Set originalSet = new TreeSet();\n--- a/src/test/org/apache/commons/collections/set/TestUnmodifiableSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestUnmodifiableSet.java\n import org.apache.commons.collections.BulkTest;\n \n /**\n- * Extension of {@link AbstractTestSet} for exercising the \n+ * Extension of {@link AbstractTestSet} for exercising the\n  * {@link UnmodifiableSet} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestUnmodifiableSet extends AbstractTestSet{\n-    \n+public class TestUnmodifiableSet<E> extends AbstractTestSet<E> {\n+\n     public TestUnmodifiableSet(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestUnmodifiableSet.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableSet.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n-    //-------------------------------------------------------------------  \n-    public Set makeEmptySet() {\n-        return UnmodifiableSet.decorate(new HashSet());\n+\n+    //-------------------------------------------------------------------\n+    public Set<E> makeObject() {\n+        return UnmodifiableSet.decorate(new HashSet<E>());\n     }\n-    \n-    public Set makeFullSet() {\n-        HashSet set = new HashSet();\n+\n+    public Set<E> makeFullCollection() {\n+        HashSet<E> set = new HashSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return UnmodifiableSet.decorate(set);\n     }\n-    \n+\n     public boolean isAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n--- a/src/test/org/apache/commons/collections/set/TestUnmodifiableSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestUnmodifiableSortedSet.java\n import java.util.Arrays;\n import java.util.Comparator;\n import java.util.Set;\n+import java.util.SortedSet;\n import java.util.TreeSet;\n \n import junit.framework.Test;\n import org.apache.commons.collections.BulkTest;\n \n /**\n- * Extension of {@link AbstractTestSortedSet} for exercising the \n+ * Extension of {@link AbstractTestSortedSet} for exercising the\n  * {@link UnmodifiableSortedSet} implementation.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Phil Steitz\n  */\n-public class TestUnmodifiableSortedSet extends AbstractTestSortedSet{\n-    \n+public class TestUnmodifiableSortedSet<E> extends AbstractTestSortedSet<E> {\n+    protected UnmodifiableSortedSet<E> set = null;\n+    protected ArrayList<E> array = null;\n+\n     public TestUnmodifiableSortedSet(String testName) {\n         super(testName);\n     }\n-    \n+\n     public static Test suite() {\n         return BulkTest.makeSuite(TestUnmodifiableSortedSet.class);\n     }\n-    \n+\n     public static void main(String args[]) {\n         String[] testCaseName = { TestUnmodifiableSortedSet.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n-    \n-    //-------------------------------------------------------------------  \n-    public Set makeEmptySet() {\n-        return UnmodifiableSortedSet.decorate(new TreeSet());\n+\n+    //-------------------------------------------------------------------\n+    public SortedSet<E> makeObject() {\n+        return UnmodifiableSortedSet.decorate(new TreeSet<E>());\n     }\n-    \n-    public Set makeFullSet() {\n-        TreeSet set = new TreeSet();\n+\n+    public UnmodifiableSortedSet<E> makeFullCollection() {\n+        TreeSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return UnmodifiableSortedSet.decorate(set);\n+        return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.decorate(set);\n     }\n-    \n+\n     public boolean isAddSupported() {\n         return false;\n     }\n-    \n+\n     public boolean isRemoveSupported() {\n         return false;\n     }\n-           \n+\n     //--------------------------------------------------------------------\n-    protected UnmodifiableSortedSet set = null;\n-    protected ArrayList array = null;\n-    \n+    @SuppressWarnings(\"unchecked\")\n     protected void setupSet() {\n-        set = (UnmodifiableSortedSet) makeFullSet();\n-        array = new ArrayList();\n-        array.add(new Integer(1));\n+        set = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) new Integer(1));\n     }\n-    \n-    /** \n+\n+    /**\n      * Verify that base set and subsets are not modifiable\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public void testUnmodifiable() {\n         setupSet();\n         verifyUnmodifiable(set);\n-        verifyUnmodifiable(set.headSet(new Integer(1)));\n-        verifyUnmodifiable(set.tailSet(new Integer(1)));\n-        verifyUnmodifiable(set.subSet(new Integer(1), new Integer(3)));    \n+        verifyUnmodifiable(set.headSet((E) new Integer(1)));\n+        verifyUnmodifiable(set.tailSet((E) new Integer(1)));\n+        verifyUnmodifiable(set.subSet((E) new Integer(1), (E) new Integer(3)));\n     }\n-    \n+\n     /**\n      * Verifies that a set is not modifiable\n      */\n-    public void verifyUnmodifiable(Set set) {\n+    @SuppressWarnings(\"unchecked\")\n+    public void verifyUnmodifiable(Set<E> set) {\n         try {\n-            set.add(\"value\");\n+            set.add((E) \"value\");\n             fail(\"Expecting UnsupportedOperationException.\");\n         } catch (UnsupportedOperationException e) {\n-            // expected  \n+            // expected\n         }\n         try {\n-            set.addAll(new TreeSet());\n+            set.addAll(new TreeSet<E>());\n             fail(\"Expecting UnsupportedOperationException.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n             // expected\n         }\n     }\n-    \n+\n     public void testComparator() {\n         setupSet();\n-        Comparator c = set.comparator();\n+        Comparator<? super E> c = set.comparator();\n         assertTrue(\"natural order, so comparator should be null\", c == null);\n     }\n ", "timestamp": 1252992596, "metainfo": ""}