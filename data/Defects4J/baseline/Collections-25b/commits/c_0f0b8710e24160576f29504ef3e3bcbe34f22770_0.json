{"sha": "0f0b8710e24160576f29504ef3e3bcbe34f22770", "log": "[COLLECTIONS-424] CompositeSet: remove inheritance from CompositeCollection, update mutator class and unit tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/collection/CompositeCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/CompositeCollection.java\n      * @param compositeCollection1  the Collection to be appended to the composite\n      * @param compositeCollection2  the Collection to be appended to the composite\n      */\n-    public CompositeCollection(final Collection<E> compositeCollection1, final Collection<E> compositeCollection2) {\n+    public CompositeCollection(final Collection<E> compositeCollection1,\n+                               final Collection<E> compositeCollection2) {\n         super();\n         addComposited(compositeCollection1, compositeCollection2);\n     }\n         addComposited(compositeCollections);\n     }\n \n-//    /**\n-//     * Create a Composite Collection extracting the collections from an iterable.\n-//     *\n-//     * @param compositeCollections  the collections to composite\n-//     */\n-//    public CompositeCollection(Iterable<Collection<E>> compositeCollections) {\n-//        super();\n-//        addComposited(compositeCollections);\n-//    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the size of this composite collection.\n      * @return true if all of the contained collections are empty\n      */\n     public boolean isEmpty() {\n-        for (final Collection<? extends E> item : all) {\n+        for (final Collection<E> item : all) {\n             if (item.isEmpty() == false) {\n                 return false;\n             }\n      * @return true if obj is contained in any of the contained collections\n      */\n     public boolean contains(final Object obj) {\n-        for (final Collection<? extends E> item : all) {\n+        for (final Collection<E> item : all) {\n             if (item.contains(obj)) {\n                 return true;\n             }\n             return EmptyIterator.<E>emptyIterator();\n         }\n         final IteratorChain<E> chain = new IteratorChain<E>();\n-        for (final Collection<? extends E> item : all) {\n+        for (final Collection<E> item : all) {\n             chain.addIterator(item.iterator());\n         }\n         return chain;\n         }\n \n         int offset = 0;\n-        for (final Collection<? extends E> item : all) {\n+        for (final Collection<E> item : all) {\n             for (final E e : item) {\n                 result[offset++] = e;\n             }\n             return false;\n         }\n         boolean changed = false;\n-        for (final Collection<? extends E> item : all) {\n+        for (final Collection<E> item : all) {\n             changed |= item.removeAll(coll);\n         }\n         return changed;\n      */\n     public boolean retainAll(final Collection<?> coll) {\n         boolean changed = false;\n-        for (final Collection<? extends E> item : all) {\n+        for (final Collection<E> item : all) {\n             changed |= item.retainAll(coll);\n         }\n         return changed;\n      * @throws UnsupportedOperationException if clear is unsupported\n      */\n     public void clear() {\n-        for (final Collection<? extends E> coll : all) {\n+        for (final Collection<E> coll : all) {\n             coll.clear();\n         }\n     }\n      * @param compositeCollection1  the Collection to be appended to the composite\n      * @param compositeCollection2  the Collection to be appended to the composite\n      */\n-    public void addComposited(final Collection<E> compositeCollection1, final Collection<E> compositeCollection2) {\n+    public void addComposited(final Collection<E> compositeCollection1,\n+                              final Collection<E> compositeCollection2) {\n         all.add(compositeCollection1);\n         all.add(compositeCollection2);\n     }\n         all.addAll(Arrays.asList(compositeCollections));\n     }\n \n-//    /**\n-//     * Add these Collections to the list of collections in this composite\n-//     *\n-//     * @param compositeCollections  the Collections to be appended to the composite\n-//     */\n-//    public void addComposited(Iterable<Collection<E>> compositeCollections) {\n-//        for (Collection<E> item : compositeCollections) {\n-//            all.add(item);\n-//        }\n-//    }\n-\n     /**\n      * Removes a collection from the those being decorated in this composite.\n      *\n      *\n      * @return Unmodifiable list of all collections in this composite.\n      */\n-    public List<? extends Collection<E>> getCollections() {\n+    public List<Collection<E>> getCollections() {\n         return UnmodifiableList.unmodifiableList(all);\n     }\n \n          * @throws NullPointerException if the object cannot be removed because its null\n          * @throws IllegalArgumentException if the object cannot be removed\n          */\n-        public boolean remove(CompositeCollection<E> composite, List<Collection<E>> collections, Object obj);\n+        public boolean remove(CompositeCollection<E> composite,\n+                              List<Collection<E>> collections,\n+                              Object obj);\n \n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/CompositeSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/CompositeSet.java\n  */\n package org.apache.commons.collections.set;\n \n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n import org.apache.commons.collections.CollectionUtils;\n-import org.apache.commons.collections.collection.CompositeCollection;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n  * Decorates a set of other sets to provide a single unified view.\n  * Changes made to this set will actually be made on the decorated set.\n  * Add operations require the use of a pluggable strategy.\n  * If no strategy is provided then add is unsupported.\n- *\n+ * <p>\n+ * From version 4.0, this class does not extend {@link CompositeCollection}\n+ * anymore due to its input restrictions (only accepts Sets).\n+ * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-424\">COLLECTIONS-424</a>\n+ * for more details.\n+ * \n  * @since 3.0\n  * @version $Id$\n  */\n-public class CompositeSet<E> extends CompositeCollection<E> implements Set<E> {\n+public class CompositeSet<E> implements Set<E>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 5185069727540378940L;\n \n-    /**\n-     * Create an empty CompositeSet\n+    /** SetMutator to handle changes to the collection */\n+    protected SetMutator<E> mutator;\n+\n+    /** Sets in the composite */\n+    protected List<Set<E>> all = new ArrayList<Set<E>>();\n+\n+    /**\n+     * Create an empty CompositeSet.\n      */\n     public CompositeSet() {\n         super();\n      * @param set  the initial set in the composite\n      */\n     public CompositeSet(final Set<E> set) {\n-        super(set);\n+        super();\n+        addComposited(set);\n     }\n \n     /**\n      * @param sets  the initial sets in the composite\n      */\n     public CompositeSet(final Set<E>... sets) {\n-        super(sets);\n-    }\n-\n-    /**\n-     * Add a Set to this composite\n-     *\n-     * @param c Must implement Set\n-     * @throws IllegalArgumentException if c does not implement java.util.Set\n-     *         or if a SetMutator is set, but fails to resolve a collision\n-     * @throws UnsupportedOperationException if there is no SetMutator set, or\n-     *         a CollectionMutator is set instead of a SetMutator\n-     * @see org.apache.commons.collections.collection.CompositeCollection.CollectionMutator\n+        super();\n+        addComposited(sets);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of this composite set.\n+     * <p>\n+     * This implementation calls <code>size()</code> on each set.\n+     *\n+     * @return total number of elements in all contained containers\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (final Set<E> item : all) {\n+            size += item.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether this composite set is empty.\n+     * <p>\n+     * This implementation calls <code>isEmpty()</code> on each set.\n+     *\n+     * @return true if all of the contained sets are empty\n+     */\n+    public boolean isEmpty() {\n+        for (final Set<E> item : all) {\n+            if (item.isEmpty() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this composite set contains the object.\n+     * <p>\n+     * This implementation calls <code>contains()</code> on each set.\n+     *\n+     * @param obj  the object to search for\n+     * @return true if obj is contained in any of the contained sets\n+     */\n+    public boolean contains(final Object obj) {\n+        for (final Set<E> item : all) {\n+            if (item.contains(obj)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets an iterator over all the sets in this composite.\n+     * <p>\n+     * This implementation uses an <code>IteratorChain</code>.\n+     *\n+     * @return an <code>IteratorChain</code> instance which supports\n+     *  <code>remove()</code>. Iteration occurs over contained collections in\n+     *  the order they were added, but this behavior should not be relied upon.\n+     * @see IteratorChain\n+     */\n+    public Iterator<E> iterator() {\n+        if (all.isEmpty()) {\n+            return EmptyIterator.<E>emptyIterator();\n+        }\n+        final IteratorChain<E> chain = new IteratorChain<E>();\n+        for (final Set<E> item : all) {\n+            chain.addIterator(item.iterator());\n+        }\n+        return chain;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this composite.\n+     *\n+     * @return an object array of all the elements in the collection\n+     */\n+    public Object[] toArray() {\n+        final Object[] result = new Object[size()];\n+        int i = 0;\n+        for (final Iterator<E> it = iterator(); it.hasNext(); i++) {\n+            result[i] = it.next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an object array, populating the supplied array if possible.\n+     * See <code>Collection</code> interface for full details.\n+     *\n+     * @param <T>  the type of the elements in the collection\n+     * @param array  the array to use, populating if possible\n+     * @return an array of all the elements in the collection\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(final T[] array) {\n+        final int size = size();\n+        Object[] result = null;\n+        if (array.length >= size) {\n+            result = array;\n+        } else {\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n+        }\n+\n+        int offset = 0;\n+        for (final Collection<E> item : all) {\n+            for (final E e : item) {\n+                result[offset++] = e;\n+            }\n+        }\n+        if (result.length > size) {\n+            result[size] = null;\n+        }\n+        return (T[]) result;\n+    }\n+\n+    /**\n+     * Adds an object to the collection, throwing UnsupportedOperationException\n+     * unless a SetMutator strategy is specified.\n+     *\n+     * @param obj  the object to add\n+     * @return {@code true} if the collection was modified\n+     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean add(final E obj) {\n+        if (mutator == null) {\n+           throw new UnsupportedOperationException(\n+               \"add() is not supported on CompositeSet without a SetMutator strategy\");\n+        }\n+        return mutator.add(this, all, obj);\n+    }\n+\n+    /**\n+     * If a <code>CollectionMutator</code> is defined for this CompositeSet then this\n+     * method will be called anyway.\n+     *\n+     * @param obj  object to be removed\n+     * @return true if the object is removed, false otherwise\n+     */\n+    public boolean remove(final Object obj) {\n+        for (final Set<E> set : getSets()) {\n+            if (set.contains(obj)) {\n+                return set.remove(obj);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether this composite contains all the elements in the specified collection.\n+     * <p>\n+     * This implementation calls <code>contains()</code> for each element in the\n+     * specified collection.\n+     *\n+     * @param coll  the collection to check for\n+     * @return true if all elements contained\n+     */\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object item : coll) {\n+            if (contains(item) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Adds a collection of elements to this composite, throwing\n+     * UnsupportedOperationException unless a SetMutator strategy is specified.\n+     *\n+     * @param coll  the collection to add\n+     * @return true if the composite was modified\n+     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        if (mutator == null) {\n+            throw new UnsupportedOperationException(\n+                \"addAll() is not supported on CompositeSet without a SetMutator strategy\");\n+        }\n+        return mutator.addAll(this, all, coll);\n+    }\n+\n+    /**\n+     * Removes the elements in the specified collection from this composite set.\n+     * <p>\n+     * This implementation calls <code>removeAll</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the composite was modified\n+     * @throws UnsupportedOperationException if removeAll is unsupported\n+     */\n+    public boolean removeAll(final Collection<?> coll) {\n+        if (coll.size() == 0) {\n+            return false;\n+        }\n+        boolean changed = false;\n+        for (final Collection<E> item : all) {\n+            changed |= item.removeAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Retains all the elements in the specified collection in this composite set,\n+     * removing all others.\n+     * <p>\n+     * This implementation calls <code>retainAll()</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the composite was modified\n+     * @throws UnsupportedOperationException if retainAll is unsupported\n+     */\n+    public boolean retainAll(final Collection<?> coll) {\n+        boolean changed = false;\n+        for (final Collection<E> item : all) {\n+            changed |= item.retainAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Removes all of the elements from this composite set.\n+     * <p>\n+     * This implementation calls <code>clear()</code> on each set.\n+     *\n+     * @throws UnsupportedOperationException if clear is unsupported\n+     */\n+    public void clear() {\n+        for (final Collection<E> coll : all) {\n+            coll.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify a SetMutator strategy instance to handle changes.\n+     *\n+     * @param mutator  the mutator to use\n+     */\n+    public void setMutator(final SetMutator<E> mutator) {\n+        this.mutator = mutator;\n+    }\n+\n+    /**\n+     * Add a Set to this composite.\n+     *\n+     * @param set  the set to add\n+     * @throws IllegalArgumentException if a SetMutator is set, but fails to resolve a collision\n+     * @throws UnsupportedOperationException if there is no SetMutator set\n      * @see SetMutator\n      */\n-    @Override\n-    public synchronized void addComposited(final Collection<E> c) {\n-        if (!(c instanceof Set)) {\n-            throw new IllegalArgumentException(\"Collections added must implement java.util.Set\");\n-        }\n-\n-        for (final Set<E> set : getCollections()) {\n-            final Collection<E> intersects = CollectionUtils.intersection(set, c);\n+    public synchronized void addComposited(final Set<E> set) {\n+        for (final Set<E> existingSet : getSets()) {\n+            final Collection<E> intersects = CollectionUtils.intersection(existingSet, set);\n             if (intersects.size() > 0) {\n                 if (this.mutator == null) {\n                     throw new UnsupportedOperationException(\n-                        \"Collision adding composited collection with no SetMutator set\");\n+                        \"Collision adding composited set with no SetMutator set\");\n                 }\n-                else if (!(this.mutator instanceof SetMutator)) {\n-                    throw new UnsupportedOperationException(\n-                        \"Collision adding composited collection to a CompositeSet with a CollectionMutator \" +\n-                        \"instead of a SetMutator\");\n-                }\n-                getMutator().resolveCollision(this, set, (Set<E>) c, intersects);\n-                if (CollectionUtils.intersection(set, c).size() > 0) {\n+                getMutator().resolveCollision(this, existingSet, set, intersects);\n+                if (CollectionUtils.intersection(existingSet, set).size() > 0) {\n                     throw new IllegalArgumentException(\n                         \"Attempt to add illegal entry unresolved by SetMutator.resolveCollision()\");\n                 }\n             }\n         }\n-        super.addComposited(c);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public List<? extends Set<E>> getCollections() {\n-        return (List<Set<E>>) super.getCollections();\n-    }\n-\n-    /**\n-     * Add two sets to this composite.\n-     *\n-     * @param c  the first {@link java.util.Set} to add to this composite\n-     * @param d  the second {@link java.util.Set} to add to this composite\n-     * @throws IllegalArgumentException if c or d does not implement {@link java.util.Set}\n-     */\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public synchronized void addComposited(final Collection<E> c, final Collection<E> d) {\n-        if (!(c instanceof Set)) {\n-            throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n-        }\n-        if (!(d instanceof Set)) {\n-            throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n-        }\n-        this.addComposited(new Set[] { (Set<? extends E>) c, (Set<? extends E>) d });\n-    }\n-\n-    /**\n-     * Add an array of sets to this composite\n-     * @param comps  the {@link Collection} of {@link java.util.Set}s to add to this composite\n-     * @throws IllegalArgumentException if any of the collections in comps does not implement {@link java.util.Set}\n-     */\n-    @Override\n-    public synchronized void addComposited(final Collection<E>[] comps) {\n-        for (int i = comps.length - 1; i >= 0; --i) {\n-            this.addComposited(comps[i]);\n-        }\n-    }\n-\n-    /**\n-     * This can receive either a\n-     * {@link org.apache.commons.collections.collection.CompositeCollection.CollectionMutator CollectionMutator}\n-     * or a {@link CompositeSet.SetMutator}. \n-     * If a {@link org.apache.commons.collections.collection.CompositeCollection.CollectionMutator CollectionMutator}\n-     * is used than conflicts when adding composited sets will throw IllegalArgumentException.\n-     * \n-     * @param mutator\n-     *   the {@link org.apache.commons.collections.collection.CompositeCollection.CollectionMutator CollectionMutator}\n-     * to use for this composite\n-     */\n-    @Override\n-    public void setMutator(final CollectionMutator<E> mutator) {\n-        super.setMutator(mutator);\n-    }\n-\n-    /* Set operations */\n-\n-    /**\n-     * If a <code>CollectionMutator</code> is defined for this CompositeSet then this\n-     * method will be called anyway.\n-     *\n-     * @param obj  object to be removed\n-     * @return true if the object is removed, false otherwise\n-     */\n-    @Override\n-    public boolean remove(final Object obj) {\n-        for (final Set<? extends E> set : getCollections()) {\n-            if (set.contains(obj)) {\n-                return set.remove(obj);\n-            }\n-        }\n-        return false;\n+        all.add(set);\n+    }\n+\n+    /**\n+     * Add these Sets to the list of sets in this composite.\n+     *\n+     * @param set1  the first Set to be appended to the composite\n+     * @param set2  the second Set to be appended to the composite\n+     */\n+    public void addComposited(final Set<E> set1, final Set<E> set2) {\n+        all.add(set1);\n+        all.add(set2);\n+    }\n+\n+    /**\n+     * Add these Sets to the list of sets in this composite\n+     *\n+     * @param sets  the Sets to be appended to the composite\n+     */\n+    public void addComposited(final Set<E>[] sets) {\n+        all.addAll(Arrays.asList(sets));\n+    }\n+\n+    /**\n+     * Removes a set from those being decorated in this composite.\n+     *\n+     * @param set  set to be removed\n+     */\n+    public void removeComposited(final Set<E> set) {\n+        all.remove(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new Set containing all of the elements.\n+     *\n+     * @return A new HashSet containing all of the elements in this composite.\n+     *   The new collection is <i>not</i> backed by this composite.\n+     */\n+    public Set<E> toSet() {\n+        return new HashSet<E>(this);\n+    }\n+\n+    /**\n+     * Gets the sets being decorated.\n+     *\n+     * @return Unmodifiable list of all sets in this composite.\n+     */\n+    public List<Set<E>> getSets() {\n+        return UnmodifiableList.unmodifiableList(all);\n+    }\n+\n+    /**\n+     * Get the set mutator to be used for this CompositeSet.\n+     * @return the set mutator\n+     */\n+    protected SetMutator<E> getMutator() {\n+        return mutator;\n     }\n \n     /**\n     public boolean equals(final Object obj) {\n         if (obj instanceof Set) {\n             final Set<?> set = (Set<?>) obj;\n-            return set.containsAll(this) && set.size() == this.size();\n+            return set.size() == this.size() && set.containsAll(this);\n         }\n         return false;\n     }\n         return code;\n     }\n \n-    @Override\n-    protected SetMutator<E> getMutator() {\n-        return (SetMutator<E>) super.getMutator();\n-    }\n-\n     /**\n      * Define callbacks for mutation operations.\n-     * <p>\n-     * Defining remove() on implementations of SetMutator is pointless\n-     * as they are never called by CompositeSet.\n-     */\n-    public static interface SetMutator<E> extends CompositeCollection.CollectionMutator<E> {\n+     */\n+    public static interface SetMutator<E> extends Serializable {\n+\n+        /**\n+         * Called when an object is to be added to the composite.\n+         *\n+         * @param composite  the CompositeSet being changed\n+         * @param sets  all of the Set instances in this CompositeSet\n+         * @param obj  the object being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean add(CompositeSet<E> composite, List<Set<E>> sets, E obj);\n+\n+        /**\n+         * Called when a collection is to be added to the composite.\n+         *\n+         * @param composite  the CompositeSet being changed\n+         * @param sets  all of the Set instances in this CompositeSet\n+         * @param coll  the collection being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean addAll(CompositeSet<E> composite,\n+                              List<Set<E>> sets,\n+                              Collection<? extends E> coll);\n \n         /**\n          * Called when a Set is added to the CompositeSet and there is a\n          * @param added  the Set being added to the composite\n          * @param intersects  the intersection of the existing and added sets\n          */\n-        public void resolveCollision(CompositeSet<E> comp, Set<E> existing, Set<E> added, Collection<E> intersects);\n+        public void resolveCollision(CompositeSet<E> comp,\n+                                     Set<E> existing,\n+                                     Set<E> added,\n+                                     Collection<E> intersects);\n     }\n }\n--- a/src/test/java/org/apache/commons/collections/collection/CompositeCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/CompositeCollectionTest.java\n     protected void setUpMutatorTest() {\n         setUpTest();\n         c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n-            public boolean add(final CompositeCollection<E> composite,\n-                    final List<Collection<E>> collections, final E obj) {\n-                for (final Collection<E> collection : collections) {\n-                    collection.add(obj);\n+            \n+            public boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj) {\n+                for (final Collection<E> coll : collections) {\n+                    coll.add(obj);\n                 }\n                 return true;\n             }\n--- a/src/test/java/org/apache/commons/collections/set/CompositeSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/CompositeSetTest.java\n import java.util.List;\n import java.util.Set;\n \n-import org.apache.commons.collections.collection.CompositeCollection;\n+import org.apache.commons.collections.set.CompositeSet.SetMutator;\n \n /**\n  * Extension of {@link AbstractSetTest} for exercising the\n         final Set<E> one = buildOne();\n         final Set<E> two = buildTwo();\n         final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n-        set.setMutator(new CompositeSet.SetMutator<E>() {\n+        set.setMutator(new SetMutator<E>() {\n             private static final long serialVersionUID = 1L;\n \n             public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing,\n                 //noop\n             }\n \n-            public boolean add(final CompositeCollection<E> composite,\n-                    final List<Collection<E>> collections, final E obj) {\n+            public boolean add(final CompositeSet<E> composite,\n+                    final List<Set<E>> collections, final E obj) {\n                 throw new UnsupportedOperationException();\n             }\n \n-            public boolean addAll(final CompositeCollection<E> composite,\n-                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            public boolean remove(final CompositeCollection<E> composite,\n-                    final List<Collection<E>> collections, final Object obj) {\n+            public boolean addAll(final CompositeSet<E> composite,\n+                    final List<Set<E>> collections, final Collection<? extends E> coll) {\n                 throw new UnsupportedOperationException();\n             }\n         });\n--- a/src/test/java/org/apache/commons/collections/set/EmptySetMutator.java\n+++ b/src/test/java/org/apache/commons/collections/set/EmptySetMutator.java\n import java.util.List;\n import java.util.Set;\n \n-import org.apache.commons.collections.collection.CompositeCollection;\n-\n /**\n  * This class is used in CompositeSetTest. When testing serialization, \n  * the class has to be separate of CompositeSetTest, else the test \n         throw new IllegalArgumentException();\n     }\n     \n-    public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {\n+    public boolean add(final CompositeSet<E> composite, final List<Set<E>> collections, final E obj) {\n         return contained.add(obj);\n     }\n     \n-    public boolean addAll(final CompositeCollection<E> composite, final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+    public boolean addAll(final CompositeSet<E> composite, final List<Set<E>> collections, final Collection<? extends E> coll) {\n         return contained.addAll(coll);\n-    }\n-    \n-    public boolean remove(final CompositeCollection<E> composite, final List<Collection<E>> collections, final Object obj) {\n-        return contained.remove(obj);\n-    }\n+    }    \n }", "timestamp": 1363514469, "metainfo": ""}