{"sha": "b979fd11e1753823021b9d718398167497415b47", "log": "Remove trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public int size() {\n         return size;\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public Iterator<E> iterator() {\n         return listIterator();\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public int indexOf(final Object value) {\n         int i = 0;\n         for (Node<E> node = header.next; node != header; node = node.next) {\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public Object[] toArray() {\n         return toArray(new Object[size]);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public boolean add(final E value) {\n         addLast(value);\n         return true;\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E remove(final int index) {\n         final Node<E> node = getNode(index, false);\n         final E oldValue = node.getValue();\n \n     /**\n      * {@inheritDoc}\n-     * <p> \n+     * <p>\n      * This implementation iterates over the elements of this list, checking each element in\n      * turn to see if it's contained in <code>coll</code>. If it's contained, it's removed\n      * from this list. As a consequence, it is advised to use a collection type for\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     /**\n      * {@inheritDoc}\n-     * <p> \n+     * <p>\n      * This implementation iterates over the elements of this list, checking each element in\n      * turn to see if it's contained in <code>coll</code>. If it's not contained, it's removed\n      * from this list. As a consequence, it is advised to use a collection type for\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E getFirst() {\n         final Node<E> node = header.next;\n         if (node == header) {\n      * <p>\n      * The first serializable subclass must call this method from\n      * <code>writeObject</code>.\n-     * \n+     *\n      * @param outputStream  the stream to write the object to\n      * @throws IOException  if anything goes wrong\n      */\n      * <p>\n      * The first serializable subclass must call this method from\n      * <code>readObject</code>.\n-     * \n+     *\n      * @param inputStream  the stream to read the object from\n      * @throws IOException  if any error occurs while reading from the stream\n      * @throws ClassNotFoundException  if a class read from the stream can not be loaded\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n \n     /**\n      * Gets the list being decorated.\n-     * \n+     *\n      * @return the decorated list\n      */\n     @Override\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public void add(final int index, final E object) {\n         decorated().add(index, object);\n     }\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java\n     //-----------------------------------------------------------------------\n     /**\n      * Write the list out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n \n     /**\n      * Read the list in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n--- a/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n \n     /**\n      * Constructor that copies the specified collection\n-     * \n+     *\n      * @param coll  the collection to copy\n      */\n     public CursorableLinkedList(final Collection<E> coll) {\n      * If the underlying list is modified while iterating using this iterator\n      * a ConcurrentModificationException will occur.\n      * The cursor behaviour is available via {@link #listIterator()}.\n-     * \n+     *\n      * @return a new iterator that does <b>not</b> support concurrent modification\n      */\n     @Override\n      * or {@link ListIterator#previous}) element of the list is removed,\n      * the cursor automatically adjusts to the change (invalidating the\n      * last returned value such that it cannot be removed).\n-     * \n+     *\n      * @return a new cursor iterator\n      */\n     @Override\n      * or {@link ListIterator#previous}) element of the list is removed,\n      * the cursor automatically adjusts to the change (invalidating the\n      * last returned value such that it cannot be removed).\n-     * \n+     *\n      * @param fromIndex  the index to start from\n      * @return a new cursor iterator\n      */\n      * Updates the node with a new value.\n      * This implementation sets the value on the node.\n      * Subclasses can override this to record the change.\n-     * \n+     *\n      * @param node  node to update\n      * @param value  new value of the node\n      */\n         super.addNode(nodeToInsert, insertBeforeNode);\n         broadcastNodeInserted(nodeToInsert);\n     }\n-    \n+\n     /**\n      * Removes the specified node from the list.\n      *\n     //-----------------------------------------------------------------------\n     /**\n      * Registers a cursor to be notified of changes to this list.\n-     * \n+     *\n      * @param cursor  the cursor to register\n      */\n     protected void registerCursor(final Cursor<E> cursor) {\n \n     /**\n      * Deregisters a cursor from the list to be notified of changes.\n-     * \n+     *\n      * @param cursor  the cursor to deregister\n      */\n     protected void unregisterCursor(final Cursor<E> cursor) {\n             final WeakReference<Cursor<E>> ref = it.next();\n             final Cursor<E> cur = ref.get();\n             if (cur == null) {\n-                // some other unrelated cursor object has been \n+                // some other unrelated cursor object has been\n                 // garbage-collected; let's take the opportunity to\n                 // clean up the cursors list anyway..\n                 it.remove();\n     /**\n      * Informs all of my registered cursors that the specified\n      * element was changed.\n-     * \n+     *\n      * @param node  the node that was changed\n      */\n     protected void broadcastNodeChanged(final Node<E> node) {\n     /**\n      * Informs all of my registered cursors that the specified\n      * element was just removed from my list.\n-     * \n+     *\n      * @param node  the node that was changed\n      */\n     protected void broadcastNodeRemoved(final Node<E> node) {\n     /**\n      * Informs all of my registered cursors that the specified\n      * element was just added to my list.\n-     * \n+     *\n      * @param node  the node that was changed\n      */\n     protected void broadcastNodeInserted(final Node<E> node) {\n     //-----------------------------------------------------------------------\n     /**\n      * Creates a list iterator for the sublist.\n-     * \n+     *\n      * @param subList  the sublist to get an iterator for\n      * @param fromIndex  the index to start from, relative to the sublist\n      * @return the list iterator for the sublist\n         boolean nextIndexValid = true;\n         /** Flag to indicate if the current element was removed by another object. */\n         boolean currentRemovedByAnother = false;\n-        \n+\n         /**\n          * Constructs a new cursor.\n-         * \n+         *\n          * @param parent  the parent list\n          * @param index  the index to start from\n          */\n         /**\n          * Adds an object to the list.\n          * The object added here will be the new 'previous' in the iterator.\n-         * \n+         *\n          * @param obj  the object to add\n          */\n         @Override\n             // thus next gets changed - reset it again here\n             next = next.next;\n         }\n-        \n+\n         // set is not overridden, as it works ok\n         // note that we want it to throw an exception if the element being\n         // set has been removed from the real list (compare this with the\n \n         /**\n          * Gets the index of the next element to be returned.\n-         * \n+         *\n          * @return the next index\n          */\n         @Override\n \n         /**\n          * Handle event from the list when a node has changed.\n-         * \n+         *\n          * @param node  the node that changed\n          */\n         protected void nodeChanged(final Node<E> node) {\n \n         /**\n          * Handle event from the list when a node has been removed.\n-         * \n+         *\n          * @param node  the node that was removed\n          */\n         protected void nodeRemoved(final Node<E> node) {\n \n         /**\n          * Handle event from the list when a node has been added.\n-         * \n+         *\n          * @param node  the node that was added\n          */\n         protected void nodeInserted(final Node<E> node) {\n \n         /**\n          * Constructs a new cursor.\n-         * \n+         *\n          * @param sub  the sub list\n          * @param index  the index to start from\n          */\n--- a/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java\n \n     /**\n      * Factory method to create a fixed size list.\n-     * \n+     *\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @return a new fixed size list\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n--- a/src/main/java/org/apache/commons/collections4/list/LazyList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/LazyList.java\n  *\n  * After the above code is executed, <code>date</code> will contain\n  * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n- * instance is the fourth element in the list.  The first, second, \n+ * instance is the fourth element in the list.  The first, second,\n  * and third element are all set to <code>null</code>.\n  * <p>\n  * This class differs from {@link GrowthList} because here growth occurs on\n \n     /**\n      * Factory method to create a lazily instantiating list.\n-     * \n+     *\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @param factory  the factory to use for creation, must not be null\n     public static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n         return new LazyList<E>(list, factory);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @param factory  the factory to use for creation, must not be null\n      * @throws IllegalArgumentException if list or factory is null\n     /**\n      * Decorate the get method to perform the lazy behaviour.\n      * <p>\n-     * If the requested index is greater than the current size, the list will \n+     * If the requested index is greater than the current size, the list will\n      * grow to the new size and a new object will be returned from the factory.\n-     * Indexes in-between the old size and the requested size are left with a \n+     * Indexes in-between the old size and the requested size are left with a\n      * placeholder that is replaced with a factory object when requested.\n-     * \n+     *\n      * @param index  the index to retrieve\n      * @return the element at the given index\n      */\n--- a/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n      * <code>next</code> pointing to the next element.\n      */\n     private transient Node<E> firstCachedNode;\n-    \n+\n     /**\n      * The size of the cache.\n      */\n \n     /**\n      * Constructor that copies the specified collection\n-     * \n+     *\n      * @param coll  the collection to copy\n      */\n     public NodeCachingLinkedList(final Collection<E> coll) {\n         super(coll);\n         this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n     }\n-    \n+\n     /**\n      * Constructor that species the maximum cache size.\n      *\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the maximum size of the cache.\n-     * \n+     *\n      * @return the maximum cache size\n      */\n     protected int getMaximumCacheSize() {\n \n     /**\n      * Sets the maximum size of the cache.\n-     * \n+     *\n      * @param maximumCacheSize  the new maximum cache size\n      */\n     protected void setMaximumCacheSize(final int maximumCacheSize) {\n             getNodeFromCache();\n         }\n     }\n-    \n+\n     /**\n      * Gets a node from the cache. If a node is returned, then the value of\n      * {@link #cacheSize} is decreased accordingly. The node that is returned\n         final Node<E> cachedNode = firstCachedNode;\n         firstCachedNode = cachedNode.next;\n         cachedNode.next = null; // This should be changed anyway, but defensively\n-                                // set it to null.                    \n+                                // set it to null.\n         cacheSize--;\n         return cachedNode;\n     }\n-    \n+\n     /**\n      * Checks whether the cache is full.\n-     * \n+     *\n      * @return true if the cache is full\n      */\n     protected boolean isCacheFull() {\n         return cacheSize >= maximumCacheSize;\n     }\n-    \n+\n     /**\n      * Adds a node to the cache, if the cache isn't full.\n      * The node's contents are cleared to so they can be garbage collected.\n-     * \n+     *\n      * @param node  the node to add to the cache\n      */\n     protected void addNodeToCache(final Node<E> node) {\n         cacheSize++;\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Creates a new node, either by reusing one from the cache or creating\n      * a new one.\n-     * \n+     *\n      * @param value  value of the new node\n      * @return the newly created node\n      */\n     /**\n      * Removes the node from the list, storing it in the cache for reuse\n      * if the cache is not yet full.\n-     * \n+     *\n      * @param node  the node to remove\n      */\n     @Override\n         super.removeNode(node);\n         addNodeToCache(node);\n     }\n-    \n+\n     /**\n      * Removes all the nodes from the list, storing as many as required in the\n      * cache for reuse.\n-     * \n+     *\n      */\n     @Override\n     protected void removeAllNodes() {\n             node = node.next;\n             addNodeToCache(oldNode);\n         }\n-        super.removeAllNodes();        \n+        super.removeAllNodes();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param <T> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @throws IllegalArgumentException if list or predicate is null\n \n     /**\n      * Gets the list being decorated.\n-     * \n+     *\n      * @return the decorated list\n      */\n     @Override\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E get(final int index) {\n         return decorated().get(index);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public void add(final int index, final E object) {\n         validate(object);\n         decorated().add(index, object);\n      * Inner class Iterator for the PredicatedList\n      */\n     protected class PredicatedListIterator extends AbstractListIteratorDecorator<E> {\n-        \n+\n         /**\n          * Create a new predicated list iterator.\n-         * \n+         *\n          * @param iterator  the list iterator to decorate\n          */\n         protected PredicatedListIterator(final ListIterator<E> iterator) {\n             super(iterator);\n         }\n-        \n+\n         @Override\n         public void add(final E object) {\n             validate(object);\n             getListIterator().add(object);\n         }\n-        \n+\n         @Override\n         public void set(final E object) {\n             validate(object);\n--- a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java\n  * retaining insertion order in the iterator.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n- * \n+ *\n  * @since 3.0\n  * @version $Id$\n  */\n     private final Set<E> set;\n \n     /**\n-     * Factory method to create a SetList using the supplied list to retain\n-     * order.\n+     * Factory method to create a SetList using the supplied list to retain order.\n      * <p>\n      * If the list contains duplicates, these are removed (first indexed one\n      * kept). A <code>HashSet</code> is used for the set behaviour.\n-     * \n+     *\n      * @param <E>\n      *            the element type\n      * @param list\n      * use.\n      * <p>\n      * The set and list must both be correctly initialised to the same elements.\n-     * \n+     *\n      * @param set\n      *            the set to decorate, must not be null\n      * @param list\n     // -----------------------------------------------------------------------\n     /**\n      * Gets an unmodifiable view as a Set.\n-     * \n+     *\n      * @return an unmodifiable set view\n      */\n     public Set<E> asSet() {\n      * <i>(Violation)</i> The <code>List</code> interface requires that this\n      * method returns <code>true</code> always. However this class may return\n      * <code>false</code> because of the <code>Set</code> behaviour.\n-     * \n+     *\n      * @param object\n      *            the object to add\n      * @return true if object was added\n      * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n      * that the element is always inserted. This may not happen with this\n      * implementation.\n-     * \n+     *\n      * @param index\n      *            the index to insert at\n      * @param object\n      * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n      * that the elements are always inserted. This may not happen with this\n      * implementation.\n-     * \n+     *\n      * @param coll\n      *            the collection to add in iterator order\n      * @return true if this collection changed\n      * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n      * that the elements are always inserted. This may not happen with this\n      * implementation.\n-     * \n+     *\n      * @param index\n      *            the index to insert at\n      * @param coll\n      * The object is set into the specified index. Afterwards, any previous\n      * duplicate is removed. If the object is not already in the list then a\n      * normal set occurs. If it is present, then the old version is removed.\n-     * \n+     *\n      * @param index\n      *            the index to insert at\n      * @param object\n      * {@inheritDoc}\n      * <p>\n      * NOTE: from 4.0, an unmodifiable list will be returned, as changes to the\n-     * subList can invalidate the parent list. \n+     * subList can invalidate the parent list.\n      */\n     @Override\n     public List<E> subList(final int fromIndex, final int toIndex) {\n     /**\n      * Create a new {@link Set} with the same type as the provided {@code set}\n      * and populate it with all elements of {@code list}.\n-     * \n+     *\n      * @param set\n      *            the {@link Set} to be used as return type, must not be null\n      * @param list\n--- a/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n      * If there are any elements already in the list being decorated, they\n      * are NOT transformed.\n      * Contrast this with {@link #transformedList(List, Transformer)}.\n-     * \n+     *\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n                                                           final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedList<E>(list, transformer);\n     }\n-    \n+\n     /**\n      * Factory method to create a transforming list that will transform\n      * existing contents of the specified list.\n      * If there are any elements already in the list being decorated, they\n      * will be transformed by this method.\n      * Contrast this with {@link #transformingList(List, Transformer)}.\n-     * \n+     *\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * are NOT transformed.\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if list or transformer is null\n \n     /**\n      * Gets the decorated list.\n-     * \n+     *\n      * @return the decorated list\n      */\n     protected List<E> getList() {\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E get(final int index) {\n         return getList().get(index);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public void add(final int index, E object) {\n         object = transform(object);\n         getList().add(index, object);\n \n         /**\n          * Create a new transformed list iterator.\n-         * \n+         *\n          * @param iterator  the list iterator to decorate\n          */\n         protected TransformedListIterator(final ListIterator<E> iterator) {\n--- a/src/main/java/org/apache/commons/collections4/list/TreeList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TreeList.java\n         if (!coll.isEmpty()) {\n             root = new AVLNode<E>(coll);\n             size = coll.size();\n-        }        \n+        }\n     }\n \n     //-----------------------------------------------------------------------\n          * Appends the elements of another tree list to this tree list by efficiently\n          * merging the two AVL trees. This operation is destructive to both trees and\n          * runs in O(log(m + n)) time.\n-         * \n+         *\n          * @param otherTree\n          *            the root of the AVL tree to merge with this one\n          * @param currentSize\n--- a/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n \n     /**\n      * Factory method to create an unmodifiable list.\n-     * \n+     *\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @return a new unmodifiable list\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      * @since Commons Collection 5", "timestamp": 1367347461, "metainfo": ""}