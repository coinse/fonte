{"sha": "f6d8876a41cbe4d7c32e29509983d1054eebc772", "log": "Fix bug in indexOf, identified by Johal Reformat and Javadoc file   ", "commit": "\n--- a/src/java/org/apache/commons/collections/SequencedHashMap.java\n+++ b/src/java/org/apache/commons/collections/SequencedHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.14 2002/10/12 22:15:19 scolebourne Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/10/12 22:15:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.15 2002/11/24 20:48:35 scolebourne Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2002/11/24 20:48:35 $\n  *\n  * ====================================================================\n  *\n import java.util.Set;\n import java.util.NoSuchElementException;\n import java.util.ConcurrentModificationException;\n-\n /**\n  *  A map of objects whose mapping entries are sequenced based on the order in\n  *  which they were added.  This data structure has fast <I>O(1)</I> search\n  *  required, use {@link Collections#synchronizedMap(Map)} as it is documented,\n  *  or use explicit synchronization controls.\n  *\n- *  @since 2.0\n- *  @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</A>\n+ * @since 2.0\n+ * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</A>\n  * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Stephen Colebourne\n  */\n public class SequencedHashMap implements Map, Cloneable, Externalizable {\n \n-  /**\n-   *  {@link java.util.Map.Entry} that doubles as a node in the linked list\n-   *  of sequenced mappings.  \n-   **/\n-  private static class Entry implements Map.Entry {\n-    // Note: This class cannot easily be made clonable.  While the actual\n-    // implementation of a clone would be simple, defining the semantics is\n-    // difficult.  If a shallow clone is implemented, then entry.next.prev !=\n-    // entry, which is unintuitive and probably breaks all sorts of assumptions\n-    // in code that uses this implementation.  If a deep clone is\n-    // implementated, then what happens when the linked list is cyclical (as is\n-    // the case with SequencedHashMap)?  It's impossible to know in the clone\n-    // when to stop cloning, and thus you end up in a recursive loop,\n-    // continuously cloning the \"next\" in the list.\n-\n-    private final Object key;\n-    private Object value;\n-    \n-    // package private to allow the SequencedHashMap to access and manipulate\n-    // them.\n-    Entry next = null;\n-    Entry prev = null;\n-\n-    public Entry(Object key, Object value) {\n-      this.key = key;\n-      this.value = value;\n-    }\n-\n-    // per Map.Entry.getKey()\n-    public Object getKey() { \n-      return this.key; \n-    }\n-\n-    // per Map.Entry.getValue()\n-    public Object getValue() { \n-      return this.value; \n-    }\n-\n-    // per Map.Entry.setValue()\n-    public Object setValue(Object value) { \n-      Object oldValue = this.value;\n-      this.value = value; \n-      return oldValue;\n-    }\n-\n-    public int hashCode() { \n-      // implemented per api docs for Map.Entry.hashCode()\n-      return ((getKey() == null ? 0 : getKey().hashCode()) ^\n-              (getValue()==null ? 0 : getValue().hashCode())); \n-    }\n-\n-    public boolean equals(Object obj) {\n-      if(obj == null) return false;\n-      if(obj == this) return true;\n-      if(!(obj instanceof Map.Entry)) return false;\n-\n-      Map.Entry other = (Map.Entry)obj;\n-\n-      // implemented per api docs for Map.Entry.equals(Object) \n-      return((getKey() == null ?\n-              other.getKey() == null : \n-              getKey().equals(other.getKey()))  &&\n-             (getValue() == null ?\n-              other.getValue() == null : \n-              getValue().equals(other.getValue())));\n-    }\n-    public String toString() {\n-      return \"[\" + getKey() + \"=\" + getValue() + \"]\";\n-    }\n-  }\n-\n-  /**\n-   *  Construct an empty sentinel used to hold the head (sentinel.next) and the\n-   *  tail (sentinel.prev) of the list.  The sentinal has a <code>null</code>\n-   *  key and value.\n-   **/\n-  private static final Entry createSentinel() {\n-    Entry s = new Entry(null, null);\n-    s.prev = s;\n-    s.next = s;\n-    return s;\n-  }\n-\n-  /**\n-   *  Sentinel used to hold the head and tail of the list of entries.\n-   **/\n-  private Entry sentinel;\n-\n-  /**\n-   *  Map of keys to entries\n-   **/\n-  private HashMap entries;\n-\n-  /**\n-   *  Holds the number of modifications that have occurred to the map,\n-   *  excluding modifications made through a collection view's iterator\n-   *  (e.g. entrySet().iterator().remove()).  This is used to create a\n-   *  fail-fast behavior with the iterators.\n-   **/\n-  private transient long modCount = 0;\n-\n-  /**\n-   *  Construct a new sequenced hash map with default initial size and load\n-   *  factor.\n-   **/\n-  public SequencedHashMap() {\n-    sentinel = createSentinel();\n-    entries = new HashMap();\n-  }\n-\n-  /**\n-   *  Construct a new sequenced hash map with the specified initial size and\n-   *  default load factor.\n-   *\n-   *  @param initialSize the initial size for the hash table \n-   *\n-   *  @see HashMap#HashMap(int)\n-   **/\n-  public SequencedHashMap(int initialSize) {\n-    sentinel = createSentinel();\n-    entries = new HashMap(initialSize);\n-  }\n-\n-  /**\n-   *  Construct a new sequenced hash map with the specified initial size and\n-   *  load factor.\n-   *\n-   *  @param initialSize the initial size for the hash table \n-   *\n-   *  @param loadFactor the load factor for the hash table.\n-   *\n-   *  @see HashMap#HashMap(int,float)\n-   **/\n-  public SequencedHashMap(int initialSize, float loadFactor) {\n-    sentinel = createSentinel();\n-    entries = new HashMap(initialSize, loadFactor);\n-  }\n-\n-  /**\n-   *  Construct a new sequenced hash map and add all the elements in the\n-   *  specified map.  The order in which the mappings in the specified map are\n-   *  added is defined by {@link #putAll(Map)}.  \n-   **/\n-  public SequencedHashMap(Map m) {\n-    this();\n-    putAll(m);\n-  }\n-\n-  /**\n-   *  Removes an internal entry from the linked list.  This does not remove\n-   *  it from the underlying map.\n-   **/\n-  private void removeEntry(Entry entry) {\n-    entry.next.prev = entry.prev;\n-    entry.prev.next = entry.next;    \n-  }\n-\n-  /**\n-   *  Inserts a new internal entry to the tail of the linked list.  This does\n-   *  not add the entry to the underlying map.\n-   **/\n-  private void insertEntry(Entry entry) {\n-    entry.next = sentinel;\n-    entry.prev = sentinel.prev;\n-    sentinel.prev.next = entry;\n-    sentinel.prev = entry;\n-  }\n-\n-  // per Map.size()\n-\n-  /**\n-   *  Implements {@link Map#size()}.\n-   */\n-  public int size() {\n-    // use the underlying Map's size since size is not maintained here.\n-    return entries.size();\n-  }\n-\n-  /**\n-   *  Implements {@link Map#isEmpty()}.\n-   */\n-  public boolean isEmpty() {\n-    // for quick check whether the map is entry, we can check the linked list\n-    // and see if there's anything in it.\n-    return sentinel.next == sentinel;\n-  }\n-\n-  /**\n-   *  Implements {@link Map#containsKey(Object)}.\n-   */\n-  public boolean containsKey(Object key) {\n-    // pass on to underlying map implementation\n-    return entries.containsKey(key);\n-  }\n-\n-  /**\n-   *  Implements {@link Map#containsValue(Object)}.\n-   */\n-  public boolean containsValue(Object value) {\n-    // unfortunately, we cannot just pass this call to the underlying map\n-    // because we are mapping keys to entries, not keys to values.  The\n-    // underlying map doesn't have an efficient implementation anyway, so this\n-    // isn't a big deal.\n-\n-    // do null comparison outside loop so we only need to do it once.  This\n-    // provides a tighter, more efficient loop at the expense of slight\n-    // code duplication.\n-    if(value == null) {\n-      for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n-        if(pos.getValue() == null) return true;\n-      } \n-    } else {\n-      for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n-        if(value.equals(pos.getValue())) return true;\n-      }\n-    }\n-    return false;      \n-  }\n-\n-  /**\n-   *  Implements {@link Map#get(Object)}.\n-   */\n-  public Object get(Object o) {\n-    // find entry for the specified key object\n-    Entry entry = (Entry)entries.get(o);\n-    if(entry == null) return null;\n-      \n-    return entry.getValue();\n-  }\n-\n-  /**\n-   *  Return the entry for the \"oldest\" mapping.  That is, return the Map.Entry\n-   *  for the key-value pair that was first put into the map when compared to\n-   *  all the other pairings in the map.  This behavior is equivalent to using\n-   *  <code>entrySet().iterator().next()</code>, but this method provides an\n-   *  optimized implementation.\n-   *\n-   *  @return The first entry in the sequence, or <code>null</code> if the\n-   *  map is empty.\n-   **/\n-  public Map.Entry getFirst() {\n-    // sentinel.next points to the \"first\" element of the sequence -- the head\n-    // of the list, which is exactly the entry we need to return.  We must test\n-    // for an empty list though because we don't want to return the sentinel!\n-    return (isEmpty()) ? null : sentinel.next;\n-  }\n-\n-  /**\n-   *  Return the key for the \"oldest\" mapping.  That is, return the key for the\n-   *  mapping that was first put into the map when compared to all the other\n-   *  objects in the map.  This behavior is equivalent to using\n-   *  <code>getFirst().getKey()</code>, but this method provides a slightly\n-   *  optimized implementation.\n-   *\n-   *  @return The first key in the sequence, or <code>null</code> if the\n-   *  map is empty.\n-   **/\n-  public Object getFirstKey() {\n-    // sentinel.next points to the \"first\" element of the sequence -- the head\n-    // of the list -- and the requisite key is returned from it.  An empty list\n-    // does not need to be tested.  In cases where the list is empty,\n-    // sentinel.next will point to the sentinel itself which has a null key,\n-    // which is exactly what we would want to return if the list is empty (a\n-    // nice convient way to avoid test for an empty list)\n-    return sentinel.next.getKey();\n-  }\n-\n-  /**\n-   *  Return the value for the \"oldest\" mapping.  That is, return the value for\n-   *  the mapping that was first put into the map when compared to all the\n-   *  other objects in the map.  This behavior is equivalent to using\n-   *  <code>getFirst().getValue()</code>, but this method provides a slightly\n-   *  optimized implementation.\n-   *\n-   *  @return The first value in the sequence, or <code>null</code> if the\n-   *  map is empty.\n-   **/\n-  public Object getFirstValue() {\n-    // sentinel.next points to the \"first\" element of the sequence -- the head\n-    // of the list -- and the requisite value is returned from it.  An empty\n-    // list does not need to be tested.  In cases where the list is empty,\n-    // sentinel.next will point to the sentinel itself which has a null value,\n-    // which is exactly what we would want to return if the list is empty (a\n-    // nice convient way to avoid test for an empty list)\n-    return sentinel.next.getValue();\n-  }\n-\n-  /**\n-   *  Return the entry for the \"newest\" mapping.  That is, return the Map.Entry\n-   *  for the key-value pair that was first put into the map when compared to\n-   *  all the other pairings in the map.  The behavior is equivalent to:\n-   *\n-   *  <pre>\n-   *    Object obj = null;\n-   *    Iterator iter = entrySet().iterator();\n-   *    while(iter.hasNext()) {\n-   *      obj = iter.next();\n-   *    }\n-   *    return (Map.Entry)obj;\n-   *  </pre>\n-   *\n-   *  However, the implementation of this method ensures an O(1) lookup of the\n-   *  last key rather than O(n).\n-   *\n-   *  @return The last entry in the sequence, or <code>null</code> if the map\n-   *  is empty.\n-   **/\n-  public Map.Entry getLast() {\n-    // sentinel.prev points to the \"last\" element of the sequence -- the tail\n-    // of the list, which is exactly the entry we need to return.  We must test\n-    // for an empty list though because we don't want to return the sentinel!\n-    return (isEmpty()) ? null : sentinel.prev;\n-  }\n-\n-  /**\n-   *  Return the key for the \"newest\" mapping.  That is, return the key for the\n-   *  mapping that was last put into the map when compared to all the other\n-   *  objects in the map.  This behavior is equivalent to using\n-   *  <code>getLast().getKey()</code>, but this method provides a slightly\n-   *  optimized implementation.\n-   *\n-   *  @return The last key in the sequence, or <code>null</code> if the map is\n-   *  empty.\n-   **/\n-  public Object getLastKey() {\n-    // sentinel.prev points to the \"last\" element of the sequence -- the tail\n-    // of the list -- and the requisite key is returned from it.  An empty list\n-    // does not need to be tested.  In cases where the list is empty,\n-    // sentinel.prev will point to the sentinel itself which has a null key,\n-    // which is exactly what we would want to return if the list is empty (a\n-    // nice convient way to avoid test for an empty list)\n-    return sentinel.prev.getKey();\n-  }\n-\n-  /**\n-   *  Return the value for the \"newest\" mapping.  That is, return the value for\n-   *  the mapping that was last put into the map when compared to all the other\n-   *  objects in the map.  This behavior is equivalent to using\n-   *  <code>getLast().getValue()</code>, but this method provides a slightly\n-   *  optimized implementation.\n-   *\n-   *  @return The last value in the sequence, or <code>null</code> if the map\n-   *  is empty.\n-   **/\n-  public Object getLastValue() {\n-    // sentinel.prev points to the \"last\" element of the sequence -- the tail\n-    // of the list -- and the requisite value is returned from it.  An empty\n-    // list does not need to be tested.  In cases where the list is empty,\n-    // sentinel.prev will point to the sentinel itself which has a null value,\n-    // which is exactly what we would want to return if the list is empty (a\n-    // nice convient way to avoid test for an empty list)\n-    return sentinel.prev.getValue();\n-  }\n-\n-  /**\n-   *  Implements {@link Map#put(Object, Object)}.\n-   */\n-  public Object put(Object key, Object value) {\n-    modCount++;\n-\n-    Object oldValue = null;\n-\n-    // lookup the entry for the specified key\n-    Entry e = (Entry)entries.get(key);\n-\n-    // check to see if it already exists\n-    if(e != null) {\n-      // remove from list so the entry gets \"moved\" to the end of list\n-      removeEntry(e);\n-\n-      // update value in map\n-      oldValue = e.setValue(value);\n-\n-      // Note: We do not update the key here because its unnecessary.  We only\n-      // do comparisons using equals(Object) and we know the specified key and\n-      // that in the map are equal in that sense.  This may cause a problem if\n-      // someone does not implement their hashCode() and/or equals(Object)\n-      // method properly and then use it as a key in this map.  \n-    } else {\n-      // add new entry\n-      e = new Entry(key, value);\n-      entries.put(key, e);\n-    }\n-    // assert(entry in map, but not list)\n-\n-    // add to list\n-    insertEntry(e);\n-\n-    return oldValue;\n-  }\n-\n-  /**\n-   *  Implements {@link Map#remove(Object)}.\n-   */\n-  public Object remove(Object key) {\n-    Entry e = removeImpl(key);\n-    return (e == null) ? null : e.getValue();\n-  }\n-  \n-  /**\n-   *  Fully remove an entry from the map, returning the old entry or null if\n-   *  there was no such entry with the specified key.\n-   **/\n-  private Entry removeImpl(Object key) {\n-    Entry e = (Entry)entries.remove(key);\n-    if(e == null) return null;\n-    modCount++;\n-    removeEntry(e);\n-    return e;\n-  }\n-\n-  /**\n-   *  Adds all the mappings in the specified map to this map, replacing any\n-   *  mappings that already exist (as per {@link Map#putAll(Map)}).  The order\n-   *  in which the entries are added is determined by the iterator returned\n-   *  from {@link Map#entrySet()} for the specified map.\n-   *\n-   *  @param t the mappings that should be added to this map.\n-   *\n-   *  @exception NullPointerException if <code>t</code> is <code>null</code>\n-   **/\n-  public void putAll(Map t) {\n-    Iterator iter = t.entrySet().iterator();\n-    while(iter.hasNext()) {\n-      Map.Entry entry = (Map.Entry)iter.next();\n-      put(entry.getKey(), entry.getValue());\n-    }\n-  }\n-\n-  /**\n-   *  Implements {@link Map#clear()}.\n-   */\n-  public void clear() {\n-    modCount++;\n-\n-    // remove all from the underlying map\n-    entries.clear();\n-\n-    // and the list\n-    sentinel.next = sentinel;\n-    sentinel.prev = sentinel;\n-  }\n-\n-  /**\n-   *  Implements {@link Map#equals(Object)}.\n-   */\n-  public boolean equals(Object obj) {\n-    if(obj == null) return false;\n-    if(obj == this) return true;\n-\n-    if(!(obj instanceof Map)) return false;\n-\n-    return entrySet().equals(((Map)obj).entrySet());\n-  }\n-\n-  /**\n-   *  Implements {@link Map#hashCode()}.\n-   */\n-  public int hashCode() {\n-    return entrySet().hashCode();\n-  }\n-\n-  /**\n-   *  Provides a string representation of the entries within the map.  The\n-   *  format of the returned string may change with different releases, so this\n-   *  method is suitable for debugging purposes only.  If a specific format is\n-   *  required, use {@link #entrySet()}.{@link Set#iterator() iterator()} and\n-   *  iterate over the entries in the map formatting them as appropriate.\n-   **/\n-  public String toString() {\n-    StringBuffer buf = new StringBuffer();\n-    buf.append('[');\n-    for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n-      buf.append(pos.getKey());\n-      buf.append('=');\n-      buf.append(pos.getValue());\n-      if(pos.next != sentinel) {\n-        buf.append(',');\n-      }\n-    }\n-    buf.append(']');\n-\n-    return buf.toString();\n-  }\n-\n-  /**\n-   *  Implements {@link Map#keySet()}.\n-   */\n-  public Set keySet() {\n-    return new AbstractSet() {\n-\n-      // required impls\n-      public Iterator iterator() { return new OrderedIterator(KEY); }\n-      public boolean remove(Object o) {\n-        Entry e = SequencedHashMap.this.removeImpl(o);\n-        return (e != null);\n-      }\n-\n-      // more efficient impls than abstract set\n-      public void clear() { \n-        SequencedHashMap.this.clear(); \n-      }\n-      public int size() { \n-        return SequencedHashMap.this.size(); \n-      }\n-      public boolean isEmpty() { \n-        return SequencedHashMap.this.isEmpty(); \n-      }\n-      public boolean contains(Object o) { \n-        return SequencedHashMap.this.containsKey(o);\n-      }\n-\n-    };\n-  }\n-\n-  /**\n-   *  Implements {@link Map#values()}.\n-   */\n-  public Collection values() {\n-    return new AbstractCollection() {\n-      // required impl\n-      public Iterator iterator() { return new OrderedIterator(VALUE); }\n-      public boolean remove(Object value) {\n+    /**\n+     *  {@link java.util.Map.Entry} that doubles as a node in the linked list\n+     *  of sequenced mappings.  \n+     **/\n+    private static class Entry implements Map.Entry {\n+        // Note: This class cannot easily be made clonable.  While the actual\n+        // implementation of a clone would be simple, defining the semantics is\n+        // difficult.  If a shallow clone is implemented, then entry.next.prev !=\n+        // entry, which is unintuitive and probably breaks all sorts of assumptions\n+        // in code that uses this implementation.  If a deep clone is\n+        // implementated, then what happens when the linked list is cyclical (as is\n+        // the case with SequencedHashMap)?  It's impossible to know in the clone\n+        // when to stop cloning, and thus you end up in a recursive loop,\n+        // continuously cloning the \"next\" in the list.\n+\n+        private final Object key;\n+        private Object value;\n+\n+        // package private to allow the SequencedHashMap to access and manipulate\n+        // them.\n+        Entry next = null;\n+        Entry prev = null;\n+\n+        public Entry(Object key, Object value) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        // per Map.Entry.getKey()\n+        public Object getKey() {\n+            return this.key;\n+        }\n+\n+        // per Map.Entry.getValue()\n+        public Object getValue() {\n+            return this.value;\n+        }\n+\n+        // per Map.Entry.setValue()\n+        public Object setValue(Object value) {\n+            Object oldValue = this.value;\n+            this.value = value;\n+            return oldValue;\n+        }\n+\n+        public int hashCode() {\n+            // implemented per api docs for Map.Entry.hashCode()\n+            return ((getKey() == null ? 0 : getKey().hashCode()) ^ (getValue() == null ? 0 : getValue().hashCode()));\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (obj == null)\n+                return false;\n+            if (obj == this)\n+                return true;\n+            if (!(obj instanceof Map.Entry))\n+                return false;\n+\n+            Map.Entry other = (Map.Entry) obj;\n+\n+            // implemented per api docs for Map.Entry.equals(Object) \n+            return (\n+                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey()))\n+                    && (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue())));\n+        }\n+        public String toString() {\n+            return \"[\" + getKey() + \"=\" + getValue() + \"]\";\n+        }\n+    }\n+\n+    /**\n+     *  Construct an empty sentinel used to hold the head (sentinel.next) and the\n+     *  tail (sentinel.prev) of the list.  The sentinal has a <code>null</code>\n+     *  key and value.\n+     **/\n+    private static final Entry createSentinel() {\n+        Entry s = new Entry(null, null);\n+        s.prev = s;\n+        s.next = s;\n+        return s;\n+    }\n+\n+    /**\n+     *  Sentinel used to hold the head and tail of the list of entries.\n+     **/\n+    private Entry sentinel;\n+\n+    /**\n+     *  Map of keys to entries\n+     **/\n+    private HashMap entries;\n+\n+    /**\n+     *  Holds the number of modifications that have occurred to the map,\n+     *  excluding modifications made through a collection view's iterator\n+     *  (e.g. entrySet().iterator().remove()).  This is used to create a\n+     *  fail-fast behavior with the iterators.\n+     **/\n+    private transient long modCount = 0;\n+\n+    /**\n+     *  Construct a new sequenced hash map with default initial size and load\n+     *  factor.\n+     **/\n+    public SequencedHashMap() {\n+        sentinel = createSentinel();\n+        entries = new HashMap();\n+    }\n+\n+    /**\n+     *  Construct a new sequenced hash map with the specified initial size and\n+     *  default load factor.\n+     *\n+     *  @param initialSize the initial size for the hash table \n+     *\n+     *  @see HashMap#HashMap(int)\n+     **/\n+    public SequencedHashMap(int initialSize) {\n+        sentinel = createSentinel();\n+        entries = new HashMap(initialSize);\n+    }\n+\n+    /**\n+     *  Construct a new sequenced hash map with the specified initial size and\n+     *  load factor.\n+     *\n+     *  @param initialSize the initial size for the hash table \n+     *\n+     *  @param loadFactor the load factor for the hash table.\n+     *\n+     *  @see HashMap#HashMap(int,float)\n+     **/\n+    public SequencedHashMap(int initialSize, float loadFactor) {\n+        sentinel = createSentinel();\n+        entries = new HashMap(initialSize, loadFactor);\n+    }\n+\n+    /**\n+     *  Construct a new sequenced hash map and add all the elements in the\n+     *  specified map.  The order in which the mappings in the specified map are\n+     *  added is defined by {@link #putAll(Map)}.  \n+     **/\n+    public SequencedHashMap(Map m) {\n+        this();\n+        putAll(m);\n+    }\n+\n+    /**\n+     *  Removes an internal entry from the linked list.  This does not remove\n+     *  it from the underlying map.\n+     **/\n+    private void removeEntry(Entry entry) {\n+        entry.next.prev = entry.prev;\n+        entry.prev.next = entry.next;\n+    }\n+\n+    /**\n+     *  Inserts a new internal entry to the tail of the linked list.  This does\n+     *  not add the entry to the underlying map.\n+     **/\n+    private void insertEntry(Entry entry) {\n+        entry.next = sentinel;\n+        entry.prev = sentinel.prev;\n+        sentinel.prev.next = entry;\n+        sentinel.prev = entry;\n+    }\n+\n+    // per Map.size()\n+\n+    /**\n+     *  Implements {@link Map#size()}.\n+     */\n+    public int size() {\n+        // use the underlying Map's size since size is not maintained here.\n+        return entries.size();\n+    }\n+\n+    /**\n+     *  Implements {@link Map#isEmpty()}.\n+     */\n+    public boolean isEmpty() {\n+        // for quick check whether the map is entry, we can check the linked list\n+        // and see if there's anything in it.\n+        return sentinel.next == sentinel;\n+    }\n+\n+    /**\n+     *  Implements {@link Map#containsKey(Object)}.\n+     */\n+    public boolean containsKey(Object key) {\n+        // pass on to underlying map implementation\n+        return entries.containsKey(key);\n+    }\n+\n+    /**\n+     *  Implements {@link Map#containsValue(Object)}.\n+     */\n+    public boolean containsValue(Object value) {\n+        // unfortunately, we cannot just pass this call to the underlying map\n+        // because we are mapping keys to entries, not keys to values.  The\n+        // underlying map doesn't have an efficient implementation anyway, so this\n+        // isn't a big deal.\n+\n         // do null comparison outside loop so we only need to do it once.  This\n         // provides a tighter, more efficient loop at the expense of slight\n         // code duplication.\n-        if(value == null) {\n-          for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n-            if(pos.getValue() == null) {\n-              SequencedHashMap.this.removeImpl(pos.getKey());\n-              return true;\n-            }\n-          } \n+        if (value == null) {\n+            for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+                if (pos.getValue() == null)\n+                    return true;\n+            }\n         } else {\n-          for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n-            if(value.equals(pos.getValue())) {\n-              SequencedHashMap.this.removeImpl(pos.getKey());\n-              return true;\n-            }\n-          }\n-        }\n-\n+            for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+                if (value.equals(pos.getValue()))\n+                    return true;\n+            }\n+        }\n         return false;\n-      }\n-\n-      // more efficient impls than abstract collection\n-      public void clear() { \n-        SequencedHashMap.this.clear(); \n-      }\n-      public int size() { \n-        return SequencedHashMap.this.size(); \n-      }\n-      public boolean isEmpty() { \n-        return SequencedHashMap.this.isEmpty(); \n-      }\n-      public boolean contains(Object o) {\n-        return SequencedHashMap.this.containsValue(o);\n-      }\n-    };\n-  }\n-\n-  /**\n-   *  Implements {@link Map#entrySet()}.\n-   */\n-  public Set entrySet() {\n-    return new AbstractSet() {\n-      // helper\n-      private Entry findEntry(Object o) {\n-        if(o == null) return null;\n-        if(!(o instanceof Map.Entry)) return null;\n-        \n-        Map.Entry e = (Map.Entry)o;\n-        Entry entry = (Entry)entries.get(e.getKey());\n-        if(entry != null && entry.equals(e)) return entry;\n-        else return null;\n-      }\n-\n-      // required impl\n-      public Iterator iterator() { \n-        return new OrderedIterator(ENTRY); \n-      }\n-      public boolean remove(Object o) {\n-        Entry e = findEntry(o);\n-        if(e == null) return false;\n-\n-        return SequencedHashMap.this.removeImpl(e.getKey()) != null;\n-      }        \n-\n-      // more efficient impls than abstract collection\n-      public void clear() { \n-        SequencedHashMap.this.clear(); \n-      }\n-      public int size() { \n-        return SequencedHashMap.this.size(); \n-      }\n-      public boolean isEmpty() { \n-        return SequencedHashMap.this.isEmpty(); \n-      }\n-      public boolean contains(Object o) {\n-        return findEntry(o) != null;\n-      }\n-    };\n-  }\n-\n-  // constants to define what the iterator should return on \"next\"\n-  private static final int KEY = 0;\n-  private static final int VALUE = 1;\n-  private static final int ENTRY = 2;\n-  private static final int REMOVED_MASK = 0x80000000;\n-\n-  private class OrderedIterator implements Iterator {\n-    /** \n-     *  Holds the type that should be returned from the iterator.  The value\n-     *  should be either {@link #KEY}, {@link #VALUE}, or {@link #ENTRY}.  To\n-     *  save a tiny bit of memory, this field is also used as a marker for when\n-     *  remove has been called on the current object to prevent a second remove\n-     *  on the same element.  Essientially, if this value is negative (i.e. the\n-     *  bit specified by {@link #REMOVED_MASK} is set), the current position\n-     *  has been removed.  If positive, remove can still be called.\n-     **/\n-    private int returnType;\n-\n-    /**\n-     *  Holds the \"current\" position in the iterator.  When pos.next is the\n-     *  sentinel, we've reached the end of the list.\n-     **/\n-    private Entry pos = sentinel;\n-\n-    /**\n-     *  Holds the expected modification count.  If the actual modification\n-     *  count of the map differs from this value, then a concurrent\n-     *  modification has occurred.\n-     **/\n-    private transient long expectedModCount = modCount;\n-    \n-    /**\n-     *  Construct an iterator over the sequenced elements in the order in which\n-     *  they were added.  The {@link #next()} method returns the type specified\n-     *  by <code>returnType</code> which must be either {@link #KEY}, {@link\n-     *  #VALUE}, or {@link #ENTRY}.\n-     **/\n-    public OrderedIterator(int returnType) {\n-      //// Since this is a private inner class, nothing else should have\n-      //// access to the constructor.  Since we know the rest of the outer\n-      //// class uses the iterator correctly, we can leave of the following\n-      //// check:\n-      //if(returnType >= 0 && returnType <= 2) {\n-      //  throw new IllegalArgumentException(\"Invalid iterator type\");\n-      //}\n-\n-      // Set the \"removed\" bit so that the iterator starts in a state where\n-      // \"next\" must be called before \"remove\" will succeed.\n-      this.returnType = returnType | REMOVED_MASK;\n-    }\n-\n-    /**\n-     *  Returns whether there is any additional elements in the iterator to be\n-     *  returned.\n-     *\n-     *  @return <code>true</code> if there are more elements left to be\n-     *  returned from the iterator; <code>false</code> otherwise.\n-     **/\n-    public boolean hasNext() {\n-      return pos.next != sentinel;\n-    }\n-\n-    /**\n-     *  Returns the next element from the iterator.\n-     *\n-     *  @return the next element from the iterator.\n-     *\n-     *  @exception NoSuchElementException if there are no more elements in the\n-     *  iterator.\n-     *\n-     *  @exception ConcurrentModificationException if a modification occurs in\n-     *  the underlying map.\n-     **/\n-    public Object next() {\n-      if(modCount != expectedModCount) {\n-        throw new ConcurrentModificationException();\n-      }\n-      if(pos.next == sentinel) {\n-        throw new NoSuchElementException();\n-      }\n-\n-      // clear the \"removed\" flag\n-      returnType = returnType & ~REMOVED_MASK;\n-\n-      pos = pos.next;\n-      switch(returnType) {\n-      case KEY:\n-        return pos.getKey();\n-      case VALUE:\n-        return pos.getValue();\n-      case ENTRY:\n+    }\n+\n+    /**\n+     *  Implements {@link Map#get(Object)}.\n+     */\n+    public Object get(Object o) {\n+        // find entry for the specified key object\n+        Entry entry = (Entry) entries.get(o);\n+        if (entry == null)\n+            return null;\n+\n+        return entry.getValue();\n+    }\n+\n+    /**\n+     *  Return the entry for the \"oldest\" mapping.  That is, return the Map.Entry\n+     *  for the key-value pair that was first put into the map when compared to\n+     *  all the other pairings in the map.  This behavior is equivalent to using\n+     *  <code>entrySet().iterator().next()</code>, but this method provides an\n+     *  optimized implementation.\n+     *\n+     *  @return The first entry in the sequence, or <code>null</code> if the\n+     *  map is empty.\n+     **/\n+    public Map.Entry getFirst() {\n+        // sentinel.next points to the \"first\" element of the sequence -- the head\n+        // of the list, which is exactly the entry we need to return.  We must test\n+        // for an empty list though because we don't want to return the sentinel!\n+        return (isEmpty()) ? null : sentinel.next;\n+    }\n+\n+    /**\n+     *  Return the key for the \"oldest\" mapping.  That is, return the key for the\n+     *  mapping that was first put into the map when compared to all the other\n+     *  objects in the map.  This behavior is equivalent to using\n+     *  <code>getFirst().getKey()</code>, but this method provides a slightly\n+     *  optimized implementation.\n+     *\n+     *  @return The first key in the sequence, or <code>null</code> if the\n+     *  map is empty.\n+     **/\n+    public Object getFirstKey() {\n+        // sentinel.next points to the \"first\" element of the sequence -- the head\n+        // of the list -- and the requisite key is returned from it.  An empty list\n+        // does not need to be tested.  In cases where the list is empty,\n+        // sentinel.next will point to the sentinel itself which has a null key,\n+        // which is exactly what we would want to return if the list is empty (a\n+        // nice convient way to avoid test for an empty list)\n+        return sentinel.next.getKey();\n+    }\n+\n+    /**\n+     *  Return the value for the \"oldest\" mapping.  That is, return the value for\n+     *  the mapping that was first put into the map when compared to all the\n+     *  other objects in the map.  This behavior is equivalent to using\n+     *  <code>getFirst().getValue()</code>, but this method provides a slightly\n+     *  optimized implementation.\n+     *\n+     *  @return The first value in the sequence, or <code>null</code> if the\n+     *  map is empty.\n+     **/\n+    public Object getFirstValue() {\n+        // sentinel.next points to the \"first\" element of the sequence -- the head\n+        // of the list -- and the requisite value is returned from it.  An empty\n+        // list does not need to be tested.  In cases where the list is empty,\n+        // sentinel.next will point to the sentinel itself which has a null value,\n+        // which is exactly what we would want to return if the list is empty (a\n+        // nice convient way to avoid test for an empty list)\n+        return sentinel.next.getValue();\n+    }\n+\n+    /**\n+     *  Return the entry for the \"newest\" mapping.  That is, return the Map.Entry\n+     *  for the key-value pair that was first put into the map when compared to\n+     *  all the other pairings in the map.  The behavior is equivalent to:\n+     *\n+     *  <pre>\n+     *    Object obj = null;\n+     *    Iterator iter = entrySet().iterator();\n+     *    while(iter.hasNext()) {\n+     *      obj = iter.next();\n+     *    }\n+     *    return (Map.Entry)obj;\n+     *  </pre>\n+     *\n+     *  However, the implementation of this method ensures an O(1) lookup of the\n+     *  last key rather than O(n).\n+     *\n+     *  @return The last entry in the sequence, or <code>null</code> if the map\n+     *  is empty.\n+     **/\n+    public Map.Entry getLast() {\n+        // sentinel.prev points to the \"last\" element of the sequence -- the tail\n+        // of the list, which is exactly the entry we need to return.  We must test\n+        // for an empty list though because we don't want to return the sentinel!\n+        return (isEmpty()) ? null : sentinel.prev;\n+    }\n+\n+    /**\n+     *  Return the key for the \"newest\" mapping.  That is, return the key for the\n+     *  mapping that was last put into the map when compared to all the other\n+     *  objects in the map.  This behavior is equivalent to using\n+     *  <code>getLast().getKey()</code>, but this method provides a slightly\n+     *  optimized implementation.\n+     *\n+     *  @return The last key in the sequence, or <code>null</code> if the map is\n+     *  empty.\n+     **/\n+    public Object getLastKey() {\n+        // sentinel.prev points to the \"last\" element of the sequence -- the tail\n+        // of the list -- and the requisite key is returned from it.  An empty list\n+        // does not need to be tested.  In cases where the list is empty,\n+        // sentinel.prev will point to the sentinel itself which has a null key,\n+        // which is exactly what we would want to return if the list is empty (a\n+        // nice convient way to avoid test for an empty list)\n+        return sentinel.prev.getKey();\n+    }\n+\n+    /**\n+     *  Return the value for the \"newest\" mapping.  That is, return the value for\n+     *  the mapping that was last put into the map when compared to all the other\n+     *  objects in the map.  This behavior is equivalent to using\n+     *  <code>getLast().getValue()</code>, but this method provides a slightly\n+     *  optimized implementation.\n+     *\n+     *  @return The last value in the sequence, or <code>null</code> if the map\n+     *  is empty.\n+     **/\n+    public Object getLastValue() {\n+        // sentinel.prev points to the \"last\" element of the sequence -- the tail\n+        // of the list -- and the requisite value is returned from it.  An empty\n+        // list does not need to be tested.  In cases where the list is empty,\n+        // sentinel.prev will point to the sentinel itself which has a null value,\n+        // which is exactly what we would want to return if the list is empty (a\n+        // nice convient way to avoid test for an empty list)\n+        return sentinel.prev.getValue();\n+    }\n+\n+    /**\n+     *  Implements {@link Map#put(Object, Object)}.\n+     */\n+    public Object put(Object key, Object value) {\n+        modCount++;\n+\n+        Object oldValue = null;\n+\n+        // lookup the entry for the specified key\n+        Entry e = (Entry) entries.get(key);\n+\n+        // check to see if it already exists\n+        if (e != null) {\n+            // remove from list so the entry gets \"moved\" to the end of list\n+            removeEntry(e);\n+\n+            // update value in map\n+            oldValue = e.setValue(value);\n+\n+            // Note: We do not update the key here because its unnecessary.  We only\n+            // do comparisons using equals(Object) and we know the specified key and\n+            // that in the map are equal in that sense.  This may cause a problem if\n+            // someone does not implement their hashCode() and/or equals(Object)\n+            // method properly and then use it as a key in this map.  \n+        } else {\n+            // add new entry\n+            e = new Entry(key, value);\n+            entries.put(key, e);\n+        }\n+        // assert(entry in map, but not list)\n+\n+        // add to list\n+        insertEntry(e);\n+\n+        return oldValue;\n+    }\n+\n+    /**\n+     *  Implements {@link Map#remove(Object)}.\n+     */\n+    public Object remove(Object key) {\n+        Entry e = removeImpl(key);\n+        return (e == null) ? null : e.getValue();\n+    }\n+\n+    /**\n+     *  Fully remove an entry from the map, returning the old entry or null if\n+     *  there was no such entry with the specified key.\n+     **/\n+    private Entry removeImpl(Object key) {\n+        Entry e = (Entry) entries.remove(key);\n+        if (e == null)\n+            return null;\n+        modCount++;\n+        removeEntry(e);\n+        return e;\n+    }\n+\n+    /**\n+     *  Adds all the mappings in the specified map to this map, replacing any\n+     *  mappings that already exist (as per {@link Map#putAll(Map)}).  The order\n+     *  in which the entries are added is determined by the iterator returned\n+     *  from {@link Map#entrySet()} for the specified map.\n+     *\n+     *  @param t the mappings that should be added to this map.\n+     *\n+     *  @throws NullPointerException if <code>t</code> is <code>null</code>\n+     **/\n+    public void putAll(Map t) {\n+        Iterator iter = t.entrySet().iterator();\n+        while (iter.hasNext()) {\n+            Map.Entry entry = (Map.Entry) iter.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     *  Implements {@link Map#clear()}.\n+     */\n+    public void clear() {\n+        modCount++;\n+\n+        // remove all from the underlying map\n+        entries.clear();\n+\n+        // and the list\n+        sentinel.next = sentinel;\n+        sentinel.prev = sentinel;\n+    }\n+\n+    /**\n+     *  Implements {@link Map#equals(Object)}.\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == null)\n+            return false;\n+        if (obj == this)\n+            return true;\n+\n+        if (!(obj instanceof Map))\n+            return false;\n+\n+        return entrySet().equals(((Map) obj).entrySet());\n+    }\n+\n+    /**\n+     *  Implements {@link Map#hashCode()}.\n+     */\n+    public int hashCode() {\n+        return entrySet().hashCode();\n+    }\n+\n+    /**\n+     *  Provides a string representation of the entries within the map.  The\n+     *  format of the returned string may change with different releases, so this\n+     *  method is suitable for debugging purposes only.  If a specific format is\n+     *  required, use {@link #entrySet()}.{@link Set#iterator() iterator()} and\n+     *  iterate over the entries in the map formatting them as appropriate.\n+     **/\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append('[');\n+        for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+            buf.append(pos.getKey());\n+            buf.append('=');\n+            buf.append(pos.getValue());\n+            if (pos.next != sentinel) {\n+                buf.append(',');\n+            }\n+        }\n+        buf.append(']');\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     *  Implements {@link Map#keySet()}.\n+     */\n+    public Set keySet() {\n+        return new AbstractSet() {\n+\n+            // required impls\n+            public Iterator iterator() {\n+                return new OrderedIterator(KEY);\n+            }\n+            public boolean remove(Object o) {\n+                Entry e = SequencedHashMap.this.removeImpl(o);\n+                return (e != null);\n+            }\n+\n+            // more efficient impls than abstract set\n+            public void clear() {\n+                SequencedHashMap.this.clear();\n+            }\n+            public int size() {\n+                return SequencedHashMap.this.size();\n+            }\n+            public boolean isEmpty() {\n+                return SequencedHashMap.this.isEmpty();\n+            }\n+            public boolean contains(Object o) {\n+                return SequencedHashMap.this.containsKey(o);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     *  Implements {@link Map#values()}.\n+     */\n+    public Collection values() {\n+        return new AbstractCollection() {\n+            // required impl\n+            public Iterator iterator() {\n+                return new OrderedIterator(VALUE);\n+            }\n+            public boolean remove(Object value) {\n+                // do null comparison outside loop so we only need to do it once.  This\n+                // provides a tighter, more efficient loop at the expense of slight\n+                // code duplication.\n+                if (value == null) {\n+                    for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+                        if (pos.getValue() == null) {\n+                            SequencedHashMap.this.removeImpl(pos.getKey());\n+                            return true;\n+                        }\n+                    }\n+                } else {\n+                    for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+                        if (value.equals(pos.getValue())) {\n+                            SequencedHashMap.this.removeImpl(pos.getKey());\n+                            return true;\n+                        }\n+                    }\n+                }\n+\n+                return false;\n+            }\n+\n+            // more efficient impls than abstract collection\n+            public void clear() {\n+                SequencedHashMap.this.clear();\n+            }\n+            public int size() {\n+                return SequencedHashMap.this.size();\n+            }\n+            public boolean isEmpty() {\n+                return SequencedHashMap.this.isEmpty();\n+            }\n+            public boolean contains(Object o) {\n+                return SequencedHashMap.this.containsValue(o);\n+            }\n+        };\n+    }\n+\n+    /**\n+     *  Implements {@link Map#entrySet()}.\n+     */\n+    public Set entrySet() {\n+        return new AbstractSet() {\n+            // helper\n+            private Entry findEntry(Object o) {\n+                if (o == null)\n+                    return null;\n+                if (!(o instanceof Map.Entry))\n+                    return null;\n+\n+                Map.Entry e = (Map.Entry) o;\n+                Entry entry = (Entry) entries.get(e.getKey());\n+                if (entry != null && entry.equals(e))\n+                    return entry;\n+                else\n+                    return null;\n+            }\n+\n+            // required impl\n+            public Iterator iterator() {\n+                return new OrderedIterator(ENTRY);\n+            }\n+            public boolean remove(Object o) {\n+                Entry e = findEntry(o);\n+                if (e == null)\n+                    return false;\n+\n+                return SequencedHashMap.this.removeImpl(e.getKey()) != null;\n+            }\n+\n+            // more efficient impls than abstract collection\n+            public void clear() {\n+                SequencedHashMap.this.clear();\n+            }\n+            public int size() {\n+                return SequencedHashMap.this.size();\n+            }\n+            public boolean isEmpty() {\n+                return SequencedHashMap.this.isEmpty();\n+            }\n+            public boolean contains(Object o) {\n+                return findEntry(o) != null;\n+            }\n+        };\n+    }\n+\n+    // constants to define what the iterator should return on \"next\"\n+    private static final int KEY = 0;\n+    private static final int VALUE = 1;\n+    private static final int ENTRY = 2;\n+    private static final int REMOVED_MASK = 0x80000000;\n+\n+    private class OrderedIterator implements Iterator {\n+        /** \n+         *  Holds the type that should be returned from the iterator.  The value\n+         *  should be either {@link #KEY}, {@link #VALUE}, or {@link #ENTRY}.  To\n+         *  save a tiny bit of memory, this field is also used as a marker for when\n+         *  remove has been called on the current object to prevent a second remove\n+         *  on the same element.  Essientially, if this value is negative (i.e. the\n+         *  bit specified by {@link #REMOVED_MASK} is set), the current position\n+         *  has been removed.  If positive, remove can still be called.\n+         **/\n+        private int returnType;\n+\n+        /**\n+         *  Holds the \"current\" position in the iterator.  When pos.next is the\n+         *  sentinel, we've reached the end of the list.\n+         **/\n+        private Entry pos = sentinel;\n+\n+        /**\n+         *  Holds the expected modification count.  If the actual modification\n+         *  count of the map differs from this value, then a concurrent\n+         *  modification has occurred.\n+         **/\n+        private transient long expectedModCount = modCount;\n+\n+        /**\n+         *  Construct an iterator over the sequenced elements in the order in which\n+         *  they were added.  The {@link #next()} method returns the type specified\n+         *  by <code>returnType</code> which must be either {@link #KEY}, {@link\n+         *  #VALUE}, or {@link #ENTRY}.\n+         **/\n+        public OrderedIterator(int returnType) {\n+            //// Since this is a private inner class, nothing else should have\n+            //// access to the constructor.  Since we know the rest of the outer\n+            //// class uses the iterator correctly, we can leave of the following\n+            //// check:\n+            //if(returnType >= 0 && returnType <= 2) {\n+            //  throw new IllegalArgumentException(\"Invalid iterator type\");\n+            //}\n+\n+            // Set the \"removed\" bit so that the iterator starts in a state where\n+            // \"next\" must be called before \"remove\" will succeed.\n+            this.returnType = returnType | REMOVED_MASK;\n+        }\n+\n+        /**\n+         *  Returns whether there is any additional elements in the iterator to be\n+         *  returned.\n+         *\n+         *  @return <code>true</code> if there are more elements left to be\n+         *  returned from the iterator; <code>false</code> otherwise.\n+         **/\n+        public boolean hasNext() {\n+            return pos.next != sentinel;\n+        }\n+\n+        /**\n+         *  Returns the next element from the iterator.\n+         *\n+         *  @return the next element from the iterator.\n+         *\n+         *  @throws NoSuchElementException if there are no more elements in the\n+         *  iterator.\n+         *\n+         *  @throws ConcurrentModificationException if a modification occurs in\n+         *  the underlying map.\n+         **/\n+        public Object next() {\n+            if (modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (pos.next == sentinel) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            // clear the \"removed\" flag\n+            returnType = returnType & ~REMOVED_MASK;\n+\n+            pos = pos.next;\n+            switch (returnType) {\n+                case KEY :\n+                    return pos.getKey();\n+                case VALUE :\n+                    return pos.getValue();\n+                case ENTRY :\n+                    return pos;\n+                default :\n+                    // should never happen\n+                    throw new Error(\"bad iterator type: \" + returnType);\n+            }\n+\n+        }\n+\n+        /**\n+         *  Removes the last element returned from the {@link #next()} method from\n+         *  the sequenced map.\n+         *\n+         *  @throws IllegalStateException if there isn't a \"last element\" to be\n+         *  removed.  That is, if {@link #next()} has never been called, or if\n+         *  {@link #remove()} was already called on the element.\n+         *\n+         *  @throws ConcurrentModificationException if a modification occurs in\n+         *  the underlying map.\n+         **/\n+        public void remove() {\n+            if ((returnType & REMOVED_MASK) != 0) {\n+                throw new IllegalStateException(\"remove() must follow next()\");\n+            }\n+            if (modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+\n+            SequencedHashMap.this.removeImpl(pos.getKey());\n+\n+            // update the expected mod count for the remove operation\n+            expectedModCount++;\n+\n+            // set the removed flag\n+            returnType = returnType | REMOVED_MASK;\n+        }\n+    }\n+\n+    // APIs maintained from previous version of SequencedHashMap for backwards\n+    // compatibility\n+\n+    /**\n+     * Creates a shallow copy of this object, preserving the internal structure\n+     * by copying only references.  The keys and values themselves are not\n+     * <code>clone()</code>'d.  The cloned object maintains the same sequence.\n+     *\n+     * @return A clone of this instance.  \n+     *\n+     * @throws CloneNotSupportedException if clone is not supported by a\n+     * subclass.\n+     */\n+    public Object clone() throws CloneNotSupportedException {\n+        // yes, calling super.clone() silly since we're just blowing away all\n+        // the stuff that super might be doing anyway, but for motivations on\n+        // this, see:\n+        // http://www.javaworld.com/javaworld/jw-01-1999/jw-01-object.html\n+        SequencedHashMap map = (SequencedHashMap) super.clone();\n+\n+        // create new, empty sentinel\n+        map.sentinel = createSentinel();\n+\n+        // create a new, empty entry map\n+        // note: this does not preserve the initial capacity and load factor.\n+        map.entries = new HashMap();\n+\n+        // add all the mappings\n+        map.putAll(this);\n+\n+        // Note: We cannot just clone the hashmap and sentinel because we must\n+        // duplicate our internal structures.  Cloning those two will not clone all\n+        // the other entries they reference, and so the cloned hash map will not be\n+        // able to maintain internal consistency because there are two objects with\n+        // the same entries.  See discussion in the Entry implementation on why we\n+        // cannot implement a clone of the Entry (and thus why we need to recreate\n+        // everything).\n+\n+        return map;\n+    }\n+\n+    /**\n+     *  Returns the Map.Entry at the specified index\n+     *\n+     *  @throws ArrayIndexOutOfBoundsException if the specified index is\n+     *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+     **/\n+    private Map.Entry getEntry(int index) {\n+        Entry pos = sentinel;\n+\n+        if (index < 0) {\n+            throw new ArrayIndexOutOfBoundsException(index + \" < 0\");\n+        }\n+\n+        // loop to one before the position\n+        int i = -1;\n+        while (i < (index - 1) && pos.next != sentinel) {\n+            i++;\n+            pos = pos.next;\n+        }\n+        // pos.next is the requested position\n+\n+        // if sentinel is next, past end of list\n+        if (pos.next == sentinel) {\n+            throw new ArrayIndexOutOfBoundsException(index + \" >= \" + (i + 1));\n+        }\n+\n+        return pos.next;\n+    }\n+\n+    /**\n+     * Gets the key at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the key at the specified index, or null\n+     * @throws ArrayIndexOutOfBoundsException if the <code>index</code> is\n+     *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+     */\n+    public Object get(int index) {\n+        return getEntry(index).getKey();\n+    }\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value at the specified index, or null\n+     * @throws ArrayIndexOutOfBoundsException if the <code>index</code> is\n+     *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+     */\n+    public Object getValue(int index) {\n+        return getEntry(index).getValue();\n+    }\n+\n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(Object key) {\n+        Entry e = (Entry) entries.get(key);\n+        if (e == null) {\n+            return -1;\n+        }\n+        int pos = 0;\n+        while (e.prev != sentinel) {\n+            pos++;\n+            e = e.prev;\n+        }\n         return pos;\n-      default:\n-        // should never happen\n-        throw new Error(\"bad iterator type: \" + returnType);\n-      }\n-\n-    }\n-    \n-    /**\n-     *  Removes the last element returned from the {@link #next()} method from\n-     *  the sequenced map.\n-     *\n-     *  @exception IllegalStateException if there isn't a \"last element\" to be\n-     *  removed.  That is, if {@link #next()} has never been called, or if\n-     *  {@link #remove()} was already called on the element.\n-     *\n-     *  @exception ConcurrentModificationException if a modification occurs in\n-     *  the underlying map.\n-     **/\n-    public void remove() {\n-      if((returnType & REMOVED_MASK) != 0) {\n-        throw new IllegalStateException(\"remove() must follow next()\");\n-      }\n-      if(modCount != expectedModCount) {\n-        throw new ConcurrentModificationException();\n-      }\n-\n-      SequencedHashMap.this.removeImpl(pos.getKey());\n-\n-      // update the expected mod count for the remove operation\n-      expectedModCount++;\n-\n-      // set the removed flag\n-      returnType = returnType | REMOVED_MASK;\n-    }\n-  }\n-\n-  // APIs maintained from previous version of SequencedHashMap for backwards\n-  // compatibility\n-\n-  /**\n-   * Creates a shallow copy of this object, preserving the internal structure\n-   * by copying only references.  The keys and values themselves are not\n-   * <code>clone()</code>'d.  The cloned object maintains the same sequence.\n-   *\n-   * @return A clone of this instance.  \n-   *\n-   * @exception CloneNotSupportedException if clone is not supported by a\n-   * subclass.\n-   */\n-  public Object clone () throws CloneNotSupportedException {\n-    // yes, calling super.clone() silly since we're just blowing away all\n-    // the stuff that super might be doing anyway, but for motivations on\n-    // this, see:\n-    // http://www.javaworld.com/javaworld/jw-01-1999/jw-01-object.html\n-    SequencedHashMap map = (SequencedHashMap)super.clone();\n-\n-    // create new, empty sentinel\n-    map.sentinel = createSentinel();\n-\n-    // create a new, empty entry map\n-    // note: this does not preserve the initial capacity and load factor.\n-    map.entries = new HashMap();\n-      \n-    // add all the mappings\n-    map.putAll(this);\n-\n-    // Note: We cannot just clone the hashmap and sentinel because we must\n-    // duplicate our internal structures.  Cloning those two will not clone all\n-    // the other entries they reference, and so the cloned hash map will not be\n-    // able to maintain internal consistency because there are two objects with\n-    // the same entries.  See discussion in the Entry implementation on why we\n-    // cannot implement a clone of the Entry (and thus why we need to recreate\n-    // everything).\n-\n-    return map;\n-  }\n-\n-  /**\n-   *  Returns the Map.Entry at the specified index\n-   *\n-   *  @exception ArrayIndexOutOfBoundsException if the specified index is\n-   *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n-   **/\n-  private Map.Entry getEntry(int index) {\n-    Entry pos = sentinel;\n-\n-    if(index < 0) {\n-      throw new ArrayIndexOutOfBoundsException(index + \" < 0\");\n-    }\n-\n-    // loop to one before the position\n-    int i = -1;\n-    while(i < (index-1) && pos.next != sentinel) {\n-      i++;\n-      pos = pos.next;\n-    }\n-    // pos.next is the requested position\n-    \n-    // if sentinel is next, past end of list\n-    if(pos.next == sentinel) {\n-      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + (i + 1));\n-    }\n-\n-    return pos.next;\n-  }\n-\n-  /**\n-   * Returns the key at the specified index.\n-   *\n-   *  @exception ArrayIndexOutOfBoundsException if the <code>index</code> is\n-   *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n-   */\n-  public Object get (int index)\n-  {\n-    return getEntry(index).getKey();\n-  }\n-\n-  /**\n-   * Returns the value at the specified index.\n-   *\n-   *  @exception ArrayIndexOutOfBoundsException if the <code>index</code> is\n-   *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n-   */\n-  public Object getValue (int index)\n-  {\n-    return getEntry(index).getValue();\n-  }\n-\n-  /**\n-   * Returns the index of the specified key.\n-   */\n-  public int indexOf (Object key)\n-  {\n-    Entry e = (Entry)entries.get(key);\n-    int pos = 0;\n-    while(e.prev != sentinel) {\n-      pos++;\n-      e = e.prev;\n-    }\n-    return pos;\n-  }\n-\n-  /**\n-   * Returns a key iterator.\n-   */\n-  public Iterator iterator ()\n-  {\n-    return keySet().iterator();\n-  }\n-\n-  /**\n-   * Returns the last index of the specified key.\n-   */\n-  public int lastIndexOf (Object key)\n-  {\n-    // keys in a map are guarunteed to be unique\n-    return indexOf(key);\n-  }\n-\n-  /**\n-   * Returns a List view of the keys rather than a set view.  The returned\n-   * list is unmodifiable.  This is required because changes to the values of\n-   * the list (using {@link java.util.ListIterator#set(Object)}) will\n-   * effectively remove the value from the list and reinsert that value at\n-   * the end of the list, which is an unexpected side effect of changing the\n-   * value of a list.  This occurs because changing the key, changes when the\n-   * mapping is added to the map and thus where it appears in the list.\n-   *\n-   * <P>An alternative to this method is to use {@link #keySet()}\n-   *\n-   * @see #keySet()\n-   * @return The ordered list of keys.  \n-   */\n-  public List sequence()\n-  {\n-    List l = new ArrayList(size());\n-    Iterator iter = keySet().iterator();\n-    while(iter.hasNext()) {\n-      l.add(iter.next());\n-    }\n-      \n-    return Collections.unmodifiableList(l);\n-  }\n-\n-  /**\n-   * Removes the element at the specified index.\n-   *\n-   * @param index The index of the object to remove.\n-   * @return      The previous value coressponding the <code>key</code>, or\n-   *              <code>null</code> if none existed.\n-   *\n-   * @exception ArrayIndexOutOfBoundsException if the <code>index</code> is\n-   * <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n-   */\n-  public Object remove (int index)\n-  {\n-    return remove(get(index));\n-  }\n-\n-  // per Externalizable.readExternal(ObjectInput)\n-\n-  /**\n-   *  Deserializes this map from the given stream.\n-   *\n-   *  @param in the stream to deserialize from\n-   *  @throws IOException if the stream raises it\n-   *  @throws ClassNotFoundException if the stream raises it\n-   */\n-  public void readExternal( ObjectInput in ) \n-    throws IOException, ClassNotFoundException \n-  {\n-    int size = in.readInt();    \n-    for(int i = 0; i < size; i++)  {\n-      Object key = in.readObject();\n-      Object value = in.readObject();\n-      put(key, value);\n-    }\n-  }\n-  \n-  /**\n-   *  Serializes this map to the given stream.\n-   *\n-   *  @param out  the stream to serialize to\n-   *  @throws IOException  if the stream raises it\n-   */\n-  public void writeExternal( ObjectOutput out ) throws IOException {\n-    out.writeInt(size());\n-    for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n-      out.writeObject(pos.getKey());\n-      out.writeObject(pos.getValue());\n-    }\n-  }\n-\n-  // add a serial version uid, so that if we change things in the future\n-  // without changing the format, we can still deserialize properly.\n-  private static final long serialVersionUID = 3380552487888102930L;\n+    }\n+\n+    /**\n+     * Gets an iterator over the keys.\n+     * \n+     * @return an iterator over the keys\n+     */\n+    public Iterator iterator() {\n+        return keySet().iterator();\n+    }\n+\n+    /**\n+     * Gets the last index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int lastIndexOf(Object key) {\n+        // keys in a map are guarunteed to be unique\n+        return indexOf(key);\n+    }\n+\n+    /**\n+     * Returns a List view of the keys rather than a set view.  The returned\n+     * list is unmodifiable.  This is required because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     *\n+     * <P>An alternative to this method is to use {@link #keySet()}\n+     *\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List sequence() {\n+        List l = new ArrayList(size());\n+        Iterator iter = keySet().iterator();\n+        while (iter.hasNext()) {\n+            l.add(iter.next());\n+        }\n+\n+        return Collections.unmodifiableList(l);\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index The index of the object to remove.\n+     * @return      The previous value coressponding the <code>key</code>, or\n+     *              <code>null</code> if none existed.\n+     *\n+     * @throws ArrayIndexOutOfBoundsException if the <code>index</code> is\n+     * <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+     */\n+    public Object remove(int index) {\n+        return remove(get(index));\n+    }\n+\n+    // per Externalizable.readExternal(ObjectInput)\n+\n+    /**\n+     * Deserializes this map from the given stream.\n+     *\n+     * @param in the stream to deserialize from\n+     * @throws IOException if the stream raises it\n+     * @throws ClassNotFoundException if the stream raises it\n+     */\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+        int size = in.readInt();\n+        for (int i = 0; i < size; i++) {\n+            Object key = in.readObject();\n+            Object value = in.readObject();\n+            put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Serializes this map to the given stream.\n+     *\n+     * @param out  the stream to serialize to\n+     * @throws IOException  if the stream raises it\n+     */\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        out.writeInt(size());\n+        for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+            out.writeObject(pos.getKey());\n+            out.writeObject(pos.getValue());\n+        }\n+    }\n+\n+    // add a serial version uid, so that if we change things in the future\n+    // without changing the format, we can still deserialize properly.\n+    private static final long serialVersionUID = 3380552487888102930L;\n \n }", "timestamp": 1038170915, "metainfo": ""}