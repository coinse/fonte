{"sha": "97850dae192aa9542547808a3304c8b1bcaf4a95", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r555925 | skestle | 2007-07-13 03:39:24 -0700 (Fri, 13 Jul 2007) | 2 lines          Added Edwin Tellman's patch for COLLECTIONS-243.       It all seems pretty reasonable, and it should all be checked again as the project is worked through     ------------------------------------------------------------------------     r471166 | scolebourne | 2006-11-04 03:33:22 -0800 (Sat, 04 Nov 2006) | 1 line          Removed Typed* containers such as TypedList and TypedMap as generics now provides type safety     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n import org.apache.commons.collections.list.PredicatedList;\n import org.apache.commons.collections.list.SynchronizedList;\n import org.apache.commons.collections.list.TransformedList;\n-import org.apache.commons.collections.list.TypedList;\n import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n      * This uses the {@link Collections Collections} implementation \n      * and is provided for completeness.\n      */\n-    public static final List EMPTY_LIST = Collections.EMPTY_LIST;\n-    \n+    public static final List<Object> EMPTY_LIST = Collections.<Object>emptyList();\n+\n     /**\n      * <code>ListUtils</code> should not normally be instantiated.\n      */\n      * @return  the intersection of those two lists\n      * @throws NullPointerException if either list is null\n      */\n-    public static List intersection(final List list1, final List list2) {\n-        final ArrayList result = new ArrayList();\n-        final Iterator iterator = list2.iterator();\n-\n-        while (iterator.hasNext()) {\n-            final Object o = iterator.next();\n-\n-            if (list1.contains(o)) {\n-                result.add(o);\n+    public static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n+        final List<E> result = new ArrayList<E>();\n+\n+        for (E e : list2) {\n+            if (list1.contains(e)) {\n+                result.add(e);\n             }\n         }\n-\n         return result;\n     }\n \n      * @return  a new list containing the results\n      * @throws NullPointerException if either list is null\n      */\n-    public static List subtract(final List list1, final List list2) {\n-        final ArrayList result = new ArrayList(list1);\n-        final Iterator iterator = list2.iterator();\n-\n-        while (iterator.hasNext()) {\n-            result.remove(iterator.next());\n-        }\n-\n+    public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n+        final ArrayList<E> result = new ArrayList<E>(list1);\n+        for (E e : list2) {\n+            result.remove(e);\n+        }\n         return result;\n     }\n \n      * @return  a new list containing the sum of those lists\n      * @throws NullPointerException if either list is null\n      */ \n-    public static List sum(final List list1, final List list2) {\n+    public static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n         return subtract(union(list1, list2), intersection(list1, list2));\n     }\n \n      * @return  a new list containing the union of those lists\n      * @throws NullPointerException if either list is null\n      */\n-    public static List union(final List list1, final List list2) {\n-        final ArrayList result = new ArrayList(list1);\n+    public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n+        final ArrayList<E> result = new ArrayList<E>(list1);\n         result.addAll(list2);\n         return result;\n     }\n      * @param list2  the second list, may be null\n      * @return whether the lists are equal by value comparison\n      */\n-    public static boolean isEqualList(final Collection list1, final Collection list2) {\n+    public static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n         if (list1 == list2) {\n             return true;\n         }\n             return false;\n         }\n \n-        Iterator it1 = list1.iterator();\n-        Iterator it2 = list2.iterator();\n+        Iterator<?> it1 = list1.iterator();\n+        Iterator<?> it2 = list2.iterator();\n         Object obj1 = null;\n         Object obj2 = null;\n \n      * @param list  the list to generate the hashCode for, may be null\n      * @return the hash code\n      */\n-    public static int hashCodeForList(final Collection list) {\n+    public static <E> int hashCodeForList(final Collection<E> list) {\n         if (list == null) {\n             return 0;\n         }\n         int hashCode = 1;\n-        Iterator it = list.iterator();\n-        Object obj = null;\n+        Iterator<E> it = list.iterator();\n         \n         while (it.hasNext()) {\n-            obj = it.next();\n+            E obj = it.next();\n             hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n         }\n         return hashCode;\n      * @throws NullPointerException if either parameter is null\n      * @since Commons Collections 3.2\n      */\n-    public static List retainAll(Collection collection, Collection retain) {\n-        List list = new ArrayList(Math.min(collection.size(), retain.size()));\n-\n-        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n-            Object obj = iter.next();\n+    public static <E> List<E> retainAll(Collection<E> collection, Collection<?> retain) {\n+        List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n+\n+        for (E obj : collection) {\n             if (retain.contains(obj)) {\n                 list.add(obj);\n             }\n      * @throws NullPointerException if either parameter is null\n      * @since Commons Collections 3.2\n      */\n-    public static List removeAll(Collection collection, Collection remove) {\n-        List list = new ArrayList();\n-        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n-            Object obj = iter.next();\n-            if (remove.contains(obj) == false) {\n+    public static <E> List<E> removeAll(Collection<E> collection, Collection<?> remove) {\n+        List<E> list = new ArrayList<E>();\n+        for (E obj : collection) {\n+            if (!remove.contains(obj)) {\n                 list.add(obj);\n             }\n         }\n      * @return a synchronized list backed by the given list\n      * @throws IllegalArgumentException  if the list is null\n      */\n-    public static List synchronizedList(List list) {\n+    public static <E> List<E> synchronizedList(List<E> list) {\n         return SynchronizedList.decorate(list);\n     }\n \n      * @return an unmodifiable list backed by the given list\n      * @throws IllegalArgumentException  if the list is null\n      */\n-    public static List unmodifiableList(List list) {\n+    public static <E> List<E> unmodifiableList(List<E> list) {\n         return UnmodifiableList.decorate(list);\n     }\n \n      * @return a predicated list backed by the given list\n      * @throws IllegalArgumentException  if the List or Predicate is null\n      */\n-    public static List predicatedList(List list, Predicate predicate) {\n+    public static <E> List<E> predicatedList(List<E> list, Predicate<E> predicate) {\n         return PredicatedList.decorate(list, predicate);\n     }\n \n-    /**\n-     * Returns a typed list backed by the given list.\n-     * <p>\n-     * Only objects of the specified type can be added to the list.\n-     * \n-     * @param list  the list to limit to a specific type, must not be null\n-     * @param type  the type of objects which may be added to the list\n-     * @return a typed list backed by the specified list\n-     */\n-    public static List typedList(List list, Class type) {\n-        return TypedList.decorate(list, type);\n-    }\n-    \n     /**\n      * Returns a transformed list backed by the given list.\n      * <p>\n      * @return a transformed list backed by the given list\n      * @throws IllegalArgumentException  if the List or Transformer is null\n      */\n-    public static List transformedList(List list, Transformer transformer) {\n+    public static <E> List<E> transformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n         return TransformedList.decorate(list, transformer);\n     }\n     \n      * @return a lazy list backed by the given list\n      * @throws IllegalArgumentException  if the List or Factory is null\n      */\n-    public static List lazyList(List list, Factory factory) {\n+    public static <E> List<E> lazyList(List<E> list, Factory<? extends E> factory) {\n         return LazyList.decorate(list, factory);\n     }\n \n      * @return a fixed-size list backed by that list\n      * @throws IllegalArgumentException  if the List is null\n      */\n-    public static List fixedSizeList(List list) {\n+    public static <E> List<E> fixedSizeList(List<E> list) {\n         return FixedSizeList.decorate(list);\n     }\n ", "timestamp": 1252994149, "metainfo": ""}