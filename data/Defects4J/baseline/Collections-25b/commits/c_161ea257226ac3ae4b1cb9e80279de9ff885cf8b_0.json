{"sha": "161ea257226ac3ae4b1cb9e80279de9ff885cf8b", "log": "Javadoc fixes.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/map/CompositeMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/CompositeMap.java\n \n     /**\n      * Gets a hash code for the Map as per the Map specification.\n+     * {@inheritDoc}\n      */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n      * <p>\n      * The value specified is returned when a missing key is found.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param defaultValue  the default value to return when the key is not found\n      * @return a new defaulting map\n      * The factory specified is called when a missing key is found.\n      * The result will be returned as the result of the map get(key) method.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use to create entries, must not be null\n      * @return a new defaulting map\n      * The key is passed to the transformer as the input, and the result\n      * will be returned as the result of the map get(key) method.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param transformer  the transformer to use as a factory to create entries, must not be null\n      * @return a new defaulting map\n--- a/src/main/java/org/apache/commons/collections/map/FixedSizeMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/FixedSizeMap.java\n     /**\n      * Factory method to create a fixed size map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new fixed size map\n      * @throws IllegalArgumentException if map is null\n--- a/src/main/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n     /**\n      * Factory method to create a fixed size sorted map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new fixed size sorted map\n      * @throws IllegalArgumentException if map is null\n--- a/src/main/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LRUMap.java\n      * This is fixed in version 3.1 onwards.\n      *\n      * @param entry  the entry to be removed\n+     * @return {@code true}\n      */\n     protected boolean removeLRU(LinkEntry<K, V> entry) {\n         return true;\n--- a/src/main/java/org/apache/commons/collections/map/LazyMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LazyMap.java\n     /**\n      * Factory method to create a lazily instantiated map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @return a new lazy map\n     /**\n      * Factory method to create a lazily instantiated map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @return a new lazy map\n--- a/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n     /**\n      * Factory method to create a lazily instantiated sorted map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n+     * @return a new lazy sorted map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n     public static <K, V> LazySortedMap<K, V> lazySortedMap(SortedMap<K, V> map, Factory<? extends V> factory) {\n     /**\n      * Factory method to create a lazily instantiated sorted map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n+     * @return a new lazy sorted map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n     public static <K, V> LazySortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n--- a/src/main/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/ListOrderedMap.java\n      * <p>\n      * An <code>ArrayList</code> is used to retain order.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n+     * @return a new list ordered map\n      * @throws IllegalArgumentException if map is null\n      */\n     public static <K, V> ListOrderedMap<K, V> listOrderedMap(Map<K, V> map) {\n      * Sets the value at the specified index.\n      *\n      * @param index  the index of the value to set\n+     * @param value  the new value to set\n      * @return the previous value at that index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @since 3.2\n--- a/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n      * Decorates the specified map to add the MultiKeyMap API and fast query.\n      * The map must not be null and must be empty.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, not null\n+     * @return a new multi key map\n      * @throws IllegalArgumentException if the map is null or not empty\n      */\n     public static <K, V> MultiKeyMap<K, V> multiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n      */\n     public boolean containsKey(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 return true;\n      */\n     public V get(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 return true;\n      * @param key3  the third key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry, Object key1, Object key2, Object key3) {\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+                                 Object key1, Object key2, Object key3) {\n         MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 3 &&\n      */\n     public V get(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 return true;\n      * @param key4  the fourth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry, Object key1, Object key2, Object key3, Object key4) {\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+                                 Object key1, Object key2, Object key3, Object key4) {\n         MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 4 &&\n      */\n     public V get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 return true;\n--- a/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n      * Creates a map which wraps the given map and\n      * maps keys to ArrayLists.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to wrap\n+     * @return a new multi-value map\n      */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n      * Creates a map which decorates the given <code>map</code> and\n      * maps keys to collections of type <code>collectionClass</code>.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to wrap\n      * @param collectionClass  the type of the collection class\n+     * @return a new multi-value map\n      */\n     public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map,\n                                                                                     Class<C> collectionClass) {\n      * Creates a map which decorates the given <code>map</code> and\n      * creates the value collections using the supplied <code>collectionFactory</code>.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate\n      * @param collectionFactory  the collection factory (must return a Collection object).\n+     * @return a new multi-value map\n      */\n     public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map,\n                                                                                     Factory<C> collectionFactory) {\n--- a/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n     /**\n      * All expired entries are removed from the map prior to determining the\n      * contains result.\n+     * {@inheritDoc}\n      */\n     @Override\n     public boolean containsKey(Object key) {\n     /**\n      * All expired entries are removed from the map prior to determining the\n      * contains result.\n+     * {@inheritDoc}\n      */\n     @Override\n     public boolean containsValue(Object value) {\n     }\n \n     /**\n-     * All expired entries are removed from the map prior to returning the entry\n-     * set.\n+     * All expired entries are removed from the map prior to returning the entry set.\n+     * {@inheritDoc}\n      */\n     @Override\n     public Set<Entry<K, V>> entrySet() {\n     }\n \n     /**\n-     * All expired entries are removed from the map prior to returning the entry\n-     * value.\n+     * All expired entries are removed from the map prior to returning the entry value.\n+     * {@inheritDoc}\n      */\n     @Override\n     public V get(Object key) {\n     }\n \n     /**\n-     * All expired entries are removed from the map prior to determining if it\n-     * is empty.\n+     * All expired entries are removed from the map prior to determining if it is empty.\n+     * {@inheritDoc}\n      */\n     @Override\n     public boolean isEmpty() {\n     }\n \n     /**\n-     * Determines if the given expiration time is less than <code>now</code>\n+     * Determines if the given expiration time is less than <code>now</code>.\n      * \n      * @param now the time in milliseconds used to compare against the\n      *        expiration time.\n     }\n \n     /**\n-     * All expired entries are removed from the map prior to returning the key\n-     * set.\n+     * All expired entries are removed from the map prior to returning the key set.\n+     * {@inheritDoc}\n      */\n     @Override\n     public Set<K> keySet() {\n     }\n \n     /**\n-     * Add the given key-value pair to this map as well as recording the entry's\n-     * expiration time based on the current time in milliseconds,\n-     * <code>now</code> and this map's {@link #expiringPolicy}.\n+     * Add the given key-value pair to this map as well as recording the entry's expiration time based on\n+     * the current time in milliseconds, <code>now</code> and this map's {@link #expiringPolicy}.\n      */\n     private V put(K key, V value, long now) {\n         // record expiration time of new entry\n     /**\n      * Normal {@link Map#remove(Object)} behavior with the addition of removing\n      * any expiration entry as well.\n+     * {@inheritDoc}\n      */\n     @Override\n     public V remove(Object key) {\n \n     /**\n      * All expired entries are removed from the map prior to returning the size.\n+     * {@inheritDoc}\n      */\n     @Override\n     public int size() {\n     }\n \n     /**\n-     * All expired entries are removed from the map prior to returning the value\n-     * collection.\n+     * All expired entries are removed from the map prior to returning the value collection.\n+     * {@inheritDoc}\n      */\n     @Override\n     public Collection<V> values() {\n--- a/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n      * If there are any elements already in the list being decorated, they\n      * are validated.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @return a new predicated map\n      * @throws IllegalArgumentException if the map is null\n      */\n     public static <K, V> PredicatedMap<K, V> predicatedMap(Map<K, V> map,\n      * Override to validate an object set into the map via <code>setValue</code>.\n      * \n      * @param value  the value to validate\n+     * @return the value itself\n      * @throws IllegalArgumentException if invalid\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n      * If there are any elements already in the list being decorated, they\n      * are validated.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @return a new predicated sorted map\n      * @throws IllegalArgumentException if the map is null\n      */\n     public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n--- a/src/main/java/org/apache/commons/collections/map/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedMap.java\n      * are NOT transformed.\n      * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @return a new transformed map\n      * @throws IllegalArgumentException if map is null\n      */\n     public static <K, V> TransformedMap<K, V> transformingMap(Map<K, V> map,\n      * will be transformed by this method.\n      * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @return a new transformed map\n      * @throws IllegalArgumentException if map is null\n      * @since 3.2\n      */\n      * The transformer itself may throw an exception if necessary.\n      *\n      * @param object  the object to transform\n-     * @throws the transformed object\n+     * @return the transformed object\n      */\n     protected K transformKey(K object) {\n         if (keyTransformer == null) {\n      * The transformer itself may throw an exception if necessary.\n      *\n      * @param object  the object to transform\n-     * @throws the transformed object\n+     * @return the transformed object\n      */\n     protected V transformValue(V object) {\n         if (valueTransformer == null) {\n      * The transformer itself may throw an exception if necessary.\n      *\n      * @param map  the map to transform\n-     * @throws the transformed object\n+     * @return the transformed object\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected Map<K, V> transformMap(Map<? extends K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n     /**\n      * Factory method to create a transforming sorted map.\n      * <p>\n-     * If there are any elements already in the map being decorated, they\n-     * are NOT transformed.\n+     * If there are any elements already in the map being decorated, they are NOT transformed.\n      * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the predicate to validate the keys, null means no transformation\n      * @param valueTransformer  the predicate to validate to values, null means no transformation\n+     * @return a new transformed sorted map\n      * @throws IllegalArgumentException if the map is null\n      */\n     public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(SortedMap<K, V> map,\n      * will be transformed by this method.\n      * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @return a new transformed sorted map\n      * @throws IllegalArgumentException if map is null\n      * @since 3.2\n      */\n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n     /**\n      * Factory method to create an unmodifiable set of Map Entry objects.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param set  the set to decorate, must not be null\n+     * @return a new unmodifiable entry set\n      * @throws IllegalArgumentException if set is null\n      */\n     public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableMap.java\n     /**\n      * Factory method to create an unmodifiable map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n+     * @return a new unmodifiable map\n      * @throws IllegalArgumentException if map is null\n      */\n     public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n     /**\n      * Factory method to create an unmodifiable sorted map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n+     * @return a new ordered map\n      * @throws IllegalArgumentException if map is null\n      */\n     public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(OrderedMap<K, V> map) {\n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n     /**\n      * Factory method to create an unmodifiable sorted map.\n      * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n+     * @return a new unmodifiable sorted map\n      * @throws IllegalArgumentException if map is null\n      */\n     public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {", "timestamp": 1347051189, "metainfo": ""}