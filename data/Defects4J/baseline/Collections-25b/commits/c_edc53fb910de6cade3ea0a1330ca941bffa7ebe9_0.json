{"sha": "edc53fb910de6cade3ea0a1330ca941bffa7ebe9", "log": "Convert three tab spacing to four tab spacing   ", "commit": "\n--- a/src/java/org/apache/commons/collections/Bag.java\n+++ b/src/java/org/apache/commons/collections/Bag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.9 2003/05/11 14:14:58 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.10 2003/05/16 14:20:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * which unfortunately will break backwards compatibility with this version.\n  *\n  * @since Commons Collections 2.0\n- * @version $Revision: 1.9 $ $Date: 2003/05/11 14:14:58 $\n+ * @version $Revision: 1.10 $ $Date: 2003/05/16 14:20:54 $\n  * \n  * @author Chuck Burdick\n  * @author Stephen Colebourne\n  */\n public interface Bag extends Collection {\n-    \n-   /**\n-    * Returns the number of occurrences (cardinality) of the given\n-    * object currently in the bag. If the object does not exist in the\n-    * bag, return 0.\n-    * \n-    * @param object  the object to search for\n-    * @return the number of occurrences of the object, zero if not found\n-    */\n-   int getCount(Object object);\n-\n-   /**\n-    * <i>(Violation)</i>\n-    * Adds one copy the specified object to the Bag.\n-    * <p>\n-    * If the object is already in the {@link #uniqueSet()} then increment its\n-    * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n-    * {@link #uniqueSet()} and report its count as 1.\n-    * <p>\n-    * Since this method always increases the size of the bag,\n-    * according to the {@link Collection#add(Object)} contract, it \n-    * should always return <code>true</code>.  Since it sometimes returns\n-    * <code>false</code>, this method violates the contract.  A future\n-    * version of this method will comply by always returning <code>true</code>.\n-    *\n-    * @param object  the object to add\n-    * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n-    */\n-   boolean add(Object object);\n-\n-   /**\n-    * Adds <code>nCopies</code> copies of the specified object to the Bag.\n-    * <p>\n-    * If the object is already in the {@link #uniqueSet()} then increment its\n-    * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n-    * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n-    * \n-    * @param object  the object to search for\n-    * @param nCopies  the number of copies to add\n-    * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n-    */\n-   boolean add(Object object, int nCopies);\n-\n-   /**\n-    * <i>(Violation)</i>\n-    * Removes all occurrences of the given object from the bag.\n-    * <p>\n-    * This will also remove the object from the {@link #uniqueSet()}.\n-    * <p>\n-    * According to the {@link Collection#remove(Object)} method,\n-    * this method should only remove the <i>first</i> occurrence of the\n-    * given object, not <i>all</i> occurrences.  A future version of this\n-    * method will comply with the contract by only removing one occurrence\n-    * of the given object.\n-    *\n-    * @return <code>true</code> if this call changed the collection\n-    */\n-   boolean remove(Object object);\n-\n-   /**\n-    * Removes <code>nCopies</code> copies of the specified object from the Bag.\n-    * <p>\n-    * If the number of copies to remove is greater than the actual number of\n-    * copies in the Bag, no error is thrown.\n-    * \n-    * @param object  the object to remove\n-    * @param nCopies  the number of copies to remove\n-    * @return <code>true</code> if this call changed the collection\n-    */\n-   boolean remove(Object object, int nCopies);\n-\n-   /**\n-    * Returns a {@link Set} of unique elements in the Bag.\n-    * <p>\n-    * Uniqueness constraints are the same as those in {@link java.util.Set}.\n-    * \n-    * @return the Set of unique Bag elements\n-    */\n-   Set uniqueSet();\n-\n-   /**\n-    * Returns the total number of items in the bag across all types.\n-    * \n-    * @return the total size of the Bag\n-    */\n-   int size();\n-\n-   /**\n-    * <i>(Violation)</i>\n-    * Returns <code>true</code> if the bag contains all elements in\n-    * the given collection, respecting cardinality.  That is, if the\n-    * given collection <code>coll</code> contains <code>n</code> copies\n-    * of a given object, calling {@link #getCount(Object)} on that object must\n-    * be <code>&gt;= n</code> for all <code>n</code> in <code>coll</code>.\n-    * <p>\n-    * The {@link Collection#containsAll(Collection)} method specifies\n-    * that cardinality should <i>not</i> be respected; this method should\n-    * return true if the bag contains at least one of every object contained\n-    * in the given collection.  A future version of this method will comply\n-    * with that contract.\n-    * \n-    * @param coll  the collection to check against\n-    * @return <code>true</code> if the Bag contains all the collection\n-    */\n-   boolean containsAll(Collection coll);\n-\n-   /**\n-    * <i>(Violation)</i>\n-    * Remove all elements represented in the given collection,\n-    * respecting cardinality.  That is, if the given collection\n-    * <code>coll</code> contains <code>n</code> copies of a given object,\n-    * the bag will have <code>n</code> fewer copies, assuming the bag\n-    * had at least <code>n</code> copies to begin with.\n-    *\n-    * <P>The {@link Collection#removeAll(Collection)} method specifies\n-    * that cardinality should <i>not</i> be respected; this method should\n-    * remove <i>all</i> occurrences of every object contained in the \n-    * given collection.  A future version of this method will comply\n-    * with that contract.\n-    *\n-    * @param coll  the collection to remove\n-    * @return <code>true</code> if this call changed the collection\n-    */\n-   boolean removeAll(Collection coll);\n-\n-   /**\n-    * <i>(Violation)</i>\n-    * Remove any members of the bag that are not in the given\n-    * collection, respecting cardinality.  That is, if the given\n-    * collection <code>coll</code> contains <code>n</code> copies of a\n-    * given object and the bag has <code>m &gt; n</code> copies, then\n-    * delete <code>m - n</code> copies from the bag.  In addition, if\n-    * <code>e</code> is an object in the bag but\n-    * <code>!coll.contains(e)</code>, then remove <code>e</code> and any\n-    * of its copies.\n-    *\n-    * <P>The {@link Collection#retainAll(Collection)} method specifies\n-    * that cardinality should <i>not</i> be respected; this method should\n-    * keep <i>all</i> occurrences of every object contained in the \n-    * given collection.  A future version of this method will comply\n-    * with that contract.\n-    *\n-    * @param coll  the collection to retain\n-    * @return <code>true</code> if this call changed the collection\n-    */\n-   boolean retainAll(Collection coll);\n-\n-   /**\n-    * Returns an {@link Iterator} over the entire set of members,\n-    * including copies due to cardinality. This iterator is fail-fast\n-    * and will not tolerate concurrent modifications.\n-    * \n-    * @return iterator over all elements in the Bag\n-    */\n-   Iterator iterator();\n-   \n+\n+    /**\n+     * Returns the number of occurrences (cardinality) of the given\n+     * object currently in the bag. If the object does not exist in the\n+     * bag, return 0.\n+     * \n+     * @param object  the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    int getCount(Object object);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Adds one copy the specified object to the Bag.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as 1.\n+     * <p>\n+     * Since this method always increases the size of the bag,\n+     * according to the {@link Collection#add(Object)} contract, it \n+     * should always return <code>true</code>.  Since it sometimes returns\n+     * <code>false</code>, this method violates the contract.  A future\n+     * version of this method will comply by always returning <code>true</code>.\n+     *\n+     * @param object  the object to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    boolean add(Object object);\n+\n+    /**\n+     * Adds <code>nCopies</code> copies of the specified object to the Bag.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n+     * \n+     * @param object  the object to add\n+     * @param nCopies  the number of copies to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    boolean add(Object object, int nCopies);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Removes all occurrences of the given object from the bag.\n+     * <p>\n+     * This will also remove the object from the {@link #uniqueSet()}.\n+     * <p>\n+     * According to the {@link Collection#remove(Object)} method,\n+     * this method should only remove the <i>first</i> occurrence of the\n+     * given object, not <i>all</i> occurrences.  A future version of this\n+     * method will comply with the contract by only removing one occurrence\n+     * of the given object.\n+     *\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean remove(Object object);\n+\n+    /**\n+     * Removes <code>nCopies</code> copies of the specified object from the Bag.\n+     * <p>\n+     * If the number of copies to remove is greater than the actual number of\n+     * copies in the Bag, no error is thrown.\n+     * \n+     * @param object  the object to remove\n+     * @param nCopies  the number of copies to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean remove(Object object, int nCopies);\n+\n+    /**\n+     * Returns a {@link Set} of unique elements in the Bag.\n+     * <p>\n+     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n+     * \n+     * @return the Set of unique Bag elements\n+     */\n+    Set uniqueSet();\n+\n+    /**\n+     * Returns the total number of items in the bag across all types.\n+     * \n+     * @return the total size of the Bag\n+     */\n+    int size();\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Returns <code>true</code> if the bag contains all elements in\n+     * the given collection, respecting cardinality.  That is, if the\n+     * given collection <code>coll</code> contains <code>n</code> copies\n+     * of a given object, calling {@link #getCount(Object)} on that object must\n+     * be <code>&gt;= n</code> for all <code>n</code> in <code>coll</code>.\n+     * <p>\n+     * The {@link Collection#containsAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * return true if the bag contains at least one of every object contained\n+     * in the given collection.  A future version of this method will comply\n+     * with that contract.\n+     * \n+     * @param coll  the collection to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    boolean containsAll(Collection coll);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Remove all elements represented in the given collection,\n+     * respecting cardinality.  That is, if the given collection\n+     * <code>coll</code> contains <code>n</code> copies of a given object,\n+     * the bag will have <code>n</code> fewer copies, assuming the bag\n+     * had at least <code>n</code> copies to begin with.\n+     *\n+     * <P>The {@link Collection#removeAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * remove <i>all</i> occurrences of every object contained in the \n+     * given collection.  A future version of this method will comply\n+     * with that contract.\n+     *\n+     * @param coll  the collection to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean removeAll(Collection coll);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Remove any members of the bag that are not in the given\n+     * collection, respecting cardinality.  That is, if the given\n+     * collection <code>coll</code> contains <code>n</code> copies of a\n+     * given object and the bag has <code>m &gt; n</code> copies, then\n+     * delete <code>m - n</code> copies from the bag.  In addition, if\n+     * <code>e</code> is an object in the bag but\n+     * <code>!coll.contains(e)</code>, then remove <code>e</code> and any\n+     * of its copies.\n+     *\n+     * <P>The {@link Collection#retainAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * keep <i>all</i> occurrences of every object contained in the \n+     * given collection.  A future version of this method will comply\n+     * with that contract.\n+     *\n+     * @param coll  the collection to retain\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean retainAll(Collection coll);\n+\n+    /**\n+     * Returns an {@link Iterator} over the entire set of members,\n+     * including copies due to cardinality. This iterator is fail-fast\n+     * and will not tolerate concurrent modifications.\n+     * \n+     * @return iterator over all elements in the Bag\n+     */\n+    Iterator iterator();\n+\n }", "timestamp": 1053094854, "metainfo": ""}