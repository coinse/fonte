{"sha": "ac857ee1e7833139f57964d3176840235d26a5f2", "log": "Complete javadoc, minor formatting.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/main/java/org/apache/commons/collections/MapUtils.java\n     /**\n      * Gets from a Map in a null-safe manner.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map, <code>null</code> if null map input\n      * <p>\n      * The String is obtained via <code>toString</code>.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a String, <code>null</code> if null map input\n      * <code>false</code> and non-zero returns <code>true</code>.\n      * Otherwise, <code>null</code> is returned.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Boolean, <code>null</code> if null map input\n      * returning <code>null</code> if the conversion fails.\n      * Otherwise, <code>null</code> is returned.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Number, <code>null</code> if null map input\n      * <p>\n      * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Byte, <code>null</code> if null map input\n      * <p>\n      * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Short, <code>null</code> if null map input\n      * <p>\n      * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Integer, <code>null</code> if null map input\n      * <p>\n      * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Long, <code>null</code> if null map input\n      * <p>\n      * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Float, <code>null</code> if null map input\n      * <p>\n      * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Double, <code>null</code> if null map input\n      * If the value returned from the specified map is not a Map then\n      * <code>null</code> is returned.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Map, <code>null</code> if null map input\n     // Type safe getters with default values\n     //-------------------------------------------------------------------------\n     /**\n-     *  Looks up the given key in the given map, converting null into the\n-     *  given default value.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null\n-     *  @return  the value in the map, or defaultValue if the original value\n-     *    is null or the map is null\n+     * Looks up the given key in the given map, converting null into the\n+     * given default value.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null\n+     * @return  the value in the map, or defaultValue if the original value\n+     *   is null or the map is null\n      */\n     public static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n         if (map != null) {\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a string, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a string, or defaultValue if the\n-     *    original value is null, the map is null or the string conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a string, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a string, or defaultValue if the\n+     *   original value is null, the map is null or the string conversion fails\n      */\n     public static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n         String answer = getString(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a boolean, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a boolean, or defaultValue if the\n-     *    original value is null, the map is null or the boolean conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a boolean, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a boolean, or defaultValue if the\n+     *   original value is null, the map is null or the boolean conversion fails\n      */\n     public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n         Boolean answer = getBoolean(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a number, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a number, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n         Number answer = getNumber(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a byte, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a byte, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n         Byte answer = getByte(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a short, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a short, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n         Short answer = getShort(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  an integer, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * an integer, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n         Integer answer = getInteger(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a long, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a long, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n         Long answer = getLong(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a float, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a float, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n         Float answer = getFloat(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a double, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the number conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a double, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n      */\n     public static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n         Double answer = getDouble(map, key);\n     }\n \n     /**\n-     *  Looks up the given key in the given map, converting the result into\n-     *  a map, using the default value if the the conversion fails.\n-     *\n-     *  @param map  the map whose value to look up\n-     *  @param key  the key of the value to look up in that map\n-     *  @param defaultValue  what to return if the value is null or if the\n-     *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the\n-     *    original value is null, the map is null or the map conversion\n-     *    fails\n+     * Looks up the given key in the given map, converting the result into\n+     * a map, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the map conversion fails\n      */\n     public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n         Map<?, ?> answer = getMap(map, key);\n      * <code>false</code> and non-zero returns <code>true</code>.\n      * Otherwise, <code>false</code> is returned.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a Boolean, <code>false</code> if null map input\n      * <p>\n      * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a byte, <code>0</code> if null map input\n      * <p>\n      * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a short, <code>0</code> if null map input\n      * <p>\n      * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as an int, <code>0</code> if null map input\n      * <p>\n      * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a long, <code>0L</code> if null map input\n      * <p>\n      * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a float, <code>0.0F</code> if null map input\n      * <p>\n      * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to use\n      * @param key  the key to look up\n      * @return the value in the Map as a double, <code>0.0</code> if null map input\n      * <code>false</code> and non-zero returns <code>true</code>.\n      * Otherwise, <code>defaultValue</code> is returned.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n      */\n     public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n      * <p>\n      * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n      */\n     public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n      * <p>\n      * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n      */\n     public static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n      * <p>\n      * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n      */\n     public static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n      * <p>\n      * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n      */\n     public static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n      * <p>\n      * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n      */\n     public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n      * <p>\n      * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n-     * @param map  the map to use\n-     * @param key  the key to look up\n-     * @param defaultValue  return if the value is null or if the\n-     *     conversion fails\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n      * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n      */\n     public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n      * Gets a new Properties object initialised with the values from a Map.\n      * A null input will return an empty properties object.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to convert to a Properties object\n      * @return the properties object\n      */\n      *  If <code>null</code>, the text 'null' is output.\n      * @throws NullPointerException if the stream is <code>null</code>\n      */\n-    public static void verbosePrint(\n-        final PrintStream out,\n-        final Object label,\n-        final Map<?, ?> map) {\n-\n+    public static void verbosePrint(final PrintStream out, final Object label, final Map<?, ?> map) {\n         verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), false);\n     }\n \n      *\n      * @param out  the stream to print to, must not be null\n      * @param label  The label to be used, may be <code>null</code>.\n-     *  If <code>null</code>, the label is not output.\n-     *  It typically represents the name of the property in a bean or similar.\n+     *   If <code>null</code>, the label is not output.\n+     *   It typically represents the name of the property in a bean or similar.\n      * @param map  The map to print, may be <code>null</code>.\n-     *  If <code>null</code>, the text 'null' is output.\n+     *   If <code>null</code>, the text 'null' is output.\n      * @throws NullPointerException if the stream is <code>null</code>\n      */\n-    public static void debugPrint(\n-        final PrintStream out,\n-        final Object label,\n-        final Map<?, ?> map) {\n-\n+    public static void debugPrint(final PrintStream out, final Object label, final Map<?, ?> map) {\n         verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), true);\n     }\n \n      *\n      * @param out  the stream to print to\n      * @param label  the label to be used, may be <code>null</code>.\n-     *  If <code>null</code>, the label is not output.\n-     *  It typically represents the name of the property in a bean or similar.\n+     *   If <code>null</code>, the label is not output.\n+     *   It typically represents the name of the property in a bean or similar.\n      * @param map  the map to print, may be <code>null</code>.\n-     *  If <code>null</code>, the text 'null' is output\n+     *   If <code>null</code>, the text 'null' is output\n      * @param lineage  a stack consisting of any maps in which the previous\n-     *  argument is contained. This is checked to avoid infinite recursion when\n-     *  printing the output\n+     *   argument is contained. This is checked to avoid infinite recursion when\n+     *   printing the output\n      * @param debug  flag indicating whether type names should be output.\n      * @throws NullPointerException if the stream is <code>null</code>\n      */\n-    private static void verbosePrintInternal(\n-        final PrintStream out,\n-        final Object label,\n-        final Map<?, ?> map,\n-        final ArrayStack<Map<?, ?>> lineage,\n-        final boolean debug) {\n-\n+    private static void verbosePrintInternal(final PrintStream out, final Object label, final Map<?, ?> map,\n+                                             final ArrayStack<Map<?, ?>> lineage, final boolean debug) {\n         printIndent(out, lineage.size());\n \n         if (map == null) {\n      * different keys, the returned map will map one of those keys to the\n      * value, but the exact key which will be mapped is undefined.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to invert, may not be null\n      * @return a new HashMap containing the inverted data\n      * @throws NullPointerException if the map is null\n      * Note that this method can be used to circumvent the map's\n      * value type at runtime.\n      *\n+     * @param <K>  the key type\n      * @param map  the map to add to, may not be null\n      * @param key  the key\n      * @param value  the value, null converted to \"\"\n      * });\n      * </pre>\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to populate, must not be null\n      * @param array  an array to populate from, null ignored\n      * @return the input map\n      * @throws NullPointerException  if map is null\n-     * @throws IllegalArgumentException  if sub-array or entry matching used and an\n-     *  entry is invalid\n+     * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n      * @throws ClassCastException if the array contents is mixed\n      * @since 3.2\n      */\n      *\n      * This method uses the implementation in {@link java.util.Collections Collections}.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to synchronize, must not be null\n      * @return a synchronized map backed by the given map\n      */\n      * <p>\n      * This method uses the implementation in the decorators subpackage.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to make unmodifiable, must not be null\n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      * It is important not to use the original map after invoking this method,\n      * as it is a backdoor for adding invalid objects.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to predicate, must not be null\n      * @param keyPred  the predicate for keys, null means no check\n      * @param valuePred  the predicate for values, null means no check\n      * If there are any elements already in the map being decorated, they\n      * are NOT transformed.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to transform, must not be null, typically empty\n      * @param keyTransformer  the transformer for the map keys, null means no transformation\n      * @param valueTransformer  the transformer for the map values, null means no transformation\n      * existing elements can be changed (for instance, via the\n      * {@link Map#put(Object,Object)} method).\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map whose size to fix, must not be null\n      * @return a fixed-size map backed by that map\n      * @throws IllegalArgumentException  if the Map is null\n      * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n      * instance is the value for the <code>\"test\"</code> key in the map.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n      * calls back to the factory Transformer to populate itself, all within the\n      * same synchronized block.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to make lazy, must not be null\n      * @param transformerFactory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n      * If a key is added twice, the order is determined by the first add.\n      * The order is observed through the keySet, values and entrySet.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to order, must not be null\n      * @return an ordered map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      * Creates a mult-value map backed by the given map which returns\n      * collections of type ArrayList.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to decorate\n      * @return a multi-value map backed by the given map which returns ArrayLists of values.\n      * @see MultiValueMap\n      * Creates a multi-value map backed by the given map which returns\n      * collections of the specified type.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <C>  the collection class type\n      * @param map  the map to decorate\n      * @param collectionClass  the type of collections to return from the map (must contain public no-arg constructor\n-     *  and extend Collection).\n+     *   and extend Collection).\n      * @return a multi-value map backed by the given map which returns collections of the specified type\n      * @see MultiValueMap\n      * @since 3.2\n      * Creates a multi-value map backed by the given map which returns\n      * collections created by the specified collection factory.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <C>  the collection class type\n      * @param map  the map to decorate\n      * @param collectionFactory  a factor which creates collection objects\n      * @return a multi-value map backed by the given map which returns collections\n-     * created by the specified collection factory\n+     *   created by the specified collection factory\n      * @see MultiValueMap\n      * @since 3.2\n      */\n      *\n      * This method uses the implementation in {@link java.util.Collections Collections}.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to synchronize, must not be null\n      * @return a synchronized map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      * <p>\n      * This method uses the implementation in the decorators subpackage.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the sorted map to make unmodifiable, must not be null\n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      * It is important not to use the original map after invoking this method,\n      * as it is a backdoor for adding invalid objects.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to predicate, must not be null\n      * @param keyPred  the predicate for keys, null means no check\n      * @param valuePred  the predicate for values, null means no check\n      * If there are any elements already in the map being decorated, they\n      * are NOT transformed.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to transform, must not be null, typically empty\n      * @param keyTransformer  the transformer for the map keys, null means no transformation\n      * @param valueTransformer  the transformer for the map values, null means no transformation\n      * existing elements can be changed (for instance, via the\n      * {@link Map#put(Object,Object)} method).\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map whose size to fix, must not be null\n      * @return a fixed-size map backed by that map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n      * instance is the value for the <code>\"test\"</code> key.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap or Factory is null\n      */\n-    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n-            final Factory<? extends V> factory) {\n+    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n         return LazySortedMap.lazySortedMap(map, factory);\n     }\n \n      * calls back to the factory Transformer to populate itself, all within the\n      * same synchronized block.\n      *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map  the map to make lazy, must not be null\n      * @param transformerFactory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n     }\n \n     /**\n-     * <p>\n      * Populates a Map using the supplied <code>Transformer</code> to transform the collection\n      * values into keys, using the unaltered collection value as the value in the <code>Map</code>.\n-     * </p>\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map the <code>Map</code> to populate.\n      * @param collection the <code>Collection</code> to use as input values for the map.\n      * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n     }\n \n     /**\n-     * <p>\n      * Populates a Map using the supplied <code>Transformer</code>s to transform the collection\n      * values into keys and values.\n-     * </p>\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <E>  the type of object contained in the {@link Collection}\n      * @param map the <code>Map</code> to populate.\n      * @param collection the <code>Collection</code> to use as input values for the map.\n      * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n \n     /**\n      * Get the specified {@link Map} as an {@link IterableMap}.\n-     * @param <K>\n-     * @param <V>\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param map to wrap if necessary.\n      * @return IterableMap<K, V>\n      * @since 4.0\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n-        return map instanceof IterableMap ? (IterableMap<K, V>) map\n-                : new AbstractMapDecorator<K, V>(map) {\n-                };\n+        return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {};\n     }\n \n     /**\n      * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n-     * @param <K>\n-     * @param <V>\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n      * @param sortedMap to wrap if necessary\n      * @return {@link IterableSortedMap}<K, V>\n      * @since 4.0\n         if (sortedMap == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n-        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap\n-                : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n-                };\n+        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap :\n+                                                        new AbstractSortedMapDecorator<K, V>(sortedMap) {};\n     }\n \n }", "timestamp": 1358779523, "metainfo": ""}