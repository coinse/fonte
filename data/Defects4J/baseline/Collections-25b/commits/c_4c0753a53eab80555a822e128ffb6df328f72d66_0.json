{"sha": "4c0753a53eab80555a822e128ffb6df328f72d66", "log": "Refactor observed classes and packages to make better use of scoping   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ModificationEvent.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationEvent.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+import java.util.EventObject;\n+\n+/**\n+ * Base event class extended by each class that encapsulates event information.\n+ * <p>\n+ * This class can be used as is, but generally it is subclassed.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ModificationEvent extends EventObject {\n+\n+    /** The source collection */\n+    protected final Collection collection;\n+    /** The handler */\n+    protected final ModificationHandler handler;\n+    /** The event code */\n+    protected final int type;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param collection  the event source\n+     * @param handler  the handler\n+     * @param type  the event type\n+     */\n+    public ModificationEvent(\n+        final Collection collection,\n+        final ModificationHandler handler,\n+        final int type) {\n+\n+        super(collection);\n+        this.collection = collection;\n+        this.handler = handler;\n+        this.type = type;\n+    }\n+\n+    // Basic info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the collection the event is reporting on.\n+     * <p>\n+     * This method returns the <code>ObservedCollection</code> instance.\n+     * If this collection is wrapped, by a synchronized wrapper for example,\n+     * changing this collection will bypass the wrapper. For the synchronized\n+     * example, this will be OK so long as the event is processed in the same\n+     * thread and program stack as the modification was made in.\n+     * \n+     * @return the collection\n+     */\n+    public Collection getSourceCollection() {\n+        return collection;\n+    }\n+\n+    /**\n+     * Gets the handler of the events.\n+     * \n+     * @return the handler\n+     */\n+    public ModificationHandler getHandler() {\n+        return handler;\n+    }\n+\n+    /**\n+     * Gets the event type constant.\n+     * <p>\n+     * This is one of the <i>method</i> constants from {@link ModificationEventType}.\n+     * \n+     * @return the method event type constant\n+     */\n+    public int getType() {\n+        return type;\n+    }\n+\n+    // toString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of the event.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(64);\n+        buf.append(\"ObservedEvent[type=\");\n+        buf.append(ModificationEventType.toString(type));\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ModificationEventType.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationEventType.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+/**\n+ * Defines event constants for event handling and matching.\n+ * <p>\n+ * The constants in this class are of two types:\n+ * <ol>\n+ * <li>Methods - the base definitions (unique bits)\n+ * <li>Groups - combination definitions (method bits combined)\n+ * </ol>\n+ * <p>\n+ * Only a method constant may be compared using == to an event type.\n+ * This can include use in a switch statement\n+ * <p>\n+ * Any constant may be used for filtering.\n+ * They may combined using the bitwise OR, <code>|</code>.\n+ * They may negated using the bitwise NOT, <code>~</code>.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ModificationEventType {\n+    \n+    /** The method add(Object) */\n+    public static final int ADD =           0x00000001;\n+    /** The method add(int,Object) */\n+    public static final int ADD_INDEXED =   0x00000002;\n+    /** The method add(Object,int) */\n+    public static final int ADD_NCOPIES =   0x00000004;\n+    \n+    /** The method addAll(Collection) */\n+    public static final int ADD_ALL =       0x00000010;\n+    /** The method addAll(int,Collection) */\n+    public static final int ADD_ALL_INDEXED=0x00000020;\n+    \n+    /** The method remove(Object) */\n+    public static final int REMOVE =        0x00000100;\n+    /** The method remove(int) */\n+    public static final int REMOVE_INDEXED =0x00000200;\n+    /** The method remove(Object,int) */\n+    public static final int REMOVE_NCOPIES =0x00000400;\n+    \n+    /** The method removeAll(Collection) */\n+    public static final int REMOVE_ALL =    0x00001000;\n+    /** The method retainAll(Collection) */\n+    public static final int RETAIN_ALL =    0x00002000;\n+    /** The method clear() */\n+    public static final int CLEAR =         0x00004000;\n+    \n+    /** The method set(int,Object) */\n+    public static final int SET_INDEXED =   0x00010000;\n+\n+    /** All add methods */\n+    public static final int GROUP_ADD = ADD | ADD_INDEXED | ADD_NCOPIES | ADD_ALL | ADD_ALL_INDEXED;\n+    /** All methods that change without structure modification */\n+    public static final int GROUP_CHANGE = SET_INDEXED;\n+    /** All remove methods */\n+    public static final int GROUP_REMOVE = REMOVE | REMOVE_NCOPIES | REMOVE_INDEXED | REMOVE_ALL;\n+    /** All retain methods */\n+    public static final int GROUP_RETAIN = RETAIN_ALL;\n+    /** All clear methods */\n+    public static final int GROUP_CLEAR = CLEAR;\n+    /** All reducing methods (remove, retain and clear) */\n+    public static final int GROUP_REDUCE = GROUP_REMOVE | GROUP_CLEAR | GROUP_RETAIN;\n+    \n+    /** All indexed methods */\n+    public static final int GROUP_INDEXED = ADD_INDEXED | ADD_ALL_INDEXED | REMOVE_INDEXED | SET_INDEXED;\n+    /** All non indexed methods */\n+    public static final int GROUP_NON_INDEXED = ADD | ADD_NCOPIES | ADD_ALL | REMOVE | REMOVE_NCOPIES | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All bulk methods (xxxAll, clear, Bag nCopies) */\n+    public static final int GROUP_BULK =  ADD_NCOPIES | ADD_ALL | ADD_ALL_INDEXED | REMOVE_NCOPIES | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All non bulk methods */\n+    public static final int GROUP_NON_BULK = ADD | ADD_INDEXED | REMOVE | REMOVE_INDEXED | SET_INDEXED;\n+    /** All methods that modify the structure */\n+    public static final int GROUP_STRUCTURE_MODIFIED = \n+        ADD | ADD_NCOPIES | ADD_INDEXED | ADD_ALL | ADD_ALL_INDEXED | REMOVE | REMOVE_NCOPIES | REMOVE_INDEXED | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All non structure modifying methods */\n+    public static final int GROUP_NON_STRUCTURE_MODIFIED = SET_INDEXED;\n+\n+    /** All methods sent by a Collection */\n+    public static final int GROUP_FROM_COLLECTION = ADD | ADD_ALL | REMOVE | REMOVE_ALL | RETAIN_ALL | CLEAR;\n+    /** All methods sent by a Set */\n+    public static final int GROUP_FROM_SET = GROUP_FROM_COLLECTION;\n+    /** All methods sent by a List */\n+    public static final int GROUP_FROM_LIST = GROUP_FROM_COLLECTION | ADD_INDEXED | ADD_ALL_INDEXED | REMOVE_INDEXED | SET_INDEXED;\n+    /** All methods sent by a List */\n+    public static final int GROUP_FROM_BAG = GROUP_FROM_COLLECTION | ADD_NCOPIES | REMOVE_NCOPIES;\n+\n+    /** No methods */\n+    public static final int GROUP_NONE = 0x00000000;\n+    /** All methods */\n+    public static final int GROUP_ALL = 0xFFFFFFFF;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected ModificationEventType() {\n+        super();\n+    }\n+    \n+    /**\n+     * Gets a string version of a method event type.\n+     * \n+     * @param methodType  the method event type constant\n+     * @return a string description\n+     */\n+    public static String toString(final int methodType) {\n+        switch (methodType) {\n+            case ADD:\n+            return \"Add\";\n+            case ADD_INDEXED:\n+            return \"AddIndexed\";\n+            case ADD_NCOPIES:\n+            return \"AddNCopies\";\n+            case ADD_ALL:\n+            return \"AddAll\";\n+            case ADD_ALL_INDEXED:\n+            return \"AddAllIndexed\";\n+            case REMOVE:\n+            return \"Remove\";\n+            case REMOVE_NCOPIES:\n+            return \"RemoveNCopies\";\n+            case REMOVE_INDEXED:\n+            return \"RemoveIndexed\";\n+            case REMOVE_ALL:\n+            return \"RemoveAll\";\n+            case RETAIN_ALL:\n+            return \"RetainAll\";\n+            case CLEAR:\n+            return \"Clear\";\n+            case SET_INDEXED:\n+            return \"SetIndexed\";\n+            default:\n+            return \"Unknown\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ModificationHandler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandler.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+\n+\n+/**\n+ * Defines a handler for collection modification events.\n+ * <p>\n+ * This class defines the event handling methods, following the \n+ * <code>preXxx</code> and <code>postXxx</code> naming convention.\n+ * It also provides a default implementation that forwards to single methods.\n+ * <p>\n+ * This class could have been implemented as an interface, however to do so\n+ * would prevent the addition of extra events in the future. It does mean\n+ * that if you subclass this class, you must check it when you upgrade to a\n+ * later collections release.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public abstract class ModificationHandler {\n+    \n+    /** Singleton factory */\n+    static final ModificationHandlerFactory FACTORY = new Factory();\n+    \n+    /** The collection being observed */\n+    private ObservedCollection collection = null;\n+    \n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected ModificationHandler() {\n+        super();\n+    }\n+\n+    /**\n+     * Initialize the handler.\n+     * <p>\n+     * The handler cannot be used until this method is called.\n+     * However, the handler's setup methods can be called.\n+     * All other methods will throw NullPointerException until then.\n+     * \n+     * @param coll  the observed collection, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     * @throws IllegalStateException if init has already been called\n+     */\n+    void init(final ObservedCollection coll) {\n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        if (this.collection != null) {\n+            throw new IllegalArgumentException(\"init() has already been called\");\n+        }\n+        this.collection = coll;\n+    }\n+\n+    // Collection access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the observed collection.\n+     * \n+     * @return the observed collection\n+     */\n+    public Collection getCollection() {\n+        return collection;\n+    }\n+    \n+    // PreListeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the pre listeners active in the handler.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @return the listeners\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public Object[] getPreModificationListeners() {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Adds a pre listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * <p>\n+     * The listener does not necessarily have to be a listener in the classic\n+     * JavaBean sense. It is entirely up to the handler as to how it interprets\n+     * the listener parameter. A ClassCastException is thrown if the handler\n+     * cannot interpret the parameter.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not of the correct type\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void addPreModificationListener(Object listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Removes a pre listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void removePreModificationListener(Object listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    // PostListeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the post listeners active in the handler.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @return the listeners\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public Object[] getPostModificationListeners() {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Adds a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * <p>\n+     * The listener does not necessarily have to be a listener in the classic\n+     * JavaBean sense. It is entirely up to the handler as to how it interprets\n+     * the listener parameter. A ClassCastException is thrown if the handler\n+     * cannot interpret the parameter.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not of the correct type\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void addPostModificationListener(Object listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Removes a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void removePostModificationListener(Object listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    // Event sending\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles the pre event.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     */\n+    protected abstract boolean preEvent(int type, int index, Object object, int repeat);\n+\n+    /**\n+     * Handles the post event where the collections method returns boolean for success.\n+     * \n+     * @param modified  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     */\n+    protected abstract void postEvent(boolean modified, int type, int index, Object object, int repeat);\n+\n+    /**\n+     * Handles the post event where the collections method has a return value.\n+     * \n+     * @param modified  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @param result  the result of the method\n+     */\n+    protected abstract void postEvent(boolean modified, int type, int index, Object object, int repeat, Object result);\n+\n+    // Event handling\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before add(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param object  the object being added\n+     * @return true to process modification\n+     */\n+    protected boolean preAdd(Object object) {\n+        return preEvent(ModificationEventType.ADD, -1, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after add(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param object  the object being added\n+     * @param result  the result from the add method\n+     */\n+    protected void postAdd(Object object, boolean result) {\n+        postEvent(result, ModificationEventType.ADD, -1, object, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before add(int,obj) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     * @return true to process modification\n+     */\n+    protected boolean preAdd(int index, Object object) {\n+        return preEvent(ModificationEventType.ADD_INDEXED, index, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after add(int,obj) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     */\n+    protected void postAdd(int index, Object object) {\n+        postEvent(true, ModificationEventType.ADD_INDEXED, index, object, 1, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before add(obj,int) is called on a Bag.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param object  the object being added\n+     * @param nCopies  the number of copies being added\n+     * @return true to process modification\n+     */\n+    protected boolean preAdd(Object object, int nCopies) {\n+        return preEvent(ModificationEventType.ADD_NCOPIES, -1, object, nCopies);\n+    }\n+\n+    /**\n+     * Send an event after add(obj,int) is called on a Bag.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param object  the object being added\n+     * @param nCopies  the number of copies being added\n+     */\n+    protected void postAdd(Object object, int nCopies, boolean result) {\n+        postEvent(true, ModificationEventType.ADD_NCOPIES, -1, object, nCopies, (result ? Boolean.TRUE : Boolean.FALSE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before addAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being added\n+     * @return true to process modification\n+     */\n+    protected boolean preAddAll(Collection coll) {\n+        return preEvent(ModificationEventType.ADD_ALL, -1, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after addAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being added\n+     * @param result  the result from the addAll method\n+     */\n+    protected void postAddAll(Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.ADD_ALL, -1, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before addAll(int,coll) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to addAll at\n+     * @param coll  the collection being added\n+     * @return true to process modification\n+     */\n+    protected boolean preAddAll(int index, Collection coll) {\n+        return preEvent(ModificationEventType.ADD_ALL_INDEXED, index, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after addAll(int,coll) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param index  the index to addAll at\n+     * @param coll  the collection being added\n+     * @param result  the result from the addAll method\n+     */\n+    protected void postAddAll(int index, Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.ADD_ALL_INDEXED, index, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before clear() is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @return true to process modification\n+     */\n+    protected boolean preClear() {\n+        return preEvent(ModificationEventType.CLEAR, -1, null, 1);\n+    }\n+\n+    /**\n+     * Send an event after clear() is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     */\n+    protected void postClear() {\n+        // assumes a modification occurred\n+        postEvent(true, ModificationEventType.CLEAR, -1, null, 1, null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before remove(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param object  the object being removed\n+     * @return true to process modification\n+     */\n+    protected boolean preRemove(Object object) {\n+        return preEvent(ModificationEventType.REMOVE, -1, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after remove(obj) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param object  the object being removed\n+     * @param result  the result from the remove method\n+     */\n+    protected void postRemove(Object object, boolean result) {\n+        postEvent(result, ModificationEventType.REMOVE, -1, object, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before remove(int) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to remove at\n+     * @return true to process modification\n+     */\n+    protected boolean preRemove(int index) {\n+        return preEvent(ModificationEventType.REMOVE_INDEXED, index, null, 1);\n+    }\n+\n+    /**\n+     * Send an event after remove(int) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param index  the index to remove at\n+     * @param result  the result from the remove method\n+     */\n+    protected void postRemove(int index, Object result) {\n+        postEvent(true, ModificationEventType.REMOVE_INDEXED, index, null, 1, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before remove(obj,int) is called on a Bag.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param object  the object being removed\n+     * @param nCopies  the number of copies being removed\n+     * @return true to process modification\n+     */\n+    protected boolean preRemove(Object object, int nCopies) {\n+        return preEvent(ModificationEventType.REMOVE_NCOPIES, -1, object, nCopies);\n+    }\n+\n+    /**\n+     * Send an event after remove(obj,int) is called on a Bag.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param object  the object being removed\n+     * @param nCopies  the number of copies being removed\n+     */\n+    protected void postRemove(Object object, int nCopies, boolean result) {\n+        postEvent(result, ModificationEventType.REMOVE_NCOPIES, -1, object, nCopies);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before removeAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being removed\n+     * @return true to process modification\n+     */\n+    protected boolean preRemoveAll(Collection coll) {\n+        return preEvent(ModificationEventType.REMOVE_ALL, -1, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after removeAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being removed\n+     * @param result  the result from the removeAll method\n+     */\n+    protected void postRemoveAll(Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.REMOVE_ALL, -1, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before retainAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being retained\n+     * @return true to process modification\n+     */\n+    protected boolean preRetainAll(Collection coll) {\n+        return preEvent(ModificationEventType.RETAIN_ALL, -1, coll, 1);\n+    }\n+\n+    /**\n+     * Send an event after retainAll(coll) is called.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int)}.\n+     * \n+     * @param coll  the collection being retained\n+     * @param result  the result from the retainAll method\n+     */\n+    protected void postRetainAll(Collection coll, boolean result) {\n+        postEvent(result, ModificationEventType.RETAIN_ALL, -1, coll, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Store data and send event before set(int,obj) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     * @return true to process modification\n+     */\n+    protected boolean preSet(int index, Object object) {\n+        return preEvent(ModificationEventType.SET_INDEXED, index, object, 1);\n+    }\n+\n+    /**\n+     * Send an event after set(int,obj) is called on a List.\n+     * <p>\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * \n+     * @param index  the index to add at\n+     * @param object  the object being added\n+     * @param result  the result from the set method\n+     */\n+    protected void postSet(int index, Object object, Object result) {\n+        // reference check for modification, in case equals() has issues (eg. performance)\n+        postEvent((object != result), ModificationEventType.SET_INDEXED, index, object, 1, result);\n+    }\n+\n+    // toString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of this object.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        String name = getClass().getName();\n+        int pos = name.lastIndexOf('.');\n+        if (pos != -1) {\n+            name = name.substring(pos + 1);\n+        }\n+        return name + '[' + (collection == null ? \"\" : \"initialised\") + ']';\n+    }\n+\n+    // Factory to create handler from handler\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory that casts the listener to a handler.\n+     */\n+    static class Factory implements ModificationHandlerFactory {\n+        public ModificationHandler createHandler(Collection coll, Object listener) {\n+            if (listener instanceof ModificationHandler) {\n+                return (ModificationHandler) listener;\n+            }\n+            return null;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ModificationHandlerFactory.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandlerFactory.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+\n+\n+/**\n+ * Defines a factory for creating ModificationHandler instances.\n+ * <p>\n+ * If an application wants to register its own event handler classes, it should\n+ * do so using this class. This must be done during initialization to be \n+ * fully thread-safe. There are two steps:\n+ * <ol>\n+ * <li>A factory must be created that is an implementation of this class\n+ * <li>One of the <code>registerFactory</code> methods must be called on ObservedCollection\n+ * </ol>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface ModificationHandlerFactory {\n+    \n+    /**\n+     * Creates a handler subclass for the specified listener.\n+     * <p>\n+     * The implementation will normally check to see if the listener\n+     * is of a suitable type, and then cast it. <code>null</code> is\n+     * returned if this factory does not handle the specified type.\n+     * <p>\n+     * The listener is defined in terms of an Object to allow for unusual\n+     * listeners, such as a Swing model object.\n+     * <p>\n+     * The collection the handler is for is passed in to allow for a different\n+     * handler to be selected for the same listener type based on the collection.\n+     * \n+     * @param coll  the collection being decorated\n+     * @param listener  a listener object to create a handler for\n+     * @return an instantiated handler with the listener attached,\n+     *  or null if the listener type is unsuited to this factory\n+     */\n+    ModificationHandler createHandler(Collection coll, Object listener);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationListener.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * An empty listener designed to be subclassed.\n+ * <p>\n+ * This interface exists to mark independent subclasses as fulfilling the\n+ * role of an event listener for collection modification events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface ModificationListener extends EventListener {\n+\n+    // no methods - subinterfaces define them\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ModificationVetoedException.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationVetoedException.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+/**\n+ * Exception thrown when a modification to a collection is vetoed.\n+ * It extends IllegalArgumentException for compatibility with the collections API.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ModificationVetoedException extends IllegalArgumentException {\n+\n+    /** The source event */\n+    protected final ModificationEvent event;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param message  the text message, may be null\n+     * @param event  the observed event, should not be null\n+     */\n+    public ModificationVetoedException(final String message, final ModificationEvent event) {\n+        super((message == null ? \"Modification vetoed\" : message));\n+        this.event = event;\n+    }\n+\n+    // Event access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the event that caused the veto.\n+     * \n+     * @return the event\n+     */\n+    public ModificationEvent getEvent() {\n+        return event;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservedBag.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedBag.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+\n+/**\n+ * Decorates a <code>Bag</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Bag</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ * <p>\n+ * NOTE: The {@link #uniqueSet()} method returns a <code>Set</code> that is\n+ * NOT observed. This is because the set should be unmodifiable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedBag extends ObservedCollection implements Bag {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable bag.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param bag  the bag to decorate, must not be null\n+     * @return the observed Bag\n+     * @throws IllegalArgumentException if the bag is null\n+     */\n+    public static ObservedBag decorate(final Bag bag) {\n+        return new ObservedBag(bag, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable bag using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservedBag</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param bag  the bag to decorate, must not be null\n+     * @param listener  bag listener, may be null\n+     * @return the observed bag\n+     * @throws IllegalArgumentException if the bag is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservedBag decorate(\n+            final Bag bag,\n+            final Object listener) {\n+        \n+        if (bag == null) {\n+            throw new IllegalArgumentException(\"Bag must not be null\");\n+        }\n+        return new ObservedBag(bag, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the bag is null\n+     */\n+    protected ObservedBag(\n+            final Bag bag,\n+            final Object listener) {\n+        super(bag, listener);\n+    }\n+    \n+    /**\n+     * Typecast the collection to a Bag.\n+     * \n+     * @return the wrapped collection as a Bag\n+     */\n+    private Bag getBag() {\n+        return (Bag) getCollection();\n+    }\n+\n+    // Bag API\n+    //-----------------------------------------------------------------------\n+    public int getCount(Object object) {\n+        return getBag().getCount(object);\n+    }\n+\n+    public Set uniqueSet() {\n+        return getBag().uniqueSet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(Object object) {\n+        // override as Bag violates Collection contract\n+        boolean result = false;\n+        if (handler.preAdd(object)) {\n+            result = collection.add(object);\n+            handler.postAdd(object, true);  // true, as result is misleading\n+        }\n+        return result;\n+    }\n+\n+    public boolean add(Object object, int nCopies) {\n+        boolean result = false;\n+        if (handler.preAdd(object, nCopies)) {\n+            result = getBag().add(object, nCopies);\n+            handler.postAdd(object, nCopies, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean remove(Object object, int nCopies) {\n+        boolean result = false;\n+        if (handler.preRemove(object, nCopies)) {\n+            result = getBag().remove(object, nCopies);\n+            handler.postRemove(object, nCopies, result);\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservedCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedCollection.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.decorators.AbstractCollectionDecorator;\n+import org.apache.commons.collections.decorators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.observed.standard.StandardModificationHandler;\n+\n+/**\n+ * Decorates a <code>Collection</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Collection</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedCollection extends AbstractCollectionDecorator {\n+    \n+    /** The list of registered factories, checked in reverse order */\n+    private static ModificationHandlerFactory[] factories = new ModificationHandlerFactory[] {\n+        ModificationHandler.FACTORY,\n+        StandardModificationHandler.FACTORY\n+    };\n+    \n+    /** The handler to delegate event handling to */\n+    protected final ModificationHandler handler;\n+\n+    // ObservedCollection factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable collection.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public static ObservedCollection decorate(final Collection coll) {\n+        return new ObservedCollection(coll, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservedCollection</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @param listener  collection listener, may be null\n+     * @return the observed collection\n+     * @throws IllegalArgumentException if the collection is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservedCollection decorate(\n+            final Collection coll,\n+            final Object listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        return new ObservedCollection(coll, listener);\n+    }\n+\n+    // Register for ModificationHandlerFactory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Registers a handler factory to be used for looking up a listener to\n+     * a handler.\n+     * <p>\n+     * This method is used to add your own event handler to the supplied ones.\n+     * Registering the factory will enable the {@link #decorate(Collection, Object)}\n+     * method to create your handler.\n+     * <p>\n+     * Each handler added becomes the first in the lookup chain. Thus it is\n+     * possible to override the default setup.\n+     * Obviously this should be done with care in a shared web environment!\n+     * <p>\n+     * This method is not guaranteed to be threadsafe.\n+     * It should only be called during initialization.\n+     * Problems will occur if two threads call this method at the same time.\n+     * \n+     * @param factory  the factory to add, may be null\n+     */\n+    public static void registerFactory(final ModificationHandlerFactory factory) {\n+        if (factory != null) {\n+            // add at end, as checked in reverse order\n+            ModificationHandlerFactory[] array = new ModificationHandlerFactory[factories.length + 1];\n+            System.arraycopy(factories, 0, array, 0, factories.length);\n+            array[factories.length] = factory;\n+            factories = array;  // atomic operation\n+        }\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * If a <code>null</code> handler is specified, an \n+     * <code>ObservedHandler</code> is created. \n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param handler  the observing handler, may be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected ObservedCollection(\n+            final Collection coll,\n+            final Object listener) {\n+        super(coll);\n+        this.handler = createHandler(coll, listener);\n+        this.handler.init(this);\n+    }\n+\n+    /**\n+     * Creates a handler subclass based on the specified listener.\n+     * <p>\n+     * The method is defined in terms of an Object to allow for unusual\n+     * listeners, such as a Swing model object.\n+     * \n+     * @param listener  a listener object to create a handler for\n+     * @return an instantiated handler with the listener attached\n+     * @throws IllegalArgumentException if no suitable handler\n+     */\n+    protected ModificationHandler createHandler(final Collection coll, final Object listener) {\n+        if (listener == null) {\n+            return new StandardModificationHandler();\n+        }\n+        ModificationHandlerFactory[] array = factories;  // atomic operation\n+        for (int i = array.length - 1; i >= 0 ; i--) {\n+            ModificationHandler handler = array[i].createHandler(coll, listener);\n+            if (handler != null) {\n+                return handler;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Unrecognised listener type: \" +\n+            (listener == null ? \"null\" : listener.getClass().getName()));\n+    }\n+\n+    // Handler access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the handler that is observing this collection.\n+     * \n+     * @return the observing handler, never null\n+     */\n+    public ModificationHandler getHandler() {\n+        return handler;\n+    }\n+    \n+    // Collection\n+    //-----------------------------------------------------------------------\n+    public boolean add(Object object) {\n+        boolean result = false;\n+        if (handler.preAdd(object)) {\n+            result = collection.add(object);\n+            handler.postAdd(object, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean addAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preAddAll(coll)) {\n+            result = collection.addAll(coll);\n+            handler.postAddAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public void clear() {\n+        if (handler.preClear()) {\n+            collection.clear();\n+            handler.postClear();\n+        }\n+    }\n+\n+    public Iterator iterator() {\n+        return new ObservedIterator(collection.iterator());\n+    }\n+\n+    public boolean remove(Object object) {\n+        boolean result = false;\n+        if (handler.preRemove(object)) {\n+            result = collection.remove(object);\n+            handler.postRemove(object, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean removeAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preRemoveAll(coll)) {\n+            result = collection.removeAll(coll);\n+            handler.postRemoveAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public boolean retainAll(Collection coll) {\n+        boolean result = false;\n+        if (handler.preRetainAll(coll)) {\n+            result = collection.retainAll(coll);\n+            handler.postRetainAll(coll, result);\n+        }\n+        return result;\n+    }\n+\n+    // Iterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Iterator for the ObservedCollection.\n+     */\n+    protected class ObservedIterator extends AbstractIteratorDecorator {\n+        \n+        protected Object last;\n+        \n+        protected ObservedIterator(Iterator iterator) {\n+            super(iterator);\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (handler.preRemove(last)) {\n+                iterator.remove();\n+                handler.postRemove(last, true);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedList.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.decorators.AbstractListIteratorDecorator;\n+\n+/**\n+ * Decorates a <code>List</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>List</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedList extends ObservedCollection implements List {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable list.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @return the observed List\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    public static ObservedList decorate(final List list) {\n+        return new ObservedList(list, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable list using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservedList</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @param listener  list listener, may be null\n+     * @return the observed list\n+     * @throws IllegalArgumentException if the list is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservedList decorate(\n+            final List list,\n+            final Object listener) {\n+        \n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        return new ObservedList(list, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * If a <code>null</code> handler is specified, an \n+     * <code>ObservedHandler</code> is created. \n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    protected ObservedList(\n+            final List list,\n+            final Object listener) {\n+        super(list, listener);\n+    }\n+    \n+    /**\n+     * Typecast the collection to a List.\n+     * \n+     * @return the wrapped collection as a List\n+     */\n+    private List getList() {\n+        return (List) getCollection();\n+    }\n+\n+    // List API\n+    //-----------------------------------------------------------------------\n+    public Object get(int index) {\n+        return getList().get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return getList().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        return getList().lastIndexOf(object);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, Object object) {\n+        if (handler.preAdd(index, object)) {\n+            getList().add(index, object);\n+            handler.postAdd(index, object);\n+        }\n+    }\n+\n+    public boolean addAll(int index, Collection coll) {\n+        boolean result = false;\n+        if (handler.preAddAll(index, coll)) {\n+            result = getList().addAll(index, coll);\n+            handler.postAddAll(index, coll, result);\n+        }\n+        return result;\n+    }\n+\n+    public Object remove(int index) {\n+        Object result = null;\n+        if (handler.preRemove(index)) {\n+            result = getList().remove(index);\n+            handler.postRemove(index, result);\n+        }\n+        return result;\n+    }\n+\n+    public Object set(int index, Object object) {\n+        Object result = null;\n+        if (handler.preSet(index, object)) {\n+            result = getList().set(index, object);\n+            handler.postSet(index, object, result);\n+        }\n+        return result;\n+    }\n+\n+    public ListIterator listIterator() {\n+        return new ObservedListIterator(getList().listIterator());\n+    }\n+\n+    public ListIterator listIterator(int index) {\n+        return new ObservedListIterator(getList().listIterator(index));\n+    }\n+\n+    public List subList(int fromIndex, int toIndex) {\n+        // TODO: This list needs to be a special impl, as the index is offset\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class ListIterator for the ObservedList.\n+     */\n+    protected class ObservedListIterator extends AbstractListIteratorDecorator {\n+        \n+        protected Object last;\n+        \n+        protected ObservedListIterator(ListIterator iterator) {\n+            super(iterator);\n+        }\n+        \n+        public Object next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        public Object previous() {\n+            last = iterator.previous();\n+            return last;\n+        }\n+\n+        public void remove() {\n+            int index = iterator.previousIndex();\n+            if (handler.preRemove(index)) {\n+                iterator.remove();\n+                handler.postRemove(index, last);\n+            }\n+        }\n+        \n+        public void add(Object object) {\n+            int index = iterator.nextIndex();\n+            if (handler.preAdd(index, object)) {\n+                iterator.add(object);\n+                handler.postAdd(index, object);\n+            }\n+        }\n+\n+        public void set(Object object) {\n+            int index = iterator.previousIndex();\n+            if (handler.preSet(index, object)) {\n+                iterator.set(object);\n+                handler.postSet(index, object, last);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/ObservedSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedSet.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Set;\n+\n+\n+/**\n+ * Decorates a <code>Set</code> implementation to observe modifications.\n+ * <p>\n+ * Each modifying method call made on this <code>Set</code> is forwarded to a\n+ * {@link ModificationHandler}.\n+ * The handler manages the event, notifying listeners and optionally vetoing changes.\n+ * The default handler is {@link StandardModificationHandler}.\n+ * See this class for details of configuration available.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedSet extends ObservedCollection implements Set {\n+    \n+    // Factories\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create an observable set.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * This can be accessed by {@link #getHandler()} to add listeners.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @return the observed Set\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public static ObservedSet decorate(final Set set) {\n+        return new ObservedSet(set, null);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set using a listener or a handler.\n+     * <p>\n+     * A lot of functionality is available through this method.\n+     * If you don't need the extra functionality, simply implement the\n+     * {@link org.apache.commons.collections.observed.standard.StandardModificationListener}\n+     * interface and pass it in as the second parameter.\n+     * <p>\n+     * Internally, an <code>ObservedSet</code> relies on a {@link ModificationHandler}.\n+     * The handler receives all the events and processes them, typically by\n+     * calling listeners. Different handler implementations can be plugged in\n+     * to provide a flexible event system.\n+     * <p>\n+     * The handler implementation is determined by the listener parameter via\n+     * the registered factories. The listener may be a manually configured \n+     * <code>ModificationHandler</code> instance.\n+     * <p>\n+     * The listener is defined as an Object for maximum flexibility.\n+     * It does not have to be a listener in the classic JavaBean sense.\n+     * It is entirely up to the factory and handler as to how the parameter\n+     * is interpretted. An IllegalArgumentException is thrown if no suitable\n+     * handler can be found for this listener.\n+     * <p>\n+     * A <code>null</code> listener will create a {@link StandardModificationHandler}.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param listener  set listener, may be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set is null\n+     * @throws IllegalArgumentException if there is no valid handler for the listener\n+     */\n+    public static ObservedSet decorate(\n+            final Set set,\n+            final Object listener) {\n+        \n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        return new ObservedSet(set, listener);\n+    }\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) and takes a handler.\n+     * <p>\n+     * If a <code>null</code> handler is specified, an \n+     * <code>ObservedHandler</code> is created. \n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param listener  the listener, may be null\n+     * @throws IllegalArgumentException if the set is null\n+     */\n+    protected ObservedSet(\n+            final Set set,\n+            final Object listener) {\n+        super(set, listener);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationEvent.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationEvent.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed.standard;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.observed.ModificationEvent;\n+import org.apache.commons.collections.observed.ModificationEventType;\n+import org.apache.commons.collections.observed.ModificationHandler;\n+\n+/**\n+ * Event class that encapsulates all the event information for a\n+ * standard collection event.\n+ * <p>\n+ * The information stored in this event is all that is available as\n+ * parameters or return values.\n+ * In addition, the <code>size</code> method is used on the collection.\n+ * All objects used are the real objects from the method calls, not clones.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class StandardModificationEvent extends ModificationEvent {\n+\n+    /** The size before the event */\n+    protected final int preSize;\n+    /** The size after the event */\n+    protected final int postSize;\n+    /** The index of the change */\n+    protected final int index;\n+    /** The object of the change */\n+    protected final Object object;\n+    /** The number of changes */\n+    protected final int repeat;\n+    /** The result of the method call */\n+    protected final Object result;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     * \n+     * @param collection  the event source\n+     * @param handler  the handler\n+     * @param type  the event type\n+     * @param preSize  the size before the change\n+     * @param index  the index that changed\n+     * @param object  the value that changed\n+     * @param repeat  the number of repeats\n+     * @param result  the method result\n+     */\n+    public StandardModificationEvent(\n+        final Collection collection,\n+        final ModificationHandler handler,\n+        final int type,\n+        final int preSize,\n+        final int index,\n+        final Object object,\n+        final int repeat,\n+        final Object result) {\n+\n+        super(collection, handler, type);\n+        this.preSize = preSize;\n+        this.postSize = collection.size();\n+        this.index = index;\n+        this.object = object;\n+        this.repeat = repeat;\n+        this.result = result;\n+    }\n+\n+    // Change info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the index of the change.\n+     * <p>\n+     * This is <code>-1</code> when not applicable. Typically only used\n+     * for {@link java.util.List} events.\n+     * \n+     * @return the change index\n+     */\n+    public int getChangeIndex() {\n+        return index;\n+    }\n+\n+    /**\n+     * Gets the object that was added/removed/set.\n+     * <p>\n+     * This is <code>null</code> when not applicable, such as for clear().\n+     * \n+     * @return the changing object\n+     */\n+    public Object getChangeObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * Gets the collection of changed objects.\n+     * <p>\n+     * For clear, it is an empty list.\n+     * For bulk operations, it is the collection.\n+     * For non-bulk operations, it is a size one list.\n+     * \n+     * @return the changing collection, never null\n+     */\n+    public Collection getChangeCollection() {\n+        if (object == null) {\n+            return Collections.EMPTY_LIST;\n+        } else if (isType(ModificationEventType.GROUP_BULK)) {\n+            if (object instanceof Collection) {\n+                return (Collection) object;\n+            } else {\n+                throw new IllegalStateException(\n+                    \"Bulk operations must involve a Collection, but was \" + object.getClass().getName());\n+            }\n+        } else {\n+            return Collections.singletonList(object);\n+        }\n+    }\n+\n+    /**\n+     * Gets the number of times the object was added/removed.\n+     * <p>\n+     * This is normally <code>1</code>, but will be used for \n+     * {@link org.apache.commons.collections.Bag Bag} events.\n+     * \n+     * @return the repeat\n+     */\n+    public int getChangeRepeat() {\n+        return repeat;\n+    }\n+\n+    /**\n+     * Gets the result of the method call.\n+     * <p>\n+     * For set(int) and remove(int) this will be the previous value\n+     * being replaced.\n+     * <p>\n+     * If there is no result yet, <code>null</code> will be returned.\n+     * If the result was a <code>boolean</code>, a <code>Boolean</code> is returned.\n+     * If the result was void, <code>null</code> will be returned.\n+     * \n+     * @return the repeat\n+     */\n+    public Object getResult() {\n+        return result;\n+    }\n+\n+    // Size info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size before the change.\n+     * \n+     * @return the size before the change\n+     */\n+    public int getPreSize() {\n+        return preSize;\n+    }\n+\n+    /**\n+     * Gets the size after the change.\n+     * <p>\n+     * This method will return the same as <code>getPreSzie</code> if\n+     * called when handling a pre event.\n+     * \n+     * @return the size before the change\n+     */\n+    public int getPostSize() {\n+        return postSize;\n+    }\n+\n+    /**\n+     * Gets the size change, negative for remove/clear.\n+     * <p>\n+     * This method will return <code>zero</code> if called when handling a pre event.\n+     * \n+     * @return the size before the change\n+     */\n+    public int getSizeChange() {\n+        return postSize - preSize;\n+    }\n+\n+    /**\n+     * Returns true if the size of the collection changed.\n+     * <p>\n+     * This method will return <code>false</code> if called when handling a pre event.\n+     * \n+     * @return true is the size changed\n+     */\n+    public boolean isSizeChanged() {\n+        return (preSize != postSize);\n+    }\n+\n+    // Event type\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks to see if the event is of the specified type.\n+     * <p>\n+     * This is any combination of constants from {@link ObservedEventType}.\n+     * \n+     * @param eventType  an event type constant\n+     * @return true if of the specified type\n+     */\n+    public boolean isType(final int eventType) {\n+        return (type & eventType) > 0;\n+    }\n+\n+    // toString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a debugging string version of the event.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer(64);\n+        buf.append(\"ObservedEvent[type=\");\n+        buf.append(ModificationEventType.toString(type));\n+        if (index >= 0) {\n+            buf.append(\",index=\");\n+            buf.append(index);\n+        }\n+        if (type != ModificationEventType.CLEAR) {\n+            buf.append(\",object=\");\n+            if (object instanceof List) {\n+                buf.append(\"List:size:\");\n+                buf.append(((List) object).size());\n+            } else if (object instanceof Set) {\n+                buf.append(\"Set:size:\");\n+                buf.append(((Set) object).size());\n+            } else if (object instanceof Bag) {\n+                buf.append(\"Bag:size:\");\n+                buf.append(((Bag) object).size());\n+            } else if (object instanceof Collection) {\n+                buf.append(\"Collection:size:\");\n+                buf.append(((Collection) object).size());\n+            } else if (object instanceof Map) {\n+                buf.append(\"Map:size:\");\n+                buf.append(((Map) object).size());\n+            } else if (object instanceof Object[]) {\n+                buf.append(\"Array:size:\");\n+                buf.append(((Object[]) object).length);\n+            } else if (object == null) {\n+                buf.append(\"null\");\n+            } else {\n+                buf.append(object.toString());\n+            }\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationHandler.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationHandler.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed.standard;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.observed.ModificationEventType;\n+import org.apache.commons.collections.observed.ModificationHandler;\n+import org.apache.commons.collections.observed.ModificationHandlerFactory;\n+\n+/**\n+ * The standard implementation of a <code>ModificationHandler</code> that\n+ * sends standard JavaBean style events to listeners.\n+ * <p>\n+ * The information gathered by this implementation is all that is available\n+ * as parameters or return values.\n+ * In addition, the <code>size</code> method is used on the collection.\n+ * All objects used are the real objects from the method calls, not clones.\n+ * <p>\n+ * Each listener can be filtered. There are separate filters for pre and post\n+ * modification events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class StandardModificationHandler extends ModificationHandler {\n+\n+    /** The singleton factory */    \n+    public static final ModificationHandlerFactory FACTORY = new Factory();\n+\n+    /** A reusable empty holders array. */    \n+    protected static final PreHolder[] EMPTY_PRE_HOLDERS = new PreHolder[0];\n+    /** A reusable empty holders array. */    \n+    protected static final PostHolder[] EMPTY_POST_HOLDERS = new PostHolder[0];\n+    \n+    /** The event mask as to which event types to send on pre events. */\n+    protected int preMask = ModificationEventType.GROUP_NONE;\n+    /** The event mask as to which event types to send on post events. */\n+    protected int postMask = ModificationEventType.GROUP_NONE;\n+    \n+    /** The event listeners. */\n+    protected PreHolder[] preHolder = EMPTY_PRE_HOLDERS;\n+    /** The event listeners. */\n+    protected PostHolder[] postHolder = EMPTY_POST_HOLDERS;\n+    /**\n+     * Temporary store for the size.\n+     * This makes the class thread-unsafe, but you should sync collections anyway.\n+     */\n+    protected int preSize;\n+    \n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor the creates the handler but leaves it invalid.\n+     * <p>\n+     * The handler can only be used after {@link #init(ObservedCollection)} is\n+     * called. This is normally done automatically by\n+     * {@link ObservedCollection#decorate(Collection, ModificationHandler)}.\n+     */\n+    public StandardModificationHandler() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor the creates the handler but leaves it invalid.\n+     * <p>\n+     * The handler can only be used after {@link #init(ObservedCollection)} is\n+     * called. This is normally done automatically by\n+     * {@link ObservedCollection#decorate(Collection, ModificationHandler)}.\n+     * \n+     * @param pre  the pre listener\n+     * @param preMask  the mask for the pre listener\n+     * @param post  the post listener\n+     * @param postMask  the mask for the post listener\n+     */\n+    public StandardModificationHandler(\n+            StandardPreModificationListener pre, int preMask,\n+            StandardPostModificationListener post, int postMask) {\n+        super();\n+        if (pre != null) {\n+            preHolder = new PreHolder[1];\n+            preHolder[0] = new PreHolder(pre, preMask);\n+            this.preMask = preMask;\n+        }\n+        if (post != null) {\n+            postHolder = new PostHolder[1];\n+            postHolder[0] = new PostHolder(post, postMask);\n+            this.postMask = postMask;\n+        }\n+    }\n+\n+    // Pre Listeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the pre listeners active in the handler.\n+     * <p>\n+     * All listeners will be instances of StandardPreModificationListener.\n+     * \n+     * @return the listeners\n+     */\n+    public synchronized Object[] getPreModificationListeners() {\n+        Object[] lnrs = new Object[preHolder.length];\n+        for (int i = 0; i < preHolder.length; i++) {\n+            lnrs[i] = preHolder[i].listener;\n+        }\n+        return lnrs;\n+    }\n+    \n+    /**\n+     * Adds a listener to the handler for pre modification events.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not a StandardPreModificationListener\n+     */\n+    public void addPreModificationListener(Object listener) {\n+        addPreModificationListener((StandardPreModificationListener) listener, -1);\n+    }\n+    \n+    /**\n+     * Adds a pre listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @param mask  the mask for events (0 for none, -1 for all)\n+     */\n+    public synchronized void addPreModificationListener(StandardPreModificationListener listener, int mask) {\n+        if (listener != null) {\n+            int oldSize = preHolder.length;\n+            PreHolder[] array = new PreHolder[oldSize + 1];\n+            System.arraycopy(preHolder, 0, array, 0, oldSize);\n+            array[oldSize] = new PreHolder(listener, mask);\n+            preHolder = array;\n+            calculatePreMask();\n+        }\n+    }\n+    \n+    /**\n+     * Removes a pre listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     */\n+    public synchronized void removePreModificationListener(Object listener) {\n+        if (listener != null) {\n+            switch (preHolder.length) {\n+                case 0:\n+                return;\n+                \n+                case 1:\n+                if (preHolder[0].listener == listener) {\n+                    preHolder = EMPTY_PRE_HOLDERS;\n+                    calculatePreMask();\n+                }\n+                return;\n+                \n+                default:\n+                PreHolder[] array = new PreHolder[preHolder.length - 1];\n+                boolean match = false;\n+                for (int i = 0; i < preHolder.length; i++) {\n+                    if (match) {\n+                        array[i - 1] = preHolder[i];\n+                    } else if (preHolder[i].listener == listener) {\n+                        match = true;\n+                    } else {\n+                        array[i] = preHolder[i];\n+                    }\n+                }\n+                preHolder = array;\n+                calculatePreMask();\n+                return;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Sets the masks of a listener.\n+     * <p>\n+     * No error occurs if the listener is not in the list.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to change, may be null\n+     * @param mask  the new mask (0 for none, -1 for all)\n+     * @return a non-null array of listeners\n+     */\n+    public synchronized void setPreModificationListenerMask(StandardPreModificationListener listener, int mask) {\n+        if (listener != null) {\n+            for (int i = 0; i < preHolder.length; i++) {\n+                if (preHolder[i].listener == listener) {\n+                    preHolder[i].mask = mask;\n+                    calculatePreMask();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Calculate the combined masks.\n+     */\n+    protected void calculatePreMask() {\n+        preMask = ModificationEventType.GROUP_NONE;\n+        for (int i = 0; i < preHolder.length; i++) {\n+            preMask |= preHolder[i].mask;\n+        }\n+    }\n+    \n+    protected static class PreHolder {\n+        final StandardPreModificationListener listener;\n+        int mask;\n+        \n+        PreHolder(StandardPreModificationListener listener, int mask) {\n+            this.listener = listener;\n+            this.mask = mask;\n+        }\n+        \n+        public String toString() {\n+            return \"[\" + listener + \",\" + ModificationEventType.toString(mask) + \"]\";\n+        }\n+\n+    }\n+    \n+    // Post Listeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the post listeners active in the handler.\n+     * <p>\n+     * All listeners will be instances of StandardModificationListener.\n+     * \n+     * @return the listeners\n+     */\n+    public synchronized Object[] getPostModificationListeners() {\n+        Object[] lnrs = new Object[postHolder.length];\n+        for (int i = 0; i < postHolder.length; i++) {\n+            lnrs[i] = postHolder[i].listener;\n+        }\n+        return lnrs;\n+    }\n+    \n+    /**\n+     * Adds a listener to the handler for post modification events.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not a StandardPreModificationListener\n+     */\n+    public void addPostModificationListener(Object listener) {\n+        addPostModificationListener((StandardPostModificationListener) listener, -1);\n+    }\n+    \n+    /**\n+     * Adds a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @param mask  the mask for events (0 for none, -1 for all)\n+     */\n+    public synchronized void addPostModificationListener(StandardPostModificationListener listener, int mask) {\n+        if (listener != null) {\n+            int oldSize = postHolder.length;\n+            PostHolder[] array = new PostHolder[oldSize + 1];\n+            System.arraycopy(postHolder, 0, array, 0, oldSize);\n+            array[oldSize] = new PostHolder(listener, mask);\n+            postHolder = array;\n+            calculatePostMask();\n+        }\n+    }\n+    \n+    /**\n+     * Removes a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     */\n+    public synchronized void removePostModificationListener(Object listener) {\n+        if (listener != null) {\n+            switch (postHolder.length) {\n+                case 0:\n+                return;\n+                \n+                case 1:\n+                if (postHolder[0].listener == listener) {\n+                    postHolder = EMPTY_POST_HOLDERS;\n+                    calculatePostMask();\n+                }\n+                return;\n+                \n+                default:\n+                PostHolder[] array = new PostHolder[postHolder.length - 1];\n+                boolean match = false;\n+                for (int i = 0; i < postHolder.length; i++) {\n+                    if (match) {\n+                        array[i - 1] = postHolder[i];\n+                    } else if (postHolder[i].listener == listener) {\n+                        match = true;\n+                    } else {\n+                        array[i] = postHolder[i];\n+                    }\n+                }\n+                postHolder = array;\n+                calculatePostMask();\n+                return;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Sets the masks of a listener.\n+     * <p>\n+     * No error occurs if the listener is not in the list.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to change, may be null\n+     * @param mask  the new mask (0 for none, -1 for all)\n+     * @return a non-null array of listeners\n+     */\n+    public synchronized void setPostModificationListenerMask(StandardPostModificationListener listener, int mask) {\n+        if (listener != null) {\n+            for (int i = 0; i < postHolder.length; i++) {\n+                if (postHolder[i].listener == listener) {\n+                    postHolder[i].mask = mask;\n+                    calculatePostMask();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Calculate the combined masks.\n+     */\n+    protected void calculatePostMask() {\n+        postMask = ModificationEventType.GROUP_NONE;\n+        for (int i = 0; i < postHolder.length; i++) {\n+            postMask |= postHolder[i].mask;\n+        }\n+    }\n+\n+    protected static class PostHolder {\n+        final StandardPostModificationListener listener;\n+        int mask;\n+        \n+        PostHolder(StandardPostModificationListener listener, int mask) {\n+            this.listener = listener;\n+            this.mask = mask;\n+        }\n+        \n+        public String toString() {\n+            return \"[\" + listener + \",\" + ModificationEventType.toString(mask) + \"]\";\n+        }\n+\n+    }\n+    \n+    // Pre event sending\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles the pre event.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @return true to call the decorated collection\n+     */\n+    protected boolean preEvent(int type, int index, Object object, int repeat) {\n+        preSize = getCollection().size();\n+        return firePreEvent(type, index, object, repeat);\n+    }\n+\n+    /**\n+     * Sends the pre event to the listeners.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @return true to call the decorated collection\n+     */\n+    protected boolean firePreEvent(int type, int index, Object object, int repeat) {\n+        if ((preMask & type) > 0) {\n+            StandardModificationEvent event = null;\n+            synchronized (this) {\n+                for (int i = 0; i < preHolder.length; i++) {\n+                    PreHolder holder = preHolder[i];\n+                    if ((holder.mask & type) > 0) {\n+                        if (event == null) {\n+                            event = new StandardModificationEvent(\n+                                getCollection(), this, type, preSize, index, object, repeat, null);\n+                        }\n+                        holder.listener.modificationOccurring(event);\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Post event sending\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Handles the post event.\n+     * \n+     * @param success  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     */\n+    protected void postEvent(boolean success, int type, int index, Object object, int repeat) {\n+        if (success) {\n+            firePostEvent(type, index, object, repeat, (success ? Boolean.TRUE : Boolean.FALSE));\n+        }\n+    }\n+    \n+    /**\n+     * Handles the post event.\n+     * \n+     * @param success  true if the method succeeded in changing the collection\n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @param result  the method result\n+     */\n+    protected void postEvent(boolean success, int type, int index, Object object, int repeat, Object result) {\n+        if (success) {\n+            firePostEvent(type, index, object, repeat, result);\n+        }\n+    }\n+    \n+    /**\n+     * Sends the post event to the listeners.\n+     * \n+     * @param type  the event type to send\n+     * @param index  the index where the change starts\n+     * @param object  the object that was added/removed\n+     * @param repeat  the number of repeats of the add/remove\n+     * @param result  the method result\n+     */\n+    protected void firePostEvent(int type, int index, Object object, int repeat, Object result) {\n+        if ((postMask & type) > 0) {\n+            StandardModificationEvent event = null;\n+            synchronized (this) {\n+                for (int i = 0; i < postHolder.length; i++) {\n+                    PostHolder holder = postHolder[i];\n+                    if ((holder.mask & type) > 0) {\n+                        if (event == null) {\n+                            event = new StandardModificationEvent(\n+                                getCollection(), this, type, preSize, index, object, repeat, result);\n+                        }\n+                        holder.listener.modificationOccurred(event);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Event handling\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Send an event after clear() is called.\n+     * <p>\n+     * Override to only send event if something actually cleared.\n+     */\n+    public void postClear() {\n+        postEvent(preSize > 0, ModificationEventType.CLEAR, -1, null, 1, null);\n+    }\n+\n+    // Factory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory implementation for the StandardModificationHandler.\n+     * \n+     * @author Stephen Colebourne\n+     */\n+    static class Factory implements ModificationHandlerFactory {\n+        \n+        /**\n+         * Creates a StandardModificationHandler using the listener.\n+         * \n+         * @param coll  the collection being decorated\n+         * @param listener  a listener object to create a handler for\n+         * @return an instantiated handler with the listener attached,\n+         *  or null if the listener type is unsuited to this factory\n+         */\n+        public ModificationHandler createHandler(Collection coll, Object listener) {\n+            if (listener instanceof StandardPreModificationListener) {\n+                if (listener instanceof StandardPostModificationListener) {\n+                    return new StandardModificationHandler(\n+                        (StandardPreModificationListener) listener, -1,\n+                        (StandardPostModificationListener) listener, -1);\n+                } else {\n+                    return new StandardModificationHandler(\n+                        (StandardPreModificationListener) listener, -1, null, 0);\n+                }\n+            }\n+            if (listener instanceof StandardPostModificationListener) {\n+                return new StandardModificationHandler(\n+                    null, 0, (StandardPostModificationListener) listener, -1);\n+            }\n+            return null;\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationListener.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed.standard;\n+\n+/**\n+ * A listener for the <code>StandardModificationHandler</code> that is called\n+ * both before the collection is changed and after the change has occurred.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface StandardModificationListener \n+    extends StandardPreModificationListener, StandardPostModificationListener {\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardPostModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPostModificationListener.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed.standard;\n+\n+import org.apache.commons.collections.observed.ModificationListener;\n+\n+/**\n+ * A listener for the <code>StandardModificationHandler</code> that is called\n+ * when a collection has been changed.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface StandardPostModificationListener extends ModificationListener {\n+\n+    /**\n+     * A collection modification occurred.\n+     * <p>\n+     * This method should be processed quickly, as with all event handling.\n+     * It should also avoid modifying the event source (the collection).\n+     * Finally it should avoid throwing an exception.\n+     * \n+     * @param event  the event detail\n+     */\n+    public void modificationOccurred(StandardModificationEvent event);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardPreModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPreModificationListener.java,v 1.1 2003/09/03 23:54:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed.standard;\n+\n+import org.apache.commons.collections.observed.ModificationListener;\n+\n+/**\n+ * A listener for the <code>StandardModificationHandler</code> that is called\n+ * when a collection is about to be modified.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:26 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface StandardPreModificationListener extends ModificationListener {\n+\n+    /**\n+     * A collection modification is occurring.\n+     * <p>\n+     * To veto the change, throw <code>ModicationVetoedException</code>.\n+     * <p>\n+     * This method should be processed quickly, as with all event handling.\n+     * It should also avoid modifying the event source (the collection).\n+     * \n+     * @param event  the event detail\n+     * @throws ModicationVetoedException to veto\n+     */\n+    public void modificationOccurring(StandardModificationEvent event);\n+    \n+}\n--- a/src/test/org/apache/commons/collections/decorators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.6 2003/09/03 00:11:28 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.7 2003/09/03 23:54:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for all collections decorators tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.6 $ $Date: 2003/09/03 00:11:28 $\n+ * @version $Revision: 1.7 $ $Date: 2003/09/03 23:54:25 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestFixedSizeMap.suite());\n         suite.addTest(TestFixedSizeSortedMap.suite());\n         \n-        suite.addTest(TestObservedCollection.suite());\n-        suite.addTest(TestObservedList.suite());\n-        suite.addTest(TestObservedSet.suite());\n-        \n         suite.addTest(TestSequencedSet.suite());\n         \n         suite.addTest(TestTransformedBag.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/observed/ObservedTestHelper.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/ObservedTestHelper.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.collections.observed.ModificationEventType;\n+import org.apache.commons.collections.observed.standard.StandardModificationEvent;\n+import org.apache.commons.collections.observed.standard.StandardModificationHandler;\n+import org.apache.commons.collections.observed.standard.StandardModificationListener;\n+import org.apache.commons.collections.observed.standard.StandardPostModificationListener;\n+import org.apache.commons.collections.observed.standard.StandardPreModificationListener;\n+\n+/**\n+ * Helper for testing\n+ * {@link ObservedCollection} implementations.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ObservedTestHelper {\n+    \n+    public static Integer SIX = new Integer(6);\n+    public static Integer SEVEN = new Integer(7);\n+    public static Integer EIGHT = new Integer(8);\n+    public static List SIX_SEVEN_LIST = new ArrayList();\n+    static {\n+        SIX_SEVEN_LIST.add(SIX);\n+        SIX_SEVEN_LIST.add(SEVEN);\n+    }\n+    \n+    public static class Listener implements StandardModificationListener {\n+        public StandardModificationEvent preEvent = null;\n+        public StandardModificationEvent postEvent = null;\n+        \n+        public void modificationOccurring(StandardModificationEvent event) {\n+            this.preEvent = event;\n+        }\n+\n+        public void modificationOccurred(StandardModificationEvent event) {\n+            this.postEvent = event;\n+        }\n+    }\n+    \n+    public static class PreListener implements StandardPreModificationListener {\n+        public StandardModificationEvent preEvent = null;\n+        \n+        public void modificationOccurring(StandardModificationEvent event) {\n+            this.preEvent = event;\n+        }\n+    }\n+    \n+    public static class PostListener implements StandardPostModificationListener {\n+        public StandardModificationEvent postEvent = null;\n+        \n+        public void modificationOccurred(StandardModificationEvent event) {\n+            this.postEvent = event;\n+        }\n+    }\n+    \n+    public static interface ObservedFactory {\n+        ObservedCollection createObservedCollection();\n+        ObservedCollection createObservedCollection(Object listener);\n+    }\n+    \n+    public static final Listener LISTENER = new Listener();\n+    public static final Listener LISTENER2 = new Listener();\n+    public static final PreListener PRE_LISTENER = new PreListener();\n+    public static final PostListener POST_LISTENER = new PostListener();\n+    \n+    public ObservedTestHelper() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void bulkTestObservedCollection(ObservedFactory factory) {\n+        doTestFactoryPlain(factory);\n+        doTestFactoryWithListener(factory);\n+        doTestFactoryWithPreListener(factory);\n+        doTestFactoryWithPostListener(factory);\n+        doTestFactoryWithHandler(factory);\n+        doTestFactoryWithObject(factory);\n+        doTestFactoryWithNull(factory);\n+        \n+        doTestAddRemoveGetPreListeners(factory);\n+        doTestAddRemoveGetPostListeners(factory);\n+        \n+        doTestAdd(factory);\n+        doTestAddAll(factory);\n+        doTestClear(factory);\n+        doTestRemove(factory);\n+        doTestRemoveAll(factory);\n+        doTestRetainAll(factory);\n+        doTestIteratorRemove(factory);\n+    }\n+    \n+    public static void bulkTestObservedSet(ObservedFactory factory) {\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedSet);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedSet);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedSet);\n+        \n+        bulkTestObservedCollection(factory);\n+    }\n+    \n+    public static void bulkTestObservedList(ObservedFactory factory) {\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedList);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedList);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedList);\n+        \n+        bulkTestObservedCollection(factory);\n+        doTestAddIndexed(factory);\n+        doTestAddAllIndexed(factory);\n+        doTestRemoveIndexed(factory);\n+        doTestSetIndexed(factory);\n+        // TODO: ITERATOR add/set\n+    }\n+    \n+    public static void bulkTestObservedBag(ObservedFactory factory) {\n+        Assert.assertTrue(factory.createObservedCollection() instanceof ObservedBag);\n+        Assert.assertTrue(factory.createObservedCollection(LISTENER) instanceof ObservedBag);\n+        Assert.assertTrue(factory.createObservedCollection(new StandardModificationHandler()) instanceof ObservedBag);\n+        \n+        bulkTestObservedCollection(factory);\n+        // TODO: bag nCopies\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public static void doTestFactoryPlain(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection();\n+        \n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+    public static void doTestFactoryWithPreListener(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(PRE_LISTENER);\n+        \n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(PRE_LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        PRE_LISTENER.preEvent = null;\n+        coll.add(SIX);\n+        Assert.assertTrue(PRE_LISTENER.preEvent != null);\n+    }\n+    \n+    public static void doTestFactoryWithPostListener(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(POST_LISTENER);\n+        \n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(POST_LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        POST_LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        Assert.assertTrue(POST_LISTENER.postEvent != null);\n+    }\n+    \n+    public static void doTestFactoryWithListener(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent != null);\n+    }\n+    \n+    public static void doTestFactoryWithHandler(ObservedFactory factory) {\n+        StandardModificationHandler handler = new StandardModificationHandler();\n+        ObservedCollection coll = factory.createObservedCollection(handler);\n+        \n+        Assert.assertSame(handler, coll.getHandler());\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+    public static void doTestFactoryWithObject(ObservedFactory factory) {\n+        try {\n+            factory.createObservedCollection(new Object());\n+            Assert.fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public static void doTestFactoryWithNull(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(null);\n+        \n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public static void doTestAddRemoveGetPreListeners(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection();\n+        \n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        coll.getHandler().addPreModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        coll.getHandler().addPreModificationListener(LISTENER2);\n+        Assert.assertEquals(2, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPreModificationListeners()[1]);\n+        \n+        coll.getHandler().removePreModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        coll.getHandler().removePreModificationListener(LISTENER);  // check no error if not present\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        coll.getHandler().removePreModificationListener(LISTENER2);\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        \n+        try {\n+            coll.getHandler().addPreModificationListener(new Object());\n+            Assert.fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+    \n+    public static void doTestAddRemoveGetPostListeners(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection();\n+        \n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+        coll.getHandler().addPostModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        coll.getHandler().addPostModificationListener(LISTENER2);\n+        Assert.assertEquals(2, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPostModificationListeners()[1]);\n+        \n+        coll.getHandler().removePostModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        coll.getHandler().removePostModificationListener(LISTENER);  // check no error if not present\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        coll.getHandler().removePostModificationListener(LISTENER2);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+        \n+        try {\n+            coll.getHandler().addPostModificationListener(new Object());\n+            Assert.fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public static void doTestAdd(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(0, coll.size());\n+        coll.add(SIX);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.add(SEVEN);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(1, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.add(SIX_SEVEN_LIST);\n+        Assert.assertEquals(3, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestAddIndexed(ObservedFactory factory) {\n+        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.add(1, EIGHT);\n+        Assert.assertEquals(3, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestAddAll(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(0, coll.size());\n+        coll.addAll(SIX_SEVEN_LIST);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(0, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestAddAllIndexed(ObservedFactory factory) {\n+        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.addAll(1, SIX_SEVEN_LIST);\n+        Assert.assertEquals(4, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.preEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_ALL_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(4, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestClear(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.clear();\n+        Assert.assertEquals(0, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.CLEAR, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.CLEAR, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(0, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(0, coll.size());\n+        coll.clear();  // already done this\n+        Assert.assertEquals(0, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRemove(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.remove(SEVEN);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.remove(SEVEN);  // already removed\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRemoveIndexed(ObservedFactory factory) {\n+        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.remove(0);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(0, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRemoveAll(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        coll.add(EIGHT);\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(3, coll.size());\n+        coll.removeAll(SIX_SEVEN_LIST);\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ALL, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ALL, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-2, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.removeAll(SIX_SEVEN_LIST);  // already done this\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestRetainAll(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        coll.add(EIGHT);\n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(3, coll.size());\n+        coll.retainAll(SIX_SEVEN_LIST);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.RETAIN_ALL, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(3, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.RETAIN_ALL, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX_SEVEN_LIST, LISTENER.postEvent.getChangeCollection());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(3, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.retainAll(SIX_SEVEN_LIST);  // already done this\n+        Assert.assertEquals(2, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestIteratorRemove(ObservedFactory factory) {\n+        ObservedCollection coll = factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        Iterator it = coll.iterator();\n+        it.next();\n+        it.next();\n+        it.remove();\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.preEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(Boolean.TRUE, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.remove(SEVEN);  // already removed\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void doTestSetIndexed(ObservedFactory factory) {\n+        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        coll.set(0, EIGHT);\n+        Assert.assertEquals(2, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.SET_INDEXED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(0, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(null, LISTENER.preEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.preEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.preEvent.isSizeChanged());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.SET_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(0, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getResult());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(0, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(false, LISTENER.postEvent.isSizeChanged());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/observed/TestAll.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestAll.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Entry point for all collections observed tests.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestAll extends TestCase {\n+    \n+    public TestAll(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestAll.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        \n+        suite.addTest(TestObservedBag.suite());\n+        suite.addTest(TestObservedCollection.suite());\n+        suite.addTest(TestObservedList.suite());\n+        suite.addTest(TestObservedSet.suite());\n+        \n+        return suite;\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedBag.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedBag.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.HashBag;\n+import org.apache.commons.collections.TestBag;\n+\n+/**\n+ * Extension of {@link TestBag} for exercising the\n+ * {@link ObservedBag} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedBag extends TestBag implements ObservedTestHelper.ObservedFactory {\n+    \n+    public TestObservedBag(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedBag.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedBag.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Bag makeBag() {\n+        return ObservedBag.decorate(new HashBag(), ObservedTestHelper.LISTENER);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testObservedSet() {\n+        ObservedTestHelper.bulkTestObservedBag(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public ObservedCollection createObservedCollection() {\n+        return ObservedBag.decorate(new HashBag());\n+    }\n+\n+    public ObservedCollection createObservedCollection(Object listener) {\n+        return ObservedBag.decorate(new HashBag(), listener);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedCollection.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedCollection.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestCollection;\n+\n+/**\n+ * Extension of {@link TestCollection} for exercising the\n+ * {@link ObservedCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedCollection extends TestCollection implements ObservedTestHelper.ObservedFactory {\n+    \n+    public TestObservedCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedCollection.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedCollection.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    protected Collection makeConfirmedFullCollection() {\n+        List list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+    \n+    public Collection makeCollection() {\n+        return ObservedCollection.decorate(new ArrayList(), ObservedTestHelper.LISTENER);\n+    }\n+\n+    protected Collection makeFullCollection() {\n+        List list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return ObservedCollection.decorate(list, ObservedTestHelper.LISTENER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testObservedCollection() {\n+        ObservedTestHelper.bulkTestObservedCollection(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public ObservedCollection createObservedCollection() {\n+        return ObservedCollection.decorate(new ArrayList());\n+    }\n+\n+    public ObservedCollection createObservedCollection(Object listener) {\n+        return ObservedCollection.decorate(new ArrayList(), listener);\n+    }\n+\n+//  public void testFactoryWithMasks() {\n+//      ObservedCollection coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, 0);\n+//      LISTENER.preEvent = null;\n+//      LISTENER.postEvent = null;\n+//      coll.add(SIX);\n+//      assertTrue(LISTENER.preEvent != null);\n+//      assertTrue(LISTENER.postEvent == null);\n+//        \n+//      coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, -1);\n+//      LISTENER.preEvent = null;\n+//      LISTENER.postEvent = null;\n+//      coll.add(SIX);\n+//      assertTrue(LISTENER.preEvent == null);\n+//      assertTrue(LISTENER.postEvent != null);\n+//        \n+//      coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, -1);\n+//      LISTENER.preEvent = null;\n+//      LISTENER.postEvent = null;\n+//      coll.add(SIX);\n+//      assertTrue(LISTENER.preEvent != null);\n+//      assertTrue(LISTENER.postEvent != null);\n+//        \n+//      coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, 0);\n+//      LISTENER.preEvent = null;\n+//      LISTENER.postEvent = null;\n+//      coll.add(SIX);\n+//      assertTrue(LISTENER.preEvent == null);\n+//      assertTrue(LISTENER.postEvent == null);\n+//        \n+//      coll = ObservedCollection.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+//      LISTENER.preEvent = null;\n+//      LISTENER.postEvent = null;\n+//      coll.add(SIX);\n+//      assertTrue(LISTENER.preEvent != null);\n+//      assertTrue(LISTENER.postEvent == null);\n+//  }\n+//    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedList.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestList;\n+\n+/**\n+ * Extension of {@link TestList} for exercising the\n+ * {@link ObservedList} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedList extends TestList implements ObservedTestHelper.ObservedFactory {\n+    \n+    public TestObservedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedList.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedList.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public List makeEmptyList() {\n+        return ObservedList.decorate(new ArrayList(), ObservedTestHelper.LISTENER);\n+    }\n+\n+    protected List makeFullList() {\n+        List set = new ArrayList();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return ObservedList.decorate(set, ObservedTestHelper.LISTENER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testObservedList() {\n+        ObservedTestHelper.bulkTestObservedList(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public ObservedCollection createObservedCollection() {\n+        return ObservedList.decorate(new ArrayList());\n+    }\n+\n+    public ObservedCollection createObservedCollection(Object listener) {\n+        return ObservedList.decorate(new ArrayList(), listener);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/observed/TestObservedSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/TestObservedSet.java,v 1.1 2003/09/03 23:54:25 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.observed;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.TestSet;\n+\n+/**\n+ * Extension of {@link TestSet} for exercising the\n+ * {@link ObservedSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/09/03 23:54:25 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestObservedSet extends TestSet implements ObservedTestHelper.ObservedFactory {\n+    \n+    public TestObservedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestObservedSet.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestObservedSet.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Set makeEmptySet() {\n+        return ObservedSet.decorate(new HashSet(), ObservedTestHelper.LISTENER);\n+    }\n+\n+    protected Set makeFullSet() {\n+        Set set = new HashSet();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return ObservedSet.decorate(set, ObservedTestHelper.LISTENER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testObservedSet() {\n+        ObservedTestHelper.bulkTestObservedSet(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public ObservedCollection createObservedCollection() {\n+        return ObservedSet.decorate(new HashSet());\n+    }\n+\n+    public ObservedCollection createObservedCollection(Object listener) {\n+        return ObservedSet.decorate(new HashSet(), listener);\n+    }\n+\n+}", "timestamp": 1062633266, "metainfo": ""}