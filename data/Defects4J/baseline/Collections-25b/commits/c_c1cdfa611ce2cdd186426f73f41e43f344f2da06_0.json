{"sha": "c1cdfa611ce2cdd186426f73f41e43f344f2da06", "log": "Fix for bug 9719.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/SequencedHashMap.java\n+++ b/src/java/org/apache/commons/collections/SequencedHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.10 2002/05/24 04:00:30 mas Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/05/24 04:00:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.11 2002/06/09 07:14:14 mas Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/06/09 07:14:14 $\n  *\n  * ====================================================================\n  *\n \n   // per Map.remove(Object)\n   public Object remove(Object key) {\n-    modCount++;\n-    return removeImpl(key);\n+    Entry e = removeImpl(key);\n+    return (e == null) ? null : e.getValue();\n   }\n   \n   /**\n-   *  Removed an entry without changing the map's modification count.  This\n-   *  method should only be called from a collection view's iterator\n-   **/\n-  private Object removeImpl(Object key) {\n+   *  Fully remove an entry from the map, returning the old entry or null if\n+   *  there was no such entry with the specified key.\n+   **/\n+  private Entry removeImpl(Object key) {\n     Entry e = (Entry)entries.remove(key);\n     if(e == null) return null;\n+    modCount++;\n     removeEntry(e);\n-    return e.getValue();\n+    return e;\n   }\n \n   /**\n       // required impls\n       public Iterator iterator() { return new OrderedIterator(KEY); }\n       public boolean remove(Object o) {\n-        return SequencedHashMap.this.remove(o) != null;\n+        Entry e = SequencedHashMap.this.removeImpl(o);\n+        return (e != null);\n       }\n \n       // more efficient impls than abstract set\n         if(value == null) {\n           for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n             if(pos.getValue() == null) {\n-              SequencedHashMap.this.remove(pos.getKey());\n+              SequencedHashMap.this.removeImpl(pos.getKey());\n               return true;\n             }\n           } \n         } else {\n           for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n             if(value.equals(pos.getValue())) {\n-              SequencedHashMap.this.remove(pos.getKey());\n+              SequencedHashMap.this.removeImpl(pos.getKey());\n               return true;\n             }\n           }\n         Entry e = findEntry(o);\n         if(e == null) return false;\n \n-        return SequencedHashMap.this.remove(e.getKey()) != null;\n+        return SequencedHashMap.this.removeImpl(e.getKey()) != null;\n       }        \n \n       // more efficient impls than abstract collection\n         throw new ConcurrentModificationException();\n       }\n \n-      // remove the entry by calling the removeImpl method which does not\n-      // update the mod count.  This allows the iterator to remain valid.\n       SequencedHashMap.this.removeImpl(pos.getKey());\n+\n+      // update the expected mod count for the remove operation\n+      expectedModCount++;\n \n       // set the removed flag\n       returnType = returnType | REMOVED_MASK;", "timestamp": 1023606854, "metainfo": ""}