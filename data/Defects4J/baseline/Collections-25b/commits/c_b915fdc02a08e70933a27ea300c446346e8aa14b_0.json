{"sha": "b915fdc02a08e70933a27ea300c446346e8aa14b", "log": "TreeList/CursorableLinkedList/NodeCachingLinkedList/AbstractLinkedList - Fix iterator remove not working properly when called after previous bug 35258  ", "commit": "\n--- a/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n /*\n- *  Copyright 2001-2004 The Apache Software Foundation\n+ *  Copyright 2001-2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n         public void remove() {\n             checkModCount();\n-            parent.removeNode(getLastNodeReturned());\n+            if (current == next) {\n+                // remove() following previous()\n+                next = next.next;\n+                parent.removeNode(getLastNodeReturned());\n+            } else {\n+                // remove() following next()\n+                parent.removeNode(getLastNodeReturned());\n+                nextIndex--;\n+            }\n             current = null;\n-            nextIndex--;\n             expectedModCount++;\n         }\n \n      */\n     protected static class LinkedSubList extends AbstractList {\n         /** The main list */\n-        private AbstractLinkedList parent;\n+        AbstractLinkedList parent;\n         /** Offset from the main list */\n-        private int offset;\n+        int offset;\n         /** Sublist size */\n-        private int size;\n+        int size;\n         /** Sublist modCount */\n-        private int expectedModCount;\n+        int expectedModCount;\n \n         protected LinkedSubList(AbstractLinkedList parent, int fromIndex, int toIndex) {\n             if (fromIndex < 0) {\n--- a/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n /*\n- *  Copyright 2002-2004 The Apache Software Foundation\n+ *  Copyright 2002-2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n  * methods provides access to a <code>Cursor</code> instance which extends\n  * <code>ListIterator</code>. The cursor allows changes to the list concurrent\n  * with changes to the iterator. Note that the {@link #iterator()} method and\n- * sublists  do <b>not</b> provide this cursor behaviour.\n+ * sublists do <b>not</b> provide this cursor behaviour.\n  * <p>\n  * The <code>Cursor</code> class is provided partly for backwards compatibility\n  * and partly because it allows the cursor to be directly closed. Closing the\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Creates a list iterator for the sublist.\n+     * \n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     */\n+    protected ListIterator createSubListListIterator(LinkedSubList subList, int fromIndex) {\n+        SubCursor cursor = new SubCursor(subList, fromIndex);\n+        registerCursor(cursor);\n+        return cursor;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * An extended <code>ListIterator</code> that allows concurrent changes to\n      * the underlying list.\n      */\n         boolean valid = true;\n         /** Is the next index valid */\n         boolean nextIndexValid = true;\n+        /** Flag to indicate if the current element was removed by another object. */\n+        boolean currentRemovedByAnother = false;\n         \n         /**\n          * Constructs a new cursor.\n             super(parent, index);\n             valid = true;\n         }\n-        \n+\n+        /**\n+         * Removes the item last returned by this iterator.\n+         * <p>\n+         * There may have been subsequent alterations to the list\n+         * since you obtained this item, however you can still remove it.\n+         * You can even remove it if the item is no longer in the main list.\n+         * However, you can't call this method on the same iterator more\n+         * than once without calling next() or previous().\n+         *\n+         * @throws IllegalStateException if there is no item to remove\n+         */\n+        public void remove() {\n+            // overridden, as the nodeRemoved() method updates the iterator\n+            // state in the parent.removeNode() call below\n+            if (current == null && currentRemovedByAnother) {\n+                // quietly ignore, as the last returned node was removed\n+                // by the list or some other iterator\n+                // by ignoring it, we keep this iterator independent from\n+                // other changes as much as possible\n+            } else {\n+                checkModCount();\n+                parent.removeNode(getLastNodeReturned());\n+            }\n+            currentRemovedByAnother = false;\n+        }\n+\n         /**\n          * Adds an object to the list.\n          * The object added here will be the new 'previous' in the iterator.\n          * @param obj  the object to add\n          */\n         public void add(Object obj) {\n+            // overridden, as the nodeInserted() method updates the iterator state\n             super.add(obj);\n-            // add on iterator does not return the added element\n+            // matches the (next.previous == node) clause in nodeInserted()\n+            // thus next gets changed - reset it again here\n             next = next.next;\n         }\n+        \n+        // set is not overridden, as it works ok\n+        // note that we want it to throw an exception if the element being\n+        // set has been removed from the real list (compare this with the\n+        // remove method where we silently ignore this case)\n \n         /**\n          * Gets the index of the next element to be returned.\n                 // state where next() followed by previous()\n                 next = node.next;\n                 current = null;\n+                currentRemovedByAnother = true;\n             } else if (node == next) {\n                 // state where next() not followed by previous()\n                 // and we are matching next node\n                 next = node.next;\n+                currentRemovedByAnother = false;\n             } else if (node == current) {\n                 // state where next() not followed by previous()\n                 // and we are matching current (last returned) node\n                 current = null;\n+                currentRemovedByAnother = true;\n                 nextIndex--;\n             } else {\n                 nextIndexValid = false;\n+                currentRemovedByAnother = false;\n             }\n         }\n \n             }\n         }\n     }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A cursor for the sublist based on LinkedSubListIterator.\n+     */\n+    protected static class SubCursor extends Cursor {\n+\n+        /** The parent list */\n+        protected final LinkedSubList sub;\n+\n+        /**\n+         * Constructs a new cursor.\n+         * \n+         * @param index  the index to start from\n+         */\n+        protected SubCursor(LinkedSubList sub, int index) {\n+            super((CursorableLinkedList) sub.parent, index + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        public boolean hasNext() {\n+            return (nextIndex() < sub.size);\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (previousIndex() >= 0);\n+        }\n+\n+        public int nextIndex() {\n+            return (super.nextIndex() - sub.offset);\n+        }\n+\n+        public void add(Object obj) {\n+            super.add(obj);\n+            sub.expectedModCount = parent.modCount;\n+            sub.size++;\n+        }\n+\n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = parent.modCount;\n+            sub.size--;\n+        }\n+    }\n+\n }\n--- a/src/java/org/apache/commons/collections/list/TreeList.java\n+++ b/src/java/org/apache/commons/collections/list/TreeList.java\n         /** The parent list */\n         protected final TreeList parent;\n         /**\n-         * The node that will be returned by {@link #next()}. If this is equal\n-         * to {@link AbstractLinkedList#header} then there are no more values to return.\n+         * Cache of the next node that will be returned by {@link #next()}.\n          */\n         protected AVLNode next;\n         /**\n-         * The index of {@link #next}.\n+         * The index of the next node to be returned.\n          */\n         protected int nextIndex;\n         /**\n-         * The last node that was returned by {@link #next()} or {@link\n-         * #previous()}. Set to <code>null</code> if {@link #next()} or {@link\n-         * #previous()} haven't been called, or if the node has been removed\n-         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Cache of the last node that was returned by {@link #next()}\n+         * or {@link #previous()}.\n          */\n         protected AVLNode current;\n         /**\n-         * The index of {@link #current}.\n+         * The index of the last node that was returned.\n          */\n         protected int currentIndex;\n         /**\n             this.expectedModCount = parent.modCount;\n             this.next = (parent.root == null ? null : parent.root.get(fromIndex));\n             this.nextIndex = fromIndex;\n+            this.currentIndex = -1;\n         }\n \n         /**\n \n         public void remove() {\n             checkModCount();\n-            if (current == null) {\n+            if (currentIndex == -1) {\n                 throw new IllegalStateException();\n             }\n-            parent.remove(currentIndex);\n+            if (nextIndex == currentIndex) {\n+                // remove() following previous()\n+                next = next.next();\n+                parent.remove(currentIndex);\n+            } else {\n+                // remove() following next()\n+                parent.remove(currentIndex);\n+                nextIndex--;\n+            }\n             current = null;\n             currentIndex = -1;\n-            nextIndex--;\n             expectedModCount++;\n         }\n \n--- a/src/test/org/apache/commons/collections/list/AbstractTestList.java\n+++ b/src/test/org/apache/commons/collections/list/AbstractTestList.java\n /*\n- *  Copyright 2001-2004 The Apache Software Foundation\n+ *  Copyright 2001-2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Tests remove on list iterator is correct.\n      */\n-    public void testListListIteratorPreviousRemove() {\n+    public void testListListIteratorPreviousRemoveNext() {\n         if (isRemoveSupported() == false) return;\n         resetFull();\n         ListIterator it = getList().listIterator();\n         assertSame(zero, getList().get(0));\n         assertSame(one, getList().get(1));\n         assertSame(two, getList().get(2));\n-        it.remove();\n+        \n+        it.remove(); // removed element at index 1 (one)\n         assertSame(zero, getList().get(0));\n         assertSame(two, getList().get(1));\n-    }\n-\n+        Object two3 = it.next();  // do next after remove\n+        assertSame(two, two3);\n+        assertEquals(collection.size() > 2, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorPreviousRemovePrevious() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        ListIterator it = getList().listIterator();\n+        Object zero = it.next();\n+        Object one = it.next();\n+        Object two = it.next();\n+        Object two2 = it.previous();\n+        Object one2 = it.previous();\n+        assertSame(one, one2);\n+        assertSame(two, two2);\n+        assertSame(zero, getList().get(0));\n+        assertSame(one, getList().get(1));\n+        assertSame(two, getList().get(2));\n+        \n+        it.remove(); // removed element at index 1 (one)\n+        assertSame(zero, getList().get(0));\n+        assertSame(two, getList().get(1));\n+        Object zero3 = it.previous();  // do previous after remove\n+        assertSame(zero, zero3);\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(collection.size() > 2, it.hasNext());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorNextRemoveNext() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        ListIterator it = getList().listIterator();\n+        Object zero = it.next();\n+        Object one = it.next();\n+        Object two = it.next();\n+        assertSame(zero, getList().get(0));\n+        assertSame(one, getList().get(1));\n+        assertSame(two, getList().get(2));\n+        Object three = getList().get(3);\n+        \n+        it.remove(); // removed element at index 2 (two)\n+        assertSame(zero, getList().get(0));\n+        assertSame(one, getList().get(1));\n+        Object three2 = it.next();  // do next after remove\n+        assertSame(three, three2);\n+        assertEquals(collection.size() > 3, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorNextRemovePrevious() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        ListIterator it = getList().listIterator();\n+        Object zero = it.next();\n+        Object one = it.next();\n+        Object two = it.next();\n+        assertSame(zero, getList().get(0));\n+        assertSame(one, getList().get(1));\n+        assertSame(two, getList().get(2));\n+        \n+        it.remove(); // removed element at index 2 (two)\n+        assertSame(zero, getList().get(0));\n+        assertSame(one, getList().get(1));\n+        Object one2 = it.previous();  // do previous after remove\n+        assertSame(one, one2);\n+        assertEquals(true, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Traverses to the end of the given iterator.\n      *\n--- a/src/test/org/apache/commons/collections/list/TestCursorableLinkedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestCursorableLinkedList.java\n         \n         assertEquals(true, c1.nextIndexValid);\n         assertEquals(1, c1.nextIndex);\n+        assertEquals(true, c1.currentRemovedByAnother);\n         assertEquals(null, c1.current);\n         assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testInternalState_CursorNextRemoveIndex1ByList() {\n         assertEquals(\"A\", c1.next());\n         \n         assertEquals(\"B\", list.remove(1));\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(\"A\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextNextRemoveIndex1ByList() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        \n+        assertEquals(\"B\", list.remove(1));\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(true, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"C\", c1.next());\n+        \n+        assertEquals(\"B\", list.remove(1));\n+        \n+        assertEquals(false, c1.nextIndexValid);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(\"C\", c1.current.value);\n+        assertEquals(\"D\", c1.next.value);\n+        \n+        assertEquals(\"[A, C, D]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, D]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInternalState_CursorNextNextPreviousRemoveByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+        \n+        c1.remove();\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextNextRemoveByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        \n+        c1.remove();\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInternalState_CursorNextNextPreviousAddIndex1ByList() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+        \n+        list.add(1, \"Z\");\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"B\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+        \n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextAddIndex1ByList() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        \n+        list.add(1, \"Z\");\n         \n         assertEquals(true, c1.nextIndexValid);\n         assertEquals(1, c1.nextIndex);\n         assertEquals(\"A\", c1.current.value);\n-        assertEquals(\"C\", c1.next.value);\n-    }\n-\n-    public void testInternalState_CursorNextNextRemoveIndex1ByList() {\n+        assertEquals(\"Z\", c1.next.value);\n+        \n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[Z, B, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextNextAddIndex1ByList() {\n         list.add(\"A\");\n         list.add(\"B\");\n         list.add(\"C\");\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         \n-        assertEquals(\"B\", list.remove(1));\n+        list.add(1, \"Z\");\n+        \n+        assertEquals(false, c1.nextIndexValid);\n+        assertEquals(\"B\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInternalState_CursorNextNextPreviousAddByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+        \n+        c1.add(\"Z\");\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(2, c1.nextIndex);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"B\", c1.next.value);\n+        \n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextNextAddByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        \n+        c1.add(\"Z\");\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(3, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, B, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInternalState_CursorNextNextRemoveByListSetByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        \n+        list.remove(1);\n         \n         assertEquals(true, c1.nextIndexValid);\n         assertEquals(1, c1.nextIndex);\n         assertEquals(null, c1.current);\n         assertEquals(\"C\", c1.next.value);\n-    }\n-\n-    public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {\n-        list.add(\"A\");\n-        list.add(\"B\");\n-        list.add(\"C\");\n-        list.add(\"D\");\n+        assertEquals(\"[A, C]\", list.toString());\n+        \n+        try {\n+            c1.set(\"Z\");\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInternalState_CursorNextNextPreviousSetByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n \n         CursorableLinkedList.Cursor c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n-        assertEquals(\"C\", c1.next());\n-        \n-        assertEquals(\"B\", list.remove(1));\n-        \n-        assertEquals(false, c1.nextIndexValid);\n-        assertEquals(\"C\", c1.current.value);\n-        assertEquals(\"D\", c1.next.value);\n+        assertEquals(\"B\", c1.previous());\n+        \n+        c1.set(\"Z\");\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"Z\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+        \n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testInternalState_CursorNextNextSetByIterator() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        \n+        c1.set(\"Z\");\n+        \n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(2, c1.nextIndex);\n+        assertEquals(\"Z\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+        \n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1121533696, "metainfo": ""}