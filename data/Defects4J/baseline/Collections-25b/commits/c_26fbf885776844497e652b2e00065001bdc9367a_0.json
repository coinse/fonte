{"sha": "26fbf885776844497e652b2e00065001bdc9367a", "log": "fixed List growing issue.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/LazyCollections.java\n+++ b/src/java/org/apache/commons/collections/LazyCollections.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/LazyCollections.java,v 1.1 2002/05/29 02:57:41 arron Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/05/29 02:57:41 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/LazyCollections.java,v 1.2 2002/05/29 03:22:42 arron Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/05/29 03:22:42 $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * @see org.apache.commons.collections.LazySortedMap\n  *\n  * @author Arron Bates\n- * @version $Revision: 1.1 $\n+ * @version $Revision: 1.2 $\n  */\n public class LazyCollections {\n-  \n-  \n+\n+\n   /** Creates a LazyMap whith the provided object factory.\n    *\n    * @param inMap the java.util.Map implementation we have to wrap.\n     /* creates a new lazy map with the provided factory */\n \t  return new LazyMap(inMap, factory);\n   }\n-  \n+\n   /** Creates a LazyMap whith the class definition, which will be used to create\n    * a SimpleObjectFactory which will create a new object from an empty\n    * constructor.\n     SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass);\n \t  return new LazyMap(inMap, f);\n   }\n-  \n+\n   /** Creates a LazyMap whith the class definition and argument details, which\n    * will be used to create a SimpleObjectFactory which will create a new object\n    * from a constructor which requires arguments.\n     /* creates a new lazy sorted map with the provided factory */\n \t  return new LazySortedMap(inMap, factory);\n   }\n-  \n+\n   /** Creates a LazySortedMap whith the class definition, which will be used to\n    * create a SimpleObjectFactory which will create a new object from an empty\n    * constructor.\n     SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass);\n \t  return new LazySortedMap(inMap, f);\n   }\n-  \n+\n   /** Creates a LazySortedMap whith the class definition and argument details,\n    * which will be used to create a SimpleObjectFactory which will create a new\n    * object from a constructor which requires arguments.\n     SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass, argTypes, argObjects);\n     return new LazySortedMap(inMap, f);\n   }\n-  \n-  \n+\n+\n   /** Creates a LazyList whith the provided object factory.\n    *\n    * @param inMap the java.util.List implementation we have to wrap.\n     /* creates a new lazy list with the provided factory */\n     return new LazyList(inList, factory);\n   }\n-  \n+\n   /** Creates a LazyList whith the class definition, which will be used to\n    * create a SimpleObjectFactory which will create a new object from an empty\n    * constructor.\n     SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass);\n     return new LazyList(inList, f);\n   }\n-  \n+\n   /** Creates a LazyList whith the class definition and argument details,\n    * which will be used to create a SimpleObjectFactory which will create a new\n    * object from a constructor which requires arguments.\n     SimpleObjectFactory f = FactoryUtils.createStandardFactory(inClass, argTypes, argObjects);\n     return new LazyList(inList, f);\n   }\n-  \n-  \n-  \n+\n+\n+\n   /** Cleans a List implementation from nulls. Because a rampant index up the\n    * line can create many nulls. At some point, the collection has to become\n    * useful outside of reliable index use. clean() does this.\n       }\n     }\n   }\n-  \n-  \n-  \n+\n+\n+\n   /* This is a java.util.List implementation which provides the means of objects\n    * when requested. When a system expects an object to be provided when accessed\n    * via an index, this collection has been provided the rules (factory reference)\n    * <code>clean()</code> will clear the list of these null references.\n    */\n   private static class LazyList implements List {\n-    \n-    \n+\n+\n     /* Builds a LazyList with the provided SimpleObjectFactory as the means of\n      * creating the objects.\n      */\n       this.listImpl = inList;\n       this.factory = factory;\n     }\n-    \n-    \n+\n+\n     /* Proxy method to the impl's get method. With the exception that if it's out\n      * of bounds, then the collection will grow, leaving place-holders in its\n      * wake, so that an item can be set at any given index. Later the\n      */\n     public Object get(int index) {\n       Object obj;\n-      int size = listImpl.size();\n-      if (index < this.listImpl.size()) {\n+      if (index < (this.listImpl.size()-1)) {\n         /* within bounds, get the object */\n         obj = this.listImpl.get(index);\n         if (obj == null) {\n         }\n       } else {\n         /* we have to grow the list */\n-        for (int i = this.listImpl.size(); i < (this.listImpl.size()-1); i++) {\n+        for (int i = this.listImpl.size(); i < index; i++) {\n           this.listImpl.add(null);\n         }\n         /* create our last object, set and return */\n         return obj;\n       }\n     }\n-  \n-  \n+\n+\n     /* proxy the call to the provided list implementation. */\n     public List subList(int fromIndex, int toIndex) {\n       /* wrap the returned sublist so it can continue the functionality */\n       return new LazyList(this.listImpl.subList(fromIndex, toIndex), factory);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation.*/\n     public int size() {\n       return this.listImpl.size();\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean isEmpty() {\n       return this.listImpl.isEmpty();\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean contains(Object o) {\n       return this.listImpl.contains(o);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public Iterator iterator() {\n       return this.listImpl.iterator();\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public Object[] toArray() {\n       return this.listImpl.toArray();\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public Object[] toArray(Object[] a) {\n       return this.listImpl.toArray(a);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean add(Object o) {\n       return this.listImpl.add(o);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean remove(Object o) {\n       return this.listImpl.remove(o);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean containsAll(Collection c) {\n       return this.listImpl.containsAll(c);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean addAll(Collection c) {\n       return this.listImpl.addAll(c);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean addAll(int index, Collection c) {\n       return this.listImpl.addAll(index, c);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean removeAll(Collection c) {\n       return this.listImpl.removeAll(c);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public boolean retainAll(Collection c) {\n       return this.listImpl.retainAll(c);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public void clear() {\n       this.listImpl.clear();\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public Object set(int index, Object element) {\n       return this.listImpl.set(index, element);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public void add(int index, Object element) {\n       this.listImpl.add(index, element);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public Object remove(int index) {\n       return this.listImpl.remove(index);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public int indexOf(Object o) {\n       return this.listImpl.indexOf(o);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public int lastIndexOf(Object o) {\n       return this.listImpl.lastIndexOf(o);\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public ListIterator listIterator() {\n       return this.listImpl.listIterator();\n     }\n-    \n+\n     /* proxy the call to the provided list implementation. */\n     public ListIterator listIterator(int index) {\n-      return this.listImpl.listIterator(index); \n-    }\n-    \n-  \n-  \n+      return this.listImpl.listIterator(index);\n+    }\n+\n+\n+\n     /* java.util.List implementation to proxy against */\n     private List listImpl;\n-    \n+\n     /* optional object factory */\n     private SimpleObjectFactory factory;\n   }\n-    \n-    \n-    \n-    \n+\n+\n+\n+\n   /* This is a java.util.Map implementation which provides the means of objects\n    * when requested. When a system expects an object to be provided when accessed\n    * via a key, this collection has been provided the rules (factory reference)\n    * collections that hold them.\n    */\n   private static class LazyMap implements Map {\n-    \n-    \n+\n+\n     /* Builds a LazyMap with the provided SimpleObjectFactory as the means of\n      * creating the objects.\n      */\n       this.mapImpl = inMap;\n       this.factory = factory;\n     }\n-    \n-    \n+\n+\n     /* Proxy method to the impl's get method. With the exception that if there\n      * is no keyed object waiting for it, an object will be created, set and\n      * returned.\n       }\n       return obj;\n     }\n-    \n-    \n+\n+\n     /* proxy the call to the provided Map implementation. */\n     public int size() {\n       return this.mapImpl.size();\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public boolean isEmpty() {\n       return this.mapImpl.isEmpty();\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public boolean containsKey(Object key) {\n       return this.mapImpl.containsKey(key);\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public boolean containsValue(Object value) {\n       return this.mapImpl.containsValue(value);\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public Object put(Object key, Object value) {\n       return this.mapImpl.put(key, value);\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public Object remove(Object key) {\n       return this.mapImpl.remove(key);\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public void putAll(Map t) {\n       this.mapImpl.putAll(t);\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public void clear() {\n       this.mapImpl.clear();\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public Set keySet() {\n       return this.mapImpl.keySet();\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public Collection values() {\n       return this.mapImpl.values();\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public Set entrySet() {\n       return this.mapImpl.entrySet();\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public boolean equals(Object o) {\n       return this.mapImpl.equals(o);\n     }\n-    \n+\n     /* proxy the call to the provided Map implementation. */\n     public int hashCode() {\n       return this.mapImpl.hashCode();\n     }\n-  \n-  \n+\n+\n     /* java.util.Map implementation to proxy against */\n     protected Map mapImpl;\n-    \n+\n     /* optional object factory */\n     protected SimpleObjectFactory factory;\n   }\n-  \n-  \n-  \n-  \n-  \n+\n+\n+\n+\n+\n   /* This is a java.util.SortedMap implementation which provides the means of objects\n    * when requested. When a system expects an object to be provided when accessed\n    * via a key, this collection has been provided the rules (factory reference)\n    * collections that hold them.\n    */\n   private static class LazySortedMap extends LazyMap implements SortedMap {\n-    \n-    \n+\n+\n     /* Builds a LazySortedMap with the provided SimpleObjectFactory as the means of\n      * creating the objects.\n      */\n     public LazySortedMap(SortedMap inMap, SimpleObjectFactory factory) {\n       super(inMap, factory);\n     }\n-    \n-    \n+\n+\n     /* proxy the call to the provided LazySortedMap implementation. */\n     public Comparator comparator() {\n       return ((SortedMap)super.mapImpl).comparator();\n     }\n-    \n+\n     /* proxy the call to the provided LazySortedMap implementation. */\n     public SortedMap subMap(Object fromKey, Object toKey) {\n       SortedMap subby = ((SortedMap)super.mapImpl).subMap(fromKey, toKey);\n       return new LazySortedMap(subby, super.factory);\n     }\n-    \n+\n     /* proxy the call to the provided LazySortedMap implementation. */\n     public SortedMap headMap(Object toKey) {\n       SortedMap heady = ((SortedMap)super.mapImpl).headMap(toKey);\n       return new LazySortedMap(heady, super.factory);\n     }\n-    \n+\n     /* proxy the call to the provided LazySortedMap implementation. */\n     public SortedMap tailMap(Object fromKey) {\n       SortedMap tailer = ((SortedMap)super.mapImpl).tailMap(fromKey);\n       return new LazySortedMap(tailer, super.factory);\n     }\n-    \n+\n     /* proxy the call to the provided LazySortedMap implementation. */\n     public Object firstKey() {\n       return ((SortedMap)super.mapImpl).firstKey();\n     }\n-    \n+\n     /* proxy the call to the provided LazySortedMap implementation. */\n     public Object lastKey() {\n       return ((SortedMap)super.mapImpl).lastKey();", "timestamp": 1022642562, "metainfo": ""}