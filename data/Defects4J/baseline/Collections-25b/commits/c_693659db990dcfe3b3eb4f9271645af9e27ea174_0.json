{"sha": "693659db990dcfe3b3eb4f9271645af9e27ea174", "log": "Add documentation indicating that the Bag interface violates the Collection interface.  Submitted by: Paul Jack   ", "commit": "\n--- a/src/java/org/apache/commons/collections/Bag.java\n+++ b/src/java/org/apache/commons/collections/Bag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.6 2002/06/12 03:59:15 mas Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/06/12 03:59:15 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.7 2002/07/19 01:15:01 mas Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/07/19 01:15:01 $\n  *\n  * ====================================================================\n  *\n  * c}</code>.  Calling {@link #getCount(Object)} on <code>a</code> would return\n  * 2, while calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n  *\n+ * <P><I>Note that this interface violates the {@link Collection} contract.</I> \n+ * The behavior specified in many of these methods is <I>not</I> the same\n+ * as the behavior specified by {@link Collection}.  The noncompliant methods\n+ * are clearly marked with \"(Violation)\" in their summary line.  A future\n+ * version of this class will specify the same behavior as {@link Collection},\n+ * which unfortunately will break backwards compatibility with this version.\n+ *\n  * @since 2.0\n  * @author Chuck Burdick\n  **/\n    public int getCount(Object o);\n \n    /**\n+    * <I>(Violation)</I>\n     * Add the given object to the bag and keep a count. If the object\n     * is already in the {@link #uniqueSet()} then increment its count as\n     * reported by {@link #getCount(Object)}. Otherwise add it to the {@link\n-    * #uniqueSet()} and report its count as 1.\n+    * #uniqueSet()} and report its count as 1.<P>\n+    *\n+    * Since this method always increases the size of the bag,\n+    * according to the {@link Collection#add(Object)} contract, it \n+    * should always return <Code>true</Code>.  Since it sometimes returns\n+    * <Code>false</Code>, this method violates the contract.  A future\n+    * version of this method will comply by always returning <Code>true</Code>.\n+    *\n     * @return <code>true</code> if the object was not already in the\n     *         <code>uniqueSet</code>\n     * @see #getCount(Object)\n    public boolean add(Object o, int i);\n \n    /**\n+    * <I>(Violation)</I>\n     * Remove all occurrences of the given object from the bag, and do\n     * not represent the object in the {@link #uniqueSet()}.\n+    *\n+    * <P>According to the {@link Collection#remove(Object)} method,\n+    * this method should only remove the <I>first</I> occurrence of the\n+    * given object, not <I>all</I> occurrences.  A future version of this\n+    * method will comply with the contract by only removing one occurrence\n+    * of the given object.\n+    *\n     * @see #remove(Object, int)\n     * @return <code>true</code> if this call changed the collection\n     **/\n    public int size();\n \n    /**\n+    * <I>(Violation)</I>\n     * Returns <code>true</code> if the bag contains all elements in\n     * the given collection, respecting cardinality.  That is, if the\n     * given collection <code>C</code> contains <code>n</code> copies\n     * of a given object, calling {@link #getCount(Object)} on that object must\n     * be <code>&gt;= n</code> for all <code>n</code> in <code>C</code>.\n+    *\n+    * <P>The {@link Collection#containsAll(Collection)} method specifies\n+    * that cardinality should <I>not</I> be respected; this method should\n+    * return true if the bag contains at least one of every object contained\n+    * in the given collection.  A future version of this method will comply\n+    * with that contract.\n     **/\n    public boolean containsAll(Collection c);\n \n    /**\n+    * <I>(Violation)</I>\n     * Remove all elements represented in the given collection,\n     * respecting cardinality.  That is, if the given collection\n     * <code>C</code> contains <code>n</code> copies of a given object,\n     * the bag will have <code>n</code> fewer copies, assuming the bag\n     * had at least <code>n</code> copies to begin with.\n+    *\n+    * <P>The {@link Collection#removeAll(Collection)} method specifies\n+    * that cardinality should <I>not</I> be respected; this method should\n+    * remove <I>all</I> occurrences of every object contained in the \n+    * given collection.  A future version of this method will comply\n+    * with that contract.\n+    *\n     * @return <code>true</code> if this call changed the collection\n     **/\n    public boolean removeAll(Collection c);\n \n    /**\n+    * <I>(Violation)</I>\n     * Remove any members of the bag that are not in the given\n     * collection, respecting cardinality.  That is, if the given\n     * collection <code>C</code> contains <code>n</code> copies of a\n     * <code>!C.contains(e)</code>, then remove <code>e</code> and any\n     * of its copies.\n     *\n+    * <P>The {@link Collection#retainAll(Collection)} method specifies\n+    * that cardinality should <I>not</I> be respected; this method should\n+    * keep <I>all</I> occurrences of every object contained in the \n+    * given collection.  A future version of this method will comply\n+    * with that contract.\n+    *\n     * @return <code>true</code> if this call changed the collection\n     **/\n    public boolean retainAll(Collection c);", "timestamp": 1027041301, "metainfo": ""}