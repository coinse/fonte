{"sha": "cc8f778554ca2e941bd74fdfc3d41ef88ba3aa3c", "log": "Add TreeIterator for iterating over object graphs   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/iterators/TreeIterator.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+\n+/**\n+ * An Iterator that can traverse multiple iterators down an object graph.\n+ * <p>\n+ * This iterator can extract multiple objects from a complex tree-like object graph.\n+ * The iteration starts from a single root object.\n+ * It uses a <code>Transformer</code> to extract the iterators and elements.\n+ * Its main benefit is that no intermediate <code>List</code> is created.\n+ * <p>\n+ * For example, consider an object graph:\n+ * <pre>\n+ *                 |- Branch -- Leaf\n+ *                 |         \\- Leaf\n+ *         |- Tree |         /- Leaf\n+ *         |       |- Branch -- Leaf\n+ *  Forest |                 \\- Leaf\n+ *         |       |- Branch -- Leaf\n+ *         |       |         \\- Leaf\n+ *         |- Tree |         /- Leaf\n+ *                 |- Branch -- Leaf\n+ *                 |- Branch -- Leaf</pre>\n+ * The following <code>Transformer</code>, used in this class, will extract all\n+ * the Leaf objects without creating a combined intermediate list:\n+ * <pre>\n+ * public Object transform(Object input) {\n+ *   if (input instanceof Forest) {\n+ *     return ((Forest) input).treeIterator();\n+ *   }\n+ *   if (input instanceof Tree) {\n+ *     return ((Tree) input).branchIterator();\n+ *   }\n+ *   if (input instanceof Branch) {\n+ *     return ((Branch) input).leafIterator();\n+ *   }\n+ *   if (input instanceof Leaf) {\n+ *     return input;\n+ *   }\n+ *   throw new ClassCastException();\n+ * }</pre>\n+ * <p>\n+ * Internally, iteration starts from the root object. When next is called,\n+ * the transformer is called to examine the object. The transformer will return\n+ * either an iterator or an object. If the object is an Iterator, the next element\n+ * from that iterator is obtained and the process repeats. If the element is an object\n+ * it is returned.\n+ * <p>\n+ * Under many circumstances, linking Iterators together in this manner is\n+ * more efficient (and convenient) than using nested for loops to extract a list.\n+ * \n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/03/14 23:27:22 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TreeIterator implements Iterator {\n+\n+    /** The stack of iterators */\n+    protected final ArrayStack stack = new ArrayStack(8);\n+\t/** The root object in the tree */\n+    protected Object root;\n+    /** The transformer to use */\n+    protected Transformer transformer;\n+\n+    /** Whether there is another element in the iteration */\n+    protected boolean hasNext = false;    \n+    /** The current iterator */\n+    protected Iterator currentIterator;\n+    /** The current value */\n+    protected Object currentValue;\n+    /** The last used iterator, needed for remove() */\n+    protected Iterator lastUsedIterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a TreeIterator using a root object and transformer.\n+     * <p>\n+     * The root object can be an iterator, in which case it will be immediately\n+     * looped around.\n+     * \n+     * @param root  the root object, null will result in an empty iterator\n+     * @param transformer  the transformer to use, null will use a no effect transformer\n+     */\n+    public TreeIterator(Object root, Transformer transformer) {\n+        super();\n+        if (root instanceof Iterator) {\n+            this.currentIterator = (Iterator) root;\n+        } else {\n+            this.root = root;\n+        }\n+        this.transformer = (transformer == null ? TransformerUtils.nopTransformer() : transformer);\n+    }\n+\n+    /**\n+     * Constructs a TreeIterator that will handle an iterator of iterators.\n+     * <p>\n+     * This constructor exists for convenience to emphasise that this class can\n+     * be used to iterate over nested iterators. That is to say that the iterator\n+     * passed in here contains other iterators, which may in turn contain further\n+     * iterators.\n+     * \n+     * @param rootIterator  the root iterator, null will result in an empty iterator\n+     */\n+    public TreeIterator(Iterator rootIterator) {\n+        super();\n+        this.currentIterator = rootIterator;\n+        this.transformer = TransformerUtils.nopTransformer();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Loops around the iterators to find the next value to return.\n+     */\n+    protected void updateCurrentIterator() {\n+        if (hasNext) {\n+            return;\n+        }\n+        if (currentIterator == null) {\n+            if (root == null) {\n+                // do nothing, hasNext will be false\n+            } else {\n+                Object value = transformer.transform(root);\n+                findNext(value);\n+                root = null;\n+            }\n+        } else {\n+            findNext(currentIterator);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next object in the iteration.\n+     * \n+     * @param value  the value to start from\n+     */\n+    protected void findNext(Object value) {\n+        if (value instanceof Iterator) {\n+            if (value != currentIterator) {\n+                // recurse a level\n+                if (currentIterator != null) {\n+                    stack.push(currentIterator);\n+                }\n+                currentIterator = (Iterator) value;\n+            }\n+            \n+            while (currentIterator.hasNext() && hasNext == false) {\n+                Object next = currentIterator.next();\n+                next = transformer.transform(next);\n+                findNext(next);\n+            }\n+            if (hasNext) {\n+                // next value found\n+            } else if (stack.isEmpty()) {\n+                // all iterators exhausted\n+            } else {\n+                // current iterator exhausted, go up a level\n+                currentIterator = (Iterator) stack.pop();\n+                findNext(currentIterator);\n+            }\n+        } else {\n+            // next value found\n+            currentValue = value;\n+            hasNext = true;\n+        }\n+    }\n+    \n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more elements in the tree to obtain.\n+     * \n+     * @return true if elements remain in the iteration\n+     */\n+    public boolean hasNext() {\n+        updateCurrentIterator();\n+        return hasNext;\n+    }\n+\n+    /**\n+     * Gets the next element of the iteration.\n+     * \n+     * @return the next element from the iteration\n+     * @throws NoSuchElementException if all the Iterators are exhausted\n+     */\n+    public Object next() {\n+        updateCurrentIterator();\n+        if (hasNext == false) {\n+            throw new NoSuchElementException(\"No more elements in the iteration\");\n+        }\n+        lastUsedIterator = currentIterator;\n+        Object result = currentValue;\n+        currentValue = null;\n+        hasNext = false;\n+        return result;\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned.\n+     * <p>\n+     * This method calls remove() on the underlying Iterator and it may\n+     * throw an UnsupportedOperationException if the underlying Iterator\n+     * does not support this method. \n+     * \n+     * @throws UnsupportedOperationException\n+     *   if the remove operator is not supported by the underlying Iterator\n+     * @throws IllegalStateException\n+     *   if the next method has not yet been called, or the remove method has\n+     *   already been called after the last call to the next method.\n+     */\n+    public void remove() {\n+        if (lastUsedIterator == null) {\n+            throw new IllegalStateException(\"Iterator remove() cannot be called at this time\");\n+        }\n+        lastUsedIterator.remove();\n+        lastUsedIterator = null;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/iterators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestAll.java\n /**\n  * Entry point for all iterator tests.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/02/18 01:20:33 $\n+ * @version $Revision: 1.13 $ $Date: 2004/03/14 23:27:22 $\n  * \n  * @author Rodney Waldhoff\n  */\n         suite.addTest(TestLoopingIterator.suite());\n         suite.addTest(TestSingletonIterator.suite());\n         suite.addTest(TestSingletonListIterator.suite());\n+        suite.addTest(TestTreeIterator.suite());\n         suite.addTest(TestUniqueFilterIterator.suite());\n         suite.addTest(TestUnmodifiableIterator.suite());\n         suite.addTest(TestUnmodifiableListIterator.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/iterators/TestTreeIterator.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Testcase.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/03/14 23:27:22 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestTreeIterator extends AbstractTestIterator {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" };\n+\n+    protected List list1 = null;\n+    protected List list2 = null;\n+    protected List list3 = null;\n+    protected List iteratorList = null;\n+\n+    public TestTreeIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestTreeIterator.class);\n+    }\n+\n+    public void setUp() {\n+        list1 = new ArrayList();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");\n+        iteratorList = new ArrayList();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Iterator makeEmptyIterator() {\n+        ArrayList list = new ArrayList();\n+        return new TreeIterator(list.iterator(), null);\n+    }\n+\n+    public Iterator makeFullIterator() {\n+        return new TreeIterator(iteratorList.iterator(), null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteratorConstructor_null1() {\n+        Iterator it = new TreeIterator(null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructor_null_next() {\n+        Iterator it = new TreeIterator(null);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructor_null_remove() {\n+        Iterator it = new TreeIterator(null);\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteratorConstructorIteration_Empty() {\n+        List iteratorList = new ArrayList();\n+        Iterator it = new TreeIterator(iteratorList.iterator());\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_Simple() {\n+        List iteratorList = new ArrayList();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator it = new TreeIterator(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_SimpleNoHasNext() {\n+        List iteratorList = new ArrayList();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator it = new TreeIterator(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+        }\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_WithEmptyIterators() {\n+        List iteratorList = new ArrayList();\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        Iterator it = new TreeIterator(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorRemove() {\n+        List iteratorList = new ArrayList();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator it = new TreeIterator(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+            it.remove();\n+        }\n+        assertEquals(false, it.hasNext());\n+        assertEquals(0, list1.size());\n+        assertEquals(0, list2.size());\n+        assertEquals(0, list3.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteration_IteratorOfIterators() {\n+        List iteratorList = new ArrayList();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator it = new TreeIterator(iteratorList.iterator(), null);\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    public void testIteration_IteratorOfIteratorsWithEmptyIterators() {\n+        List iteratorList = new ArrayList();\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.EMPTY_ITERATOR);\n+        Iterator it = new TreeIterator(iteratorList.iterator(), null);\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteration_RootNull() {\n+        Iterator it = new TreeIterator(null, null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteration_RootNoTransformer() {\n+        Forest forest = new Forest();\n+        Iterator it = new TreeIterator(forest, null);\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(forest, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed1() {\n+        Forest forest = new Forest();\n+        Leaf l1 = forest.addTree().addBranch().addLeaf();\n+        Iterator it = new TreeIterator(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed2() {\n+        Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        Branch b1 = forest.getTree(0).addBranch();\n+        Branch b2 = forest.getTree(0).addBranch();\n+        Branch b3 = forest.getTree(2).addBranch();\n+        Branch b4 = forest.getTree(2).addBranch();\n+        Branch b5 = forest.getTree(2).addBranch();\n+        Leaf l1 = b1.addLeaf();\n+        Leaf l2 = b1.addLeaf();\n+        Leaf l3 = b2.addLeaf();\n+        Leaf l4 = b3.addLeaf();\n+        Leaf l5 = b5.addLeaf();\n+\n+        Iterator it = new TreeIterator(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l2, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l3, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l4, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l5, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed3() {\n+        Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        Branch b1 = forest.getTree(1).addBranch();\n+        Branch b2 = forest.getTree(1).addBranch();\n+        Branch b3 = forest.getTree(2).addBranch();\n+        Branch b4 = forest.getTree(2).addBranch();\n+        Branch b5 = forest.getTree(2).addBranch();\n+        Leaf l1 = b1.addLeaf();\n+        Leaf l2 = b1.addLeaf();\n+        Leaf l3 = b2.addLeaf();\n+        Leaf l4 = b3.addLeaf();\n+        Leaf l5 = b4.addLeaf();\n+\n+        Iterator it = new TreeIterator(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l2, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l3, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l4, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l5, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class LeafFinder implements Transformer {\n+        public Object transform(Object input) {\n+            if (input instanceof Forest) {\n+                return ((Forest) input).treeIterator();\n+            }\n+            if (input instanceof Tree) {\n+                return ((Tree) input).branchIterator();\n+            }\n+            if (input instanceof Branch) {\n+                return ((Branch) input).leafIterator();\n+            }\n+            if (input instanceof Leaf) {\n+                return input;\n+            }\n+            throw new ClassCastException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class Forest {\n+        List trees = new ArrayList();\n+\n+        Tree addTree() {\n+            trees.add(new Tree());\n+            return getTree(trees.size() - 1);\n+        }\n+\n+        Tree getTree(int index) {\n+            return (Tree) trees.get(index);\n+        }\n+\n+        Iterator treeIterator() {\n+            return trees.iterator();\n+        }\n+    }\n+\n+    static class Tree {\n+        List branches = new ArrayList();\n+\n+        Branch addBranch() {\n+            branches.add(new Branch());\n+            return getBranch(branches.size() - 1);\n+        }\n+\n+        Branch getBranch(int index) {\n+            return (Branch) branches.get(index);\n+        }\n+\n+        Iterator branchIterator() {\n+            return branches.iterator();\n+        }\n+    }\n+\n+    static class Branch {\n+        List leaves = new ArrayList();\n+\n+        Leaf addLeaf() {\n+            leaves.add(new Leaf());\n+            return getLeaf(leaves.size() - 1);\n+        }\n+\n+        Leaf getLeaf(int index) {\n+            return (Leaf) leaves.get(index);\n+        }\n+\n+        Iterator leafIterator() {\n+            return leaves.iterator();\n+        }\n+    }\n+\n+    static class Leaf {\n+        String colour;\n+\n+        String getColour() {\n+            return colour;\n+        }\n+\n+        void setColour(String colour) {\n+            this.colour = colour;\n+        }\n+    }\n+\n+}", "timestamp": 1079306842, "metainfo": ""}