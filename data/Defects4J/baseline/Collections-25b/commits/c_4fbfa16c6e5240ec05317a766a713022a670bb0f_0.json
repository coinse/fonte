{"sha": "4fbfa16c6e5240ec05317a766a713022a670bb0f", "log": "Performance optimised LinkedList, from Jeff Varszegi   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/NodeCachingLinkedList.java,v 1.1 2002/11/18 23:58:17 scolebourne Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/11/18 23:58:17 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+/**\n+ * <code>NodeCachingLinkedList</code> is a linked list implementation that \n+ * provides better performance than java.util.LinkedList.\n+ * <p>\n+ * This class differs from java.util.LinkedList in that internal Node \n+ * objects used to hold the elements are not necessarily thrown away when an\n+ * entry is removed from the list. Instead, they are cached, which allows this\n+ * implementation to give better performance than java.util.LinkedList with a\n+ * small space penalty.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b> If multiple\n+ * threads access a list concurrently, and at least one of the threads\n+ * modifies the list structurally, it <i>must</i> be synchronized\n+ * externally.\n+ * <p>\n+ * The iterators returned by the this class's <code>iterator</code> and\n+ * <code>listIterator</code> methods are <i>fail-fast</i>: if the list is\n+ * structurally modified at any time after the iterator is created, in any way\n+ * except through the Iterator's own <code>remove</code> or <code>add</code> methods,\n+ * the iterator will throw a <code>ConcurrentModificationException</code>.  Thus,\n+ * in the face of concurrent modification, the iterator fails quickly and\n+ * cleanly, rather than risking arbitrary, non-deterministic behavior at an\n+ * undetermined time in the future.\n+ * <p>\n+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n+ * as it is, generally speaking, impossible to make any hard guarantees in the\n+ * presence of unsynchronized concurrent modification.  Fail-fast iterators\n+ * throw <code>ConcurrentModificationException</code> on a best-effort basis. \n+ * Therefore, it would be wrong to write a program that depended on this\n+ * exception for its correctness:   <i>the fail-fast behavior of iterators\n+ * should be used only to detect bugs.</i>\n+ *\n+ * @author Jeff Varszegi\n+ */\n+public final class NodeCachingLinkedList \n+        extends LinkedList \n+        implements List, Cloneable, Serializable {\n+            \n+    private static final int MINIMUM_MAXIMUM_CACHE_SIZE = 100;\n+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000000;\n+\n+    private Node cacheHeader = new Node(null, null, null);\n+    private int cacheCount = 0;\n+\n+    private int maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n+\n+    private Node header = new Node(null, null, null);\n+    private int size = 0;\n+    \n+    /**\n+     * Constructs an empty list.\n+     */\n+    public NodeCachingLinkedList() {\n+        header.next = header.previous = header;\n+    }\n+\n+    /**\n+     * Constructs a list containing the elements of the specified\n+     * collection, in the order they are returned by the collection's\n+     * iterator.\n+     *\n+     * @param coll the collection whose elements are to be placed into this list.\n+     * @throws NullPointerException if the specified collection is null.\n+     */\n+    public NodeCachingLinkedList(Collection coll) {\n+        this();\n+        addAll(coll);\n+    }\n+    \n+    /**\n+     * Sets the maximum number of elements that may be held in the internal\n+     * reusable node cache.\n+     * \n+     * @return the maximum cache size\n+     */\n+    public int getMaximumCacheSize() {\n+        return maximumCacheSize;\n+    }\n+\n+    /**\n+     * Sets the maximum number of elements that may be held in the internal\n+     * reusable node cache.\n+     * \n+     * @param maximumCacheSize the maximum cache size to set\n+     */\n+    public void setMaximumCacheSize(int maximumCacheSize) {\n+        this.maximumCacheSize = maximumCacheSize;\n+    }\n+    \n+    /**\n+     * Returns the first element in this list.\n+     * \n+     * @return the first object in the list\n+     * @throws NoSuchElementException if this list is empty\n+     */\n+    public Object getFirst() {\n+        if (size == 0) {\n+            throw new NoSuchElementException();\n+        }\n+        else {\n+            return header.next.element;\n+        }\n+    }\n+\n+    /**\n+     * Returns the last element in this list.\n+     * \n+     * @return the last object in the list\n+     * @throws NoSuchElementException if this list is empty\n+     */\n+    public Object getLast() {\n+        if (size == 0) {\n+            throw new NoSuchElementException();\n+        }\n+        return header.previous.element;\n+    }\n+\n+    /**\n+     * Removes and returns the first element from this list.\n+     *\n+     * @return the first element from this list, now removed\n+     * @throws NoSuchElementException if this list is empty\n+     */\n+    public Object removeFirst() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(); \n+        }\n+        Node firstNode = header.next;\n+        Object first = firstNode.element;\n+        \n+        firstNode.next.previous = header;\n+        header.next = firstNode.next;\n+        size--;\n+        modCount++;\n+\n+        if (cacheCount < maximumCacheSize) {\n+            \n+            firstNode.element = null;\n+            firstNode.next = cacheHeader.next;\n+            cacheHeader.next = firstNode;\n+            cacheCount++;\n+        }\n+                \n+        return first;\n+    }\n+\n+    /**\n+     * Removes and returns the last element from this list.\n+     *\n+     * @return the last element from this list, now removed\n+     * @throws NoSuchElementException if this list is empty\n+     */\n+    public Object removeLast() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(); \n+\n+        }\n+        Node lastNode = header.previous;\n+        Object last = lastNode.element;\n+\n+        lastNode.previous.next = header;\n+        header.previous = lastNode.previous;\n+        size--;\n+        modCount++;\n+\n+        if (cacheCount < maximumCacheSize) {\n+            lastNode.element = null;\n+            lastNode.previous = null;\n+            lastNode.next = cacheHeader.next;\n+            cacheHeader.next = lastNode;\n+            cacheCount++;\n+        }\n+        \n+        return last;\n+    }\n+    \n+    /**\n+     * Inserts the given element at the beginning of this list.\n+     * \n+     * @param obj the element to be inserted at the beginning of this list\n+     */\n+    public void addFirst(Object obj) {\n+        Node newNode;\n+          \n+        if (cacheCount > 0) {\n+            newNode = cacheHeader.next;\n+            cacheHeader.next = newNode.next;\n+            newNode.element = obj;\n+            newNode.next = header.next;\n+            newNode.previous = header;\n+            cacheCount--;\n+        }\n+        else {\n+            newNode = new Node(obj, header.next, header);\n+        }\n+        \n+        newNode.previous.next = newNode;\n+        newNode.next.previous = newNode;\n+        size++;\n+        modCount++;\n+    }\n+    \n+    /**\n+     * Appends the given element to the end of this list.  (Identical in\n+     * function to the <code>add</code> method; included only for consistency.)\n+     * \n+     * @param obj the element to be inserted at the end of this list\n+     */\n+    public void addLast(Object obj) {\n+        Node newNode;\n+\n+        if (cacheCount > 0) {\n+            newNode = cacheHeader.next;\n+            cacheHeader.next = newNode.next;\n+            newNode.element = obj;\n+            newNode.next = header.next;\n+            newNode.previous = header;\n+            cacheCount--;\n+        }\n+        else {\n+            newNode = new Node(obj, header, header.previous);\n+        }\n+\n+\n+  \n+        newNode.previous.next = newNode;\n+        newNode.next.previous = newNode;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if this list contains the specified element.\n+     * More formally, returns <code>true</code> if and only if this list contains\n+     * at least one element <code>e</code> such that <code>(o==null ? e==null\n+     * : o.equals(e))</code>.\n+     *\n+     * @param obj element whose presence in this list is to be tested\n+     * @return <code>true</code> if this list contains the specified element\n+     */\n+    public boolean contains(Object obj) {\n+        return indexOf(obj) != -1;\n+    }\n+\n+    /**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param obj element to be appended to this list.\n+     * @return <code>true</code> (as per the general contract of\n+     * <code>Collection.add</code>)\n+     */\n+    public boolean add(Object obj) {\n+        addLast(obj);\n+        return true;\n+    }\n+\n+    /**\n+     * Removes the first occurrence of the specified element in this list.  If\n+     * the list does not contain the element, it is unchanged.  More formally,\n+     * removes the element with the lowest index <code>i</code> such that\n+     * <code>(o==null ? get(i)==null : o.equals(get(i)))</code> (if such an\n+     * element exists).\n+     *\n+     * @param obj element to be removed from this list, if present\n+     * @return <code>true</code> if the list contained the specified element\n+     */\n+    public boolean remove(Object obj) {\n+        if (obj == null) {\n+            for (Node e = header.next; e != header; e = e.next) {\n+                if (e.element == null) {\n+                    remove(e);\n+                    return true;\n+                }\n+            }\n+        }\n+        else {\n+            for (Node e = header.next; e != header; e = e.next) {\n+                if (obj.equals(e.element)) {\n+                    remove(e);\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Appends all of the elements in the specified collection to the end of\n+     * this list, in the order that they are returned by the specified\n+     * collection's iterator.  The behavior of this operation is undefined if\n+     * the specified collection is modified while the operation is in\n+     * progress.  (This implies that the behavior of this call is undefined if\n+     * the specified Collection is this list, and this list is nonempty.)\n+     *\n+     * @param coll the elements to be inserted into this list\n+     * @return <code>true</code> if this list changed as a result of the call\n+     * @throws NullPointerException if the specified collection is null\n+     */\n+    public boolean addAll(Collection coll) {\n+        return addAll(size, coll);\n+    }\n+\n+    /**\n+     * Inserts all of the elements in the specified collection into this\n+     * list, starting at the specified position.  Shifts the element\n+     * currently at that position (if any) and any subsequent elements to\n+     * the right (increases their indices).  The new elements will appear\n+     * in the list in the order that they are returned by the\n+     * specified collection's iterator.\n+     *\n+     * @param index index at which to insert first element\n+     *          from the specified collection\n+     * @param coll elements to be inserted into this list\n+     * @return <code>true</code> if this list changed as a result of the call\n+     * @throws IndexOutOfBoundsException if the specified index is out of\n+     *            range (<code>index &lt; 0 || index &gt; size()</code>)\n+     * @throws NullPointerException if the specified collection is null\n+     */\n+    public boolean addAll(int index, Collection coll) {\n+        int numNew = coll.size();\n+        if (numNew == 0)\n+            return false;\n+        modCount++;\n+\n+        Node successor = (index == size ? header : entry(index));\n+        Node predecessor = successor.previous;\n+        Iterator it = coll.iterator();\n+        for (int i = 0; i < numNew; i++) {\n+            Node e; \n+            if (cacheCount > 0) {\n+                e = cacheHeader.next;\n+                cacheHeader.next = e.next;\n+                e.element = it.next();\n+                e.next = successor;\n+                e.previous = predecessor;\n+            }\n+            else {\n+                e = new Node(it.next(), successor, predecessor);\n+            }\n+            \n+            predecessor.next = e;\n+            predecessor = e;\n+        }\n+        successor.previous = predecessor;\n+\n+        size += numNew;\n+        return true;\n+    }\n+\n+    /**\n+     * Removes all of the elements from this list.\n+     */\n+    public void clear() {\n+        modCount++;\n+        header.next = header.previous = header;\n+        size = 0;\n+    }\n+\n+    // Positional Access Operations\n+\n+    /**\n+     * Returns the element at the specified position in this list.\n+     *\n+     * @param index index of element to return\n+     * @return the element at the specified position in this list\n+     * \n+     * @throws IndexOutOfBoundsException if the specified index is is out of\n+     * range (<code>index &lt; 0 || index &gt;= size()</code>)\n+     */\n+    public Object get(int index) {\n+        if (index < 0 || index >= size) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n+        }\n+        Node e = header;\n+        if (index < (size >> 1)) {\n+            for (int i = 0; i <= index; i++) {\n+                e = e.next;\n+            }\n+        }\n+        else {\n+            for (int i = size; i > index; i--) {\n+                e = e.previous;\n+            }\n+        }\n+        return e.element;\n+    }\n+\n+    /**\n+     * Replaces the element at the specified position in this list with the\n+     * specified element.\n+     *\n+     * @param index index of element to replace\n+     * @param element element to be stored at the specified position\n+     * @return the element previously at the specified position\n+     * @throws IndexOutOfBoundsException if the specified index is out of\n+     *        range (<code>index &lt; 0 || index &gt;= size()</code>)\n+     */\n+    public Object set(int index, Object element) {\n+        Node e = entry(index);\n+        Object oldVal = e.element;\n+        e.element = element;\n+        return oldVal;\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position in this list.\n+     * Shifts the element currently at that position (if any) and any\n+     * subsequent elements to the right (adds one to their indices).\n+     *\n+     * @param index index at which the specified element is to be inserted\n+     * @param element element to be inserted\n+     * \n+     * @throws IndexOutOfBoundsException if the specified index is out of\n+     *        range (<code>index &lt; 0 || index &gt; size()</code>)\n+     */\n+    public void add(int index, Object element) {\n+        Node e = (index == size ? header : entry(index));\n+        Node newNode; \n+        if (cacheCount > 0) {\n+            newNode = cacheHeader.next;\n+            cacheHeader.next = newNode.next;\n+            newNode.element = element;\n+            newNode.next = e;\n+            newNode.previous = e.previous;\n+        }\n+        else {\n+            newNode = new Node(element, e, e.previous);\n+        }\n+        \n+        newNode.previous.next = newNode;\n+        newNode.next.previous = newNode;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this list.  Shifts any\n+     * subsequent elements to the left (subtracts one from their indices).\n+     * Returns the element that was removed from the list.\n+     *\n+     * @param index the index of the element to removed\n+     * @return the element previously at the specified position\n+     * \n+     * @throws IndexOutOfBoundsException if the specified index is out of\n+     *        range (<code>index &lt; 0 || index &gt;= size()</code>)\n+     */\n+    public Object remove(int index) {\n+        Node e = entry(index);\n+        Object data = e.element;\n+        remove(e);\n+        return data;\n+    }\n+\n+    /**\n+     * Return the indexed entry.\n+     */\n+    private Node entry(int index) {\n+        if (index < 0 || index >= size) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n+        }\n+        Node e = header;\n+        if (index < (size >> 1)) {\n+            for (int i = 0; i <= index; i++) {\n+                e = e.next;\n+            }\n+        }\n+        else {\n+            for (int i = size; i > index; i--) {\n+                e = e.previous;\n+            }\n+        }\n+        return e;\n+    }\n+\n+    // Search Operations\n+\n+    /**\n+     * Returns the index in this list of the first occurrence of the\n+     * specified element, or -1 if the List does not contain this\n+     * element.  More formally, returns the lowest index i such that\n+     * <code>(o==null ? get(i)==null : o.equals(get(i)))</code>, or -1 if\n+     * there is no such index.\n+     *\n+     * @param obj element to search for\n+     * @return the index in this list of the first occurrence of the\n+     *         specified element, or -1 if the list does not contain this\n+     *         element\n+     */\n+    public int indexOf(Object obj) {\n+        int index = 0;\n+        if (obj == null) {\n+            for (Node e = header.next; e != header; e = e.next) {\n+                if (e.element == null)\n+                    return index;\n+                index++;\n+            }\n+        }\n+        else {\n+            for (Node e = header.next; e != header; e = e.next) {\n+                if (obj.equals(e.element))\n+                    return index;\n+                index++;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns the index in this list of the last occurrence of the\n+     * specified element, or -1 if the list does not contain this\n+     * element.  More formally, returns the highest index i such that\n+     * <code>(o==null ? get(i)==null : o.equals(get(i)))</code>, or -1 if\n+     * there is no such index.\n+     *\n+     * @param obj element to search for\n+     * @return the index in this list of the last occurrence of the\n+     *         specified element, or -1 if the list does not contain this\n+     *         element\n+     */\n+    public int lastIndexOf(Object obj) {\n+        int index = size;\n+        if (obj == null) {\n+            for (Node e = header.previous; e != header; e = e.previous) {\n+                index--;\n+                if (e.element == null)\n+                    return index;\n+            }\n+        }\n+        else {\n+            for (Node e = header.previous; e != header; e = e.previous) {\n+                index--;\n+                if (obj.equals(e.element))\n+                    return index;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns a list-iterator of the elements in this list (in proper\n+     * sequence), starting at the specified position in the list.\n+     * Obeys the general contract of <code>List.listIterator(int)</code>.<p>\n+     * <p>\n+     * The list-iterator is <i>fail-fast</i>: if the list is structurally\n+     * modified at any time after the Iterator is created, in any way except\n+     * through the list-iterator's own <code>remove</code> or <code>add</code>\n+     * methods, the list-iterator will throw a\n+     * <code>ConcurrentModificationException</code>.  Thus, in the face of\n+     * concurrent modification, the iterator fails quickly and cleanly, rather\n+     * than risking arbitrary, non-deterministic behavior at an undetermined\n+     * time in the future.\n+     *\n+     * @param index index of first element to be returned from the\n+     *          list-iterator (by a call to <code>next</code>)\n+     * @return a ListIterator of the elements in this list (in proper\n+     *         sequence), starting at the specified position in the list\n+     * @throws    IndexOutOfBoundsException if index is out of range\n+     *        (<code>index &lt; 0 || index &gt; size()</code>)\n+     * @see List#listIterator(int)\n+     */\n+    public ListIterator listIterator(int index) {\n+        return new ListItr(index);\n+    }\n+\n+    private final class ListItr implements ListIterator {\n+        private Node lastReturned = header;\n+        private Node next;\n+        private int nextIndex;\n+        private int expectedModCount = modCount;\n+\n+        ListItr(int index) {\n+            if (index < 0 || index > size)\n+                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n+            if (index < (size >> 1)) {\n+                next = header.next;\n+                for (nextIndex = 0; nextIndex < index; nextIndex++)\n+                    next = next.next;\n+            }\n+            else {\n+                next = header;\n+                for (nextIndex = size; nextIndex > index; nextIndex--)\n+                    next = next.previous;\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return nextIndex != size;\n+        }\n+\n+        public Object next() {\n+            checkForComodification();\n+            if (nextIndex == size)\n+                throw new NoSuchElementException();\n+\n+            lastReturned = next;\n+            next = next.next;\n+            nextIndex++;\n+            return lastReturned.element;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return nextIndex != 0;\n+        }\n+\n+        public Object previous() {\n+            if (nextIndex == 0)\n+                throw new NoSuchElementException();\n+\n+            lastReturned = next = next.previous;\n+            nextIndex--;\n+            checkForComodification();\n+            return lastReturned.element;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex - 1;\n+        }\n+\n+        public void remove() {\n+            checkForComodification();\n+            try {\n+                NodeCachingLinkedList.this.remove(lastReturned);\n+            }\n+            catch (NoSuchElementException e) {\n+                throw new IllegalStateException();\n+            }\n+            if (next == lastReturned)\n+                next = lastReturned.next;\n+            else\n+                nextIndex--;\n+            lastReturned = header;\n+            expectedModCount++;\n+        }\n+\n+        public void set(Object o) {\n+            if (lastReturned == header)\n+                throw new IllegalStateException();\n+            checkForComodification();\n+            lastReturned.element = o;\n+        }\n+\n+        public void add(Object o) {\n+            checkForComodification();\n+            lastReturned = header;\n+\n+            Node newNode; \n+            if (cacheCount > 0) {\n+                newNode = cacheHeader.next;\n+                cacheHeader.next = newNode.next;\n+                newNode.element = o;\n+                newNode.next = next;\n+                newNode.previous = next.previous;\n+            }\n+            else {\n+                newNode = new Node(o, next, next.previous);\n+            }\n+            \n+            newNode.previous.next = newNode;\n+            newNode.next.previous = newNode;\n+            size++;\n+            modCount++;\n+\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+\n+        private void checkForComodification() {\n+            if (modCount != expectedModCount)\n+                throw new ConcurrentModificationException();\n+        }\n+    }\n+\n+    private final static class Node implements Serializable {\n+        Object element;\n+        Node next;\n+        Node previous;\n+\n+        Node(Object element, Node next, Node previous) {\n+            this.element = element;\n+            this.next = next;\n+            this.previous = previous;\n+        }\n+    }\n+\n+\n+    private Node addsBefore(Object o, Node e) {\n+        Node newNode; \n+        if (cacheCount > 0) {\n+            newNode = cacheHeader.next;\n+            cacheHeader.next = newNode.next;\n+            newNode.element = o;\n+            newNode.next = e;\n+            newNode.previous = e.previous;\n+        }\n+        else {\n+            newNode = new Node(o, e, e.previous);\n+        }\n+        \n+        newNode.previous.next = newNode;\n+        newNode.next.previous = newNode;\n+        size++;\n+        modCount++;\n+        return newNode;\n+    }\n+\n+\n+    private void remove(Node e) {\n+        if (e == header) {\n+            throw new NoSuchElementException();\n+        }\n+        e.previous.next = e.next;\n+        e.next.previous = e.previous;\n+        size--;\n+        modCount++;\n+        \n+        if (cacheCount < maximumCacheSize) {\n+            e.element = null;\n+            e.previous = null;\n+            e.next = cacheHeader.next;\n+            cacheHeader.next = e;\n+            cacheCount++;\n+        }\n+    }\n+\n+    /**\n+     * Returns a shallow copy of this <code>NodeCachingLinkedList</code>. (The elements\n+     * themselves are not cloned.)\n+     *\n+     * @return a shallow copy of this <code>NodeCachingLinkedList</code> instance\n+     */\n+    public Object clone() {\n+        NodeCachingLinkedList clone = new NodeCachingLinkedList();\n+        clone.setMaximumCacheSize(maximumCacheSize);\n+        \n+        // Initialize clone with our elements\n+        for (Node e = header.next; e != header; e = e.next) {\n+            clone.add(e.element);\n+        }\n+\n+        return clone;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list\n+     * in the correct order.\n+     *\n+     * @return an array containing all of the elements in this list\n+     *         in the correct order\n+     */\n+    public Object[] toArray() {\n+        Object[] result = new Object[size];\n+        int i = 0;\n+        for (Node e = header.next; e != header; e = e.next)\n+            result[i++] = e.element;\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in\n+     * the correct order; the runtime type of the returned array is that of\n+     * the specified array.  If the list fits in the specified array, it\n+     * is returned therein.  Otherwise, a new array is allocated with the\n+     * runtime type of the specified array and the size of this list.<p>\n+     * <p>\n+     * If the list fits in the specified array with room to spare\n+     * (i.e., the array has more elements than the list),\n+     * the element in the array immediately following the end of the\n+     * collection is set to null.  This is useful in determining the length\n+     * of the list <i>only</i> if the caller knows that the list\n+     * does not contain any null elements.\n+     *\n+     * @param a the array into which the elements of the list are to\n+     *      be stored, if it is big enough; otherwise, a new array of the\n+     *      same runtime type is allocated for this purpose\n+     * @return an array containing the elements of the list\n+     * @throws ArrayStoreException if the runtime type of a is not a\n+     *         supertype of the runtime type of every element in this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    public Object[] toArray(Object a[]) {\n+        if (a.length < size)\n+            a = (Object[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);\n+        int i = 0;\n+        for (Node e = header.next; e != header; e = e.next)\n+            a[i++] = e.element;\n+\n+        if (a.length > size)\n+            a[size] = null;\n+\n+        return a;\n+    }\n+    \n+}", "timestamp": 1037663897, "metainfo": ""}