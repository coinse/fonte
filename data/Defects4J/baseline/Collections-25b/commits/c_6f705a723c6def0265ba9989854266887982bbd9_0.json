{"sha": "6f705a723c6def0265ba9989854266887982bbd9", "log": "Apply collection coding standards   ", "commit": "\n--- a/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java,v 1.3 2003/12/28 16:36:48 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java,v 1.4 2004/01/01 19:24:46 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * This buffer prevents null objects from being added.\n  *\n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.3 $ $Date: 2003/12/28 16:36:48 $\n+ * @version $Revision: 1.4 $ $Date: 2004/01/01 19:24:46 $\n  * \n  * @author Avalon\n  * @author Berin Loritsch\n public class BoundedFifoBuffer extends AbstractCollection\n         implements Buffer, BoundedCollection {\n             \n-    private final Object[] m_elements;\n-    private int m_start = 0;\n-    private int m_end = 0;\n-    private boolean m_full = false;\n+    private final Object[] elements;\n+    private int start = 0;\n+    private int end = 0;\n+    private boolean full = false;\n     private final int maxElements;\n \n     /**\n         if (size <= 0) {\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n-        m_elements = new Object[size];\n-        maxElements = m_elements.length;\n+        elements = new Object[size];\n+        maxElements = elements.length;\n     }\n \n     /**\n     public int size() {\n         int size = 0;\n \n-        if (m_end < m_start) {\n-            size = maxElements - m_start + m_end;\n-        } else if (m_end == m_start) {\n-            size = (m_full ? maxElements : 0);\n+        if (end < start) {\n+            size = maxElements - start + end;\n+        } else if (end == start) {\n+            size = (full ? maxElements : 0);\n         } else {\n-            size = m_end - m_start;\n+            size = end - start;\n         }\n \n         return size;\n      * Clears this buffer.\n      */\n     public void clear() {\n-        m_full = false;\n-        m_start = 0;\n-        m_end = 0;\n-        Arrays.fill(m_elements, null);\n+        full = false;\n+        start = 0;\n+        end = 0;\n+        Arrays.fill(elements, null);\n     }\n \n     /**\n             throw new NullPointerException(\"Attempted to add null object to buffer\");\n         }\n \n-        if (m_full) {\n+        if (full) {\n             throw new BufferOverflowException(\"The buffer cannot hold more than \" + maxElements + \" objects.\");\n         }\n \n-        m_elements[m_end++] = element;\n-\n-        if (m_end >= maxElements) {\n-            m_end = 0;\n-        }\n-\n-        if (m_end == m_start) {\n-            m_full = true;\n+        elements[end++] = element;\n+\n+        if (end >= maxElements) {\n+            end = 0;\n+        }\n+\n+        if (end == start) {\n+            full = true;\n         }\n \n         return true;\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        return m_elements[m_start];\n+        return elements[start];\n     }\n \n     /**\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        Object element = m_elements[m_start];\n+        Object element = elements[start];\n \n         if (null != element) {\n-            m_elements[m_start++] = null;\n-\n-            if (m_start >= maxElements) {\n-                m_start = 0;\n+            elements[start++] = null;\n+\n+            if (start >= maxElements) {\n+                start = 0;\n             }\n \n-            m_full = false;\n+            full = false;\n         }\n \n         return element;\n     public Iterator iterator() {\n         return new Iterator() {\n \n-            private int index = m_start;\n+            private int index = start;\n             private int lastReturnedIndex = -1;\n-            private boolean isFirst = m_full;\n+            private boolean isFirst = full;\n \n             public boolean hasNext() {\n-                return isFirst || (index != m_end);\n+                return isFirst || (index != end);\n                 \n             }\n \n             public Object next() {\n-                if (!hasNext()) throw new NoSuchElementException();\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n                 isFirst = false;\n                 lastReturnedIndex = index;\n                 index = increment(index);\n-                return m_elements[lastReturnedIndex];\n+                return elements[lastReturnedIndex];\n             }\n \n             public void remove() {\n-                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n \n                 // First element can be removed quickly\n-                if (lastReturnedIndex == m_start) {\n+                if (lastReturnedIndex == start) {\n                     BoundedFifoBuffer.this.remove();\n                     lastReturnedIndex = -1;\n                     return;\n \n                 // Other elements require us to shift the subsequent elements\n                 int i = lastReturnedIndex + 1;\n-                while (i != m_end) {\n+                while (i != end) {\n                     if (i >= maxElements) {\n-                        m_elements[i - 1] = m_elements[0];\n+                        elements[i - 1] = elements[0];\n                         i = 0;\n                     } else {\n-                        m_elements[i - 1] = m_elements[i];\n+                        elements[i - 1] = elements[i];\n                         i++;\n                     }\n                 }\n \n                 lastReturnedIndex = -1;\n-                m_end = decrement(m_end);\n-                m_elements[m_end] = null;\n-                m_full = false;\n+                end = decrement(end);\n+                elements[end] = null;\n+                full = false;\n                 index = decrement(index);\n             }\n \n--- a/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java,v 1.2 2003/12/28 16:36:48 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java,v 1.3 2004/01/01 19:24:46 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * This buffer prevents null objects from being added.\n  * \n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.2 $ $Date: 2003/12/28 16:36:48 $\n+ * @version $Revision: 1.3 $ $Date: 2004/01/01 19:24:46 $\n  *\n  * @author Avalon\n  * @author Federico Barbieri\n  */\n public class UnboundedFifoBuffer extends AbstractCollection implements Buffer {\n     \n-    protected Object[] m_buffer;\n-    protected int m_head;\n-    protected int m_tail;\n+    protected Object[] buffer;\n+    protected int head;\n+    protected int tail;\n \n     /**\n      * Constructs an UnboundedFifoBuffer with the default number of elements.\n         if (initialSize <= 0) {\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n-        m_buffer = new Object[initialSize + 1];\n-        m_head = 0;\n-        m_tail = 0;\n+        buffer = new Object[initialSize + 1];\n+        head = 0;\n+        tail = 0;\n     }\n \n     /**\n     public int size() {\n         int size = 0;\n \n-        if (m_tail < m_head) {\n-            size = m_buffer.length - m_head + m_tail;\n+        if (tail < head) {\n+            size = buffer.length - head + tail;\n         } else {\n-            size = m_tail - m_head;\n+            size = tail - head;\n         }\n \n         return size;\n             throw new NullPointerException(\"Attempted to add null object to buffer\");\n         }\n \n-        if (size() + 1 >= m_buffer.length) {\n-            Object[] tmp = new Object[((m_buffer.length - 1) * 2) + 1];\n+        if (size() + 1 >= buffer.length) {\n+            Object[] tmp = new Object[((buffer.length - 1) * 2) + 1];\n \n             int j = 0;\n-            for (int i = m_head; i != m_tail;) {\n-                tmp[j] = m_buffer[i];\n-                m_buffer[i] = null;\n+            for (int i = head; i != tail;) {\n+                tmp[j] = buffer[i];\n+                buffer[i] = null;\n \n                 j++;\n                 i++;\n-                if (i == m_buffer.length) {\n+                if (i == buffer.length) {\n                     i = 0;\n                 }\n             }\n \n-            m_buffer = tmp;\n-            m_head = 0;\n-            m_tail = j;\n-        }\n-\n-        m_buffer[m_tail] = obj;\n-        m_tail++;\n-        if (m_tail >= m_buffer.length) {\n-            m_tail = 0;\n+            buffer = tmp;\n+            head = 0;\n+            tail = j;\n+        }\n+\n+        buffer[tail] = obj;\n+        tail++;\n+        if (tail >= buffer.length) {\n+            tail = 0;\n         }\n         return true;\n     }\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        return m_buffer[m_head];\n+        return buffer[head];\n     }\n \n     /**\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        Object element = m_buffer[m_head];\n+        Object element = buffer[head];\n \n         if (null != element) {\n-            m_buffer[m_head] = null;\n-\n-            m_head++;\n-            if (m_head >= m_buffer.length) {\n-                m_head = 0;\n+            buffer[head] = null;\n+\n+            head++;\n+            if (head >= buffer.length) {\n+                head = 0;\n             }\n         }\n \n      */\n     private int increment(int index) {\n         index++;\n-        if (index >= m_buffer.length) {\n+        if (index >= buffer.length) {\n             index = 0;\n         }\n         return index;\n     private int decrement(int index) {\n         index--;\n         if (index < 0) {\n-            index = m_buffer.length - 1;\n+            index = buffer.length - 1;\n         }\n         return index;\n     }\n     public Iterator iterator() {\n         return new Iterator() {\n \n-            private int index = m_head;\n+            private int index = head;\n             private int lastReturnedIndex = -1;\n \n             public boolean hasNext() {\n-                return index != m_tail;\n+                return index != tail;\n \n             }\n \n             public Object next() {\n-                if (!hasNext())\n+                if (!hasNext()) {\n                     throw new NoSuchElementException();\n+                }\n                 lastReturnedIndex = index;\n                 index = increment(index);\n-                return m_buffer[lastReturnedIndex];\n+                return buffer[lastReturnedIndex];\n             }\n \n             public void remove() {\n-                if (lastReturnedIndex == -1)\n+                if (lastReturnedIndex == -1) {\n                     throw new IllegalStateException();\n+                }\n \n                 // First element can be removed quickly\n-                if (lastReturnedIndex == m_head) {\n+                if (lastReturnedIndex == head) {\n                     UnboundedFifoBuffer.this.remove();\n                     lastReturnedIndex = -1;\n                     return;\n \n                 // Other elements require us to shift the subsequent elements\n                 int i = lastReturnedIndex + 1;\n-                while (i != m_tail) {\n-                    if (i >= m_buffer.length) {\n-                        m_buffer[i - 1] = m_buffer[0];\n+                while (i != tail) {\n+                    if (i >= buffer.length) {\n+                        buffer[i - 1] = buffer[0];\n                         i = 0;\n                     } else {\n-                        m_buffer[i - 1] = m_buffer[i];\n+                        buffer[i - 1] = buffer[i];\n                         i++;\n                     }\n                 }\n \n                 lastReturnedIndex = -1;\n-                m_tail = decrement(m_tail);\n-                m_buffer[m_tail] = null;\n+                tail = decrement(tail);\n+                buffer[tail] = null;\n                 index = decrement(index);\n             }\n ", "timestamp": 1072985086, "metainfo": ""}