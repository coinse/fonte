{"sha": "c9e19ce6cde755b4f6c03002d1ff99010e364063", "log": "Add missing @Override markers  ", "commit": "\n--- a/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n         return normalMap.containsKey(key);\n     }\n \n+    @Override\n     public boolean equals(Object obj) {\n         return normalMap.equals(obj);\n     }\n \n+    @Override\n     public int hashCode() {\n         return normalMap.hashCode();\n     }\n \n+    @Override\n     public String toString() {\n         return normalMap.toString();\n     }\n             this.parent = parent;\n         }\n \n+        @Override\n         public boolean removeAll(Collection<?> coll) {\n             if (parent.isEmpty() || coll.isEmpty()) {\n                 return false;\n             return modified;\n         }\n \n+        @Override\n         public boolean retainAll(Collection<?> coll) {\n             if (parent.isEmpty()) {\n                 return false;\n             return modified;\n         }\n \n+        @Override\n         public void clear() {\n             parent.clear();\n         }\n             super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n         }\n \n+        @Override\n         public Iterator<K> iterator() {\n             return parent.createKeySetIterator(super.iterator());\n         }\n \n+        @Override\n         public boolean contains(Object key) {\n             return parent.normalMap.containsKey(key);\n         }\n \n+        @Override\n         public boolean remove(Object key) {\n             if (parent.normalMap.containsKey(key)) {\n                 Object value = parent.normalMap.remove(key);\n             this.parent = parent;\n         }\n \n+        @Override\n         public K next() {\n             lastKey = super.next();\n             canRemove = true;\n             return lastKey;\n         }\n \n+        @Override\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n         }\n \n+        @Override\n         public Iterator<V> iterator() {\n             return parent.createValuesIterator(super.iterator());\n         }\n \n+        @Override\n         public boolean contains(Object value) {\n             return parent.reverseMap.containsKey(value);\n         }\n \n+        @Override\n         public boolean remove(Object value) {\n             if (parent.reverseMap.containsKey(value)) {\n                 Object key = parent.reverseMap.remove(value);\n             this.parent = (AbstractDualBidiMap<Object, V>) parent;\n         }\n \n+        @Override\n         public V next() {\n             lastValue = super.next();\n             canRemove = true;\n             return lastValue;\n         }\n \n+        @Override\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             super(parent.normalMap.entrySet(), parent);\n         }\n \n+        @Override\n         public Iterator<Map.Entry<K, V>> iterator() {\n             return parent.createEntrySetIterator(super.iterator());\n         }\n \n+        @Override\n         public boolean remove(Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             this.parent = parent;\n         }\n \n+        @Override\n         public Map.Entry<K, V> next() {\n             last = new MapEntry<K, V>(super.next(), parent);\n             canRemove = true;\n             return last;\n         }\n \n+        @Override\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             this.parent = parent;\n         }\n \n+        @Override\n         public V setValue(V value) {\n             K key = MapEntry.this.getKey();\n             if (parent.reverseMap.containsKey(value) &&\n             canRemove = false;\n         }\n \n+        @Override\n         public String toString() {\n             if (last != null) {\n                 return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n--- a/src/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n+++ b/src/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n      * \n      * @return the decorated map\n      */\n+    @Override\n     protected OrderedBidiMap<K, V> decorated() {\n         return (OrderedBidiMap<K, V>) super.decorated();\n     }\n \n     //-----------------------------------------------------------------------\n+    @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n         return decorated().mapIterator();\n     }\n--- a/src/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n      * @param inverseBidiMap  the inverse BidiMap\n      * @return new bidi map\n      */\n+    @Override\n     protected BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseBidiMap) {\n         return new DualHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n     }\n--- a/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n      * The equivalent of a default constructor called\n      * by any constructor and by <code>readObject</code>.\n      */\n+    @Override\n     protected void init() {\n         super.init();\n         cursors = new ArrayList<WeakReference<Cursor<E>>>();\n      * \n      * @return a new iterator that does <b>not</b> support concurrent modification\n      */\n+    @Override\n     public Iterator<E> iterator() {\n         return super.listIterator(0);\n     }\n      * \n      * @return a new cursor iterator\n      */\n+    @Override\n     public ListIterator<E> listIterator() {\n         return cursor(0);\n     }\n      * @param fromIndex  the index to start from\n      * @return a new cursor iterator\n      */\n+    @Override\n     public ListIterator<E> listIterator(int fromIndex) {\n         return cursor(fromIndex);\n     }\n      * @param node  node to update\n      * @param value  new value of the node\n      */\n+    @Override\n     protected void updateNode(Node<E> node, E value) {\n         super.updateNode(node, value);\n         broadcastNodeChanged(node);\n      * @param insertBeforeNode  node to insert before\n      * @throws NullPointerException if either node is null\n      */\n+    @Override\n     protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n         super.addNode(nodeToInsert, insertBeforeNode);\n         broadcastNodeInserted(nodeToInsert);\n      * @param node  the node to remove\n      * @throws NullPointerException if <code>node</code> is null\n      */\n+    @Override\n     protected void removeNode(Node<E> node) {\n         super.removeNode(node);\n         broadcastNodeRemoved(node);\n     /**\n      * Removes all nodes by iteration.\n      */\n+    @Override\n     protected void removeAllNodes() {\n         if (size() > 0) {\n             // superclass implementation would break all the iterators\n      * @param subList  the sublist to get an iterator for\n      * @param fromIndex  the index to start from, relative to the sublist\n      */\n+    @Override\n     protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n         SubCursor<E> cursor = new SubCursor<E>(subList, fromIndex);\n         registerCursor(cursor);\n          *\n          * @throws IllegalStateException if there is no item to remove\n          */\n+        @Override\n         public void remove() {\n             // overridden, as the nodeRemoved() method updates the iterator\n             // state in the parent.removeNode() call below\n          * \n          * @param obj  the object to add\n          */\n+        @Override\n         public void add(E obj) {\n             // overridden, as the nodeInserted() method updates the iterator state\n             super.add(obj);\n          * \n          * @return the next index\n          */\n+        @Override\n         public int nextIndex() {\n             if (nextIndexValid == false) {\n                 if (next == parent.header) {\n         /**\n          * Override superclass modCount check, and replace it with our valid flag.\n          */\n+        @Override\n         protected void checkModCount() {\n             if (!valid) {\n                 throw new ConcurrentModificationException(\"Cursor closed\");\n             this.sub = sub;\n         }\n \n+        @Override\n         public boolean hasNext() {\n             return (nextIndex() < sub.size);\n         }\n \n+        @Override\n         public boolean hasPrevious() {\n             return (previousIndex() >= 0);\n         }\n \n+        @Override\n         public int nextIndex() {\n             return (super.nextIndex() - sub.offset);\n         }\n \n+        @Override\n         public void add(E obj) {\n             super.add(obj);\n             sub.expectedModCount = parent.modCount;\n             sub.size++;\n         }\n \n+        @Override\n         public void remove() {\n             super.remove();\n             sub.expectedModCount = parent.modCount;\n--- a/src/java/org/apache/commons/collections/list/FixedSizeList.java\n+++ b/src/java/org/apache/commons/collections/list/FixedSizeList.java\n     }\n \n     //-----------------------------------------------------------------------\n+    @Override\n     public boolean add(E object) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public void add(int index, E object) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public boolean addAll(Collection<? extends E> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public boolean addAll(int index, Collection<? extends E> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public void clear() {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public E get(int index) {\n         return decorated().get(index);\n     }\n \n+    @Override\n     public int indexOf(Object object) {\n         return decorated().indexOf(object);\n     }\n \n+    @Override\n     public Iterator<E> iterator() {\n         return UnmodifiableIterator.decorate(decorated().iterator());\n     }\n \n+    @Override\n     public int lastIndexOf(Object object) {\n         return decorated().lastIndexOf(object);\n     }\n \n+    @Override\n     public ListIterator<E> listIterator() {\n         return new FixedSizeListIterator(decorated().listIterator(0));\n     }\n \n+    @Override\n     public ListIterator<E> listIterator(int index) {\n         return new FixedSizeListIterator(decorated().listIterator(index));\n     }\n \n+    @Override\n     public E remove(int index) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public boolean remove(Object object) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public boolean removeAll(Collection<?> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public boolean retainAll(Collection<?> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n+    @Override\n     public E set(int index, E object) {\n         return decorated().set(index, object);\n     }\n \n+    @Override\n     public List<E> subList(int fromIndex, int toIndex) {\n         List<E> sub = decorated().subList(fromIndex, toIndex);\n         return new FixedSizeList<E>(sub);\n         protected FixedSizeListIterator(ListIterator<E> iterator) {\n             super(iterator);\n         }\n+        @Override\n         public void remove() {\n             throw new UnsupportedOperationException(\"List is fixed size\");\n         }\n+        @Override\n         public void add(Object object) {\n             throw new UnsupportedOperationException(\"List is fixed size\");\n         }\n--- a/src/java/org/apache/commons/collections/list/PredicatedList.java\n+++ b/src/java/org/apache/commons/collections/list/PredicatedList.java\n      * \n      * @return the decorated list\n      */\n+    @Override\n     protected List<E> decorated() {\n         return (List<E>) super.decorated();\n     }\n             super(iterator);\n         }\n         \n+        @Override\n         public void add(E object) {\n             validate(object);\n             iterator.add(object);\n         }\n         \n+        @Override\n         public void set(E object) {\n             validate(object);\n             iterator.set(object);", "timestamp": 1279731838, "metainfo": ""}