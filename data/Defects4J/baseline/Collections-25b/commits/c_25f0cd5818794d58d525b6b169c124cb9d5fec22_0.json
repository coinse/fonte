{"sha": "25f0cd5818794d58d525b6b169c124cb9d5fec22", "log": "Change to standard variable naming style   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/java/org/apache/commons/collections/map/Flat3Map.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Flat3Map.java,v 1.8 2003/12/07 23:59:13 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Flat3Map.java,v 1.9 2003/12/29 00:38:32 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.8 $ $Date: 2003/12/07 23:59:13 $\n+ * @version $Revision: 1.9 $ $Date: 2003/12/29 00:38:32 $\n  *\n  * @author Stephen Colebourne\n  */\n public class Flat3Map implements IterableMap {\n     \n     /** The size of the map, used while in flat mode */\n-    private int iSize;\n+    private int size;\n     /** Hash, used while in flat mode */\n-    private int iHash1;\n+    private int hash1;\n     /** Hash, used while in flat mode */\n-    private int iHash2;\n+    private int hash2;\n     /** Hash, used while in flat mode */\n-    private int iHash3;\n+    private int hash3;\n     /** Key, used while in flat mode */\n-    private Object iKey1;\n+    private Object key1;\n     /** Key, used while in flat mode */\n-    private Object iKey2;\n+    private Object key2;\n     /** Key, used while in flat mode */\n-    private Object iKey3;\n+    private Object key3;\n     /** Value, used while in flat mode */\n-    private Object iValue1;\n+    private Object value1;\n     /** Value, used while in flat mode */\n-    private Object iValue2;\n+    private Object value2;\n     /** Value, used while in flat mode */\n-    private Object iValue3;\n+    private Object value3;\n     /** Map, used while in delegate mode */\n-    private HashedMap iMap;\n+    private HashedMap delegateMap;\n \n     /**\n      * Constructor.\n      * @return the mapped value, null if no match\n      */\n     public Object get(Object key) {\n-        if (iMap != null) {\n-            return iMap.get(key);\n+        if (delegateMap != null) {\n+            return delegateMap.get(key);\n         }\n         if (key == null) {\n-            switch (iSize) {\n+            switch (size) {\n                 // drop through\n                 case 3:\n-                    if (iKey3 == null) return iValue3;\n-                case 2:\n-                    if (iKey2 == null) return iValue2;\n-                case 1:\n-                    if (iKey1 == null) return iValue1;\n+                    if (key3 == null) return value3;\n+                case 2:\n+                    if (key2 == null) return value2;\n+                case 1:\n+                    if (key1 == null) return value1;\n             }\n         } else {\n-            if (iSize > 0) {\n+            if (size > 0) {\n                 int hashCode = key.hashCode();\n-                switch (iSize) {\n+                switch (size) {\n                     // drop through\n                     case 3:\n-                        if (iHash3 == hashCode && key.equals(iKey3)) return iValue3;\n+                        if (hash3 == hashCode && key.equals(key3)) return value3;\n                     case 2:\n-                        if (iHash2 == hashCode && key.equals(iKey2)) return iValue2;\n+                        if (hash2 == hashCode && key.equals(key2)) return value2;\n                     case 1:\n-                        if (iHash1 == hashCode && key.equals(iKey1)) return iValue1;\n+                        if (hash1 == hashCode && key.equals(key1)) return value1;\n                 }\n             }\n         }\n      * @return the size\n      */\n     public int size() {\n-        if (iMap != null) {\n-            return iMap.size();\n-        }\n-        return iSize;\n+        if (delegateMap != null) {\n+            return delegateMap.size();\n+        }\n+        return size;\n     }\n \n     /**\n      * @return true if the map contains the key\n      */\n     public boolean containsKey(Object key) {\n-        if (iMap != null) {\n-            return iMap.containsKey(key);\n+        if (delegateMap != null) {\n+            return delegateMap.containsKey(key);\n         }\n         if (key == null) {\n-            switch (iSize) {  // drop through\n+            switch (size) {  // drop through\n                 case 3:\n-                    if (iKey3 == null) return true;\n-                case 2:\n-                    if (iKey2 == null) return true;\n-                case 1:\n-                    if (iKey1 == null) return true;\n+                    if (key3 == null) return true;\n+                case 2:\n+                    if (key2 == null) return true;\n+                case 1:\n+                    if (key1 == null) return true;\n             }\n         } else {\n-            if (iSize > 0) {\n+            if (size > 0) {\n                 int hashCode = key.hashCode();\n-                switch (iSize) {  // drop through\n+                switch (size) {  // drop through\n                     case 3:\n-                        if (iHash3 == hashCode && key.equals(iKey3)) return true;\n+                        if (hash3 == hashCode && key.equals(key3)) return true;\n                     case 2:\n-                        if (iHash2 == hashCode && key.equals(iKey2)) return true;\n+                        if (hash2 == hashCode && key.equals(key2)) return true;\n                     case 1:\n-                        if (iHash1 == hashCode && key.equals(iKey1)) return true;\n+                        if (hash1 == hashCode && key.equals(key1)) return true;\n                 }\n             }\n         }\n      * @return true if the map contains the key\n      */\n     public boolean containsValue(Object value) {\n-        if (iMap != null) {\n-            return iMap.containsValue(value);\n+        if (delegateMap != null) {\n+            return delegateMap.containsValue(value);\n         }\n         if (value == null) {  // drop through\n-            switch (iSize) {\n+            switch (size) {\n                 case 3:\n-                    if (iValue3 == null) return true;\n-                case 2:\n-                    if (iValue2 == null) return true;\n-                case 1:\n-                    if (iValue1 == null) return true;\n+                    if (value3 == null) return true;\n+                case 2:\n+                    if (value2 == null) return true;\n+                case 1:\n+                    if (value1 == null) return true;\n             }\n         } else {\n-            switch (iSize) {  // drop through\n+            switch (size) {  // drop through\n                 case 3:\n-                    if (value.equals(iValue3)) return true;\n-                case 2:\n-                    if (value.equals(iValue2)) return true;\n-                case 1:\n-                    if (value.equals(iValue1)) return true;\n+                    if (value.equals(value3)) return true;\n+                case 2:\n+                    if (value.equals(value2)) return true;\n+                case 1:\n+                    if (value.equals(value1)) return true;\n             }\n         }\n         return false;\n      * @return the value previously mapped to this key, null if none\n      */\n     public Object put(Object key, Object value) {\n-        if (iMap != null) {\n-            return iMap.put(key, value);\n+        if (delegateMap != null) {\n+            return delegateMap.put(key, value);\n         }\n         // change existing mapping\n         if (key == null) {\n-            switch (iSize) {  // drop through\n+            switch (size) {  // drop through\n                 case 3:\n-                    if (iKey3 == null) {\n-                        Object old = iValue3;\n-                        iValue3 = value;\n+                    if (key3 == null) {\n+                        Object old = value3;\n+                        value3 = value;\n                         return old;\n                     }\n                 case 2:\n-                    if (iKey2 == null) {\n-                        Object old = iValue2;\n-                        iValue2 = value;\n+                    if (key2 == null) {\n+                        Object old = value2;\n+                        value2 = value;\n                         return old;\n                     }\n                 case 1:\n-                    if (iKey1 == null) {\n-                        Object old = iValue1;\n-                        iValue1 = value;\n+                    if (key1 == null) {\n+                        Object old = value1;\n+                        value1 = value;\n                         return old;\n                     }\n             }\n         } else {\n-            if (iSize > 0) {\n+            if (size > 0) {\n                 int hashCode = key.hashCode();\n-                switch (iSize) {  // drop through\n+                switch (size) {  // drop through\n                     case 3:\n-                        if (iHash3 == hashCode && key.equals(iKey3)) {\n-                            Object old = iValue3;\n-                            iValue3 = value;\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            Object old = value3;\n+                            value3 = value;\n                             return old;\n                         }\n                     case 2:\n-                        if (iHash2 == hashCode && key.equals(iKey2)) {\n-                            Object old = iValue2;\n-                            iValue2 = value;\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            Object old = value2;\n+                            value2 = value;\n                             return old;\n                         }\n                     case 1:\n-                        if (iHash1 == hashCode && key.equals(iKey1)) {\n-                            Object old = iValue1;\n-                            iValue1 = value;\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            Object old = value1;\n+                            value1 = value;\n                             return old;\n                         }\n                 }\n         }\n         \n         // add new mapping\n-        switch (iSize) {\n+        switch (size) {\n             default:\n                 convertToMap();\n-                iMap.put(key, value);\n+                delegateMap.put(key, value);\n                 return null;\n             case 2:\n-                iHash3 = (key == null ? 0 : key.hashCode());\n-                iKey3 = key;\n-                iValue3 = value;\n+                hash3 = (key == null ? 0 : key.hashCode());\n+                key3 = key;\n+                value3 = value;\n                 break;\n             case 1:\n-                iHash2 = (key == null ? 0 : key.hashCode());\n-                iKey2 = key;\n-                iValue2 = value;\n+                hash2 = (key == null ? 0 : key.hashCode());\n+                key2 = key;\n+                value2 = value;\n                 break;\n             case 0:\n-                iHash1 = (key == null ? 0 : key.hashCode());\n-                iKey1 = key;\n-                iValue1 = value;\n+                hash1 = (key == null ? 0 : key.hashCode());\n+                key1 = key;\n+                value1 = value;\n                 break;\n         }\n-        iSize++;\n+        size++;\n         return null;\n     }\n \n         if (size == 0) {\n             return;\n         }\n-        if (iMap != null) {\n-            iMap.putAll(map);\n+        if (delegateMap != null) {\n+            delegateMap.putAll(map);\n             return;\n         }\n         if (size < 4) {\n             }\n         } else {\n             convertToMap();\n-            iMap.putAll(map);\n+            delegateMap.putAll(map);\n         }\n     }\n \n      * Converts the flat map data to a HashMap.\n      */\n     private void convertToMap() {\n-        iMap = new HashedMap();\n-        switch (iSize) {  // drop through\n+        delegateMap = new HashedMap();\n+        switch (size) {  // drop through\n             case 3:\n-                iMap.put(iKey3, iValue3);\n+                delegateMap.put(key3, value3);\n             case 2:\n-                iMap.put(iKey2, iValue2);\n+                delegateMap.put(key2, value2);\n             case 1:\n-                iMap.put(iKey1, iValue1);\n-        }\n-        \n-        iSize = 0;\n-        iHash1 = iHash2 = iHash3 = 0;\n-        iKey1 = iKey2 = iKey3 = null;\n-        iValue1 = iValue2 = iValue3 = null;\n+                delegateMap.put(key1, value1);\n+        }\n+        \n+        size = 0;\n+        hash1 = hash2 = hash3 = 0;\n+        key1 = key2 = key3 = null;\n+        value1 = value2 = value3 = null;\n     }\n \n     /**\n      * @return the value mapped to the removed key, null if key not in map\n      */\n     public Object remove(Object key) {\n-        if (iMap != null) {\n-            return iMap.remove(key);\n-        }\n-        if (iSize == 0) {\n+        if (delegateMap != null) {\n+            return delegateMap.remove(key);\n+        }\n+        if (size == 0) {\n             return null;\n         }\n         if (key == null) {\n-            switch (iSize) {  // drop through\n+            switch (size) {  // drop through\n                 case 3:\n-                    if (iKey3 == null) {\n-                        Object old = iValue3;\n-                        iHash3 = 0;\n-                        iKey3 = null;\n-                        iValue3 = null;\n-                        iSize = 2;\n+                    if (key3 == null) {\n+                        Object old = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n                         return old;\n                     }\n-                    if (iKey2 == null) {\n-                        Object old = iValue3;\n-                        iHash2 = iHash3;\n-                        iKey2 = iKey3;\n-                        iValue2 = iValue3;\n-                        iHash3 = 0;\n-                        iKey3 = null;\n-                        iValue3 = null;\n-                        iSize = 2;\n+                    if (key2 == null) {\n+                        Object old = value3;\n+                        hash2 = hash3;\n+                        key2 = key3;\n+                        value2 = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n                         return old;\n                     }\n-                    if (iKey1 == null) {\n-                        Object old = iValue3;\n-                        iHash1 = iHash3;\n-                        iKey1 = iKey3;\n-                        iValue1 = iValue3;\n-                        iHash3 = 0;\n-                        iKey3 = null;\n-                        iValue3 = null;\n-                        iSize = 2;\n+                    if (key1 == null) {\n+                        Object old = value3;\n+                        hash1 = hash3;\n+                        key1 = key3;\n+                        value1 = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n                         return old;\n                     }\n                     return null;\n                 case 2:\n-                    if (iKey2 == null) {\n-                        Object old = iValue2;\n-                        iHash2 = 0;\n-                        iKey2 = null;\n-                        iValue2 = null;\n-                        iSize = 1;\n+                    if (key2 == null) {\n+                        Object old = value2;\n+                        hash2 = 0;\n+                        key2 = null;\n+                        value2 = null;\n+                        size = 1;\n                         return old;\n                     }\n-                    if (iKey1 == null) {\n-                        Object old = iValue2;\n-                        iHash1 = iHash2;\n-                        iKey1 = iKey2;\n-                        iValue1 = iValue2;\n-                        iHash2 = 0;\n-                        iKey2 = null;\n-                        iValue2 = null;\n-                        iSize = 1;\n+                    if (key1 == null) {\n+                        Object old = value2;\n+                        hash1 = hash2;\n+                        key1 = key2;\n+                        value1 = value2;\n+                        hash2 = 0;\n+                        key2 = null;\n+                        value2 = null;\n+                        size = 1;\n                         return old;\n                     }\n                     return null;\n                 case 1:\n-                    if (iKey1 == null) {\n-                        Object old = iValue1;\n-                        iHash1 = 0;\n-                        iKey1 = null;\n-                        iValue1 = null;\n-                        iSize = 0;\n+                    if (key1 == null) {\n+                        Object old = value1;\n+                        hash1 = 0;\n+                        key1 = null;\n+                        value1 = null;\n+                        size = 0;\n                         return old;\n                     }\n             }\n         } else {\n-            if (iSize > 0) {\n+            if (size > 0) {\n                 int hashCode = key.hashCode();\n-                switch (iSize) {  // drop through\n+                switch (size) {  // drop through\n                     case 3:\n-                        if (iHash3 == hashCode && key.equals(iKey3)) {\n-                            Object old = iValue3;\n-                            iHash3 = 0;\n-                            iKey3 = null;\n-                            iValue3 = null;\n-                            iSize = 2;\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            Object old = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n                             return old;\n                         }\n-                        if (iHash2 == hashCode && key.equals(iKey2)) {\n-                            Object old = iValue3;\n-                            iHash2 = iHash3;\n-                            iKey2 = iKey3;\n-                            iValue2 = iValue3;\n-                            iHash3 = 0;\n-                            iKey3 = null;\n-                            iValue3 = null;\n-                            iSize = 2;\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            Object old = value3;\n+                            hash2 = hash3;\n+                            key2 = key3;\n+                            value2 = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n                             return old;\n                         }\n-                        if (iHash1 == hashCode && key.equals(iKey1)) {\n-                            Object old = iValue3;\n-                            iHash1 = iHash3;\n-                            iKey1 = iKey3;\n-                            iValue1 = iValue3;\n-                            iHash3 = 0;\n-                            iKey3 = null;\n-                            iValue3 = null;\n-                            iSize = 2;\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            Object old = value3;\n+                            hash1 = hash3;\n+                            key1 = key3;\n+                            value1 = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n                             return old;\n                         }\n                         return null;\n                     case 2:\n-                        if (iHash2 == hashCode && key.equals(iKey2)) {\n-                            Object old = iValue2;\n-                            iHash2 = 0;\n-                            iKey2 = null;\n-                            iValue2 = null;\n-                            iSize = 1;\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            Object old = value2;\n+                            hash2 = 0;\n+                            key2 = null;\n+                            value2 = null;\n+                            size = 1;\n                             return old;\n                         }\n-                        if (iHash1 == hashCode && key.equals(iKey1)) {\n-                            Object old = iValue2;\n-                            iHash1 = iHash2;\n-                            iKey1 = iKey2;\n-                            iValue1 = iValue2;\n-                            iHash2 = 0;\n-                            iKey2 = null;\n-                            iValue2 = null;\n-                            iSize = 1;\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            Object old = value2;\n+                            hash1 = hash2;\n+                            key1 = key2;\n+                            value1 = value2;\n+                            hash2 = 0;\n+                            key2 = null;\n+                            value2 = null;\n+                            size = 1;\n                             return old;\n                         }\n                         return null;\n                     case 1:\n-                        if (iHash1 == hashCode && key.equals(iKey1)) {\n-                            Object old = iValue1;\n-                            iHash1 = 0;\n-                            iKey1 = null;\n-                            iValue1 = null;\n-                            iSize = 0;\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            Object old = value1;\n+                            hash1 = 0;\n+                            key1 = null;\n+                            value1 = null;\n+                            size = 0;\n                             return old;\n                         }\n                 }\n      * to avoid garbage collection issues.\n      */\n     public void clear() {\n-        if (iMap != null) {\n-            iMap.clear();  // should aid gc\n-            iMap = null;  // switch back to flat mode\n+        if (delegateMap != null) {\n+            delegateMap.clear();  // should aid gc\n+            delegateMap = null;  // switch back to flat mode\n         } else {\n-            iSize = 0;\n-            iHash1 = iHash2 = iHash3 = 0;\n-            iKey1 = iKey2 = iKey3 = null;\n-            iValue1 = iValue2 = iValue3 = null;\n+            size = 0;\n+            hash1 = hash2 = hash3 = 0;\n+            key1 = key2 = key3 = null;\n+            value1 = value2 = value3 = null;\n         }\n     }\n \n      * @return the map iterator\n      */\n     public MapIterator mapIterator() {\n-        if (iMap != null) {\n-            return iMap.mapIterator();\n-        }\n-        if (iSize == 0) {\n+        if (delegateMap != null) {\n+            return delegateMap.mapIterator();\n+        }\n+        if (size == 0) {\n             return IteratorUtils.EMPTY_MAP_ITERATOR;\n         }\n         return new FlatMapIterator(this);\n      * FlatMapIterator\n      */\n     static class FlatMapIterator implements MapIterator, ResettableIterator {\n-        private final Flat3Map iFlatMap;\n-        private int iIndex = 0;\n-        private boolean iCanRemove = false;\n-        \n-        FlatMapIterator(Flat3Map map) {\n+        private final Flat3Map parent;\n+        private int nextIndex = 0;\n+        private boolean canRemove = false;\n+        \n+        FlatMapIterator(Flat3Map parent) {\n             super();\n-            iFlatMap = map;\n+            this.parent = parent;\n         }\n \n         public boolean hasNext() {\n-            return (iIndex < iFlatMap.iSize);\n+            return (nextIndex < parent.size);\n         }\n \n         public Object next() {\n             if (hasNext() == false) {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n-            iCanRemove = true;\n-            iIndex++;\n+            canRemove = true;\n+            nextIndex++;\n             return getKey();\n         }\n \n         public void remove() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n-            iFlatMap.remove(getKey());\n-            iIndex--;\n-            iCanRemove = false;\n+            parent.remove(getKey());\n+            nextIndex--;\n+            canRemove = false;\n         }\n \n         public Object getKey() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n-            switch (iIndex) {\n+            switch (nextIndex) {\n                 case 3:\n-                    return iFlatMap.iKey3;\n-                case 2:\n-                    return iFlatMap.iKey2;\n-                case 1:\n-                    return iFlatMap.iKey1;\n+                    return parent.key3;\n+                case 2:\n+                    return parent.key2;\n+                case 1:\n+                    return parent.key1;\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n         public Object getValue() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n-            switch (iIndex) {\n+            switch (nextIndex) {\n                 case 3:\n-                    return iFlatMap.iValue3;\n-                case 2:\n-                    return iFlatMap.iValue2;\n-                case 1:\n-                    return iFlatMap.iValue1;\n+                    return parent.value3;\n+                case 2:\n+                    return parent.value2;\n+                case 1:\n+                    return parent.value1;\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n         public Object setValue(Object value) {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             Object old = getValue();\n-            switch (iIndex) {\n+            switch (nextIndex) {\n                 case 3: \n-                    iFlatMap.iValue3 = value;\n-                case 2:\n-                    iFlatMap.iValue2 = value;\n-                case 1:\n-                    iFlatMap.iValue1 = value;\n+                    parent.value3 = value;\n+                case 2:\n+                    parent.value2 = value;\n+                case 1:\n+                    parent.value1 = value;\n             }\n             return old;\n         }\n         \n         public void reset() {\n-            iIndex = 0;\n-            iCanRemove = false;\n+            nextIndex = 0;\n+            canRemove = false;\n         }\n         \n         public String toString() {\n-            if (iCanRemove) {\n+            if (canRemove) {\n                 return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n             } else {\n                 return \"Iterator[]\";\n      * @return the entrySet view\n      */\n     public Set entrySet() {\n-        if (iMap != null) {\n-            return iMap.entrySet();\n+        if (delegateMap != null) {\n+            return delegateMap.entrySet();\n         }\n         return new EntrySet(this);\n     }\n      * EntrySet\n      */\n     static class EntrySet extends AbstractSet {\n-        private final Flat3Map iFlatMap;\n-        \n-        EntrySet(Flat3Map map) {\n+        private final Flat3Map parent;\n+        \n+        EntrySet(Flat3Map parent) {\n             super();\n-            iFlatMap = map;\n+            this.parent = parent;\n         }\n \n         public int size() {\n-            return iFlatMap.size();\n+            return parent.size();\n         }\n         \n         public void clear() {\n-            iFlatMap.clear();\n+            parent.clear();\n         }\n         \n         public boolean remove(Object obj) {\n             }\n             Map.Entry entry = (Map.Entry) obj;\n             Object key = entry.getKey();\n-            boolean result = iFlatMap.containsKey(key);\n-            iFlatMap.remove(key);\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n             return result;\n         }\n \n         public Iterator iterator() {\n-            if (iFlatMap.iMap != null) {\n-                return iFlatMap.iMap.entrySet().iterator();\n-            }\n-            if (iFlatMap.size() == 0) {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.entrySet().iterator();\n+            }\n+            if (parent.size() == 0) {\n                 return IteratorUtils.EMPTY_ITERATOR;\n             }\n-            return new EntrySetIterator(iFlatMap);\n+            return new EntrySetIterator(parent);\n         }\n     }\n \n      * EntrySetIterator and MapEntry\n      */\n     static class EntrySetIterator implements Iterator, Map.Entry {\n-        private final Flat3Map iFlatMap;\n-        private int iIndex = 0;\n-        private boolean iCanRemove = false;\n-        \n-        EntrySetIterator(Flat3Map map) {\n+        private final Flat3Map parent;\n+        private int nextIndex = 0;\n+        private boolean canRemove = false;\n+        \n+        EntrySetIterator(Flat3Map parent) {\n             super();\n-            iFlatMap = map;\n+            this.parent = parent;\n         }\n \n         public boolean hasNext() {\n-            return (iIndex < iFlatMap.iSize);\n+            return (nextIndex < parent.size);\n         }\n \n         public Object next() {\n             if (hasNext() == false) {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n-            iCanRemove = true;\n-            iIndex++;\n+            canRemove = true;\n+            nextIndex++;\n             return this;\n         }\n \n         public void remove() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n-            iFlatMap.remove(getKey());\n-            iIndex--;\n-            iCanRemove = false;\n+            parent.remove(getKey());\n+            nextIndex--;\n+            canRemove = false;\n         }\n \n         public Object getKey() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n-            switch (iIndex) {\n+            switch (nextIndex) {\n                 case 3:\n-                    return iFlatMap.iKey3;\n-                case 2:\n-                    return iFlatMap.iKey2;\n-                case 1:\n-                    return iFlatMap.iKey1;\n+                    return parent.key3;\n+                case 2:\n+                    return parent.key2;\n+                case 1:\n+                    return parent.key1;\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n         public Object getValue() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n-            switch (iIndex) {\n+            switch (nextIndex) {\n                 case 3:\n-                    return iFlatMap.iValue3;\n-                case 2:\n-                    return iFlatMap.iValue2;\n-                case 1:\n-                    return iFlatMap.iValue1;\n+                    return parent.value3;\n+                case 2:\n+                    return parent.value2;\n+                case 1:\n+                    return parent.value1;\n             }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n         public Object setValue(Object value) {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             Object old = getValue();\n-            switch (iIndex) {\n+            switch (nextIndex) {\n                 case 3: \n-                    iFlatMap.iValue3 = value;\n-                case 2:\n-                    iFlatMap.iValue2 = value;\n-                case 1:\n-                    iFlatMap.iValue1 = value;\n+                    parent.value3 = value;\n+                case 2:\n+                    parent.value2 = value;\n+                case 1:\n+                    parent.value1 = value;\n             }\n             return old;\n         }\n         \n         public boolean equals(Object obj) {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 return false;\n             }\n             if (obj instanceof Map.Entry == false) {\n         }\n         \n         public int hashCode() {\n-            if (iCanRemove == false) {\n+            if (canRemove == false) {\n                 return 0;\n             }\n             Object key = getKey();\n         }\n         \n         public String toString() {\n-            if (iCanRemove) {\n+            if (canRemove) {\n                 return getKey() + \"=\" + getValue();\n             } else {\n                 return \"\";\n      * @return the keySet view\n      */\n     public Set keySet() {\n-        if (iMap != null) {\n-            return iMap.keySet();\n+        if (delegateMap != null) {\n+            return delegateMap.keySet();\n         }\n         return new KeySet(this);\n     }\n      * KeySet\n      */\n     static class KeySet extends AbstractSet {\n-        private final Flat3Map iFlatMap;\n-        \n-        KeySet(Flat3Map map) {\n+        private final Flat3Map parent;\n+        \n+        KeySet(Flat3Map parent) {\n             super();\n-            iFlatMap = map;\n+            this.parent = parent;\n         }\n \n         public int size() {\n-            return iFlatMap.size();\n+            return parent.size();\n         }\n         \n         public void clear() {\n-            iFlatMap.clear();\n+            parent.clear();\n         }\n         \n         public boolean contains(Object key) {\n-            return iFlatMap.containsKey(key);\n+            return parent.containsKey(key);\n         }\n \n         public boolean remove(Object key) {\n-            boolean result = iFlatMap.containsKey(key);\n-            iFlatMap.remove(key);\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n             return result;\n         }\n \n         public Iterator iterator() {\n-            if (iFlatMap.iMap != null) {\n-                return iFlatMap.iMap.keySet().iterator();\n-            }\n-            if (iFlatMap.size() == 0) {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.keySet().iterator();\n+            }\n+            if (parent.size() == 0) {\n                 return IteratorUtils.EMPTY_ITERATOR;\n             }\n-            return new KeySetIterator(iFlatMap);\n+            return new KeySetIterator(parent);\n         }\n     }\n \n      */\n     static class KeySetIterator extends EntrySetIterator {\n         \n-        KeySetIterator(Flat3Map map) {\n-            super(map);\n+        KeySetIterator(Flat3Map parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      * @return the values view\n      */\n     public Collection values() {\n-        if (iMap != null) {\n-            return iMap.values();\n+        if (delegateMap != null) {\n+            return delegateMap.values();\n         }\n         return new Values(this);\n     }\n      * Values\n      */\n     static class Values extends AbstractCollection {\n-        private final Flat3Map iFlatMap;\n-        \n-        Values(Flat3Map map) {\n+        private final Flat3Map parent;\n+        \n+        Values(Flat3Map parent) {\n             super();\n-            iFlatMap = map;\n+            this.parent = parent;\n         }\n \n         public int size() {\n-            return iFlatMap.size();\n+            return parent.size();\n         }\n         \n         public void clear() {\n-            iFlatMap.clear();\n+            parent.clear();\n         }\n         \n         public boolean contains(Object value) {\n-            return iFlatMap.containsValue(value);\n+            return parent.containsValue(value);\n         }\n \n         public Iterator iterator() {\n-            if (iFlatMap.iMap != null) {\n-                return iFlatMap.iMap.values().iterator();\n-            }\n-            if (iFlatMap.size() == 0) {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.values().iterator();\n+            }\n+            if (parent.size() == 0) {\n                 return IteratorUtils.EMPTY_ITERATOR;\n             }\n-            return new ValuesIterator(iFlatMap);\n+            return new ValuesIterator(parent);\n         }\n     }\n \n      */\n     static class ValuesIterator extends EntrySetIterator {\n         \n-        ValuesIterator(Flat3Map map) {\n-            super(map);\n+        ValuesIterator(Flat3Map parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n         if (obj == this) {\n             return true;\n         }\n-        if (iMap != null) {\n-            return iMap.equals(obj);\n+        if (delegateMap != null) {\n+            return delegateMap.equals(obj);\n         }\n         if (obj instanceof Map == false) {\n             return false;\n         }\n         Map other = (Map) obj;\n-        if (iSize != other.size()) {\n+        if (size != other.size()) {\n             return false;\n         }\n-        if (iSize > 0) {\n+        if (size > 0) {\n             Object otherValue = null;\n-            switch (iSize) {  // drop through\n+            switch (size) {  // drop through\n                 case 3:\n-                    if (other.containsKey(iKey3) == false) {\n-                        otherValue = other.get(iKey3);\n-                        if (iValue3 == null ? otherValue != null : !iValue3.equals(otherValue)) {\n+                    if (other.containsKey(key3) == false) {\n+                        otherValue = other.get(key3);\n+                        if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n                             return false;\n                         }\n                     }\n                 case 2:\n-                    if (other.containsKey(iKey2) == false) {\n-                        otherValue = other.get(iKey2);\n-                        if (iValue2 == null ? otherValue != null : !iValue2.equals(otherValue)) {\n+                    if (other.containsKey(key2) == false) {\n+                        otherValue = other.get(key2);\n+                        if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n                             return false;\n                         }\n                     }\n                 case 1:\n-                    if (other.containsKey(iKey1) == false) {\n-                        otherValue = other.get(iKey1);\n-                        if (iValue1 == null ? otherValue != null : !iValue1.equals(otherValue)) {\n+                    if (other.containsKey(key1) == false) {\n+                        otherValue = other.get(key1);\n+                        if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n                             return false;\n                         }\n                     }\n      * @return the hashcode defined in the Map interface\n      */\n     public int hashCode() {\n-        if (iMap != null) {\n-            return iMap.hashCode();\n+        if (delegateMap != null) {\n+            return delegateMap.hashCode();\n         }\n         int total = 0;\n-        switch (iSize) {  // drop through\n+        switch (size) {  // drop through\n             case 3:\n-                total += (iHash3 ^ (iValue3 == null ? 0 : iValue3.hashCode()));\n+                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n             case 2:\n-                total += (iHash2 ^ (iValue2 == null ? 0 : iValue2.hashCode()));\n+                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n             case 1:\n-                total += (iHash1 ^ (iValue1 == null ? 0 : iValue1.hashCode()));\n+                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n         }\n         return total;\n     }\n      * @return a string version of the map\n      */\n     public String toString() {\n-        if (iMap != null) {\n-            return iMap.toString();\n-        }\n-        if (iSize == 0) {\n+        if (delegateMap != null) {\n+            return delegateMap.toString();\n+        }\n+        if (size == 0) {\n             return \"{}\";\n         }\n         StringBuffer buf = new StringBuffer(128);\n         buf.append('{');\n-        switch (iSize) {  // drop through\n+        switch (size) {  // drop through\n             case 3:\n-                buf.append(iKey3);\n+                buf.append(key3);\n                 buf.append('=');\n-                buf.append(iValue3);\n+                buf.append(value3);\n                 buf.append(',');\n             case 2:\n-                buf.append(iKey2);\n+                buf.append(key2);\n                 buf.append('=');\n-                buf.append(iValue2);\n+                buf.append(value2);\n                 buf.append(',');\n             case 1:\n-                buf.append(iKey1);\n+                buf.append(key1);\n                 buf.append('=');\n-                buf.append(iValue1);\n+                buf.append(value1);\n         }\n         buf.append('}');\n         return buf.toString();", "timestamp": 1072658312, "metainfo": ""}