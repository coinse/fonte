{"sha": "e5e367a2b28823db9e2e31522bd6e67cc42dd7af", "log": "Reproduce COLLECTIONS-3.  ", "commit": "\n--- a/src/test/org/apache/commons/collections/map/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLRUMap.java\n package org.apache.commons.collections.map;\n \n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n             fail();\n         } catch (IndexOutOfBoundsException ex) {}\n     }\n+    \n+    public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {\n+\n+        final Map map = new LRUMap(10000);\n+        \n+        final Map exceptions = new HashMap();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {\n+                                Map.Entry entry = (Map.Entry)iter.next();\n+                                if (entry.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    // TODO: COLLECTIONS-3\n+    public void todoTestSynchronizedRemoveFromKeySet() throws InterruptedException {\n+\n+        final Map map = new LRUMap(10000);\n+        \n+        final Map exceptions = new HashMap();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {\n+                                String name = (String)iter.next();\n+                                if (map.get(name) == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromValues() throws InterruptedException {\n+\n+        final Map map = new LRUMap(10000);\n+        \n+        final Map exceptions = new HashMap();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator iter = map.values().iterator(); iter.hasNext();) {\n+                                if (iter.next() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n \n //    public void testCreate() throws Exception {\n //        resetEmpty();", "timestamp": 1245230761, "metainfo": ""}