{"sha": "89417ef747638c484a20472cf5032a500e32694d", "log": "LRUMap reimplemented, based on SequencedHashMap   ", "commit": "\n--- a/src/java/org/apache/commons/collections/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/LRUMap.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/LRUMap.java,v 1.8 2002/02/14 21:24:32 morgand Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/02/14 21:24:32 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n-package org.apache.commons.collections;\n-\n-import java.io.Externalizable;\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectOutput;\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/** <p>\n-  * An implementation of a Map which has a maximum size and uses a Least Recently Used\n-  * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n-  * </p>\n-  *\n-  * <p>\n-  * This implementation uses a simple bubbling\n-  * algorithm, whereby every random access get() method call bubbles the item\n-  * up the list, further away from the 'drop zone'.\n-  * </p>\n-  *\n-  * <p>\n-  * A synchronized version can be obtained with:\n-  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n-  * If it will be accessed by multiple threads, you _must_ synchronize access \n-  * to this Map.  Even concurrent get(Object) operations produce indeterminate\n-  * behaviour.\n-  * </p>\n-  *\n-  * <p>\n-  * <b>Warning</b>: This class is not a true \"Least Recently Used\" map.  When \n-  * mappings are accessed, the mapping is moved one position away from the end\n-  * of the list, rather than all the way to the front of the list.  This means\n-  * that the \"most\" recently used, is not at the front of the list, and the \n-  * \"least\" recently used is not necessarily at the end of the list.  Here's a\n-  * simple example (Provided by Aaron Smuts on commons-dev@):\n-  *\n-  * <pre>\n-  *    Say that items 0 - 9 are put in.  The limit is 10.\n-  *\n-  *    The list looks like:\n-  *\n-  *    Index order (0-9)\n-  *    9,8,7,6,5,4,3,2,1,0\n-  *\n-  *    Item 1 is accessed and the list now looks like:\n-  *    Index order (0-9)\n-  *    9,8,7,6,5,4,3,1,2,0\n-  *\n-  *    Item 0 is accessed and the list now looks like:\n-  *    Index order (0-9)\n-  *    9,8,7,6,5,4,3,1,0,2\n-  *\n-  *    Item 2 is accessed and the list now looks like:\n-  *    Index order (0-9)\n-  *    9,8,7,6,5,4,3,1,2,0\n-  *\n-  *    Item 10 is added and the list now looks like\n-  *    Index order (0-9)\n-  *    10,9,8,7,6,5,4,3,1,2\n-  *\n-  *    Item 0 was droped but it was not the least recently used element.\n-  * </pre>\n-   * </p>\n-  * <p>\n-  * Additionally, the results from entrySet() and values() are not properly \n-  * backed by the map in violation of the Map API contract.  These methods \n-  * are also not implemented efficiently.</li>\n-  * </ul>\n-  * </p>\n-  * \n-  * <p>These issues hopefully will be corrected at a later date.</p>\n-  * \n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n-  */\n-public class LRUMap extends HashMap implements Externalizable {\n-    \n-    /** Holds value of property maximumSize. */\n-    private int maximumSize;\n-    /** Used to hold the bubble list - bubbles keys up the list as they are accessed */\n-    private ArrayList bubbleList;\n-    \n-    //static final long serialVersionUID = 0x9e1e06764b24cb05L;\n-\n-    public LRUMap() {\n-        this( 100 );\n-    }\n-\n-    public LRUMap(int i) {\n-        super( i );\n-        maximumSize = i;\n-        bubbleList = new ArrayList( i );\n-    }\n-\n-\n-     /**\n-      * <p>\n-      *   Removes the least recently used object from the Map.\n-      * </p>\n-      * \n-      * <p>\n-      * This method will determine the object to\n-      * remove and call remove(Object).  If you want a subclass\n-      * to perform some operation before removing an Object,\n-      * you can override remove(Object) for all remove\n-      * operations, or removeLRU() if you only want to affect\n-      * automatic removes.\n-      * </p>\n-      * \n-      * @return the key of the removed item\n-      */\n-    public Object removeLRU() {\n-        int lastItem = size() - 1;\n-        Object key = bubbleList.get( lastItem );\n-\n-         remove( key );\n-        return key;\n-    }\n-    \n-    // Map interface\n-    //-------------------------------------------------------------------------        \n-    public Object get( Object key ) {\n-        ValuePositionPair pair = getPair( key );\n-        if ( pair == null ) {\n-            return null;\n-        }\n-        int position = pair.position;\n-        if ( position > 0 ) {\n-            // lets bubble up this entry up the list\n-            // avoiding expesive list removal / insertion\n-            int position2 = position - 1;\n-            Object key2 = bubbleList.get( position2 );\n-            ValuePositionPair pair2 = getPair( key2 );\n-            if ( pair2 != null ) {\n-                pair2.position = position;\n-                pair.position = position2;\n-                bubbleList.set( position, key2 );\n-                bubbleList.set( position2, key );\n-            }\n-        }\n-        return pair.value;\n-    }\n-\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/LRUMap.java,v 1.9 2002/02/20 18:01:34 morgand Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/02/20 18:01:34 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutput;\n+import java.io.ObjectOutputStream;\n+import java.util.Iterator;\n+\n+/** <p>\n+  * An implementation of a Map which has a maximum size and uses a Least Recently Used\n+  * algorithm to remove items from the Map when the maximum size is reached and new items are added.\n+  * </p>\n+  *\n+  * <p>\n+  * A synchronized version can be obtained with:\n+  * <code>Collections.synchronizedMap( theMapToSynchronize )</code>\n+  * If it will be accessed by multiple threads, you _must_ synchronize access \n+  * to this Map.  Even concurrent get(Object) operations produce indeterminate\n+  * behaviour.\n+  * </p>\n+  *\n+  * <p>\n+  * Unlike that Collections 1.0 version, this version of LRUMap does use a true\n+  * LRU algorithm.  The keys for all gets and puts are moved to the front of\n+  * the list.  LRUMap is now a subclass of SequencedHashMap, and the \"LRU\"\n+  * key is now equivalent to LRUMap.getFirst().\n+  * </p>\n+  * \n+  * \n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n+  */\n+public class LRUMap extends SequencedHashMap implements Externalizable {\n+        \n+    private int maximumSize = 0;\n+\n+    /**\n+     * Default constructor, primarily for the purpose of\n+     * de-externalization.  This constructors sets a default\n+     * LRU limit of 100 keys, but this value may be overridden\n+     * internally as a result of de-externalization.\n+     */\n+    public LRUMap() {\n+        this( 100 );\n+    }\n+\n+    /**\n+     * Create a new LRUMap with a maximum capacity of <i>i</i>.\n+     * Once <i>i</i> capacity is achieved, subsequent gets\n+     * and puts will push keys out of the map.  See .\n+     * \n+     * @param i      Maximum capacity of the LRUMap\n+     */\n+    public LRUMap(int i) {\n+        super( i );\n+        maximumSize = i;\n+    }\n \n      /**\n       * <p>Removes the key and its Object from the Map.</p>\n       * @param value  Object to add\n       * @return Former value of the key\n       * @see removeLRU()\n-      */\n+      */    \n     public Object put( Object key, Object value ) {\n \n-         ValuePositionPair pair = new ValuePositionPair( value );\n          int mapSize = size();\n-\n-         // check to see if the object already exists in\n-         // our LRUMap, if it does then the position in the\n-         // bubble sort is OK\n-        int keyIndex = bubbleList.indexOf(key);\n-         if (keyIndex != -1) {\n-\n-             pair.position = keyIndex;\n-\n-         } else if ( mapSize >= maximumSize ) {\n-            // lets retire the least recently used item in the cache\n-            int lastIndex = maximumSize - 1;\n-            pair.position = lastIndex;\n-\n-             removeLRU();\n-\n-             bubbleList.add(lastIndex, key);\n-        } else {\n-            pair.position = mapSize;\n-            bubbleList.add( mapSize, key );\n-        }\n-        pair = (ValuePositionPair) putPair( key, pair );\n-        return ( pair != null ) ? pair.value : null;\n-    }\n-\n-    public Object remove( Object key ) {\n-        ValuePositionPair pair = removePair( key );\n-        if ( pair != null ) {\n-            bubbleList.remove( pair.position );\n-            return pair.value;\n-        }\n-        return null;\n-    }\n-    \n-    public boolean containsKey( Object key ) {\n-        return super.containsKey( key );\n-    }\n-\n-    public boolean containsValue( Object value ) {\n-        for ( Iterator iter = pairIterator(); iter.hasNext(); ) {\n-            ValuePositionPair pair = (ValuePositionPair) iter.next();\n-            Object otherValue = pair.value;\n-            if ( value == otherValue ) {\n-                return true;\n-            }\n-            if ( value != null && value.equals( otherValue ) ) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-    \n-    public Set keySet() {\n-        return super.keySet();\n-    }\n-    \n-    public Set entrySet() {\n-        HashSet answer = new HashSet();\n-        for ( Iterator iter = super.entrySet().iterator(); iter.hasNext(); ) {\n-            Map.Entry otherEntry = (Map.Entry) iter.next();\n-            Object key = otherEntry.getKey();\n-            ValuePositionPair pair = (ValuePositionPair) otherEntry.getValue();\n-            Object value = pair.value;\n-            Entry newEntry = new Entry( key, value );\n-            answer.add( newEntry );\n-        }\n-        return answer;\n-    }\n-\n-    public Collection values() {\n-        ArrayList answer = new ArrayList();\n-        for ( Iterator iter = super.entrySet().iterator(); iter.hasNext(); ) {\n-            Map.Entry otherEntry = (Map.Entry) iter.next();\n-            Entry newEntry = new Entry( otherEntry.getKey(), otherEntry.getValue() );\n-            answer.add( newEntry );\n-        }\n-        return answer;\n-    }\n-\n-\n- \n-    // Externalizable interface\n-    //-------------------------------------------------------------------------        \n-    public void readExternal( ObjectInput in )  throws IOException, ClassNotFoundException {\n-        maximumSize = in.readInt();\n-        int size = in.readInt();\n-        \n-        // create a populated list\n-        bubbleList = new ArrayList( maximumSize );\n-        for( int i = 0; i < size; i++ )  {\n-            bubbleList.add( \"\" );\n-        }\n-\n-        for( int i = 0; i < size; i++ )  {\n-            Object key = in.readObject();\n-            Object value = in.readObject();\n-            ValuePositionPair pair = (ValuePositionPair) value;            \n-            int position = pair.position;\n-            bubbleList.set( position, pair );\n-            putPair( key, pair );\n-        }\n-    }\n-\n-    public void writeExternal( ObjectOutput out ) throws IOException {\n-        out.writeInt( maximumSize );\n-        out.writeInt( size() );\n-        for( Iterator iterator = keySet().iterator(); iterator.hasNext(); ) {\n-            Object key = iterator.next();\n-            out.writeObject( key );\n-            Object value = getPair( key );\n-            out.writeObject( value );\n-        }\n-    }\n-    \n-    \n-    // Properties\n-    //-------------------------------------------------------------------------        \n-    /** Getter for property maximumSize.\n-     * @return Value of property maximumSize.\n-     */\n-    public int getMaximumSize() {\n-        return maximumSize;\n-    }\n-    /** Setter for property maximumSize.\n-     * @param maximumSize New value of property maximumSize.\n-     */\n-    public void setMaximumSize(int maximumSize) {\n-        this.maximumSize = maximumSize;\n-    }\n-    \n-    \n-    // Implementation methods\n-    //-------------------------------------------------------------------------        \n-    protected ValuePositionPair getPair( Object key ) {\n-        return (ValuePositionPair) super.get( key );\n-    }\n-    \n-    protected ValuePositionPair putPair( Object key, ValuePositionPair pair ) {\n-        return (ValuePositionPair) super.put( key, pair );\n-    }\n-    \n-    protected ValuePositionPair removePair( Object key ) {\n-        return (ValuePositionPair) super.remove( key );\n-    }\n-    \n-    protected Iterator pairIterator() {\n-        return super.values().iterator();\n-    }\n-    \n-    // Implementation classes\n-    //-------------------------------------------------------------------------    \n-    protected static class ValuePositionPair implements Serializable {\n-\n-        public Object value;\n-        public int position;\n-\n-        public ValuePositionPair() {\n-        }\n-        \n-        public ValuePositionPair( Object value ) {\n-            this.value = value;\n-        }\n-        \n-        public String toString() {\n-            return \"[ \" + position + \": \" + value + \" ]\";\n-        }\n-    }\n-    \n-    /** \n-     * A map entry, which is backed by this RefHashMap\n-     */\n-    class Entry implements Map.Entry {\n-        \n-        /**\n-         * Constructor\n-         */\n-        public Entry( Object key, Object value ) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        // Map.Entry interface\n-        // -----------------------------------------------------------\n-        \n-        /**\n-         * Retrieves the key of this mapping\n-         */\n-        public Object getKey() {\n-            return key;\n-        }\n-        \n-        /**\n-         * Retrieves the value of this mapping\n-         */\n-        public Object getValue() {\n-           return value;\n-        }\n-        \n-        /**\n-         * Sets the value of this mapping\n-         */\n-        public Object setValue( Object value ) {\n-            this.value = value;\n-            put( key, value ); \n-            return value;\n-        }\n-        \n-        /**\n-         * Return the hash code of this mapping.\n-         * This algorithm was taken from the JavaDoc for Map.Entry\n-         */\n-        public int hashCode() {\n-            return ( getKey() == null ? 0 : getKey().hashCode() ) ^\n-                ( getValue() == null ? 0 : getValue().hashCode() );\n-         }\n-        \n-        /** The domain of this mapping */\n-        private Object key;\n-        /** The range of this mapping */\n-        private Object value;    \n-    }\n-}\n+         Object retval = null;\n+\n+         if ( mapSize >= maximumSize ) {\n+\n+             // don't retire LRU if you are just\n+             // updating an existing key\n+             if (!containsKey(key)) {\n+                 // lets retire the least recently used item in the cache\n+                 removeLRU();\n+             }\n+\n+            retval = super.put(key,value);\n+        } else {\n+            retval = super.put(key,value);\n+        }\n+\n+        return retval;\n+    }\n+\n+    /**\n+     * This method is used internally by the class for \n+     * finding and removing the LRU Object.\n+     */\n+    protected void removeLRU() {\n+        Object key = getFirstKey();\n+        Object value = get(key);\n+        \n+        remove(key);\n+\n+        processRemovedLRU(key,value);\n+    }\n+\n+    /**\n+     * Subclasses of LRUMap may hook into this method to\n+     * provide specialized actions whenever an Object is\n+     * automatically removed from the cache.  By default,\n+     * this method does nothing.\n+     * \n+     * @param key    key that was removed\n+     * @param value  value of that key (can be null)\n+     */\n+    protected void processRemovedLRU(Object key, Object value) {\n+    }\n+ \n+    // Externalizable interface\n+    //-------------------------------------------------------------------------        \n+    public void readExternal( ObjectInput in )  throws IOException, ClassNotFoundException {\n+        maximumSize = in.readInt();\n+        int size = in.readInt();\n+        \n+        for( int i = 0; i < size; i++ )  {\n+            Object key = in.readObject();\n+            Object value = in.readObject();\n+            put(key,value);\n+        }\n+    }\n+\n+    public void writeExternal( ObjectOutput out ) throws IOException {\n+        out.writeInt( maximumSize );\n+        out.writeInt( size() );\n+        for( Iterator iterator = keySet().iterator(); iterator.hasNext(); ) {\n+            Object key = iterator.next();\n+            out.writeObject( key );\n+            Object value = get( key );\n+            out.writeObject( value );\n+        }\n+    }\n+    \n+    \n+    // Properties\n+    //-------------------------------------------------------------------------        \n+    /** Getter for property maximumSize.\n+     * @return Value of property maximumSize.\n+     */\n+    public int getMaximumSize() {\n+        return maximumSize;\n+    }\n+    /** Setter for property maximumSize.\n+     * @param maximumSize New value of property maximumSize.\n+     */\n+    public void setMaximumSize(int maximumSize) {\n+        this.maximumSize = maximumSize;\n+        while (size() > maximumSize) {\n+            removeLRU();\n+        }\n+    }\n+        \n+}\n--- a/src/test/org/apache/commons/collections/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/TestLRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.11 2002/02/19 21:28:53 morgand Exp $\n- * $Revision: 1.11 $\n- * $Date: 2002/02/19 21:28:53 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.12 2002/02/20 18:01:34 morgand Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2002/02/20 18:01:34 $\n  *\n  * ====================================================================\n  *\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n import java.util.Map;\n import java.util.HashMap;\n \n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n- * @version $Id: TestLRUMap.java,v 1.11 2002/02/19 21:28:53 morgand Exp $\n+ * @version $Id: TestLRUMap.java,v 1.12 2002/02/20 18:01:34 morgand Exp $\n  */\n public class TestLRUMap extends TestMap\n {\n     }\n \n     public void testRemoveLRU() {\n-        LRUMap map2 = new LRUMap(4);\n+        LRUMap map2 = new LRUMap(3);\n         map2.put(new Integer(1),\"foo\");\n         map2.put(new Integer(2),\"foo\");\n         map2.put(new Integer(3),\"foo\");\n         map2.put(new Integer(4),\"foo\");\n-        map2.removeLRU();  // should be Integer(4)\n-\n-        assertTrue(\"Second to last value should exist\",map2.get(new Integer(3)).equals(\"foo\"));\n-        assertTrue(\"Last value inserted should not exist\", map2.get(new Integer(4)) == null);\n+\n+        assertTrue(\"last value should exist\",map2.get(new Integer(4)).equals(\"foo\"));\n+        assertTrue(\"LRU should not exist\", map2.get(new Integer(1)) == null);\n     }\n \n     public void testMultiplePuts() {\n \n         assertTrue(\"null value in Map\",map.containsValue(null));\n         assertTrue(\"key to a null value\",map.containsKey(new Integer(2)));\n-    }\n-\n-    /**\n-     * Test performs a complex series of puts, then makes sure\n-     * that they have ended up in the correct LRU order.\n-     */\n-    public void testTrueLRU() {\n-        // implement when subclass of SequencedHashMap\n     }\n \n     /**\n      */\n     public void testLRUSubclass() {\n         LRUCounter counter = new LRUCounter(3);\n-        counter.put(new Integer(1),\"foo\");\n-        counter.put(new Integer(2),\"foo\");\n-        counter.put(new Integer(3),\"foo\");\n-        counter.put(new Integer(1),\"foo\");\n-        counter.put(new Integer(4),\"foo\");\n-        counter.put(new Integer(5),\"foo\");\n-        counter.put(new Integer(2),\"foo\");\n-        counter.remove(new Integer(5));\n-\n-        assertTrue(\"size should be 2, but was \" + counter.size(), counter.size() == 2);\n-        assertTrue(\"removedCount should be 2 but was \" + counter.removedCount,\n-                   counter.removedCount == 2);\n-    }\n-\n-    /**\n-     * You should be able to subclass LRUMap and perform a \n-     * custom action when items are removed automatically\n-     * or when remove is called manually\n-     * by overriding the remove(Object) method.\n-     */\n-    public void testRemoveSubclass() {\n-        RemoveCounter counter = new RemoveCounter(3);\n-        counter.put(new Integer(1),\"foo\");\n-        counter.put(new Integer(2),\"foo\");\n-        counter.put(new Integer(3),\"foo\");\n-        counter.put(new Integer(1),\"foo\");\n-        counter.put(new Integer(4),\"foo\");\n-        counter.put(new Integer(5),\"foo\");\n-        counter.put(new Integer(2),\"foo\");\n-        counter.remove(new Integer(5));\n+        // oldest <--> newest\n+        // 1\n+        counter.put(\"1\",\"foo\");\n+        // 1 2\n+        counter.put(\"2\",\"foo\");\n+        // 1 2 3\n+        counter.put(\"3\",\"foo\");\n+        // 2 3 1\n+        counter.put(\"1\",\"foo\");\n+        // 3 1 4 (2 goes out)\n+        counter.put(\"4\",\"foo\");\n+        // 1 4 5 (3 goes out)\n+        counter.put(\"5\",\"foo\");\n+        // 4 5 2 (1 goes out)\n+        counter.put(\"2\",\"foo\");\n+        // 4 2\n+        counter.remove(\"5\");\n \n         assertTrue(\"size should be 2, but was \" + counter.size(), counter.size() == 2);\n         assertTrue(\"removedCount should be 3 but was \" + counter.removedCount,\n                    counter.removedCount == 3);\n+\n+        assertTrue(\"first removed was '2'\",counter.list.get(0).equals(\"2\"));\n+        assertTrue(\"second removed was '3'\",counter.list.get(1).equals(\"3\"));\n+        assertTrue(\"third removed was '1'\",counter.list.get(2).equals(\"1\"));\n+\n+        assertTrue(\"oldest key is '4'\",counter.get(0).equals(\"4\"));\n+        assertTrue(\"newest key is '2'\",counter.get(1).equals(\"2\"));\n     }\n \n     private class LRUCounter extends LRUMap {\n         int removedCount = 0;\n+        ArrayList list = new ArrayList(3); \n \n         LRUCounter(int i) {\n             super(i);\n         }\n \n-        public Object removeLRU() {\n+        protected void processRemovedLRU(Object key, Object value) {\n             ++removedCount;\n-            return super.removeLRU();\n+            list.add(key);\n         }\n     }\n \n-    private class RemoveCounter extends LRUMap {\n-        int removedCount = 0;\n-\n-        RemoveCounter(int i) {\n-            super(i);\n-        }\n-\n-        public Object remove(Object o) {\n-            ++removedCount;\n-            return super.remove(o);\n-        }\n-    }\n-\n }", "timestamp": 1014228094, "metainfo": ""}