{"sha": "b7430de759bc66fcce9c5becb7dc0b022606d8ae", "log": "Remove trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ArrayStack.java\n+++ b/src/main/java/org/apache/commons/collections4/ArrayStack.java\n  * is therefore operates faster in environments where you do not need to\n  * worry about multiple thread contention.\n  * <p>\n- * The removal order of an <code>ArrayStack</code> is based on insertion \n+ * The removal order of an <code>ArrayStack</code> is based on insertion\n  * order: The most recently added element is removed first.  The iteration\n  * order is <i>not</i> the same as the removal order.  The iterator returns\n  * elements from the bottom up.\n @Deprecated\n public class ArrayStack<E> extends ArrayList<E> {\n \n-    /** Ensure serialization compatibility */    \n+    /** Ensure serialization compatibility */\n     private static final long serialVersionUID = 2130079159931574599L;\n \n     /**\n \n     /**\n      * Constructs a new empty <code>ArrayStack</code> with an initial size.\n-     * \n+     *\n      * @param initialSize  the initial size to use\n      * @throws IllegalArgumentException  if the specified initial size\n      *  is negative\n      * <p>\n      * This method exists for compatibility with <code>java.util.Stack</code>.\n      * New users of this class should use <code>isEmpty</code> instead.\n-     * \n+     *\n      * @return true if the stack is currently empty\n      */\n     public boolean empty() {\n--- a/src/main/java/org/apache/commons/collections4/Bag.java\n+++ b/src/main/java/org/apache/commons/collections4/Bag.java\n  * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n  * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n  * <p>\n- * <i>NOTE: This interface violates the {@link Collection} contract.</i> \n+ * <i>NOTE: This interface violates the {@link Collection} contract.</i>\n  * The behavior specified in many of these methods is <i>not</i> the same\n  * as the behavior specified by <code>Collection</code>.\n  * The noncompliant methods are clearly marked with \"(Violation)\".\n      * Returns the number of occurrences (cardinality) of the given\n      * object currently in the bag. If the object does not exist in the\n      * bag, return 0.\n-     * \n+     *\n      * @param object  the object to search for\n      * @return the number of occurrences of the object, zero if not found\n      */\n      * {@link #uniqueSet()} and report its count as 1.\n      * <p>\n      * Since this method always increases the size of the bag,\n-     * according to the {@link Collection#add(Object)} contract, it \n+     * according to the {@link Collection#add(Object)} contract, it\n      * should always return <code>true</code>.  Since it sometimes returns\n      * <code>false</code>, this method violates the contract.\n      *\n      * If the object is already in the {@link #uniqueSet()} then increment its\n      * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n      * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n-     * \n+     *\n      * @param object  the object to add\n      * @param nCopies  the number of copies to add\n      * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      * <p>\n      * If the number of copies to remove is greater than the actual number of\n      * copies in the Bag, no error is thrown.\n-     * \n+     *\n      * @param object  the object to remove\n      * @param nCopies  the number of copies to remove\n      * @return <code>true</code> if this call changed the collection\n      * Returns a {@link Set} of unique elements in the Bag.\n      * <p>\n      * Uniqueness constraints are the same as those in {@link java.util.Set}.\n-     * \n+     *\n      * @return the Set of unique Bag elements\n      */\n     Set<E> uniqueSet();\n \n     /**\n      * Returns the total number of items in the bag across all types.\n-     * \n+     *\n      * @return the total size of the Bag\n      */\n     int size();\n      * that cardinality should <i>not</i> be respected; this method should\n      * return true if the bag contains at least one of every object contained\n      * in the given collection.\n-     * \n+     *\n      * @param coll  the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n      *\n      * <p>The {@link Collection#removeAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n-     * remove <i>all</i> occurrences of every object contained in the \n+     * remove <i>all</i> occurrences of every object contained in the\n      * given collection.\n      *\n      * @param coll  the collection to remove\n      *\n      * <p>The {@link Collection#retainAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n-     * keep <i>all</i> occurrences of every object contained in the \n+     * keep <i>all</i> occurrences of every object contained in the\n      * given collection.\n      *\n      * @param coll  the collection to retain\n      * Returns an {@link Iterator} over the entire set of members,\n      * including copies due to cardinality. This iterator is fail-fast\n      * and will not tolerate concurrent modifications.\n-     * \n+     *\n      * @return iterator over all elements in the Bag\n      */\n     Iterator<E> iterator();\n //     * This Bag equals another Bag if it contains the same number of occurrences of\n //     * the same elements.\n //     * This equals definition is compatible with the Set interface.\n-//     * \n+//     *\n //     * @param obj  the Bag to compare to\n //     * @return true if equal\n //     */\n //     * The per element hash code is defined as\n //     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>.\n //     * This hash code definition is compatible with the Set interface.\n-//     * \n+//     *\n //     * @return the hash code of the Bag\n //     */\n //    int hashCode();\n--- a/src/main/java/org/apache/commons/collections4/BagUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/BagUtils.java\n      * <p>\n      * It is imperative that the user manually synchronize on the returned bag\n      * when iterating over it:\n-     * \n+     *\n      * <pre>\n      * Bag bag = BagUtils.synchronizedBag(new HashBag());\n      * ...\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * Failure to follow this advice may result in non-deterministic behavior.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag to synchronize, must not be null\n      * @return a synchronized bag backed by that bag\n     /**\n      * Returns an unmodifiable view of the given bag. Any modification attempts\n      * to the returned bag will raise an {@link UnsupportedOperationException}.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag whose unmodifiable view is to be returned, must not be null\n      * @return an unmodifiable view of that bag\n      * IllegalArgumentException. It is important not to use the original bag\n      * after invoking this method, as it is a backdoor for adding invalid\n      * objects.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag to predicate, must not be null\n      * @param predicate the predicate for the bag, must not be null\n      * <p>\n      * Existing entries in the specified bag will not be transformed.\n      * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag to predicate, must not be null\n      * @param transformer the transformer for the bag, must not be null\n      * <p>\n      * It is imperative that the user manually synchronize on the returned bag\n      * when iterating over it:\n-     * \n+     *\n      * <pre>\n      * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n      * ...\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * Failure to follow this advice may result in non-deterministic behavior.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag to synchronize, must not be null\n      * @return a synchronized bag backed by that bag\n      * Returns an unmodifiable view of the given sorted bag. Any modification\n      * attempts to the returned bag will raise an\n      * {@link UnsupportedOperationException}.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag whose unmodifiable view is to be returned, must not be null\n      * @return an unmodifiable view of that bag\n      * IllegalArgumentException. It is important not to use the original bag\n      * after invoking this method, as it is a backdoor for adding invalid\n      * objects.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the sorted bag to predicate, must not be null\n      * @param predicate the predicate for the bag, must not be null\n      * Existing entries in the specified bag will not be transformed.\n      * If you want that behaviour, see\n      * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n-     * \n+     *\n      * @param <E> the element type\n      * @param bag the bag to predicate, must not be null\n      * @param transformer the transformer for the bag, must not be null\n      */\n     @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n     public static <E> Bag<E> emptyBag() {\n-        return (Bag<E>) EMPTY_BAG;        \n+        return (Bag<E>) EMPTY_BAG;\n     }\n \n     /**\n      */\n     @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n     public static <E> SortedBag<E> emptySortedBag() {\n-        return (SortedBag<E>) EMPTY_SORTED_BAG;        \n+        return (SortedBag<E>) EMPTY_SORTED_BAG;\n     }\n }\n--- a/src/main/java/org/apache/commons/collections4/BidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/BidiMap.java\n  * a key to be looked up from a value with equal performance.\n  * <p>\n  * This map enforces the restriction that there is a 1:1 relation between\n- * keys and values, meaning that multiple keys cannot map to the same value. \n- * This is required so that \"inverting\" the map results in a map without \n+ * keys and values, meaning that multiple keys cannot map to the same value.\n+ * This is required so that \"inverting\" the map results in a map without\n  * duplicate keys. See the {@link #put} method description for more information.\n  *\n  * @param <K> the type of the keys in the map\n      *  BidiMap map1 = new DualHashBidiMap();\n      *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n      *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n-     * \n+     *\n      *  BidiMap map2 = new DualHashBidiMap();\n      *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n      *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n      * @param key  the key to store\n      * @param value  the value to store\n      * @return the previous value mapped to this key\n-     * \n+     *\n      * @throws UnsupportedOperationException if the <code>put</code> method is not supported\n-     * @throws ClassCastException (optional) if the map limits the type of the \n+     * @throws ClassCastException (optional) if the map limits the type of the\n      *  value and the specified value is inappropriate\n      * @throws IllegalArgumentException (optional) if the map limits the values\n      *  in some way and the value was invalid\n      *\n      * @param value  the value to find the key for\n      * @return the mapped key, or <code>null</code> if not found\n-     * \n-     * @throws ClassCastException (optional) if the map limits the type of the \n+     *\n+     * @throws ClassCastException (optional) if the map limits the type of the\n      *  value and the specified value is inappropriate\n      * @throws NullPointerException (optional) if the map limits the values to\n      *  non-null and null was specified\n      *\n      * @param value  the value to find the key-value pair for\n      * @return the key that was removed, <code>null</code> if nothing removed\n-     * \n-     * @throws ClassCastException (optional) if the map limits the type of the \n+     *\n+     * @throws ClassCastException (optional) if the map limits the type of the\n      *  value and the specified value is inappropriate\n      * @throws NullPointerException (optional) if the map limits the values to\n      *  non-null and null was specified\n--- a/src/main/java/org/apache/commons/collections4/BoundedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/BoundedCollection.java\n /**\n  * Defines a collection that is bounded in size.\n  * <p>\n- * The size of the collection can vary, but it can never exceed a preset \n+ * The size of the collection can vary, but it can never exceed a preset\n  * maximum number of elements. This interface allows the querying of details\n  * associated with the maximum number of elements.\n  *\n--- a/src/main/java/org/apache/commons/collections4/BoundedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/BoundedMap.java\n /**\n  * Defines a map that is bounded in size.\n  * <p>\n- * The size of the map can vary, but it can never exceed a preset \n+ * The size of the map can vary, but it can never exceed a preset\n  * maximum number of elements. This interface allows the querying of details\n  * associated with the maximum number of elements.\n  *\n--- a/src/main/java/org/apache/commons/collections4/ComparatorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ComparatorUtils.java\n  * Provides convenient static utility methods for <Code>Comparator</Code>\n  * objects.\n  * <p>\n- * Most of the functionality in this class can also be found in the \n- * <code>comparators</code> package. This class merely provides a \n+ * Most of the functionality in this class can also be found in the\n+ * <code>comparators</code> package. This class merely provides a\n  * convenient central place if you have use for more than one class\n  * in the <code>comparators</code> subpackage.\n  *\n \n     /**\n      * Gets a comparator that compares using a collection of {@link Comparator}s,\n-     * applied in (default iterator) sequence until one returns not equal or the \n+     * applied in (default iterator) sequence until one returns not equal or the\n      * collection is exhausted.\n      *\n      * @param <E>  the object type to compare\n     @SuppressWarnings(\"unchecked\")\n     public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(\n             final Collection<Comparator<E>> comparators) {\n-        \n+\n         return chainedComparator(\n             (Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()])\n         );\n      * The parameter specifies whether true or false is sorted first.\n      * <p>\n      * The comparator throws NullPointerException if a null value is compared.\n-     * \n-     * @param trueFirst  when <code>true</code>, sort \n+     *\n+     * @param trueFirst  when <code>true</code>, sort\n      *        <code>true</code> {@link Boolean}s before\n      *        <code>false</code> {@link Boolean}s.\n      * @return  a comparator that sorts booleans\n     public static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n         return BooleanComparator.booleanComparator(trueFirst);\n     }\n-    \n+\n     /**\n      * Gets a Comparator that controls the comparison of <code>null</code> values.\n      * <p>\n     }\n \n     /**\n-     * Returns the smaller of the given objects according to the given \n+     * Returns the smaller of the given objects according to the given\n      * comparator, returning the second object if the comparator\n      * returns equal.\n      *\n     }\n \n     /**\n-     * Returns the larger of the given objects according to the given \n-     * comparator, returning the second object if the comparator \n+     * Returns the larger of the given objects according to the given\n+     * comparator, returning the second object if the comparator\n      * returns equal.\n      *\n      * @param <E>  the object type to compare\n         final int c = comparator.compare(o1, o2);\n         return c > 0 ? o1 : o2;\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/collections4/EnumerationUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/EnumerationUtils.java\n      * EnumerationUtils is not normally instantiated.\n      */\n     private EnumerationUtils() {}\n-    \n+\n     /**\n      * Creates a list based on an enumeration.\n-     * \n+     *\n      * <p>As the enumeration is traversed, an ArrayList of its values is\n      * created. The new list is returned.</p>\n      *\n--- a/src/main/java/org/apache/commons/collections4/FactoryUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/FactoryUtils.java\n      * This could be useful during testing as a placeholder.\n      *\n      * @see org.apache.commons.collections4.functors.ExceptionFactory\n-     * \n+     *\n      * @param <T> the type that the factory creates\n      * @return the factory\n      */\n      * use the prototype factory.\n      *\n      * @see org.apache.commons.collections4.functors.ConstantFactory\n-     * \n+     *\n      * @param <T> the type that the factory creates\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      * <ul>\n      *\n      * @see org.apache.commons.collections4.functors.PrototypeFactory\n-     * \n+     *\n      * @param <T> the type that the factory creates\n      * @param prototype  the object to clone each time in the factory\n      * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n      * a no-args constructor.\n      *\n      * @see org.apache.commons.collections4.functors.InstantiateFactory\n-     * \n+     *\n      * @param <T> the type that the factory creates\n      * @param classToInstantiate  the Class to instantiate each time in the factory\n      * @return the <code>reflection</code> factory\n      * the arguments specified to this method.\n      *\n      * @see org.apache.commons.collections4.functors.InstantiateFactory\n-     * \n+     *\n      * @param <T> the type that the factory creates\n      * @param classToInstantiate  the Class to instantiate each time in the factory\n      * @param paramTypes  parameter types for the constructor, can be null\n--- a/src/main/java/org/apache/commons/collections4/FunctorException.java\n+++ b/src/main/java/org/apache/commons/collections4/FunctorException.java\n  * @version $Id$\n  */\n public class FunctorException extends RuntimeException {\n-    \n+\n     /** Serialization version */\n     private static final long serialVersionUID = -4704772662059351193L;\n \n--- a/src/main/java/org/apache/commons/collections4/Get.java\n+++ b/src/main/java/org/apache/commons/collections4/Get.java\n \n /**\n  * The \"read\" subset of the {@link java.util.Map} interface.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  *\n--- a/src/main/java/org/apache/commons/collections4/IterableGet.java\n+++ b/src/main/java/org/apache/commons/collections4/IterableGet.java\n      *   it.setValue(value + 1);\n      * }\n      * </pre>\n-     * \n+     *\n      * @return a map iterator\n      */\n     MapIterator<K, V> mapIterator();\n--- a/src/main/java/org/apache/commons/collections4/KeyValue.java\n+++ b/src/main/java/org/apache/commons/collections4/KeyValue.java\n     /**\n      * Gets the key from the pair.\n      *\n-     * @return the key \n+     * @return the key\n      */\n     K getKey();\n \n--- a/src/main/java/org/apache/commons/collections4/MultiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiMap.java\n \n import java.util.Collection;\n \n-/** \n+/**\n  * Defines a map that holds a collection of values against each key.\n  * <p>\n  * A <code>MultiMap</code> is a Map with slightly different semantics.\n      * If the last value for a key is removed, implementations typically\n      * return <code>null</code> from a subsequent <code>get(Object)</code>, however\n      * they may choose to return an empty collection.\n-     * \n+     *\n      * @param key  the key to remove from\n      * @param item  the item to remove\n      * @return the value removed (which was passed in), null if nothing removed\n--- a/src/main/java/org/apache/commons/collections4/OrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/OrderedMap.java\n      * <p>\n      * A ordered map iterator is an efficient way of iterating over maps\n      * in both directions.\n-     * \n+     *\n      * @return a map iterator\n      */\n     OrderedMapIterator<K, V> mapIterator();\n--- a/src/main/java/org/apache/commons/collections4/Put.java\n+++ b/src/main/java/org/apache/commons/collections4/Put.java\n \n /**\n  * The \"write\" subset of the {@link Map} interface.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n- * \n+ *\n  * @see Get\n  */\n public interface Put<K, V> {\n--- a/src/main/java/org/apache/commons/collections4/QueueUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/QueueUtils.java\n      * Returns a transformed queue backed by the given queue.\n      * <p>\n      * Each object is passed through the transformer as it is added to the\n-     * Queue. It is important not to use the original queue after invoking this \n+     * Queue. It is important not to use the original queue after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified queue will not be transformed.\n--- a/src/main/java/org/apache/commons/collections4/ResettableIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/ResettableIterator.java\n \n import java.util.Iterator;\n \n-/** \n+/**\n  * Defines an iterator that can be reset back to an initial state.\n  * <p>\n  * This interface allows an iterator to be repeatedly reused.\n--- a/src/main/java/org/apache/commons/collections4/ResettableListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/ResettableListIterator.java\n \n import java.util.ListIterator;\n \n-/** \n+/**\n  * Defines a list iterator that can be reset back to an initial state.\n  * <p>\n  * This interface allows an iterator to be repeatedly reused.\n--- a/src/main/java/org/apache/commons/collections4/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n     private SetUtils() {}\n \n     //-----------------------------------------------------------------------\n-    \n+\n     /**\n      * Returns an immutable empty set if the argument is <code>null</code>,\n      * or the argument itself otherwise.\n-     * \n+     *\n      * @param <T> the element type\n      * @param set the set, possibly <code>null</code>\n      * @return an empty set if the argument is <code>null</code>\n     public static <T> Set<T> emptyIfNull(final Set<T> set) {\n         return set == null ? Collections.<T>emptySet() : set;\n     }\n-    \n+\n     /**\n      * Tests two sets for equality as per the <code>equals()</code> contract\n      * in {@link java.util.Set#equals(java.lang.Object)}.\n      * the second. This ensures that the <tt>equals</tt> method works\n      * properly across different implementations of the <tt>Set</tt>\n      * interface.</p>\n-     * \n-     * <p>\n-     * This implementation first checks if the two sets are the same object: \n+     *\n+     * <p>\n+     * This implementation first checks if the two sets are the same object:\n      * if so it returns <tt>true</tt>.  Then, it checks if the two sets are\n      * identical in size; if not, it returns false. If so, it returns\n      * <tt>a.containsAll((Collection) b)</tt>.</p>\n      * </blockquote>\n-     * \n+     *\n      * @see java.util.Set\n      * @param set1  the first set, may be null\n      * @param set2  the second set, may be null\n     }\n \n     /**\n-     * Generates a hash code using the algorithm specified in \n+     * Generates a hash code using the algorithm specified in\n      * {@link java.util.Set#hashCode()}.\n      * <p>\n      * This method is useful for implementing <code>Set</code> when you cannot\n      * extend AbstractSet. The method takes Collection instances to enable other\n      * collection types to use the Set implementation algorithm.\n-     * \n+     *\n      * @param <T> the element type\n      * @see java.util.Set#hashCode()\n      * @param set  the set to calculate the hash code for, may be null\n         }\n         return hashCode;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a synchronized set backed by the given set.\n      * <p>\n-     * You must manually synchronize on the returned set's iterator to \n+     * You must manually synchronize on the returned set's iterator to\n      * avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * Set s = SetUtils.synchronizedSet(mySet);\n      * synchronized (s) {\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n-     * \n+     *\n      * @param <E> the element type\n      * @param set  the set to synchronize, must not be null\n      * @return a synchronized set backed by the given set\n      * Returns a transformed set backed by the given set.\n      * <p>\n      * Each object is passed through the transformer as it is added to the\n-     * Set. It is important not to use the original set after invoking this \n+     * Set. It is important not to use the original set after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified set will not be transformed.\n     public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedSet.transformingSet(set, transformer);\n     }\n-    \n+\n     /**\n      * Returns a set that maintains the order of elements that are added\n      * backed by the given set.\n     public static <E> Set<E> orderedSet(final Set<E> set) {\n         return ListOrderedSet.listOrderedSet(set);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a synchronized sorted set backed by the given sorted set.\n      * <p>\n-     * You must manually synchronize on the returned set's iterator to \n+     * You must manually synchronize on the returned set's iterator to\n      * avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * Set s = SetUtils.synchronizedSet(mySet);\n      * synchronized (s) {\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n-     * \n+     *\n      * @param <E> the element type\n      * @param set  the sorted set to synchronize, must not be null\n      * @return a synchronized set backed by the given set\n     }\n \n     /**\n-     * Returns a predicated (validating) sorted set backed by the given sorted set.  \n+     * Returns a predicated (validating) sorted set backed by the given sorted set.\n      * <p>\n      * Only objects that pass the test in the given predicate can be added to the set.\n      * Trying to add an invalid object results in an IllegalArgumentException.\n      * Returns a transformed sorted set backed by the given set.\n      * <p>\n      * Each object is passed through the transformer as it is added to the\n-     * Set. It is important not to use the original set after invoking this \n+     * Set. It is important not to use the original set after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified set will not be transformed.\n                                                         final Transformer<? super E, ? extends E> transformer) {\n         return TransformedSortedSet.transformingSortedSet(set, transformer);\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/collections4/SortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/SortedBag.java\n     /**\n      * Returns the comparator associated with this sorted set, or null\n      * if it uses its elements' natural ordering.\n-     * \n+     *\n      * @return the comparator in use, or null if natural ordering\n      */\n     public Comparator<? super E> comparator();\n \n     /**\n      * Returns the first (lowest) member.\n-     * \n+     *\n      * @return the first element in the sorted bag\n      */\n     public E first();\n \n     /**\n      * Returns the last (highest) member.\n-     * \n+     *\n      * @return the last element in the sorted bag\n      */\n     public E last();\n--- a/src/main/java/org/apache/commons/collections4/SortedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/SortedBidiMap.java\n  * <p>\n  * Implementations should allow a value to be looked up from a key and\n  * a key to be looked up from a value with equal performance.\n- *  \n+ *\n  * @param <K> the type of the keys in the map\n  * @param <V> the type of the values in the map\n  * @since 3.0\n--- a/src/main/java/org/apache/commons/collections4/TransformerUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/TransformerUtils.java\n import org.apache.commons.collections4.functors.SwitchTransformer;\n \n /**\n- * <code>TransformerUtils</code> provides reference implementations and \n+ * <code>TransformerUtils</code> provides reference implementations and\n  * utilities for the Transformer functor interface. The supplied transformers are:\n  * <ul>\n  * <li>Invoker - returns the result of a method call on the input object\n     /**\n      * Gets a transformer that always throws an exception.\n      * This could be useful during testing as a placeholder.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @return the transformer\n \n     /**\n      * Gets a transformer that always returns null.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @return the transformer\n      * Gets a transformer that returns the input object.\n      * The input object should be immutable to maintain the\n      * contract of Transformer (although this is not checked).\n-     * \n+     *\n      * @param <T>  the input/output type\n      * @return the transformer\n      * @see org.apache.commons.collections4.functors.NOPTransformer\n      * <li>public copy constructor\n      * <li>serialization clone\n      * <ul>\n-     * \n+     *\n      * @param <T>  the input/output type\n      * @return the transformer\n      * @see org.apache.commons.collections4.functors.CloneTransformer\n     }\n \n     /**\n-     * Creates a Transformer that will return the same object each time the \n+     * Creates a Transformer that will return the same object each time the\n      * transformer is used.\n      *\n      * @param <I>  the input type\n     /**\n      * Create a new Transformer that calls two transformers, passing the result of\n      * the first into the second.\n-     * \n+     *\n      * @param <T>  the input/output type\n      * @param transformer1  the first transformer\n      * @param transformer2  the second transformer\n     }\n \n     /**\n-     * Create a new Transformer that calls each transformer in turn, passing the \n+     * Create a new Transformer that calls each transformer in turn, passing the\n      * result into the next transformer.\n-     * \n+     *\n      * @param <T>  the input/output type\n      * @param transformers  an array of transformers to chain\n      * @return the transformer\n     }\n \n     /**\n-     * Create a new Transformer that calls each transformer in turn, passing the \n+     * Create a new Transformer that calls each transformer in turn, passing the\n      * result into the next transformer. The ordering is that of the iterator()\n      * method on the collection.\n-     * \n+     *\n      * @param <T>  the input/output type\n      * @param transformers  a collection of transformers to chain\n      * @return the transformer\n     }\n \n     /**\n-     * Create a new Transformer that calls one of two transformers depending \n+     * Create a new Transformer that calls one of two transformers depending\n      * on the specified predicate.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param predicate  the predicate to switch on\n     }\n \n     /**\n-     * Create a new Transformer that calls one of the transformers depending \n+     * Create a new Transformer that calls one of the transformers depending\n      * on the predicates. The transformer at array location 0 is called if the\n      * predicate at array location 0 returned true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, null is returned.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param predicates  an array of predicates to check\n     }\n \n     /**\n-     * Create a new Transformer that calls one of the transformers depending \n+     * Create a new Transformer that calls one of the transformers depending\n      * on the predicates. The transformer at array location 0 is called if the\n      * predicate at array location 0 returned true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n      * transformer is called. If the default transformer is null, null is returned.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param predicates  an array of predicates to check\n     }\n \n     /**\n-     * Create a new Transformer that calls one of the transformers depending \n-     * on the predicates. \n+     * Create a new Transformer that calls one of the transformers depending\n+     * on the predicates.\n      * <p>\n-     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * The Map consists of Predicate keys and Transformer values. A transformer\n      * is called if its matching predicate returns true. Each predicate is evaluated\n      * until one returns true. If no predicates evaluate to true, the default\n-     * transformer is called. The default transformer is set in the map with a \n+     * transformer is called. The default transformer is set in the map with a\n      * null key. If no default transformer is set, null will be returned in a default\n-     * case. The ordering is that of the iterator() method on the entryset collection \n+     * case. The ordering is that of the iterator() method on the entryset collection\n      * of the map.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param predicatesAndTransformers  a map of predicates to transformers\n \n     /**\n      * Create a new Transformer that uses the input object as a key to find the\n-     * transformer to call. \n+     * transformer to call.\n      * <p>\n-     * The Map consists of object keys and Transformer values. A transformer \n+     * The Map consists of object keys and Transformer values. A transformer\n      * is called if the input object equals the key. If there is no match, the\n      * default transformer is called. The default transformer is set in the map\n      * using a null key. If no default is set, null will be returned in a default case.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param objectsAndTransformers  a map of objects to transformers\n \n     /**\n      * Gets a Transformer that expects an input Class object that it will instantiate.\n-     * \n+     *\n      * @param <T>  the output type\n      * @return the transformer\n      * @see org.apache.commons.collections4.functors.InstantiateTransformer\n         return InstantiateTransformer.<T>instantiateTransformer();\n     }\n \n-    /** \n-     * Creates a Transformer that expects an input Class object that it will \n+    /**\n+     * Creates a Transformer that expects an input Class object that it will\n      * instantiate. The constructor used is determined by the arguments specified\n      * to this method.\n      *\n         return InstantiateTransformer.<T>instantiateTransformer(paramTypes, args);\n     }\n \n-    /** \n-     * Creates a Transformer that uses the passed in Map to transform the input \n+    /**\n+     * Creates a Transformer that uses the passed in Map to transform the input\n      * object (as a simple lookup).\n      *\n      * @param <I>  the input type\n \n     /**\n      * Gets a Transformer that invokes a method on the input object.\n-     * The method must have no parameters. If the input object is null, \n+     * The method must have no parameters. If the input object is null,\n      * null is returned.\n      * <p>\n      * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n-     * will call the <code>getName/code> method on the input object to \n+     * will call the <code>getName/code> method on the input object to\n      * determine the transformer result.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param methodName  the method name to call on the input object, may not be null\n \n     /**\n      * Gets a Transformer that invokes a method on the input object.\n-     * The method parameters are specified. If the input object is {@code null}, \n+     * The method parameters are specified. If the input object is {@code null},\n      * {@code null} is returned.\n-     * \n+     *\n      * @param <I>  the input type\n      * @param <O>  the output type\n      * @param methodName  the name of the method\n      * Gets a transformer that returns a <code>java.lang.String</code>\n      * representation of the input object. This is achieved via the\n      * <code>toString</code> method, <code>null</code> returns 'null'.\n-     * \n+     *\n      * @param <T>  the input type\n      * @return the transformer\n      * @see org.apache.commons.collections4.functors.StringValueTransformer\n     public static <T> Transformer<T, String> stringValueTransformer() {\n         return StringValueTransformer.<T>stringValueTransformer();\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/collections4/Trie.java\n+++ b/src/main/java/org/apache/commons/collections4/Trie.java\n import java.util.Map.Entry;\n \n /**\n- * Defines the interface for a prefix tree, an ordered tree data structure. For \n+ * Defines the interface for a prefix tree, an ordered tree data structure. For\n  * more information, see <a href=\"http://en.wikipedia.org/wiki/Trie\">Tries</a>.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public interface Trie<K, V> extends SortedMap<K, V> {\n \n     /**\n-     * Returns the {@link Entry} whose key is closest in a bitwise XOR \n+     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n      * metric to the given key. This is NOT lexicographic closeness.\n      * For example, given the keys:\n      *\n      * <li>H = 1001000\n      * <li>L = 1001100\n      * </ol>\n-     * \n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n-     * return 'L', because the XOR distance between D &amp; L is smaller \n-     * than the XOR distance between D &amp; H. \n-     * \n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n      * @param key  the key to use in the search\n      * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n      *   to the provided key\n      */\n     public Map.Entry<K, V> select(K key);\n-    \n-    /**\n-     * Returns the key that is closest in a bitwise XOR metric to the \n+\n+    /**\n+     * Returns the key that is closest in a bitwise XOR metric to the\n      * provided key. This is NOT lexicographic closeness!\n-     * \n+     *\n      * For example, given the keys:\n-     * \n+     *\n      * <ol>\n      * <li>D = 1000100\n      * <li>H = 1001000\n      * <li>L = 1001100\n      * </ol>\n-     * \n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n-     * return 'L', because the XOR distance between D &amp; L is smaller \n-     * than the XOR distance between D &amp; H. \n-     * \n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n      * @param key  the key to use in the search\n      * @return the key that is closest in a bitwise XOR metric to the provided key\n      */\n     public K selectKey(K key);\n-    \n-    /**\n-     * Returns the value whose key is closest in a bitwise XOR metric to \n+\n+    /**\n+     * Returns the value whose key is closest in a bitwise XOR metric to\n      * the provided key. This is NOT lexicographic closeness!\n-     * \n+     *\n      * For example, given the keys:\n-     * \n+     *\n      * <ol>\n      * <li>D = 1000100\n      * <li>H = 1001000\n      * <li>L = 1001100\n      * </ol>\n-     * \n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n-     * return 'L', because the XOR distance between D &amp; L is smaller \n-     * than the XOR distance between D &amp; H. \n-     * \n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n      * @param key  the key to use in the search\n      * @return the value whose key is closest in a bitwise XOR metric\n      * to the provided key\n      */\n     public V selectValue(K key);\n-    \n+\n     /**\n      * Iterates through the {@link Trie}, starting with the entry whose bitwise\n      * value is closest in an XOR metric to the given key. After the closest\n      * and stop traversing.\n      * <p>\n      * Note: The {@link Cursor.Decision#REMOVE} operation is not supported.\n-     * \n+     *\n      * @param key  the key to use in the search\n      * @param cursor  the cursor used throughout the search\n-     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null \n+     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null\n      * if it continued till the end\n      */\n     public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n-    \n-    /**\n-     * Traverses the {@link Trie} in lexicographical order. \n+\n+    /**\n+     * Traverses the {@link Trie} in lexicographical order.\n      * {@link Cursor#select(java.util.Map.Entry)} will be called on each entry.\n      * <p>\n-     * The traversal will stop when the cursor returns {@link Cursor.Decision#EXIT}, \n-     * {@link Cursor.Decision#CONTINUE} is used to continue traversing and \n-     * {@link Cursor.Decision#REMOVE} is used to remove the element that was selected \n+     * The traversal will stop when the cursor returns {@link Cursor.Decision#EXIT},\n+     * {@link Cursor.Decision#CONTINUE} is used to continue traversing and\n+     * {@link Cursor.Decision#REMOVE} is used to remove the element that was selected\n      * and continue traversing.\n      * <p>\n      * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n      * and stop traversing.\n-     *   \n+     *\n      * @param cursor  the cursor used while traversing the {@link Trie}\n-     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null \n+     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null\n      * if it continued till the end\n      */\n     public Map.Entry<K,V> traverse(Cursor<? super K, ? super V> cursor);\n-    \n-    /**\n-     * Returns a view of this {@link Trie} of all elements that are prefixed \n+\n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the given key.\n      * <p>\n-     * In a {@link Trie} with fixed size keys, this is essentially a \n+     * In a {@link Trie} with fixed size keys, this is essentially a\n      * {@link #get(Object)} operation.\n      * <p>\n-     * For example, if the {@link Trie} contains 'Anna', 'Anael', \n+     * For example, if the {@link Trie} contains 'Anna', 'Anael',\n      * 'Analu', 'Andreas', 'Andrea', 'Andres', and 'Anatole', then\n      * a lookup of 'And' would return 'Andreas', 'Andrea', and 'Andres'.\n-     * \n+     *\n      * @param key  the key used in the search\n      * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n      *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedBy(K key);\n-    \n-    /**\n-     * Returns a view of this {@link Trie} of all elements that are prefixed \n+\n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the length of the key.\n      * <p>\n-     * {@link Trie}s with fixed size keys will not support this operation \n+     * {@link Trie}s with fixed size keys will not support this operation\n      * (because all keys are the same length).\n      * <p>\n-     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu', \n-     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for 'Andrey' \n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu',\n+     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for 'Andrey'\n      * and a length of 4 would return 'Andreas', 'Andrea', and 'Andres'.\n-     * \n+     *\n      * @param key  the key used in the search\n      * @param length  the length of the prefix\n      * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n      *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedBy(K key, int length);\n-    \n+\n     /**\n      * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the key, starting at the given offset and for the given length.\n      * <p>\n-     * {@link Trie}s with fixed size keys will not support this operation \n+     * {@link Trie}s with fixed size keys will not support this operation\n      * (because all keys are the same length).\n      * <p>\n-     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu', \n-     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for \n-     * 'Hello Andrey Smith', an offset of 6 and a length of 4 would return \n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu',\n+     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for\n+     * 'Hello Andrey Smith', an offset of 6 and a length of 4 would return\n      * 'Andreas', 'Andrea', and 'Andres'.\n-     * \n+     *\n      * @param key  the key used in the search\n      * @param offset  the prefix start\n      * @param length  the length of the prefix\n      *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedBy(K key, int offset, int length);\n-    \n+\n     /**\n      * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the number of bits in the given Key.\n      * <p>\n      * In {@link Trie}s with fixed size keys like IP addresses this method\n      * can be used to lookup partial keys. That is you can lookup all addresses\n-     * that begin with '192.168' by providing the key '192.168.X.X' and a \n+     * that begin with '192.168' by providing the key '192.168.X.X' and a\n      * length of 16.\n-     * \n+     *\n      * @param key  the key to use in the search\n      * @param lengthInBits  the number of significant key bits\n      * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n      *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits);\n-    \n+\n     /**\n      * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the number of bits in the given Key.\n-     * \n+     *\n      * @param key  the key to use in the search\n      * @param offsetInBits  the prefix offset\n      * @param lengthInBits  the number of significant prefix bits\n      *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits);\n-    \n-    /**\n-     * A {@link Trie.Cursor} can be used to traverse a {@link Trie}, visit each node \n-     * step by step and make {@link Decision}s on each step how to continue with \n+\n+    /**\n+     * A {@link Trie.Cursor} can be used to traverse a {@link Trie}, visit each node\n+     * step by step and make {@link Decision}s on each step how to continue with\n      * traversing the {@link Trie}.\n      */\n     public interface Cursor<K, V> {\n-        \n+\n         /**\n-         * The {@link Decision} tells the {@link Trie.Cursor} what to do on each step \n+         * The {@link Decision} tells the {@link Trie.Cursor} what to do on each step\n          * while traversing the {@link Trie}.\n-         * \n-         * NOTE: Not all operations that work with a {@link Trie.Cursor} support all \n+         *\n+         * NOTE: Not all operations that work with a {@link Trie.Cursor} support all\n          * {@link Decision} types\n          */\n         public static enum Decision {\n-            \n+\n             /**\n              * Exit the traverse operation\n              */\n-            EXIT, \n-            \n+            EXIT,\n+\n             /**\n              * Continue with the traverse operation\n              */\n-            CONTINUE, \n-            \n+            CONTINUE,\n+\n             /**\n              * Remove the previously returned element\n              * from the {@link Trie} and continue\n              */\n-            REMOVE, \n-            \n+            REMOVE,\n+\n             /**\n              * Remove the previously returned element\n              * from the {@link Trie} and exit from the\n              */\n             REMOVE_AND_EXIT;\n         }\n-        \n+\n         /**\n-         * Called for each {@link Entry} in the {@link Trie}. Return \n+         * Called for each {@link Entry} in the {@link Trie}. Return\n          * {@link Decision#EXIT} to finish the {@link Trie} operation,\n          * {@link Decision#CONTINUE} to go to the next {@link Entry},\n          * {@link Decision#REMOVE} to remove the {@link Entry} and\n          * remove the {@link Entry} and stop iterating.\n          * <p>\n          * Note: Not all operations support {@link Decision#REMOVE}.\n-         * \n+         *\n          * @param entry  the current entry\n          * @return the {@link Decision} based on the current entry\n          */\n--- a/src/main/java/org/apache/commons/collections4/TrieUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/TrieUtils.java\n \n /**\n  * A collection of {@link Trie} utilities.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n      * {@link TrieUtils} should not normally be instantiated.\n      */\n     private TrieUtils() {}\n-    \n+\n     /**\n      * Returns a synchronized instance of a {@link Trie}\n-     * \n+     *\n      * @see java.util.Collections#synchronizedMap(java.util.Map)\n      */\n     public static <K, V> Trie<K, V> synchronizedTrie(final Trie<K, V> trie) {\n         return SynchronizedTrie.synchronizedTrie(trie);\n     }\n-    \n+\n     /**\n      * Returns an unmodifiable instance of a {@link Trie}\n-     * \n+     *\n      * @see java.util.Collections#unmodifiableMap(java.util.Map)\n      */\n     public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, V> trie) {\n--- a/src/main/java/org/apache/commons/collections4/Unmodifiable.java\n+++ b/src/main/java/org/apache/commons/collections4/Unmodifiable.java\n  * Of course all this only works if you use the Unmodifiable classes defined\n  * in this library. If you use the JDK unmodifiable class via {@code java.util Collections}\n  * then the interface won't be there.\n- *  \n+ *\n  * @since 3.0\n  * @version $Id$\n  */", "timestamp": 1367348124, "metainfo": ""}