{"sha": "91e030ff08b6ce7012145591081571bbd19f40c6", "log": "Fixed the following Bag related problems:   - In Bag.java, the statement \"If the bag contains less than i occurences, the item item will be removed from the unique set\" implies that if the bag contains 5 occurences and i is 5, (5 is not less than 5) then the item will not be removed from the unique set, even though there should be no more occurances in the bag.   - In AbstractBag.java, the documentation does not specify exactly what a subcless needs to do to extend AbstractBag to make a concrete subclass.   - AbstractBag.add(Object,int) has two calls to getCount(o), when only one is necessary.  This wastes a few cycles to perform method invocations, a map lookup, a cast, and a few comparisons.   - The AbstractBag.equals(Object) method will incorrectly throw a NullPointerException if a null value is passed.  The Object.equals(Object) API specifies \"For any non-null reference value x, x.equals(null) should return false\".   - The AbstractBag.equals(Object) method will only work if the object passed in extends AbstractMap or implements Map.  Neither of these facts is documented, and neither is correct.  The contract for Object.equals(Object) states: \"for any reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. \". Returning true when the argument is a Map is incorrect since he reverse (the map checking to see if its equal to the bag) will most certainly be false.  The same can be said for AbstractMap.  A subclass of AbstractMap may add extra data to be stored within the Bag that must also be compared for them to be equal.  The reverse comparison (specialized subclass equals basic abstract bap) will fail.  You can read more about this in a three- year old, but still valid java world article: http://www.javaworld.com/javaworld/jw-01-1999/jw-01-object.html   - if AbstractBag.remove(Object,int) is called passing in 0 as the number to remove and specifying an object that exists in the bag, true will be returned from the method. Per the Bag API specification, true should only return when an object is actually removed.  Since no objects are removed, false should be returned instead. Additionally, if a negative number is specified, not only is the object not removed, but object(s) are *added* (well, in the sense that it is equivalent of calling add(o, -i))   - the uniqueSet() method returns the set of unique objects, however the set is modifiable.  If the underlying map implementation has the set backed by the map (as per the map contract -- so it should), then elements can be removed from the unique set and have them removed from the underlying map as well.  This causes consistency problems with the Bag since _total will then be incorrect.   - in extractList(), getCount(current) is called each time through the inner loop, adding lots of extra overhead.  Reversing the loop (starting at the count and going down to 0) eliminates the excess overhead.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/AbstractBag.java\n+++ b/src/java/org/apache/commons/collections/AbstractBag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/AbstractBag.java,v 1.2 2002/02/10 08:07:42 jstrachan Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/02/10 08:07:42 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/AbstractBag.java,v 1.3 2002/02/22 04:39:53 mas Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/22 04:39:53 $\n  *\n  * ====================================================================\n  *\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n import java.util.List;\n /**\n  * This class provides a skeletal implementation of the {@link Bag}\n  * interface to minimize the effort required for target implementations.\n+ * Subclasses need only to call {@link #setMap(Map)} in their constructor \n+ * specifying a map instance that will be used to store the contents of \n+ * the bag. \n  *\n  * @author Chuck Burdick\n+ * @author <a href=\"michael@iammichael.org\">Michael Smith</a>\n  **/\n public abstract class AbstractBag implements Bag {\n    private Map _map = null;\n          int count = (i + getCount(o));\n          _map.put(o, new Integer(count));\n          _total += i;\n-         return (getCount(o) == i);\n+         return (count == i);\n       } else {\n          return false;\n       }\n    }\n \n    public boolean equals(Object o) {\n-      boolean result = false;\n-      if (o instanceof AbstractBag) {\n-         result = _map.equals(((AbstractBag)o).getMap());\n-      } else if (o instanceof Map) {\n-         result = _map.equals((Map)o);\n-      }\n-      return result;\n+      return (o == this || \n+              (o != null && o.getClass().equals(this.getClass()) &&\n+               ((AbstractBag)o)._map.equals(this._map)));\n    }\n \n    public int hashCode() {\n       _mods++;\n       boolean result = false;\n       int count = getCount(o);\n-      if (count > i) {\n+      if (i <= 0) {\n+         result = false;\n+      } else if (count > i) {\n          _map.put(o, new Integer(count - i));\n          result = true;\n          _total -= i;\n-      } else {\n-         result = uniqueSet().remove(o);\n+      } else { // count > 0 && count <= i  \n+         // need to remove all\n+         result = (_map.remove(o) != null);\n          _total -= count;\n       }\n       return result;\n    }\n \n    public Set uniqueSet() {\n-      return _map.keySet();\n+      return Collections.unmodifiableSet(_map.keySet());\n    }\n \n    public int size() {\n       Iterator i = uniqueSet().iterator();\n       while (i.hasNext()) {\n          Object current = i.next();\n-         for (int index = 0; index < getCount(current); index++) {\n+         for (int index = getCount(current); index > 0; index--) {\n             result.add(current);\n          }\n       }\n--- a/src/java/org/apache/commons/collections/Bag.java\n+++ b/src/java/org/apache/commons/collections/Bag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.2 2002/02/10 08:07:42 jstrachan Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/02/10 08:07:42 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.3 2002/02/22 04:39:53 mas Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/22 04:39:53 $\n  *\n  * ====================================================================\n  *\n \n    /**\n     * Remove the given number of occurrences from the bag. If the bag\n-    * contains less than <code>i</code> occurrences, the item will be\n+    * contains <code>i</code> occurrences or less, the item will be\n     * removed from the {@link #uniqueSet}.\n     * @see #getCount\n     * @see #remove(Object)", "timestamp": 1014352793, "metainfo": ""}