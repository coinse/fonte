{"sha": "be74e690e04d42335fc1811e228beff9ef71f831", "log": "Add extra tests for maps Make the tests pass   ", "commit": "\n--- a/src/java/org/apache/commons/collections/AbstractDualBidiMap.java\n+++ b/src/java/org/apache/commons/collections/AbstractDualBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/AbstractDualBidiMap.java,v 1.5 2003/10/31 01:26:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/AbstractDualBidiMap.java,v 1.6 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <code>createMap</code> method.\n  * \n  * @since Commons Collections 3.0\n- * @version $Id: AbstractDualBidiMap.java,v 1.5 2003/10/31 01:26:25 scolebourne Exp $\n+ * @version $Id: AbstractDualBidiMap.java,v 1.6 2003/11/01 18:47:18 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n         }\n         \n         public Object setValue(Object value) {\n+            Object key = MapEntry.this.getKey();\n+            if (map.maps[1].containsKey(value) &&\n+                map.maps[1].get(value) != key) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            map.put(key, value);\n             final Object oldValue = super.setValue(value);\n-\n-            // Gets old key and pairs with new value\n-            final Object inverseKey = map.maps[1].remove(oldValue);\n-            map.maps[1].put(value, inverseKey);\n-\n             return oldValue;\n         }\n     }\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n             }\n-            Object oldValue = last.setValue(value);\n-\n-            // Gets old key and pairs with new value\n-            final Object inverseKey = map.maps[1].remove(oldValue);\n-            map.maps[1].put(value, inverseKey);\n-\n-            return oldValue;\n+            if (map.maps[1].containsKey(value) &&\n+                map.maps[1].get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            return map.put(last.getKey(), value);\n         }\n     }\n     \n--- a/src/java/org/apache/commons/collections/DualTreeBidiMap.java\n+++ b/src/java/org/apache/commons/collections/DualTreeBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/DualTreeBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/DualTreeBidiMap.java,v 1.2 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n package org.apache.commons.collections;\n \n import java.util.Comparator;\n+import java.util.Iterator;\n import java.util.Map;\n import java.util.SortedMap;\n import java.util.TreeMap;\n  * Implementation of <code>BidiMap</code> that uses two <code>TreeMap</code> instances.\n  * \n  * @since Commons Collections 3.0\n- * @version $Id: DualTreeBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * @version $Id: DualTreeBidiMap.java,v 1.2 2003/11/01 18:47:18 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n         final DualTreeBidiMap bidi;\n         \n         protected ViewMap(DualTreeBidiMap bidi, SortedMap sm) {\n+            // the implementation is not great here...\n+            // use the maps[0] as the filtered map, but maps[1] as the full map\n+            // this forces containsValue and clear to be overridden\n             super((SortedMap) bidi.createBidiMap(sm, bidi.maps[1], bidi.inverseBidiMap));\n             this.bidi = (DualTreeBidiMap) map;\n         }\n             return bidi.maps[0].containsValue(value);\n         }\n         \n+        public void clear() {\n+            // override as default implementation jumps to [1]\n+            for (Iterator it = keySet().iterator(); it.hasNext();) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+        \n         public SortedMap headMap(Object toKey) {\n             return new ViewMap(bidi, super.headMap(toKey));\n         }\n--- a/src/test/org/apache/commons/collections/AbstractTestBidiMap.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestBidiMap.java,v 1.3 2003/10/31 01:25:24 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestBidiMap.java,v 1.4 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.NoSuchElementException;\n+import java.util.Set;\n \n /**\n  * Abstract test class for {@link BidiMap} methods and contracts.\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/10/31 01:25:24 $\n+ * @version $Revision: 1.4 $ $Date: 2003/11/01 18:47:18 $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n \n     protected void verifyInverse() {\n         assertEquals(map.size(), ((BidiMap) map).inverseBidiMap().size());\n+        Map map1 = new HashMap(map);\n+        Map map2 = new HashMap(((BidiMap) map).inverseBidiMap());\n+        Set keys1 = map1.keySet();\n+        Set keys2 = map2.keySet();\n+        Collection values1 = map1.values();\n+        Collection values2 = map2.values();\n+        assertEquals(true, keys1.containsAll(values2));\n+        assertEquals(true, values2.containsAll(keys1));\n+        assertEquals(true, values1.containsAll(keys2));\n+        assertEquals(true, keys2.containsAll(values1));\n     }\n     \n     // testGetKey\n             !map.inverseBidiMap().containsKey(value));\n     }\n \n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestBidiMapEntrySet();\n+    }\n+\n+    public class TestBidiMapEntrySet extends TestMapEntrySet {\n+        public TestBidiMapEntrySet() {\n+            super();\n+        }\n+        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n+            Object key1 = getSampleKeys()[0];\n+            Object key2 = getSampleKeys()[1];\n+            Object newValue1 = getNewSampleValues()[0];\n+            Object newValue2 = getNewSampleValues()[1];\n+                \n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator it = TestBidiMapEntrySet.this.collection.iterator();\n+            Map.Entry entry1 = getEntry(it, key1);\n+            it = TestBidiMapEntrySet.this.collection.iterator();\n+            Map.Entry entry2 = getEntry(it, key2);\n+            Iterator itConfirmed = TestBidiMapEntrySet.this.confirmed.iterator();\n+            Map.Entry entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestBidiMapEntrySet.this.confirmed.iterator();\n+            Map.Entry entryConfirmed2 = getEntry(itConfirmed, key2);\n+            TestBidiMapEntrySet.this.verify();\n+                \n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            // these checked in superclass                \n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+            \n+            // at this point\n+            // key1=newValue1, key2=newValue2\n+            try {\n+                entry2.setValue(newValue1);  // should remove key1\n+            } catch (IllegalArgumentException ex) {\n+                return;  // simplest way of dealing with tricky situation\n+            }\n+            entryConfirmed2.setValue(newValue1);\n+            AbstractTestBidiMap.this.confirmed.remove(key1);\n+            assertEquals(newValue1, entry2.getValue());\n+            assertEquals(true, AbstractTestBidiMap.this.map.containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractTestBidiMap.this.map.containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestBidiMap.this.map.get(entry2.getKey()));\n+            assertEquals(false, AbstractTestBidiMap.this.map.containsKey(key1));\n+            assertEquals(false, AbstractTestBidiMap.this.map.containsValue(newValue2));\n+            TestBidiMapEntrySet.this.verify();\n+            \n+            // check for ConcurrentModification\n+            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+            if (isRemoveSupported()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+        \n     public BulkTest bulkTestInverseMap() {\n         return new TestInverseBidiMap(this);\n     }\n         }\n         protected boolean isPutChangeSupported() {\n             return main.isPutChangeSupported();\n+        }\n+        protected boolean isSetValueSupported() {\n+            return main.isSetValueSupported();\n         }\n         protected boolean isRemoveSupported() {\n             return main.isRemoveSupported();\n \n     //-----------------------------------------------------------------------\n     public void testBidiMapIteratorSet() {\n+        Object newValue1 = getOtherValues()[0];\n+        Object newValue2 = getOtherValues()[1];\n+        \n+        resetFull();\n+        BidiMap bidi = (BidiMap) map;\n+        MapIterator it = bidi.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key1 = it.next();\n+        \n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+        \n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+        \n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+        \n+        Object key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, bidi.containsKey(key2));\n+        assertEquals(true, bidi.containsValue(newValue2));\n+        assertEquals(newValue2, bidi.get(key2));\n+        verify();\n+        \n+        // at this point\n+        // key1=newValue1, key2=newValue2\n+        try {\n+            it.setValue(newValue1);  // should remove key1\n+        } catch (IllegalArgumentException ex) {\n+            return;  // simplest way of dealing with tricky situation\n+        }\n+        confirmed.put(key2, newValue1);\n+        AbstractTestBidiMap.this.confirmed.remove(key1);\n+        assertEquals(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(it.getKey()));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(it.getKey()));\n+        assertEquals(false, bidi.containsKey(key1));\n+        assertEquals(false, bidi.containsValue(newValue2));\n+        verify();\n+            \n+        // check for ConcurrentModification\n+        it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+        if (isRemoveSupported()) {\n+            it.remove();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiMapIteratorSetRemoveSet() {\n+        if (isSetValueSupported() == false || isRemoveSupported() == false) {\n+            return;\n+        }\n+        Object newValue1 = getOtherValues()[0];\n+        \n         resetFull();\n         BidiMap bidi = (BidiMap) map;\n         MapIterator it = bidi.mapIterator();\n         assertEquals(true, it.hasNext());\n         Object key = it.next();\n         \n-        if (isPutChangeSupported() == false) {\n-            try {\n-                it.setValue(getOtherValues()[0]);\n-            } catch (UnsupportedOperationException ex) {\n-            }\n-            return;\n-        }\n-        \n-        it.setValue(getOtherValues()[0]);\n-        confirmed.put(key, getOtherValues()[0]);\n-        assertEquals(getOtherValues()[0], bidi.get(key));\n+        it.setValue(newValue1);\n+        confirmed.put(key, newValue1);\n         verify();\n         \n         it.remove();\n         confirmed.remove(key);\n-        try {\n-            it.setValue(getOtherValues()[0]);\n+        verify();\n+        \n+        try {\n+            it.setValue(newValue1);\n         } catch (IllegalStateException ex) {\n         }\n         verify();\n--- a/src/test/org/apache/commons/collections/AbstractTestMap.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestMap.java,v 1.9 2003/10/31 01:24:32 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestMap.java,v 1.10 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <ul>\n  * <li> {@link #isPutAddSupported()}\n  * <li> {@link #isPutChangeSupported()}\n+ * <li> {@link #isSetValueSupported()}\n  * <li> {@link #isRemoveSupported()}\n  * <li> {@link #isAllowDuplicateValues()}\n  * <li> {@link #isAllowNullKey()}\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  * @author Stephen Colebourne\n- * @version $Revision: 1.9 $ $Date: 2003/10/31 01:24:32 $\n+ * @version $Revision: 1.10 $ $Date: 2003/11/01 18:47:18 $\n  */\n public abstract class AbstractTestMap extends AbstractTestObject {\n \n      */\n     protected boolean isPutChangeSupported() {\n         return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by \n+     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * support the <code>setValue</code> operation on entrySet entries.\n+     * <p>\n+     * Default implementation returns isPutChangeSupported().\n+     * Override if your collection class does not support setValue but does\n+     * support put changing.\n+     */\n+    protected boolean isSetValueSupported() {\n+        return isPutChangeSupported();\n     }\n \n     /**\n                 }\n             } else {\n                 try {\n+                    // two possible exception here, either valid\n                     map.put(keys[0], newValues[0]);\n-                    fail(\"Expected UnsupportedOperationException on put (change)\");\n+                    fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n+                } catch (IllegalArgumentException ex) {\n                 } catch (UnsupportedOperationException ex) {}\n             }\n             \n         return new TestMapEntrySet();\n     }\n \n-    class TestMapEntrySet extends AbstractTestSet {\n+    public class TestMapEntrySet extends AbstractTestSet {\n         public TestMapEntrySet() {\n-            super(\"\");\n+            super(\"MapEntrySet\");\n         }\n \n         // Have to implement manually; entrySet doesn't support addAll\n             TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();\n         }\n         \n+        public void testMapEntrySetIteratorEntry() {\n+            resetFull();\n+            Iterator it = collection.iterator();\n+            int count = 0;\n+            while (it.hasNext()) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                assertEquals(true, AbstractTestMap.this.map.containsKey(entry.getKey()));\n+                assertEquals(true, AbstractTestMap.this.map.containsValue(entry.getValue()));\n+                assertEquals(AbstractTestMap.this.map.get(entry.getKey()), entry.getValue());\n+                count++;\n+            }\n+            assertEquals(collection.size(), count);\n+        }\n+\n+        public void testMapEntrySetIteratorEntrySetValue() {\n+            Object key1 = getSampleKeys()[0];\n+            Object key2 = getSampleKeys()[1];\n+            Object newValue1 = getNewSampleValues()[0];\n+            Object newValue2 = getNewSampleValues()[1];\n+            \n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator it = TestMapEntrySet.this.collection.iterator();\n+            Map.Entry entry1 = getEntry(it, key1);\n+            it = TestMapEntrySet.this.collection.iterator();\n+            Map.Entry entry2 = getEntry(it, key2);\n+            Iterator itConfirmed = TestMapEntrySet.this.confirmed.iterator();\n+            Map.Entry entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestMapEntrySet.this.confirmed.iterator();\n+            Map.Entry entryConfirmed2 = getEntry(itConfirmed, key2);\n+            verify();\n+            \n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+            \n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractTestMap.this.map.containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestMap.this.map.get(entry1.getKey()));\n+            verify();\n+            \n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractTestMap.this.map.containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestMap.this.map.get(entry1.getKey()));\n+            verify();\n+            \n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+            assertEquals(newValue2, entry2.getValue());\n+            assertEquals(true, AbstractTestMap.this.map.containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue2));\n+            assertEquals(newValue2, AbstractTestMap.this.map.get(entry2.getKey()));\n+            verify();\n+        }\n+        \n+        protected Map.Entry getEntry(Iterator itConfirmed, Object key) {\n+            Map.Entry entry = null;\n+            while (itConfirmed.hasNext()) {\n+                Map.Entry temp = (Map.Entry) itConfirmed.next();\n+                if (temp.getKey() == null) {\n+                    if (key == null) {\n+                        entry = temp;\n+                        break;\n+                    }\n+                } else if (temp.getKey().equals(key)) {\n+                    entry = temp;\n+                    break;\n+                }\n+            }\n+            assertNotNull(\"No matching entry in map for key '\" + key + \"'\", entry);\n+            return entry;\n+        }\n+\n         protected void verify() {\n             super.verify();\n             AbstractTestMap.this.verify();\n         return new TestMapKeySet();\n     }\n \n-    class TestMapKeySet extends AbstractTestSet {\n+    public class TestMapKeySet extends AbstractTestSet {\n         public TestMapKeySet() {\n             super(\"\");\n         }\n         return new TestMapValues();\n     }\n \n-    class TestMapValues extends AbstractTestCollection {\n+    public class TestMapValues extends AbstractTestCollection {\n         public TestMapValues() {\n             super(\"\");\n         }\n                      size, values.size());\n         assertEquals(\"values should be empty if HashMap is\", \n                      empty, values.isEmpty());\n-        assertTrue(\"values should contain all HashMap's elements\",\n-                   values.containsAll(confirmed.values()));\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                    test.containsAll(known));\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                   known.containsAll(test));\n         // originally coded to use a HashBag, but now separate jar so...\n         for (Iterator it = known.iterator(); it.hasNext();) {\n             boolean removed = test.remove(it.next());\n--- a/src/test/org/apache/commons/collections/AbstractTestSortedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestSortedBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestSortedBidiMap.java,v 1.1 2003/10/31 01:26:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestSortedBidiMap.java,v 1.2 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Abstract test class for {@link BidiMap} methods and contracts.\n  * \n- * @version $Revision: 1.1 $ $Date: 2003/10/31 01:26:25 $\n+ * @version $Revision: 1.2 $ $Date: 2003/11/01 18:47:18 $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n     }\n     \n     //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n     public void testBidiHeadMapContains() {\n         // extra test as other tests get complex\n         SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n     }\n                 \n     //-----------------------------------------------------------------------\n-    public void testBidiRemoveByHeadMap() {\n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        SortedMap head = sm.headMap(toKey);\n-        assertEquals(2, head.size());\n-        assertEquals(true, sm.containsKey(first));\n-        assertEquals(true, head.containsKey(first));\n-        assertEquals(true, sm.containsKey(second));\n-        assertEquals(true, head.containsKey(second));\n-        \n-        Object firstValue = head.remove(first);\n+    public void testBidiClearByHeadMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        Object firstValue = sm.get(first);\n+        Object secondValue = sm.get(second);\n+        Object toKeyValue = sm.get(toKey);\n+        \n+        SortedMap sub = sm.headMap(toKey);\n+        int size = sm.size();\n+        assertEquals(2, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        \n         assertEquals(false, sm.containsKey(first));\n         assertEquals(false, sm.containsValue(firstValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(first));\n-        assertEquals(false, head.containsKey(first));\n-        assertEquals(false, head.containsValue(firstValue));\n-        assertEquals(1, head.size());\n-        \n-        Object secondValue = head.remove(second);\n-        assertEquals(false, sm.containsKey(second));\n-        assertEquals(false, sm.containsValue(secondValue));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n-        assertEquals(false, head.containsKey(second));\n-        assertEquals(false, head.containsValue(secondValue));\n-        assertEquals(0, head.size());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testBidiRemoveByHeadMapEntrySet() {\n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        SortedMap head = sm.headMap(toKey);\n-        Set set = head.entrySet();\n-        Iterator it2 = set.iterator();\n-        Object fromEntry = it2.next();\n-        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n-        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n-        assertEquals(true, sm.containsKey(first));\n-        assertEquals(true, head.containsKey(first));\n-        assertEquals(true, set.contains(firstEntry));\n-        assertEquals(true, sm.containsKey(second));\n-        assertEquals(true, head.containsKey(second));\n-        assertEquals(true, set.contains(secondEntry));\n-        \n-        set.remove(firstEntry);\n-        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n-        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n-        assertEquals(false, head.containsKey(firstEntry.getKey()));\n-        assertEquals(false, head.containsValue(firstEntry.getValue()));\n-        assertEquals(false, set.contains(firstEntry));\n-        \n-        set.remove(secondEntry);\n-        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n-        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n-        assertEquals(false, head.containsKey(secondEntry.getKey()));\n-        assertEquals(false, head.containsValue(secondEntry.getValue()));\n-        assertEquals(false, set.contains(secondEntry));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testBidiRemoveByTailMap() {\n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        \n-        SortedMap tail = sm.tailMap(fromKey);\n-        assertEquals(true, sm.containsKey(first));\n-        assertEquals(true, tail.containsKey(first));\n-        assertEquals(true, sm.containsKey(second));\n-        assertEquals(true, tail.containsKey(second));\n-        \n-        Object firstValue = tail.remove(first);\n-        assertEquals(false, sm.containsKey(first));\n-        assertEquals(false, sm.containsValue(firstValue));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n-        assertEquals(false, tail.containsKey(first));\n-        assertEquals(false, tail.containsValue(firstValue));\n-        \n-        Object secondValue = tail.remove(second);\n-        assertEquals(false, sm.containsKey(second));\n-        assertEquals(false, sm.containsValue(secondValue));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n-        assertEquals(false, tail.containsKey(second));\n-        assertEquals(false, tail.containsValue(secondValue));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testBidiRemoveByTailMapEntrySet() {\n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        SortedMap tail = sm.tailMap(fromKey);\n-        Set set = tail.entrySet();\n-        Iterator it2 = set.iterator();\n-        Object fromEntry = it2.next();\n-        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n-        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n-        assertEquals(true, sm.containsKey(first));\n-        assertEquals(true, tail.containsKey(first));\n-        assertEquals(true, set.contains(firstEntry));\n-        assertEquals(true, sm.containsKey(second));\n-        assertEquals(true, tail.containsKey(second));\n-        assertEquals(true, set.contains(secondEntry));\n-        \n-        set.remove(firstEntry);\n-        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n-        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n-        assertEquals(false, tail.containsKey(firstEntry.getKey()));\n-        assertEquals(false, tail.containsValue(firstEntry.getValue()));\n-        assertEquals(false, set.contains(firstEntry));\n-        \n-        set.remove(secondEntry);\n-        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n-        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n-        assertEquals(false, tail.containsKey(secondEntry.getKey()));\n-        assertEquals(false, tail.containsValue(secondEntry.getValue()));\n-        assertEquals(false, set.contains(secondEntry));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testBidiRemoveBySubMap() {\n-        // extra test as other tests get complex\n-        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n-        Iterator it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        Object fromKey = it.next();\n-        Object first = it.next();\n-        Object second = it.next();\n-        Object toKey = it.next();\n-        \n-        SortedMap sub = sm.subMap(fromKey, toKey);\n-        assertEquals(true, sm.containsKey(first));\n-        assertEquals(true, sub.containsKey(first));\n-        assertEquals(true, sm.containsKey(second));\n-        assertEquals(true, sub.containsKey(second));\n-        \n-        Object firstValue = sub.remove(first);\n-        assertEquals(false, sm.containsKey(first));\n-        assertEquals(false, sm.containsValue(firstValue));\n-        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n-        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n-        assertEquals(false, sub.containsKey(first));\n-        assertEquals(false, sub.containsValue(firstValue));\n-        \n-        Object secondValue = sub.remove(second);\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n         assertEquals(false, sm.containsKey(second));\n         assertEquals(false, sm.containsValue(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n         assertEquals(false, sm.inverseBidiMap().containsValue(second));\n         assertEquals(false, sub.containsKey(second));\n         assertEquals(false, sub.containsValue(secondValue));\n+        \n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.headMap(toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.headMap(toKey);\n+        Set set = sub.entrySet();\n+        assertEquals(2, sub.size());\n+        assertEquals(2, set.size());\n+        \n+        Iterator it2 = set.iterator();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiTailMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object fromKey = it.next();\n+        Object second = it.next();\n+        Object firstValue = sm.get(first);\n+        Object fromKeyValue = sm.get(fromKey);\n+        Object secondValue = sm.get(second);\n+        \n+        SortedMap sub = sm.tailMap(fromKey);\n+        assertEquals(sm.size() - 1, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByTailMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object first = it.next();\n+        Object fromKey = it.next();\n+        Object second = it.next();\n+        \n+        Object firstValue = sm.get(first);\n+        Object fromKeyValue = sm.get(fromKey);\n+        Object secondValue = sm.get(second);\n+        \n+        SortedMap sub = sm.tailMap(fromKey);\n+        int size = sm.size();\n+        assertEquals(size - 3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(3, sm.size());\n+        assertEquals(3, sm.inverseBidiMap().size());\n+        \n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+        \n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------                \n+    public void testBidiRemoveByTailMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.tailMap(fromKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMapEntrySet() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.tailMap(fromKey);\n+        Set set = sub.entrySet();\n+        Iterator it2 = set.iterator();\n+        Object fromEntry = it2.next();\n+        Map.Entry firstEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        Map.Entry secondEntry = new DefaultMapEntry((Map.Entry) it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+        \n+        set.remove(firstEntry);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+        \n+        set.remove(secondEntry);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiSubMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        Object first = it.next();\n+        Object fromKey = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        Object third = it.next();\n+        Object firstValue = sm.get(first);\n+        Object fromKeyValue = sm.get(fromKey);\n+        Object secondValue = sm.get(second);\n+        Object thirdValue = sm.get(third);\n+        \n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+        assertEquals(true, sm.containsKey(third));\n+        assertEquals(false, sub.containsKey(third));\n+        assertEquals(true, sm.containsValue(thirdValue));\n+        assertEquals(false, sub.containsValue(thirdValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearBySubMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        Object fromKeyValue = sm.get(fromKey);\n+        Object firstValue = sm.get(first);\n+        Object secondValue = sm.get(second);\n+        Object toKeyValue = sm.get(toKey);\n+        \n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        int size = sm.size();\n+        assertEquals(3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 3, sm.size());\n+        assertEquals(size - 3, sm.inverseBidiMap().size());\n+        \n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+        \n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+        \n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMap() {\n+        // extra test as other tests get complex\n+        SortedBidiMap sm = (SortedBidiMap) makeFullMap();\n+        Iterator it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        Object fromKey = it.next();\n+        Object first = it.next();\n+        Object second = it.next();\n+        Object toKey = it.next();\n+        \n+        int size = sm.size();\n+        SortedMap sub = sm.subMap(fromKey, toKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        \n+        Object firstValue = sub.remove(first);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        \n+        Object secondValue = sub.remove(second);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n     }\n \n     //-----------------------------------------------------------------------\n         Object second = it.next();\n         Object toKey = it.next();\n         \n+        int size = sm.size();\n         SortedMap sub = sm.subMap(fromKey, toKey);\n         Set set = sub.entrySet();\n         assertEquals(3, set.size());\n         assertEquals(true, set.contains(secondEntry));\n         \n         set.remove(firstEntry);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n         assertEquals(false, sm.containsKey(firstEntry.getKey()));\n         assertEquals(false, sm.containsValue(firstEntry.getValue()));\n         assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n         assertEquals(false, set.contains(firstEntry));\n         \n         set.remove(secondEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n         assertEquals(false, sm.containsKey(secondEntry.getKey()));\n         assertEquals(false, sm.containsValue(secondEntry.getValue()));\n         assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n--- a/src/test/org/apache/commons/collections/TestBeanMap.java\n+++ b/src/test/org/apache/commons/collections/TestBeanMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBeanMap.java,v 1.13 2003/10/07 22:20:57 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBeanMap.java,v 1.14 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Map;\n \n import junit.framework.Test;\n+import junit.textui.TestRunner;\n \n /**\n  * Test cases for BeanMap\n  * \n- * @version $Revision: 1.13 $ $Date: 2003/10/07 22:20:57 $\n+ * @version $Revision: 1.14 $ $Date: 2003/11/01 18:47:18 $\n  * \n  * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n  */\n public class TestBeanMap extends AbstractTestMap {\n \n     public TestBeanMap(String testName) {\n         super(testName);\n+    }\n+    \n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n     }\n \n     public static Test suite() {\n     }\n \n     /**\n+     * Values is a dead copy in BeanMap, so refresh each time.\n+     */\n+    protected void verifyValues() {\n+        values = map.values();\n+        super.verifyValues();\n+    }\n+\n+    /**\n      * The mappings in a BeanMap are fixed on the properties the underlying\n      * bean has.  Adding and removing mappings is not possible, thus this\n      * method is overridden to return false.\n--- a/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.10 2003/10/07 22:20:57 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.11 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Map that does not support duplicate keys, duplicate \n  * values, or null values.\n  * \n- * @version $Revision: 1.10 $ $Date: 2003/10/07 22:20:57 $\n+ * @version $Revision: 1.11 $ $Date: 2003/11/01 18:47:18 $\n  * \n- * @author Marc Johnson (marcj at users dot sourceforge dot net)\n+ * @author Marc Johnson\n+ * @author Stephen Colebourne\n  */\n public class TestDoubleOrderedMap extends AbstractTestMap  {\n \n     /**\n      *  The default comparator in double ordered map does not allow null keys.\n      **/\n-    public boolean isAllowNullKey() {\n+    protected boolean isAllowNullKey() {\n         return false;\n     }\n \n      *  The default comparator in double ordered map does not allow null keys,\n      *  and values are keys in this map.\n      **/\n-    public boolean isAllowNullValue() {\n+    protected boolean isAllowNullValue() {\n         return false;\n     }\n \n     /**\n      *  Double ordered map does not support duplicate values\n      **/\n-    public boolean isAllowDuplicateValues() {\n+    protected boolean isAllowDuplicateValues() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Change the Map.put() test because it tries put with the same key\n+     * which is invalid in the modified double ordered map contract. (The\n+     * DoubleOrderedMap documentation states that an IllegalArgumentException\n+     * is thrown when a key is tried to be put into the map again.  This\n+     * differs from the standard Map contract which would replace the value\n+     * for that key and return it.\n+     */\n+    protected boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * setValue() is not supported as it can change the map.\n+     */\n+    protected boolean isSetValueSupported() {\n         return false;\n     }\n \n         junit.textui.TestRunner.run(TestDoubleOrderedMap.class);\n     }\n \n-    /**\n-     *  Override the Map.put() test because it tries put with the same key\n-     *  which is invalid in the modified double ordered map contract. (The\n-     *  DoubleOrderedMap documentation states that an IllegalArgumentException\n-     *  is thrown when a key is tried to be put into the map again.  This\n-     *  differs from the standard Map contract which would replace the value\n-     *  for that key and return it.\n-     **/\n-    public void testMapPut() {\n-    }\n }\n--- a/src/test/org/apache/commons/collections/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/TestLRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.25 2003/10/05 21:17:40 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.26 2003/11/01 18:47:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Tests LRUMap.\n  * \n- * @version $Revision: 1.25 $ $Date: 2003/10/05 21:17:40 $\n+ * @version $Revision: 1.26 $ $Date: 2003/11/01 18:47:18 $\n  * \n  * @author James Strachan\n  * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n  */\n public class TestLRUMap extends TestSequencedHashMap {\n     \n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n+    //-----------------------------------------------------------------------\n     public Map makeEmptyMap() {\n         LRUMap map = new LRUMap();\n         return map;\n     }\n \n+    /**\n+     * Override as test uses iterator() and getKey() in combination which doesn't work.\n+     */\n+    protected String[] ignoredTests() {\n+        return new String[] {\"TestLRUMap.bulkTestMapEntrySet.testMapEntrySetIteratorEntry\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testRemoveLRU() {\n         LRUMap map2 = new LRUMap(3);\n         map2.put(new Integer(1),\"foo\");", "timestamp": 1067712438, "metainfo": ""}