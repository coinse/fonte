{"sha": "3b9b229b367da4470e51fab2fd1b7511eea33643", "log": "complete re-implementation of SequencedHashMap submitted by Michael Smith   ", "commit": "\n--- a/src/java/org/apache/commons/collections/SequencedHashMap.java\n+++ b/src/java/org/apache/commons/collections/SequencedHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.2 2002/02/10 08:07:42 jstrachan Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/02/10 08:07:42 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.3 2002/02/18 20:34:57 morgand Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/18 20:34:57 $\n  *\n  * ====================================================================\n  *\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections;\n \n-\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.LinkedList;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.NoSuchElementException;\n \n /**\n- * <p>A {@link java.util.HashMap} whose keys are sequenced.  The\n- * sequencing of the keys allow easy access to the values in the order\n- * which they were added in.  This class is thread safe.</p>\n- *\n- * <p>Implementing the List interface is not possible due to a instance\n- * method name clash between the Collection and the List interface:\n- *\n- * <table>\n- * <tr><td>Collections</td><td>boolean remove(Object o)</td></tr>\n- * <tr><td>Lists</td><td>Object remove(Object o)</td></tr>\n- * </table>\n- * </p>\n- *\n- * <p>So one cannot implement both interfaces at the same, which is\n- * unfortunate because the List interface would be very nice in\n- * conjuction with <a\n- * href=\"http://jakarta.apache.org/velocity/\">Velocity</a>.</p>\n- *\n- * <p>A slightly more complex implementation and interface could involve\n- * the use of a list of <code>Map.Entry</code> objects.</p>\n- *\n+ *  A map of objects whose mapping entries are sequenced based on the order in\n+ *  which they were added.  This data structure has fast <I>O(1)</I> search\n+ *  time, deletion time, and insertion time.\n+ *\n+ *  This class inherits from {@link java.util.HashMap} purely for backwards\n+ *  compatibility.  It should really be inheriting from {@link\n+ *  java.util.AbstractMap}, or with a tiny extra bit of work, implement the\n+ *  full map interface on its own. APIs should not rely on this class being an\n+ *  actual {@link java.util.HashMap}, and instead should recognize it only as a\n+ *  generic {@link java.util.Map} (unless, of course, you need the sequencing\n+ *  functionality, but even in that case, this class should not be referred to\n+ *  as a java.util.HashMap).\n+ *\n+ *  <P>Although this map is sequenced, it cannot implement {@link\n+ *  java.util.List} because of incompatible interface definitions.  The remove\n+ *  methods in List and Map have different return values (see: {@link\n+ *  java.util.List#remove(Object)} and {@link java.util.Map#remove(Object)}).\n+ *\n+ *  <P>This class is not thread safe.  When a thread safe implementation is\n+ *  required, use {@link Collections#synchronizedMap(Map)} as it is documented,\n+ *  or use explicit synchronization controls.\n+ *\n+ *  @author <a href=\"mailto:michael@iammichael.org\">Michael A. Smith</A>\n  * @author <a href=\"mailto:dlr@collab.net\">Daniel Rall</a>\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n  */\n-public class SequencedHashMap extends HashMap\n-{\n+public class SequencedHashMap extends HashMap {\n+\n+  /**\n+   *  {@link java.util.Map.Entry} that doubles as a node in the linked list\n+   *  of sequenced mappings.  \n+   **/\n+  private static class Entry implements Map.Entry {\n+    // Note: This class cannot easily be made clonable.  While the actual\n+    // implementation of a clone would be simple, defining the semantics is\n+    // difficult.  If a shallow clone is implemented, then entry.next.prev !=\n+    // entry, which is unintuitive and probably breaks all sorts of assumptions\n+    // in code that uses this implementation.  If a deep clone is\n+    // implementated, then what happens when the linked list is cyclical (as is\n+    // the case with SequencedHashMap)?  It's impossible to know in the clone\n+    // when to stop cloning, and thus you end up in a recursive loop,\n+    // continuously cloning the \"next\" in the list.\n+\n+    private final Object key;\n+    private Object value;\n+    \n+    // package private to allow the SequencedHashMap to access and manipulate\n+    // them.\n+    Entry next = null;\n+    Entry prev = null;\n+\n+    public Entry(Object key, Object value) {\n+      this.key = key;\n+      this.value = value;\n+    }\n+\n+    // per Map.Entry.getKey()\n+    public Object getKey() { \n+      return this.key; \n+    }\n+\n+    // per Map.Entry.getValue()\n+    public Object getValue() { \n+      return this.value; \n+    }\n+\n+    // per Map.Entry.setValue()\n+    public Object setValue(Object value) { \n+      Object oldValue = this.value;\n+      this.value = value; \n+      return oldValue;\n+    }\n+\n+    public int hashCode() { \n+      // implemented per api docs for Map.Entry.hashCode()\n+      return ((getKey() == null ? 0 : getKey().hashCode()) ^\n+              (getValue()==null ? 0 : getValue().hashCode())); \n+    }\n+\n+    public boolean equals(Object obj) {\n+      if(obj == null) return false;\n+      if(obj == this) return true;\n+      if(!(obj instanceof Map.Entry)) return false;\n+\n+      Map.Entry other = (Map.Entry)obj;\n+\n+      // implemented per api docs for Map.Entry.equals(Object) \n+      return((getKey() == null ?\n+              other.getKey() == null : \n+              getKey().equals(other.getKey()))  &&\n+             (getValue() == null ?\n+              other.getValue() == null : \n+              getValue().equals(other.getValue())));\n+    }\n+    public String toString() {\n+      return \"[\" + getKey() + \"=\" + getValue() + \"]\";\n+    }\n+  }\n+\n+  /**\n+   *  Construct an empty sentinel used to hold the head (sentinel.next) and the\n+   *  tail (sentinel.prev) of the list.  The sentinal has a <code>null</code>\n+   *  key and value.\n+   **/\n+  private static final Entry createSentinel() {\n+    Entry s = new Entry(null, null);\n+    s.prev = s;\n+    s.next = s;\n+    return s;\n+  }\n+\n+  /**\n+   *  Sentinel used to hold the head and tail of the list of entries.\n+   **/\n+  private Entry sentinel;\n+\n+  /**\n+   *  Map of keys to entries\n+   **/\n+  private HashMap entries;\n+\n+  /**\n+   *  Construct a new sequenced hash map with default initial size and load\n+   *  factor.\n+   **/\n+  public SequencedHashMap() {\n+    sentinel = createSentinel();\n+    entries = new HashMap();\n+  }\n+\n+  /**\n+   *  Construct a new sequenced hash map with the specified initial size and\n+   *  default load factor.\n+   *\n+   *  @param initialSize the initial size for the hash table \n+   *\n+   *  @see HashMap#HashMap(int)\n+   **/\n+  public SequencedHashMap(int initialSize) {\n+    sentinel = createSentinel();\n+    entries = new HashMap(initialSize);\n+  }\n+\n+  /**\n+   *  Construct a new sequenced hash map with the specified initial size and\n+   *  load factor.\n+   *\n+   *  @param initialSize the initial size for the hash table \n+   *\n+   *  @param loadFactor the load factor for the hash table.\n+   *\n+   *  @see HashMap#HashMap(int,float)\n+   **/\n+  public SequencedHashMap(int initialSize, float loadFactor) {\n+    sentinel = createSentinel();\n+    entries = new HashMap(initialSize, loadFactor);\n+  }\n+\n+  /**\n+   *  Construct a new sequenced hash map and add all the elements in the\n+   *  specified map.  The order in which the mappings in the specified map are\n+   *  added is defined by {@link #putAll(Map)}.  \n+   **/\n+  public SequencedHashMap(Map m) {\n+    this();\n+    putAll(m);\n+  }\n+\n+  /**\n+   *  Removes an internal entry from the linked list.  This does not remove\n+   *  it from the underlying map.\n+   **/\n+  private void removeEntry(Entry entry) {\n+    entry.next.prev = entry.prev;\n+    entry.prev.next = entry.next;    \n+  }\n+\n+  /**\n+   *  Inserts a new internal entry to the tail of the linked list.  This does\n+   *  not add the entry to the underlying map.\n+   **/\n+  private void insertEntry(Entry entry) {\n+    entry.next = sentinel;\n+    entry.prev = sentinel.prev;\n+    sentinel.prev.next = entry;\n+    sentinel.prev = entry;\n+  }\n+\n+  // per Map.size()\n+  public int size() {\n+    // use the underlying Map's size since size is not maintained here.\n+    return entries.size();\n+  }\n+\n+  // per Map.isEmpty()\n+  public boolean isEmpty() {\n+    // for quick check whether the map is entry, we can check the linked list\n+    // and see if there's anything in it.\n+    return sentinel.next == sentinel;\n+  }\n+\n+  // per Map.containsKey(Object)\n+  public boolean containsKey(Object key) {\n+    // pass on to underlying map implementation\n+    return entries.containsKey(key);\n+  }\n+\n+  // per Map.containsValue(Object)\n+  public boolean containsValue(Object value) {\n+    // unfortunately, we cannot just pass this call to the underlying map\n+    // because we are mapping keys to entries, not keys to values.  The\n+    // underlying map doesn't have an efficient implementation anyway, so this\n+    // isn't a big deal.\n+\n+    // do null comparison outside loop so we only need to do it once.  This\n+    // provides a tighter, more efficient loop at the expense of slight\n+    // code duplication.\n+    if(value == null) {\n+      for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+        if(pos.getValue() == null) return true;\n+      } \n+    } else {\n+      for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+        if(value.equals(pos.getValue())) return true;\n+      }\n+    }\n+    return false;      \n+  }\n+\n+  // per Map.get(Object)\n+  public Object get(Object o) {\n+    // find entry for the specified key object\n+    Entry entry = (Entry)entries.get(o);\n+    if(entry == null) return null;\n+      \n+    return entry.getValue();\n+  }\n+\n+  /**\n+   *  Return the entry for the \"oldest\" mapping.  That is, return the Map.Entry\n+   *  for the key-value pair that was first put into the map when compared to\n+   *  all the other pairings in the map.  This behavior is equivalent to using\n+   *  <code>entrySet().iterator().next()</code>, but this method provides an\n+   *  optimized implementation.\n+   *\n+   *  @return The first entry in the sequence, or <code>null</code> if the\n+   *  map is empty.\n+   **/\n+  public Map.Entry getFirst() {\n+    // sentinel.next points to the \"first\" element of the sequence -- the head\n+    // of the list, which is exactly the entry we need to return.  We must test\n+    // for an empty list though because we don't want to return the sentinel!\n+    return (isEmpty()) ? null : sentinel.next;\n+  }\n+\n+  /**\n+   *  Return the key for the \"oldest\" mapping.  That is, return the key for the\n+   *  mapping that was first put into the map when compared to all the other\n+   *  objects in the map.  This behavior is equivalent to using\n+   *  <code>getFirst().getKey()</code>, but this method provides a slightly\n+   *  optimized implementation.\n+   *\n+   *  @return The first key in the sequence, or <code>null</code> if the\n+   *  map is empty.\n+   **/\n+  public Object getFirstKey() {\n+    // sentinel.next points to the \"first\" element of the sequence -- the head\n+    // of the list -- and the requisite key is returned from it.  An empty list\n+    // does not need to be tested.  In cases where the list is empty,\n+    // sentinel.next will point to the sentinel itself which has a null key,\n+    // which is exactly what we would want to return if the list is empty (a\n+    // nice convient way to avoid test for an empty list)\n+    return sentinel.next.getKey();\n+  }\n+\n+  /**\n+   *  Return the value for the \"oldest\" mapping.  That is, return the value for\n+   *  the mapping that was first put into the map when compared to all the\n+   *  other objects in the map.  This behavior is equivalent to using\n+   *  <code>getFirst().getValue()</code>, but this method provides a slightly\n+   *  optimized implementation.\n+   *\n+   *  @return The first value in the sequence, or <code>null</code> if the\n+   *  map is empty.\n+   **/\n+  public Object getFirstValue() {\n+    // sentinel.next points to the \"first\" element of the sequence -- the head\n+    // of the list -- and the requisite value is returned from it.  An empty\n+    // list does not need to be tested.  In cases where the list is empty,\n+    // sentinel.next will point to the sentinel itself which has a null value,\n+    // which is exactly what we would want to return if the list is empty (a\n+    // nice convient way to avoid test for an empty list)\n+    return sentinel.next.getValue();\n+  }\n+\n+  /**\n+   *  Return the entry for the \"newest\" mapping.  That is, return the Map.Entry\n+   *  for the key-value pair that was first put into the map when compared to\n+   *  all the other pairings in the map.  The behavior is equivalent to:\n+   *\n+   *  <pre>\n+   *    Object obj = null;\n+   *    Iterator iter = entrySet().iterator();\n+   *    while(iter.hasNext()) {\n+   *      obj = iter.next();\n+   *    }\n+   *    return (Map.Entry)obj;\n+   *  </pre>\n+   *\n+   *  However, the implementation of this method ensures an O(1) lookup of the\n+   *  last key rather than O(n).\n+   *\n+   *  @return The last entry in the sequence, or <code>null</code> if the map\n+   *  is empty.\n+   **/\n+  public Map.Entry getLast() {\n+    // sentinel.prev points to the \"last\" element of the sequence -- the tail\n+    // of the list, which is exactly the entry we need to return.  We must test\n+    // for an empty list though because we don't want to return the sentinel!\n+    return (isEmpty()) ? null : sentinel.prev;\n+  }\n+\n+  /**\n+   *  Return the key for the \"newest\" mapping.  That is, return the key for the\n+   *  mapping that was last put into the map when compared to all the other\n+   *  objects in the map.  This behavior is equivalent to using\n+   *  <code>getLast().getKey()</code>, but this method provides a slightly\n+   *  optimized implementation.\n+   *\n+   *  @return The last key in the sequence, or <code>null</code> if the map is\n+   *  empty.\n+   **/\n+  public Object getLastKey() {\n+    // sentinel.prev points to the \"last\" element of the sequence -- the tail\n+    // of the list -- and the requisite key is returned from it.  An empty list\n+    // does not need to be tested.  In cases where the list is empty,\n+    // sentinel.prev will point to the sentinel itself which has a null key,\n+    // which is exactly what we would want to return if the list is empty (a\n+    // nice convient way to avoid test for an empty list)\n+    return sentinel.prev.getKey();\n+  }\n+\n+  /**\n+   *  Return the value for the \"newest\" mapping.  That is, return the value for\n+   *  the mapping that was last put into the map when compared to all the other\n+   *  objects in the map.  This behavior is equivalent to using\n+   *  <code>getLast().getValue()</code>, but this method provides a slightly\n+   *  optimized implementation.\n+   *\n+   *  @return The last value in the sequence, or <code>null</code> if the map\n+   *  is empty.\n+   **/\n+  public Object getLastValue() {\n+    // sentinel.prev points to the \"last\" element of the sequence -- the tail\n+    // of the list -- and the requisite value is returned from it.  An empty\n+    // list does not need to be tested.  In cases where the list is empty,\n+    // sentinel.prev will point to the sentinel itself which has a null value,\n+    // which is exactly what we would want to return if the list is empty (a\n+    // nice convient way to avoid test for an empty list)\n+    return sentinel.prev.getValue();\n+  }\n+\n+  // per Map.put(Object,Object)\n+  public Object put(Object key, Object value) {\n+\n+    Object oldValue = null;\n+\n+    // lookup the entry for the specified key\n+    Entry e = (Entry)entries.get(key);\n+\n+    // check to see if it already exists\n+    if(e != null) {\n+      // remove from list so the entry gets \"moved\" to the end of list\n+      removeEntry(e);\n+\n+      // update value in map\n+      oldValue = e.setValue(value);\n+\n+      // Note: We do not update the key here because its unnecessary.  We only\n+      // do comparisons using equals(Object) and we know the specified key and\n+      // that in the map are equal in that sense.  This may cause a problem if\n+      // someone does not implement their hashCode() and/or equals(Object)\n+      // method properly and then use it as a key in this map.  \n+    } else {\n+      // add new entry\n+      e = new Entry(key, value);\n+      entries.put(key, e);\n+    }\n+    // assert(entry in map, but not list)\n+\n+    // add to list\n+    insertEntry(e);\n+\n+    return oldValue;\n+  }\n+\n+  // per Map.remove(Object)\n+  public Object remove(Object key) {\n+    Entry e = (Entry)entries.remove(key);\n+    if(e == null) return null;\n+    removeEntry(e);\n+    return e.getValue();\n+  }\n+\n+  /**\n+   *  Adds all the mappings in the specified map to this map, replacing any\n+   *  mappings that already exist (as per {@link Map#putAll(Map)}).  The order\n+   *  in which the entries are added is determined by the iterator returned\n+   *  from {@link Map#entrySet()} for the specified map.\n+   *\n+   *  @param t the mappings that should be added to this map.\n+   *\n+   *  @exception NullPointerException if <code>t</code> is <code>null</code>\n+   **/\n+  public void putAll(Map t) {\n+    Iterator iter = t.entrySet().iterator();\n+    while(iter.hasNext()) {\n+      Map.Entry entry = (Map.Entry)iter.next();\n+      put(entry.getKey(), entry.getValue());\n+    }\n+  }\n+\n+  // per Map.clear()\n+  public void clear() {\n+    // remove all from the underlying map\n+    entries.clear();\n+\n+    // and the list\n+    sentinel.next = sentinel;\n+    sentinel.prev = sentinel;\n+  }\n+\n+  // per Map.keySet()\n+  public Set keySet() {\n+    return new AbstractSet() {\n+\n+      // required impls\n+      public Iterator iterator() { return new OrderedIterator(KEY); }\n+      public boolean remove(Object o) {\n+        return SequencedHashMap.this.remove(o) != null;\n+      }\n+\n+      // more efficient impls than abstract set\n+      public void clear() { \n+        SequencedHashMap.this.clear(); \n+      }\n+      public int size() { \n+        return SequencedHashMap.this.size(); \n+      }\n+      public boolean isEmpty() { \n+        return SequencedHashMap.this.isEmpty(); \n+      }\n+      public boolean contains(Object o) { \n+        return SequencedHashMap.this.containsKey(o);\n+      }\n+\n+    };\n+  }\n+\n+  // per Map.values()\n+  public Collection values() {\n+    return new AbstractCollection() {\n+      // required impl\n+      public Iterator iterator() { return new OrderedIterator(VALUE); }\n+      public boolean remove(Object value) {\n+        // do null comparison outside loop so we only need to do it once.  This\n+        // provides a tighter, more efficient loop at the expense of slight\n+        // code duplication.\n+        if(value == null) {\n+          for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+            if(pos.getValue() == null) {\n+              SequencedHashMap.this.remove(pos.getKey());\n+              return true;\n+            }\n+          } \n+        } else {\n+          for(Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {\n+            if(value.equals(pos.getValue())) {\n+              SequencedHashMap.this.remove(pos.getKey());\n+              return true;\n+            }\n+          }\n+        }\n+\n+        return false;\n+      }\n+\n+      // more efficient impls than abstract collection\n+      public void clear() { \n+        SequencedHashMap.this.clear(); \n+      }\n+      public int size() { \n+        return SequencedHashMap.this.size(); \n+      }\n+      public boolean isEmpty() { \n+        return SequencedHashMap.this.isEmpty(); \n+      }\n+      public boolean contains(Object o) {\n+        return SequencedHashMap.this.containsValue(o);\n+      }\n+    };\n+  }\n+\n+  // per Map.entrySet()\n+  public Set entrySet() {\n+    return new AbstractSet() {\n+      // helper\n+      private Entry findEntry(Object o) {\n+        if(o == null) return null;\n+        if(!(o instanceof Map.Entry)) return null;\n+        \n+        Map.Entry e = (Map.Entry)o;\n+        Entry entry = (Entry)entries.get(e.getKey());\n+        if(entry.equals(e)) return entry;\n+        else return null;\n+      }\n+\n+      // required impl\n+      public Iterator iterator() { \n+        return new OrderedIterator(ENTRY); \n+      }\n+      public boolean remove(Object o) {\n+        Entry e = findEntry(o);\n+        if(e == null) return false;\n+\n+        return SequencedHashMap.this.remove(e.getKey()) != null;\n+      }        \n+\n+      // more efficient impls than abstract collection\n+      public void clear() { \n+        SequencedHashMap.this.clear(); \n+      }\n+      public int size() { \n+        return SequencedHashMap.this.size(); \n+      }\n+      public boolean isEmpty() { \n+        return SequencedHashMap.this.isEmpty(); \n+      }\n+      public boolean contains(Object o) {\n+        return findEntry(o) != null;\n+      }\n+    };\n+  }\n+\n+  // constants to define what the iterator should return on \"next\"\n+  private static final int KEY = 0;\n+  private static final int VALUE = 1;\n+  private static final int ENTRY = 2;\n+  private static final int REMOVED_MASK = 0x80000000;\n+\n+  private class OrderedIterator implements Iterator {\n+    /** \n+     *  Holds the type that should be returned from the iterator.  The value\n+     *  should be either {@link #KEY}, {@link #VALUE}, or {@link #ENTRY}.  To\n+     *  save a tiny bit of memory, this field is also used as a marker for when\n+     *  remove has been called on the current object to prevent a second remove\n+     *  on the same element.  Essientially, if this value is negative (i.e. the\n+     *  bit specified by {@link #REMOVED_MASK} is set), the current position\n+     *  has been removed.  If positive, remove can still be called.\n+     **/\n+    private int returnType;\n+\n     /**\n-     * The index of the eldest element in the collection.\n-     */\n-    protected static final int ELDEST_INDEX = 0;\n-\n+     *  Holds the \"current\" position in the iterator.  when pos.next is the\n+     *  sentinel, we've reached the end of the list.\n+     **/\n+    private Entry pos = sentinel;\n+    \n     /**\n-     * Indicator for an unknown index.\n-     */\n-    private static final int UNKNOWN_INDEX = -1;\n+     *  Construct an iterator over the sequenced elements in the order in which\n+     *  they were added.  The {@link #next()} method returns the type specified\n+     *  by <code>returnType</code> which must be either {@link #KEY}, {@link\n+     *  #VALUE}, or {@link #ENTRY}.\n+     **/\n+    public OrderedIterator(int returnType) {\n+      //// Since this is a private inner class, nothing else should have\n+      //// access to the constructor.  Since we know the rest of the outer\n+      //// class uses the iterator correctly, we can leave of the following\n+      //// check:\n+      //if(returnType >= 0 && returnType <= 2) {\n+      //  throw new IllegalArgumentException(\"Invalid iterator type\");\n+      //}\n+\n+      // Set the \"removed\" bit so that the iterator starts in a state where\n+      // \"next\" must be called before \"remove\" will succeed.\n+      this.returnType = returnType | REMOVED_MASK;\n+    }\n \n     /**\n-     * The sequence used to keep track of the hash keys.  Younger objects are\n-     * kept towards the end of the list.  Does not allow duplicates.\n-     */\n-    private LinkedList keySequence;\n+     *  Returns whether there is any additional elements in the iterator to be\n+     *  returned.\n+     *\n+     *  @return <code>true</code> if there are more elements left to be\n+     *  returned from the iterator; <code>false</code> otherwise.\n+     **/\n+    public boolean hasNext() {\n+      return pos.next != sentinel;\n+    }\n \n     /**\n-     * Creates a new instance with default storage.\n-     */\n-    public SequencedHashMap ()\n-    {\n-        keySequence = new LinkedList();\n-    }\n-\n+     *  Returns the next element from the iterator.\n+     *\n+     *  @return the next element from the iterator.\n+     *\n+     *  @exception NoSuchElementException if there are no more elements in the\n+     *  iterator.\n+     **/\n+    public Object next() {\n+      if(pos.next == sentinel) {\n+        throw new NoSuchElementException();\n+      }\n+\n+      // clear the \"removed\" flag\n+      returnType = returnType & ~REMOVED_MASK;\n+\n+      pos = pos.next;\n+      switch(returnType) {\n+      case KEY:\n+        return pos.getKey();\n+      case VALUE:\n+        return pos.getValue();\n+      case ENTRY:\n+        return pos;\n+      default:\n+        // should never happen\n+        throw new Error(\"bad iterator type: \" + returnType);\n+      }\n+\n+    }\n+    \n     /**\n-     * Creates a new instance with the specified storage.\n+     *  Removes the last element returned from the {@link #next()} method from\n+     *  the sequenced map.\n      *\n-     * @param size The storage to allocate up front.\n-     */\n-    public SequencedHashMap (int size)\n-    {\n-        super(size);\n-        keySequence = new LinkedList();\n-    }\n-\n-    /**\n-     * Clears all elements.\n-     */\n-    public void clear ()\n-    {\n-        super.clear();\n-        keySequence.clear();\n-    }\n-\n-    /**\n-     * Creates a shallow copy of this object, preserving the internal\n-     * structure by copying only references.  The keys, values, and\n-     * sequence are not <code>clone()</code>'d.\n-     *\n-     * @return A clone of this instance.\n-     */\n-    public Object clone ()\n-    {\n-        SequencedHashMap seqHash = (SequencedHashMap) super.clone();\n-        seqHash.keySequence = (LinkedList) keySequence.clone();\n-        return seqHash;\n-    }\n-\n-    /**\n-     * Returns the key at the specified index.\n-     */\n-    public Object get (int index)\n-    {\n-        return keySequence.get(index);\n-    }\n-\n-    /**\n-     * Returns the value at the specified index.\n-     */\n-    public Object getValue (int index)\n-    {\n-        return get(get(index));\n-    }\n-\n-    /**\n-     * Returns the index of the specified key.\n-     */\n-    public int indexOf (Object key)\n-    {\n-        return keySequence.indexOf(key);\n-    }\n-\n-    /**\n-     * Returns a key iterator.\n-     */\n-    public Iterator iterator ()\n-    {\n-        return keySequence.iterator();\n-    }\n-\n-    /**\n-     * Returns the last index of the specified key.\n-     */\n-    public int lastIndexOf (Object key)\n-    {\n-        return keySequence.lastIndexOf(key);\n-    }\n-\n-    /**\n-     * Returns the ordered sequence of keys.\n-     *\n-     * This method is meant to be used for retrieval of Key / Value pairs\n-     * in e.g. Velocity:\n-     * <PRE>\n-     * ## $table contains a sequenced hashtable\n-     * #foreach ($key in $table.sequence())\n-     * &lt;TR&gt;\n-     * &lt;TD&gt;Key: $key&lt;/TD&gt;\n-     * &lt;/TD&gt;Value: $table.get($key)&lt;/TD&gt;\n-     * &lt;/TR&gt;\n-     * #end\n-     * </PRE>\n-     *\n-     * @return The ordered list of keys.\n-     */\n-    public List sequence()\n-    {\n-        return keySequence;\n-    }\n-\n-    /**\n-     * Stores the provided key/value pair.  Freshens the sequence of existing\n-     * elements.\n-     *\n-     * @param key   The key to the provided value.\n-     * @param value The value to store.\n-     * @return      The previous value for the specified key, or\n-     *              <code>null</code> if none.\n-     */\n-    public Object put (Object key, Object value)\n-    {\n-        Object prevValue = super.put(key, value);\n-        freshenSequence(key, prevValue);\n-        return prevValue;\n-    }\n-\n-    /**\n-     * Freshens the sequence of the element <code>value</code> if\n-     * <code>value</code> is not <code>null</code>.\n-     *\n-     * @param key   The key whose sequence to freshen.\n-     * @param value The value whose existance to check before removing the old\n-     *              key sequence.\n-     */\n-    protected void freshenSequence(Object key, Object value)\n-    {\n-        if (value != null)\n-        {\n-            // Freshening existing element's sequence.\n-            keySequence.remove(key);\n-        }\n-        keySequence.add(key);\n-    }\n-\n-    /**\n-     * Stores the provided key/value pairs.\n-     *\n-     * @param t The key/value pairs to store.\n-     */\n-    public void putAll (Map t)\n-    {\n-        Set set = t.entrySet();\n-        for (Iterator iter = set.iterator(); iter.hasNext(); )\n-        {\n-            Map.Entry e = (Map.Entry)iter.next();\n-            put(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    /**\n-     * Removes the element at the specified index.\n-     *\n-     * @param index The index of the object to remove.\n-     * @return      The previous value coressponding the <code>key</code>, or\n-     *              <code>null</code> if none existed.\n-     */\n-    public Object remove (int index)\n-    {\n-        return remove(index, null);\n-    }\n-\n-    /**\n-     * Removes the element with the specified key.\n-     *\n-     * @param key   The <code>Map</code> key of the object to remove.\n-     * @return      The previous value coressponding the <code>key</code>, or\n-     *              <code>null</code> if none existed.\n-     */\n-    public Object remove (Object key)\n-    {\n-        return remove(UNKNOWN_INDEX, key);\n-    }\n-\n-    /**\n-     * Removes the element with the specified key or index.\n-     *\n-     * @param index The index of the object to remove, or\n-     *              <code>UNKNOWN_INDEX</code> if not known.\n-     * @param key   The <code>Map</code> key of the object to remove.\n-     * @return      The previous value coressponding the <code>key</code>, or\n-     *              <code>null</code> if none existed.\n-     */\n-    private final Object remove (int index, Object key)\n-    {\n-        if (index == UNKNOWN_INDEX)\n-        {\n-            index = indexOf(key);\n-        }\n-        if (key == null)\n-        {\n-            key = get(index);\n-        }\n-        if (index != UNKNOWN_INDEX)\n-        {\n-            keySequence.remove(index);\n-        }\n-        return super.remove(key);\n-    }\n+     *  @exception IllegalStateException if there isn't a \"last element\" to be\n+     *  removed.  That is, if {@link #next()} has never been called, or if\n+     *  {@link #remove()} was already called on the element.\n+     **/\n+    public void remove() {\n+      if((returnType & REMOVED_MASK) != 0) {\n+        throw new IllegalStateException(\"remove() must follow next()\");\n+      }\n+\n+      // remove the entry\n+      SequencedHashMap.this.remove(pos.getKey());\n+\n+      // set the removed flag\n+      returnType = returnType | REMOVED_MASK;\n+    }\n+  }\n+\n+  // APIs maintained from previous version of SequencedHashMap for backwards\n+  // compatibility\n+\n+  /**\n+   * Creates a shallow copy of this object, preserving the internal structure\n+   * by copying only references.  The keys and values themselves are not\n+   * <code>clone()</code>'d.  The cloned object maintains the same sequence.\n+   *\n+   * @return A clone of this instance.  \n+   */\n+  public Object clone () {\n+    // yes, calling super.clone() silly since we're just blowing away all\n+    // the stuff that super might be doing anyway, but for motivations on\n+    // this, see:\n+    // http://www.javaworld.com/javaworld/jw-01-1999/jw-01-object.html\n+    SequencedHashMap map = (SequencedHashMap)super.clone();\n+\n+    // create new, empty sentinel\n+    map.sentinel = createSentinel();\n+\n+    // create a new, empty entry map\n+    // note: this does not preserve the initial capacity and load factor.\n+    map.entries = new HashMap();\n+      \n+    // add all the mappings\n+    map.putAll(this);\n+\n+    // Note: We cannot just clone the hashmap and sentinel because we must\n+    // duplicate our internal structures.  Cloning those two will not clone all\n+    // the other entries they reference, and so the cloned hash map will not be\n+    // able to maintain internal consistency because there are two objects with\n+    // the same entries.  See discussion in the Entry implementation on why we\n+    // cannot implement a clone of the Entry (and thus why we need to recreate\n+    // everything).\n+\n+    return map;\n+  }\n+\n+  /**\n+   *  Returns the Map.Entry at the specified index\n+   *\n+   *  @exception ArrayIndexOutOfBoundsException if the specified index is\n+   *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+   **/\n+  private Map.Entry getEntry(int index) {\n+    Entry pos = sentinel;\n+\n+    if(index < 0) {\n+      throw new ArrayIndexOutOfBoundsException(index + \" < 0\");\n+    }\n+\n+    // loop to one before the position\n+    int i = -1;\n+    while(i < (index-1) && pos.next != sentinel) {\n+      i++;\n+      pos = pos.next;\n+    }\n+    // pos.next is the requested position\n+    \n+    // if sentinel is next, past end of list\n+    if(pos.next == sentinel) {\n+      throw new ArrayIndexOutOfBoundsException(index + \" >= \" + (i + 1));\n+    }\n+\n+    return pos.next;\n+  }\n+\n+  /**\n+   * Returns the key at the specified index.\n+   *\n+   *  @exception ArrayIndexOutOfBoundsException if the <code>index</code> is\n+   *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+   */\n+  public Object get (int index)\n+  {\n+    return getEntry(index).getKey();\n+  }\n+\n+  /**\n+   * Returns the value at the specified index.\n+   *\n+   *  @exception ArrayIndexOutOfBoundsException if the <code>index</code> is\n+   *  <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+   */\n+  public Object getValue (int index)\n+  {\n+    return getEntry(index).getValue();\n+  }\n+\n+  /**\n+   * Returns the index of the specified key.\n+   */\n+  public int indexOf (Object key)\n+  {\n+    Entry e = (Entry)entries.get(key);\n+    int pos = 0;\n+    while(e.prev != sentinel) {\n+      pos++;\n+      e = e.prev;\n+    }\n+    return pos;\n+  }\n+\n+  /**\n+   * Returns a key iterator.\n+   */\n+  public Iterator iterator ()\n+  {\n+    return keySet().iterator();\n+  }\n+\n+  /**\n+   * Returns the last index of the specified key.\n+   */\n+  public int lastIndexOf (Object key)\n+  {\n+    // keys in a map are guarunteed to be unique\n+    return indexOf(key);\n+  }\n+\n+  /**\n+   * Returns a List view of the keys rather than a set view.  The returned\n+   * list is unmodifiable.  This is required because changes to the values of\n+   * the list (using {@link java.util.ListIterator#set(Object)}) will\n+   * effectively remove the value from the list and reinsert that value at\n+   * the end of the list, which is an unexpected side effect of changing the\n+   * value of a list.  This occurs because changing the key, changes when the\n+   * mapping is added to the map and thus where it appears in the list.\n+   *\n+   * <P>An alternative to this method is to use {@link #keySet()}\n+   *\n+   * @see #keySet()\n+   * @return The ordered list of keys.  \n+   */\n+  public List sequence()\n+  {\n+    List l = new ArrayList(size());\n+    Iterator iter = keySet().iterator();\n+    while(iter.hasNext()) {\n+      l.add(iter.next());\n+    }\n+      \n+    return Collections.unmodifiableList(l);\n+  }\n+\n+  /**\n+   * Removes the element at the specified index.\n+   *\n+   * @param index The index of the object to remove.\n+   * @return      The previous value coressponding the <code>key</code>, or\n+   *              <code>null</code> if none existed.\n+   *\n+   * @exception ArrayIndexOutOfBoundsException if the <code>index</code> is\n+   * <code>&lt; 0</code> or <code>&gt;</code> the size of the map.\n+   */\n+  public Object remove (int index)\n+  {\n+    return remove(get(index));\n+  }\n+\n }\n-", "timestamp": 1014064497, "metainfo": ""}