{"sha": "60a3e7c07aa7ac8102ee5b31fbdebb2c6c84f609", "log": "Cleanup of splitmap package.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/SplitMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.IterableGet;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections.map.EntrySetToMapIteratorAdapter;\n+import org.apache.commons.collections.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Utilities for working with \"split maps:\" objects that implement {@link Put}\n+ * and/or {@link Get} but not {@link Map}.\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Id$\n+ *\n+ * @see Get\n+ * @see Put\n+ */\n+public class SplitMapUtils {\n+\n+    /**\n+     * <code>SplitMapUtils</code> should not normally be instantiated.\n+     */\n+    public SplitMapUtils() {\n+    }\n+\n+    private static class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n+        private final Get<K, V> get;\n+\n+        private WrappedGet(Get<K, V> get) {\n+            this.get = get;\n+        }\n+\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            return get.containsKey(key);\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            return get.containsValue(value);\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n+        }\n+\n+        @Override\n+        public boolean equals(Object arg0) {\n+            if (arg0 == this) {\n+                return true;\n+            }\n+            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(this.get);\n+        }\n+\n+        public V get(Object key) {\n+            return get.get(key);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedGet\".hashCode() << 4) | get.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            return get.isEmpty();\n+        }\n+\n+        public Set<K> keySet() {\n+            return UnmodifiableSet.unmodifiableSet(get.keySet());\n+        }\n+\n+        public V put(K key, V value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V remove(Object key) {\n+            return get.remove(key);\n+        }\n+\n+        public int size() {\n+            return get.size();\n+        }\n+\n+        public Collection<V> values() {\n+            return UnmodifiableCollection.unmodifiableCollection(get.values());\n+        }\n+\n+        public MapIterator<K, V> mapIterator() {\n+            MapIterator<K, V> it;\n+            if (get instanceof IterableGet) {\n+                it = ((IterableGet<K, V>) get).mapIterator();\n+            } else {\n+                it = new EntrySetToMapIteratorAdapter<K, V>(get.entrySet());\n+            }\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+        }\n+    }\n+\n+    private static class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n+        private final Put<K, V> put;\n+\n+        private WrappedPut(Put<K, V> put) {\n+            this.put = put;\n+        }\n+\n+        public void clear() {\n+            put.clear();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(this.put);\n+        }\n+\n+        public V get(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedPut\".hashCode() << 4) | put.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<K> keySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V put(K key, V value) {\n+            return (V) put.put(key, value);\n+        }\n+\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+            put.putAll(t);\n+        }\n+\n+        public V remove(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int size() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Collection<V> values() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Get the specified {@link Get} as an instance of {@link IterableMap}.\n+     * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n+     * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n+     * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n+     * @param <K>\n+     * @param <V>\n+     * @param get to wrap, must not be null\n+     * @return {@link IterableMap}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> IterableMap<K, V> readableMap(Get<K, V> get) {\n+        if (get == null) {\n+            throw new IllegalArgumentException(\"Get must not be null\");\n+        }\n+        if (get instanceof Map) {\n+            return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils\n+                    .iterableMap((Map<K, V>) get);\n+        }\n+        return new WrappedGet<K, V>(get);\n+    }\n+\n+    /**\n+     * Get the specified {@link Put} as an instanceof {@link Map}.\n+     * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n+     * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n+     * it is recommended that the result of #put(K, V) be discarded as it likely will not\n+     * match <code>V</code> at runtime.\n+     *\n+     * @param <K>\n+     * @param <V>\n+     * @param put to wrap, must not be null\n+     * @return {@link Map}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> Map<K, V> writableMap(Put<K, V> put) {\n+        if (put == null) {\n+            throw new IllegalArgumentException(\"Put must not be null\");\n+        }\n+        if (put instanceof Map) {\n+            return (Map<K, V>) put;\n+        }\n+        return new WrappedPut<K, V>(put);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections.Get;\n import org.apache.commons.collections.IterableGet;\n import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.map.EntrySetToMapIteratorAdapter;\n \n /**\n- * {@link IterableGet} that uses a {@link Map}<K, V> for the {@link Get}<K, V>\n- * implementation.\n+ * {@link IterableGet} that uses a {@link Map}<K, V> for the\n+ * {@link org.apache.commons.collections.Get Get}<K, V> implementation.\n  *\n  * @since Commons Collections 4.0\n- * @version $Revision$\n- *\n- * @author Matt Benson\n+ * @version $Id$\n  */\n public class AbstractIterableGetMapDecorator<K, V> implements IterableGet<K, V> {\n+\n     /** The map to decorate */\n     protected transient Map<K, V> map;\n \n--- a/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n import org.apache.commons.collections.map.LinkedMap;\n \n /**\n- * Decorates another <code>Map</code> to transform objects that are added.\n+ * Decorates another {@link Map} to transform objects that are added.\n  * <p>\n  * The Map put methods and Map.Entry setValue method are affected by this class.\n  * Thus objects must be removed or searched for using their transformed form.\n  * generalizations.\n  *\n  * @since Commons Collections 4.0\n- * @version $Revision$\n+ * @version $Id$\n+ *\n  * @see SplitMapUtils#readableMap(Get)\n  * @see SplitMapUtils#writableMap(Put)\n- *\n- * @author Stephen Colebourne\n- * @author Matt Benson\n  */\n-public class TransformedMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V> implements\n-        Put<J, U>, Serializable {\n+public class TransformedMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V>\n+        implements Put<J, U>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 5966875321133456994L;\n      * The transformer itself may throw an exception if necessary.\n      *\n      * @param object the object to transform\n-     * @throws the transformed object\n+     * @return the transformed object\n      */\n     protected K transformKey(J object) {\n         return keyTransformer.transform(object);\n      * The transformer itself may throw an exception if necessary.\n      *\n      * @param object the object to transform\n-     * @throws the transformed object\n+     * @return the transformed object\n      */\n     protected V transformValue(U object) {\n         return valueTransformer.transform(object);\n      * The transformer itself may throw an exception if necessary.\n      *\n      * @param map the map to transform\n-     * @throws the transformed object\n+     * @return the transformed object\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected Map<K, V> transformMap(Map<? extends J, ? extends U> map) {\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/splitmap/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * The \"split map\" concept is that of an object that implements\n+ * the {@link org.apache.commons.collections.Put Put} and\n+ * {@link org.apache.commons.collections.Get Get} interfaces,\n+ * with <i>differing</i> generic types. This is like a pre-generics\n+ * {@link java.util.Map Map} whose input key/value constraints are\n+ * different than its output key/value constraints.  While it would\n+ * be possible to declare a \"split map\" with matching input/output\n+ * key/value constraints, this would be a {@link java.util.Map Map}\n+ * and would therefore make little sense (any Commons Collections\n+ * {@link java.util.Map Map} implementation will also implement\n+ * {@link org.apache.commons.collections.Put Put} and\n+ * {@link org.apache.commons.collections.Get Get} with matching\n+ * generic parameters).\n+ * <p>\n+ * The following decorators are provided:\n+ * <ul>\n+ *   <li>Transformed - transforms each element added\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections.splitmap;", "timestamp": 1341350665, "metainfo": ""}