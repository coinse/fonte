{"sha": "76d2a092424d840e5107da99865dfd0e4b19caa3", "log": "Add list view methods to ordered maps   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java,v 1.2 2003/12/25 01:09:01 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java,v 1.3 2003/12/28 22:45:47 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/12/25 01:09:01 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/28 22:45:47 $\n  *\n  * @author java util LinkedHashMap\n  * @author Stephen Colebourne\n \n     //-----------------------------------------------------------------------    \n     /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected LinkEntry getEntry(int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index \" + index + \" is less than zero\");\n+        }\n+        if (index >= size) {\n+            throw new IndexOutOfBoundsException(\"Index \" + index + \" is invalid for size \" + size);\n+        }\n+        LinkEntry entry;\n+        if (index < (size / 2)) {\n+            // Search forwards\n+            entry = header.after;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                entry = entry.after;\n+            }\n+        } else {\n+            // Search backwards\n+            entry = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                entry = entry.before;\n+            }\n+        }\n+        return entry;\n+    }\n+    \n+    /**\n      * Adds an entry into this map, maintaining insertion order.\n      * <p>\n      * This implementation adds the entry to the data storage table and\n     /**\n      * MapIterator implementation.\n      */\n-    protected static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n+    static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n         \n         LinkMapIterator(AbstractLinkedMap map) {\n             super(map);\n     /**\n      * EntrySet iterator.\n      */\n-    protected static class EntrySetIterator extends LinkIterator {\n+    static class EntrySetIterator extends LinkIterator {\n         \n         EntrySetIterator(AbstractLinkedMap map) {\n             super(map);\n     /**\n      * KeySet iterator.\n      */\n-    protected static class KeySetIterator extends EntrySetIterator {\n+    static class KeySetIterator extends EntrySetIterator {\n         \n         KeySetIterator(AbstractLinkedMap map) {\n             super(map);\n     /**\n      * Values iterator.\n      */\n-    protected static class ValuesIterator extends LinkIterator {\n+    static class ValuesIterator extends LinkIterator {\n         \n         ValuesIterator(AbstractLinkedMap map) {\n             super(map);\n     \n     //-----------------------------------------------------------------------\n     /**\n-     * LinkEntry\n+     * LinkEntry that stores the data.\n      */\n     protected static class LinkEntry extends HashEntry {\n         \n+        /** The entry before this one in the order */\n         protected LinkEntry before;\n+        /** The entry after this one in the order */\n         protected LinkEntry after;\n         \n+        /**\n+         * Constructs a new entry.\n+         * \n+         * @param next  the next entry in the hash bucket sequence\n+         * @param hashCode  the hash code\n+         * @param key  the key\n+         * @param value  the value\n+         */\n         protected LinkEntry(HashEntry next, int hashCode, Object key, Object value) {\n             super(next, hashCode, key, value);\n         }\n     }\n     \n     /**\n-     * Base Iterator\n+     * Base Iterator that iterates in link order.\n      */\n     protected static abstract class LinkIterator\n             implements OrderedIterator, ResettableIterator {\n                 \n+        /** The parent map */\n         protected final AbstractLinkedMap map;\n+        /** The current (last returned) entry */\n         protected LinkEntry current;\n+        /** The next entry */\n         protected LinkEntry next;\n+        /** The modification count expected */\n         protected int expectedModCount;\n         \n         protected LinkIterator(AbstractLinkedMap map) {\n         public boolean hasNext() {\n             return (next != map.header);\n         }\n-\n+        \n         public boolean hasPrevious() {\n             return (next.before != map.header);\n         }\n--- a/src/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.5 2003/12/28 17:58:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.6 2003/12/28 22:45:47 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n import java.util.Map;\n+\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableListIterator;\n+import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n  * A <code>Map</code> implementation that maintains the order of the entries.\n- * In this implementation order is maintained is by original insertion.\n+ * In this implementation order is maintained by original insertion.\n  * <p>\n  * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n  * {@link org.apache.commons.collections.MapIterator MapIterator}\n  * functionality, additional convenience methods and allowing\n  * bidirectional iteration. It also implements <code>OrderedMap</code>.\n+ * In addition, non-interface methods are provided to access the map by index.\n  * <p>\n  * The <code>orderedMapIterator()</code> method provides direct access to a\n  * bidirectional iterator. The iterators from the other views can also be cast\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2003/12/28 17:58:54 $\n+ * @version $Revision: 1.6 $ $Date: 2003/12/28 22:45:47 $\n  *\n  * @author Stephen Colebourne\n  */\n         doReadObject(in);\n     }\n     \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object get(int index) {\n+        return getEntry(index).getKey();\n+    }\n+    \n+    /**\n+     * Gets the value at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object getValue(int index) {\n+        return getEntry(index).getValue();\n+    }\n+    \n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(Object key) {\n+        key = convertKey(key);\n+        int i = 0;\n+        for (LinkEntry entry = header.after; entry != header; entry = entry.after, i++) {\n+            if (isEqualKey(key, entry.key)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index of the object to remove\n+     * @return the previous value corresponding the <code>key</code>,\n+     *  or <code>null</code> if none existed\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object remove(int index) {\n+        return remove(get(index));\n+    }\n+\n+    /**\n+     * Gets an unmodifiable List view of the keys.\n+     * <p>\n+     * The returned list is unmodifiable because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     * <p>\n+     * An alternative to this method is to use {@link #keySet()}.\n+     *\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List asList() {\n+        return new LinkedMapList(this);\n+    }\n+\n+    /**\n+     * List view of map.\n+     */\n+    static class LinkedMapList extends AbstractList {\n+        \n+        final LinkedMap parent;\n+        \n+        LinkedMapList(LinkedMap parent) {\n+            this.parent = parent;\n+        }\n+        \n+        public int size() {\n+            return parent.size();\n+        }\n+    \n+        public Object get(int index) {\n+            return parent.get(index);\n+        }\n+        \n+        public boolean contains(Object obj) {\n+            return parent.containsKey(obj);\n+        }\n+\n+        public int indexOf(Object obj) {\n+            return parent.indexOf(obj);\n+        }\n+        \n+        public int lastIndexOf(Object obj) {\n+            return parent.indexOf(obj);\n+        }\n+        \n+        public boolean containsAll(Collection coll) {\n+            return parent.keySet().containsAll(coll);\n+        }\n+        \n+        public Object remove(int index) {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        public boolean remove(Object obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        public boolean removeAll(Collection coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        public boolean retainAll(Collection coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+        public Object[] toArray() {\n+            return parent.keySet().toArray();\n+        }\n+\n+        public Object[] toArray(Object[] array) {\n+            return parent.keySet().toArray(array);\n+        }\n+        \n+        public Iterator iterator() {\n+            return UnmodifiableIterator.decorate(parent.keySet().iterator());\n+        }\n+        \n+        public ListIterator listIterator() {\n+            return UnmodifiableListIterator.decorate(super.listIterator());\n+        }\n+        \n+        public ListIterator listIterator(int fromIndex) {\n+            return UnmodifiableListIterator.decorate(super.listIterator(fromIndex));\n+        }\n+        \n+        public List subList(int fromIndexInclusive, int toIndexExclusive) {\n+            return UnmodifiableList.decorate(super.subList(fromIndexInclusive, toIndexExclusive));\n+        }\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.8 2003/12/07 23:59:13 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.9 2003/12/28 22:45:47 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.ResettableIterator;\n import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n import org.apache.commons.collections.keyvalue.AbstractMapEntry;\n+import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n  * Decorates a <code>Map</code> to ensure that the order of addition is retained.\n  * The order is also returned by the <code>MapIterator</code>.\n  * The <code>orderedMapIterator()</code> method accesses an iterator that can\n  * iterate both forwards and backwards through the map.\n+ * In addition, non-interface methods are provided to access the map by index.\n  * <p>\n  * If an object is added to the Map for a second time, it will remain in the\n  * original position in the iteration.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.8 $ $Date: 2003/12/07 23:59:13 $\n+ * @version $Revision: 1.9 $ $Date: 2003/12/28 22:45:47 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n     }\n \n     //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object get(int index) {\n+        return insertOrder.get(index);\n+    }\n+    \n+    /**\n+     * Gets the value at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object getValue(int index) {\n+        return get(insertOrder.get(index));\n+    }\n+    \n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(Object key) {\n+        return insertOrder.indexOf(key);\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index of the object to remove\n+     * @return the previous value corresponding the <code>key</code>,\n+     *  or <code>null</code> if none existed\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object remove(int index) {\n+        return remove(get(index));\n+    }\n+\n+    /**\n+     * Gets an unmodifiable List view of the keys which changes as the map changes.\n+     * <p>\n+     * The returned list is unmodifiable because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     * <p>\n+     * An alternative to this method is to use {@link #keySet()}.\n+     *\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List asList() {\n+        return UnmodifiableList.decorate(insertOrder);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     static class ValuesView extends AbstractCollection {\n         private final ListOrderedMap parent;\n \n--- a/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLinkedMap.java,v 1.3 2003/12/07 23:59:12 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLinkedMap.java,v 1.4 2003/12/28 22:45:47 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.textui.TestRunner;\n \n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedMap;\n import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.list.AbstractTestList;\n \n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/12/07 23:59:12 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/28 22:45:47 $\n  * \n  * @author Stephen Colebourne\n  */\n         assertSame(values[2], it.next());\n     }\n     \n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        LinkedMap lm = (LinkedMap) map;\n+        try {\n+            lm.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        resetFull();\n+        lm = (LinkedMap) map;\n+        try {\n+            lm.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        int i = 0;\n+        for (MapIterator it = lm.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lm.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        LinkedMap lm = (LinkedMap) map;\n+        try {\n+            lm.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        resetFull();\n+        lm = (LinkedMap) map;\n+        try {\n+            lm.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        int i = 0;\n+        for (MapIterator it = lm.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lm.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        LinkedMap lm = (LinkedMap) map;\n+        assertEquals(-1, lm.indexOf(getOtherKeys()));\n+        \n+        resetFull();\n+        lm = (LinkedMap) map;\n+        List list = new ArrayList();\n+        for (MapIterator it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lm.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        LinkedMap lm = (LinkedMap) map;\n+        try {\n+            lm.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        resetFull();\n+        lm = (LinkedMap) map;\n+        try {\n+            lm.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        List list = new ArrayList();\n+        for (MapIterator it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lm.get(key);\n+            assertEquals(value, lm.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lm.containsKey(key));\n+        }\n+    }\n+    \n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+    \n+    public class TestListView extends AbstractTestList {\n+        \n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        public List makeEmptyList() {\n+            return ((LinkedMap) TestLinkedMap.this.makeEmptyMap()).asList();\n+        }\n+        \n+        public List makeFullList() {\n+            return ((LinkedMap) TestLinkedMap.this.makeFullMap()).asList();\n+        }\n+        \n+        public Object[] getFullElements() {\n+            return TestLinkedMap.this.getSampleKeys();\n+        }\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        public boolean isNullSupported() {\n+            return TestLinkedMap.this.isAllowNullKey();\n+        }\n+\n+    }\n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n--- a/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestListOrderedMap.java,v 1.5 2003/11/20 22:34:49 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestListOrderedMap.java,v 1.6 2003/12/28 22:45:47 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.map;\n \n+import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n import junit.framework.Test;\n \n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.list.AbstractTestList;\n \n /**\n  * Extension of {@link TestMap} for exercising the {@link ListOrderedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2003/11/20 22:34:49 $\n+ * @version $Revision: 1.6 $ $Date: 2003/12/28 22:45:47 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n     public Map makeEmptyMap() {\n         return ListOrderedMap.decorate(new HashMap());\n     }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap lom = (ListOrderedMap) map;\n+        try {\n+            lom.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        resetFull();\n+        lom = (ListOrderedMap) map;\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        int i = 0;\n+        for (MapIterator it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap lom = (ListOrderedMap) map;\n+        try {\n+            lom.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        resetFull();\n+        lom = (ListOrderedMap) map;\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        int i = 0;\n+        for (MapIterator it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap lom = (ListOrderedMap) map;\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+        \n+        resetFull();\n+        lom = (ListOrderedMap) map;\n+        List list = new ArrayList();\n+        for (MapIterator it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap lom = (ListOrderedMap) map;\n+        try {\n+            lom.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        resetFull();\n+        lom = (ListOrderedMap) map;\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        List list = new ArrayList();\n+        for (MapIterator it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+    \n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+    \n+    public class TestListView extends AbstractTestList {\n+        \n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        public List makeEmptyList() {\n+            return ((ListOrderedMap) TestListOrderedMap.this.makeEmptyMap()).asList();\n+        }\n+        \n+        public List makeFullList() {\n+            return ((ListOrderedMap) TestListOrderedMap.this.makeFullMap()).asList();\n+        }\n+        \n+        public Object[] getFullElements() {\n+            return TestListOrderedMap.this.getSampleKeys();\n+        }\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        public boolean isNullSupported() {\n+            return TestListOrderedMap.this.isAllowNullKey();\n+        }\n+\n+    }\n \n }", "timestamp": 1072651547, "metainfo": ""}