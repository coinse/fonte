{"sha": "084754f692073f308b2a317e333607b3182ba58e", "log": "Improve debugPrint() and verbosePrint() bug 20740, from Arun Mammen Thomas   ", "commit": "\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.26 2003/08/20 21:03:16 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.27 2003/08/24 09:47:19 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *  </ul>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.26 $ $Date: 2003/08/20 21:03:16 $\n+ * @version $Revision: 1.27 $ $Date: 2003/08/24 09:47:19 $\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n  * @author Arun Mammen Thomas\n  * @author Janek Bogucki\n  * @author Max Rydahl Andersen\n+ * @author Arun Mammen Thomas\n  */\n public class MapUtils {\n     \n      */\n     public static final SortedMap EMPTY_SORTED_MAP = Collections.unmodifiableSortedMap(new TreeMap());\n \n-    private static int debugIndent = 0;\n+    private static int indentDepth = 0;  // must be synchronized\n+\n+    private static final String INDENT_STRING = \"    \";\n \n     /**\n      * <code>MapUtils</code> should not normally be instantiated.\n     //-------------------------------------------------------------------------\n \n     /**\n-     *  Prints the given map with nice line breaks.\n-     *\n-     *  @param out  the stream to print to\n-     *  @param label  the label to be applied to the output generated.  This \n-     *                 may well be the key associated with this map within a \n-     *                 surrounding map in which this is nested.   \n-     *  @param map  the map to print\n+     * Prints the given map with nice line breaks.\n+     * <p>\n+     * This method prints a nicely formatted String decribing the Map.\n+     * Each map entry will be printed with key and value.\n+     * When the value is a Map, recursive behaviour occurs.\n+     *\n+     * @param out  the stream to print to, must not be null\n+     * @param label  the label to be applied to the output generated.  This \n+     *              may well be the key associated with this map within a \n+     *              surrounding map in which this is nested.   \n+     * @param map  the map to print, may be null\n+     * @throws NullPointerException if the stream is null\n      */\n     public static synchronized void verbosePrint(\n         final PrintStream out,\n         final Object label,\n         final Map map) {\n \n+        indentDepth = 0;\n         verbosePrintInternal(out, label, map, false);\n     }\n \n     /**\n-     *  Prints the given map with nice line breaks.\n-     *\n-     *  @param out  the stream to print to\n-     *  @param label  the label to be applied to the output generated.  This \n-     *                 may well be the key associated with this map within a \n-     *                 surrounding map in which this is nested.   \n-     *  @param map  the map to print\n+     * Prints the given map with nice line breaks.\n+     * <p>\n+     * This method prints a nicely formatted String decribing the Map.\n+     * Each map entry will be printed with key, value and value classname.\n+     * When the value is a Map, recursive behaviour occurs.\n+     *\n+     * @param out  the stream to print to, must not be null\n+     * @param label  the label to be applied to the output generated.  This \n+     *              may well be the key associated with this map within a \n+     *              surrounding map in which this is nested.   \n+     * @param map  the map to print, may be null\n+     * @throws NullPointerException if the stream is null\n      */\n     public static synchronized void debugPrint(\n         final PrintStream out,\n         final Object label,\n         final Map map) {\n \n+        indentDepth = 0;\n         verbosePrintInternal(out, label, map, true);\n     }\n \n      *\n      * @param out  the stream to indent\n      */\n-    protected static void debugPrintIndent(PrintStream out) {\n-        for (int i = 0; i < debugIndent; i++) {\n-            out.print(\"    \");\n+    protected static void printIndent(PrintStream out) {\n+        for (int i = 0; i < indentDepth; i++) {\n+            out.print(INDENT_STRING);\n         }\n     }\n     \n      * Implementation providing functionality for {@link #debugPrint} and for \n      * {@link #verbosePrint}.  This prints the given map with nice line breaks.\n      * If the debug flag is true, it additionally prints the type of the object \n-     * value.  .\n+     * value.\n      *\n      * @param out  the stream to print to\n      * @param label  the label to be applied to the output generated.  This \n-     *                may well be the key associated with this map within a \n-     *                surrounding map in which this is nested.   \n-     * @param map  the map to print\n+     *              may well be the key associated with this map within a \n+     *              surrounding map in which this is nested.   \n+     * @param map  the map to print, may be null\n      * @param debug flag indicating whether type names should be output.\n      */\n-    private static void verbosePrintInternal(\n+    private static void verbosePrintInternal(  // externally synchronized\n         final PrintStream out,\n         final Object label,\n         final Map map,\n         final boolean debug) {\n \n-        debugPrintIndent(out);\n-        out.println(label + \" = \");\n-\n-        debugPrintIndent(out);\n+        printIndent(out);\n+\n+        if (label != null) {\n+            if (map == null) {\n+                // Guard against null map.\n+                out.println(label + \" = null\");\n+                return;\n+            } else {\n+                out.println(label + \" = \");\n+            }            \n+        }\n+        if (map == null) {\n+            return;\n+        }\n+\n+        printIndent(out);\n         out.println(\"{\");\n-        ++debugIndent;\n-\n-        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {\n-            Map.Entry entry = (Map.Entry) iter.next();\n+        indentDepth++;\n+\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n             Object childKey = entry.getKey();\n             Object childValue = entry.getValue();\n             if (childValue instanceof Map) {\n-                verbosePrintInternal(out, childKey, (Map) childValue, false);\n+                if (childValue == map) {\n+                    printIndent(out);\n+                    out.println(childKey + \" = this Map\");  // should have stack really...\n+                } else {\n+                    verbosePrintInternal(out, childKey, (Map) childValue, debug);\n+                }\n             } else {\n-                debugPrintIndent(out);\n-\n-                if (debug) {\n-                    String typeName =\n-                        (childValue != null)\n-                            ? childValue.getClass().getName()\n-                            : null;\n-\n+                printIndent(out);\n+\n+                if (debug && childValue != null) {\n                     out.println(\n-                        childKey + \" = \" + childValue + \" class: \" + typeName);\n+                        childKey \n+                        + \" = \" \n+                        + childValue \n+                        + \" \" \n+                        + childValue.getClass().getName()\n+                    );\n                 } else {\n                     out.println(childKey + \" = \" + childValue);\n                 }\n             }\n         }\n-        --debugIndent;\n-        debugPrintIndent(out);\n-        out.println(\"}\");\n+        indentDepth--;\n+        printIndent(out);\n+        out.println(debug ? \"} \" + map.getClass().getName() : \"}\");\n     }\n \n     // Misc\n--- a/src/test/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.6 2003/08/20 21:03:16 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.7 2003/08/24 09:47:19 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Map;\n import java.util.ResourceBundle;\n import java.util.Set;\n+import java.util.TreeMap;\n \n import junit.framework.Test;\n \n /**\n  * Tests for MapUtils.\n  * \n- * @version $Revision: 1.6 $ $Date: 2003/08/20 21:03:16 $\n+ * @version $Revision: 1.7 $ $Date: 2003/08/24 09:47:19 $\n  * \n  * @author Stephen Colebourne\n  * @author Arun Mammen Thomas\n             fail(\"No Casting should be occurring!\");\n         }\n     }\n+\n+    public void testDebugAndVerbosePrintNullMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        outPrint.println(LABEL + \" = \" + String.valueOf((Object) null));\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();            \n+\n+        MapUtils.debugPrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+        \n+        out.reset();\n+        \n+        MapUtils.verbosePrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map map = new TreeMap();  // treeMap guarantees order across JDKs for test\n+        map.put( new Integer(2) , \"B\" );\n+        map.put( new Integer(3) , \"C\" );\n+        \n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"3 = C\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+            \n+    public void testDebugPrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map map = new TreeMap();  // treeMap guarantees order across JDKs for test\n+        map.put( new Integer(2) , \"B\" );\n+        map.put( new Integer(3) , \"C\" );\n+    \n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+        \n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        MapUtils.verbosePrint(outPrint, null, null);\n+        assertEquals(\"\", out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        MapUtils.debugPrint(outPrint, null, null);\n+        assertEquals(\"\", out.toString());\n+    }\n+\n+    public void testVerbosePrintNullStream() {\n+        try {\n+            MapUtils.verbosePrint(null, \"Map\", new HashMap());\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+    \n+    public void testDebugPrintNullStream() {\n+        try {\n+            MapUtils.debugPrint(null, \"Map\", new HashMap());\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+    \n+    public void testVerbosePrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+        \n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+        \n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(INDENT + \"7 = this Map\");\n+        outPrint.println(\"}\");\n+        \n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();            \n+\n+        final Map inner = new TreeMap();  // treeMap guarantees order across JDKs for test\n+        inner.put( new Integer(2) , \"B\" );\n+        inner.put( new Integer(3) , \"C\" );\n+\n+        final Map outer = new TreeMap();\n+        outer.put( new Integer(1) , inner );\n+        outer.put( new Integer(0) , \"A\");\n+        outer.put( new Integer(7) , outer);\n+\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+        \n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+        \n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"7 = this Map\");\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+        \n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();            \n+\n+        final Map inner = new TreeMap();  // treeMap guarantees order across JDKs for test\n+        inner.put( new Integer(2) , \"B\" );\n+        inner.put( new Integer(3) , \"C\" );\n+\n+        final Map outer = new TreeMap();\n+        outer.put( new Integer(1) , inner );\n+        outer.put( new Integer(0) , \"A\");\n+        outer.put( new Integer(7) , outer);\n+\n+        MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n }", "timestamp": 1061718439, "metainfo": ""}