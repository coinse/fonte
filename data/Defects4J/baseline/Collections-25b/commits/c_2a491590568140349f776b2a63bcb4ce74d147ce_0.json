{"sha": "2a491590568140349f776b2a63bcb4ce74d147ce", "log": "A few minor changes :  1) replaced with the current version from velocity's CVS - this is a few changes by dan  2) added the recent patch from Ilkka for dealing with encoded properties PR: Obtained from: Submitted by: Reviewed by:   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n  *\n  */\n \n+\n import java.io.IOException;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.OutputStream;\n import java.io.PrintWriter;\n import java.io.Reader;\n+import java.io.UnsupportedEncodingException;\n \n import java.util.ArrayList;\n import java.util.Enumeration;\n  * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n  * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n  * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n- * @version $Id: ExtendedProperties.java,v 1.1 2001/04/16 05:01:03 geirm Exp $\n+ * @author <a href=\"mailto:kjohnson@transparent.com>Kent Johnson</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com>Daniel Rall</a>\n+ * @author <a href=\"mailto:ipriha@surfeu.fi>Ilkka Priha</a>\n+ * @version $Id: ExtendedProperties.java,v 1.2 2001/05/04 02:22:48 geirm Exp $\n  */\n public class ExtendedProperties extends Hashtable\n {\n \n     /**\n      * Base path of the configuration file used to create\n-     * this Configuration object.\n+     * this ExtendedProperties object.\n      */\n     protected String basePath;\n \n     class PropertiesTokenizer extends StringTokenizer\n     {\n         /**\n+         * The property delimiter used while parsing (a comma).\n+         */\n+        static final String DELIMITER = \",\";\n+\n+        /**\n          * Constructor.\n          *\n          * @param string A String.\n          */\n         public PropertiesTokenizer(String string)\n         {\n-            super(string, \",\");\n+            super(string, DELIMITER);\n         }\n \n         /**\n                 if (token.endsWith(\"\\\\\"))\n                 {\n                     buffer.append(token.substring(0, token.length() - 1));\n-                    buffer.append(\",\");\n+                    buffer.append(DELIMITER);\n                 }\n                 else\n                 {\n     /**\n      * Creates an empty extended properties object.\n      */\n-    public ExtendedProperties ()\n+    public ExtendedProperties()\n     {\n         super();\n     }\n      * @param file A String.\n      * @exception IOException.\n      */\n-    public ExtendedProperties(String file) \n-        throws IOException\n+    public ExtendedProperties(String file) throws IOException\n     {\n         this(file,null);\n     }\n      * @param file A String.\n      * @exception IOException.\n      */\n-    public ExtendedProperties (String file, String defaultFile)\n+    public ExtendedProperties(String file, String defaultFile)\n         throws IOException\n     {\n         this.file = file;\n      * @param input An InputStream.\n      * @exception IOException.\n      */\n-    public synchronized void load(InputStream input)\n+    public void load( InputStream input )\n         throws IOException\n     {\n-        PropertiesReader reader =\n-            new PropertiesReader(new InputStreamReader(input));\n+        load(input,null);\n+    }\n+    \n+    /**\n+     * Load the properties from the given input stream\n+     * and using the specified encoding.\n+     *\n+     * @param input An InputStream.\n+     * @param enc An encoding.\n+     * @exception IOException.\n+     */\n+    public synchronized void load(InputStream input, String enc)\n+        throws IOException\n+    {\n+        PropertiesReader reader = null;\n+        if (enc != null)\n+        {\n+            try\n+            {\n+                reader =\n+                    new PropertiesReader(new InputStreamReader(input,enc));\n+            }\n+            catch (UnsupportedEncodingException e)\n+            {\n+                // Get one with the default encoding...\n+            }\n+        }\n+        \n+        if (reader == null)\n+        {\n+            reader =\n+                new PropertiesReader(new InputStreamReader(input));\n+        }\n \n         try\n         {\n              *  if there isn't a value there, get it from the\n              *  defaults if we have them\n              */\n-            \n             if (defaults != null)\n             {\n                 o = defaults.get(key);\n              * like that cannot parse multiple same key\n              * values.\n              */\n-            if (token instanceof String && ((String)token).indexOf(\",\") > 0)\n+            if (token instanceof String &&\n+                ((String)token).indexOf(PropertiesTokenizer.DELIMITER) > 0)\n             {\n                 PropertiesTokenizer tokenizer = \n                     new PropertiesTokenizer((String)token);\n      *\n      * Warning: It will overwrite previous entries without warning.\n      *\n-     * @param Configuration\n-     */\n-    public void combine( ExtendedProperties c)\n+     * @param ExtendedProperties\n+     */\n+    public void combine( ExtendedProperties c )\n     {\n         for (Iterator i = c.getKeys() ; i.hasNext() ;)\n         {\n     }\n \n     /**\n-     * Create a Configurations object that is a subset\n+     * Create an ExtendedProperties object that is a subset\n      * of this one. Take into account duplicate keys\n-     * by using the setProperty() in Configuration.\n+     * by using the setProperty() in ExtendedProperties.\n      *\n      * @param String prefix\n      */\n                 return defaultValue;\n             }\n         }\n+        else if (value instanceof Vector)\n+        {\n+            return (String) ((Vector) value).get(0);\n+        }\n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a String object\");\n+                '\\'' + key + \"' doesn't map to a String object\");\n         }\n     }\n \n             }\n             else\n             {\n-                throw new IllegalArgumentException(\"'\" +\n-                                                   token +\n+                throw new IllegalArgumentException('\\'' + token +\n                                                    \"' does not contain \" +\n                                                    \"an equals sign\");\n             }\n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a String/Vector object\");\n+                '\\'' + key + \"' doesn't map to a String/Vector object\");\n         }\n \n         String[] tokens = new String[vector.size()];\n         for (int i = 0; i < tokens.length; i++)\n-        tokens[i] = (String)vector.elementAt(i);\n+        {\n+            tokens[i] = (String)vector.elementAt(i);\n+        }\n \n         return tokens;\n     }\n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Vector object\");\n+                '\\'' + key + \"' doesn't map to a Vector object\");\n         }\n     }\n \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \"doesn't map to an existing object\");\n+                '\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Boolean object\");\n+                '\\'' + key + \"' doesn't map to a Boolean object\");\n         }\n     }\n     \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \" doesn't map to an existing object\");\n+                '\\'' + key + \" doesn't map to an existing object\");\n         }\n     }\n \n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Byte object\");\n+                '\\'' + key + \"' doesn't map to a Byte object\");\n         }\n     }\n \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \" doesn't map to an existing object\");\n+                '\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Short object\");\n+                '\\'' + key + \"' doesn't map to a Short object\");\n         }\n     }\n \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \" doesn't map to an existing object\");\n+                '\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n      */\n     public int getInteger(String key,\n                           int defaultValue)\n-    {\n-        return getInteger(key, new Integer(defaultValue)).intValue();\n-    }\n+    {    \n+        Integer i = getInteger(key, null);\n+        \n+        if (i == null)\n+        {\n+            return defaultValue;\n+        }\n+        \n+        return i.intValue();\n+      }\n+\n \n     /**\n      * Get a int associated with the given configuration key.\n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Integer object\");\n+                '\\'' + key + \"' doesn't map to a Integer object\");\n         }\n     }\n \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \" doesn't map to an existing object\");\n+                '\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Long object\");\n+                '\\'' + key + \"' doesn't map to a Long object\");\n         }\n     }\n \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \" doesn't map to an existing object\");\n+                '\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Float object\");\n+                '\\'' + key + \"' doesn't map to a Float object\");\n         }\n     }\n \n         else\n         {\n             throw new NoSuchElementException(\n-                key + \" doesn't map to an existing object\");\n+                '\\'' + key + \"' doesn't map to an existing object\");\n         }\n     }\n \n         else\n         {\n             throw new ClassCastException(\n-                key + \" doesn't map to a Double object\");\n+                '\\'' + key + \"' doesn't map to a Double object\");\n         }\n     }\n \n      * Convert a standard properties class into a configuration\n      * class.\n      *\n-     * @param Properties properties object to convert into\n-     *                   a Configuration object.\n-     *\n-     * @return Configuration configuration created from the\n+     * @param p properties object to convert into\n+     *                   a ExtendedProperties object.\n+     *\n+     * @return ExtendedProperties configuration created from the\n      *                      properties object.\n      */\n     public static ExtendedProperties convertProperties(Properties p)\n     {\n-         ExtendedProperties c = new ExtendedProperties();\n+        ExtendedProperties c = new ExtendedProperties();\n     \n         for (Enumeration e = p.keys(); e.hasMoreElements() ; ) \n         {", "timestamp": 988942968, "metainfo": ""}