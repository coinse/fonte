{"sha": "7f0c6e905a5e9b9b060dd7a0d135dfc52d2185b1", "log": "Remove again unneeded closing p tags to keep consistency.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/Bag.java\n+++ b/src/main/java/org/apache/commons/collections/Bag.java\n  * <p>\n  * Suppose you have a Bag that contains <code>{a, a, b, c}</code>.\n  * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n- * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.</p>\n+ * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n  * <p>\n  * <i>NOTE: This interface violates the {@link Collection} contract.</i> \n  * The behavior specified in many of these methods is <i>not</i> the same\n  * as the behavior specified by <code>Collection</code>.\n  * The noncompliant methods are clearly marked with \"(Violation)\".\n- * Exercise caution when using a bag as a <code>Collection</code>.</p>\n+ * Exercise caution when using a bag as a <code>Collection</code>.\n  * <p>\n  * This violation resulted from the original specification of this interface.\n  * In an ideal world, the interface would be changed to fix the problems, however\n- * it has been decided to maintain backwards compatibility instead.</p>\n+ * it has been decided to maintain backwards compatibility instead.\n  *\n  * @param <E> the type held in the bag\n  * @since Commons Collections 2.0\n      * <p>\n      * If the object is already in the {@link #uniqueSet()} then increment its\n      * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n-     * {@link #uniqueSet()} and report its count as 1.</p>\n+     * {@link #uniqueSet()} and report its count as 1.\n      * <p>\n      * Since this method always increases the size of the bag,\n      * according to the {@link Collection#add(Object)} contract, it \n      * should always return <code>true</code>.  Since it sometimes returns\n-     * <code>false</code>, this method violates the contract.</p>\n+     * <code>false</code>, this method violates the contract.\n      *\n      * @param object  the object to add\n      * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      * <p>\n      * If the object is already in the {@link #uniqueSet()} then increment its\n      * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n-     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.</p>\n+     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n      * \n      * @param object  the object to add\n      * @param nCopies  the number of copies to add\n      * <i>(Violation)</i>\n      * Removes all occurrences of the given object from the bag.\n      * <p>\n-     * This will also remove the object from the {@link #uniqueSet()}.</p>\n+     * This will also remove the object from the {@link #uniqueSet()}.\n      * <p>\n      * According to the {@link Collection#remove(Object)} method,\n      * this method should only remove the <i>first</i> occurrence of the\n-     * given object, not <i>all</i> occurrences.</p>\n+     * given object, not <i>all</i> occurrences.\n      *\n      * @param object  the object to remove\n      * @return <code>true</code> if this call changed the collection\n      * Removes <code>nCopies</code> copies of the specified object from the Bag.\n      * <p>\n      * If the number of copies to remove is greater than the actual number of\n-     * copies in the Bag, no error is thrown.</p>\n+     * copies in the Bag, no error is thrown.\n      * \n      * @param object  the object to remove\n      * @param nCopies  the number of copies to remove\n     /**\n      * Returns a {@link Set} of unique elements in the Bag.\n      * <p>\n-     * Uniqueness constraints are the same as those in {@link java.util.Set}.</p>\n+     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n      * \n      * @return the Set of unique Bag elements\n      */\n      * The {@link Collection#containsAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n      * return true if the bag contains at least one of every object contained\n-     * in the given collection.</p>\n+     * in the given collection.\n      * \n      * @param coll  the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      * <p>The {@link Collection#removeAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n      * remove <i>all</i> occurrences of every object contained in the \n-     * given collection.</p>\n+     * given collection.\n      *\n      * @param coll  the collection to remove\n      * @return <code>true</code> if this call changed the collection\n      * <p>The {@link Collection#retainAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n      * keep <i>all</i> occurrences of every object contained in the \n-     * given collection.</p>\n+     * given collection.\n      *\n      * @param coll  the collection to retain\n      * @return <code>true</code> if this call changed the collection\n--- a/src/main/java/org/apache/commons/collections/Buffer.java\n+++ b/src/main/java/org/apache/commons/collections/Buffer.java\n  * <p>\n  * The removal order can be based on insertion order (eg, a FIFO queue or a\n  * LIFO stack), on access order (eg, an LRU cache), on some arbitrary comparator\n- * (eg, a priority queue) or on any other well-defined ordering.</p>\n+ * (eg, a priority queue) or on any other well-defined ordering.\n  * <p>\n  * Note that the removal order is not necessarily the same as the iteration\n  * order.  A <code>Buffer</code> implementation may have equivalent removal\n- * and iteration orders, but this is not required.</p>\n+ * and iteration orders, but this is not required.\n  * <p>\n  * This interface does not specify any behavior for \n  * {@link Object#equals(Object)} and {@link Object#hashCode} methods.  It\n  * is therefore possible for a <code>Buffer</code> implementation to also\n  * also implement {@link java.util.List}, {@link java.util.Set} or \n- * {@link Bag}.</p>\n+ * {@link Bag}.\n  *\n  * @param <E> the type of the elements in the buffer\n  * @since Commons Collections 2.1\n--- a/src/main/java/org/apache/commons/collections/Closure.java\n+++ b/src/main/java/org/apache/commons/collections/Closure.java\n  * Defines a functor interface implemented by classes that do something.\n  * <p>\n  * A <code>Closure</code> represents a block of code which is executed from\n- * inside some block, function or iteration. It operates an input object.</p>\n+ * inside some block, function or iteration. It operates an input object.\n  * <p>\n  * Standard implementations of common closures are provided by\n- * {@link ClosureUtils}. These include method invocation and for/while loops.</p>\n+ * {@link ClosureUtils}. These include method invocation and for/while loops.\n  *\n  * @param <T> the type that the closure acts on\n  * @since Commons Collections 1.0\n--- a/src/main/java/org/apache/commons/collections/Factory.java\n+++ b/src/main/java/org/apache/commons/collections/Factory.java\n  * Defines a functor interface implemented by classes that create objects.\n  * <p>\n  * A <code>Factory</code> creates an object without using an input parameter.\n- * If an input parameter is required, then {@link Transformer} is more appropriate.</p>\n+ * If an input parameter is required, then {@link Transformer} is more appropriate.\n  * <p>\n  * Standard implementations of common factories are provided by\n  * {@link FactoryUtils}. These include factories that return a constant,\n- * a copy of a prototype or a new instance.</p>\n+ * a copy of a prototype or a new instance.\n  *\n  * @param <T> the type that the factory creates\n  *\n--- a/src/main/java/org/apache/commons/collections/MultiMap.java\n+++ b/src/main/java/org/apache/commons/collections/MultiMap.java\n  * <p>\n  * A <code>MultiMap</code> is a Map with slightly different semantics.\n  * Putting a value into the map will add the value to a Collection at that key.\n- * Getting a value will return a Collection, holding all the values put to that key.</p>\n+ * Getting a value will return a Collection, holding all the values put to that key.\n  * <p>\n  * For example:\n  * <pre>\n  * mhm.put(key, \"A\");\n  * mhm.put(key, \"B\");\n  * mhm.put(key, \"C\");\n- * Collection coll = (Collection) mhm.get(key);</pre></p>\n+ * Collection coll = (Collection) mhm.get(key);</pre>\n  * <p>\n- * <code>coll</code> will be a collection containing \"A\", \"B\", \"C\".</p>\n+ * <code>coll</code> will be a collection containing \"A\", \"B\", \"C\".\n  * <p>\n  * NOTE: Additional methods were added to this interface in Commons Collections 3.1.\n  * These were added solely for documentation purposes and do not change the interface\n- * as they were defined in the superinterface <code>Map</code> anyway.</p>\n+ * as they were defined in the superinterface <code>Map</code> anyway.\n  *\n  * @since Commons Collections 2.0\n  * @version $Revision$", "timestamp": 1340470949, "metainfo": ""}