{"sha": "a7f9fcfb60d4f04a6ec19a95fbb2352d1266cb2e", "log": "Change to standard variable naming and braces style   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/CompositeMap.java\n+++ b/src/java/org/apache/commons/collections/map/CompositeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/CompositeMap.java,v 1.2 2003/12/29 01:04:43 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/CompositeMap.java,v 1.3 2003/12/29 15:26:39 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * strategy is provided then add and remove are unsupported.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/12/29 01:04:43 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/29 15:26:39 $\n  *\n  * @author Brian McCallister\n  */\n public class CompositeMap implements Map {\n+    \n     /** Array of all maps in the composite */\n-    private Map[] composite = null;\n+    private Map[] composite;\n     \n     /** Handle mutation operations */\n-    private MapMutator mutator = null;\n-    \n-    /**\n-     * Create a new, empty, CompositeMap\n+    private MapMutator mutator;\n+    \n+    /**\n+     * Create a new, empty, CompositeMap.\n      */\n     public CompositeMap() {\n         this(new Map[]{}, null);\n     }\n     \n     /**\n-     * Create a new CompositeMap with two composited Map instances\n-     * @param one First Map to be composited\n-     * @param two Second Map to be composited\n+     * Create a new CompositeMap with two composited Map instances.\n+     * \n+     * @param one  the first Map to be composited\n+     * @param two  the second Map to be composited\n      * @throws IllegalArgumentException if there is a key collision\n      */\n     public CompositeMap(Map one, Map two) {\n     }\n     \n     /**\n-     * Create a new CompositeMap with two composited Map instances\n-     * @param one First Map to be composited\n-     * @param two Second Map to be composited\n-     * @param mutator MapMutator to be used for mutation operations\n+     * Create a new CompositeMap with two composited Map instances.\n+     * \n+     * @param one  the first Map to be composited\n+     * @param two  the second Map to be composited\n+     * @param mutator  MapMutator to be used for mutation operations\n      */\n     public CompositeMap(Map one, Map two, MapMutator mutator) {\n         this(new Map[]{one, two}, mutator);\n     /**\n      * Create a new CompositeMap which composites all of the Map instances in the\n      * argument. It copies the argument array, it does not use it directly.\n-     * @param composite Maps to be composited\n+     * \n+     * @param composite  the Maps to be composited\n      * @throws IllegalArgumentException if there is a key collision\n      */\n     public CompositeMap(Map[] composite) {\n     /**\n      * Create a new CompositeMap which composites all of the Map instances in the\n      * argument. It copies the argument array, it does not use it directly.\n-     * @param composite Maps to be composited\n-     * @param mutator MapMutator to be used for mutation operations\n+     * \n+     * @param composite  Maps to be composited\n+     * @param mutator  MapMutator to be used for mutation operations\n      */\n     public CompositeMap(Map[] composite, MapMutator mutator) {\n         this.mutator = mutator;\n         }\n     }\n     \n-    /**\n-     * Specify the MapMutator to be used by mutation operations\n-     * @param mutator The MapMutator to be used for mutation delegation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify the MapMutator to be used by mutation operations.\n+     * \n+     * @param mutator  the MapMutator to be used for mutation delegation\n      */\n     public void setMutator(MapMutator mutator) {\n         this.mutator = mutator;\n     }\n     \n     /**\n-     * Add an additional Map to the composite\n-     *\n-     * @param map Map to be added to the composite\n+     * Add an additional Map to the composite.\n+     *\n+     * @param map  the Map to be added to the composite\n      * @throws IllegalArgumentException if there is a key collision and there is no\n      *         MapMutator set to handle it.\n      */\n     }\n     \n     /**\n-     * Remove a Map from the composite\n-     *\n-     * @param map The Map to be removed from the composite\n+     * Remove a Map from the composite.\n+     *\n+     * @param map  the Map to be removed from the composite\n      * @return The removed Map or <code>null</code> if map is not in the composite\n      */\n     public synchronized Map removeComposited(Map map) {\n         }\n         return null;\n     }\n-    \n-    /* Map Implementation */\n-    \n-    /**\n-     * Calls <code>clear()</code> on all composited Maps\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Calls <code>clear()</code> on all composited Maps.\n      *\n      * @throws UnsupportedOperationException if any of the composited Maps do not support clear()\n      */\n      * <tt>(key==null ? k==null : key.equals(k))</tt>.  (There can be\n      * at most one such mapping.)\n      *\n-     * @param key key whose presence in this map is to be tested.\n+     * @param key  key whose presence in this map is to be tested.\n      * @return <tt>true</tt> if this map contains a mapping for the specified\n      *         key.\n      *\n      */\n     public boolean containsKey(Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n-            if (this.composite[i].containsKey(key)) return true;\n+            if (this.composite[i].containsKey(key)) {\n+                return true;\n+            }\n         }\n         return false;\n     }\n      */\n     public boolean containsValue(Object value) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n-            if (this.composite[i].containsValue(value)) return true;\n+            if (this.composite[i].containsValue(value)) {\n+                return true;\n+            }\n         }\n         return false;\n     }\n      */\n     public Object get(Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n-            if (this.composite[i].containsKey(key)) return this.composite[i].get(key);\n+            if (this.composite[i].containsKey(key)) {\n+                return this.composite[i].get(key);\n+            }\n         }\n         return null;\n     }\n      */\n     public boolean isEmpty() {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n-            if (!this.composite[i].isEmpty()) return false;\n+            if (!this.composite[i].isEmpty()) {\n+                return false;\n+            }\n         }\n         return true;\n     }\n      *            <tt>null</tt>.\n      */\n     public Object put(Object key, Object value) {\n-        if (this.mutator == null) throw new UnsupportedOperationException(\"No mutator specified\");\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\"No mutator specified\");\n+        }\n         return this.mutator.put(this, this.composite, key, value);\n     }\n     \n      * specified map.  The behavior of this operation is unspecified if the\n      * specified map is modified while the operation is in progress.\n      *\n-     * @param t Mappings to be stored in this map.\n+     * @param map Mappings to be stored in this map.\n      *\n      * @throws UnsupportedOperationException if the <tt>putAll</tt> method is\n      * \t\t  not supported by this map.\n      *         this map does not permit <tt>null</tt> keys or values, and the\n      *         specified map contains <tt>null</tt> keys or values.\n      */\n-    public void putAll(Map t) {\n-        if (this.mutator == null) throw new UnsupportedOperationException(\"No mutator specified\");\n-        this.mutator.putAll(this, this.composite, t);\n+    public void putAll(Map map) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\"No mutator specified\");\n+        }\n+        this.mutator.putAll(this, this.composite, map);\n     }\n     \n     /**\n      */\n     public Object remove(Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n-            if (this.composite[i].containsKey(key)) return this.composite[i].remove(key);\n+            if (this.composite[i].containsKey(key)) {\n+                return this.composite[i].remove(key);\n+            }\n         }\n         return null;\n     }\n     }\n     \n     /**\n-     * @see Map#hashCode\n+     * Checks if this Map equals another as per the Map specification.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if the maps are equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof Map) {\n+            Map map = (Map) obj;\n+            return (this.entrySet().equals(map.entrySet()));\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Gets a hash code for the Map as per the Map specification.\n      */\n     public int hashCode() {\n         int code = 0;\n             code += i.next().hashCode();\n         }\n         return code;\n-    }\n-    \n-    /**\n-     * @see Map#equals\n-     */\n-    public boolean equals(Object obj) {\n-        if (obj instanceof Map) {\n-            Map map = (Map) obj;\n-            return (this.entrySet().equals(map.entrySet()));\n-        }\n-        return false;\n     }\n     \n     /**\n          * Called when adding a new Composited Map results in a\n          * key collision.\n          *\n-         * @param composite the CompositeMap withthe collision\n-         * @param existing the Map already in the composite which contains the\n+         * @param composite  the CompositeMap withthe collision\n+         * @param existing  the Map already in the composite which contains the\n          *        offending key\n-         * @param added the Map being added\n-         * @param intersect the intersection of the keysets of the existing and added maps\n+         * @param added  the Map being added\n+         * @param intersect  the intersection of the keysets of the existing and added maps\n          */\n-        public void resolveCollision(CompositeMap composite,\n-        Map existing,\n-        Map added,\n-        Collection intersect);\n+        public void resolveCollision(\n+            CompositeMap composite, Map existing, Map added, Collection intersect);\n         \n         /**\n          * Called when the CompositeMap.put() method is invoked.\n          *\n-         * @param map the CompositeMap which is being modified\n-         * @param composited array of Maps in the CompositeMap being modified\n-         * @param key key with which the specified value is to be associated.\n-         * @param value value to be associated with the specified key.\n+         * @param map  the CompositeMap which is being modified\n+         * @param composited  array of Maps in the CompositeMap being modified\n+         * @param key  key with which the specified value is to be associated.\n+         * @param value  value to be associated with the specified key.\n          * @return previous value associated with specified key, or <tt>null</tt>\n          *\t       if there was no mapping for key.  A <tt>null</tt> return can\n          *\t       also indicate that the map previously associated <tt>null</tt>\n         /**\n          * Called when the CompositeMap.putAll() method is invoked.\n          *\n-         * @param map the CompositeMap which is being modified\n-         * @param composited array of Maps in the CompositeMap being modified\n-         * @param t Mappings to be stored in this CompositeMap\n+         * @param map  the CompositeMap which is being modified\n+         * @param composited  array of Maps in the CompositeMap being modified\n+         * @param mapToAdd  Mappings to be stored in this CompositeMap\n          *\n          * @throws UnsupportedOperationException if not defined\n          * @throws ClassCastException if the class of the specified key or value\n          *            keys or values, and the specified key or value is\n          *            <tt>null</tt>.\n          */\n-        public void putAll(CompositeMap map, Map[] composited, Map t);\n+        public void putAll(CompositeMap map, Map[] composited, Map mapToAdd);\n     }\n }\n--- a/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n+++ b/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/StaticBucketMap.java,v 1.5 2003/12/29 15:08:15 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/StaticBucketMap.java,v 1.6 2003/12/29 15:26:39 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * operations will affect the map.<p>\n  *\n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.5 $ $Date: 2003/12/29 15:08:15 $\n+ * @version $Revision: 1.6 $ $Date: 2003/12/29 15:26:39 $\n  * \n  * @author Berin Loritsch\n  * @author Gerhard Froehlich\n     /**\n      * Puts all the entries from the specified map into this map.\n      * This operation is <b>not atomic</b> and may have undesired effects.\n-     */\n-    public void putAll(Map other) {\n-        Iterator i = other.keySet().iterator();\n+     * \n+     * @param map  the map of entries to add\n+     */\n+    public void putAll(Map map) {\n+        Iterator i = map.keySet().iterator();\n \n         while (i.hasNext()) {\n             Object key = i.next();\n-            put(key, other.get(key));\n+            put(key, map.get(key));\n         }\n     }\n ", "timestamp": 1072711599, "metainfo": ""}