{"sha": "9f14cf8d87353d99b88cede6592fba3f7c81a11c", "log": "Update licence and javadoc   ", "commit": "\n--- a/src/java/org/apache/commons/collections/Bag.java\n+++ b/src/java/org/apache/commons/collections/Bag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.7 2002/07/19 01:15:01 mas Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/07/19 01:15:01 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Bag.java,v 1.8 2003/05/11 12:13:58 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections;\n \n import java.util.Collection;\n \n /**\n  * A {@link Collection} that counts the number of times an object appears in\n- * the collection.  Suppose you have a Bag that contains <code>{a, a, b,\n- * c}</code>.  Calling {@link #getCount(Object)} on <code>a</code> would return\n- * 2, while calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n- *\n- * <P><I>Note that this interface violates the {@link Collection} contract.</I> \n+ * the collection.\n+ * <p>\n+ * Suppose you have a Bag that contains <code>{a, a, b, c}</code>.\n+ * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n+ * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n+ * <p>\n+ * <i>Note that this interface violates the {@link Collection} contract.</i> \n  * The behavior specified in many of these methods is <I>not</I> the same\n  * as the behavior specified by {@link Collection}.  The noncompliant methods\n- * are clearly marked with \"(Violation)\" in their summary line.  A future\n+ * are clearly marked with \"(Violation)\".  A future\n  * version of this class will specify the same behavior as {@link Collection},\n  * which unfortunately will break backwards compatibility with this version.\n  *\n- * @since 2.0\n+ * @since Commons Collections 2.0\n+ * @version $Revision: 1.8 $ $Date: 2003/05/11 12:13:58 $\n+ * \n  * @author Chuck Burdick\n- **/\n+ * @author Stephen Colebourne\n+ */\n public interface Bag extends Collection {\n-   /**\n-    * Return the number of occurrences (cardinality) of the given\n+    \n+   /**\n+    * Returns the number of occurrences (cardinality) of the given\n     * object currently in the bag. If the object does not exist in the\n     * bag, return 0.\n-    **/\n-   public int getCount(Object o);\n-\n-   /**\n-    * <I>(Violation)</I>\n-    * Add the given object to the bag and keep a count. If the object\n-    * is already in the {@link #uniqueSet()} then increment its count as\n-    * reported by {@link #getCount(Object)}. Otherwise add it to the {@link\n-    * #uniqueSet()} and report its count as 1.<P>\n-    *\n+    * \n+    * @param object  the object to search for\n+    * @return the number of occurrences of the object, zero if not found\n+    */\n+   public int getCount(Object object);\n+\n+   /**\n+    * <i>(Violation)</i>\n+    * Adds one copy the specified object to the Bag.\n+    * <p>\n+    * If the object is already in the {@link #uniqueSet()} then increment its\n+    * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+    * {@link #uniqueSet()} and report its count as 1.\n+    * <p>\n     * Since this method always increases the size of the bag,\n     * according to the {@link Collection#add(Object)} contract, it \n-    * should always return <Code>true</Code>.  Since it sometimes returns\n-    * <Code>false</Code>, this method violates the contract.  A future\n-    * version of this method will comply by always returning <Code>true</Code>.\n-    *\n-    * @return <code>true</code> if the object was not already in the\n-    *         <code>uniqueSet</code>\n-    * @see #getCount(Object)\n-    **/\n-   public boolean add(Object o);\n-\n-   /**\n-    * Add <code>i</code> copies of the given object to the bag and\n-    * keep a count.\n-    * @return <code>true</code> if the object was not already in the\n-    *         <code>uniqueSet</code>\n-    * @see #add(Object)\n-    * @see #getCount(Object)\n-    **/\n-   public boolean add(Object o, int i);\n-\n-   /**\n-    * <I>(Violation)</I>\n-    * Remove all occurrences of the given object from the bag, and do\n-    * not represent the object in the {@link #uniqueSet()}.\n-    *\n-    * <P>According to the {@link Collection#remove(Object)} method,\n-    * this method should only remove the <I>first</I> occurrence of the\n-    * given object, not <I>all</I> occurrences.  A future version of this\n+    * should always return <code>true</code>.  Since it sometimes returns\n+    * <code>false</code>, this method violates the contract.  A future\n+    * version of this method will comply by always returning <code>true</code>.\n+    *\n+    * @param object  the object to add\n+    * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+    */\n+   public boolean add(Object object);\n+\n+   /**\n+    * Adds <code>nCopies</code> copies of the specified object to the Bag.\n+    * <p>\n+    * If the object is already in the {@link #uniqueSet()} then increment its\n+    * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+    * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n+    * \n+    * @param object  the object to search for\n+    * @param nCopies  the number of copies to add\n+    * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+    */\n+   public boolean add(Object object, int nCopies);\n+\n+   /**\n+    * <i>(Violation)</i>\n+    * Removes all occurrences of the given object from the bag.\n+    * <p>\n+    * This will also remove the object from the {@link #uniqueSet()}.\n+    * <p>\n+    * According to the {@link Collection#remove(Object)} method,\n+    * this method should only remove the <i>first</i> occurrence of the\n+    * given object, not <i>all</i> occurrences.  A future version of this\n     * method will comply with the contract by only removing one occurrence\n     * of the given object.\n     *\n-    * @see #remove(Object, int)\n-    * @return <code>true</code> if this call changed the collection\n-    **/\n-   public boolean remove(Object o);\n-\n-   /**\n-    * Remove the given number of occurrences from the bag. If the bag\n-    * contains <code>i</code> occurrences or less, the item will be\n-    * removed from the {@link #uniqueSet()}.\n-    * @see #getCount(Object)\n-    * @see #remove(Object)\n-    * @return <code>true</code> if this call changed the collection\n-    **/\n-   public boolean remove(Object o, int i);\n-\n-   /**\n-    * The {@link Set} of unique members that represent all members in\n-    * the bag. Uniqueness constraints are the same as those in {@link\n-    * Set}.\n-    **/\n+    * @return <code>true</code> if this call changed the collection\n+    */\n+   public boolean remove(Object object);\n+\n+   /**\n+    * Removes <code>nCopies</code> copies of the specified object from the Bag.\n+    * <p>\n+    * If the number of copies to remove is greater than the actual number of\n+    * copies in the Bag, no error is thrown.\n+    * \n+    * @param object  the object to remove\n+    * @param nCopies  the number of copies to remove\n+    * @return <code>true</code> if this call changed the collection\n+    */\n+   public boolean remove(Object object, int nCopies);\n+\n+   /**\n+    * Returns a {@link Set} of unique elements in the Bag.\n+    * <p>\n+    * Uniqueness constraints are the same as those in {@link java.util.Set}.\n+    * \n+    * @return the Set of unique Bag elements\n+    */\n    public Set uniqueSet();\n \n    /**\n     * Returns the total number of items in the bag across all types.\n-    **/\n+    * \n+    * @return the total size of the Bag\n+    */\n    public int size();\n \n    /**\n-    * <I>(Violation)</I>\n+    * <i>(Violation)</i>\n     * Returns <code>true</code> if the bag contains all elements in\n     * the given collection, respecting cardinality.  That is, if the\n-    * given collection <code>C</code> contains <code>n</code> copies\n+    * given collection <code>coll</code> contains <code>n</code> copies\n     * of a given object, calling {@link #getCount(Object)} on that object must\n-    * be <code>&gt;= n</code> for all <code>n</code> in <code>C</code>.\n-    *\n-    * <P>The {@link Collection#containsAll(Collection)} method specifies\n-    * that cardinality should <I>not</I> be respected; this method should\n+    * be <code>&gt;= n</code> for all <code>n</code> in <code>coll</code>.\n+    * <p>\n+    * The {@link Collection#containsAll(Collection)} method specifies\n+    * that cardinality should <i>not</i> be respected; this method should\n     * return true if the bag contains at least one of every object contained\n     * in the given collection.  A future version of this method will comply\n     * with that contract.\n-    **/\n-   public boolean containsAll(Collection c);\n-\n-   /**\n-    * <I>(Violation)</I>\n+    * \n+    * @param coll  the collection to check against\n+    * @return <code>true</code> if the Bag contains all the collection\n+    */\n+   public boolean containsAll(Collection coll);\n+\n+   /**\n+    * <i>(Violation)</i>\n     * Remove all elements represented in the given collection,\n     * respecting cardinality.  That is, if the given collection\n-    * <code>C</code> contains <code>n</code> copies of a given object,\n+    * <code>coll</code> contains <code>n</code> copies of a given object,\n     * the bag will have <code>n</code> fewer copies, assuming the bag\n     * had at least <code>n</code> copies to begin with.\n     *\n     * <P>The {@link Collection#removeAll(Collection)} method specifies\n-    * that cardinality should <I>not</I> be respected; this method should\n-    * remove <I>all</I> occurrences of every object contained in the \n+    * that cardinality should <i>not</i> be respected; this method should\n+    * remove <i>all</i> occurrences of every object contained in the \n     * given collection.  A future version of this method will comply\n     * with that contract.\n     *\n-    * @return <code>true</code> if this call changed the collection\n-    **/\n-   public boolean removeAll(Collection c);\n-\n-   /**\n-    * <I>(Violation)</I>\n+    * @param coll  the collection to remove\n+    * @return <code>true</code> if this call changed the collection\n+    */\n+   public boolean removeAll(Collection coll);\n+\n+   /**\n+    * <i>(Violation)</i>\n     * Remove any members of the bag that are not in the given\n     * collection, respecting cardinality.  That is, if the given\n-    * collection <code>C</code> contains <code>n</code> copies of a\n+    * collection <code>coll</code> contains <code>n</code> copies of a\n     * given object and the bag has <code>m &gt; n</code> copies, then\n     * delete <code>m - n</code> copies from the bag.  In addition, if\n     * <code>e</code> is an object in the bag but\n-    * <code>!C.contains(e)</code>, then remove <code>e</code> and any\n+    * <code>!coll.contains(e)</code>, then remove <code>e</code> and any\n     * of its copies.\n     *\n     * <P>The {@link Collection#retainAll(Collection)} method specifies\n-    * that cardinality should <I>not</I> be respected; this method should\n-    * keep <I>all</I> occurrences of every object contained in the \n+    * that cardinality should <i>not</i> be respected; this method should\n+    * keep <i>all</i> occurrences of every object contained in the \n     * given collection.  A future version of this method will comply\n     * with that contract.\n     *\n-    * @return <code>true</code> if this call changed the collection\n-    **/\n-   public boolean retainAll(Collection c);\n+    * @param coll  the collection to retain\n+    * @return <code>true</code> if this call changed the collection\n+    */\n+   public boolean retainAll(Collection coll);\n \n    /**\n     * Returns an {@link Iterator} over the entire set of members,\n     * including copies due to cardinality. This iterator is fail-fast\n     * and will not tolerate concurrent modifications.\n-    **/\n+    * \n+    * @return iterator over all elements in the Bag\n+    */\n    public Iterator iterator();\n+   \n }\n-\n-\n-\n-\n-", "timestamp": 1052655238, "metainfo": ""}