{"sha": "ee70aa120d63a394872a54d63a94fe3eeda72587", "log": "Initial version of AbstractSimpleMapDecorator   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/AbstractSimpleMapDecorator.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.set.AbstractSetDecorator;\n+\n+/**\n+ * An abstract base class that simplifies the task of creating map decorators.\n+ * <p>\n+ * The Map API is very difficult to decorate correctly, and involves implementing\n+ * lots of different classes. This class exists to provide a simpler API.\n+ * <p>\n+ * Special hook methods are provided that are called when events occur on the map.\n+ * By overriding these methods, the input and output can be validated or manipulated.\n+ * <p>\n+ * This class provides full implementations of the keySet, values and entrySet,\n+ * which means that your subclass decorator should not need any inner classes.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/05/21 21:42:04 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class AbstractSimpleMapDecorator\n+        extends AbstractMapDecorator {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractSimpleMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected AbstractSimpleMapDecorator(Map map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Hook method called when a key is being retrieved from the map using\n+     * <code>put</code>, <code>keySet.iterator</code> or <code>entry.getKey</code>.\n+     * <p>\n+     * An implementation may validate the key and throw an exception\n+     * or it may transform the key into another object.\n+     * <p>\n+     * This implementation returns the input key.\n+     * \n+     * @param key  the key to check\n+     * @throws UnsupportedOperationException if the map get is not supported\n+     * @throws IllegalArgumentException if the specified key is invalid\n+     * @throws ClassCastException if the class of the specified key is invalid\n+     * @throws NullPointerException if the specified key is null and nulls are invalid\n+     */\n+    protected Object checkGetKey(Object key) {\n+        return key;\n+    }\n+\n+    /**\n+     * Hook method called when a value is being retrieved from the map using\n+     * <code>get</code>, <code>values.iterator</code> or <code>entry.getValue</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map get is not supported\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkGetValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called when a key is being added to the map using\n+     * <code>put</code> or <code>putAll</code>.\n+     * <p>\n+     * An implementation may validate the key and throw an exception\n+     * or it may transform the key into another object.\n+     * The key may already exist in the map.\n+     * <p>\n+     * This implementation returns the input key.\n+     * \n+     * @param key  the key to check\n+     * @throws UnsupportedOperationException if the map may not be changed by put/putAll\n+     * @throws IllegalArgumentException if the specified key is invalid\n+     * @throws ClassCastException if the class of the specified key is invalid\n+     * @throws NullPointerException if the specified key is null and nulls are invalid\n+     */\n+    protected Object checkPutKey(Object key) {\n+        return key;\n+    }\n+\n+    /**\n+     * Hook method called when a new value is being added to the map using\n+     * <code>put</code> or <code>putAll</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map may not be changed by put/putAll\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkPutValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called when a value is being set using <code>setValue</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map may not be changed by setValue\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkSetValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called when the map is being queried using a key via the\n+     * contains and equals methods.\n+     * <p>\n+     * An implementation may validate the key and throw an exception\n+     * or it may transform the key into another object.\n+     * <p>\n+     * This implementation returns the input key.\n+     * \n+     * @param key  the key to check\n+     * @throws UnsupportedOperationException if the method is not supported\n+     * @throws IllegalArgumentException if the specified key is invalid\n+     * @throws ClassCastException if the class of the specified key is invalid\n+     * @throws NullPointerException if the specified key is null and nulls are invalid\n+     */\n+    protected Object checkQueryKey(Object key) {\n+        return key;\n+    }\n+\n+    /**\n+     * Hook method called when the map is being queried using a value via the\n+     * contains and equals methods.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the method is not supported\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkQueryValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called when the map is being queried using a key via the\n+     * remove methods.\n+     * <p>\n+     * An implementation may validate the key and throw an exception\n+     * or it may transform the key into another object.\n+     * <p>\n+     * This implementation returns the input key.\n+     * \n+     * @param key  the key to check\n+     * @throws UnsupportedOperationException if the method is not supported\n+     * @throws IllegalArgumentException if the specified key is invalid\n+     * @throws ClassCastException if the class of the specified key is invalid\n+     * @throws NullPointerException if the specified key is null and nulls are invalid\n+     */\n+    protected Object checkRemoveKey(Object key) {\n+        return key;\n+    }\n+\n+    /**\n+     * Hook method called when the map is being queried using a value via the\n+     * remove methods.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the method is not supported\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected Object checkRemoveValue(Object value) {\n+        return value;\n+    }\n+\n+    /**\n+     * Hook method called to determine if the keySet view should be decorated.\n+     * <p>\n+     * An implementation should return false if the there is no decoration of the keySet\n+     * view as this optimises the implementation.\n+     * <p>\n+     * This implementation returns <code>true</code>.\n+     * \n+     * @param value  the value to check\n+     */\n+    protected boolean requiresKeySetDecorator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Hook method called to determine if the values view should be decorated.\n+     * <p>\n+     * An implementation should return false if the there is no decoration of the values\n+     * view as this optimises the implementation.\n+     * <p>\n+     * This implementation returns <code>true</code>.\n+     * \n+     * @param value  the value to check\n+     */\n+    protected boolean requiresValuesDecorator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Hook method called to determine if the entrySet view should be decorated.\n+     * <p>\n+     * An implementation should return false if the there is no decoration of the entrySet\n+     * view as this optimises the implementation.\n+     * <p>\n+     * This implementation returns <code>true</code>.\n+     * \n+     * @param value  the value to check\n+     */\n+    protected boolean requiresEntrySetDecorator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Checks each element in the specified map, creating a new map.\n+     * <p>\n+     * This method is used by <code>putAll</code> to check all the elements\n+     * before adding them to the map.\n+     * <p>\n+     * This implementation builds a <code>LinkedMap</code> to preserve the order\n+     * of the input map.\n+     * \n+     * @param map  the map to transform\n+     * @throws the transformed object\n+     */\n+    protected Map checkMap(Map map) {\n+        Map result = new LinkedMap(map.size());\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            result.put(checkPutKey(entry.getKey()), checkPutValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Object get(Object key) {\n+        return checkGetValue(getMap().get(key));\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        key = checkQueryKey(key);\n+        return getMap().containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        value = checkQueryValue(value);\n+        return getMap().containsValue(value);\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        key = checkPutKey(key);\n+        value = checkPutValue(value);\n+        return checkGetKey(getMap().put(key, value));\n+    }\n+\n+    public void putAll(Map mapToCopy) {\n+        if (mapToCopy.size() == 0) {\n+            return;\n+        } else {\n+            mapToCopy = checkMap(mapToCopy);\n+            getMap().putAll(mapToCopy);\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        key = checkRemoveKey(key);\n+        return checkGetKey(getMap().remove(key));\n+    }\n+\n+    public Set keySet() {\n+        if (requiresKeySetDecorator()) {\n+            return new KeySet(map.keySet(), this);\n+        } else {\n+            return map.keySet();\n+        }\n+    }\n+\n+    public Collection values() {\n+        if (requiresValuesDecorator()) {\n+            return new Values(map.values(), this);\n+        } else {\n+            return map.values();\n+        }\n+    }\n+\n+    public Set entrySet() {\n+        if (requiresEntrySetDecorator()) {\n+            return new EntrySet(map.entrySet(), this);\n+        } else {\n+            return map.entrySet();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set that checks the returned keys.\n+     */\n+    static class KeySet extends AbstractSetDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+\n+        protected KeySet(Set set, AbstractSimpleMapDecorator parent) {\n+            super(set);\n+            this.parent = parent;\n+        }\n+\n+        public Iterator iterator() {\n+            return new KeySetIterator(collection.iterator(), parent);\n+        }\n+\n+        public boolean contains(Object key) {\n+            key = parent.checkQueryKey(key);\n+            return collection.contains(key);\n+        }\n+\n+        public boolean containsAll(Collection coll) {\n+            List list = new ArrayList(coll);\n+            for (int i = 0; i < list.size(); i++) {\n+                list.set(i, parent.checkQueryKey(list.get(i)));\n+            }\n+            return collection.containsAll(list);\n+        }\n+\n+        public boolean remove(Object key) {\n+            key = parent.checkRemoveKey(key);\n+            return collection.remove(key);\n+        }\n+\n+        public boolean removeAll(Collection coll) {\n+            List list = new ArrayList(coll);\n+            for (int i = 0; i < list.size(); i++) {\n+                list.set(i, parent.checkRemoveKey(list.get(i)));\n+            }\n+            return collection.removeAll(list);\n+        }\n+\n+        public boolean retainAll(Collection coll) {\n+            List list = new ArrayList(coll);\n+            for (int i = 0; i < list.size(); i++) {\n+                list.set(i, parent.checkRemoveKey(list.get(i)));\n+            }\n+            return collection.retainAll(list);\n+        }\n+\n+        public boolean equals(Object object) {\n+            if (object == this) {\n+                return true;\n+            }\n+            if (object instanceof Set == false) {\n+                return false;\n+            }\n+            Set other = (Set) object;\n+            Set set = new HashSet(other.size());\n+            for (Iterator it = other.iterator(); it.hasNext();) {\n+                set.add(parent.checkQueryKey(it.next()));\n+            }\n+            return collection.equals(set);\n+        }\n+\n+        public Object[] toArray() {\n+            Object[] array = collection.toArray();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = parent.checkGetKey(array[i]);\n+            }\n+            return array;\n+        }\n+\n+        public Object[] toArray(Object array[]) {\n+            Object[] result = array;\n+            if (array.length > 0) {\n+                // we must create a new array to handle multi-threaded situations\n+                // where another thread could access data before we decorate it\n+                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+            }\n+            result = collection.toArray(result);\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = parent.checkGetKey(result[i]);\n+            }\n+\n+            // check to see if result should be returned straight\n+            if (result.length > array.length) {\n+                return result;\n+            }\n+\n+            // copy back into input array to fulfil the method contract\n+            System.arraycopy(result, 0, array, 0, result.length);\n+            if (array.length > result.length) {\n+                array[result.length] = null;\n+            }\n+            return array;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of a key set iterator that checks the returned keys.\n+     */\n+    static class KeySetIterator extends AbstractIteratorDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+        \n+        protected KeySetIterator(Iterator iterator, AbstractSimpleMapDecorator parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+        \n+        public Object next() {\n+            return parent.checkGetKey(iterator.next());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of a values collection that checks the returned values.\n+     */\n+    static class Values extends AbstractCollectionDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+\n+        protected Values(Collection coll, AbstractSimpleMapDecorator parent) {\n+            super(coll);\n+            this.parent = parent;\n+        }\n+\n+        public Iterator iterator() {\n+            return new ValuesIterator(collection.iterator(), parent);\n+        }\n+\n+        public boolean contains(Object key) {\n+            key = parent.checkQueryValue(key);\n+            return collection.contains(key);\n+        }\n+\n+        public boolean containsAll(Collection coll) {\n+            List list = new ArrayList(coll);\n+            for (int i = 0; i < list.size(); i++) {\n+                list.set(i, parent.checkQueryValue(list.get(i)));\n+            }\n+            return collection.containsAll(list);\n+        }\n+\n+        public boolean remove(Object key) {\n+            key = parent.checkRemoveValue(key);\n+            return collection.remove(key);\n+        }\n+\n+        public boolean removeAll(Collection coll) {\n+            List list = new ArrayList(coll);\n+            for (int i = 0; i < list.size(); i++) {\n+                list.set(i, parent.checkRemoveValue(list.get(i)));\n+            }\n+            return collection.removeAll(list);\n+        }\n+\n+        public boolean retainAll(Collection coll) {\n+            List list = new ArrayList(coll);\n+            for (int i = 0; i < list.size(); i++) {\n+                list.set(i, parent.checkRemoveValue(list.get(i)));\n+            }\n+            return collection.retainAll(list);\n+        }\n+\n+        public boolean equals(Object object) {\n+            if (object == this) {\n+                return true;\n+            }\n+            if (object instanceof Collection == false) {\n+                return false;\n+            }\n+            Collection other = (Collection) object;\n+            Collection coll = new ArrayList(other.size());\n+            for (Iterator it = other.iterator(); it.hasNext();) {\n+                coll.add(parent.checkQueryValue(it.next()));\n+            }\n+            return collection.equals(coll);\n+        }\n+\n+        public Object[] toArray() {\n+            Object[] array = collection.toArray();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = parent.checkGetValue(array[i]);\n+            }\n+            return array;\n+        }\n+\n+        public Object[] toArray(Object array[]) {\n+            Object[] result = array;\n+            if (array.length > 0) {\n+                // we must create a new array to handle multi-threaded situations\n+                // where another thread could access data before we decorate it\n+                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+            }\n+            result = collection.toArray(result);\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = parent.checkGetValue(result[i]);\n+            }\n+\n+            // check to see if result should be returned straight\n+            if (result.length > array.length) {\n+                return result;\n+            }\n+\n+            // copy back into input array to fulfil the method contract\n+            System.arraycopy(result, 0, array, 0, result.length);\n+            if (array.length > result.length) {\n+                array[result.length] = null;\n+            }\n+            return array;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an value iterator that checks the returned values.\n+     */\n+    static class ValuesIterator extends AbstractIteratorDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+        \n+        protected ValuesIterator(Iterator iterator, AbstractSimpleMapDecorator parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+        \n+        public Object next() {\n+            return parent.checkGetValue(iterator.next());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set that calls hook methods from the map entry.\n+     */\n+    static class EntrySet extends AbstractSetDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+\n+        protected EntrySet(Set set, AbstractSimpleMapDecorator parent) {\n+            super(set);\n+            this.parent = parent;\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntrySetIterator(collection.iterator(), parent);\n+        }\n+\n+        public Object[] toArray() {\n+            Object[] array = collection.toArray();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = new MapEntry((Map.Entry) array[i], parent);\n+            }\n+            return array;\n+        }\n+\n+        public Object[] toArray(Object array[]) {\n+            Object[] result = array;\n+            if (array.length > 0) {\n+                // we must create a new array to handle multi-threaded situations\n+                // where another thread could access data before we decorate it\n+                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+            }\n+            result = collection.toArray(result);\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MapEntry((Map.Entry) result[i], parent);\n+            }\n+\n+            // check to see if result should be returned straight\n+            if (result.length > array.length) {\n+                return result;\n+            }\n+\n+            // copy back into input array to fulfil the method contract\n+            System.arraycopy(result, 0, array, 0, result.length);\n+            if (array.length > result.length) {\n+                array[result.length] = null;\n+            }\n+            return array;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set iterator that sets up a special map entry.\n+     */\n+    static class EntrySetIterator extends AbstractIteratorDecorator {\n+        \n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+        \n+        protected EntrySetIterator(Iterator iterator, AbstractSimpleMapDecorator parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+        \n+        public Object next() {\n+            Map.Entry entry = (Map.Entry) iterator.next();\n+            return new MapEntry(entry, parent);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of a map entry that calls the hook methods.\n+     */\n+    static class MapEntry implements Map.Entry, KeyValue {\n+\n+        /** The <code>Map.Entry</code> to decorate */\n+        protected final Map.Entry entry;\n+        /** The parent map */\n+        private final AbstractSimpleMapDecorator parent;\n+\n+        protected MapEntry(Map.Entry entry, AbstractSimpleMapDecorator parent) {\n+            super();\n+            this.entry = entry;\n+            this.parent = parent;\n+        }\n+\n+        public Object getKey() {\n+            return parent.checkGetKey(entry.getKey());\n+        }\n+\n+        public Object getValue() {\n+            return parent.checkGetValue(entry.getValue());\n+        }\n+\n+        public Object setValue(Object value) {\n+            value = parent.checkSetValue(value);\n+            return entry.setValue(value);\n+        }\n+\n+        public boolean equals(Object object) {\n+            if (object == this) {\n+                return true;\n+            }\n+            return entry.equals(object);\n+        }\n+\n+        public int hashCode() {\n+            return entry.hashCode();\n+        }\n+\n+        public String toString() {\n+            return entry.toString();\n+        }\n+    }\n+\n+}", "timestamp": 1085175724, "metainfo": ""}