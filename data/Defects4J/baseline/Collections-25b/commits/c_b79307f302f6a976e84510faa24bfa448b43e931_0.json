{"sha": "b79307f302f6a976e84510faa24bfa448b43e931", "log": "Enhanced TestCollection to more completely test the Collection contract.  This will be used to test straight Collection implementations and for collection views of other collections (e.g. Map.values()).  Submitted by: Paul Jack ( pjack at sfaf dot org ).  Changed TestBag to extend from TestObject instead of TestCollection since the Bag contract conflicts with the Collection contract.  This needs to be addressed at some point.   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestBag.java\n+++ b/src/test/org/apache/commons/collections/TestBag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestBag.java,v 1.3 2002/03/14 18:10:33 morgand Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/03/14 18:10:33 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestBag.java,v 1.4 2002/06/18 01:14:23 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/06/18 01:14:23 $\n  *\n  * ====================================================================\n  *\n  * test case (method) your {@link Bag} fails.\n  *\n  * @author Chuck Burdick\n- * @version $Id: TestBag.java,v 1.3 2002/03/14 18:10:33 morgand Exp $\n+ * @version $Id: TestBag.java,v 1.4 2002/06/18 01:14:23 mas Exp $\n  */\n-public abstract class TestBag extends TestCollection {\n+// TODO: this class should really extend from TestCollection, but the bag\n+// implementations currently do not conform to the Collection interface.  Once\n+// those are fixed or at least a strategy is made for resolving the issue, this\n+// can be changed back to extend TestCollection instead.\n+public abstract class TestBag extends TestObject {\n     public TestBag(String testName) {\n         super(testName);\n     }\n      */\n     public abstract Bag makeBag();\n \n-    public Collection makeCollection() {\n+    public Object makeObject() {\n         return makeBag();\n     }\n \n--- a/src/test/org/apache/commons/collections/TestCollection.java\n+++ b/src/test/org/apache/commons/collections/TestCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.5 2001/07/14 23:33:27 craigmcc Exp $\n- * $Revision: 1.5 $\n- * $Date: 2001/07/14 23:33:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.6 2002/06/18 01:14:23 mas Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/06/18 01:14:23 $\n  *\n  * ====================================================================\n  *\n package org.apache.commons.collections;\n \n import junit.framework.*;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n \n /**\n  * Tests base {@link java.util.Collection} methods and contracts.\n  * <p>\n- * To use, simply extend this class, and implement\n- * the {@link #makeCollection} method.\n- * <p>\n+ * You should create a concrete subclass of this class to test any custom\n+ * {@link Collection} implementation.  At minimum, you'll have to \n+ * implement the {@link #makeCollection} method.  You might want to \n+ * override some of the additional protected methods as well:<P>\n+ *\n+ * <B>Element Population Methods</B><P>\n+ * \n+ * Override these if your collection restricts what kind of elements are\n+ * allowed (for instance, if <Code>null</Code> is not permitted):\n+ * <UL>\n+ * <Li>{@link #getFullElements}\n+ * <Li>{@link #getOtherElements}\n+ * </UL>\n+ *\n+ * <B>Supported Operation Methods</B><P>\n+ *\n+ * Override these if your collection doesn't support certain operations:\n+ * <UL>\n+ * <LI>{@link #supportsAdd}\n+ * <LI>{@link #supportsRemove}\n+ * </UL>\n+ *\n+ * <B>Fixture Methods</B><P>\n+ *\n+ * For tests on modification operations (adds and removes), fixtures are \n+ * used to verify that the the operation results in correct state for the\n+ * collection.  Basically, the modification is performed against your \n+ * collection implementation, and an identical modification is performed\n+ * against a <I>confirmed</I> collection implementation.  A confirmed \n+ * collection implementation is something like \n+ * <Code>java.util.ArrayList</Code>, which is known to conform exactly to\n+ * its collection interface's contract.  After the modification takes \n+ * place on both your collection implementation and the confirmed \n+ * collection implementation, the two collections are compared to see if\n+ * their state is identical.  The comparison is usually much more \n+ * involved than a simple <Code>equals</Code> test.<P>\n+ *\n+ * The {@link #collection} field holds an instance of your collection\n+ * implementation; the {@link #confirmed} field holds an instance of the\n+ * confirmed collection implementation.  The {@link #resetEmpty} and\n+ * {@link #resetFull} methods set these fields to empty or full collections,\n+ * so that tests can proceed from a known state.<P>\n+ *\n+ * After a modification operation to both {@link #collection} and\n+ * {@link #confirmed}, the {@link #verify} method is invoked to compare\n+ * the results.  You may want to override {@link #verify} to perform\n+ * additional verifications.  For instance, when testing the collection\n+ * views of a map, {@link TestMap} overrides {@link #verify} to make sure\n+ * the map is changed after the collection view is changed.\n+ *\n+ * If you're extending this class directly, you will have to provide \n+ * implementations for the following:\n+ * <UL>\n+ * <LI>{@link #makeConfirmedCollection()}\n+ * <LI>{@link #makeConfirmedFullCollection()}\n+ * </UL>\n+ *\n+ * Those methods should provide a confirmed collection implementation \n+ * that's compatible with your collection implementation.<P>\n+ *\n+ * If you're extending {@link TestList}, {@link TestSet},\n+ * or {@link TestBag}, you probably don't have to worry about the\n+ * above methods, because those three classes already override the methods\n+ * to provide standard JDK confirmed collections.<P>\n+ *\n+ * <B>Other notes</B><P>\n+ *\n  * If your {@link Collection} fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n- * test case (method) your {@link Collection} fails.\n+ * test case (method) your {@link Collection} fails.  For instance, the\n+ * {@link #testIteratorFailFast} method is provided since most collections\n+ * have fail-fast iterators; however, that's not strictly required by the\n+ * collection contract, so you may want to override that method to do \n+ * nothing.<P>\n  *\n  * @author Rodney Waldhoff\n- * @version $Id: TestCollection.java,v 1.5 2001/07/14 23:33:27 craigmcc Exp $\n+ * @author Paul Jack\n+ * @version $Id: TestCollection.java,v 1.6 2002/06/18 01:14:23 mas Exp $\n  */\n public abstract class TestCollection extends TestObject {\n+\n+    // These fields are used by reset() and verify(), and any test\n+    // method that tests a modification.\n+\n+    /** \n+     *  A collection instance that will be used for testing.\n+     */\n+    protected Collection collection;\n+\n+    /** \n+     *  Confirmed collection.  This is an instance of a collection that is\n+     *  confirmed to conform exactly to the java.util.Collection contract.\n+     *  Modification operations are tested by performing a mod on your \n+     *  collection, performing the exact same mod on an equivalent confirmed\n+     *  collection, and then calling verify() to make sure your collection\n+     *  still matches the confirmed collection.\n+     */\n+    protected Collection confirmed;\n+\n+\n     public TestCollection(String testName) {\n         super(testName);\n     }\n \n-    /**\n-     * Return a new, empty {@link Collection} to used for testing.\n-     */\n-    public abstract Collection makeCollection();\n-\n+\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    protected void resetEmpty() {\n+        this.collection = makeCollection();\n+        this.confirmed = makeConfirmedCollection();\n+    }\n+\n+\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    protected void resetFull() {\n+        this.collection = makeFullCollection();\n+        this.confirmed = makeConfirmedFullCollection();\n+    }\n+\n+\n+    /**\n+     *  Verifies that {@link #collection} and {@link #confirmed} have \n+     *  identical state.\n+     */\n+    protected void verify() {\n+        assertEquals(\"Collection size should match confirmed collection's\",\n+                     confirmed.size(), collection.size());\n+        assertEquals(\"Collection isEmpty() result should match confirmed \" +\n+                     \" collection's\", \n+                     confirmed.isEmpty(), collection.isEmpty());\n+        Bag bag1 = new HashBag(confirmed);\n+        Bag bag2 = new HashBag(collection);\n+        assertEquals(\"Collections should contain same elements with \" + \n+                     \" the same cardinality\", bag1, bag2);\n+    }\n+    \n+    \n+    /**\n+     *  Returns a confirmed empty collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.\n+     *\n+     *  @return a confirmed empty collection\n+     */\n+    protected abstract Collection makeConfirmedCollection();\n+\n+\n+\n+    /**\n+     *  Returns a confirmed full collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.  The returned collection\n+     *  should contain the elements returned by {@link #getFullElements}.\n+     *\n+     *  @return a confirmed full collection\n+     */\n+    protected abstract Collection makeConfirmedFullCollection();\n+\n+\n+    /**\n+     *  Returns true if the collections produced by \n+     *  {@link #makeCollection} and {@link #makeFullCollection}\n+     *  support the <Code>add</Code> and <Code>addAll</Code>\n+     *  operations.<P>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support add or addAll.\n+     */\n+    protected boolean supportsAdd() {\n+        return true;\n+    }\n+\n+\n+    /**\n+     *  Returns true if the collections produced by \n+     *  {@link #makeCollection} and {@link #makeFullCollection}\n+     *  support the <Code>remove</Code>, <Code>removeAll</Code>,\n+     *  <Code>retainAll</Code>, <Code>clear</Code> and\n+     *  <Code>iterator().remove</Code> methods.\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support removal operations.\n+     */\n+    protected boolean supportsRemove() {\n+        return true;\n+    }\n+\n+\n+    /**\n+     *  Returns an array of objects that are contained in a collection\n+     *  produced by {@link #makeFullCollection}.  Every element in the\n+     *  returned array <I>must</I> be an element in a full collection.<P>\n+     *  The default implementation returns a heterogenous array of \n+     *  objects with some duplicates and with the null element.  \n+     *  Override if you require specific testing elements.  Note that if you\n+     *  override {@link #makeFullCollection}, you <I>must</I> override\n+     *  this method to reflect the contents of a full collection.\n+     */\n+    protected Object[] getFullElements() {\n+        ArrayList list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullNonNullElements()));\n+        list.add(4, null);\n+        return list.toArray();\n+    }\n+\n+\n+    /**\n+     *  Returns an array of elements that are <I>not</I> contained in a\n+     *  full collection.  Every element in the returned array must \n+     *  not exist in a collection returned by {@link #makeFullCollection}.\n+     *  The default implementation returns a heterogenous array of elements\n+     *  without null.  Note that some of the tests add these elements\n+     *  to an empty or full collection, so if your collection restricts\n+     *  certain kinds of elements, you should override this method.\n+     */\n+    protected Object[] getOtherElements() {\n+        return getOtherNonNullElements();\n+    }\n+    \n+\n+    /**\n+     * Return a new, empty {@link Collection} to be used for testing.\n+     */\n+    protected abstract Collection makeCollection();\n+\n+\n+    /**\n+     *  Returns a full collection to be used for testing.  The collection\n+     *  returned by this method should contain every element returned by\n+     *  {@link #getFullElements}.  The default implementation, in fact,\n+     *  simply invokes <Code>addAll</Code> on an empty collection with\n+     *  the results of {@link #getFullElements}.  Override this default\n+     *  if your collection doesn't support addAll.\n+     */\n+    protected Collection makeFullCollection() {\n+        Collection c = makeCollection();\n+        c.addAll(Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+\n+    /**\n+     *  Returns an empty collection for Object tests.\n+     */\n     public Object makeObject() {\n         return makeCollection();\n     }\n \n-    // optional operation\n+\n+    /**\n+     *  Tests {@link Collection#add}.\n+     */\n     public void testCollectionAdd() {\n-        Collection c = makeCollection();\n-        boolean added1 = tryToAdd(c,\"element1\");\n-        boolean added2 = tryToAdd(c,\"element2\");\n-    }\n-\n-    // optional operation\n+        if (!supportsAdd()) return;\n+        \n+        Object[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            resetEmpty();\n+            boolean r = collection.add(elements[i]);\n+            confirmed.add(elements[i]);\n+            verify();\n+            assertTrue(\"Empty collection changed after add\", r);\n+            assertTrue(\"Collection size is 1 after first add\", \n+                       collection.size() == 1);\n+        }\n+        \n+        resetEmpty();\n+        int size = 0;\n+        for (int i = 0; i < elements.length; i++) {\n+            boolean r = collection.add(elements[i]);\n+            confirmed.add(elements[i]);\n+            verify();\n+            if (r) size++;\n+            assertEquals(\"Collection size should grow after add\", \n+                         size, collection.size());\n+            assertTrue(\"Collection should contain added element\",\n+                       collection.contains(elements[i]));\n+        }\n+    }\n+    \n+    \n+    /**\n+     *  Tests {@link Collection#addAll}.\n+     */\n     public void testCollectionAddAll() {\n-        Collection c = makeCollection();\n-        Collection col = new ArrayList();\n-        col.add(\"element1\");\n-        col.add(\"element2\");\n-        col.add(\"element3\");\n-        boolean added = false;\n-        try {\n-            added = c.addAll(col);\n-        } catch(UnsupportedOperationException e) {\n-            // ignored, must not be supported\n-        } catch(ClassCastException e) {\n-            // ignored, type must not be supported\n-        } catch(IllegalArgumentException e) {\n-            // ignored, element must not be supported\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.addAll should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n-        }\n-    }\n-\n-    // optional operation\n+        if (!supportsAdd()) return;\n+\n+        resetEmpty();\n+        Object[] elements = getFullElements();\n+        boolean r = collection.addAll(Arrays.asList(elements));\n+        confirmed.addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Collection should contain added element\",\n+                       collection.contains(elements[i]));\n+        }\n+\n+        resetFull();\n+        int size = collection.size();\n+        elements = getOtherElements();\n+        r = collection.addAll(Arrays.asList(elements));\n+        confirmed.addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain added element\",\n+                       collection.contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\", \n+                     size + elements.length, collection.size());\n+\n+        resetFull();\n+        size = collection.size();\n+        r = collection.addAll(Arrays.asList(getFullElements()));\n+        confirmed.addAll(Arrays.asList(getFullElements()));\n+        verify();\n+        if (r) {\n+            assertTrue(\"Size should increase if addAll returns true\", \n+                       size < collection.size());\n+        } else {\n+            assertTrue(\"Size should not change if addAll returns false\",\n+                       size == collection.size());\n+        } \n+    }\n+\n+\n+    /**\n+     *  If {@link #supportsAdd} returns false, tests that add operations\n+     *  raise <Code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedAdd() {\n+        if (supportsAdd()) return;\n+        \n+        try {\n+            makeCollection().add(new Object());\n+            fail(\"Emtpy collection should not support add.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            makeCollection().addAll(Arrays.asList(getFullElements()));\n+            fail(\"Emtpy collection should not support addAll.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            makeFullCollection().add(new Object());\n+            fail(\"Full collection should not support add.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            makeFullCollection().addAll(Arrays.asList(getOtherElements()));\n+            fail(\"Full collection should not support addAll.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Test {@link Collection#clear}.\n+     */\n     public void testCollectionClear() {\n-        Collection c = makeCollection();\n-        boolean cleared = false;\n-        try {\n-            c.clear();\n-            cleared = true;\n-        } catch(UnsupportedOperationException e) {\n-            // ignored, must not be supported\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.clear should only throw UnsupportedOperationException. Found \" + t.toString());\n-        }\n-\n-        if(cleared) {\n-            assertTrue(\"After Collection.clear(), Collection.isEmpty() should be true.\",c.isEmpty());\n-        }\n-\n-        boolean added = tryToAdd(c,\"element1\");\n-\n-        if(added) {\n-            assertTrue(\"After element is added, Collection.isEmpty() should be false.\",!c.isEmpty());\n-            boolean cleared2 = false;\n-            try {\n-                c.clear();\n-                cleared2 = true;\n-            } catch(UnsupportedOperationException e) {\n-                // ignored, must not be supported\n-            } catch(Throwable t) {\n-                t.printStackTrace();\n-                fail(\"Collection.clear should only throw UnsupportedOperationException. Found \" + t.toString());\n-            }\n-            if(cleared2) {\n-                assertTrue(\"After Collection.clear(), Collection.isEmpty() should be true.\",c.isEmpty());\n-            }\n-        }\n-    }\n-\n+        if (!supportsRemove()) return;\n+\n+        resetEmpty();\n+        collection.clear(); // just to make sure it doesn't raise anything\n+        verify();\n+\n+        resetFull();\n+        collection.clear();\n+        confirmed.clear();\n+        verify();\n+    }    \n+\n+    \n+    /**\n+     *  Tests {@link Collection#contains}.\n+     */\n     public void testCollectionContains() {\n         Collection c = makeCollection();\n-        assertTrue(\"Empty Collection shouldn't contain element.\",!c.contains(\"element1\"));\n-        boolean added1 = tryToAdd(c,\"element1\");\n-        assertTrue(\"[1] If an element was added, it should be contained, if it wasn't, it shouldn't.\",added1 == c.contains(\"element1\"));\n-\n-        assertTrue(\"Shouldn't be contained.\",!c.contains(\"element2\"));\n-        boolean added2 = tryToAdd(c,\"element2\");\n-        assertTrue(\"[2] If an element was added, it should be contained, if it wasn't, it shouldn't.\",added1 == c.contains(\"element1\"));\n-        assertTrue(\"[3] If an element was added, it should be contained, if it wasn't, it shouldn't.\",added2 == c.contains(\"element2\"));\n-    }\n-\n+        ArrayList elements = new ArrayList();\n+        elements.addAll(Arrays.asList(getFullElements()));\n+        elements.addAll(Arrays.asList(getOtherElements()));\n+        Iterator iter = elements.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Empty collection shouldn't contain element\", \n+                       !c.contains(iter.next()));\n+        }\n+        \n+        elements.clear();\n+        elements.addAll(Arrays.asList(getFullElements()));\n+        c = makeFullCollection();\n+        iter = elements.iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            assertTrue(\"Full collection should contain element \" + o, \n+                       c.contains(o));\n+        }\n+        \n+        elements.clear();\n+        elements.addAll(Arrays.asList(getOtherElements()));\n+        iter = elements.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Full collection shouldn't contain element\", \n+                       !c.contains(iter.next()));\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Collection#containsAll}.\n+     */\n     public void testCollectionContainsAll() {\n         Collection c = makeCollection();\n-        Collection col = new ArrayList();\n-        assertTrue(\"Every Collection should contain all elements of an empty Collection.\",c.containsAll(col));\n-        col.add(\"element1\");\n-        assertTrue(\"Empty Collection shouldn't contain all elements of a non-empty Collection.\",!c.containsAll(col));\n-\n-        boolean added1 = tryToAdd(c,\"element1\");\n-        if(added1) {\n-            assertTrue(\"[1] Should contain all.\",c.containsAll(col));\n-        }\n-\n-        col.add(\"element2\");\n-        assertTrue(\"Shouldn't contain all.\",!c.containsAll(col));\n-\n-        boolean added2 = tryToAdd(c,\"element2\");\n-        if(added1 && added2) {\n-            assertTrue(\"[2] Should contain all.\",c.containsAll(col));\n-        }\n-    }\n-\n+        Collection col = new HashSet();\n+        assertTrue(\"Every Collection should contain all elements of an \" +\n+                   \"empty Collection.\",c.containsAll(col));\n+        col.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Empty Collection shouldn't contain all elements of \" +\n+                   \"a non-empty Collection.\",!c.containsAll(col));\n+        \n+        c = makeFullCollection();\n+        assertTrue(\"Full collection shouldn't contain other elements\", \n+                   !c.containsAll(col));\n+        \n+        col.clear();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll full elements \" + \n+                   c + \" \" + col, c.containsAll(col));\n+        col = Arrays.asList(getFullElements()).subList(2, 5);\n+        assertTrue(\"Full collection should containAll partial full \" +\n+                   \"elements\", c.containsAll(col));\n+        assertTrue(\"Full collection should containAll itself\", \n+                   c.containsAll(c));\n+        \n+        col = new ArrayList();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll duplicate full \" +\n+                   \"elements\", c.containsAll(col));\n+    }\n+\n+\n+    /* ---------------------------------\n+\n+     // Got rid of the equals() tests -- Collection doesn't define\n+     // any semantics for equals, and recommends you use reference-based\n+     // default behavior of Object.equals.  (And a test for that already\n+     // exists in TestObject).  Tests for equality of lists,\n+     // sets and bags will have to be written in test subclasses.\n+     \n     public void testCollectionEqualsSelf() {\n         Collection c = makeCollection();\n         assertEquals(\"A Collection should equal itself\",c,c);\n         }\n     }\n \n+    -------------------------- */\n+\n+\n+    /**\n+     *  Tests {@link Collection#isEmpty}.\n+     */\n     public void testCollectionIsEmpty() {\n         Collection c = makeCollection();\n         assertTrue(\"New Collection should be empty.\",c.isEmpty());\n-        boolean added = tryToAdd(c,\"element1\");\n-        if(added) {\n-            assertTrue(\"If an element was added, the Collection.isEmpty() should return false.\",!c.isEmpty());\n-        }\n-    }\n-\n+\n+        c =  makeFullCollection();\n+        assertTrue(\"Full collection shouldn't be empty\", !c.isEmpty());\n+    }\n+\n+\n+    /**\n+     *  Tests the read-only functionality of {@link Collection#iterator}.\n+     */\n     public void testCollectionIterator() {\n         Collection c = makeCollection();\n         Iterator it1 = c.iterator();\n-        assertTrue(\"Iterator for empty Collection shouldn't have next.\",!it1.hasNext());\n+        assertTrue(\"Iterator for empty Collection shouldn't have next.\",\n+                   !it1.hasNext());\n         try {\n             it1.next();\n-            fail(\"Iterator at end of Collection should throw NoSuchElementException when next is called.\");\n+            fail(\"Iterator at end of Collection should throw \" +\n+                 \"NoSuchElementException when next is called.\");\n         } catch(NoSuchElementException e) {\n             // expected\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.iterator.next() should only throw NoSuchElementException. Found \" + t.toString());\n-        }\n-\n-        boolean added = tryToAdd(c,\"element1\");\n-        if(added) {\n-            Iterator it2 = c.iterator();\n-            assertTrue(\"Iterator for non-empty Collection should have next.\",it2.hasNext());\n-            assertEquals(\"element1\",it2.next());\n-            assertTrue(\"Iterator at end of Collection shouldn't have next.\",!it2.hasNext());\n-            try {\n-                it2.next();\n-                fail(\"Iterator at end of Collection should throw NoSuchElementException when next is called.\");\n-            } catch(NoSuchElementException e) {\n-                // expected\n-            } catch(Throwable t) {\n-                t.printStackTrace();\n-                fail(\"Collection.iterator.next() should only throw NoSuchElementException. Found \" + t.toString());\n+        } \n+        \n+        c = makeFullCollection();\n+        it1 = c.iterator();\n+        for (int i = 0; i < c.size(); i++) {\n+            assertTrue(\"Iterator for full collection should haveNext\", \n+                       it1.hasNext());\n+            it1.next();\n+        }\n+        assertTrue(\"Iterator should be finished\", !it1.hasNext());\n+        \n+        ArrayList list = new ArrayList();\n+        it1 = c.iterator();\n+        for (int i = 0; i < c.size(); i++) {\n+            Object next = it1.next();\n+            assertTrue(\"Collection should contain element returned by \" +\n+                       \"its iterator\", c.contains(next));\n+            list.add(next);\n+        }\n+        try {\n+            it1.next();\n+            fail(\"iterator.next() should raise NoSuchElementException \" +\n+                 \"after it finishes\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+        \n+        /*\n+           Removed -- TestSet, TestBag and TestList should do this\n+        Collection elements = Arrays.asList(getFullElements());\n+        if (c instanceof Set) {\n+            assertTrue(\"Iterator should return unique elements\", \n+              new HashSet(list).equals(new HashSet(elements)));\n+        }\n+        if (c instanceof List) {\n+            assertTrue(\"Iterator should return sequenced elements\",\n+              list.equals(elements));\n+        }\n+        if (c instanceof Bag) {\n+            assertTrue(\"Iterator should return duplicate elements\",\n+              new HashBag(list).equals(new HashBag(elements)));\n+        }\n+\n+        */\n+    }\n+\n+\n+    /**\n+     *  Tests removals from {@link Collection#iterator}.\n+     */\n+    public void testCollectionIteratorRemove() {\n+        if (!supportsRemove()) return;\n+\n+        resetEmpty();\n+        try {\n+            collection.iterator().remove();\n+            fail(\"New iterator.remove should raise IllegalState\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+\n+        try {\n+            Iterator iter = collection.iterator();\n+            iter.hasNext();\n+            iter.remove();\n+            fail(\"New iterator.remove should raise IllegalState \" +\n+                 \"even after hasNext\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        int size = collection.size();\n+        HashBag bag = new HashBag(collection);\n+        Iterator iter = collection.iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            bag.remove(o, 1);\n+            iter.remove();\n+            if ((collection instanceof Set) || (collection instanceof List) ||\n+                (collection instanceof Bag)) {\n+                // Unfortunately, we can't get away with this for a straight\n+                // collection that might have unordered duplicate elements,\n+                // but it works for Bag, Set and List.\n+                confirmed.remove(o);\n+                verify();\n             }\n-        }\n-    }\n-\n-    // optional operation\n+            size--;\n+            assertEquals(\"Collection should shrink after iterator.remove\",\n+                         collection.size(), size);\n+            if (bag.getCount(o) == 0) {\n+                assertTrue(\"Collection shouldn't contain element after \" +\n+                           \"iterator.remove\", !collection.contains(o));\n+            } else {\n+                assertTrue(\"Collection should still contain element after \" +\n+                           \"iterator.remove\", collection.contains(o));\n+            }\n+        }\n+        assertTrue(\"Collection should be empty after iterator purge\",\n+                   collection.isEmpty());\n+        \n+        resetFull();\n+        iter = collection.iterator();\n+        iter.next();\n+        iter.remove();\n+        try {\n+            iter.remove();\n+            fail(\"Second iter.remove should raise IllegalState\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Collection#remove}.\n+     */\n     public void testCollectionRemove() {\n-        Collection c = makeCollection();\n-        boolean added = tryToAdd(c,\"element1\");\n-\n-        try {\n-            assertTrue(\"Shouldn't be able to remove an element that wasn't added.\",!c.remove(\"element2\"));\n-        } catch(UnsupportedOperationException e) {\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.remove should only throw UnsupportedOperationException. Found \" + t.toString());\n-        }\n-\n-        try {\n-            assertTrue(\"If added, should be removed by call to remove.\",added == c.remove(\"element1\"));\n-            assertTrue(\"If removed, shouldn't be contained.\",!c.contains(\"element1\"));\n-        } catch(UnsupportedOperationException e) {\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.remove should only throw UnsupportedOperationException. Found \" + t.toString());\n-        }\n-    }\n-\n-    // optional operation\n+        if (!supportsRemove()) return;\n+\n+        resetEmpty();\n+        Object[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent element\", \n+                       !collection.remove(elements[i]));\n+            verify();\n+        }\n+        \n+        Object[] other = getOtherElements();\n+        \n+        resetFull();\n+        for (int i = 0; i < other.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent other element\", \n+                       !collection.remove(other[i]));\n+            verify();\n+        }\n+        \n+        int size = collection.size();\n+        for (int i = 0; i < elements.length; i++) {\n+            resetFull();\n+            HashBag bag = new HashBag(collection);\n+            assertTrue(\"Collection should remove extant element\",\n+                       collection.remove(elements[i]));\n+            if ((collection instanceof Set) || (collection instanceof List) ||\n+                (collection instanceof Bag)) {\n+                // Can't do this for unordered straight collection...\n+                confirmed.remove(elements[i]);\n+                verify();\n+            }\n+            assertEquals(\"Collection should shrink after remove\", \n+                         size - 1, collection.size());\n+            bag.remove(elements[i], 1);\n+            if (bag.getCount(elements[i]) == 0) {\n+                assertTrue(\"Collection shouldn't contain removed element\",\n+                           !collection.contains(elements[i]));\n+            } else {\n+                assertTrue(\"Collection should still contain removed element\",\n+                           collection.contains(elements[i]));\n+            }\n+        }\n+    }\n+    \n+\n+    /**\n+     *  Tests {@link Collection#removeAll}.\n+     */\n     public void testCollectionRemoveAll() {\n-        Collection c = makeCollection();\n-        assertTrue(\"Initial Collection is empty.\",c.isEmpty());\n-        try {\n-            c.removeAll(c);\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.removeAll should only throw UnsupportedOperationException. Found \" + t.toString());\n-        }\n-        assertTrue(\"Collection is still empty.\",c.isEmpty());\n-\n-        boolean added = tryToAdd(c,\"element1\");\n-        if(added) {\n-            assertTrue(\"Collection is not empty.\",!c.isEmpty());\n-            try {\n-                c.removeAll(c);\n-                assertTrue(\"Collection is empty.\",c.isEmpty());\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            } catch(Throwable t) {\n-                t.printStackTrace();\n-                fail(\"Collection.removeAll should only throw UnsupportedOperationException. Found \" + t.toString());\n-            }\n-        }\n-    }\n-\n-    // optional operation\n-    public void testCollectionRemoveAll2() {\n-        Collection c = makeCollection();\n-        Collection col = new ArrayList();\n-        col.add(\"element1\");\n-        col.add(\"element2\");\n-        col.add(\"element3\");\n-        boolean added = false;\n-        try {\n-            added = c.addAll(col);\n-            if(added) {\n-                added = c.add(\"element0\");\n-            }\n-        } catch(UnsupportedOperationException e) {\n-            // ignored, must not be supported\n-        } catch(ClassCastException e) {\n-            // ignored, type must not be supported\n-        } catch(IllegalArgumentException e) {\n-            // ignored, element must not be supported\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.addAll should only throw UnsupportedOperationException, ClassCastException or IllegalArgumentException. Found \" + t.toString());\n-        }\n-        col.add(\"element4\");\n-        if(added) {\n-            assertTrue(\"Collection is not empty.\",!c.isEmpty());\n-            try {\n-                assertTrue(\"Should be changed\",c.removeAll(col));\n-                assertTrue(\"Collection is not empty.\",!c.isEmpty());\n-                assertTrue(\"Collection should contain element\",c.contains(\"element0\"));\n-                assertTrue(\"Collection shouldn't contain removed element\",!c.contains(\"element1\"));\n-                assertTrue(\"Collection shouldn't contain removed element\",!c.contains(\"element2\"));\n-                assertTrue(\"Collection shouldn't contain removed element\",!c.contains(\"element3\"));\n-                assertTrue(\"Collection shouldn't contain removed element\",!c.contains(\"element4\"));\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            } catch(Throwable t) {\n-                t.printStackTrace();\n-                fail(\"Collection.removeAll should only throw UnsupportedOperationException. Found \" + t.toString());\n-            }\n-        }\n-    }\n-\n-    // optional operation\n+        if (!supportsRemove()) return;\n+\n+        resetEmpty();\n+        assertTrue(\"Emtpy collection removeAll should return false for \" +\n+                   \"empty input\", \n+                   !collection.removeAll(Collections.EMPTY_SET));\n+        verify();\n+        \n+        assertTrue(\"Emtpy collection removeAll should return false for \" +\n+                   \"nonempty input\", \n+                   !collection.removeAll(new ArrayList(collection)));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection removeAll should return false for \" + \n+                   \"empty input\", \n+                   !collection.removeAll(Collections.EMPTY_SET));\n+        verify();\n+        \n+        assertTrue(\"Full collection removeAll should return false for \" +\n+                   \"other elements\", \n+                   !collection.removeAll(Arrays.asList(getOtherElements())));\n+        verify();\n+        \n+        assertTrue(\"Full collection removeAll should return true for \" +\n+                   \"full elements\", \n+                   collection.removeAll(new HashSet(collection)));\n+        confirmed.removeAll(new HashSet(confirmed));\n+        verify();\n+        \n+        resetFull();\n+        int size = collection.size();\n+        Collection all = Arrays.asList(getFullElements()).subList(2, 5);\n+        assertTrue(\"Full collection removeAll should work\", \n+                   collection.removeAll(all));\n+        confirmed.removeAll(all);\n+        verify();\n+        \n+        assertTrue(\"Collection should shrink after removeAll\", \n+                   collection.size() < size);\n+        Iterator iter = all.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Collection shouldn't contain removed element\",\n+                       !collection.contains(iter.next()));\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Collection#retainAll}.\n+     */\n     public void testCollectionRetainAll() {\n-        Collection a = makeCollection();\n-        Collection b = makeCollection();\n-        try {\n-            assertTrue(!a.retainAll(b));\n-            assertTrue(!a.retainAll(a));\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.retainAll should only throw UnsupportedOperationException. Found \" + t.toString());\n-        }\n-\n-        boolean added_b = b.add(\"element1\");\n-        try {\n-            assertTrue(!a.retainAll(b));\n-            assertTrue(added_b == b.retainAll(a));\n-            assertTrue(b.isEmpty());\n-        } catch(UnsupportedOperationException e) {\n-            // expected\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Collection.retainAll should only throw UnsupportedOperationException. Found \" + t.toString());\n-        }\n-\n-        boolean added_b1 = b.add(\"element1\");\n-        boolean added_b2 = b.add(\"element2\");\n-        boolean added_a1 = a.add(\"element1\");\n-        if(added_b1 && added_b2 && added_a1) {\n-            try {\n-                assertTrue(!b.retainAll(b));\n-                assertTrue(b.contains(\"element1\"));\n-                assertTrue(b.contains(\"element2\"));\n-\n-                assertTrue(!a.retainAll(b));\n-\n-                assertTrue(b.retainAll(a));\n-                assertTrue(b.contains(\"element1\"));\n-                assertTrue(!b.contains(\"element2\"));\n-            } catch(UnsupportedOperationException e) {\n-                // expected\n-            } catch(Throwable t) {\n-                t.printStackTrace();\n-                fail(\"Collection.retainAll should only throw UnsupportedOperationException. Found \" + t.toString());\n-            }\n-        }\n-    }\n-\n+        if (!supportsRemove()) return;\n+\n+        resetEmpty();\n+        List elements = Arrays.asList(getFullElements());\n+        List other = Arrays.asList(getOtherElements());\n+\n+        assertTrue(\"Empty retainAll() should return false\", \n+                   !collection.retainAll(Collections.EMPTY_SET));\n+        verify();\n+        \n+        assertTrue(\"Empty retainAll() should return false\", \n+                   !collection.retainAll(elements));\n+        verify();\n+        \n+        resetFull();\n+        assertTrue(\"Collection should change from retainAll empty\", \n+                   collection.retainAll(Collections.EMPTY_SET));\n+        confirmed.retainAll(Collections.EMPTY_SET);\n+        verify();\n+        \n+        resetFull();\n+        assertTrue(\"Collection changed from retainAll other\", \n+                   collection.retainAll(other));\n+        confirmed.retainAll(other);\n+        verify();\n+        \n+        resetFull();\n+        int size = collection.size();\n+        assertTrue(\"Collection shouldn't change from retainAll elements\",\n+                   !collection.retainAll(elements));\n+        verify();\n+        assertEquals(\"Collection size shouldn't change\", size, \n+                     collection.size());\n+        \n+        resetFull();\n+        size = collection.size();\n+        assertTrue(\"Collection should changed by partial retainAll\",\n+                   collection.retainAll(elements.subList(2, 5)));\n+        confirmed.retainAll(elements.subList(2, 5));\n+        verify();\n+        \n+        Iterator iter = collection.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Collection only contains retained element\", \n+                       elements.subList(2, 5).contains(iter.next()));\n+        }\n+        \n+        resetFull();\n+        HashSet set = new HashSet(elements);\n+        size = collection.size();\n+        assertTrue(\"Collection shouldn't change from retainAll without \" +\n+                   \"duplicate elements\", !collection.retainAll(set));\n+        verify();\n+        assertEquals(\"Collection size didn't change from nonduplicate \" +\n+                     \"retainAll\", size, collection.size());\n+    }\n+    \n+    \n+    /**\n+     *  Tests {@link Collection#size}.\n+     */\n     public void testCollectionSize() {\n         Collection c = makeCollection();\n         assertEquals(\"Size of new Collection is 0.\",0,c.size());\n-        boolean added = tryToAdd(c,\"element1\");\n-        if(added) {\n-            assertEquals(\"If one element was added, the Collection.size() should be 1.\",1,c.size());\n-        }\n-    }\n-\n+\n+        c = makeFullCollection();\n+        assertTrue(\"Size of full collection should be nonzero\", c.size() != 0);\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Collection#toArray()}.\n+     */\n     public void testCollectionToArray() {\n         Collection c = makeCollection();\n-        assertEquals(\"Empty Collection should return empty array for toArray\",0,c.toArray().length);\n-        boolean added = tryToAdd(c,\"element1\");\n-        if(added) {\n-            assertEquals(\"If an element was added, the Collection.toArray().length should be 1.\",1,c.toArray().length);\n-        } else {\n-            assertEquals(\"Empty Collection should return empty array for toArray\",0,c.toArray().length);\n-        }\n-\n-        boolean added2 = tryToAdd(c,\"element2\");\n-        if(added && added2) {\n-            assertEquals(\"If another element was added, the Collection.toArray().length should be 2.\",2,c.toArray().length);\n-        } else if(added2) {\n-            assertEquals(\"If an element was added, the Collection.toArray().length should be 1.\",1,c.toArray().length);\n-        } else {\n-            assertEquals(\"Empty Collection should return empty array for toArray\",0,c.toArray().length);\n-        }\n-    }\n-\n+        assertEquals(\"Empty Collection should return empty array for toArray\",\n+                     0, c.toArray().length);\n+\n+        c = makeFullCollection();\n+        HashBag bag = new HashBag(c);\n+        Object[] array = c.toArray();\n+        assertEquals(\"Full collection toArray should be same size as \" +\n+                     \"collection\", array.length, c.size());\n+        for (int i = 0; i < array.length; i++) {\n+            assertTrue(\"Collection should contain element in toArray\",\n+                       c.contains(array[i]));\n+            bag.remove(array[i], 1);\n+        }\n+        assertTrue(\"Collection should return all its elements in toArray\",\n+                   bag.isEmpty());\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Collection.toArray(Object[])}.\n+     */\n     public void testCollectionToArray2() {\n         Collection c = makeCollection();\n-        assertEquals(10,c.toArray(new String[10]).length);\n-        assertEquals(7,c.toArray(new Object[7]).length);\n-        boolean added1 = tryToAdd(c,\"element1\");\n-        if(added1) {\n-            String[] fits = new String[1];\n-            String[] small = new String[0];\n-            assertSame(fits,c.toArray(fits));\n-            assertTrue(small != c.toArray(small));\n-        }\n-    }\n+        Object[] a = new Object[] { new Object(), null, null };\n+        Object[] array = c.toArray(a);\n+        assertEquals(\"Given array shouldn't shrink\", array, a);\n+        assertEquals(\"Last element should be set to null\", a[0], null);\n+        \n+        c = makeFullCollection();\n+        try {\n+            array = c.toArray(new Void[0]);\n+            fail(\"toArray(new Void[0]) should raise ArrayStore\");\n+        } catch (ArrayStoreException e) {\n+            // expected\n+        }\n+\n+        try {\n+            array = c.toArray(null);\n+            fail(\"toArray(null) should raise NPE\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        \n+        array = c.toArray(new Object[0]);\n+        a = c.toArray();\n+        assertEquals(\"toArrays should be equal\", \n+                     Arrays.asList(array), Arrays.asList(a));\n+\n+        // Figure out if they're all the same class\n+        // TODO: It'd be nicer to detect a common superclass\n+        HashSet classes = new HashSet();\n+        for (int i = 0; i < array.length; i++) {\n+            classes.add((array[i] == null) ? null : array[i].getClass());\n+        }\n+        if (classes.size() > 1) return;\n+        \n+        Class cl = (Class)classes.iterator().next();\n+        a = (Object[])Array.newInstance(cl, 0);\n+        array = c.toArray(a);\n+        assertEquals(\"toArray(Object[]) should return correct array type\",\n+                     a.getClass(), array.getClass());\n+        assertEquals(\"type-specific toArrays should be equal\", \n+                     Arrays.asList(array), Arrays.asList(c.toArray()));\n+    }\n+\n+\n+    /**\n+     *  Tests <Code>toString</Code> on a collection.\n+     */\n+    public void testCollectionToString() {\n+        Collection c = makeCollection();\n+        assertTrue(\"toString shouldn't return null\", c.toString() != null);\n+\n+        c = makeFullCollection();\n+        assertTrue(\"toString shouldn't return null\", c.toString() != null);\n+    }\n+\n+\n+    /**\n+     *  If supportsRemove() returns false, tests to see that remove\n+     *  operations raise an UnsupportedOperationException.\n+     */\n+    public void testUnsupportedRemove() {\n+        if (supportsRemove()) return;\n+\n+        try {\n+            makeCollection().clear();\n+            fail(\"clear should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            makeCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            makeCollection().removeAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            makeCollection().retainAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            Collection c = makeFullCollection();\n+            Iterator iterator = c.iterator();\n+            iterator.next();\n+            iterator.remove();\n+            fail(\"iterator.remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests that the collection's iterator is fail-fast.  \n+     */\n+    public void testCollectionIteratorFailFast() {\n+        if (supportsAdd()) {\n+            try {\n+                Collection c = makeFullCollection();\n+                Iterator iter = c.iterator();\n+                c.add(getOtherElements()[0]);\n+                iter.next();\n+                fail(\"next after add should raise ConcurrentModification\");\n+            } catch (ConcurrentModificationException e) {\n+                // expected\n+            }\n+            \n+            try {\n+                Collection c = makeFullCollection();\n+                Iterator iter = c.iterator();\n+                c.addAll(Arrays.asList(getOtherElements()));\n+                iter.next();\n+                fail(\"next after addAll should raise ConcurrentModification\");\n+            } catch (ConcurrentModificationException e) {\n+                // expected\n+            }\n+        }\n+\n+        if (!supportsRemove()) return;\n+\n+        try {\n+            Collection c = makeFullCollection();\n+            Iterator iter = c.iterator();\n+            c.clear();\n+            iter.next();\n+            fail(\"next after clear should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        } catch (NoSuchElementException e) {\n+            // (also legal given spec)\n+        }\n+        \n+        try {\n+            Collection c = makeFullCollection();\n+            Iterator iter = c.iterator();\n+            c.remove(getFullElements()[0]);\n+            iter.next();\n+            fail(\"next after remove should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            Collection c = makeFullCollection();\n+            Iterator iter = c.iterator();\n+            c.removeAll(Arrays.asList(getFullElements()).subList(2,5));\n+            iter.next();\n+            fail(\"next after removeAll should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        try {\n+            Collection c = makeFullCollection();\n+            Iterator iter = c.iterator();\n+            c.retainAll(Arrays.asList(getFullElements()).subList(2,5));\n+            iter.next();\n+            fail(\"next after retainAll should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+    }\n+\n \n     /**\n      * Try to add the given object to the given Collection.\n      * ClassCastException, or IllegalArgumentException is thrown.\n      */\n     protected boolean tryToAdd(Collection c,Object obj) {\n+        // FIXME: Delete this method after TestList is patched\n         try {\n             return c.add(obj);\n         } catch(UnsupportedOperationException e) {\n             return false; // never get here, since fail throws exception\n         }\n     }\n+\n+\n+    \n+    /**\n+     *  Returns a list of elements suitable for return by\n+     *  {@link getFullElements}.  The array returned by this method\n+     *  does not include null, but does include a variety of objects \n+     *  of different types.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  the null element.\n+     */\n+    public static Object[] getFullNonNullElements() {\n+        return new Object[] {\n+            new String(\"\"),\n+            new String(\"One\"),\n+            new Integer(2),\n+            \"Three\",\n+            new Integer(4),\n+            \"One\",\n+            new Double(5),\n+            new Float(6),\n+            \"Seven\",\n+            \"Eight\",\n+            new String(\"Nine\"),\n+            new Integer(10),\n+            new Short((short)11),\n+            new Long(12),\n+            \"Thirteen\",\n+            \"14\",\n+            \"15\",\n+            new Byte((byte)16)\n+        };\n+    }\n+\n+\n+    /**\n+     *  Returns the default list of objects returned by \n+     *  {@link getOtherElements}.  Includes many objects\n+     *  of different types.\n+     */\n+    public static Object[] getOtherNonNullElements() {\n+        return new Object[] {\n+            new Integer(0),\n+            new Float(0),\n+            new Double(0),\n+            \"Zero\",\n+            new Short((short)0),\n+            new Byte((byte)0),\n+            new Long(0),\n+            new Character('\\u0000'),\n+            \"0\"\n+        };\n+    }\n+\n+\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link getFullElements}.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public static Object[] getFullNonNullStringElements() {\n+        return new Object[] {\n+            \"If\",\"the\",\"dull\",\"substance\",\"of\",\"my\",\"flesh\",\"were\",\"thought\",\n+            \"Injurious\",\"distance\",\"could\",\"not\",\"stop\",\"my\",\"way\",\n+        };\n+    }\n+\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link getOtherElements}.  Override getOtherElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public static Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\",\"then\",\"despite\",/* of */\"space\",\"I\",\"would\",\"be\",\"brought\",\n+            \"From\",\"limits\",\"far\",\"remote\",\"where\",\"thou\",\"dost\",\"stay\"\n+        };\n+    }\n }\n--- a/src/test/org/apache/commons/collections/TestList.java\n+++ b/src/test/org/apache/commons/collections/TestList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.8 2002/02/26 18:45:46 morgand Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/02/26 18:45:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.9 2002/06/18 01:14:23 mas Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/06/18 01:14:23 $\n  *\n  * ====================================================================\n  *\n  * test case (method) your {@link List} fails.\n  *\n  * @author Rodney Waldhoff\n- * @version $Id: TestList.java,v 1.8 2002/02/26 18:45:46 morgand Exp $\n+ * @version $Id: TestList.java,v 1.9 2002/06/18 01:14:23 mas Exp $\n  */\n public abstract class TestList extends TestCollection {\n     public TestList(String testName) {\n         assertEquals(\"List is the right size\",list.size(), 4);\n     }\n \n+    protected Collection makeConfirmedCollection() {\n+        ArrayList list = new ArrayList();\n+        return list;\n+    }\n+\n+    protected Collection makeConfirmedFullCollection() {\n+        ArrayList list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n }", "timestamp": 1024362863, "metainfo": ""}