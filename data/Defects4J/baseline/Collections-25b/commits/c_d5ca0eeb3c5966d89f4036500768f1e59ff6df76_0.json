{"sha": "d5ca0eeb3c5966d89f4036500768f1e59ff6df76", "log": "Changed PriorityQueue and BinaryHeap to allow objects that do not implement Comparable.  BinaryHeap implements this by accepting an optional Comparator in its constructor.  If no comparator is specified, the object's natural ordering is used (i.e. it is cast to a Comparable and compared using its compareTo method)  Also added basic tests for BinaryHeap   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BinaryHeap.java\n+++ b/src/java/org/apache/commons/collections/BinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.4 2002/02/22 04:16:19 mas Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/02/22 04:16:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.5 2002/03/19 04:34:18 mas Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/03/19 04:34:18 $\n  *\n  * ====================================================================\n  *\n package org.apache.commons.collections;\n \n import java.util.NoSuchElementException;\n+import java.util.Comparator;\n \n /**\n  * Binary heap implementation of {@link PriorityQueue}.\n     protected final static int      DEFAULT_CAPACITY   = 13;\n \n     protected int                   m_size;\n-    protected Comparable[]          m_elements;\n+    protected Object[]              m_elements;\n     protected boolean               m_isMinHeap;\n+    private Comparator              m_comparator;\n \n     /**\n      *  Create a new minimum binary heap.\n     public BinaryHeap()\n     {\n         this( DEFAULT_CAPACITY, true );\n+    }\n+\n+    public BinaryHeap( Comparator comparator )\n+    {\n+        this();\n+        m_comparator = comparator;\n     }\n \n     /**\n         this( capacity, true );\n     }\n \n+    public BinaryHeap( final int capacity, Comparator comparator )\n+    {\n+        this( capacity );\n+        m_comparator = comparator;\n+    }\n+\n     /**\n      *  Create a new minimum or maximum binary heap\n      *\n         this( DEFAULT_CAPACITY, isMinHeap );\n     }\n \n+    public BinaryHeap( final boolean isMinHeap, Comparator comparator )\n+    {\n+        this( isMinHeap );\n+        m_comparator = comparator;\n+    }\n+\n     /**\n      *  Create a new minimum or maximum binary heap with the specified \n      *  initial capacity.\n         m_isMinHeap = isMinHeap;\n \n         //+1 as 0 is noop\n-        m_elements = new Comparable[ capacity + 1 ];\n+        m_elements = new Object[ capacity + 1 ];\n+    }\n+\n+    public BinaryHeap( final int capacity, final boolean isMinHeap,\n+                       Comparator comparator ) \n+    {\n+        this( capacity, isMinHeap );\n+        m_comparator = comparator;\n     }\n \n     /**\n      *\n      * @param element the element to be inserted\n      */\n-    public void insert( final Comparable element )\n+    public void insert( final Object element )\n     {\n         if( isFull() ) grow();\n \n      * @return the element at top of heap\n      * @exception NoSuchElementException if <code>isEmpty() == true</code>\n      */\n-    public Comparable peek() throws NoSuchElementException\n+    public Object peek() throws NoSuchElementException\n     {\n         if( isEmpty() ) throw new NoSuchElementException();\n         else return m_elements[ 1 ];\n      * @return the element at top of heap\n      * @exception NoSuchElementException if <code>isEmpty() == true</code>\n      */\n-    public Comparable pop() throws NoSuchElementException\n-    {\n-        final Comparable result = peek();\n+    public Object pop() throws NoSuchElementException\n+    {\n+        final Object result = peek();\n         m_elements[ 1 ] = m_elements[ m_size-- ];\n \n         //set the unused element to 'null' so that the garbage collector\n      */\n     protected void percolateDownMinHeap( final int index )\n     {\n-        final Comparable element = m_elements[ index ];\n+        final Object element = m_elements[ index ];\n+\n+        int hole = index;\n+\n+        while( (hole * 2) <= m_size )\n+        {\n+            int child = hole * 2;\n+\n+            //if we have a right child and that child can not be percolated\n+            //up then move onto other child\n+            if( child != m_size && \n+                compare( m_elements[ child + 1 ], m_elements[ child ] ) < 0 )\n+            {\n+                child++;\n+            }\n+\n+            //if we found resting place of bubble then terminate search\n+            if( compare( m_elements[ child ], element ) >= 0 )\n+            {\n+                break;\n+            }\n+\n+            m_elements[ hole ] = m_elements[ child ];\n+            hole = child;\n+        }\n+\n+        m_elements[ hole ] = element;\n+    }\n+\n+    /**\n+     * Percolate element down heap from top.\n+     * Assume it is a maximum heap.\n+     *\n+     * @param index the index of the element\n+     */\n+    protected void percolateDownMaxHeap( final int index )\n+    {\n+        final Object element = m_elements[ index ];\n \n         int hole = index;\n \n             //if we have a right child and that child can not be percolated\n             //up then move onto other child\n             if( child != m_size &&\n-                m_elements[ child + 1 ].compareTo( m_elements[ child ] ) < 0 )\n+                compare( m_elements[ child + 1 ], m_elements[ child ] ) > 0 )\n             {\n                 child++;\n             }\n \n             //if we found resting place of bubble then terminate search\n-            if( m_elements[ child ].compareTo( element ) >= 0 )\n+            if( compare( m_elements[ child ], element ) <= 0 )\n             {\n                 break;\n             }\n     }\n \n     /**\n-     * Percolate element down heap from top.\n-     * Assume it is a maximum heap.\n-     *\n-     * @param index the index of the element\n-     */\n-    protected void percolateDownMaxHeap( final int index )\n-    {\n-        final Comparable element = m_elements[ index ];\n-\n-        int hole = index;\n-\n-        while( (hole * 2) <= m_size )\n-        {\n-            int child = hole * 2;\n-\n-            //if we have a right child and that child can not be percolated\n-            //up then move onto other child\n-            if( child != m_size &&\n-                m_elements[ child + 1 ].compareTo( m_elements[ child ] ) > 0 )\n-            {\n-                child++;\n-            }\n-\n-            //if we found resting place of bubble then terminate search\n-            if( m_elements[ child ].compareTo( element ) <= 0 )\n-            {\n-                break;\n-            }\n-\n-            m_elements[ hole ] = m_elements[ child ];\n-            hole = child;\n-        }\n-\n-        m_elements[ hole ] = element;\n-    }\n-\n-    /**\n      * Percolate element up heap from bottom.\n      * Assume it is a maximum heap.\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMinHeap( final Comparable element )\n+    protected void percolateUpMinHeap( final Object element )\n     {\n         int hole = ++m_size;\n \n         m_elements[ hole ] = element;\n \n         while( hole > 1 &&\n-               element.compareTo( m_elements[ hole / 2 ] ) < 0 )\n+               compare( element,  m_elements[ hole / 2 ] ) < 0 )\n         {\n             //save element that is being pushed down\n             //as the element \"bubble\" is percolated up\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMaxHeap( final Comparable element )\n+    protected void percolateUpMaxHeap( final Object element )\n     {\n         int hole = ++m_size;\n \n         while( hole > 1 &&\n-               element.compareTo( m_elements[ hole / 2 ] ) > 0 )\n+               compare( element, m_elements[ hole / 2 ] ) > 0 )\n         {\n             //save element that is being pushed down\n             //as the element \"bubble\" is percolated up\n         m_elements[ hole ] = element;\n     }\n \n+    private int compare(Object a, Object b) {\n+        if(m_comparator != null) {\n+            return m_comparator.compare(a, b);\n+        } else {\n+            return ((Comparable)a).compareTo(b);\n+        }\n+    }\n+\n     /**\n      *  Increase the size of the heap to support additional elements\n      **/\n     protected void grow()\n     {\n-        final Comparable[] elements =\n-            new Comparable[ m_elements.length * 2 ];\n+        final Object[] elements = new Object[ m_elements.length * 2 ];\n         System.arraycopy( m_elements, 0, elements, 0, m_elements.length );\n         m_elements = elements;\n     }\n--- a/src/java/org/apache/commons/collections/PriorityQueue.java\n+++ b/src/java/org/apache/commons/collections/PriorityQueue.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PriorityQueue.java,v 1.3 2002/02/10 08:07:42 jstrachan Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/02/10 08:07:42 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PriorityQueue.java,v 1.4 2002/03/19 04:34:18 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/03/19 04:34:18 $\n  *\n  * ====================================================================\n  *\n      * Insert an element into queue.\n      *\n      * @param element the element to be inserted\n+     *\n+     * @exception ClassCastException if the specified <code>element</code>'s\n+     * type prevents it from being compared to other items in the queue to\n+     * determine its relative priority.  \n      */\n-    void insert( Comparable element );\n+    void insert( Object element );\n \n     /**\n      * Return element on top of heap but don't remove it.\n      *\n      * @return the element at top of heap\n-     * @exception NoSuchElementException if isEmpty() == true\n+     * @exception NoSuchElementException if <code>isEmpty() == true</code>\n      */\n-    Comparable peek() throws NoSuchElementException;\n+    Object peek() throws NoSuchElementException;\n \n     /**\n      * Return element on top of heap and remove it.\n      *\n      * @return the element at top of heap\n-     * @exception NoSuchElementException if isEmpty() == true\n+     * @exception NoSuchElementException if <code>isEmpty() == true</code>\n      */\n-    Comparable pop() throws NoSuchElementException;\n+    Object pop() throws NoSuchElementException;\n }\n \n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.23 2002/03/01 23:31:35 morgand Exp $\n- * $Revision: 1.23 $\n- * $Date: 2002/03/01 23:31:35 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.24 2002/03/19 04:34:18 mas Exp $\n+ * $Revision: 1.24 $\n+ * $Date: 2002/03/19 04:34:18 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.23 2002/03/01 23:31:35 morgand Exp $\n+ * @version $Id: TestAll.java,v 1.24 2002/03/19 04:34:18 mas Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestArrayIterator2.suite());\n         suite.addTest(TestArrayStack.suite());\n         suite.addTest(TestBeanMap.suite());\n+        suite.addTest(TestBinaryHeap.suite());\n         suite.addTest(TestCollectionUtils.suite());\n         suite.addTest(TestComparableComparator.suite());\n         suite.addTest(TestComparatorChain.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestBinaryHeap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBinaryHeap.java,v 1.1 2002/03/19 04:34:18 mas Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/03/19 04:34:18 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.*;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * Tests the BinaryHeap.\n+ * \n+ * @author <a href=\"mas@apache.org\">Michael A. Smith</a>\n+ * @version $Id: TestBinaryHeap.java,v 1.1 2002/03/19 04:34:18 mas Exp $\n+ */\n+public class TestBinaryHeap extends TestObject {\n+    \n+  public static Test suite() {\n+    return new TestSuite(TestBinaryHeap.class);\n+  }\n+  \n+  public TestBinaryHeap(String testName) {\n+    super(testName);\n+  }\n+  \n+  /**\n+   * Return a new, empty {@link Object} to used for testing.\n+   */\n+  public Object makeObject() {\n+    return new BinaryHeap();\n+  }\n+  \n+  public void testBasicOps() {\n+    BinaryHeap heap = new BinaryHeap();\n+    \n+    assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+    \n+    try {\n+      heap.peek();\n+      fail(\"NoSuchElementException should be thrown if peek is called \" +\n+           \"before any elements are inserted\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }\n+    \n+    try {\n+      heap.pop();\n+      fail(\"NoSuchElementException should be thrown if pop is called \" +\n+           \"before any elements are inserted\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }\n+    \n+    heap.insert(\"a\");\n+    heap.insert(\"c\");\n+    heap.insert(\"e\");\n+    heap.insert(\"b\");\n+    heap.insert(\"d\");\n+    heap.insert(\"n\");\n+    heap.insert(\"m\");\n+    heap.insert(\"l\");\n+    heap.insert(\"k\");\n+    heap.insert(\"j\");\n+    heap.insert(\"i\");\n+    heap.insert(\"h\");\n+    heap.insert(\"g\");\n+    heap.insert(\"f\");\n+    \n+    assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n+    \n+    for(int i = 0; i < 14; i++) {\n+      assertEquals(\"peek using default constructor should return \" +\n+                   \"minimum value in the binary heap\", \n+                   String.valueOf((char)('a' + i)), heap.peek());\n+      \n+      assertEquals(\"pop using default constructor should return minimum \" +\n+                   \"value in the binary heap\", \n+                   String.valueOf((char)('a' + i)), heap.pop());\n+      \n+      if(i + 1 < 14) {\n+        assertTrue(\"heap should not be empty before all elements are popped\",\n+                   !heap.isEmpty());\n+      } else {\n+        assertTrue(\"heap should be empty after all elements are popped\", \n+                   heap.isEmpty());\n+      }\n+    }\n+\n+    try {\n+      heap.peek();\n+      fail(\"NoSuchElementException should be thrown if peek is called \" +\n+           \"after all elements are popped\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }\n+    \n+    try {\n+      heap.pop();\n+      fail(\"NoSuchElementException should be thrown if pop is called \" +\n+           \"after all elements are popped\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }     \n+  }\n+  \n+  public void testBasicComparatorOps() {\n+    BinaryHeap heap = \n+      new BinaryHeap(new ReverseComparator(new ComparableComparator()));\n+    \n+    assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+    \n+    try {\n+      heap.peek();\n+      fail(\"NoSuchElementException should be thrown if peek is called \" +\n+           \"before any elements are inserted\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }\n+    \n+    try {\n+      heap.pop();\n+      fail(\"NoSuchElementException should be thrown if pop is called \" +\n+           \"before any elements are inserted\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }\n+    \n+    heap.insert(\"a\");\n+    heap.insert(\"c\");\n+    heap.insert(\"e\");\n+    heap.insert(\"b\");\n+    heap.insert(\"d\");\n+    heap.insert(\"n\");\n+    heap.insert(\"m\");\n+    heap.insert(\"l\");\n+    heap.insert(\"k\");\n+    heap.insert(\"j\");\n+    heap.insert(\"i\");\n+    heap.insert(\"h\");\n+    heap.insert(\"g\");\n+    heap.insert(\"f\");\n+    \n+    assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n+    \n+    for(int i = 0; i < 14; i++) {\n+\n+      // note: since we're using a comparator that reverses items, the\n+      // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n+\n+      assertEquals(\"peek using default constructor should return \" +\n+                   \"minimum value in the binary heap\", \n+                   String.valueOf((char)('n' - i)), heap.peek());\n+      \n+      assertEquals(\"pop using default constructor should return minimum \" +\n+                   \"value in the binary heap\", \n+                   String.valueOf((char)('n' - i)), heap.pop());\n+      \n+      if(i + 1 < 14) {\n+        assertTrue(\"heap should not be empty before all elements are popped\",\n+                   !heap.isEmpty());\n+      } else {\n+        assertTrue(\"heap should be empty after all elements are popped\", \n+                   heap.isEmpty());\n+      }\n+    }\n+\n+    try {\n+      heap.peek();\n+      fail(\"NoSuchElementException should be thrown if peek is called \" +\n+           \"after all elements are popped\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }\n+    \n+    try {\n+      heap.pop();\n+      fail(\"NoSuchElementException should be thrown if pop is called \" +\n+           \"after all elements are popped\");\n+    } catch (NoSuchElementException e) {\n+      // expected\n+    }     \n+  }\n+}\n+", "timestamp": 1016512458, "metainfo": ""}