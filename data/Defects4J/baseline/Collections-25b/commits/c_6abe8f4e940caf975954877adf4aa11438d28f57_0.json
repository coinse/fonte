{"sha": "6abe8f4e940caf975954877adf4aa11438d28f57", "log": "Add support for event reporting from SubList view Hopefully other views should also be supported   ", "commit": "\n--- a/src/java/org/apache/commons/collections/observed/ModificationHandler.java\n+++ b/src/java/org/apache/commons/collections/observed/ModificationHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandler.java,v 1.2 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ModificationHandler.java,v 1.3 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import java.util.Collection;\n \n-\n /**\n  * Defines a handler for collection modification events.\n  * <p>\n  * later collections release.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n     \n     /** The collection being observed */\n     private ObservedCollection collection = null;\n+    /** The root handler */\n+    protected final ModificationHandler rootHandler;\n+    /** The range offset, 0 if not a range */\n+    protected final int rangeOffset;\n     \n     // Constructors\n     //-----------------------------------------------------------------------\n      */\n     protected ModificationHandler() {\n         super();\n+        this.rootHandler = this;\n+        this.rangeOffset = 0;\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param rootHandler  the base underlying handler\n+     * @param rangeOffset  the offset on the base collection\n+     */\n+    protected ModificationHandler(ModificationHandler rootHandler, int rangeOffset) {\n+        super();\n+        this.rootHandler = rootHandler;\n+        this.rangeOffset = rangeOffset;\n     }\n \n     /**\n      * \n      * @return the observed collection\n      */\n-    public Collection getCollection() {\n+    public ObservedCollection getCollection() {\n         return collection;\n     }\n     \n      * @param object  the object that will be added/removed/set, the method param or derived\n      * @param repeat  the number of repeats of the add/remove, the method param or derived\n      * @param previous  the previous value that will be removed/replaced, must exist in coll\n-     */\n-    protected abstract boolean preEvent(int type, int index, Object object, int repeat, Object previous);\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n+     */\n+    protected abstract boolean preEvent(\n+            int type, int index, Object object, int repeat,\n+            Object previous, ObservedCollection range, int rangeOffset);\n \n     /**\n      * Handles the post event.\n      * @param object  the object that was added/removed/set, the method param or derived\n      * @param repeat  the number of repeats of the add/remove, the method param or derived\n      * @param previous  the previous value that was removed/replace, must have existed in coll\n-     */\n-    protected abstract void postEvent(boolean modified, int type, int index, Object object, int repeat, Object previous);\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n+     */\n+    protected abstract void postEvent(\n+            boolean modified, int type, int index, Object object, int repeat,\n+            Object previous, ObservedCollection range, int rangeOffset);\n \n     // Event handling\n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before add(obj) is called.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * It does not set the index for List implementations.\n      * \n      * @param object  the object being added\n      * @return true to process modification\n      */\n     protected boolean preAdd(Object object) {\n-        return preEvent(ModificationEventType.ADD, -1, object, 1, null);\n+        return preEvent(ModificationEventType.ADD, -1, object, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after add(obj) is called.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * It does not set the index for List implementations.\n      * \n      * @param object  the object being added\n      * @param result  the result from the add method\n      */\n     protected void postAdd(Object object, boolean result) {\n-        postEvent(result, ModificationEventType.ADD, -1, object, 1, null);\n+        postEvent(result, ModificationEventType.ADD, -1, object, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before add(int,obj) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to add at\n      * @param object  the object being added\n      * @return true to process modification\n      */\n     protected boolean preAddIndexed(int index, Object object) {\n-        return preEvent(ModificationEventType.ADD_INDEXED, index, object, 1, null);\n+        return preEvent(ModificationEventType.ADD_INDEXED, index + rangeOffset, object, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after add(int,obj) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to add at\n      * @param object  the object being added\n      */\n     protected void postAddIndexed(int index, Object object) {\n-        postEvent(true, ModificationEventType.ADD_INDEXED, index, object, 1, null);\n+        postEvent(true, ModificationEventType.ADD_INDEXED, index + rangeOffset, object, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before add(obj,int) is called on a Bag.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param object  the object being added\n      * @param nCopies  the number of copies being added\n      * @return true to process modification\n      */\n     protected boolean preAddNCopies(Object object, int nCopies) {\n-        return preEvent(ModificationEventType.ADD_NCOPIES, -1, object, nCopies, null);\n+        return preEvent(ModificationEventType.ADD_NCOPIES, -1, object, nCopies, null, null, -1);\n     }\n \n     /**\n      * Send an event after add(obj,int) is called on a Bag.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * The method result is not used by this implementation (Bag violates the\n      * Collection contract)\n      * \n      * @param result  the method result\n      */\n     protected void postAddNCopies(Object object, int nCopies, boolean result) {\n-        postEvent(true, ModificationEventType.ADD_NCOPIES, -1, object, nCopies, null);\n+        postEvent(true, ModificationEventType.ADD_NCOPIES, -1, object, nCopies, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before add(obj) is called on a ListIterator.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index of the iterator\n      * @param object  the object being added\n      * @return true to process modification\n      */\n     protected boolean preAddIterated(int index, Object object) {\n-        return preEvent(ModificationEventType.ADD_ITERATED, index, object, 1, null);\n+        return preEvent(ModificationEventType.ADD_ITERATED, index + rangeOffset, object, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after add(obj) is called on a ListIterator.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index of the iterator\n      * @param object  the object being added\n      */\n     protected void postAddIterated(int index, Object object) {\n         // assume collection changed\n-        postEvent(true, ModificationEventType.ADD_ITERATED, index, object, 1, null);\n+        postEvent(true, ModificationEventType.ADD_ITERATED, index + rangeOffset, object, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before addAll(coll) is called.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param coll  the collection being added\n      * @return true to process modification\n      */\n     protected boolean preAddAll(Collection coll) {\n-        return preEvent(ModificationEventType.ADD_ALL, -1, coll, 1, null);\n+        return preEvent(ModificationEventType.ADD_ALL, -1, coll, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after addAll(coll) is called.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param coll  the collection being added\n      * @param collChanged  the result from the addAll method\n      */\n     protected void postAddAll(Collection coll, boolean collChanged) {\n-        postEvent(collChanged, ModificationEventType.ADD_ALL, -1, coll, 1, null);\n+        postEvent(collChanged, ModificationEventType.ADD_ALL, -1, coll, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before addAll(int,coll) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to addAll at\n      * @param coll  the collection being added\n      * @return true to process modification\n      */\n     protected boolean preAddAllIndexed(int index, Collection coll) {\n-        return preEvent(ModificationEventType.ADD_ALL_INDEXED, index, coll, 1, null);\n+        return preEvent(ModificationEventType.ADD_ALL_INDEXED, index + rangeOffset, coll, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after addAll(int,coll) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to addAll at\n      * @param coll  the collection being added\n      * @param collChanged  the result from the addAll method\n      */\n     protected void postAddAllIndexed(int index, Collection coll, boolean collChanged) {\n-        postEvent(collChanged, ModificationEventType.ADD_ALL_INDEXED, index, coll, 1, null);\n+        postEvent(collChanged, ModificationEventType.ADD_ALL_INDEXED, index + rangeOffset, coll, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return true to process modification\n      */\n     protected boolean preClear() {\n-        return preEvent(ModificationEventType.CLEAR, -1, null, 1, null);\n+        return preEvent(ModificationEventType.CLEAR, -1, null, 1, null, null, -1);\n     }\n \n     /**\n      */\n     protected void postClear() {\n         // assumes a modification occurred\n-        postEvent(true, ModificationEventType.CLEAR, -1, null, 1, null);\n+        postEvent(true, ModificationEventType.CLEAR, -1, null, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before remove(obj) is called.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param object  the object being removed\n      * @return true to process modification\n      */\n     protected boolean preRemove(Object object) {\n-        return preEvent(ModificationEventType.REMOVE, -1, object, 1, null);\n+        return preEvent(ModificationEventType.REMOVE, -1, object, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after remove(obj) is called.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param object  the object being removed\n      * @param collChanged  the result from the remove method\n      */\n     protected void postRemove(Object object, boolean collChanged) {\n-        postEvent(collChanged, ModificationEventType.REMOVE, -1, object, 1, (collChanged ? object : null));\n+        postEvent(collChanged, ModificationEventType.REMOVE, -1, object, 1, (collChanged ? object : null), null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before remove(int) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to remove at\n      * @return true to process modification\n     protected boolean preRemoveIndexed(int index) {\n         // could do a get(index) to determine previousValue\n         // we don't for performance, but subclass may override\n-        return preEvent(ModificationEventType.REMOVE_INDEXED, index, null, 1, null);\n+        return preEvent(ModificationEventType.REMOVE_INDEXED, index + rangeOffset, null, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after remove(int) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to remove at\n      * @param previousValue  the result from the remove method\n      */\n     protected void postRemoveIndexed(int index, Object previousValue) {\n-        postEvent(true, ModificationEventType.REMOVE_INDEXED, index, null, 1, previousValue);\n+        postEvent(true, ModificationEventType.REMOVE_INDEXED, index + rangeOffset, null, 1, previousValue, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before remove(obj,int) is called on a Bag.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param object  the object being removed\n      * @param nCopies  the number of copies being removed\n      * @return true to process modification\n      */\n     protected boolean preRemoveNCopies(Object object, int nCopies) {\n-        return preEvent(ModificationEventType.REMOVE_NCOPIES, -1, object, nCopies, null);\n+        return preEvent(ModificationEventType.REMOVE_NCOPIES, -1, object, nCopies, null, null, -1);\n     }\n \n     /**\n      * Send an event after remove(obj,int) is called on a Bag.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param object  the object being removed\n      * @param nCopies  the number of copies being removed\n      * @param collChanged  the result from the remove method\n      */\n     protected void postRemoveNCopies(Object object, int nCopies, boolean collChanged) {\n-        postEvent(collChanged, ModificationEventType.REMOVE_NCOPIES, -1, object, nCopies, (collChanged ? object : null));\n+        postEvent(collChanged, ModificationEventType.REMOVE_NCOPIES, -1, object, nCopies, (collChanged ? object : null), null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before remove(obj) is called on an Iterator.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index of the iterator\n      * @param removedValue  the object being removed\n      * @return true to process modification\n      */\n     protected boolean preRemoveIterated(int index, Object removedValue) {\n-        return preEvent(ModificationEventType.REMOVE_ITERATED, index, removedValue, 1, removedValue);\n+        return preEvent(ModificationEventType.REMOVE_ITERATED, index + rangeOffset, removedValue, 1, removedValue, null, -1);\n     }\n \n     /**\n      * Send an event after remove(obj) is called on an Iterator.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index of the iterator\n      * @param removedValue  the previous value at this index\n      */\n     protected void postRemoveIterated(int index, Object removedValue) {\n         // assume collection changed\n-        postEvent(true, ModificationEventType.REMOVE_ITERATED, index, removedValue, 1, removedValue);\n+        postEvent(true, ModificationEventType.REMOVE_ITERATED, index + rangeOffset, removedValue, 1, removedValue, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before removeAll(coll) is called.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param coll  the collection being removed\n      * @return true to process modification\n      */\n     protected boolean preRemoveAll(Collection coll) {\n-        return preEvent(ModificationEventType.REMOVE_ALL, -1, coll, 1, null);\n+        return preEvent(ModificationEventType.REMOVE_ALL, -1, coll, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after removeAll(coll) is called.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param coll  the collection being removed\n      * @param collChanged  the result from the removeAll method\n      */\n     protected void postRemoveAll(Collection coll, boolean collChanged) {\n-        postEvent(collChanged, ModificationEventType.REMOVE_ALL, -1, coll, 1, null);\n+        postEvent(collChanged, ModificationEventType.REMOVE_ALL, -1, coll, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before retainAll(coll) is called.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param coll  the collection being retained\n      * @return true to process modification\n      */\n     protected boolean preRetainAll(Collection coll) {\n-        return preEvent(ModificationEventType.RETAIN_ALL, -1, coll, 1, null);\n+        return preEvent(ModificationEventType.RETAIN_ALL, -1, coll, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after retainAll(coll) is called.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param coll  the collection being retained\n      * @param collChanged  the result from the retainAll method\n      */\n     protected void postRetainAll(Collection coll, boolean collChanged) {\n-        postEvent(collChanged, ModificationEventType.RETAIN_ALL, -1, coll, 1, null);\n+        postEvent(collChanged, ModificationEventType.RETAIN_ALL, -1, coll, 1, null, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before set(int,obj) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to add at\n      * @param object  the object being added\n     protected boolean preSetIndexed(int index, Object object) {\n         // could do a get(index) to determine previousValue\n         // we don't for performance, but subclass may override\n-        return preEvent(ModificationEventType.SET_INDEXED, index, object, 1, null);\n+        return preEvent(ModificationEventType.SET_INDEXED, index + rangeOffset, object, 1, null, null, -1);\n     }\n \n     /**\n      * Send an event after set(int,obj) is called on a List.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to add at\n      * @param object  the object being added\n      */\n     protected void postSetIndexed(int index, Object object, Object previousValue) {\n         // reference check for modification, in case equals() has issues (eg. performance)\n-        postEvent((object != previousValue), ModificationEventType.SET_INDEXED, index, object, 1, previousValue);\n+        postEvent((object != previousValue), ModificationEventType.SET_INDEXED, index + rangeOffset, object, 1, previousValue, null, -1);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Store data and send event before set(obj) is called on a ListIterator.\n      * <p>\n-     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #preEvent(int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to set at\n      * @param object  the object being added\n      * @return true to process modification\n      */\n     protected boolean preSetIterated(int index, Object object, Object previousValue) {\n-        return preEvent(ModificationEventType.SET_ITERATED, index, object, 1, previousValue);\n+        return preEvent(ModificationEventType.SET_ITERATED, index + rangeOffset, object, 1, previousValue, null, -1);\n     }\n \n     /**\n      * Send an event after set(obj) is called on a ListIterator.\n      * <p>\n-     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object)}.\n+     * This implementation forwards to {@link #postEvent(boolean, int, int, Object, int, Object, Object, int)}.\n      * \n      * @param index  the index to set at\n      * @param object  the object being added\n      */\n     protected void postSetIterated(int index, Object object, Object previousValue) {\n         // reference check for modification, in case equals() has issues (eg. performance)\n-        postEvent((object != previousValue), ModificationEventType.SET_ITERATED, index, object, 1, previousValue);\n-    }\n-\n+        postEvent((object != previousValue), ModificationEventType.SET_ITERATED, index + rangeOffset, object, 1, previousValue, null, -1);\n+    }\n+\n+    // Views\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new handler for subLists that is aware of the offset.\n+     * \n+     * @param fromIndex  the sublist fromIndex (inclusive)\n+     * @param toIndex  the sublist toIndex (exclusive)\n+     */\n+    protected ModificationHandler createSubListHandler(int fromIndex, int toIndex) {\n+        return new SubListHandler(rootHandler, fromIndex + rangeOffset);\n+    }\n+    \n+    protected class SubListHandler extends ModificationHandler {\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param rootHandler  the base underlying handler\n+         * @param rangeOffset  the offset on the base collection\n+         */\n+        protected SubListHandler(ModificationHandler rootHandler, int rangeOffset) {\n+            super(rootHandler, rangeOffset);\n+        }\n+\n+        /**\n+         * Override the preEvent method to forward all events to the \n+         * underlying handler. This method also inserts details of the range\n+         * that caused the event.\n+         */\n+        protected boolean preEvent(\n+                int type, int index, Object object, int repeat,\n+                Object previous, ObservedCollection ignoredRange, int ignoredOffset) {\n+\n+            return rootHandler.preEvent(\n+                type, index, object, repeat,\n+                previous, getCollection(), this.rangeOffset);\n+        }\n+\n+        /**\n+         * Override the postEvent method to forward all events to the \n+         * underlying handler. This method also inserts details of the range\n+         * that caused the event.\n+         */\n+        protected void postEvent(\n+                boolean modified, int type, int index, Object object, int repeat,\n+                Object previous, ObservedCollection ignoredRange, int ignoredOffset) {\n+\n+            rootHandler.postEvent(\n+                modified, type, index, object, repeat,\n+                previous, getCollection(), this.rangeOffset);\n+        }\n+    }\n+    \n     // toString\n     //-----------------------------------------------------------------------\n     /**\n--- a/src/java/org/apache/commons/collections/observed/ObservedCollection.java\n+++ b/src/java/org/apache/commons/collections/observed/ObservedCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedCollection.java,v 1.2 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedCollection.java,v 1.3 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * See this class for details of configuration available.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n \n     /**\n+     * Constructor used by subclass views, such as subList.\n+     * \n+     * @param handler  the observing handler, may be null\n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected ObservedCollection(\n+            final ModificationHandler handler,\n+            final Collection coll) {\n+        super(coll);\n+        this.handler = handler;\n+    }\n+\n+    /**\n      * Creates a handler subclass based on the specified listener.\n      * <p>\n      * The method is defined in terms of an Object to allow for unusual\n--- a/src/java/org/apache/commons/collections/observed/ObservedList.java\n+++ b/src/java/org/apache/commons/collections/observed/ObservedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedList.java,v 1.2 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/Attic/ObservedList.java,v 1.3 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n package org.apache.commons.collections.observed;\n \n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n \n  * The handler manages the event, notifying listeners and optionally vetoing changes.\n  * The default handler is {@link StandardModificationHandler}.\n  * See this class for details of configuration available.\n+ * <p>\n+ * All indices on events returned by <code>subList</code> are relative to the\n+ * base <code>List</code>.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n public class ObservedList extends ObservedCollection implements List {\n-    \n+\n     // Factories\n     //-----------------------------------------------------------------------\n     /**\n     }\n     \n     /**\n+     * Constructor used by subclass views, such as subList.\n+     * \n+     * @param handler  the handler to use, must not be null\n+     * @param list  the subList to decorate, must not be null\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    protected ObservedList(\n+            final ModificationHandler handler,\n+            final List list) {\n+        super(handler, list);\n+    }\n+    \n+    /**\n      * Typecast the collection to a List.\n      * \n      * @return the wrapped collection as a List\n         return new ObservedListIterator(getList().listIterator(index));\n     }\n \n+    /**\n+     * Returns a subList view on the original base <code>List</code>.\n+     * <p>\n+     * Changes to the subList affect the underlying List. Change events will\n+     * return change indices relative to the underlying List, not the subList.\n+     * \n+     * @param fromIndex  inclusive start index of the range\n+     * @param toIndex  exclusive end index of the range\n+     * @return the subList view\n+     */\n     public List subList(int fromIndex, int toIndex) {\n-        // TODO: This list needs to be a special impl, as the index is offset\n-        throw new UnsupportedOperationException();\n+        List subList = getList().subList(fromIndex, toIndex);\n+        return new ObservedList(subList, getHandler().createSubListHandler(fromIndex, toIndex));\n     }\n \n     // ListIterator\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationEvent.java,v 1.3 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationEvent.java,v 1.4 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.observed.ModificationEvent;\n import org.apache.commons.collections.observed.ModificationEventType;\n import org.apache.commons.collections.observed.ModificationHandler;\n+import org.apache.commons.collections.observed.ObservedCollection;\n \n /**\n  * Event class that encapsulates the event information for a\n  * All objects used are the real objects from the method calls, not clones.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n     protected final int repeat;\n     /** The result of the method call */\n     protected final Object previous;\n+    /** The range that the event came from, null if none */\n+    protected final ObservedCollection range;\n+    /** The offset of the range that the event came from, -1 if none */\n+    protected final int rangeOffset;\n \n     // Constructor\n     //-----------------------------------------------------------------------\n      * @param object  the value that changed\n      * @param repeat  the number of repeats\n      * @param previous  the previous value being removed/replaced\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n      */\n     public StandardModificationEvent(\n         final Collection collection,\n         final int index,\n         final Object object,\n         final int repeat,\n-        final Object previous) {\n+        final Object previous,\n+        final ObservedCollection range,\n+        final int rangeOffset) {\n \n         super(collection, handler, type);\n         this.preSize = preSize;\n         this.object = object;\n         this.repeat = repeat;\n         this.previous = previous;\n+        this.range = range;\n+        this.rangeOffset = rangeOffset;\n     }\n \n     // Change info\n      */\n     public int getPreSize() {\n         return preSize;\n+    }\n+\n+    // Range info\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the range, <code>null</code> if none.\n+     * \n+     * @return the range\n+     */\n+    public ObservedCollection getRange() {\n+        return range;\n+    }\n+\n+    /**\n+     * Checks whether the event originated from a range.\n+     * \n+     * @return the range\n+     */\n+    public boolean isRange() {\n+        return (range != null);\n+    }\n+\n+    /**\n+     * Gets the range offset, <code>-1</code> if no range or unknown offset.\n+     * \n+     * @return the range offset\n+     */\n+    public int getRangeOffset() {\n+        return rangeOffset;\n     }\n \n     // Event type\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardModificationHandler.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardModificationHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationHandler.java,v 1.2 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardModificationHandler.java,v 1.3 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.observed.ModificationEventType;\n import org.apache.commons.collections.observed.ModificationHandler;\n import org.apache.commons.collections.observed.ModificationHandlerFactory;\n+import org.apache.commons.collections.observed.ObservedCollection;\n \n /**\n  * The standard implementation of a <code>ModificationHandler</code> that\n  * modification events.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.3 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n      * @param object  the object that will be added/removed/set, the method param or derived\n      * @param repeat  the number of repeats of the add/remove, the method param or derived\n      * @param previous  the previous value that will be removed/replaced, must exist in coll\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n      * @return true to call the decorated collection\n      */\n-    protected boolean preEvent(int type, int index, Object object, int repeat, Object previous) {\n+    protected boolean preEvent(\n+            int type, int index, Object object,\n+            int repeat, Object previous, ObservedCollection range, int rangeOffset) {\n+\n         preSize = getCollection().size();\n-        return firePreEvent(type, index, object, repeat, previous);\n+        return firePreEvent(type, index, object, repeat, previous, range, rangeOffset);\n     }\n \n     /**\n      * @param object  the object that will be added/removed/set, the method param or derived\n      * @param repeat  the number of repeats of the add/remove, the method param or derived\n      * @param previous  the previous value that will be removed/replaced, must exist in coll\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n      * @return true to call the decorated collection\n      */\n-    protected boolean firePreEvent(int type, int index, Object object, int repeat, Object previous) {\n+    protected boolean firePreEvent(\n+            int type, int index, Object object, int repeat,\n+            Object previous, ObservedCollection range, int rangeOffset) {\n+\n         if ((preMask & type) > 0) {\n             StandardPreModificationEvent event = null;\n             synchronized (this) {\n                     if ((holder.mask & type) > 0) {\n                         if (event == null) {\n                             event = new StandardPreModificationEvent(\n-                                getCollection(), this, type, preSize, index, object, repeat, previous);\n+                                getCollection(), this, type, preSize, index, object,\n+                                repeat, previous, range, rangeOffset);\n                         }\n                         holder.listener.modificationOccurring(event);\n                     }\n     /**\n      * Handles the post event.\n      * \n-     * @param success  true if the method succeeded in changing the collection\n+     * @param modified  true if the method succeeded in changing the collection\n      * @param type  the event type to send\n      * @param index  the index where the change starts, the method param or derived\n      * @param object  the object that will be added/removed/set, the method param or derived\n      * @param repeat  the number of repeats of the add/remove, the method param or derived\n      * @param previous  the previous value that will be removed/replaced, must exist in coll\n-     */\n-    protected void postEvent(boolean success, int type, int index, Object object, int repeat, Object previous) {\n-        if (success) {\n-            firePostEvent(type, index, object, repeat, previous);\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n+     */\n+    protected void postEvent(\n+            boolean modified, int type, int index, Object object,\n+            int repeat, Object previous, ObservedCollection range, int rangeOffset) {\n+\n+        if (modified) {\n+            firePostEvent(type, index, object, repeat, previous, range, rangeOffset);\n         }\n     }\n     \n      * @param object  the object that will be added/removed/set, the method param or derived\n      * @param repeat  the number of repeats of the add/remove, the method param or derived\n      * @param previous  the previous value that will be removed/replaced, must exist in coll\n-     */\n-    protected void firePostEvent(int type, int index, Object object, int repeat, Object previous) {\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n+     */\n+    protected void firePostEvent(\n+            int type, int index, Object object, int repeat,\n+            Object previous, ObservedCollection range, int rangeOffset) {\n+\n         if ((postMask & type) > 0) {\n             StandardPostModificationEvent event = null;\n             synchronized (this) {\n                     if ((holder.mask & type) > 0) {\n                         if (event == null) {\n                             event = new StandardPostModificationEvent(\n-                                getCollection(), this, type, preSize, index, object, repeat, previous);\n+                                getCollection(), this, type, preSize, index,\n+                                object, repeat, previous, range, rangeOffset);\n                         }\n                         holder.listener.modificationOccurred(event);\n                     }\n      * <p>\n      * Override to only send event if something actually cleared.\n      */\n-    public void postClear() {\n-        postEvent(preSize > 0, ModificationEventType.CLEAR, -1, null, 1, null);\n+    protected void postClear() {\n+        postEvent(preSize > 0, ModificationEventType.CLEAR, -1, null, 1, null, null, -1);\n     }\n \n     // Factory\n--- a/src/java/org/apache/commons/collections/observed/standard/StandardPostModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardPostModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPostModificationEvent.java,v 1.1 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPostModificationEvent.java,v 1.2 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Collection;\n \n import org.apache.commons.collections.observed.ModificationHandler;\n+import org.apache.commons.collections.observed.ObservedCollection;\n \n /**\n  * Event class that encapsulates all the event information for a\n  * All objects used are the real objects from the method calls, not clones.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n      * @param object  the value that changed\n      * @param repeat  the number of repeats\n      * @param previous  the previous value being removed/replaced\n+     * @param range  the range collection, null if no range\n+     * @param rangeOffset  the offset of the range, -1 if unknown\n      */\n     public StandardPostModificationEvent(\n         final Collection collection,\n         final int index,\n         final Object object,\n         final int repeat,\n-        final Object previous) {\n+        final Object previous,\n+        final ObservedCollection range,\n+        final int rangeOffset) {\n \n-        super(collection, handler, type, preSize, index, object, repeat, previous);\n+        super(collection, handler, type, preSize, index, object, repeat, previous, range, rangeOffset);\n         postSize = collection.size();\n     }\n \n--- a/src/java/org/apache/commons/collections/observed/standard/StandardPreModificationEvent.java\n+++ b/src/java/org/apache/commons/collections/observed/standard/StandardPreModificationEvent.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPreModificationEvent.java,v 1.1 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/observed/standard/Attic/StandardPreModificationEvent.java,v 1.2 2003/09/07 00:51:31 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Collection;\n \n import org.apache.commons.collections.observed.ModificationHandler;\n+import org.apache.commons.collections.observed.ObservedCollection;\n \n /**\n  * Event class that encapsulates all the event information for a\n  * All objects used are the real objects from the method calls, not clones.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.2 $ $Date: 2003/09/07 00:51:31 $\n  * \n  * @author Stephen Colebourne\n  */\n         final int index,\n         final Object object,\n         final int repeat,\n-        final Object previous) {\n+        final Object previous,\n+        final ObservedCollection range,\n+        final int rangeOffset) {\n \n-        super(collection, handler, type, preSize, index, object, repeat, previous);\n+        super(collection, handler, type, preSize, index, object, repeat, previous, range, rangeOffset);\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/observed/ObservedTestHelper.java\n+++ b/src/test/org/apache/commons/collections/observed/ObservedTestHelper.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/ObservedTestHelper.java,v 1.3 2003/09/06 18:59:09 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/observed/Attic/ObservedTestHelper.java,v 1.4 2003/09/07 00:51:32 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * {@link ObservedCollection} implementations.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/09/06 18:59:09 $\n+ * @version $Revision: 1.4 $ $Date: 2003/09/07 00:51:32 $\n  * \n  * @author Stephen Colebourne\n  */\n         doTestSetIndexed(factory);\n         doTestAddIterated(factory);\n         doTestSetIterated(factory);\n+        doTestRemoveListIterated(factory);\n+        doTestSubList(factory);\n     }\n     \n     public static void bulkTestObservedBag(ObservedFactory factory) {\n     public static void doTestFactoryPlain(ObservedFactory factory) {\n         ObservedCollection coll = factory.createObservedCollection();\n         \n+        Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n         Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n         Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n     public static void doTestFactoryWithPreListener(ObservedFactory factory) {\n         ObservedCollection coll = factory.createObservedCollection(PRE_LISTENER);\n         \n+        Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n         Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n         Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n     public static void doTestFactoryWithPostListener(ObservedFactory factory) {\n         ObservedCollection coll = factory.createObservedCollection(POST_LISTENER);\n         \n+        Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n         Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n         Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n     public static void doTestFactoryWithListener(ObservedFactory factory) {\n         ObservedCollection coll = factory.createObservedCollection(LISTENER);\n         \n+        Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n         Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n         Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n         StandardModificationHandler handler = new StandardModificationHandler();\n         ObservedCollection coll = factory.createObservedCollection(handler);\n         \n+        Assert.assertNotNull(coll.getHandler());\n         Assert.assertSame(handler, coll.getHandler());\n         Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n         Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n     public static void doTestFactoryWithNull(ObservedFactory factory) {\n         ObservedCollection coll = factory.createObservedCollection(null);\n         \n+        Assert.assertNotNull(coll.getHandler());\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n         Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n         Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n         Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n         \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(3, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(2, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(2, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-2, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-3, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n+        Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n+        Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n+        Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n+        Assert.assertEquals(false, LISTENER.postEvent.isTypeBulk());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(1, coll.size());\n+        coll.remove(SEVEN);  // already removed\n+        Assert.assertEquals(1, coll.size());\n+        Assert.assertTrue(LISTENER.preEvent != null);\n+        Assert.assertTrue(LISTENER.postEvent == null);\n+    }\n+\n+    public static void doTestRemoveListIterated(ObservedFactory factory) {\n+        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(2, coll.size());\n+        ListIterator it = coll.listIterator();\n+        it.next();\n+        it.next();\n+        it.remove();\n+        Assert.assertEquals(1, coll.size());\n+        // pre\n+        Assert.assertSame(coll, LISTENER.preEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.preEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ITERATED, LISTENER.preEvent.getType());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.preEvent.getChangeRepeat());\n+        Assert.assertSame(SEVEN, LISTENER.preEvent.getPrevious());\n+        Assert.assertEquals(2, LISTENER.preEvent.getPreSize());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ITERATED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeCollection().size());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeCollection().iterator().next());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeRepeat());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getPrevious());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(1, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n+        Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n+\n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-2, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(-1, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(true, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(0, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(false, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(0, LISTENER.postEvent.getSizeChange());\n         Assert.assertEquals(false, LISTENER.postEvent.isSizeChanged());\n \n+        Assert.assertEquals(false, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertEquals(null, LISTENER.postEvent.getRange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeAdd());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeReduce());\n         Assert.assertEquals(true, LISTENER.postEvent.isTypeChange());\n         Assert.assertEquals(false, LISTENER.postEvent.isTypeBulk());\n     }\n \n+    //-----------------------------------------------------------------------\n+    public static void doTestSubList(ObservedFactory factory) {\n+        ObservedList coll = (ObservedList) factory.createObservedCollection(LISTENER);\n+        \n+        coll.addAll(SIX_SEVEN_LIST);\n+        coll.add(EIGHT);\n+        coll.addAll(SIX_SEVEN_LIST);\n+        List subList = coll.subList(1, 4);\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(3, subList.size());\n+        subList.add(EIGHT);\n+        Assert.assertEquals(4, subList.size());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(5, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(6, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(true, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertSame(subList, LISTENER.postEvent.getRange());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(4, subList.size());\n+        subList.add(1, EIGHT);\n+        Assert.assertEquals(5, subList.size());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.ADD_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(2, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertEquals(6, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(7, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(true, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertSame(subList, LISTENER.postEvent.getRange());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(5, subList.size());\n+        subList.set(3, SEVEN);\n+        Assert.assertEquals(5, subList.size());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.SET_INDEXED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(4, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SIX, LISTENER.postEvent.getPrevious());\n+        Assert.assertEquals(7, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(7, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(true, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertSame(subList, LISTENER.postEvent.getRange());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(5, subList.size());\n+        ListIterator it = subList.listIterator();\n+        it.next();\n+        it.remove();\n+        Assert.assertEquals(4, subList.size());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.REMOVE_ITERATED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getPrevious());\n+        Assert.assertEquals(7, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(6, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(true, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertSame(subList, LISTENER.postEvent.getRange());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(4, subList.size());\n+        it = subList.listIterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        it.set(EIGHT);\n+        Assert.assertEquals(4, subList.size());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.SET_ITERATED, LISTENER.postEvent.getType());\n+        Assert.assertEquals(3, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(EIGHT, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(SEVEN, LISTENER.postEvent.getPrevious());\n+        Assert.assertEquals(6, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(6, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(true, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertSame(subList, LISTENER.postEvent.getRange());\n+        \n+        LISTENER.preEvent = null;\n+        LISTENER.postEvent = null;\n+        Assert.assertEquals(4, subList.size());\n+        subList.clear();\n+        Assert.assertEquals(0, subList.size());\n+        // post\n+        Assert.assertSame(coll, LISTENER.postEvent.getSourceCollection());\n+        Assert.assertSame(coll.getHandler(), LISTENER.postEvent.getHandler());\n+        Assert.assertEquals(ModificationEventType.CLEAR, LISTENER.postEvent.getType());\n+        Assert.assertEquals(-1, LISTENER.postEvent.getChangeIndex());\n+        Assert.assertSame(null, LISTENER.postEvent.getChangeObject());\n+        Assert.assertSame(null, LISTENER.postEvent.getPrevious());\n+        Assert.assertEquals(6, LISTENER.postEvent.getPreSize());\n+        Assert.assertEquals(2, LISTENER.postEvent.getPostSize());\n+        Assert.assertEquals(true, LISTENER.postEvent.isRange());\n+        Assert.assertEquals(1, LISTENER.postEvent.getRangeOffset());\n+        Assert.assertSame(subList, LISTENER.postEvent.getRange());\n+    }\n+\n }", "timestamp": 1062895892, "metainfo": ""}