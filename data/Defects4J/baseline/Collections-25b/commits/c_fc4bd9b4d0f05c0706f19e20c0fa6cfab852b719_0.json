{"sha": "fc4bd9b4d0f05c0706f19e20c0fa6cfab852b719", "log": "[COLLECTIONS-508] Improved original contribution after feedback. Thanks to Dipanjan Laha.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n      */\n     Collection<V> values();\n \n+    /**\n+     * Returns a {@link Map} view of this MultiValuedMap with a Collection as\n+     * its value. The Collection holds all the values mapped to that key.\n+     *\n+     * @return a Map view of the mappings in this MultiValuedMap\n+     */\n+    Map<K, Collection<V>> asMap();\n+\n+    // Iterators\n+\n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * <p>\n+     * A map iterator is an efficient way of iterating over maps. There is no\n+     * need to access the entries collection or use Map Entry objects.\n+     *\n+     * @return a map iterator\n+     */\n+    MapIterator<K, V> mapIterator();\n+\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Set;\n+\n+/**\n+ * Defines a map that holds a set of values against each key.\n+ * <p>\n+ * A <code>SetValuedMap</code> is a Map with slightly different semantics:\n+ * <ul>\n+ * <li>Putting a value into the map will add the value to a <code>Set</code> at\n+ * that key.</li>\n+ * <li>Getting a value will return a <code>Set</code>, holding all the values\n+ * put to that key.</li>\n+ * </ul>\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public interface SetValuedMap<K, V> extends MultiValuedMap<K, V> {\n+\n+    /**\n+     * Gets the set of values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> if no values have been\n+     * mapped to the key, however the implementation may choose to return an\n+     * empty collection.\n+     * <p>\n+     * Implementations may choose to return a clone of the internal collection.\n+     *\n+     * @param key the key to retrieve\n+     * @return the <code>Set</code> of values, implementations should return\n+     *         <code>null</code> for no mapping, but may return an empty\n+     *         collection\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Set<V> get(Object key);\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> from a subsequent\n+     * <code>get(Object)</code>, however they may choose to return an empty\n+     * collection.\n+     *\n+     * @param key the key to remove values from\n+     * @return the <code>Set</code> of values removed, implementations should\n+     *         return <code>null</code> for no mapping found, but may return an\n+     *         empty collection\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Set<V> remove(Object key);\n+}\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n import java.util.Set;\n \n import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.IteratorUtils;\n+import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Transformer;\n import org.apache.commons.collections4.bag.HashBag;\n import org.apache.commons.collections4.functors.InstantiateFactory;\n-import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.EmptyMapIterator;\n import org.apache.commons.collections4.iterators.IteratorChain;\n import org.apache.commons.collections4.iterators.LazyIteratorChain;\n import org.apache.commons.collections4.iterators.TransformIterator;\n+import org.apache.commons.collections4.keyvalue.AbstractMapEntry;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Abstract implementation of the {@link MultiValuedMap} interface to simplify\n     }\n \n     /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param <C> the collection type\n+     * @param map the map to wrap, must not be null\n+     * @param initialCollectionCapacity the initial capacity of the collection\n+     * @param collectionClazz the collection class\n+     * @throws IllegalArgumentException if the map is null or if\n+     *         initialCollectionCapacity is negetive\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map,\n+            int initialCollectionCapacity, final Class<C> collectionClazz) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        if (initialCollectionCapacity < 0) {\n+            throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCollectionCapacity);\n+        }\n+        this.map = (Map<K, Collection<V>>) map;\n+        this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE },\n+                new Object[] { new Integer(initialCollectionCapacity) });\n+    }\n+\n+    /**\n      * Gets the map being wrapped.\n      *\n      * @return the wrapped map\n      * {@inheritDoc}\n      */\n     public boolean containsMapping(Object key, Object value) {\n-        final Collection<V> col = get(key);\n+        final Collection<V> col = getMap().get(key);\n         if (col == null) {\n             return false;\n         }\n     }\n \n     /**\n-     * Gets the collection of values associated with the specified key.\n+     * Gets the collection of values associated with the specified key. This\n+     * would return an empty collection in case the mapping is not present\n      *\n      * @param key the key to retrieve\n-     * @return the <code>Collection</code> of values, will return\n-     *         <code>null</code> for no mapping\n+     * @return the <code>Collection</code> of values, will return an empty\n+     *         <code>Collection</code> for no mapping\n      * @throws ClassCastException if the key is of an invalid type\n      */\n     public Collection<V> get(Object key) {\n-        return getMap().get(key);\n+        return new WrappedCollection(key);\n     }\n \n     /**\n      */\n     public boolean removeMapping(K key, V item) {\n         boolean result = false;\n-        final Collection<V> col = get(key);\n+        final Collection<V> col = getMap().get(key);\n         if (col == null) {\n             return false;\n         }\n      */\n     public V put(K key, V value) {\n         boolean result = false;\n-        Collection<V> coll = get(key);\n+        Collection<V> coll = getMap().get(key);\n         if (coll == null) {\n             coll = createCollection();\n             coll.add(value);\n     }\n \n     /**\n+     * {@inheritDoc}\n+     */\n+    public Map<K, Collection<V>> asMap() {\n+        return getMap();\n+    }\n+\n+    /**\n      * Adds Iterable values to the collection associated with the specified key.\n      *\n      * @param key the key to store against\n         }\n         Iterator<? extends V> it = values.iterator();\n         boolean result = false;\n-        Collection<V> coll = get(key);\n+        Collection<V> coll = getMap().get(key);\n         if (coll == null) {\n             coll = createCollection(); // might produce a non-empty collection\n             while (it.hasNext()) {\n     }\n \n     /**\n-     * Gets an iterator for the collection mapped to the specified key.\n-     *\n-     * @param key the key to get an iterator for\n-     * @return the iterator of the collection at the key, empty iterator if key\n-     *         not in map\n-     */\n-    public Iterator<V> iterator(final Object key) {\n-        if (!containsKey(key)) {\n-            return EmptyIterator.<V> emptyIterator();\n-        }\n-        return new ValuesIterator(key);\n-    }\n-\n-    /**\n-     * Gets the size of the collection mapped to the specified key.\n-     *\n-     * @param key the key to get size for\n-     * @return the size of the collection at the key, zero if key not in map\n-     */\n-    public int size(final Object key) {\n-        final Collection<V> coll = get(key);\n-        if (coll == null) {\n-            return 0;\n-        }\n-        return coll.size();\n+     * {@inheritDoc}\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        if (size() == 0) {\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n+        }\n+        return new MultiValuedMapIterator();\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n     }\n \n     // -----------------------------------------------------------------------\n+\n+    /**\n+     * Wrapped collection to handle add and remove on the collection returned by get(object)\n+     */\n+    private class WrappedCollection implements Collection<V> {\n+\n+        private final Object key;\n+\n+        public WrappedCollection(Object key) {\n+            this.key = key;\n+        }\n+\n+        private Collection<V> getMapping() {\n+            return getMap().get(key);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public boolean add(V value) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                V addedVal = AbstractMultiValuedMap.this.put((K) key, value);\n+                return addedVal != null ? true : false;\n+            }\n+            return col.add(value);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public boolean addAll(Collection<? extends V> c) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return AbstractMultiValuedMap.this.putAll((K) key, c);\n+            }\n+            return col.addAll(c);\n+        }\n+\n+        public void clear() {\n+            final Collection<V> col = getMapping();\n+            if (col != null) {\n+                col.clear();\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public Iterator<V> iterator() {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return (Iterator<V>) IteratorUtils.EMPTY_ITERATOR;\n+            }\n+            return new ValuesIterator(key);\n+        }\n+\n+        public int size() {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return 0;\n+            }\n+            return col.size();\n+        }\n+\n+        public boolean contains(Object o) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return false;\n+            }\n+            return col.contains(o);\n+        }\n+\n+        public boolean containsAll(Collection<?> o) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return false;\n+            }\n+            return col.containsAll(o);\n+        }\n+\n+        public boolean isEmpty() {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return true;\n+            }\n+            return col.isEmpty();\n+        }\n+\n+        public boolean remove(Object item) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return false;\n+            }\n+\n+            boolean result = col.remove(item);\n+            if (col.isEmpty()) {\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+            return result;\n+        }\n+\n+        public boolean removeAll(Collection<?> c) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return false;\n+            }\n+\n+            boolean result = col.removeAll(c);\n+            if (col.isEmpty()) {\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+            return result;\n+        }\n+\n+        public boolean retainAll(Collection<?> c) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return false;\n+            }\n+\n+            boolean result = col.retainAll(c);\n+            if (col.isEmpty()) {\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+            return result;\n+        }\n+\n+        public Object[] toArray() {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return CollectionUtils.EMPTY_COLLECTION.toArray();\n+            }\n+            return col.toArray();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return (T[]) CollectionUtils.EMPTY_COLLECTION.toArray(a);\n+            }\n+            return col.toArray(a);\n+        }\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        @Override\n+        public boolean equals(Object other) {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return CollectionUtils.EMPTY_COLLECTION.equals(other);\n+            }\n+            if (other == null) {\n+                return false;\n+            }\n+            if(!(other instanceof Collection)){\n+                return false;\n+            }\n+            Collection otherCol = (Collection) other;\n+            if (col.size() != otherCol.size()) {\n+                return false;\n+            }\n+            for (Object value : col) {\n+                if (!otherCol.contains(value)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return CollectionUtils.EMPTY_COLLECTION.hashCode();\n+            }\n+            return col.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final Collection<V> col = getMapping();\n+            if (col == null) {\n+                return CollectionUtils.EMPTY_COLLECTION.toString();\n+            }\n+            return col.toString();\n+        }\n+\n+    }\n \n     /**\n      * Inner class that provides a Bag<K> keys view\n         }\n \n         public Set<K> uniqueSet() {\n-            return keySet();\n+            return UnmodifiableSet.<K>unmodifiableSet(keySet());\n         }\n \n         public int size() {\n                     final Transformer<V, Entry<K, V>> entryTransformer = new Transformer<V, Entry<K, V>>() {\n \n                         public Entry<K, V> transform(final V input) {\n-                            return new Entry<K, V>() {\n-\n-                                public K getKey() {\n-                                    return key;\n-                                }\n-\n-                                public V getValue() {\n-                                    return input;\n-                                }\n-\n-                                public V setValue(V value) {\n-                                    throw new UnsupportedOperationException();\n-                                }\n-                            };\n+                            return new MultiValuedMapEntry(key, input);\n                         }\n+\n                     };\n                     return new TransformIterator<V, Entry<K, V>>(new ValuesIterator(key), entryTransformer);\n                 }\n         @Override\n         public int size() {\n             return AbstractMultiValuedMap.this.size();\n+        }\n+\n+    }\n+\n+    /**\n+     * Inner class for MultiValuedMap Entries\n+     */\n+    private class MultiValuedMapEntry extends AbstractMapEntry<K, V> {\n+\n+        public MultiValuedMapEntry(K key, V value) {\n+            super(key, value);\n+        }\n+\n+        @Override\n+        public V setValue(V value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+    }\n+\n+    /**\n+     * Inner class for MapIterator\n+     */\n+    private class MultiValuedMapIterator implements MapIterator<K, V> {\n+\n+        private final Iterator<Entry<K, V>> it;\n+\n+        private Entry<K, V> current = null;\n+\n+        public MultiValuedMapIterator() {\n+            this.it = AbstractMultiValuedMap.this.entries().iterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return it.hasNext();\n+        }\n+\n+        public K next() {\n+            current = it.next();\n+            return current.getKey();\n+        }\n+\n+        public K getKey() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current.getValue();\n+        }\n+\n+        public void remove() {\n+            it.remove();\n+        }\n+\n+        public V setValue(V value) {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current.setValue(value);\n         }\n \n     }\n \n         public ValuesIterator(final Object key) {\n             this.key = key;\n-            this.values = get(key);\n+            this.values = getMap().get(key);\n             this.iterator = values.iterator();\n         }\n \n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n import java.util.Set;\n \n import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n  * Decorates another <code>MultiValuedMap</code> to provide additional behaviour.\n  * <p>\n- * Each method call made on this <code>MultiValuedMap</code> is forwarded to the\n- * decorated <code>MultiValuedMap</code>. This class is used as a framework to\n- * build to extensions such as synchronized and unmodifiable behaviour.\n+ * Each method call made on this <code>MultiValuedMap</code> is forwarded to the decorated <code>MultiValuedMap</code>.\n+ * This class is used as a framework to build to extensions such as synchronized and unmodifiable behaviour.\n  *\n  * @param <K> the type of key elements\n  * @param <V> the type of value elements\n      */\n     protected AbstractMultiValuedMapDecorator(final MultiValuedMap<K, V> map) {\n         if (map == null) {\n-            throw new IllegalArgumentException(\"MultiValuedMap must not be null\");\n+            throw new IllegalArgumentException(\n+                    \"MultiValuedMap must not be null\");\n         }\n         this.map = map;\n     }\n         return decorated().values();\n     }\n \n+    public Map<K, Collection<V>> asMap() {\n+        return decorated().asMap();\n+    }\n+\n     public boolean putAll(K key, Iterable<? extends V> values) {\n         return decorated().putAll(key, values);\n     }\n \n     public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n         decorated().putAll(m);\n+    }\n+\n+    public MapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n     private static final long serialVersionUID = -5845183518195365857L;\n \n     /**\n+     * The initial capacity used when none specified in constructor.\n+     */\n+    static final int DEFAULT_INITIAL_CAPACITY = 16;\n+\n+    /**\n+     * The load factor used when none specified in constructor.\n+     */\n+    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+\n+    /**\n      * Creates a MultiValuedHashMap which maps keys to collections of type\n      * <code>collectionClass</code>.\n      *\n      */\n     public static <K, V, C extends Collection<V>> MultiValuedMap<K, V> multiValuedMap(\n             final Class<C> collectionClass) {\n-        return new MultiValuedHashMap<K, V>(collectionClass);\n+        return new MultiValuedHashMap<K, V>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, collectionClass);\n     }\n \n     /**\n-     * Creates a MultiValueMap based on a <code>HashMap</code> which stores the\n-     * multiple values in an <code>ArrayList</code>.\n+     * Creates a MultiValueMap based on a <code>HashMap</code> with the default\n+     * initial capacity (16) and the default load factor (0.75), which stores\n+     * the multiple values in an <code>ArrayList</code>.\n      */\n     @SuppressWarnings(\"unchecked\")\n     public MultiValuedHashMap() {\n-        this(ArrayList.class);\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> with the initial\n+     * capacity and the default load factor (0.75), which stores the multiple\n+     * values in an <code>ArrayList</code>.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying hash map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedHashMap(int initialCapacity) {\n+        this(initialCapacity, DEFAULT_LOAD_FACTOR, ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> with the initial\n+     * capacity and the load factor, which stores the multiple values in an\n+     * <code>ArrayList</code>.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying hash map\n+     * @param loadFactor the load factor of the underlying hash map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedHashMap(int initialCapacity, float loadFactor) {\n+        this(initialCapacity, loadFactor, ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> with the initial\n+     * capacity and the load factor, which stores the multiple values in an\n+     * <code>ArrayList</code> with the initial collection capacity.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying hash map\n+     * @param loadFactor the load factor of the underlying hash map\n+     * @param initialCollectionCapacity the initial capacity of the Collection\n+     *        of values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedHashMap(int initialCapacity, float loadFactor, int initialCollectionCapacity) {\n+        this(initialCapacity, loadFactor, initialCollectionCapacity, ArrayList.class);\n     }\n \n     /**\n      */\n     @SuppressWarnings(\"unchecked\")\n     public MultiValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n-        this(ArrayList.class);\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, ArrayList.class);\n         super.putAll(map);\n     }\n \n      */\n     @SuppressWarnings(\"unchecked\")\n     public MultiValuedHashMap(final Map<? extends K, ? extends V> map) {\n-        this(ArrayList.class);\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, ArrayList.class);\n         super.putAll(map);\n     }\n \n      * Creates a MultiValuedHashMap which creates the value collections using\n      * the supplied <code>collectionClazz</code>.\n      *\n-     * @param <C>  the collection type\n-     * @param collectionClazz  the class of the <code>Collection</code> to use to\n-     *   create the value collections\n+     * @param initialCapacity the initial capacity of the underlying\n+     *        <code>HashMap</code>\n+     * @param loadFactor the load factor of the underlying <code>HashMap</code>\n+     * @param <C> the collection type\n+     * @param collectionClazz the class of the <code>Collection</code> to use to\n+     *        create the value collections\n      */\n-    protected <C extends Collection<V>> MultiValuedHashMap(final Class<C> collectionClazz) {\n-        super(new HashMap<K, Collection<V>>(), collectionClazz);\n+    protected <C extends Collection<V>> MultiValuedHashMap(int initialCapacity, float loadFactor,\n+            final Class<C> collectionClazz) {\n+        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedHashMap which creates the value collections using\n+     * the supplied <code>collectionClazz</code> and the initial collection\n+     * capacity .\n+     *\n+     * @param initialCapacity the initial capacity of the underlying\n+     *        <code>HashMap</code>\n+     * @param loadFactor the load factor of the underlying <code>HashMap</code>\n+     * @param initialCollectionCapacity the initial capacity of the\n+     *        <code>Collection</code>\n+     * @param <C> the collection type\n+     * @param collectionClazz the class of the <code>Collection</code> to use to\n+     *        create the value collections\n+     */\n+    protected <C extends Collection<V>> MultiValuedHashMap(int initialCapacity, float loadFactor,\n+            int initialCollectionCapacity, final Class<C> collectionClazz) {\n+        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), initialCollectionCapacity, collectionClazz);\n     }\n \n }\n--- a/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n import java.util.Set;\n \n import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.bag.UnmodifiableBag;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections4.map.UnmodifiableMap;\n import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n     }\n \n     @Override\n+    public Collection<V> get(Object key) {\n+        return UnmodifiableCollection.<V>unmodifiableCollection(decorated().get(key));\n+    }\n+\n+    @Override\n     public V put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n     }\n \n     @Override\n+    public Map<K, Collection<V>> asMap() {\n+        return UnmodifiableMap.<K, Collection<V>>unmodifiableMap(decorated().asMap());\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        return UnmodifiableMapIterator.<K, V>unmodifiableMapIterator(decorated().mapIterator());\n+    }\n+\n+    @Override\n     public boolean putAll(K key, Iterable<? extends V> values) {\n         throw new UnsupportedOperationException();\n     }\n--- a/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java\n         // make sure calls to \"containsAll\" don't change anything\n         verify();\n \n-        final int min = getFullElements().length < 2 ? 0 : 2;\n+        final int min = getFullElements().length < 4 ? 0 : 2;\n         final int max = getFullElements().length == 1 ? 1 :\n                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n         col = Arrays.asList(getFullElements()).subList(min, max);\n \n         resetFull();\n         final int size = getCollection().size();\n-        final int min = getFullElements().length < 2 ? 0 : 2;\n+        final int min = getFullElements().length < 4 ? 0 : 2;\n         final int max = getFullElements().length == 1 ? 1 :\n                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n         final Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n         if (getFullElements().length > 1) {\n             resetFull();\n             size = getCollection().size();\n-            final int min = getFullElements().length < 2 ? 0 : 2;\n+            final int min = getFullElements().length < 4 ? 0 : 2;\n             final int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n             assertTrue(\"Collection should changed by partial retainAll\",\n                     getCollection().retainAll(elements.subList(min, max)));\n--- a/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n \n import org.apache.commons.collections4.AbstractObjectTest;\n import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.bag.AbstractBagTest;\n+import org.apache.commons.collections4.bag.CollectionBag;\n import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+import org.apache.commons.collections4.map.AbstractMapTest;\n+import org.apache.commons.collections4.set.AbstractSetTest;\n \n /**\n  * Abstract test class for {@link MultiValuedMap} contract and methods.\n  */\n public abstract class AbstractMultiValuedMapTest<K, V> extends AbstractObjectTest {\n \n+    /** Map created by reset(). */\n+    protected MultiValuedMap<K, V> map;\n+\n+    /** MultiValuedHashMap created by reset(). */\n+    protected MultiValuedMap<K, V> confirmed;\n+\n     public AbstractMultiValuedMapTest(String testName) {\n         super(testName);\n     }\n         return true;\n     }\n \n+    /**\n+     * Returns true if the maps produced by {@link #makeObject()} and\n+     * {@link #makeFullMap()} supports null keys.\n+     * <p>\n+     * Default implementation returns true. Override if your collection class\n+     * does not support null keys.\n+     */\n+    public boolean isAllowNullKey() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the set of keys in the mappings used to test the map. This method\n+     * must return an array with the same length as {@link #getSampleValues()}\n+     * and all array elements must be different. The default implementation\n+     * constructs a set of String keys, and includes a single null key if\n+     * {@link #isAllowNullKey()} returns <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        final Object[] result = new Object[] {\n+                \"one\", \"one\", \"two\", \"two\",\n+                \"three\", \"three\"\n+        };\n+        return (K[]) result;\n+    }\n+\n+    /**\n+     * Returns the set of values in the mappings used to test the map. This\n+     * method must return an array with the same length as\n+     * {@link #getSampleKeys()}. The default implementation constructs a set of\n+     * String values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        final Object[] result = new Object[] {\n+                \"uno\", \"un\", \"dos\", \"deux\",\n+                \"tres\", \"trois\"\n+        };\n+        return (V[]) result;\n+    }\n+\n     protected MultiValuedMap<K, V> makeFullMap() {\n         final MultiValuedMap<K, V> map = makeObject();\n         addSampleMappings(map);\n         return map;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     protected void addSampleMappings(MultiValuedMap<? super K, ? super V> map) {\n-        map.put((K) \"one\", (V) \"uno\");\n-        map.put((K) \"one\", (V) \"un\");\n-        map.put((K) \"two\", (V) \"dos\");\n-        map.put((K) \"two\", (V) \"deux\");\n-        map.put((K) \"three\", (V) \"tres\");\n-        map.put((K) \"three\", (V) \"trois\");\n-    }\n-\n-    public void testNoMappingReturnsNull() {\n-        final MultiValuedMap<K, V> map = makeFullMap();\n-        assertNull(map.get(\"whatever\"));\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        for (int i = 0; i < keys.length; i++) {\n+            map.put(keys[i], values[i]);\n+        }\n+    }\n+\n+    /**\n+     * Override to return a MultiValuedMap other than MultiValuedHashMap as the\n+     * confirmed map.\n+     *\n+     * @return a MultiValuedMap that is known to be valid\n+     */\n+    public MultiValuedMap<K, V> makeConfirmedMap() {\n+        return new MultiValuedHashMap<K, V>();\n+    }\n+\n+    public MultiValuedMap<K, V> getConfirmed() {\n+        return this.confirmed;\n+    }\n+\n+    public void setConfirmed(MultiValuedMap<K, V> map) {\n+        this.confirmed = map;\n+    }\n+\n+    public MultiValuedMap<K, V> getMap() {\n+        return this.map;\n+    }\n+\n+    /**\n+     * Resets the {@link #map} and {@link #confirmed} fields to empty.\n+     */\n+    public void resetEmpty() {\n+        this.map = makeObject();\n+        this.confirmed = makeConfirmedMap();\n+    }\n+\n+    /**\n+     * Resets the {@link #map} and {@link #confirmed} fields to full.\n+     */\n+    public void resetFull() {\n+        this.map = makeFullMap();\n+        this.confirmed = makeConfirmedMap();\n+        final K[] k = getSampleKeys();\n+        final V[] v = getSampleValues();\n+        for (int i = 0; i < k.length; i++) {\n+            confirmed.put(k[i], v[i]);\n+        }\n+    }\n+\n+    public void testNoMappingReturnsEmptyCol() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertTrue(map.get(\"whatever\").isEmpty());\n     }\n \n     public void testMultipleValues() {\n         assertTrue(map.get(\"two\").contains(\"deux\"));\n         assertTrue(map.get(\"three\").contains(\"tres\"));\n         assertTrue(map.get(\"three\").contains(\"trois\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddMappingThroughGet(){\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        resetEmpty();\n+        final MultiValuedMap<K, V> map =  getMap();\n+        Collection<V> col1 = map.get(\"one\");\n+        Collection<V> col2 = map.get(\"one\");\n+        assertTrue(col1.isEmpty());\n+        assertTrue(col2.isEmpty());\n+        assertEquals(0, map.size());\n+        col1.add((V) \"uno\");\n+        col2.add((V) \"un\");\n+        assertTrue(map.containsKey(\"one\"));\n+        assertTrue(map.containsMapping(\"one\", \"uno\"));\n+        assertTrue(map.containsMapping(\"one\", \"un\"));\n+        assertTrue(map.containsValue(\"uno\"));\n+        assertTrue(map.containsValue(\"un\"));\n+        assertTrue(col1.contains(\"un\"));\n+        assertTrue(col2.contains(\"uno\"));\n+    }\n+\n+    public void testRemoveMappingThroughGet() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        final MultiValuedMap<K, V> map = getMap();\n+        Collection<V> col = map.get(\"one\");\n+        assertEquals(2, col.size());\n+        assertEquals(6, map.size());\n+        col.remove(\"uno\");\n+        col.remove(\"un\");\n+        assertFalse(map.containsKey(\"one\"));\n+        assertFalse(map.containsMapping(\"one\", \"uno\"));\n+        assertFalse(map.containsMapping(\"one\", \"un\"));\n+        assertFalse(map.containsValue(\"uno\"));\n+        assertFalse(map.containsValue(\"un\"));\n+        assertEquals(4, map.size());\n+        assertNull(map.remove(\"one\"));\n+    }\n+\n+    public void testRemoveMappingThroughGetIterator() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        final MultiValuedMap<K, V> map = getMap();\n+        Iterator<V> it = map.get(\"one\").iterator();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertFalse(map.containsKey(\"one\"));\n+        assertFalse(map.containsMapping(\"one\", \"uno\"));\n+        assertFalse(map.containsMapping(\"one\", \"un\"));\n+        assertFalse(map.containsValue(\"uno\"));\n+        assertFalse(map.containsValue(\"un\"));\n+        assertEquals(4, map.size());\n+        assertNull(map.remove(\"one\"));\n     }\n \n     public void testContainsValue() {\n //        assertEquals(expected, actual);\n //    }\n \n-    public void testRemoveAllViaIterator() {\n+    public void testRemoveAllViaValuesIterator() {\n         if (!isRemoveSupported()) {\n             return;\n         }\n             i.next();\n             i.remove();\n         }\n-        assertNull(map.get(\"one\"));\n+        assertTrue(map.get(\"one\").isEmpty());\n         assertTrue(map.isEmpty());\n     }\n+\n+    public void testRemoveViaValuesRemove() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        Collection<V> values = map.values();\n+        values.remove(\"uno\");\n+        values.remove(\"un\");\n+        assertFalse(map.containsKey(\"one\"));\n+        assertEquals(4, map.size());\n+    }\n+\n+    /*public void testRemoveViaGetCollectionRemove() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        Collection<V> values = map.get(\"one\");\n+        values.remove(\"uno\");\n+        values.remove(\"un\");\n+        assertFalse(map.containsKey(\"one\"));\n+        assertEquals(4, map.size());\n+    }*/\n \n //    public void testRemoveAllViaKeyedIterator() {\n //        if (!isRemoveSupported()) {\n             i.next();\n             i.remove();\n         }\n-        assertNull(map.get(\"one\"));\n+        assertTrue(map.get(\"one\").isEmpty());\n         assertEquals(0, map.size());\n     }\n \n         assertTrue(keyBag.containsAll(col));\n     }\n \n-//    public void testMapEqulas() {\n-//        MultiValuedMap<K, V> map1 = makeFullMap();\n-//        MultiValuedMap<K, V> map2 = makeFullMap();\n-//        assertEquals(true, map1.equals(map2));\n-//    }\n+    public void testAsMapGet() {\n+        resetEmpty();\n+        Map<K, Collection<V>> mapCol = getMap().asMap();\n+        assertNull(mapCol.get(\"one\"));\n+        assertEquals(0, mapCol.size());\n+\n+        resetFull();\n+        mapCol = getMap().asMap();\n+        Collection<V> col = mapCol.get(\"one\");\n+        assertNotNull(col);\n+        assertTrue(col.contains(\"un\"));\n+        assertTrue(col.contains(\"uno\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAsMapPut() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        resetEmpty();\n+        Map<K, Collection<V>> mapCol = getMap().asMap();\n+        Collection<V> col = (Collection<V>) Arrays.asList(\"un\", \"uno\");\n+        mapCol.put((K) \"one\", col);\n+        assertEquals(2, getMap().size());\n+        assertTrue(getMap().containsKey(\"one\"));\n+        assertTrue(getMap().containsValue(\"un\"));\n+        assertTrue(getMap().containsValue(\"uno\"));\n+\n+        resetFull();\n+        mapCol = getMap().asMap();\n+        col = mapCol.get(\"one\");\n+        col.add((V) \"one\");\n+        assertEquals(7, getMap().size());\n+        assertTrue(getMap().containsValue(\"one\"));\n+        assertTrue(getMap().containsValue(\"un\"));\n+        assertTrue(getMap().containsValue(\"uno\"));\n+    }\n+\n+    public void testAsMapRemove() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        Map<K, Collection<V>> mapCol = getMap().asMap();\n+        mapCol.remove(\"one\");\n+        assertFalse(getMap().containsKey(\"one\"));\n+        assertEquals(4, getMap().size());\n+    }\n+\n+    public void testMapIterator() {\n+        resetEmpty();\n+        MapIterator<K, V> mapIt  = getMap().mapIterator();\n+        assertFalse(mapIt.hasNext());\n+\n+        resetFull();\n+        mapIt = getMap().mapIterator();\n+        while (mapIt.hasNext()) {\n+            K key = mapIt.next();\n+            V value = mapIt.getValue();\n+            assertTrue(getMap().containsMapping(key, value));\n+        }\n+    }\n+\n+    public void testMapIteratorRemove() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        MapIterator<K, V> mapIt = getMap().mapIterator();\n+        while (mapIt.hasNext()) {\n+            mapIt.next();\n+            mapIt.remove();\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorUnsupportedSet() {\n+        resetFull();\n+        MapIterator<K, V> mapIt = getMap().mapIterator();\n+        mapIt.next();\n+        try {\n+            mapIt.setValue((V) \"some value\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n \n     // -----------------------------------------------------------------------\n     // Manual serialization testing as this class cannot easily\n \n     public void testEmptyMapCompatibility() throws Exception {\n         final MultiValuedMap<?, ?> map = makeObject();\n-        final MultiValuedMap<?, ?> map2 = (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+        final MultiValuedMap<?, ?> map2 =\n+                (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n         assertEquals(\"Map is empty\", 0, map2.size());\n     }\n \n     public void testFullMapCompatibility() throws Exception {\n         final MultiValuedMap<?, ?> map = (MultiValuedMap<?, ?>) makeFullMap();\n-        final MultiValuedMap<?, ?> map2 = (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        final MultiValuedMap<?, ?> map2 =\n+                (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n         assertEquals(\"Map is the right size\", map.size(), map2.size());\n         for (final Object key : map.keySet()) {\n             assertEquals(\"Map had inequal elements\", map.get(key), map2.get(key));\n         }\n     }\n \n+    // Bulk Tests\n+    /**\n+     * Bulk test {@link MultiValuedMap#entries()}. This method runs through all\n+     * of the tests in {@link AbstractCollectionTest}. After modification\n+     * operations, {@link #verify()} is invoked to ensure that the map and the\n+     * other collection views are still valid.\n+     *\n+     * @return a {@link AbstractCollectionTest} instance for testing the map's\n+     *         values collection\n+     */\n+    public BulkTest bulkTestMultiValuedMapEntries() {\n+        return new TestMultiValuedMapEntries();\n+    }\n+\n+    public class TestMultiValuedMapEntries extends AbstractCollectionTest<Entry<K, V>> {\n+        public TestMultiValuedMapEntries() {\n+            super(\"\");\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public Entry<K, V>[] getFullElements() {\n+            return makeFullMap().entries().toArray(new Entry[0]);\n+        }\n+\n+        @Override\n+        public Collection<Entry<K, V>> makeObject() {\n+            return AbstractMultiValuedMapTest.this.makeObject().entries();\n+        }\n+\n+        @Override\n+        public Collection<Entry<K, V>> makeFullCollection() {\n+            return AbstractMultiValuedMapTest.this.makeFullMap().entries();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            // Add not supported in entries view\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMultiValuedMapTest.this.resetFull();\n+            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n+            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMultiValuedMapTest.this.resetEmpty();\n+            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n+            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n+        }\n+\n+        @Override\n+        public Collection<Entry<K, V>> makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public Collection<Entry<K, V>> makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link MultiValuedMap#keySet()}. This method runs through all\n+     * of the tests in {@link AbstractSetTest}. After modification operations,\n+     * {@link #verify()} is invoked to ensure that the map and the other\n+     * collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing the map's key set\n+     */\n+    public BulkTest bulkTestMultiValuedMapKeySet() {\n+        return new TestMultiValuedMapKeySet();\n+    }\n+\n+    public class TestMultiValuedMapKeySet extends AbstractSetTest<K> {\n+        public TestMultiValuedMapKeySet() {\n+            super(\"\");\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public K[] getFullElements() {\n+            return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();\n+        }\n+\n+        @Override\n+        public Set<K> makeObject() {\n+            return AbstractMultiValuedMapTest.this.makeObject().keySet();\n+        }\n+\n+        @Override\n+        public Set<K> makeFullCollection() {\n+            return AbstractMultiValuedMapTest.this.makeFullMap().keySet();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link MultiValuedMap#values()}. This method runs through all\n+     * of the tests in {@link AbstractCollectionTest}. After modification\n+     * operations, {@link #verify()} is invoked to ensure that the map and the\n+     * other collection views are still valid.\n+     *\n+     * @return a {@link AbstractCollectionTest} instance for testing the map's\n+     *         values collection\n+     */\n+    public BulkTest bulkTestMultiValuedMapValues() {\n+        return new TestMultiValuedMapValues();\n+    }\n+\n+    public class TestMultiValuedMapValues extends AbstractCollectionTest<V> {\n+        public TestMultiValuedMapValues() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return getSampleValues();\n+        }\n+\n+        @Override\n+        public Collection<V> makeObject() {\n+            return AbstractMultiValuedMapTest.this.makeObject().values();\n+        }\n+\n+        @Override\n+        public Collection<V> makeFullCollection() {\n+            return AbstractMultiValuedMapTest.this.makeFullMap().values();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMultiValuedMapTest.this.resetFull();\n+            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n+            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMultiValuedMapTest.this.resetEmpty();\n+            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n+            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link MultiValuedMap#keys()}. This method runs through all of\n+     * the tests in {@link AbstractBagTest}. After modification operations,\n+     * {@link #verify()} is invoked to ensure that the map and the other\n+     * collection views are still valid.\n+     *\n+     * @return a {@link AbstractBagTest} instance for testing the map's values\n+     *         collection\n+     */\n+    public BulkTest bulkTestMultiValuedMapKeys() {\n+        return new TestMultiValuedMapKeys();\n+    }\n+\n+    public class TestMultiValuedMapKeys extends AbstractBagTest<K> {\n+\n+        public TestMultiValuedMapKeys() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return getSampleKeys();\n+        }\n+\n+        @Override\n+        public Bag<K> makeObject() {\n+            return AbstractMultiValuedMapTest.this.makeObject().keys();\n+        }\n+\n+        @Override\n+        public Bag<K> makeFullCollection() {\n+            return AbstractMultiValuedMapTest.this.makeFullMap().keys();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMultiValuedMapTest.this.resetFull();\n+            // wrapping with CollectionBag as otherwise the Collection tests\n+            // would fail\n+            setCollection(CollectionBag.<K>collectionBag(AbstractMultiValuedMapTest.this.getMap().keys()));\n+            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMultiValuedMapTest.this.resetEmpty();\n+            setCollection(CollectionBag.<K>collectionBag(AbstractMultiValuedMapTest.this.getMap().keys()));\n+            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n+        }\n+\n+    }\n+\n+    public BulkTest bulkTestAsMap() {\n+        return new TestMultiValuedMapAsMap();\n+    }\n+\n+    public class TestMultiValuedMapAsMap extends AbstractMapTest<K, Collection<V>> {\n+\n+        public TestMultiValuedMapAsMap() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public Map<K, Collection<V>> makeObject() {\n+            return AbstractMultiValuedMapTest.this.makeObject().asMap();\n+        }\n+\n+        public Map<K, Collection<V>> makeFullMap() {\n+            return AbstractMultiValuedMapTest.this.makeFullMap().asMap();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public K[] getSampleKeys() {\n+            K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();\n+            Object[] finalKeys = new Object[3];\n+            for (int i = 0; i < 3; i++) {\n+                finalKeys[i] = samplekeys[i * 2];\n+            }\n+            return (K[]) finalKeys;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public Collection<V>[] getSampleValues() {\n+            V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();\n+            Collection<V>[] colArr = new Collection[3];\n+            for(int i = 0; i < 3; i++) {\n+                colArr[i] = Arrays.asList(sampleValues[i*2], sampleValues[i*2 + 1]);\n+            }\n+            return colArr;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public Collection<V>[] getNewSampleValues() {\n+            Object[] sampleValues = { \"ein\", \"ek\", \"zwei\", \"duey\", \"drei\", \"teen\" };\n+            Collection<V>[] colArr = new Collection[3];\n+            for (int i = 0; i < 3; i++) {\n+                colArr[i] = Arrays.asList((V) sampleValues[i * 2], (V) sampleValues[i * 2 + 1]);\n+            }\n+            return colArr;\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return AbstractMultiValuedMapTest.this.isAddSupported();\n+        }\n+\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return AbstractMultiValuedMapTest.this.isAddSupported();\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+    }\n }\n--- a/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n package org.apache.commons.collections4.multimap;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashSet;\n-import java.util.LinkedList;\n \n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n         super(testName);\n     }\n \n+    public static Test suite() {\n+        return BulkTest.makeSuite(MultiValuedHashMapTest.class);\n+    }\n+\n     @Override\n     public MultiValuedMap<K, V> makeObject() {\n         final MultiValuedMap<K, V> m = new MultiValuedHashMap<K, V>();\n         return m;\n     }\n \n-    private <C extends Collection<V>> MultiValuedHashMap<K, V> createTestMap(final Class<C> collectionClass) {\n+    /*private <C extends Collection<V>> MultiValuedHashMap<K, V> createTestMap(final Class<C> collectionClass) {\n         final MultiValuedHashMap<K, V> map =\n                 (MultiValuedHashMap<K, V>) MultiValuedHashMap.<K, V, C> multiValuedMap(collectionClass);\n         addSampleMappings(map);\n     public void testValueCollectionType() {\n         final MultiValuedHashMap<K, V> map = createTestMap(LinkedList.class);\n         assertTrue(map.get(\"one\") instanceof LinkedList);\n-    }\n+    }*/\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithList() {\n-        final MultiValuedHashMap<K, V> test = (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(ArrayList.class);\n+        final MultiValuedHashMap<K, V> test =\n+                (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(ArrayList.class);\n         assertEquals(\"a\", test.put((K) \"A\", (V) \"a\"));\n         assertEquals(\"b\", test.put((K) \"A\", (V) \"b\"));\n         assertEquals(1, test.keySet().size());\n-        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.get(\"A\").size());\n         assertEquals(2, test.size());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithSet() {\n-        final MultiValuedHashMap<K, V> test = (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(HashSet.class);\n+        final MultiValuedHashMap<K, V> test =\n+                (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(HashSet.class);\n         assertEquals(\"a\", test.put((K) \"A\", (V) \"a\"));\n         assertEquals(\"b\", test.put((K) \"A\", (V) \"b\"));\n         assertEquals(null, test.put((K) \"A\", (V) \"a\"));\n         assertEquals(1, test.keySet().size());\n-        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.get(\"A\").size());\n         assertEquals(2, test.size());\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n  */\n package org.apache.commons.collections4.multimap;\n \n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Transformer;\n import org.apache.commons.collections4.TransformerUtils;\n \n     public TransformedMultiValuedMapTest(String testName) {\n         super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TransformedMultiValuedMapTest.class);\n     }\n \n     @Override\n--- a/src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java\n  */\n package org.apache.commons.collections4.multimap;\n \n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Unmodifiable;\n \n         super(testName);\n     }\n \n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableMultiValuedMapTest.class);\n+    }\n+    \n     public boolean isAddSupported() {\n         return false;\n     }\n         MultiValuedMap<K, V> map = makeObject();\n         try {\n             map.put((K) \"one\", (V) \"uno\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiableEntries() {\n+        resetFull();\n+        Collection<Entry<K, V>> entries = getMap().entries();\n+        try {\n+            entries.clear();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        Iterator<Entry<K, V>> it = entries.iterator();\n+        Entry<K, V> entry = it.next();\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            entry.setValue((V) \"three\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiableMapIterator() {\n+        resetFull();\n+        MapIterator<K, V> mapIt = getMap().mapIterator();\n+        try {\n+            mapIt.remove();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            mapIt.setValue((V) \"three\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiableKeySet() {\n+        resetFull();\n+        Set<K> keySet = getMap().keySet();\n+        try {\n+            keySet.add((K) \"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            keySet.remove(\"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            keySet.clear();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        Iterator<K> it = keySet.iterator();\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiableValues() {\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        try {\n+            values.add((V) \"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            values.remove(\"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            values.clear();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        Iterator<V> it = values.iterator();\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiableAsMap() {\n+        resetFull();\n+        Map<K, Collection<V>> mapCol = getMap().asMap();\n+        try {\n+            mapCol.put((K) \"four\", (Collection<V>) Arrays.asList(\"four\"));\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            mapCol.remove(\"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            mapCol.clear();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            mapCol.clear();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiableKeys() {\n+        resetFull();\n+        Bag<K> keys = getMap().keys();\n+        try {\n+            keys.add((K) \"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            keys.remove(\"four\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        try {\n+            keys.clear();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        Iterator<K> it = keys.iterator();\n+        try {\n+            it.remove();\n             fail();\n         } catch (UnsupportedOperationException e) {\n         }", "timestamp": 1396814317, "metainfo": ""}