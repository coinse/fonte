{"sha": "54a201398966d33ad632bf5c495d6e951a4d742f", "log": "Add new FixedOrderComparator that allows the order to be easily specified from David Leppik, bug ref 16823   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/comparators/FixedOrderComparator.java,v 1.1 2003/04/13 17:37:26 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** \n+ * A Comparator which imposes a specific order on a specific set of Objects.\n+ * Objects are presented to the FixedOrderComparator in a specified order and\n+ * subsequent calls to {@link #compare} yield that order.\n+ * For example:\n+ * <pre>\n+ * String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"};\n+ * FixedOrderComparator distanceFromSun = new FixedOrderComparator(planets);\n+ * Arrays.sort(planets);                     // Sort to alphabetical order\n+ * Arrays.sort(planets, distanceFromSun);    // Back to original order\n+ * </pre>\n+ * <p>\n+ * Once {@link #compare} has been called, the FixedOrderComparator is locked and\n+ * attempts to modify it yield an UnsupportedOperationException.\n+ * <p>\n+ * Instances of FixedOrderComparator are not synchronized.  The class is not\n+ * thread-safe at construction time, but it is thread-safe to perform\n+ * multiple comparisons  after all the setup operations are complete.\n+ * \n+ * @since Commons Collections 2.2\n+ * @version $Revision: 1.1 $ $Date: 2003/04/13 17:37:26 $\n+ *\n+ * @author David Leppik\n+ * @author Stephen Colebourne\n+ */\n+public class FixedOrderComparator implements Comparator {\n+\n+    /** \n+     * Behavior when comparing unknown Objects:\n+     * unknown objects compare as before known Objects.\n+     */\n+    public static final int UNKNOWN_BEFORE = 0;\n+\n+    /** \n+     * Behavior when comparing unknown Objects:\n+     * unknown objects compare as before known Objects.\n+     */\n+    public static final int UNKNOWN_AFTER = 1;\n+\n+    /** \n+     * Behavior when comparing unknown Objects:\n+     * unknown objects cause a IllegalArgumentException to be thrown.\n+     * This is the default behavior.\n+     */\n+    public static final int UNKNOWN_THROW_EXCEPTION = 2;\n+\n+    /** Internal map of object to position */\n+    private final Map map = new HashMap();\n+    /** Counter used in determining the position in the map */\n+    private int counter = 0;\n+    /** Is the comparator locked against further change */\n+    private boolean isLocked = false;\n+    /** The behaviour in the case of an unknown object */\n+    private int unknownObjectBehavior = UNKNOWN_THROW_EXCEPTION;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Constructs an empty FixedOrderComparator.\n+     */\n+    public FixedOrderComparator() {\n+        super();\n+    }\n+\n+    /** \n+     * Constructs a FixedOrderComparator which uses the order of the given array\n+     * to compare the objects.\n+     * <p>\n+     * The array is copied, so later changes will not affect the comparator.\n+     * \n+     * @param items  the items that the comparator can compare in order\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public FixedOrderComparator(Object[] items) {\n+        super();\n+        if (items == null) {\n+            throw new IllegalArgumentException(\"The list of items must not be null\");\n+        }\n+        for (int i = 0; i < items.length; i++) {\n+            add(items[i]);\n+        }\n+    }\n+\n+    /** \n+     * Constructs a FixedOrderComparator which uses the order of the given list\n+     * to compare the objects.\n+     * <p>\n+     * The list is copied, so later changes will not affect the comparator.\n+     * \n+     * @param items  the items that the comparator can compare in order\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    public FixedOrderComparator(List items) {\n+        super();\n+        if (items == null) {\n+            throw new IllegalArgumentException(\"The list of items must not be null\");\n+        }\n+        for (Iterator it = items.iterator(); it.hasNext();) {\n+            add(it.next());\n+        }\n+    }\n+\n+    // Bean methods / state querying methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if modifications cannot be made to the FixedOrderComparator.\n+     * FixedOrderComparators cannot be modified once they have performed a comparison.\n+     * \n+     * @return true if attempts to change the FixedOrderComparator yield an\n+     *  UnsupportedOperationException, false if it can be changed.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    /**\n+     * Checks to see whether the comparator is now locked against further changes.\n+     * \n+     * @throws UnsupportedOperationException if the comparator is locked\n+     */\n+    protected void checkLocked() {\n+        if (isLocked()) {\n+            throw new UnsupportedOperationException(\"Cannot modify a FixedOrderComparator after a comparison\");\n+        }\n+    }\n+\n+    /** \n+     * Gets the behavior for comparing unknown objects.\n+     */\n+    public int getUnkownObjectBehavior() {\n+        return unknownObjectBehavior;\n+    }\n+\n+    /** \n+     * Sets the behavior for comparing unknown objects.\n+     * \n+     * @throws UnsupportedOperationException if a comparison has been performed\n+     * @throws IllegalArgumentException if the unknown flag is not valid\n+     */\n+    public void setUnknownObjectBehavior(int unknownObjectBehavior) {\n+        checkLocked();\n+        if (unknownObjectBehavior != UNKNOWN_AFTER \n+            && unknownObjectBehavior != UNKNOWN_BEFORE \n+            && unknownObjectBehavior != UNKNOWN_THROW_EXCEPTION) {\n+            throw new IllegalArgumentException(\"Unrecognised value for unkown behaviour flag\");    \n+        }\n+        this.unknownObjectBehavior = unknownObjectBehavior;\n+    }\n+\n+    // Methods for adding items\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Adds an item, which compares as after all items known to the Comparator.\n+     * If the item is already known to the Comparator, its old position is\n+     * replaced with the new position.\n+     * \n+     * @param obj  the item to be added to the Comparator.\n+     * @return true if obj has been added for the first time, false if\n+     *  it was already known to the Comparator.\n+     * @throws UnsupportedOperationException if a comparison has already been made\n+     */\n+    public boolean add(Object obj) {\n+        checkLocked();\n+        Object position = map.put(obj, new Integer(counter++));\n+        return (position == null);\n+    }\n+\n+    /**\n+     * Adds a new item, which compares as equal to the given existing item.\n+     * \n+     * @param existingObj  an item already in the Comparator's set of \n+     *  known objects\n+     * @param newObj  an item to be added to the Comparator's set of\n+     *  known objects\n+     * @return true if newObj has been added for the first time, false if\n+     *  it was already known to the Comparator.\n+     * @throws IllegalArgumentException if existingObject is not in the \n+     *  Comparator's set of known objects.\n+     * @throws UnsupportedOperationException if a comparison has already been made\n+     */\n+    public boolean addAsEqual(Object existingObj, Object newObj) {\n+        checkLocked();\n+        Integer position = (Integer) map.get(existingObj);\n+        if (position == null) {\n+            throw new IllegalArgumentException(existingObj + \" not known to \" + this);\n+        }\n+        Object result = map.put(newObj, position);\n+        return (result == null);\n+    }\n+\n+    // Comparator methods\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Compares two objects according to the order of this Comparator.\n+     * <p>\n+     * It is important to note that this class will throw an IllegalArgumentException\n+     * in the case of an unrecognised object. This is not specified in the \n+     * Comparator interface, but is the most appropriate exception.\n+     * \n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @throws IllegalArgumentException if o1 or o2 are not known \n+     *  to this Comparator and an alternative behavior has not been set\n+     *  via {@link #setUnknownObjectBehavior(int)}.\n+     */\n+    public int compare(Object obj1, Object obj2) {\n+        isLocked = true;\n+        Integer position1 = (Integer) map.get(obj1);\n+        Integer position2 = (Integer) map.get(obj2);\n+        if (position1 == null || position2 == null) {\n+            switch (unknownObjectBehavior) {\n+                case UNKNOWN_BEFORE :\n+                    if (position1 == null) {\n+                        return (position2 == null) ? 0 : -1;\n+                    } else {\n+                        return 1;\n+                    }\n+                case UNKNOWN_AFTER :\n+                    if (position1 == null) {\n+                        return (position2 == null) ? 0 : 1;\n+                    } else {\n+                        return -1;\n+                    }\n+                case UNKNOWN_THROW_EXCEPTION :\n+                    Object unknownObj = (position1 == null) ? obj1 : obj2;\n+                    throw new IllegalArgumentException(\"Attempting to compare unknown object \" + unknownObj);\n+                default :\n+                    throw new UnsupportedOperationException(\"Unknown unknownObjectBehavior: \" + unknownObjectBehavior);\n+            }\n+        } else {\n+            return position1.compareTo(position2);\n+        }\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/comparators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/comparators/TestAll.java,v 1.2 2003/01/10 00:21:08 rwaldhoff Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/comparators/TestAll.java,v 1.3 2003/04/13 17:37:26 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections.comparators;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n /**\n  * Entry point for all Comparator Collections tests.\n+ * \n  * @author Stephen Colebourne\n- * @version $Revision: 1.2 $ $Date: 2003/01/10 00:21:08 $\n+ * @version $Revision: 1.3 $ $Date: 2003/04/13 17:37:26 $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestBooleanComparator.suite());\n         suite.addTest(TestComparableComparator.suite());\n         suite.addTest(TestComparatorChain.suite());\n+        suite.addTest(TestFixedOrderComparator.suite());\n         suite.addTest(TestNullComparator.suite());\n         suite.addTest(TestReverseComparator.suite());\n         return suite;\n         String[] testCaseName = { TestAll.class.getName() };\n         junit.textui.TestRunner.main(testCaseName);\n     }\n+    \n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/comparators/TestFixedOrderComparator.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/comparators/TestFixedOrderComparator.java,v 1.1 2003/04/13 17:37:26 scolebourne Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/04/13 17:37:26 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test class for FixedOrderComparator.\n+ * \n+ * @author David Leppik \n+ * @author Stephen Colebourne\n+ */\n+public class TestFixedOrderComparator extends TestCase {\n+\n+\n+    /**\n+     * Top cities of the world, by population including metro areas.\n+     */\n+    public static final String topCities[] = new String[] {\n+        \"Tokyo\",\n+        \"Mexico City\",\n+        \"Mumbai\",\n+        \"Sao Paulo\",\n+        \"New York\",\n+        \"Shanghai\",\n+        \"Lagos\",\n+        \"Los Angeles\",\n+        \"Calcutta\",\n+        \"Buenos Aires\"\n+    };\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public TestFixedOrderComparator(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestFixedOrderComparator.class);\n+    }\n+\n+    public static void main(String args[]) { \n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+\n+\n+    //\n+    // The tests\n+    //\n+\n+    /** \n+     * Tests that the constructor plus add method compares items properly. \n+     */\n+    public void testConstructorPlusAdd() {\n+        FixedOrderComparator comparator = new FixedOrderComparator();\n+        for (int i = 0; i < topCities.length; i++) {\n+            comparator.add(topCities[i]);\n+        }\n+        String[] keys = (String[]) topCities.clone();\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /** \n+     * Tests that the array constructor compares items properly. \n+     */\n+    public void testArrayConstructor() {\n+        String[] keys = (String[]) topCities.clone();\n+        String[] topCitiesForTest = (String[]) topCities.clone();\n+        FixedOrderComparator comparator = new FixedOrderComparator(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest[0] = \"Brighton\";\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests the list constructor. \n+     */\n+    public void testListConstructor() {\n+        String[] keys = (String[]) topCities.clone();\n+        List topCitiesForTest = new LinkedList(Arrays.asList(topCities));\n+        FixedOrderComparator comparator = new FixedOrderComparator(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest.set(0, \"Brighton\");\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests addAsEqual method.\n+     */\n+    public void testAddAsEqual() {\n+        FixedOrderComparator comparator = new FixedOrderComparator(topCities);\n+        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n+        assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n+    }\n+\n+    /** \n+     * Tests whether or not updates are disabled after a comparison is made.\n+     */\n+    public void testLock() {\n+        FixedOrderComparator comparator = new FixedOrderComparator(topCities);\n+        assertEquals(false, comparator.isLocked());\n+        comparator.compare(\"New York\", \"Tokyo\");\n+        assertEquals(true, comparator.isLocked());\n+        try {\n+            comparator.add(\"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+\n+        try {\n+            comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+    }\n+\n+    public void testUnknownObjectBehavior() {\n+        FixedOrderComparator comparator = new FixedOrderComparator(topCities);\n+        try {\n+            comparator.compare(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        try {\n+            comparator.compare(\"Minneapolis\", \"New York\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        assertEquals(FixedOrderComparator.UNKNOWN_THROW_EXCEPTION, comparator.getUnkownObjectBehavior());\n+\n+        comparator = new FixedOrderComparator(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UNKNOWN_BEFORE);\n+        assertEquals(FixedOrderComparator.UNKNOWN_BEFORE, comparator.getUnkownObjectBehavior());\n+        LinkedList keys = new LinkedList(Arrays.asList(topCities));\n+        keys.addFirst(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+        \n+        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+        comparator = new FixedOrderComparator(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UNKNOWN_AFTER);\n+        keys = new LinkedList(Arrays.asList(topCities));\n+        keys.add(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+        \n+        assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+        \n+    }\n+    \n+    //\n+    // Helper methods\n+    //\n+    \n+    /** Shuffles the keys and asserts that the comparator sorts them back to\n+     * their original order.\n+     */\n+    private void assertComparatorYieldsOrder(Object[] orderedObjects, \n+                                             Comparator comparator) {\n+        Object[] keys = (Object[]) orderedObjects.clone();\n+        \n+        // shuffle until the order changes.  It's extremely rare that\n+        // this requires more than one shuffle.\n+\n+        boolean isInNewOrder = false;\n+        while (keys.length > 1 && isInNewOrder == false) {\n+            shuffle: {\n+                Random rand = new Random();\n+                for (int i = keys.length-1; i > 0; i--) {\n+                        Object swap = keys[i];\n+                        int j = rand.nextInt(i+1);\n+                        keys[i] = keys[j];\n+                        keys[j] = swap;     \n+                    }\n+            }\n+        \n+            testShuffle: {\n+                for (int i = 0; i < keys.length && !isInNewOrder; i++) {\n+                    if( !orderedObjects[i].equals(keys[i])) {\n+                        isInNewOrder = true;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // The real test:  sort and make sure they come out right.\n+        \n+        Arrays.sort(keys, comparator);\n+\n+        for (int i = 0; i < orderedObjects.length; i++) {\n+            assertEquals(orderedObjects[i], keys[i]);\n+        }\n+    }\n+    \n+}", "timestamp": 1050255446, "metainfo": ""}