{"sha": "646488dc7e05c19a36398a0386df99d60375319b", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r751887 | mbenson | 2009-03-09 15:40:01 -0700 (Mon, 09 Mar 2009) | 1 line          add methods to wrap Maps and SortedMaps not based on Commons Collections classes to their Iterable*Map counterparts     ------------------------------------------------------------------------     r471166 | scolebourne | 2006-11-04 03:33:22 -0800 (Sat, 04 Nov 2006) | 1 line          Removed Typed* containers such as TypedList and TypedMap as generics now provides type safety     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n \n import org.apache.commons.collections.keyvalue.DefaultKeyValue;\n import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections.map.HashedMap;\n import org.apache.commons.collections.map.LazyMap;\n import org.apache.commons.collections.map.PredicatedMap;\n-import org.apache.commons.collections.map.TestPredicatedMap;\n import org.apache.commons.collections.collection.TestTransformedCollection;\n \n /**\n         super(name);\n     }\n \n-\n     public static Test suite() {\n         return BulkTest.makeSuite(TestMapUtils.class);\n     }\n \n-    public Predicate getPredicate() {\n-        return new Predicate() {\n+    public Predicate<Object> getPredicate() {\n+        return new Predicate<Object>() {\n             public boolean evaluate(Object o) {\n                 return o instanceof String;\n             }\n     }\n \n     public void testPredicatedMap() {\n-        Predicate p = getPredicate();\n-        Map map = MapUtils.predicatedMap(new HashMap(), p, p);\n-        assertTrue(\"returned object should be a PredicatedMap\",\n-            map instanceof PredicatedMap);\n+        Predicate<Object> p = getPredicate();\n+        Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<Object, Object>(), p, p);\n+        assertTrue(\"returned object should be a PredicatedMap\", map instanceof PredicatedMap);\n         try {\n             map = MapUtils.predicatedMap(null, p, p);\n             fail(\"Expecting IllegalArgumentException for null map.\");\n         }\n     }\n \n-    // Since a typed map is a predicated map, I copied the tests for predicated map\n-    public void testTypedMapIllegalPut() {\n-        final Map map = MapUtils.typedMap(new HashMap(), String.class, String.class);\n-\n-        try {\n-            map.put(\"Hi\", new Integer(3));\n-            fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        try {\n-            map.put(new Integer(3), \"Hi\");\n-            fail(\"Illegal key should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        assertTrue(!map.containsKey(new Integer(3)));\n-        assertTrue(!map.containsValue(new Integer(3)));\n-\n-        Map map2 = new HashMap();\n-        map2.put(\"A\", \"a\");\n-        map2.put(\"B\", \"b\");\n-        map2.put(\"C\", \"c\");\n-        map2.put(\"c\", new Integer(3));\n-\n-        try {\n-            map.putAll(map2);\n-            fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        map.put(\"E\", \"e\");\n-        Iterator iterator = map.entrySet().iterator();\n-        try {\n-            Map.Entry entry = (Map.Entry)iterator.next();\n-            entry.setValue(new Integer(3));\n-            fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-    }\n-\n-    public BulkTest bulkTestTypedMap() {\n-        return new TestPredicatedMap(\"\") {\n-            public boolean isAllowNullKey() {\n-                return false;\n-            }\n-\n-            public boolean isAllowNullValue() {\n-                return false;\n-            }\n-\n-            public Map makeEmptyMap() {\n-                return MapUtils.typedMap(new HashMap(), String.class, String.class);\n-            }\n-        };\n-    }\n-\n     public void testLazyMapFactory() {\n-        Factory factory = FactoryUtils.constantFactory(new Integer(5));\n-        Map map = MapUtils.lazyMap(new HashMap(), factory);\n+        Factory<Integer> factory = FactoryUtils.constantFactory(new Integer(5));\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), factory);\n         assertTrue(map instanceof LazyMap);\n         try {\n-            map = MapUtils.lazyMap(new HashMap(), (Factory) null);\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Factory<Object>) null);\n             fail(\"Expecting IllegalArgumentException for null factory\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n         try {\n-            map = MapUtils.lazyMap(null, factory);\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, factory);\n             fail(\"Expecting IllegalArgumentException for null map\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        Transformer transformer = TransformerUtils.asTransformer(factory);\n-        map = MapUtils.lazyMap(new HashMap(), transformer);\n+        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n+        map = MapUtils.lazyMap(new HashMap<Object, Object>(), transformer);\n         assertTrue(map instanceof LazyMap);\n         try {\n-            map = MapUtils.lazyMap(new HashMap(), (Transformer) null);\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Transformer<Object, Object>) null);\n             fail(\"Expecting IllegalArgumentException for null transformer\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n         try {\n-            map = MapUtils.lazyMap(null, transformer);\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, transformer);\n             fail(\"Expecting IllegalArgumentException for null map\");\n         } catch (IllegalArgumentException e) {\n             // expected\n     }\n \n     public void testLazyMapTransformer() {\n-        Map map = MapUtils.lazyMap(new HashMap(), new Transformer() {\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), new Transformer<Object, Object>() {\n             public Object transform(Object mapKey) {\n                 if (mapKey instanceof String) {\n                     return new Integer((String) mapKey);\n     }\n \n     public void testInvertMap() {\n-        final Map in = new HashMap( 5 , 1 );\n-        in.put( \"1\" , \"A\" );\n-        in.put( \"2\" , \"B\" );\n-        in.put( \"3\" , \"C\" );\n-        in.put( \"4\" , \"D\" );\n-        in.put( \"5\" , \"E\" );\n-\n-        final Set inKeySet = new HashSet( in.keySet() );\n-        final Set inValSet = new HashSet( in.values() );\n-\n-        final Map out =  MapUtils.invertMap(in);\n-\n-        final Set outKeySet = new HashSet( out.keySet() );\n-        final Set outValSet = new HashSet( out.values() );\n+        final Map<String, String> in = new HashMap<String, String>(5, 1);\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        final Set<String> inKeySet = new HashSet<String>(in.keySet());\n+        final Set<String> inValSet = new HashSet<String>(in.values());\n+\n+        final Map<String, String> out =  MapUtils.invertMap(in);\n+\n+        final Set<String> outKeySet = new HashSet<String>(out.keySet());\n+        final Set<String> outValSet = new HashSet<String>(out.values());\n \n         assertTrue( inKeySet.equals( outValSet ));\n         assertTrue( inValSet.equals( outKeySet ));\n             fail();\n         } catch (NullPointerException ex) {}\n \n-        Map test = MapUtils.putAll(new HashMap(), new String[0]);\n+        Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);\n         assertEquals(0, test.size());\n \n         // sub array\n-        test = MapUtils.putAll(new HashMap(), new String[][] {\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n             {\"RED\", \"#FF0000\"},\n             {\"GREEN\", \"#00FF00\"},\n             {\"BLUE\", \"#0000FF\"}\n         assertEquals(3, test.size());\n \n         try {\n-            MapUtils.putAll(new HashMap(), new String[][] {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n                 {\"RED\", \"#FF0000\"},\n                 null,\n                 {\"BLUE\", \"#0000FF\"}\n         } catch (IllegalArgumentException ex) {}\n \n         try {\n-            MapUtils.putAll(new HashMap(), new String[][] {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n                 {\"RED\", \"#FF0000\"},\n                 {\"GREEN\"},\n                 {\"BLUE\", \"#0000FF\"}\n         } catch (IllegalArgumentException ex) {}\n \n         try {\n-            MapUtils.putAll(new HashMap(), new String[][] {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n                 {\"RED\", \"#FF0000\"},\n                 {},\n                 {\"BLUE\", \"#0000FF\"}\n         } catch (IllegalArgumentException ex) {}\n \n         // flat array\n-        test = MapUtils.putAll(new HashMap(), new String[] {\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n             \"RED\", \"#FF0000\",\n             \"GREEN\", \"#00FF00\",\n             \"BLUE\", \"#0000FF\"\n         assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n         assertEquals(3, test.size());\n \n-        test = MapUtils.putAll(new HashMap(), new String[] {\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n             \"RED\", \"#FF0000\",\n             \"GREEN\", \"#00FF00\",\n             \"BLUE\", \"#0000FF\",\n         assertEquals(3, test.size());\n \n         // map entry\n-        test = MapUtils.putAll(new HashMap(), new Object[] {\n-            new DefaultMapEntry(\"RED\", \"#FF0000\"),\n-            new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n-            new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultMapEntry<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultMapEntry<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultMapEntry<String, String>(\"BLUE\", \"#0000FF\")\n         });\n         assertEquals(true, test.containsKey(\"RED\"));\n         assertEquals(\"#FF0000\", test.get(\"RED\"));\n         assertEquals(3, test.size());\n \n         // key value\n-        test = MapUtils.putAll(new HashMap(), new Object[] {\n-            new DefaultKeyValue(\"RED\", \"#FF0000\"),\n-            new DefaultKeyValue(\"GREEN\", \"#00FF00\"),\n-            new DefaultKeyValue(\"BLUE\", \"#0000FF\")\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultKeyValue<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultKeyValue<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultKeyValue<String, String>(\"BLUE\", \"#0000FF\")\n         });\n         assertEquals(true, test.containsKey(\"RED\"));\n         assertEquals(\"#FF0000\", test.get(\"RED\"));\n     }\n \n     public void testConvertResourceBundle() {\n-        final Map in = new HashMap( 5 , 1 );\n-        in.put( \"1\" , \"A\" );\n-        in.put( \"2\" , \"B\" );\n-        in.put( \"3\" , \"C\" );\n-        in.put( \"4\" , \"D\" );\n-        in.put( \"5\" , \"E\" );\n+        final Map<String, String> in = new HashMap<String, String>( 5 , 1 );\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n \n         ResourceBundle b = new ListResourceBundle() {\n             public Object[][] getContents() {\n                 final Object[][] contents = new Object[ in.size() ][2];\n-                final Iterator i = in.keySet().iterator();\n+                final Iterator<String> i = in.keySet().iterator();\n                 int n = 0;\n                 while ( i.hasNext() ) {\n                     final Object key = i.next();\n             }\n         };\n \n-        final Map out = MapUtils.toMap(b);\n+        final Map<String, Object> out = MapUtils.toMap(b);\n \n         assertTrue( in.equals(out));\n     }\n \n     public void testDebugAndVerbosePrintCasting() {\n-        final Map inner = new HashMap(2, 1);\n-        inner.put( new Integer(2) , \"B\" );\n-        inner.put( new Integer(3) , \"C\" );\n-\n-        final Map outer = new HashMap(2, 1);\n-        outer.put( new Integer(0) , inner );\n-        outer.put( new Integer(1) , \"A\");\n-\n+        final Map<Integer, String> inner = new HashMap<Integer, String>(2, 1);\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new HashMap<Integer, Object>(2, 1);\n+        outer.put(0, inner);\n+        outer.put(1, \"A\");\n \n         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n         final PrintStream outPrint = new PrintStream(out);\n \n         final String INDENT = \"    \";\n \n-        final Map map = new TreeMap();  // treeMap guarantees order across JDKs for test\n-        map.put( new Integer(2) , \"B\" );\n-        map.put( new Integer(3) , \"C\" );\n-        map.put( new Integer(4) , null );\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"2 = B\");\n \n         final String INDENT = \"    \";\n \n-        final Map map = new TreeMap();  // treeMap guarantees order across JDKs for test\n-        map.put( new Integer(2) , \"B\" );\n-        map.put( new Integer(3) , \"C\" );\n-        map.put( new Integer(4) , null );\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n \n     public void testVerbosePrintNullStream() {\n         try {\n-            MapUtils.verbosePrint(null, \"Map\", new HashMap());\n+            MapUtils.verbosePrint(null, \"Map\", new HashMap<Object, Object>());\n             fail(\"Should generate NullPointerException\");\n         } catch (NullPointerException expected) {\n         }\n \n     public void testDebugPrintNullStream() {\n         try {\n-            MapUtils.debugPrint(null, \"Map\", new HashMap());\n+            MapUtils.debugPrint(null, \"Map\", new HashMap<Object, Object>());\n             fail(\"Should generate NullPointerException\");\n         } catch (NullPointerException expected) {\n         }\n \n         final String INDENT = \"    \";\n \n-        final Map map = new HashMap();\n-        map.put( null , \"A\" );\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"null = A \" + String.class.getName());\n \n         final String INDENT = \"    \";\n \n-        final Map map = new HashMap();\n-        map.put( null , \"A\" );\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"null = A\");\n \n         final String INDENT = \"    \";\n \n-        final Map map = new HashMap();\n-        map.put( null , map );\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"null = (this Map) \" + HashMap.class.getName());\n \n         final String INDENT = \"    \";\n \n-        final Map map = new HashMap();\n-        map.put( null , map );\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"null = (this Map)\");\n \n         final String INDENT = \"    \";\n \n-        final Map map = new HashMap();\n-        final Map map2= new HashMap();\n-        map.put( null , map2 );\n-        map2.put( \"2\", \"B\" );\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"null = \");\n \n         final String INDENT = \"    \";\n \n-        final Map map = new HashMap();\n-        final Map map2= new HashMap();\n-        map.put( null , map2 );\n-        map2.put( \"2\", \"B\" );\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n \n         outPrint.println(\"{\");\n         outPrint.println(INDENT + \"null = \");\n \n         out.reset();\n \n-        final Map inner = new TreeMap();  // treeMap guarantees order across JDKs for test\n-        inner.put( new Integer(2) , \"B\" );\n-        inner.put( new Integer(3) , \"C\" );\n-\n-        final Map outer = new TreeMap();\n-        outer.put( new Integer(1) , inner );\n-        outer.put( new Integer(0) , \"A\");\n-        outer.put( new Integer(7) , outer);\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n \n         MapUtils.verbosePrint(outPrint, \"Print Map\", outer);\n         assertEquals(EXPECTED_OUT, out.toString());\n \n         out.reset();\n \n-        final Map inner = new TreeMap();  // treeMap guarantees order across JDKs for test\n-        inner.put( new Integer(2) , \"B\" );\n-        inner.put( new Integer(3) , \"C\" );\n-\n-        final Map outer = new TreeMap();\n-        outer.put( new Integer(1) , inner );\n-        outer.put( new Integer(0) , \"A\");\n-        outer.put( new Integer(7) , outer);\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n \n         MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n         assertEquals(EXPECTED_OUT, out.toString());\n         final String LABEL = \"Print Map\";\n         final String INDENT = \"    \";\n \n-\n-        final Map grandfather = new TreeMap();// treeMap guarantees order across JDKs for test\n-        final Map father = new TreeMap();\n-        final Map son    = new TreeMap();\n-\n-        grandfather.put( new Integer(0), \"A\" );\n-        grandfather.put( new Integer(1), father );\n-\n-        father.put( new Integer(2), \"B\" );\n-        father.put( new Integer(3), grandfather);\n-        father.put( new Integer(4), son);\n-\n-        son.put( new Integer(5), \"C\");\n-        son.put( new Integer(6), grandfather);\n-        son.put( new Integer(7), father);\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n \n         outPrint.println(LABEL + \" = \");\n         outPrint.println(\"{\");\n         final String LABEL = \"Print Map\";\n         final String INDENT = \"    \";\n \n-\n-        final Map grandfather = new TreeMap();// treeMap guarantees order across JDKs for test\n-        final Map father = new TreeMap();\n-        final Map son    = new TreeMap();\n-\n-        grandfather.put( new Integer(0), \"A\" );\n-        grandfather.put( new Integer(1), father );\n-\n-        father.put( new Integer(2), \"B\" );\n-        father.put( new Integer(3), grandfather);\n-        father.put( new Integer(4), son);\n-\n-        son.put( new Integer(5), \"C\");\n-        son.put( new Integer(6), grandfather);\n-        son.put( new Integer(7), father);\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n \n         outPrint.println(LABEL + \" = \");\n         outPrint.println(\"{\");\n \n     //-----------------------------------------------------------------------\n     public void testIsEmptyWithEmptyMap() {\n-        Map map = new HashMap();\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n         assertEquals(true, MapUtils.isEmpty(map));\n     }\n \n     public void testIsEmptyWithNonEmptyMap() {\n-        Map map = new HashMap();\n+        Map<String, String> map = new HashMap<String, String>();\n         map.put(\"item\", \"value\");\n         assertEquals(false, MapUtils.isEmpty(map));\n     }\n \n     public void testIsEmptyWithNull() {\n-        Map map = null;\n+        Map<Object, Object> map = null;\n         assertEquals(true, MapUtils.isEmpty(map));\n     }\n \n     public void testIsNotEmptyWithEmptyMap() {\n-        Map map = new HashMap();\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n         assertEquals(false, MapUtils.isNotEmpty(map));\n     }\n \n     public void testIsNotEmptyWithNonEmptyMap() {\n-        Map map = new HashMap();\n+        Map<String, String> map = new HashMap<String, String>();\n         map.put(\"item\", \"value\");\n         assertEquals(true, MapUtils.isNotEmpty(map));\n     }\n \n     public void testIsNotEmptyWithNull() {\n-        Map map = null;\n+        Map<Object, Object> map = null;\n         assertEquals(false, MapUtils.isNotEmpty(map));\n     }\n \n             assertEquals(new Integer((String) list.get(i)), map.get(new Integer((String) list.get(i))));\n         }\n     }\n+\n+    public void testIterableMap() {\n+        try {\n+            MapUtils.iterableMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        HashMap<String, String> map = new HashMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        HashedMap<String, String> hMap = new HashedMap<String, String>(map);\n+        assertSame(hMap, MapUtils.iterableMap(hMap));\n+    }\n+\n+    public void testIterableSortedMap() {\n+        try {\n+            MapUtils.iterableSortedMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        TreeMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        assertSame(iMap, MapUtils.iterableMap(iMap));\n+    }\n+\n }", "timestamp": 1252994291, "metainfo": ""}