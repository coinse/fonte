{"sha": "5a2fc907469754e2c2a4ef2a9cad3df6ad94dd21", "log": "[COLLECTIONS-251] improving static factory methods for static importability, conistency  ", "commit": "\n--- a/src/java/org/apache/commons/collections/BagUtils.java\n+++ b/src/java/org/apache/commons/collections/BagUtils.java\n     /**\n      * An empty unmodifiable bag.\n      */\n-    public static final Bag<Object> EMPTY_BAG = UnmodifiableBag.decorate(new HashBag<Object>());\n+    public static final Bag<Object> EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n \n     /**\n      * An empty unmodifiable sorted bag.\n      */\n-    public static final Bag<Object> EMPTY_SORTED_BAG = UnmodifiableSortedBag.decorate(new TreeBag<Object>());\n+    public static final Bag<Object> EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n \n     /**\n      * Instantiation of BagUtils is not intended or required. However, some\n      * @throws IllegalArgumentException if the Bag is null\n      */\n     public static <E> Bag<E> synchronizedBag(Bag<E> bag) {\n-        return SynchronizedBag.decorate(bag);\n+        return SynchronizedBag.synchronizedBag(bag);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the Bag is null\n      */\n     public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n-        return UnmodifiableBag.decorate(bag);\n+        return UnmodifiableBag.unmodifiableBag(bag);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the Bag or Predicate is null\n      */\n     public static <E> Bag<E> predicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n-        return PredicatedBag.decorate(bag, predicate);\n+        return PredicatedBag.predicatedBag(bag, predicate);\n     }\n \n     /**\n      * as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified bag will not be transformed.\n-     * If you want that behaviour, see {@link TransformedBag#decorateTransform}.\n+     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n      * \n      * @param bag the bag to predicate, must not be null\n      * @param transformer the transformer for the bag, must not be null\n      * @return a transformed bag backed by the given bag\n      * @throws IllegalArgumentException if the Bag or Transformer is null\n      */\n-    public static <E> Bag<E> transformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedBag.decorate(bag, transformer);\n+    public static <E> Bag<E> transformingBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedBag.transformingBag(bag, transformer);\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException if the SortedBag is null\n      */\n     public static <E> SortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n-        return SynchronizedSortedBag.decorate(bag);\n+        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the SortedBag is null\n      */\n     public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n-        return UnmodifiableSortedBag.decorate(bag);\n+        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n     }\n \n     /**\n      */\n     public static <E> SortedBag<E> predicatedSortedBag(SortedBag<E> bag,\n             Predicate<? super E> predicate) {\n-        return PredicatedSortedBag.decorate(bag, predicate);\n+        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n     }\n \n     /**\n      * as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified bag will not be transformed.\n-     * If you want that behaviour, see {@link TransformedSortedBag#decorateTransform}.\n+     * If you want that behaviour, see {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n      * \n      * @param bag the bag to predicate, must not be null\n      * @param transformer the transformer for the bag, must not be null\n      * @return a transformed bag backed by the given bag\n      * @throws IllegalArgumentException if the Bag or Transformer is null\n      */\n-    public static <E> SortedBag<E> transformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedSortedBag.decorate(bag, transformer);\n+    public static <E> SortedBag<E> transformingSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n     /**\n      * An empty unmodifiable buffer.\n      */\n-    public static final Buffer<Object> EMPTY_BUFFER = UnmodifiableBuffer.decorate(new ArrayStack<Object>(1));\n+    public static final Buffer<Object> EMPTY_BUFFER = UnmodifiableBuffer.unmodifiableBuffer(new ArrayStack<Object>(1));\n \n     /**\n      * <code>BufferUtils</code> should not normally be instantiated.\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n     public static <E> Buffer<E> synchronizedBuffer(Buffer<E> buffer) {\n-        return SynchronizedBuffer.decorate(buffer);\n+        return SynchronizedBuffer.synchronizedBuffer(buffer);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n     public static <E> Buffer<E> blockingBuffer(Buffer<E> buffer) {\n-        return BlockingBuffer.decorate(buffer);\n+        return BlockingBuffer.blockingBuffer(buffer);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <E> Buffer<E> blockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n-        return BlockingBuffer.decorate(buffer, timeoutMillis);\n+        return BlockingBuffer.blockingBuffer(buffer, timeoutMillis);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <E> Buffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize) {\n-        return BoundedBuffer.decorate(buffer, maximumSize);\n+        return BoundedBuffer.boundedBuffer(buffer, maximumSize);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <E> Buffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize, long timeoutMillis) {\n-        return BoundedBuffer.decorate(buffer, maximumSize, timeoutMillis);\n+        return BoundedBuffer.boundedBuffer(buffer, maximumSize, timeoutMillis);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n     public static <E> Buffer<E> unmodifiableBuffer(Buffer<E> buffer) {\n-        return UnmodifiableBuffer.decorate(buffer);\n+        return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Buffer or Predicate is null\n      */\n     public static <E> Buffer<E> predicatedBuffer(Buffer<E> buffer, Predicate<? super E> predicate) {\n-        return PredicatedBuffer.decorate(buffer, predicate);\n+        return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n     }\n \n     /**\n      * @return a transformed buffer backed by the given buffer\n      * @throws IllegalArgumentException  if the Buffer or Transformer is null\n      */\n-    public static <E> Buffer<E> transformedBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedBuffer.decorate(buffer, transformer);\n+    public static <E> Buffer<E> transformingBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedBuffer.transformingBuffer(buffer, transformer);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/ClosureUtils.java\n+++ b/src/java/org/apache/commons/collections/ClosureUtils.java\n      * @return the closure\n      */\n     public static <E> Closure<E> exceptionClosure() {\n-        return ExceptionClosure.<E>getInstance();\n+        return ExceptionClosure.<E>exceptionClosure();\n     }\n \n     /**\n      * @return the closure\n      */\n     public static <E> Closure<E> nopClosure() {\n-        return NOPClosure.<E>getInstance();\n+        return NOPClosure.<E>nopClosure();\n     }\n \n     /**\n      * @return the closure\n      */\n     public static <E> Closure<E> asClosure(Transformer<? super E, ?> transformer) {\n-        return TransformerClosure.getInstance(transformer);\n+        return TransformerClosure.transformerClosure(transformer);\n     }\n \n     /**\n      * @return the <code>for</code> closure\n      */\n     public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n-        return ForClosure.getInstance(count, closure);\n+        return ForClosure.forClosure(count, closure);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either argument is null\n      */\n     public static <E> Closure<E> whileClosure(Predicate<? super E> predicate, Closure<? super E> closure) {\n-        return WhileClosure.<E>getInstance(predicate, closure, false);\n+        return WhileClosure.<E>whileClosure(predicate, closure, false);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either argument is null\n      */\n     public static <E> Closure<E> doWhileClosure(Closure<? super E> closure, Predicate<? super E> predicate) {\n-        return WhileClosure.<E>getInstance(predicate, closure, true);\n+        return WhileClosure.<E>whileClosure(predicate, closure, true);\n     }\n \n     /**\n      */\n     public static <E> Closure<E> invokerClosure(String methodName) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n-        return asClosure(InvokerTransformer.<E, Object>getInstance(methodName));\n+        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n     }\n \n     /**\n      */\n     public static <E> Closure<E> invokerClosure(String methodName, Class<?>[] paramTypes, Object[] args) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n-        return asClosure(InvokerTransformer.<E, Object>getInstance(methodName, paramTypes, args));\n+        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n     }\n \n     /**\n      * @throws IllegalArgumentException if either closure is null\n      */\n     public static <E> Closure<E> chainedClosure(Closure<? super E> closure1, Closure<? super E> closure2) {\n-        return ChainedClosure.<E>getInstance(closure1, closure2);\n+        return ChainedClosure.<E>chainedClosure(closure1, closure2);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n     public static <E> Closure<E> chainedClosure(Closure<? super E>[] closures) {\n-        return ChainedClosure.getInstance(closures);\n+        return ChainedClosure.chainedClosure(closures);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n     public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n-        return ChainedClosure.getInstance(closures);\n+        return ChainedClosure.chainedClosure(closures);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n-        return IfClosure.<E>getInstance(predicate, trueClosure);\n+        return IfClosure.<E>ifClosure(predicate, trueClosure);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either closure is null\n      */\n     public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n-        return IfClosure.<E>getInstance(predicate, trueClosure, falseClosure);\n+        return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures) {\n-        return SwitchClosure.<E>getInstance(predicates, closures, null);\n+        return SwitchClosure.<E>switchClosure(predicates, closures, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n-        return SwitchClosure.<E>getInstance(predicates, closures, defaultClosure);\n+        return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n     }\n     \n     /**\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n-        return SwitchClosure.getInstance(predicatesAndClosures);\n+        return SwitchClosure.switchClosure(predicatesAndClosures);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n      * this purpose. However they could be cast to Set or List which might be\n      * undesirable. This implementation only implements Collection.\n      */\n-    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.decorate(new ArrayList<Object>());\n+    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n \n     /**\n      * <code>CollectionUtils</code> should not normally be instantiated.\n             return ((BoundedCollection<?>) coll).isFull();\n         }\n         try {\n-            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.decorateUsing((Collection<Object>) coll);\n+            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n             return bcoll.isFull();\n         } catch (IllegalArgumentException ex) {\n             return false;\n             return ((BoundedCollection<?>) coll).maxSize();\n         }\n         try {\n-            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.decorateUsing((Collection<Object>) coll);\n+            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n             return bcoll.maxSize();\n         } catch (IllegalArgumentException ex) {\n             return -1;\n      * @throws IllegalArgumentException  if the collection is null\n      */\n     public static <C> Collection<C> synchronizedCollection(Collection<C> collection) {\n-        return SynchronizedCollection.decorate(collection);\n+        return SynchronizedCollection.synchronizedCollection(collection);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the collection is null\n      */\n     public static <C> Collection<C> unmodifiableCollection(Collection<C> collection) {\n-        return UnmodifiableCollection.decorate(collection);\n+        return UnmodifiableCollection.unmodifiableCollection(collection);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Collection is null\n      */\n     public static <C> Collection<C> predicatedCollection(Collection<C> collection, Predicate<? super C> predicate) {\n-        return PredicatedCollection.decorate(collection, predicate);\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n     }\n \n     /**\n      * @return a transformed collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection or Transformer is null\n      */\n-    public static <E> Collection<E> transformedCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedCollection.decorate(collection, transformer);\n+    public static <E> Collection<E> transformingCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedCollection.transformingCollection(collection, transformer);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/ComparatorUtils.java\n+++ b/src/java/org/apache/commons/collections/ComparatorUtils.java\n      * @see ComparableComparator#getInstance\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>getInstance();\n+    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();\n \n     /**\n      * Gets a comparator that uses the natural order of the objects.\n      * @return  a comparator that sorts booleans\n      */\n     public static Comparator<Boolean> booleanComparator(boolean trueFirst) {\n-        return BooleanComparator.getBooleanComparator(trueFirst);\n+        return BooleanComparator.booleanComparator(trueFirst);\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/collections/FactoryUtils.java\n+++ b/src/java/org/apache/commons/collections/FactoryUtils.java\n      * @return the factory\n      */\n     public static <T> Factory<T> exceptionFactory() {\n-        return ExceptionFactory.<T>getInstance();\n+        return ExceptionFactory.<T>exceptionFactory();\n     }\n \n     /**\n      * @return the factory\n      */\n     public static <T> Factory<T> nullFactory() {\n-        return ConstantFactory.<T>getInstance(null);\n+        return ConstantFactory.<T>constantFactory(null);\n     }\n \n     /**\n      * @return the <code>constant</code> factory.\n      */\n     public static <T> Factory<T> constantFactory(T constantToReturn) {\n-        return ConstantFactory.getInstance(constantToReturn);\n+        return ConstantFactory.constantFactory(constantToReturn);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the prototype cannot be cloned\n      */\n     public static <T> Factory<T> prototypeFactory(T  prototype) {\n-        return PrototypeFactory.<T>getInstance(prototype);\n+        return PrototypeFactory.<T>prototypeFactory(prototype);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the classToInstantiate is null\n      */\n     public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate) {\n-        return InstantiateFactory.getInstance(classToInstantiate, null, null);\n+        return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the constructor doesn't exist\n      */\n     public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n-        return InstantiateFactory.getInstance(classToInstantiate, paramTypes, args);\n+        return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/IteratorUtils.java\n+++ b/src/java/org/apache/commons/collections/IteratorUtils.java\n      * @return  an iterator over nothing\n      */\n     public static <E> ResettableIterator<E> emptyIterator() {\n-        return EmptyIterator.<E>getResettableInstance();\n+        return EmptyIterator.<E>resettableEmptyIterator();\n     }\n \n     /**\n      * @return  a list iterator over nothing\n      */\n     public static <E> ResettableListIterator<E> emptyListIterator() {\n-        return EmptyListIterator.<E>getResettableInstance();\n+        return EmptyListIterator.<E>resettableEmptyListIterator();\n     }\n \n     /**\n      * @return  an ordered iterator over nothing\n      */\n     public static <E> OrderedIterator<E> emptyOrderedIterator() {\n-        return EmptyOrderedIterator.<E>getInstance();\n+        return EmptyOrderedIterator.<E>emptyOrderedIterator();\n     }\n \n     /**\n      * @return  a map iterator over nothing\n      */\n     public static <K, V> MapIterator<K, V> emptyMapIterator() {\n-        return EmptyMapIterator.<K, V>getInstance();\n+        return EmptyMapIterator.<K, V>emptyMapIterator();\n     }\n \n     /**\n      * @return  a map iterator over nothing\n      */\n     public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n-        return EmptyOrderedMapIterator.<K, V>getInstance();\n+        return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n     }\n \n     // Singleton\n      * @return an immutable version of the iterator\n      */\n     public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n-        return UnmodifiableIterator.decorate(iterator);\n+        return UnmodifiableIterator.unmodifiableIterator(iterator);\n     }\n \n     /**\n      * @return an immutable version of the iterator\n      */\n     public static <E> ListIterator<E> unmodifiableListIterator(ListIterator<E> listIterator) {\n-        return UnmodifiableListIterator.decorate(listIterator);\n+        return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n     }\n \n     /**\n      * @return an immutable version of the iterator\n      */\n     public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> mapIterator) {\n-        return UnmodifiableMapIterator.decorate(mapIterator);\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n     }\n \n     // Chained\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n      * @throws IllegalArgumentException  if the list is null\n      */\n     public static <E> List<E> synchronizedList(List<E> list) {\n-        return SynchronizedList.decorate(list);\n+        return SynchronizedList.synchronizedList(list);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the list is null\n      */\n     public static <E> List<E> unmodifiableList(List<E> list) {\n-        return UnmodifiableList.decorate(list);\n+        return UnmodifiableList.unmodifiableList(list);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the List or Predicate is null\n      */\n     public static <E> List<E> predicatedList(List<E> list, Predicate<E> predicate) {\n-        return PredicatedList.decorate(list, predicate);\n+        return PredicatedList.predicatedList(list, predicate);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the List or Transformer is null\n      */\n     public static <E> List<E> transformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedList.decorate(list, transformer);\n+        return TransformedList.transformingList(list, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the List or Factory is null\n      */\n     public static <E> List<E> lazyList(List<E> list, Factory<? extends E> factory) {\n-        return LazyList.decorate(list, factory);\n+        return LazyList.lazyList(list, factory);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the List is null\n      */\n     public static <E> List<E> fixedSizeList(List<E> list) {\n-        return FixedSizeList.decorate(list);\n+        return FixedSizeList.fixedSizeList(list);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n      * An empty unmodifiable map.\n      * This was not provided in JDK1.2.\n      */\n-    public static final Map<Object, Object> EMPTY_MAP = UnmodifiableMap.decorate(new HashMap<Object, Object>(1));\n+    public static final Map<Object, Object> EMPTY_MAP = UnmodifiableMap.unmodifiableMap(new HashMap<Object, Object>(1));\n \n     /**\n      * An empty unmodifiable sorted map.\n      * This is not provided in the JDK.\n      */\n-    public static final SortedMap<Object, Object> EMPTY_SORTED_MAP = UnmodifiableSortedMap.decorate(new TreeMap<Object, Object>());\n+    public static final SortedMap<Object, Object> EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());\n \n     /**\n      * String used to indent the verbose and debug Map prints.\n      * @throws IllegalArgumentException  if the map is null\n      */\n     public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n-        return UnmodifiableMap.decorate(map);\n+        return UnmodifiableMap.unmodifiableMap(map);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map is null\n      */\n     public static <K, V> IterableMap<K, V> predicatedMap(Map<K, V> map, Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n-        return PredicatedMap.decorate(map, keyPred, valuePred);\n+        return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n     }\n \n     /**\n     public static <K, V> IterableMap<K, V> transformedMap(Map<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer,\n             Transformer<? super V, ? extends V> valueTransformer) {\n-        return TransformedMap.decorate(map, keyTransformer, valueTransformer);\n+        return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map is null\n      */\n     public static <K, V> IterableMap<K, V> fixedSizeMap(Map<K, V> map) {\n-        return FixedSizeMap.decorate(map);\n+        return FixedSizeMap.fixedSizeMap(map);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map or Factory is null\n      */\n     public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Factory<? extends V> factory) {\n-        return LazyMap.getLazyMap(map, factory);\n+        return LazyMap.lazyMap(map, factory);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n     public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> transformerFactory) {\n-        return LazyMap.getLazyMap(map, transformerFactory);\n+        return LazyMap.lazyMap(map, transformerFactory);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map is null\n      */\n     public static <K, V> OrderedMap<K, V> orderedMap(Map<K, V> map) {\n-        return ListOrderedMap.decorate(map);\n+        return ListOrderedMap.listOrderedMap(map);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n-        return MultiValueMap.<K, V>decorate(map);\n+        return MultiValueMap.<K, V>multiValueMap(map);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Class<C> collectionClass) {\n-        return MultiValueMap.decorate(map, collectionClass);\n+        return MultiValueMap.multiValueMap(map, collectionClass);\n     }\n \n     /**\n      * @since Commons Collections 3.2\n      */\n     public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Factory<C> collectionFactory) {\n-        return MultiValueMap.decorate(map, collectionFactory);\n+        return MultiValueMap.multiValueMap(map, collectionFactory);\n     }\n \n     // SortedMap decorators\n      * @throws IllegalArgumentException  if the map is null\n      */\n     public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n-        return UnmodifiableSortedMap.decorate(map);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n     }\n \n     /**\n      */\n     public static <K, V> SortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n             Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n-        return PredicatedSortedMap.decorate(map, keyPred, valuePred);\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n     }\n \n     /**\n     public static <K, V> SortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer,\n             Transformer<? super V, ? extends V> valueTransformer) {\n-        return TransformedSortedMap.decorate(map, keyTransformer, valueTransformer);\n+        return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n     public static <K, V> SortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n-        return FixedSizeSortedMap.decorate(map);\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n     }\n \n     /**\n      */\n     public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n             Factory<? extends V> factory) {\n-        return LazySortedMap.getLazySortedMap(map, factory);\n+        return LazySortedMap.lazySortedMap(map, factory);\n     }\n \n     /**\n      */\n     public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n             Transformer<? super K, ? extends V> transformerFactory) {\n-        return LazySortedMap.getLazySortedMap(map, transformerFactory);\n+        return LazySortedMap.lazySortedMap(map, transformerFactory);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/PredicateUtils.java\n+++ b/src/java/org/apache/commons/collections/PredicateUtils.java\n import org.apache.commons.collections.functors.AllPredicate;\n import org.apache.commons.collections.functors.AndPredicate;\n import org.apache.commons.collections.functors.AnyPredicate;\n+import org.apache.commons.collections.functors.EqualPredicate;\n import org.apache.commons.collections.functors.ExceptionPredicate;\n+import org.apache.commons.collections.functors.FalsePredicate;\n import org.apache.commons.collections.functors.IdentityPredicate;\n import org.apache.commons.collections.functors.InstanceofPredicate;\n import org.apache.commons.collections.functors.InvokerTransformer;\n import org.apache.commons.collections.functors.NullIsExceptionPredicate;\n import org.apache.commons.collections.functors.NullIsFalsePredicate;\n import org.apache.commons.collections.functors.NullIsTruePredicate;\n+import org.apache.commons.collections.functors.NullPredicate;\n import org.apache.commons.collections.functors.OnePredicate;\n import org.apache.commons.collections.functors.OrPredicate;\n import org.apache.commons.collections.functors.TransformedPredicate;\n import org.apache.commons.collections.functors.TransformerPredicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n import org.apache.commons.collections.functors.UniquePredicate;\n \n /**\n      * @return the predicate\n      */\n     public static <T> Predicate<T> exceptionPredicate() {\n-        return ExceptionPredicate.<T>getInstance();\n+        return ExceptionPredicate.<T>exceptionPredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.TruePredicate\n+     *\n+     * @return the predicate\n+     * @deprecated use {@link TruePredicate#truePredicate()} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> truePredicate() {\n+        return TruePredicate.truePredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.FalsePredicate\n+     *\n+     * @return the predicate\n+     * @deprecated use {@link FalsePredicate#falsePredicate()} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> falsePredicate() {\n+        return FalsePredicate.<T> falsePredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is null.\n+     *\n+     * @see org.apache.commons.collections.functors.NullPredicate\n+     *\n+     * @return the predicate\n+     * @deprecated use {@link NullPredicate#nullPredicate()} instead\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> nullPredicate() {\n+        return NullPredicate.nullPredicate();\n     }\n \n     /**\n      * @return the predicate\n      */\n     public static <T> Predicate<T> notNullPredicate() {\n-        return NotNullPredicate.<T>getInstance();\n+        return NotNullPredicate.<T>notNullPredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object using equals().\n+     *\n+     * @see org.apache.commons.collections.functors.EqualPredicate\n+     *\n+     * @param value  the value to compare against\n+     * @return the predicate\n+     * @deprecated use {@link EqualPredicate#equalPredicate(Object)} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> equalPredicate(T value) {\n+        return EqualPredicate.equalPredicate(value);\n     }\n \n     /**\n      * @return the predicate\n      */\n     public static <T> Predicate<T> identityPredicate(T value) {\n-        return IdentityPredicate.<T>getInstance(value);\n+        return IdentityPredicate.<T>identityPredicate(value);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the class is null\n      */\n     public static Predicate<Object> instanceofPredicate(Class<?> type) {\n-        return InstanceofPredicate.getInstance(type);\n+        return InstanceofPredicate.instanceOfPredicate(type);\n     }\n \n     /**\n      */\n     public static <T> Predicate<T> uniquePredicate() {\n         // must return new instance each time\n-        return UniquePredicate.<T>getInstance();\n+        return UniquePredicate.<T>uniquePredicate();\n     }\n \n     /**\n      */\n     public static <T> Predicate<T> invokerPredicate(String methodName){\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n-        return asPredicate(InvokerTransformer.<Object, Boolean>getInstance(methodName));\n+        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n     }\n \n     /**\n      */\n     public static <T> Predicate<T> invokerPredicate(String methodName, Class<?>[] paramTypes, Object[] args){\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n-        return asPredicate(InvokerTransformer.<Object, Boolean>getInstance(methodName, paramTypes, args));\n+        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n     }\n \n     // Boolean combinations\n      * @throws IllegalArgumentException if either predicate is null\n      */\n     public static <T> Predicate<T> andPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n-        return AndPredicate.<T>getInstance(predicate1, predicate2);\n+        return AndPredicate.<T>andPredicate(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.AllPredicate\n+     *\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @deprecated use {@link AllPredicate#allPredicate(Predicate...)} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> allPredicate(Predicate<? super T>[] predicates) {\n+        return AllPredicate.allPredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either predicate is null\n      */\n     public static <T> Predicate<T> orPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n-        return OrPredicate.<T>getInstance(predicate1, predicate2);\n+        return OrPredicate.<T>orPredicate(predicate1, predicate2);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> anyPredicate(Predicate<? super T>[] predicates) {\n-        return AnyPredicate.getInstance(predicates);\n+        return AnyPredicate.anyPredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n     public static <T> Predicate<T> anyPredicate(Collection<? extends Predicate<T>> predicates) {\n-        return AnyPredicate.getInstance(predicates);\n+        return AnyPredicate.anyPredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> onePredicate(Predicate<? super T>[] predicates) {\n-        return OnePredicate.getInstance(predicates);\n+        return OnePredicate.onePredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n     public static <T> Predicate<T> onePredicate(Collection<Predicate<T>> predicates) {\n-        return OnePredicate.getInstance(predicates);\n+        return OnePredicate.onePredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> nonePredicate(Predicate<? super T>[] predicates) {\n-        return NonePredicate.getInstance(predicates);\n+        return NonePredicate.nonePredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n     public static <T> Predicate<T> nonePredicate(Collection<? extends Predicate<T>> predicates) {\n-        return NonePredicate.getInstance(predicates);\n+        return NonePredicate.nonePredicate(predicates);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicate is null\n      */\n     public static <T> Predicate<T> notPredicate(Predicate<? super T> predicate) {\n-        return NotPredicate.getInstance(predicate);\n+        return NotPredicate.notPredicate(predicate);\n     }\n \n     // Adaptors\n      * @throws IllegalArgumentException if the transformer is null\n      */\n     public static <T> Predicate<T> asPredicate(Transformer<? super T, Boolean> transformer) {\n-        return TransformerPredicate.getInstance(transformer);\n+        return TransformerPredicate.transformerPredicate(transformer);\n     }\n \n     // Null handlers\n      * @throws IllegalArgumentException if the predicate is null.\n      */\n     public static <T> Predicate<T> nullIsExceptionPredicate(Predicate<? super T> predicate){\n-        return NullIsExceptionPredicate.getInstance(predicate);\n+        return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicate is null.\n      */\n     public static <T> Predicate<T> nullIsFalsePredicate(Predicate<? super T> predicate){\n-        return NullIsFalsePredicate.getInstance(predicate);\n+        return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicate is null.\n      */\n     public static <T> Predicate<T> nullIsTruePredicate(Predicate<? super T> predicate){\n-        return NullIsTruePredicate.getInstance(predicate);\n+        return NullIsTruePredicate.nullIsTruePredicate(predicate);\n     }\n \n     // Transformed\n      */\n     public static <T> Predicate<T> transformedPredicate(\n             Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n-        return TransformedPredicate.<T>getInstance(transformer, predicate);\n+        return TransformedPredicate.<T>transformedPredicate(transformer, predicate);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/SetUtils.java\n+++ b/src/java/org/apache/commons/collections/SetUtils.java\n      * An empty unmodifiable sorted set.\n      * This is not provided in the JDK.\n      */\n-    public static final SortedSet<?> EMPTY_SORTED_SET = UnmodifiableSortedSet.decorate(new TreeSet<Object>());\n+    public static final SortedSet<?> EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());\n \n     /**\n      * Get a typed empty unmodifiable sorted set.\n      * @throws IllegalArgumentException  if the set is null\n      */\n     public static <T> Set<T> synchronizedSet(Set<T> set) {\n-        return SynchronizedSet.decorate(set);\n+        return SynchronizedSet.synchronizedSet(set);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the set is null\n      */\n     public static <E> Set<E> unmodifiableSet(Set<E> set) {\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n     public static <T> Set<T> predicatedSet(Set<T> set, Predicate<? super T> predicate) {\n-        return PredicatedSet.decorate(set, predicate);\n+        return PredicatedSet.predicatedSet(set, predicate);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Set or Transformer is null\n      */\n     public static <E> Set<E> transformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedSet.decorate(set, transformer);\n+        return TransformedSet.transformingSet(set, transformer);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the Set is null\n      */\n     public static <E> Set<E> orderedSet(Set<E> set) {\n-        return ListOrderedSet.decorate(set);\n+        return ListOrderedSet.listOrderedSet(set);\n     }\n     \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException  if the set is null\n      */\n     public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> set) {\n-        return SynchronizedSortedSet.decorate(set);\n+        return SynchronizedSortedSet.synchronizedSortedSet(set);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the set is null\n      */\n     public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> set) {\n-        return UnmodifiableSortedSet.decorate(set);\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n     public static <T> SortedSet<T> predicatedSortedSet(SortedSet<T> set, Predicate<? super T> predicate) {\n-        return PredicatedSortedSet.decorate(set, predicate);\n+        return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Set or Transformer is null\n      */\n     public static <E> SortedSet<E> transformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n-        return TransformedSortedSet.decorate(set, transformer);\n+        return TransformedSortedSet.transformingSortedSet(set, transformer);\n     }\n     \n }\n--- a/src/java/org/apache/commons/collections/TransformerUtils.java\n+++ b/src/java/org/apache/commons/collections/TransformerUtils.java\n      * @return the transformer\n      */\n     public static <I, O> Transformer<I, O> exceptionTransformer() {\n-        return ExceptionTransformer.<I, O>getInstance();\n+        return ExceptionTransformer.<I, O>exceptionTransformer();\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static <I, O> Transformer<I, O> nullTransformer() {\n-        return ConstantTransformer.<I, O>getNullInstance();\n+        return ConstantTransformer.<I, O>nullTransformer();\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static <T> Transformer<T, T> nopTransformer() {\n-        return NOPTransformer.<T>getInstance();\n+        return NOPTransformer.<T>nopTransformer();\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static <T> Transformer<T, T> cloneTransformer() {\n-        return CloneTransformer.<T>getInstance();\n+        return CloneTransformer.<T>cloneTransformer();\n     }\n \n     /**\n      * @return the transformer.\n      */\n     public static <I, O> Transformer<I, O> constantTransformer(O constantToReturn) {\n-        return ConstantTransformer.getInstance(constantToReturn);\n+        return ConstantTransformer.constantTransformer(constantToReturn);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the closure is null\n      */\n     public static <T> Transformer<T, T> asTransformer(Closure<? super T> closure) {\n-        return ClosureTransformer.getInstance(closure);\n+        return ClosureTransformer.closureTransformer(closure);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the predicate is null\n      */\n     public static <T> Transformer<T, Boolean> asTransformer(Predicate<? super T> predicate) {\n-        return PredicateTransformer.getInstance(predicate);\n+        return PredicateTransformer.predicateTransformer(predicate);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the factory is null\n      */\n     public static <I, O> Transformer<I, O> asTransformer(Factory<? extends O> factory) {\n-        return FactoryTransformer.getInstance(factory);\n+        return FactoryTransformer.factoryTransformer(factory);\n     }\n \n     /**\n      * @return the transformer\n      * @throws IllegalArgumentException if either transformer is null\n      */\n-    public static <T> Transformer<T, T> chainedTransformer(\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic static <T> Transformer<T, T> chainedTransformer(\n             Transformer<? super T, ? extends T> transformer1,\n             Transformer<? super T, ? extends T> transformer2) {\n-        return ChainedTransformer.<T>getInstance(transformer1, transformer2);\n+        return ChainedTransformer.<T> chainedTransformer(transformer1, transformer2);\n     }\n \n     /**\n      * @throws IllegalArgumentException if any transformer in the array is null\n      */\n     public static <T> Transformer<T, T> chainedTransformer(Transformer<? super T, ? extends T>[] transformers) {\n-        return ChainedTransformer.getInstance(transformers);\n+        return ChainedTransformer.chainedTransformer(transformers);\n     }\n \n     /**\n      */\n     public static <T> Transformer<T, T> chainedTransformer(\n             Collection<? extends Transformer<T, T>> transformers) {\n-        return ChainedTransformer.getInstance(transformers);\n+        return ChainedTransformer.chainedTransformer(transformers);\n     }\n \n     /**\n     public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I> predicate,\n             Transformer<? super I, ? extends O> trueTransformer,\n             Transformer<? super I, ? extends O> falseTransformer) {\n-        return SwitchTransformer.getInstance(new Predicate[] { predicate },\n+        return SwitchTransformer.switchTransformer(new Predicate[] { predicate },\n                 new Transformer[] { trueTransformer }, falseTransformer);\n     }\n \n      */\n     public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n             Transformer<? super I, ? extends O>[] transformers) {\n-        return SwitchTransformer.<I, O>getInstance(predicates, transformers, null);\n+        return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, null);\n     }\n \n     /**\n     public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n             Transformer<? super I, ? extends O>[] transformers,\n             Transformer<? super I, ? extends O> defaultTransformer) {\n-        return SwitchTransformer.<I, O>getInstance(predicates, transformers, defaultTransformer);\n+        return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, defaultTransformer);\n     }\n \n     /**\n      */\n     public static <I, O> Transformer<I, O> switchTransformer(\n             Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n-        return SwitchTransformer.<I, O>getInstance(predicatesAndTransformers);\n+        return SwitchTransformer.<I, O>switchTransformer(predicatesAndTransformers);\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n-        return InstantiateTransformer.<T>getInstance();\n+        return InstantiateTransformer.<T>instantiateTransformer();\n     }\n \n     /** \n      */\n     public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(\n             Class<?>[] paramTypes, Object[] args) {\n-        return InstantiateTransformer.<T>getInstance(paramTypes, args);\n+        return InstantiateTransformer.<T>instantiateTransformer(paramTypes, args);\n     }\n \n     /** \n      * @throws IllegalArgumentException if the map is null\n      */\n     public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {\n-        return MapTransformer.getInstance(map);\n+        return MapTransformer.mapTransformer(map);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the methodName is null.\n      */\n     public static <I, O> Transformer<I, O> invokerTransformer(String methodName){\n-        return InvokerTransformer.<I, O>getInstance(methodName, null, null);\n+        return InvokerTransformer.<I, O>invokerTransformer(methodName, null, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static <I, O> Transformer<I, O> invokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args){\n-        return InvokerTransformer.<I, O>getInstance(methodName, paramTypes, args);\n+        return InvokerTransformer.<I, O>invokerTransformer(methodName, paramTypes, args);\n     }\n \n     /**\n      * @return the transformer\n      */\n     public static <T> Transformer<T, String> stringValueTransformer() {\n-        return StringValueTransformer.<T>getInstance();\n+        return StringValueTransformer.<T>stringValueTransformer();\n     }\n     \n }\n--- a/src/java/org/apache/commons/collections/bag/AbstractMapBag.java\n+++ b/src/java/org/apache/commons/collections/bag/AbstractMapBag.java\n      */\n     public Set<E> uniqueSet() {\n         if (uniqueSet == null) {\n-            uniqueSet = UnmodifiableSet.<E> decorate(map.keySet());\n+            uniqueSet = UnmodifiableSet.<E> unmodifiableSet(map.keySet());\n         }\n         return uniqueSet;\n     }\n--- a/src/java/org/apache/commons/collections/bag/PredicatedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/PredicatedBag.java\n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    public static <T> Bag<T> decorate(Bag<T> bag, Predicate<? super T> predicate) {\n+    public static <T> Bag<T> predicatedBag(Bag<T> bag, Predicate<? super T> predicate) {\n         return new PredicatedBag<T>(bag, predicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    public static <T> SortedBag<T> decorate(SortedBag<T> bag, Predicate<? super T> predicate) {\n+    public static <T> SortedBag<T> predicatedSortedBag(SortedBag<T> bag, Predicate<? super T> predicate) {\n         return new PredicatedSortedBag<T>(bag, predicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/bag/SynchronizedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/SynchronizedBag.java\n      * @return a new synchronized Bag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <T> Bag<T> decorate(Bag<T> bag) {\n+    public static <T> Bag<T> synchronizedBag(Bag<T> bag) {\n         return new SynchronizedBag<T>(bag);\n     }\n     \n--- a/src/java/org/apache/commons/collections/bag/SynchronizedSortedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/SynchronizedSortedBag.java\n      * @return a new synchronized SortedBag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> SortedBag<E> decorate(SortedBag<E> bag) {\n+    public static <E> SortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n         return new SynchronizedSortedBag<E>(bag);\n     }\n     \n--- a/src/java/org/apache/commons/collections/bag/TransformedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/TransformedBag.java\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedBag(Bag, Transformer)}.\n      * \n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Bag\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    public static <E> Bag<E> decorate(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Bag<E> transformingBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedBag<E>(bag, transformer);\n     }\n     \n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n      * \n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> Bag<E> decorateTransform(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Bag<E> transformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // Bag is of type E\n             E[] values = (E[]) bag.toArray();\n             bag.clear();\n-            for(int i=0; i<values.length; i++) {\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n                 decorated.decorated().add(transformer.transform(values[i]));\n             }\n         }\n \n     public Set<E> uniqueSet() {\n         Set<E> set = getBag().uniqueSet();\n-        return TransformedSet.<E>decorate(set, transformer);\n+        return TransformedSet.<E>transformingSet(set, transformer);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n      * \n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed SortedBag\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    public static <E> SortedBag<E> decorate(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> SortedBag<E> transformingSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedBag<E>(bag, transformer);\n     }\n     \n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n      * \n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> SortedBag<E>  decorateTransform(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> SortedBag<E> transformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // bag is type E\n--- a/src/java/org/apache/commons/collections/bag/UnmodifiableBag.java\n+++ b/src/java/org/apache/commons/collections/bag/UnmodifiableBag.java\n      * @return an unmodifiable Bag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> Bag<E> decorate(Bag<E> bag) {\n+    public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n         if (bag instanceof Unmodifiable) {\n             return bag;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.<E>decorate(decorated().iterator());\n+\t\treturn UnmodifiableIterator.<E> unmodifiableIterator(decorated()\n+\t\t\t\t.iterator());\n     }\n \n     @Override\n     @Override\n     public Set<E> uniqueSet() {\n         Set<E> set = decorated().uniqueSet();\n-        return UnmodifiableSet.<E>decorate(set);\n+\t\treturn UnmodifiableSet.<E> unmodifiableSet(set);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/bag/UnmodifiableSortedBag.java\n+++ b/src/java/org/apache/commons/collections/bag/UnmodifiableSortedBag.java\n      * @return an unmodifiable SortedBag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> SortedBag<E> decorate(SortedBag<E> bag) {\n+    public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n         if (bag instanceof Unmodifiable) {\n             return bag;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n     @Override\n     public Set<E> uniqueSet() {\n         Set<E> set = decorated().uniqueSet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n      */\n     public OrderedMapIterator<K, V> mapIterator() {\n         if (isEmpty()) {\n-            return EmptyOrderedMapIterator.<K, V>getInstance();\n+            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n         }\n         return new ViewMapIterator(KEY);\n     }\n \n         public OrderedMapIterator<V, K> mapIterator() {\n             if (isEmpty()) {\n-                return EmptyOrderedMapIterator.<V, K>getInstance();\n+                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n             }\n             return new InverseViewMapIterator(VALUE);\n         }\n--- a/src/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n      * @return an unmodifiable BidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> BidiMap<K, V> decorate(BidiMap<K, V> map) {\n+    public static <K, V> BidiMap<K, V> unmodifiableBidiMap(BidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         Set<Map.Entry<K, V>> set = super.entrySet();\n-        return UnmodifiableEntrySet.decorate(set);\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n         Set<K> set = super.keySet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n         Collection<V> coll = super.values();\n-        return UnmodifiableCollection.decorate(coll);\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public MapIterator<K, V> mapIterator() {\n         MapIterator<K, V> it = decorated().mapIterator();\n-        return UnmodifiableMapIterator.decorate(it);\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n      * @return an unmodifiable OrderedBidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> OrderedBidiMap<K, V> decorate(OrderedBidiMap<K, V> map) {\n+    public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(OrderedBidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         Set<Map.Entry<K, V>> set = super.entrySet();\n-        return UnmodifiableEntrySet.decorate(set);\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n         Set<K> set = super.keySet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n         Collection<V> coll = super.values();\n-        return UnmodifiableCollection.decorate(coll);\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n         OrderedMapIterator<K, V> it = decorated().mapIterator();\n-        return UnmodifiableOrderedMapIterator.decorate(it);\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n     public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n--- a/src/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n      * @return an unmodifiable SortedBidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> SortedBidiMap<K, V> decorate(SortedBidiMap<K, V> map) {\n+    public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(SortedBidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         Set<Map.Entry<K, V>> set = super.entrySet();\n-        return UnmodifiableEntrySet.decorate(set);\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n         Set<K> set = super.keySet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n         Collection<V> coll = super.values();\n-        return UnmodifiableCollection.decorate(coll);\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n         OrderedMapIterator<K, V> it = decorated().mapIterator();\n-        return UnmodifiableOrderedMapIterator.decorate(it);\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public SortedMap<K, V> subMap(K fromKey, K toKey) {\n         SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n-        return UnmodifiableSortedMap.decorate(sm);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n     }\n \n     @Override\n     public SortedMap<K, V> headMap(K toKey) {\n         SortedMap<K, V> sm = decorated().headMap(toKey);\n-        return UnmodifiableSortedMap.decorate(sm);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n     }\n \n     @Override\n     public SortedMap<K, V> tailMap(K fromKey) {\n         SortedMap<K, V> sm = decorated().tailMap(fromKey);\n-        return UnmodifiableSortedMap.decorate(sm);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n      * @return a new blocking Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static <T> Buffer<T> decorate(Buffer<T> buffer) {\n+    public static <T> Buffer<T> blockingBuffer(Buffer<T> buffer) {\n         return new BlockingBuffer<T>(buffer);\n     }\n \n      * @throws IllegalArgumentException if the buffer is null\n      * @since Commons Collections 3.2\n      */\n-    public static <T> Buffer<T> decorate(Buffer<T> buffer, long timeoutMillis) {\n+    public static <T> Buffer<T> blockingBuffer(Buffer<T> buffer, long timeoutMillis) {\n         return new BlockingBuffer<T>(buffer, timeoutMillis);\n     }\n \n--- a/src/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n      * @throws IllegalArgumentException if the buffer is null\n      * @throws IllegalArgumentException if the maximum size is zero or less\n      */\n-    public static <E> BoundedBuffer<E> decorate(Buffer<E> buffer, int maximumSize) {\n+    public static <E> BoundedBuffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize) {\n         return new BoundedBuffer<E>(buffer, maximumSize, 0L);\n     }\n \n      * @throws IllegalArgumentException if the buffer is null\n      * @throws IllegalArgumentException if the maximum size is zero or less\n      */\n-    public static <E> BoundedBuffer<E> decorate(Buffer<E> buffer, int maximumSize, long timeout) {\n+    public static <E> BoundedBuffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize, long timeout) {\n         return new BoundedBuffer<E>(buffer, maximumSize, timeout);\n     }\n \n--- a/src/java/org/apache/commons/collections/buffer/PredicatedBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/PredicatedBuffer.java\n      * @throws IllegalArgumentException if buffer or predicate is null\n      * @throws IllegalArgumentException if the buffer contains invalid elements\n      */\n-    public static <T> Buffer<T> decorate(Buffer<T> buffer, Predicate<? super T> predicate) {\n+    public static <T> Buffer<T> predicatedBuffer(Buffer<T> buffer, Predicate<? super T> predicate) {\n         return new PredicatedBuffer<T>(buffer, predicate);\n     }\n     \n--- a/src/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n  * <p>\n  * Note that this implementation is not synchronized.  Use \n  * {@link org.apache.commons.collections.BufferUtils#synchronizedBuffer(Buffer)} or\n- * {@link org.apache.commons.collections.buffer.SynchronizedBuffer#decorate(Buffer)}\n+ * {@link org.apache.commons.collections.buffer.SynchronizedBuffer#synchronizedBuffer(Buffer)}\n  * to provide synchronized access to a <code>PriorityBuffer</code>:\n  * <pre>\n  * Buffer heap = SynchronizedBuffer.decorate(new PriorityBuffer());\n--- a/src/java/org/apache/commons/collections/buffer/SynchronizedBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/SynchronizedBuffer.java\n      * @return a new synchronized Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static <T> Buffer<T> decorate(Buffer<T> buffer) {\n+    public static <T> Buffer<T> synchronizedBuffer(Buffer<T> buffer) {\n         return new SynchronizedBuffer<T>(buffer);\n     }\n \n--- a/src/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n      * <p>\n      * If there are any elements already in the buffer being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedBuffer(Buffer, Transformer)}.\n      * \n      * @param buffer  the buffer to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Buffer\n      * @throws IllegalArgumentException if buffer or transformer is null\n      */\n-    public static <E> Buffer<E> decorate(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Buffer<E> transformingBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedBuffer<E>(buffer, transformer);\n     }\n     \n      * <p>\n      * If there are any elements already in the buffer being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingBuffer(Buffer, Transformer)}.\n      * \n      * @param buffer  the buffer to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if buffer or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> Buffer<E> decorateTransform(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Buffer<E> transformedBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n         TransformedBuffer<E> decorated = new TransformedBuffer<E>(buffer, transformer); // throws IAE if buffer or transformer is null\n         if (buffer.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // buffer is type <E>\n--- a/src/java/org/apache/commons/collections/buffer/UnmodifiableBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/UnmodifiableBuffer.java\n      * @return an unmodifiable Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static <E> Buffer<E> decorate(Buffer<E> buffer) {\n+    public static <E> Buffer<E> unmodifiableBuffer(Buffer<E> buffer) {\n         if (buffer instanceof Unmodifiable) {\n             return buffer;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/collection/CompositeCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/CompositeCollection.java\n      */\n     public Iterator<E> iterator() {\n         if (all.isEmpty()) {\n-            return EmptyIterator.<E>getInstance();\n+            return EmptyIterator.<E>emptyIterator();\n         }\n         IteratorChain<E> chain = new IteratorChain<E>();\n         for (Collection<? extends E> item : all) {\n      * @return Unmodifiable list of all collections in this composite.\n      */\n     public List<? extends Collection<E>> getCollections() {\n-        return UnmodifiableList.decorate(all);\n+        return UnmodifiableList.unmodifiableList(all);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/collection/PredicatedCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/PredicatedCollection.java\n      * @throws IllegalArgumentException if collection or predicate is null\n      * @throws IllegalArgumentException if the collection contains invalid elements\n      */\n-    public static <T> Collection<T> decorate(Collection<T> coll, Predicate<? super T> predicate) {\n+    public static <T> Collection<T> predicatedCollection(Collection<T> coll, Predicate<? super T> predicate) {\n         return new PredicatedCollection<T>(coll, predicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/collection/SynchronizedCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/SynchronizedCollection.java\n      * @return a new synchronized collection\n      * @throws IllegalArgumentException if collection is null\n      */\n-    public static <T> Collection<T> decorate(Collection<T> coll) {\n+    public static <T> Collection<T> synchronizedCollection(Collection<T> coll) {\n         return new SynchronizedCollection<T>(coll);\n     }\n \n--- a/src/java/org/apache/commons/collections/collection/TransformedCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/TransformedCollection.java\n      * <p>\n      * If there are any elements already in the collection being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n      * \n      * @param coll  the collection to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed collection\n      * @throws IllegalArgumentException if collection or transformer is null\n      */\n-    public static <E> Collection<E> decorate(Collection<E> coll, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Collection<E> transformingCollection(Collection<E> coll, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedCollection<E>(coll, transformer);\n     }\n \n      * <p>\n      * If there are any elements already in the collection being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n      * \n      * @param collection  the collection to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if collection or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> Collection<E> decorateTransform(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Collection<E> transformedCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n         TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n         // null collection & transformer are disallowed by the constructor call above \n         if (collection.size() > 0) {\n--- a/src/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n      * @return a new unmodifiable bounded collection\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> BoundedCollection<E> decorate(BoundedCollection<E> coll) {\n-        return new UnmodifiableBoundedCollection<E>(coll);\n+    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(BoundedCollection<E> coll) {\n+        return unmodifiableBoundedCollection(coll);\n     }\n \n     /**\n      * @throws IllegalArgumentException if bag is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> BoundedCollection<E> decorateUsing(Collection<? super E> coll) {\n+\tpublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n         if (coll == null) {\n             throw new IllegalArgumentException(\"The collection must not be null\");\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/collection/UnmodifiableCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/UnmodifiableCollection.java\n      * @return an unmodifiable collection\n      * @throws IllegalArgumentException if collection is null\n      */\n-    public static <T> Collection<T> decorate(Collection<T> coll) {\n+    public static <T> Collection<T> unmodifiableCollection(Collection<T> coll) {\n         if (coll instanceof Unmodifiable) {\n             return coll;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/comparators/BooleanComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/BooleanComparator.java\n  * <p>\n  * @see #getTrueFirstComparator()\n  * @see #getFalseFirstComparator()\n- * @see #getBooleanComparator(boolean)\n+ * @see #booleanComparator(boolean)\n  *\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n      * <code>true</code> <code>Boolean</code>s before <code>false</code>\n      * @return a singleton BooleanComparator instance\n      */\n-    public static BooleanComparator getBooleanComparator(boolean trueFirst) {\n+    public static BooleanComparator booleanComparator(boolean trueFirst) {\n         return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n     }\n \n--- a/src/java/org/apache/commons/collections/comparators/ComparableComparator.java\n+++ b/src/java/org/apache/commons/collections/comparators/ComparableComparator.java\n      * @return the singleton ComparableComparator\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E extends Comparable<? super E>> ComparableComparator<E> getInstance() {\n+    public static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n         return (ComparableComparator<E>) INSTANCE;\n     }\n \n     /**\n      * Constructor whose use should be avoided.\n      * <p>\n-     * Please use the {@link #getInstance()} method whenever possible.\n+     * Please use the {@link #comparableComparator()} method whenever possible.\n      */\n     public ComparableComparator() {\n         super();\n--- a/src/java/org/apache/commons/collections/functors/AndPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/AndPredicate.java\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> andPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/AnyPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/AnyPredicate.java\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> getInstance(Predicate<? super T>[] predicates) {\n+    public static <T> Predicate<T> anyPredicate(Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return FalsePredicate.<T>falsePredicate();\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> getInstance(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> anyPredicate(Collection<? extends Predicate<T>> predicates) {\n         Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         if (preds.length == 0) {\n             return FalsePredicate.<T>falsePredicate();\n--- a/src/java/org/apache/commons/collections/functors/ChainedClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/ChainedClosure.java\n      * @throws IllegalArgumentException if the closures array is null\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n-    public static <E> Closure<E> getInstance(Closure<? super E>[] closures) {\n+    public static <E> Closure<E> chainedClosure(Closure<? super E>... closures) {\n         FunctorUtils.validate(closures);\n         if (closures.length == 0) {\n-            return NOPClosure.<E>getInstance();\n+            return NOPClosure.<E>nopClosure();\n         }\n         closures = FunctorUtils.copy(closures);\n         return new ChainedClosure<E>(closures);\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance(Collection<Closure<E>> closures) {\n+    public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n         if (closures == null) {\n             throw new IllegalArgumentException(\"Closure collection must not be null\");\n         }\n         if (closures.size() == 0) {\n-            return NOPClosure.<E>getInstance();\n+            return NOPClosure.<E>nopClosure();\n         }\n         // convert to array like this to guarantee iterator() ordering\n         Closure<? super E>[] cmds = new Closure[closures.size()];\n         }\n         FunctorUtils.validate(cmds);\n         return new ChainedClosure<E>(cmds);\n-    }\n-\n-    /**\n-     * Factory method that performs validation.\n-     * \n-     * @param closure1  the first closure, not null\n-     * @param closure2  the second closure, not null\n-     * @return the <code>chained</code> closure\n-     * @throws IllegalArgumentException if either closure is null\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance(Closure<? super E> closure1, Closure<? super E> closure2) {\n-        if (closure1 == null || closure2 == null) {\n-            throw new IllegalArgumentException(\"Closures must not be null\");\n-        }\n-        Closure<E>[] closures = new Closure[] { closure1, closure2 };\n-        return new ChainedClosure<E>(closures);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/functors/ChainedTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ChainedTransformer.java\n      * @throws IllegalArgumentException if the transformers array is null\n      * @throws IllegalArgumentException if any transformer in the array is null\n      */\n-    public static <T> Transformer<T, T> getInstance(Transformer<? super T, ? extends T>[] transformers) {\n+    public static <T> Transformer<T, T> chainedTransformer(Transformer<? super T, ? extends T>... transformers) {\n         FunctorUtils.validate(transformers);\n         if (transformers.length == 0) {\n-            return NOPTransformer.<T>getInstance();\n+            return NOPTransformer.<T>nopTransformer();\n         }\n         transformers = FunctorUtils.copy(transformers);\n         return new ChainedTransformer<T>(transformers);\n      * @throws IllegalArgumentException if any transformer in the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Transformer<T, T> getInstance(Collection<? extends Transformer<T, T>> transformers) {\n+    public static <T> Transformer<T, T> chainedTransformer(Collection<? extends Transformer<T, T>> transformers) {\n         if (transformers == null) {\n             throw new IllegalArgumentException(\"Transformer collection must not be null\");\n         }\n         if (transformers.size() == 0) {\n-            return NOPTransformer.<T>getInstance();\n+            return NOPTransformer.<T>nopTransformer();\n         }\n         // convert to array like this to guarantee iterator() ordering\n         Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n         FunctorUtils.validate(cmds);\n         return new ChainedTransformer<T>(cmds);\n-    }\n-\n-    /**\n-     * Factory method that performs validation.\n-     * \n-     * @param transformer1  the first transformer, not null\n-     * @param transformer2  the second transformer, not null\n-     * @return the <code>chained</code> transformer\n-     * @throws IllegalArgumentException if either transformer is null\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Transformer<T, T> getInstance(Transformer<? super T, ? extends T> transformer1, Transformer<? super T, ? extends T> transformer2) {\n-        if (transformer1 == null || transformer2 == null) {\n-            throw new IllegalArgumentException(\"Transformers must not be null\");\n-        }\n-        Transformer<? super T, ? extends T>[] transformers = new Transformer[] { transformer1, transformer2 };\n-        return new ChainedTransformer<T>(transformers);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/functors/CloneTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/CloneTransformer.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Transformer<T, T> getInstance() {\n+    public static <T> Transformer<T, T> cloneTransformer() {\n         return (Transformer<T, T>) INSTANCE;\n     }\n \n         if (input == null) {\n             return null;\n         }\n-        return PrototypeFactory.getInstance(input).create();\n+        return PrototypeFactory.prototypeFactory(input).create();\n     }\n \n     private Object readResolve() {\n--- a/src/java/org/apache/commons/collections/functors/ClosureTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ClosureTransformer.java\n      * @return the <code>closure</code> transformer\n      * @throws IllegalArgumentException if the closure is null\n      */\n-    public static <T> Transformer<T, T> getInstance(Closure<? super T> closure) {\n+    public static <T> Transformer<T, T> closureTransformer(Closure<? super T> closure) {\n         if (closure == null) {\n             throw new IllegalArgumentException(\"Closure must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if comparator is null\n      */\n-    public static <T> Predicate<T> getInstance(T object, Comparator<T> comparator) {\n-        return getInstance(object, comparator, Criterion.EQUAL);\n+    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator) {\n+        return comparatorPredicate(object, comparator, Criterion.EQUAL);\n     }\n \n     /**\n      * @return the predicate\n      * @throws IllegalArgumentException if comparator is null of criterion is invalid\n      */\n-    public static <T> Predicate<T> getInstance(T object, Comparator<T> comparator, Criterion criterion) {\n+    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n         if (comparator == null) {\n             throw new IllegalArgumentException(\"Comparator must not be null.\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/ConstantFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/ConstantFactory.java\n      * @return the <code>constant</code> factory.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Factory<T> getInstance(T constantToReturn) {\n+    public static <T> Factory<T> constantFactory(T constantToReturn) {\n         if (constantToReturn == null) {\n             return (Factory<T>) NULL_INSTANCE;\n         }\n--- a/src/java/org/apache/commons/collections/functors/ConstantTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ConstantTransformer.java\n      * @return Transformer<I, O> that always returns null.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> getNullInstance() {\n+    public static <I, O> Transformer<I, O> nullTransformer() {\n         return (Transformer<I, O>) NULL_INSTANCE;\n     }\n \n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n-    public static <I, O> Transformer<I, O> getInstance(O constantToReturn) {\n+    public static <I, O> Transformer<I, O> constantTransformer(O constantToReturn) {\n         if (constantToReturn == null) {\n-            return getNullInstance();\n+            return nullTransformer();\n         }\n         return new ConstantTransformer<I, O>(constantToReturn);\n     }\n--- a/src/java/org/apache/commons/collections/functors/DefaultEquator.java\n+++ b/src/java/org/apache/commons/collections/functors/DefaultEquator.java\n \t * @return {@link DefaultEquator#INSTANCE}\n \t */\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic static <T> DefaultEquator<T> instance() {\n+\tpublic static <T> DefaultEquator<T> defaultEquator() {\n \t\treturn (DefaultEquator<T>) DefaultEquator.INSTANCE;\n \t}\n }\n--- a/src/java/org/apache/commons/collections/functors/EqualPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/EqualPredicate.java\n \n     /** The value to compare to */\n     private final Object iValue;\n-    \n+\n     /**\n      * Factory to create the identity predicate.\n      * \n--- a/src/java/org/apache/commons/collections/functors/ExceptionClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionClosure.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance() {\n+    public static <E> Closure<E> exceptionClosure() {\n         return (Closure<E>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ExceptionFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionFactory.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Factory<T> getInstance() {\n+    public static <T> Factory<T> exceptionFactory() {\n         return (Factory<T>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> getInstance() {\n+    public static <T> Predicate<T> exceptionPredicate() {\n         return (Predicate<T>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> getInstance() {\n+    public static <I, O> Transformer<I, O> exceptionTransformer() {\n         return (Transformer<I, O>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/FactoryTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/FactoryTransformer.java\n      * @return the <code>factory</code> transformer\n      * @throws IllegalArgumentException if the factory is null\n      */\n-    public static <I, O> Transformer<I, O> getInstance(Factory<? extends O> factory) {\n+    public static <I, O> Transformer<I, O> factoryTransformer(Factory<? extends O> factory) {\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/FalsePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/FalsePredicate.java\n      * Get a typed instance.\n      *\n      * @return the singleton instance\n-     * @since Commons Collections 5\n+     * @since Commons Collections 4.0\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> Predicate<T> falsePredicate() {\n--- a/src/java/org/apache/commons/collections/functors/ForClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/ForClosure.java\n      * @return the <code>for</code> closure\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance(int count, Closure<? super E> closure) {\n+    public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n         if (count <= 0 || closure == null) {\n-            return NOPClosure.<E>getInstance();\n+            return NOPClosure.<E>nopClosure();\n         }\n         if (count == 1) {\n             return (Closure<E>) closure;\n--- a/src/java/org/apache/commons/collections/functors/IdentityPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/IdentityPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(T object) {\n+    public static <T> Predicate<T> identityPredicate(T object) {\n         if (object == null) {\n             return NullPredicate.<T>nullPredicate();\n         }\n--- a/src/java/org/apache/commons/collections/functors/IfClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/IfClosure.java\n      * @throws IllegalArgumentException if either argument is null\n      * @since Commons Collections 3.2\n      */\n-    public static <E> Closure<E> getInstance(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n-        return IfClosure.<E>getInstance(predicate, trueClosure, NOPClosure.<E>getInstance());\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n     }\n \n     /**\n      * @return the <code>if</code> closure\n      * @throws IllegalArgumentException if any argument is null\n      */\n-    public static <E> Closure<E> getInstance(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the class is null\n      */\n-    public static Predicate<Object> getInstance(Class<?> type) {\n+    public static Predicate<Object> instanceOfPredicate(Class<?> type) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/InstantiateFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/InstantiateFactory.java\n      * @param args  the constructor arguments\n      * @return a new instantiate factory\n      */\n-    public static <T> Factory<T> getInstance(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n         if (classToInstantiate == null) {\n             throw new IllegalArgumentException(\"Class to instantiate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n      * @param <T>\n      * @return Transformer<Class<? extends T>, T>\n      */\n-    public static <T> Transformer<Class<? extends T>, T> getInstance() {\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n         return new InstantiateTransformer<T>();\n     }\n \n      * @param args  the constructor arguments\n      * @return an instantiate transformer\n      */\n-    public static <T> Transformer<Class<? extends T>, T> getInstance(Class<?>[] paramTypes, Object[] args) {\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(Class<?>[] paramTypes, Object[] args) {\n         if (((paramTypes == null) && (args != null))\n             || ((paramTypes != null) && (args == null))\n             || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n--- a/src/java/org/apache/commons/collections/functors/InvokerTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/InvokerTransformer.java\n      * @return an invoker transformer\n      * @since Commons Collections 3.1\n      */\n-    public static <I, O> Transformer<I, O> getInstance(String methodName) {\n+    public static <I, O> Transformer<I, O> invokerTransformer(String methodName) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n      * @param args  the arguments to pass to the method\n      * @return an invoker transformer\n      */\n-    public static <I, O> Transformer<I, O> getInstance(String methodName, Class<?>[] paramTypes, Object[] args) {\n+    public static <I, O> Transformer<I, O> invokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/MapTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/MapTransformer.java\n      * @param map the map, not cloned\n      * @return the transformer\n      */\n-    public static <I, O> Transformer<I, O> getInstance(Map<? super I, ? extends O> map) {\n+    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {\n         if (map == null) {\n-            return ConstantTransformer.<I, O>getNullInstance();\n+            return ConstantTransformer.<I, O>nullTransformer();\n         }\n         return new MapTransformer<I, O>(map);\n     }\n--- a/src/java/org/apache/commons/collections/functors/NOPClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/NOPClosure.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance() {\n+    public static <E> Closure<E> nopClosure() {\n         return (Closure<E>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NOPTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/NOPTransformer.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Transformer<T, T> getInstance() {\n+    public static <T> Transformer<T, T> nopTransformer() {\n         return (Transformer<T, T>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NonePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NonePredicate.java\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T>[] predicates) {\n+    public static <T> Predicate<T> nonePredicate(Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return TruePredicate.<T>truePredicate();\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> getInstance(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> nonePredicate(Collection<? extends Predicate<T>> predicates) {\n         Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         if (preds.length == 0) {\n             return TruePredicate.<T>truePredicate();\n--- a/src/java/org/apache/commons/collections/functors/NotNullPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NotNullPredicate.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> getInstance() {\n+    public static <T> Predicate<T> notNullPredicate() {\n         return (Predicate<T>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/NotPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NotPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> notPredicate(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> nullIsExceptionPredicate(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> nullIsFalsePredicate(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> nullIsTruePredicate(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/OnePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/OnePredicate.java\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> getInstance(Predicate<? super T>[] predicates) {\n+    public static <T> Predicate<T> onePredicate(Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return FalsePredicate.<T>falsePredicate();\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> getInstance(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> onePredicate(Collection<? extends Predicate<T>> predicates) {\n         Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         return new OnePredicate<T>(preds);\n     }\n--- a/src/java/org/apache/commons/collections/functors/OrPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/OrPredicate.java\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> orPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/PredicateTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/PredicateTransformer.java\n      * @return the <code>predicate</code> transformer\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Transformer<T, Boolean> getInstance(Predicate<? super T> predicate) {\n+    public static <T> Transformer<T, Boolean> predicateTransformer(Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/PrototypeFactory.java\n+++ b/src/java/org/apache/commons/collections/functors/PrototypeFactory.java\n      * @throws IllegalArgumentException if the prototype cannot be cloned\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Factory<T> getInstance(T prototype) {\n+    public static <T> Factory<T> prototypeFactory(T prototype) {\n         if (prototype == null) {\n-            return ConstantFactory.<T>getInstance(null);\n+            return ConstantFactory.<T>constantFactory(null);\n         }\n         try {\n             Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n--- a/src/java/org/apache/commons/collections/functors/StringValueTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/StringValueTransformer.java\n      * @since Commons Collections 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Transformer<T, String> getInstance() {\n+    public static <T> Transformer<T, String> stringValueTransformer() {\n         return (Transformer<T, String>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/SwitchClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/SwitchClosure.java\n      * @throws IllegalArgumentException if any element in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n+    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n         FunctorUtils.validate(predicates);\n         FunctorUtils.validate(closures);\n         if (predicates.length != closures.length) {\n             throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n         }\n         if (predicates.length == 0) {\n-            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>getInstance(): defaultClosure);\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure(): defaultClosure);\n         }\n         predicates = FunctorUtils.copy(predicates);\n         closures = FunctorUtils.copy(closures);\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> getInstance(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+    public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n         if (predicatesAndClosures == null) {\n             throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n         }\n         Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n         int size = predicatesAndClosures.size();\n         if (size == 0) {\n-            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>getInstance() : defaultClosure);\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n         }\n         Closure<E>[] closures = new Closure[size];\n         Predicate<E>[] preds = new Predicate[size];\n         super();\n         iPredicates = predicates;\n         iClosures = closures;\n-        iDefault = (Closure<? super E>) (defaultClosure == null ? NOPClosure.<E>getInstance() : defaultClosure);\n+        iDefault = (Closure<? super E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/functors/SwitchTransformer.java\n+++ b/src/java/org/apache/commons/collections/functors/SwitchTransformer.java\n      * @throws IllegalArgumentException if any element in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> getInstance(Predicate<? super I>[] predicates,\n+    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n             Transformer<? super I, ? extends O>[] transformers,\n             Transformer<? super I, ? extends O> defaultTransformer) {\n         FunctorUtils.validate(predicates);\n             throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n         }\n         if (predicates.length == 0) {\n-            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>getNullInstance() : defaultTransformer);\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n         }\n         predicates = FunctorUtils.copy(predicates);\n         transformers = FunctorUtils.copy(transformers);\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> getInstance(\n+    public static <I, O> Transformer<I, O> switchTransformer(\n             Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> predicatesAndTransformers) {\n         if (predicatesAndTransformers == null) {\n             throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n         }\n         if (predicatesAndTransformers.size() == 0) {\n-            return ConstantTransformer.<I, O>getNullInstance();\n+            return ConstantTransformer.<I, O>nullTransformer();\n         }\n         // convert to array like this to guarantee iterator() ordering\n         Transformer<? super I, ? extends O> defaultTransformer = predicatesAndTransformers.remove(null);\n         int size = predicatesAndTransformers.size();\n         if (size == 0) {\n-            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>getNullInstance() : defaultTransformer);\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n         }\n         Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n         Predicate<? super I>[] preds = new Predicate[size];\n         super();\n         iPredicates = predicates;\n         iTransformers = transformers;\n-        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ? ConstantTransformer.<I, O>getNullInstance() : defaultTransformer);\n+        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/functors/TransformedPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/TransformedPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the transformer or the predicate is null\n      */\n-    public static <T> Predicate<T> getInstance(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> transformedPredicate(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/TransformerClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/TransformerClosure.java\n      * @param transformer  the transformer to call, null means nop\n      * @return the <code>transformer</code> closure\n      */\n-    public static <E> Closure<E> getInstance(Transformer<? super E, ?> transformer) {\n+    public static <E> Closure<E> transformerClosure(Transformer<? super E, ?> transformer) {\n         if (transformer == null) {\n-            return NOPClosure.<E>getInstance();\n+            return NOPClosure.<E>nopClosure();\n         }\n         return new TransformerClosure<E>(transformer);\n     }\n--- a/src/java/org/apache/commons/collections/functors/TransformerPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/TransformerPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the transformer is null\n      */\n-    public static <T> Predicate<T> getInstance(Transformer<? super T, Boolean> transformer) {\n+    public static <T> Predicate<T> transformerPredicate(Transformer<? super T, Boolean> transformer) {\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/functors/UniquePredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/UniquePredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <E> Predicate<E> getInstance() {\n+    public static <E> Predicate<E> uniquePredicate() {\n         return new UniquePredicate<E>();\n     }\n \n--- a/src/java/org/apache/commons/collections/functors/WhileClosure.java\n+++ b/src/java/org/apache/commons/collections/functors/WhileClosure.java\n      * @return the <code>while</code> closure\n      * @throws IllegalArgumentException if the predicate or closure is null\n      */\n-    public static <E> Closure<E> getInstance(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n+    public static <E> Closure<E> whileClosure(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/iterators/CollatingIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/CollatingIterator.java\n      * @return the unmodifiable list of iterators added\n      */\n     public List<Iterator<? extends E>> getIterators() {\n-        return UnmodifiableList.decorate(iterators);\n+        return UnmodifiableList.unmodifiableList(iterators);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/iterators/EmptyIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyIterator.java\n      * @return ResettableIterator<E>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> ResettableIterator<E> getResettableInstance() {\n+    public static <E> ResettableIterator<E> resettableEmptyIterator() {\n         return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n     }\n \n      * @return Iterator<E>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Iterator<E> getInstance() {\n+    public static <E> Iterator<E> emptyIterator() {\n         return (Iterator<E>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/EmptyListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyListIterator.java\n      * @return {@link ResettableListIterator}<E>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> ResettableListIterator<E> getResettableInstance() {\n+    public static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n         return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n     }\n \n      * @return {@link ListIterator}<E>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> ListIterator<E> getInstance() {\n+    public static <E> ListIterator<E> emptyListIterator() {\n         return (ListIterator<E>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/EmptyMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyMapIterator.java\n      * @return {@link MapIterator}<K, V>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <K, V> MapIterator<K, V> getInstance() {\n+    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n         return (MapIterator<K, V>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/EmptyOrderedIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyOrderedIterator.java\n      * @return OrderedIterator<E>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> OrderedIterator<E> getInstance() {\n+    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n         return (OrderedIterator<E>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/EmptyOrderedMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/EmptyOrderedMapIterator.java\n      * @return {@link OrderedMapIterator}<K, V>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <K, V> OrderedMapIterator<K, V> getInstance() {\n+    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n         return (OrderedMapIterator<K, V>) INSTANCE;\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/IteratorChain.java\n+++ b/src/java/org/apache/commons/collections/iterators/IteratorChain.java\n      * @param iteratorChain the array of iterators, not null\n      * @throws NullPointerException if iterators array is or contains null\n      */\n-    public IteratorChain(Iterator<? extends E>[] iteratorChain) {\n+    public IteratorChain(Iterator<? extends E>... iteratorChain) {\n         super();\n         for (int i = 0; i < iteratorChain.length; i++) {\n             addIterator(iteratorChain[i]);\n      * @return the unmodifiable list of iterators added\n      */\n     public List<Iterator<? extends E>> getIterators() {\n-        return UnmodifiableList.decorate(iteratorChain);\n+        return UnmodifiableList.unmodifiableList(iteratorChain);\n     }\n \n     /**\n     protected void updateCurrentIterator() {\n         if (currentIterator == null) {\n             if (iteratorChain.isEmpty()) {\n-                currentIterator = EmptyIterator.<E> getInstance();\n+                currentIterator = EmptyIterator.<E> emptyIterator();\n             } else {\n                 currentIterator = iteratorChain.get(0);\n             }\n--- a/src/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n      * @param array the array to iterate over\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayIterator(E[] array) {\n+    public ObjectArrayIterator(E... array) {\n         this(array, 0, array.length);\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/ObjectArrayListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/ObjectArrayListIterator.java\n      * @param array the array to iterate over\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayListIterator(E[] array) {\n+    public ObjectArrayListIterator(E... array) {\n         super(array);\n     }\n \n--- a/src/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n      *  @param iterator  the iterator to use\n      */\n     public UniqueFilterIterator(Iterator<E> iterator) {\n-        super(iterator, UniquePredicate.getInstance());\n+        super(iterator, UniquePredicate.uniquePredicate());\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <E> Iterator<E> decorate(Iterator<E> iterator) {\n+    public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"Iterator must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <E> ListIterator<E> decorate(ListIterator<E> iterator) {\n+    public static <E> ListIterator<E> umodifiableListIterator(ListIterator<E> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"ListIterator must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <K, V> MapIterator<K, V> decorate(MapIterator<K, V> iterator) {\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"MapIterator must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n+++ b/src/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n      * @param iterator  the iterator to decorate\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <K, V> OrderedMapIterator<K, V> decorate(OrderedMapIterator<K, V> iterator) {\n+    public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(OrderedMapIterator<K, V> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/list/FixedSizeList.java\n+++ b/src/java/org/apache/commons/collections/list/FixedSizeList.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> List<E> decorate(List<E> list) {\n+    public static <E> List<E> fixedSizeList(List<E> list) {\n         return new FixedSizeList<E>(list);\n     }\n \n \n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/list/GrowthList.java\n+++ b/src/java/org/apache/commons/collections/list/GrowthList.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> List<E> decorate(List<E> list) {\n+    public static <E> List<E> growthList(List<E> list) {\n         return new GrowthList<E>(list);\n     }\n \n--- a/src/java/org/apache/commons/collections/list/LazyList.java\n+++ b/src/java/org/apache/commons/collections/list/LazyList.java\n      * @param factory  the factory to use for creation, must not be null\n      * @throws IllegalArgumentException if list or factory is null\n      */\n-    public static <E> List<E> decorate(List<E> list, Factory<? extends E> factory) {\n+    public static <E> List<E> lazyList(List<E> list, Factory<? extends E> factory) {\n         return new LazyList<E>(list, factory);\n     }\n     \n--- a/src/java/org/apache/commons/collections/list/PredicatedList.java\n+++ b/src/java/org/apache/commons/collections/list/PredicatedList.java\n      * @throws IllegalArgumentException if list or predicate is null\n      * @throws IllegalArgumentException if the list contains invalid elements\n      */\n-    public static <T> List<T> decorate(List<T> list, Predicate<? super T> predicate) {\n+    public static <T> List<T> predicatedList(List<T> list, Predicate<? super T> predicate) {\n         return new PredicatedList<T>(list, predicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/list/SetUniqueList.java\n+++ b/src/java/org/apache/commons/collections/list/SetUniqueList.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> SetUniqueList<E> decorate(List<E> list) {\n+    public static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n      * @return an unmodifiable set view\n      */\n     public Set<E> asSet() {\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/collections/list/SynchronizedList.java\n+++ b/src/java/org/apache/commons/collections/list/SynchronizedList.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <T> List<T> decorate(List<T> list) {\n+    public static <T> List<T> synchronizedList(List<T> list) {\n         return new SynchronizedList<T>(list);\n     }\n     \n--- a/src/java/org/apache/commons/collections/list/TransformedList.java\n+++ b/src/java/org/apache/commons/collections/list/TransformedList.java\n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedList(List, Transformer)}.\n      * \n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if list or transformer is null\n      */\n-    public static <E> List<E> decorate(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> List<E> transformingList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedList<E>(list, transformer);\n     }\n     \n      * <p>\n      * If there are any elements already in the list being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingList(List, Transformer)}.\n      * \n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if list or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> List<E> decorateTransform(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> List<E> transformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n         TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n         if (transformer != null && list != null && list.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // list is of type E\n--- a/src/java/org/apache/commons/collections/list/UnmodifiableList.java\n+++ b/src/java/org/apache/commons/collections/list/UnmodifiableList.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> List<E> decorate(List<E> list) {\n+    public static <E> List<E> unmodifiableList(List<E> list) {\n         if (list instanceof Unmodifiable) {\n             return list;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n     //-----------------------------------------------------------------------\n     @Override\n     public ListIterator<E> listIterator() {\n-        return UnmodifiableListIterator.decorate(decorated().listIterator());\n+        return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator());\n     }\n \n     @Override\n     public ListIterator<E> listIterator(int index) {\n-        return UnmodifiableListIterator.decorate(decorated().listIterator(index));\n+        return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator(index));\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n      */\n     public MapIterator<K, V> mapIterator() {\n         if (size == 0) {\n-            return EmptyMapIterator.<K, V>getInstance();\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n         }\n         return new HashMapIterator<K, V>(this);\n     }\n      */\n     protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n         if (size() == 0) {\n-            return EmptyIterator.<Map.Entry<K, V>>getInstance();\n+            return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n         }\n         return new EntrySetIterator<K, V>(this);\n     }\n      */\n     protected Iterator<K> createKeySetIterator() {\n         if (size() == 0) {\n-            return EmptyIterator.<K>getInstance();\n+            return EmptyIterator.<K>emptyIterator();\n         }\n         return new KeySetIterator<K>(this);\n     }\n      */\n     protected Iterator<V> createValuesIterator() {\n         if (size() == 0) {\n-            return EmptyIterator.<V>getInstance();\n+            return EmptyIterator.<V>emptyIterator();\n         }\n         return new ValuesIterator<V>(this);\n     }\n--- a/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n         if (size == 0) {\n-            return EmptyOrderedMapIterator.<K, V>getInstance();\n+            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n         }\n         return new LinkMapIterator<K, V>(this);\n     }\n     @Override\n     protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n         if (size() == 0) {\n-            return EmptyOrderedIterator.<Map.Entry<K, V>>getInstance();\n+            return EmptyOrderedIterator.<Map.Entry<K, V>>emptyOrderedIterator();\n         }\n         return new EntrySetIterator<K, V>(this);\n     }\n     @Override\n     protected Iterator<K> createKeySetIterator() {\n         if (size() == 0) {\n-            return EmptyOrderedIterator.<K>getInstance();\n+            return EmptyOrderedIterator.<K>emptyOrderedIterator();\n         }\n         return new KeySetIterator<K>(this);\n     }\n     @Override\n     protected Iterator<V> createValuesIterator() {\n         if (size() == 0) {\n-            return EmptyOrderedIterator.<V>getInstance();\n+            return EmptyOrderedIterator.<V>emptyOrderedIterator();\n         }\n         return new ValuesIterator<V>(this);\n     }\n--- a/src/java/org/apache/commons/collections/map/CompositeMap.java\n+++ b/src/java/org/apache/commons/collections/map/CompositeMap.java\n      * @param composite  the Maps to be composited\n      * @throws IllegalArgumentException if there is a key collision\n      */\n-    public CompositeMap(Map<K, V>[] composite) {\n+    public CompositeMap(Map<K, V>... composite) {\n         this(composite, null);\n     }\n \n--- a/src/java/org/apache/commons/collections/map/DefaultedMap.java\n+++ b/src/java/org/apache/commons/collections/map/DefaultedMap.java\n      * @param defaultValue  the default value to return when the key is not found\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> Map<K, V> decorate(Map<K, V> map, V defaultValue) {\n-        return new DefaultedMap<K, V>(map, ConstantTransformer.getInstance(defaultValue));\n+    public static <K, V> Map<K, V> defaultedMap(Map<K, V> map, V defaultValue) {\n+        return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n     }\n \n     /**\n      * @param factory  the factory to use to create entries, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> IterableMap<K, V> decorate(Map<K, V> map, Factory<? extends V> factory) {\n+    public static <K, V> IterableMap<K, V> defaultedMap(Map<K, V> map, Factory<? extends V> factory) {\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n         }\n-        return new DefaultedMap<K, V>(map, FactoryTransformer.getInstance(factory));\n+        return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n     }\n \n     /**\n      * @param transformer  the transformer to use as a factory to create entries, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> Map<K, V> decorate(Map<K, V> map, Transformer<? super K, ? extends V> transformer) {\n+    public static <K, V> Map<K, V> defaultedMap(Map<K, V> map, Transformer<? super K, ? extends V> transformer) {\n         if (transformer == null) {\n            throw new IllegalArgumentException(\"Transformer must not be null\");\n        }\n      * @param defaultValue  the default value to return when the key is not found\n      */\n     public DefaultedMap(V defaultValue) {\n-        this(ConstantTransformer.getInstance(defaultValue));\n+        this(ConstantTransformer.constantTransformer(defaultValue));\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/map/FixedSizeMap.java\n+++ b/src/java/org/apache/commons/collections/map/FixedSizeMap.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> IterableMap<K, V> decorate(Map<K, V> map) {\n+    public static <K, V> IterableMap<K, V> fixedSizeMap(Map<K, V> map) {\n         return new FixedSizeMap<K, V>(map);\n     }\n \n     public Set<Map.Entry<K, V>> entrySet() {\n         Set<Map.Entry<K, V>> set = map.entrySet();\n         // unmodifiable set will still allow modification via Map.Entry objects\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n         Set<K> set = map.keySet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n         Collection<V> coll = map.values();\n-        return UnmodifiableCollection.decorate(coll);\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     public boolean isFull() {\n--- a/src/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> SortedMap<K, V> decorate(SortedMap<K, V> map) {\n+    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n         return new FixedSizeSortedMap<K, V>(map);\n     }\n \n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        return UnmodifiableSet.decorate(map.entrySet());\n+        return UnmodifiableSet.unmodifiableSet(map.entrySet());\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        return UnmodifiableSet.decorate(map.keySet());\n+        return UnmodifiableSet.unmodifiableSet(map.keySet());\n     }\n \n     @Override\n     public Collection<V> values() {\n-        return UnmodifiableCollection.decorate(map.values());\n+        return UnmodifiableCollection.unmodifiableCollection(map.values());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/java/org/apache/commons/collections/map/Flat3Map.java\n             return delegateMap.mapIterator();\n         }\n         if (size == 0) {\n-            return EmptyMapIterator.<K, V>getInstance();\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n         }\n         return new FlatMapIterator<K, V>(this);\n     }\n                 return parent.delegateMap.entrySet().iterator();\n             }\n             if (parent.size() == 0) {\n-                return EmptyIterator.<Map.Entry<K, V>>getInstance();\n+                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n             }\n             return new EntrySetIterator<K, V>(parent);\n         }\n                 return parent.delegateMap.keySet().iterator();\n             }\n             if (parent.size() == 0) {\n-                return EmptyIterator.<K>getInstance();\n+                return EmptyIterator.<K>emptyIterator();\n             }\n             return new KeySetIterator<K>(parent);\n         }\n                 return parent.delegateMap.values().iterator();\n             }\n             if (parent.size() == 0) {\n-                return EmptyIterator.<V>getInstance();\n+                return EmptyIterator.<V>emptyIterator();\n             }\n             return new ValuesIterator<V>(parent);\n         }\n--- a/src/java/org/apache/commons/collections/map/LazyMap.java\n+++ b/src/java/org/apache/commons/collections/map/LazyMap.java\n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> LazyMap<K, V> getLazyMap(Map<K, V> map, Factory< ? extends V> factory) {\n+    public static <K, V> LazyMap<K, V> lazyMap(Map<K, V> map, Factory< ? extends V> factory) {\n         return new LazyMap<K,V>(map, factory);\n     }\n \n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <V, K> LazyMap<K, V> getLazyMap(Map<K, V> map, Transformer<? super K, ? extends V> factory) {\n+    public static <V, K> LazyMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> factory) {\n         return new LazyMap<K,V>(map, factory);\n     }\n \n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n         }\n-        this.factory = FactoryTransformer.getInstance(factory);\n+        this.factory = FactoryTransformer.factoryTransformer(factory);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/map/LazySortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LazySortedMap.java\n     /** Serialization version */\n     private static final long serialVersionUID = 2715322183617658933L;\n \n-\n     /**\n      * Factory method to create a lazily instantiated sorted map.\n      * \n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> SortedMap<K, V> getLazySortedMap(SortedMap<K, V> map, Factory<? extends V> factory) {\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map, Factory<? extends V> factory) {\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> SortedMap<K, V> getLazySortedMap(SortedMap<K, V> map, Transformer<? super K, ? extends V> factory) {\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map, Transformer<? super K, ? extends V> factory) {\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n--- a/src/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n \n         @Override\n         public Iterator<K> iterator() {\n-            return UnmodifiableIterator.decorate(parent.keySet().iterator());\n+            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n         }\n \n         @Override\n         public ListIterator<K> listIterator() {\n-            return UnmodifiableListIterator.decorate(super.listIterator());\n+            return UnmodifiableListIterator.umodifiableListIterator(super.listIterator());\n         }\n \n         @Override\n         public ListIterator<K> listIterator(int fromIndex) {\n-            return UnmodifiableListIterator.decorate(super.listIterator(fromIndex));\n+            return UnmodifiableListIterator.umodifiableListIterator(super.listIterator(fromIndex));\n         }\n \n         @Override\n         public List<K> subList(int fromIndexInclusive, int toIndexExclusive) {\n-            return UnmodifiableList.decorate(super.subList(fromIndexInclusive, toIndexExclusive));\n+            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n         }\n     }\n \n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> OrderedMap<K, V> decorate(Map<K, V> map) {\n+    public static <K, V> OrderedMap<K, V> listOrderedMap(Map<K, V> map) {\n         return new ListOrderedMap<K, V>(map);\n     }\n \n      * @since Commons Collections 3.2\n      */\n     public List<K> keyList() {\n-        return UnmodifiableList.decorate(insertOrder);\n+        return UnmodifiableList.unmodifiableList(insertOrder);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n      * @param map  the map to decorate, not null\n      * @throws IllegalArgumentException if the map is null or not empty\n      */\n-    public static <K, V> MultiKeyMap<K, V> decorate(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+    public static <K, V> MultiKeyMap<K, V> multiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n \n     /**\n      * Constructor that decorates the specified map and is called from\n-     * {@link #decorate(AbstractHashedMap)}.\n+     * {@link #multiKeyMap(AbstractHashedMap)}.\n      * The map must not be null and should be empty or only contain valid keys.\n      * This constructor performs no validation.\n      *\n--- a/src/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiValueMap.java\n      *\n      * @param map  the map to wrap\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    public static <K, V> MultiValueMap<K, V> decorate(Map<K, ? super Collection<V>> map) {\n-        return MultiValueMap.<K, V, ArrayList>decorate((Map<K, ? super Collection>) map, ArrayList.class);\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n     }\n \n     /**\n      * @param map  the map to wrap\n      * @param collectionClass  the type of the collection class\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> decorate(Map<K, ? super C> map, Class<C> collectionClass) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map, Class<C> collectionClass) {\n         return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n     }\n \n      * @param map  the map to decorate\n      * @param collectionFactory  the collection factory (must return a Collection object).\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> decorate(Map<K, ? super C> map, Factory<C> collectionFactory) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map, Factory<C> collectionFactory) {\n         return new MultiValueMap<K, V>(map, collectionFactory);\n     }\n \n      * Creates a MultiValueMap based on a <code>HashMap</code> and\n      * storing the multiple values in an <code>ArrayList</code>.\n      */\n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public MultiValueMap() {\n-        this(new HashMap(), new ReflectionFactory(ArrayList.class));\n+        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n     }\n \n     /**\n      */\n     public Iterator<V> iterator(Object key) {\n         if (!containsKey(key)) {\n-            return EmptyIterator.<V>getInstance();\n+            return EmptyIterator.<V>emptyIterator();\n         }\n         return new ValuesIterator(key);\n     }\n--- a/src/java/org/apache/commons/collections/map/PredicatedMap.java\n+++ b/src/java/org/apache/commons/collections/map/PredicatedMap.java\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static <K, V> IterableMap<K, V> decorate(Map<K, V> map, Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+    public static <K, V> IterableMap<K, V> predicatedMap(Map<K, V> map, Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n         return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static <K, V> SortedMap<K, V> decorate(SortedMap<K, V> map,\n+    public static <K, V> SortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n             Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n         return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n--- a/src/java/org/apache/commons/collections/map/TransformedMap.java\n+++ b/src/java/org/apache/commons/collections/map/TransformedMap.java\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * are NOT transformed.\n-     * Contrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n      *\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> IterableMap<K, V> decorate(Map<K, V> map,\n+    public static <K, V> IterableMap<K, V> transformingMap(Map<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer,\n             Transformer<? super V, ? extends V> valueTransformer) {\n         return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * will be transformed by this method.\n-     * Contrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n      *\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n      * @since Commons Collections 3.2\n      */\n-    public static <K, V> Map<K, V> decorateTransform(Map<K, V> map,\n+    public static <K, V> Map<K, V> transformedMap(Map<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer,\n             Transformer<? super V, ? extends V> valueTransformer) {\n         TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n--- a/src/java/org/apache/commons/collections/map/TransformedSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/TransformedSortedMap.java\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n      * \n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the predicate to validate the keys, null means no transformation\n      * @param valueTransformer  the predicate to validate to values, null means no transformation\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static <K, V> SortedMap<K, V> decorate(SortedMap<K, V> map,\n+    public static <K, V> SortedMap<K, V> transformingSortedMap(SortedMap<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer,\n             Transformer<? super V, ? extends V> valueTransformer) {\n         return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n      * \n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n      * @since Commons Collections 3.2\n      */\n-    public static <K, V> SortedMap<K, V> decorateTransform(SortedMap<K, V> map,\n+    public static <K, V> SortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer,\n             Transformer<? super V, ? extends V> valueTransformer) {\n         TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n--- a/src/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n+++ b/src/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <K, V> Set<Map.Entry<K, V>> decorate(Set<Map.Entry<K, V>> set) {\n+    public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n--- a/src/java/org/apache/commons/collections/map/UnmodifiableMap.java\n+++ b/src/java/org/apache/commons/collections/map/UnmodifiableMap.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> Map<K, V> decorate(Map<K, V> map) {\n+    public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n     public MapIterator<K, V> mapIterator() {\n         if (map instanceof IterableMap) {\n             MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n-            return UnmodifiableMapIterator.decorate(it);\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n         }\n         MapIterator<K, V> it = new EntrySetMapIterator<K, V>(map);\n-        return UnmodifiableMapIterator.decorate(it);\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         Set<Map.Entry<K, V>> set = super.entrySet();\n-        return UnmodifiableEntrySet.decorate(set);\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n         Set<K> set = super.keySet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n         Collection<V> coll = super.values();\n-        return UnmodifiableCollection.decorate(coll);\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> OrderedMap<K, V> decorate(OrderedMap<K, V> map) {\n+    public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(OrderedMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n         OrderedMapIterator<K, V> it = decorated().mapIterator();\n-        return UnmodifiableOrderedMapIterator.decorate(it);\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n     @Override\n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         Set<Map.Entry<K, V>> set = super.entrySet();\n-        return UnmodifiableEntrySet.decorate(set);\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n         Set<K> set = super.keySet();\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n         Collection<V> coll = super.values();\n-        return UnmodifiableCollection.decorate(coll);\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n+++ b/src/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> SortedMap<K, V> decorate(SortedMap<K, V> map) {\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        return UnmodifiableEntrySet.decorate(super.entrySet());\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(super.entrySet());\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        return UnmodifiableSet.decorate(super.keySet());\n+        return UnmodifiableSet.unmodifiableSet(super.keySet());\n     }\n \n     @Override\n     public Collection<V> values() {\n-        return UnmodifiableCollection.decorate(super.values());\n+        return UnmodifiableCollection.unmodifiableCollection(super.values());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/collections/set/CompositeSet.java\n+++ b/src/java/org/apache/commons/collections/set/CompositeSet.java\n     /**\n      * Create a composite set with sets as the initial set of composited Sets\n      */\n-    public CompositeSet(Set<E>[] sets) {\n+    public CompositeSet(Set<E>... sets) {\n         super(sets);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/ListOrderedSet.java\n+++ b/src/java/org/apache/commons/collections/set/ListOrderedSet.java\n      * @throws IllegalArgumentException if either the set or list is not empty\n      * @since Commons Collections 3.1\n      */\n-    public static <E> ListOrderedSet<E> decorate(Set<E> set, List<E> list) {\n+    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set, List<E> list) {\n         if (set == null) {\n             throw new IllegalArgumentException(\"Set must not be null\");\n         }\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> ListOrderedSet<E> decorate(Set<E> set) {\n+    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set) {\n         return new ListOrderedSet<E>(set);\n     }\n \n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> ListOrderedSet<E> decorate(List<E> list) {\n+    public static <E> ListOrderedSet<E> listOrderedSet(List<E> list) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n      * @return an unmodifiable list view\n      */\n     public List<E> asList() {\n-        return UnmodifiableList.decorate(setOrder);\n+        return UnmodifiableList.unmodifiableList(setOrder);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/collections/set/MapBackedSet.java\n+++ b/src/java/org/apache/commons/collections/set/MapBackedSet.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E, V> Set<E> decorate(Map<E, ? super V> map) {\n-        return decorate(map, null);\n+    public static <E, V> Set<E> mapBackedSet(Map<E, ? super V> map) {\n+        return mapBackedSet(map, null);\n     }\n \n     /**\n      * @param dummyValue  the dummy value to use\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <E, V> Set<E> decorate(Map<E, ? super V> map, V dummyValue) {\n+    public static <E, V> Set<E> mapBackedSet(Map<E, ? super V> map, V dummyValue) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"The map must not be null\");\n         }\n--- a/src/java/org/apache/commons/collections/set/PredicatedSet.java\n+++ b/src/java/org/apache/commons/collections/set/PredicatedSet.java\n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    public static <T> Set<T> decorate(Set<T> set, Predicate<? super T> predicate) {\n+    public static <T> Set<T> predicatedSet(Set<T> set, Predicate<? super T> predicate) {\n         return new PredicatedSet<T>(set, predicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n+++ b/src/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    public static <T> SortedSet<T> decorate(SortedSet<T> set, Predicate<? super T> predicate) {\n+    public static <T> SortedSet<T> predicatedSortedSet(SortedSet<T> set, Predicate<? super T> predicate) {\n         return new PredicatedSortedSet<T>(set, predicate);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/SynchronizedSet.java\n+++ b/src/java/org/apache/commons/collections/set/SynchronizedSet.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <T> Set<T> decorate(Set<T> set) {\n+    public static <T> Set<T> synchronizedSet(Set<T> set) {\n         return new SynchronizedSet<T>(set);\n     }\n     \n--- a/src/java/org/apache/commons/collections/set/SynchronizedSortedSet.java\n+++ b/src/java/org/apache/commons/collections/set/SynchronizedSortedSet.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <T> SortedSet<T> decorate(SortedSet<T> set) {\n+    public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> set) {\n         return new SynchronizedSortedSet<T>(set);\n     }\n \n--- a/src/java/org/apache/commons/collections/set/TransformedSet.java\n+++ b/src/java/org/apache/commons/collections/set/TransformedSet.java\n      * <p>\n      * If there are any elements already in the set being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n      * \n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static <E> Set<E> decorate(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Set<E> transformingSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSet<E>(set, transformer);\n     }\n     \n      * <p>\n      * If there are any elements already in the set being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n      * \n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> Set<E> decorateTransform(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Set<E> transformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n         TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n--- a/src/java/org/apache/commons/collections/set/TransformedSortedSet.java\n+++ b/src/java/org/apache/commons/collections/set/TransformedSortedSet.java\n      * <p>\n      * If there are any elements already in the set being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n+     * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n      * \n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static <E> SortedSet<E> decorate(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> SortedSet<E> transformingSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedSet<E>(set, transformer);\n     }\n     \n      * <p>\n      * If there are any elements already in the set being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n+     * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n      * \n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      * @since Commons Collections 3.3\n      */\n-    public static <E> SortedSet<E> decorateTransform(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> SortedSet<E> transformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n         TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n--- a/src/java/org/apache/commons/collections/set/UnmodifiableSet.java\n+++ b/src/java/org/apache/commons/collections/set/UnmodifiableSet.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> Set<E> decorate(Set<E> set) {\n+    public static <E> Set<E> unmodifiableSet(Set<E> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.<E>decorate(decorated().iterator());\n+        return UnmodifiableIterator.<E>unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/set/UnmodifiableSortedSet.java\n+++ b/src/java/org/apache/commons/collections/set/UnmodifiableSortedSet.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <T> SortedSet<T> decorate(SortedSet<T> set) {\n+    public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n     //-----------------------------------------------------------------------\n     @Override\n     public Iterator<E> iterator() {\n-        return UnmodifiableIterator.decorate(decorated().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n     }\n \n     @Override\n--- a/src/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n+++ b/src/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n  * {@link IterableGet} that uses a {@link Map}<K, V> for the {@link Get}<K, V>\n  * implementation.\n  *\n- * @since Commons Collections 5\n- * @TODO fix version\n+ * @since Commons Collections 4.0\n  * @version $Revision$ $Date$\n  *\n  * @author Matt Benson\n--- a/src/java/org/apache/commons/collections/splitmap/SplitMapUtils.java\n+++ b/src/java/org/apache/commons/collections/splitmap/SplitMapUtils.java\n  * Utilities for working with \"split maps:\" objects that implement {@link Put}\n  * and/or {@link Get} but not {@link Map}.\n  *\n- * @since Commons Collections 5\n- * @TODO fix version\n+ * @since Commons Collections 4.0\n  * @version $Revision$ $Date$\n  * @see Get\n  * @see Put\n     }\n \n     private static class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n-        private Get<K, V> get;\n+        private final Get<K, V> get;\n \n         private WrappedGet(Get<K, V> get) {\n             this.get = get;\n         }\n \n         public Set<java.util.Map.Entry<K, V>> entrySet() {\n-            return UnmodifiableEntrySet.decorate(get.entrySet());\n+            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n         }\n \n         @Override\n         }\n \n         public Set<K> keySet() {\n-            return UnmodifiableSet.decorate(get.keySet());\n+            return UnmodifiableSet.unmodifiableSet(get.keySet());\n         }\n \n         public V put(K key, V value) {\n         }\n \n         public Collection<V> values() {\n-            return UnmodifiableCollection.decorate(get.values());\n+            return UnmodifiableCollection.unmodifiableCollection(get.values());\n         }\n \n         public MapIterator<K, V> mapIterator() {\n             } else {\n                 it = new EntrySetToMapIteratorAdapter<K, V>(get.entrySet());\n             }\n-            return UnmodifiableMapIterator.decorate(it);\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n         }\n     }\n \n     private static class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n-        private Put<K, V> put;\n+        private final Put<K, V> put;\n \n         private WrappedPut(Put<K, V> put) {\n             this.put = put;\n--- a/src/java/org/apache/commons/collections/splitmap/TransformedMap.java\n+++ b/src/java/org/apache/commons/collections/splitmap/TransformedMap.java\n  * In practice this would often mean <code>&gt;Object, Object&gt;</code>, defeating\n  * much of the usefulness of having parameterized types.\n  * <p>\n- * On the downside, this class is not a drop-in replacement for {@link java.util.Map}\n+ * On the downside, this class is not drop-in compatible with {@link java.util.Map}\n  * but is intended to be worked with either directly or by {@link Put} and {@link Get}\n  * generalizations.\n  *\n- * @since Commons Collections 5\n- * @TODO fix version\n+ * @since Commons Collections 4.0\n  * @version $Revision$ $Date$\n+ * @see SplitMapUtils#readableMap(Get)\n+ * @see SplitMapUtils#writableMap(Put)\n  *\n  * @author Stephen Colebourne\n  * @author Matt Benson\n      * means no transformation\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <J, K, U, V> TransformedMap<J, K, U, V> decorate(Map<K, V> map,\n+    public static <J, K, U, V> TransformedMap<J, K, U, V> transformingMap(Map<K, V> map,\n             Transformer<? super J, ? extends K> keyTransformer,\n             Transformer<? super U, ? extends V> valueTransformer) {\n         return new TransformedMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n--- a/src/test/org/apache/commons/collections/TestBagUtils.java\n+++ b/src/test/org/apache/commons/collections/TestBagUtils.java\n     }\n \n      public void testTransformedBag() {\n-        Bag<Object> bag = BagUtils.transformedBag(new HashBag<Object>(), nopTransformer);\n+        Bag<Object> bag = BagUtils.transformingBag(new HashBag<Object>(), nopTransformer);\n         assertTrue(\"Returned object should be an TransformedBag.\",\n             bag instanceof TransformedBag);\n         try {\n-            bag = BagUtils.transformedBag(null, nopTransformer);\n+            bag = BagUtils.transformingBag(null, nopTransformer);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n-            bag = BagUtils.transformedBag(new HashBag<Object>(), null);\n+            bag = BagUtils.transformingBag(new HashBag<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null transformer.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n     }\n \n     public void testTransformedSortedBag() {\n-        Bag<Object> bag = BagUtils.transformedSortedBag(new TreeBag<Object>(), nopTransformer);\n+        Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), nopTransformer);\n         assertTrue(\"Returned object should be an TransformedSortedBag\",\n             bag instanceof TransformedSortedBag);\n         try {\n-            bag = BagUtils.transformedSortedBag(null, nopTransformer);\n+            bag = BagUtils.transformingSortedBag(null, nopTransformer);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n-            bag = BagUtils.transformedSortedBag(new TreeBag<Object>(), null);\n+            bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null transformer.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n--- a/src/test/org/apache/commons/collections/TestCollectionUtils.java\n+++ b/src/test/org/apache/commons/collections/TestCollectionUtils.java\n     @Test\n     public void testTransformedCollection() {\n         Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n-        Collection<Object> collection = CollectionUtils.transformedCollection(new ArrayList<Object>(), transformer);\n+        Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), transformer);\n         assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n         try {\n-            collection = CollectionUtils.transformedCollection(new ArrayList<Object>(), null);\n+            collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null transformer.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n-            collection = CollectionUtils.transformedCollection(null, transformer);\n+            collection = CollectionUtils.transformingCollection(null, transformer);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         list.add(\"1\");\n         list.add(\"2\");\n         list.add(\"3\");\n-        Collection<Object> result = CollectionUtils.transformedCollection(list, TRANSFORM_TO_INTEGER);\n+        Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n         assertEquals(true, result.contains(\"1\")); // untransformed\n         assertEquals(true, result.contains(\"2\")); // untransformed\n         assertEquals(true, result.contains(\"3\")); // untransformed\n--- a/src/test/org/apache/commons/collections/bag/TestPredicatedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestPredicatedBag.java\n     protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n \n     protected Bag<T> decorateBag(HashBag<T> bag, Predicate<T> predicate) {\n-        return PredicatedBag.decorate(bag, predicate);\n+        return PredicatedBag.predicatedBag(bag, predicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/bag/TestPredicatedSortedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestPredicatedSortedBag.java\n     protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n \n     protected SortedBag<T> decorateBag(SortedBag<T> bag, Predicate<T> predicate) {\n-        return PredicatedSortedBag.decorate(bag, predicate);\n+        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/bag/TestTransformedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestTransformedBag.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Bag<T> makeObject() {\n-        return TransformedBag.decorate(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedBag.transformingBag(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n         //T had better be Object!\n-        Bag<T> bag = TransformedBag.decorate(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalBag.add(els[i]);\n         }\n-        Bag bag = TransformedBag.decorateTransform(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Bag bag = TransformedBag.transformedBag(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, bag.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, bag.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/bag/TestTransformedSortedBag.java\n+++ b/src/test/org/apache/commons/collections/bag/TestTransformedSortedBag.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SortedBag<T> makeObject() {\n-        return TransformedSortedBag.decorate(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n-        SortedBag<T> bag = TransformedSortedBag.decorate(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n         Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalBag.add(els[i]);\n         }\n-        Bag<?> bag = TransformedBag.decorateTransform(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Bag<?> bag = TransformedBag.transformedBag(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, bag.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, bag.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap2.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestDualTreeBidiMap2.java\n     @Override\n     public DualTreeBidiMap<K, V> makeObject() {\n         return new DualTreeBidiMap<K, V>(\n-                new ReverseComparator<K>(ComparableComparator.<K> getInstance()),\n-                new ReverseComparator<V>(ComparableComparator.<V> getInstance()));\n+                new ReverseComparator<K>(ComparableComparator.<K> comparableComparator()),\n+                new ReverseComparator<V>(ComparableComparator.<V> comparableComparator()));\n     }\n \n     @Override\n     public TreeMap<K, V> makeConfirmedMap() {\n-        return new TreeMap<K, V>(new ReverseComparator<K>(ComparableComparator.<K>getInstance()));\n+        return new TreeMap<K, V>(new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n     }\n \n     public void testComparator() {\n \n         // Sort by the comparator used in the makeEmptyBidiMap() method\n         List<K> newSortedKeys = getAsList(getSampleKeys());\n-        Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>getInstance()));\n+        Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n         newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n \n         Iterator<K> mapIter = sm.keySet().iterator();\n--- a/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableBidiMap.java\n \n     @Override\n     public BidiMap<K, V> makeObject() {\n-        return UnmodifiableBidiMap.decorate(new DualHashBidiMap<K, V>());\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<K, V>());\n     }\n \n     @Override\n     public BidiMap<K, V> makeFullMap() {\n         BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n         addSampleMappings(bidi);\n-        return UnmodifiableBidiMap.decorate(bidi);\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableOrderedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableOrderedBidiMap.java\n \n     @Override\n     public OrderedBidiMap<K, V> makeObject() {\n-        return UnmodifiableOrderedBidiMap.decorate(new TreeBidiMap<K, V>());\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<K, V>());\n     }\n \n     @Override\n     public BidiMap<K, V> makeFullMap() {\n         OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n         addSampleMappings(bidi);\n-        return UnmodifiableOrderedBidiMap.decorate(bidi);\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableSortedBidiMap.java\n+++ b/src/test/org/apache/commons/collections/bidimap/TestUnmodifiableSortedBidiMap.java\n     //-----------------------------------------------------------------------\n     @Override\n     public SortedBidiMap<K, V> makeObject() {\n-        return UnmodifiableSortedBidiMap.decorate(new DualTreeBidiMap<K, V>());\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<K, V>());\n     }\n \n     @Override\n     public SortedBidiMap<K, V> makeFullMap() {\n         SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n         addSampleMappings(bidi);\n-        return UnmodifiableSortedBidiMap.decorate(bidi);\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n \n     @Override\n     public Buffer<E> makeObject() {\n-        return BlockingBuffer.decorate(new MyBuffer<E>());\n+        return BlockingBuffer.blockingBuffer(new MyBuffer<E>());\n     }\n \n     @Override\n     }\n \n     public void testGetWithAddTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 500);\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n         E obj = makeElement();\n         new DelayedAdd<E>(blockingBuffer, obj, 100).start();\n \n     }\n \n     public void testGetWithAddAllTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 500);\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n         E obj = makeElement();\n         new DelayedAddAll<E>(blockingBuffer, obj, 100).start();\n \n     }\n \n     public void testRemoveWithAddTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 100);\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n         E obj = makeElement();\n         new DelayedAdd<E>(blockingBuffer, obj, 500).start();\n         try {\n     }\n \n     public void testRemoveWithAddAllTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.decorate(new MyBuffer<E>(), 100);\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n         E obj = makeElement();\n         new DelayedAddAll<E>(blockingBuffer, obj, 500).start();\n         try {\n--- a/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n \n     @Override\n     public Buffer<E> makeObject() {\n-        return BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 1);\n+        return BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testMaxSize() {\n-        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 2, 500);\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n         BoundedCollection<?> bc = (BoundedCollection<?>) bounded;\n         assertEquals(2, bc.maxSize());\n         assertEquals(false, bc.isFull());\n         bounded.remove();\n         assertEquals(false, bc.isFull());\n         try {\n-            BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 0);\n+            BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 0);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n         try {\n-            BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), -1);\n+            BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), -1);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testAddToFullBufferRemoveViaIterator() {\n-        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 1, 500);\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1, 500);\n         bounded.add((E) \"Hello\");\n         new DelayedIteratorRemove(bounded, 200).start();\n         bounded.add((E) \"World\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testAddAllToFullBufferRemoveViaIterator() {\n-        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 2, 500);\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n         bounded.add((E) \"Hello\");\n         bounded.add((E) \"World\");\n         new DelayedIteratorRemove(bounded, 200, 2).start();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testAddToFullBufferWithTimeout() {\n-        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 1, 500);\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1, 500);\n         bounded.add((E) \"Hello\");\n         new DelayedRemove(bounded, 200).start();\n         bounded.add((E) \"World\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testAddAllToFullBufferWithTimeout() {\n-        final Buffer<E> bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer<E>(), 2, 500);\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n         bounded.add((E) \"Hello\");\n         bounded.add((E) \"World\");\n         new DelayedRemove(bounded, 200, 2).start();\n--- a/src/test/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n     //---------------------------------------------------------------\n \n     protected Buffer<E> decorateCollection(Buffer<E> buffer, Predicate<E> predicate) {\n-        return PredicatedBuffer.decorate(buffer, predicate);\n+        return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n     //-----------------------------------------------------------------------\n     @Override\n     public Buffer<E> makeObject() {\n-        return SynchronizedBuffer.decorate(new UnboundedFifoBuffer<E>());\n+        return SynchronizedBuffer.synchronizedBuffer(new UnboundedFifoBuffer<E>());\n     }\n \n     @Override\n     public Collection<E> makeFullCollection() {\n         Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n         buffer.addAll(Arrays.asList(getFullElements()));\n-        return SynchronizedBuffer.decorate(buffer);\n+        return SynchronizedBuffer.synchronizedBuffer(buffer);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n     }\n \n     public void testTransformedBuffer() {\n-        Buffer<Object> buffer = TransformedBuffer.decorate(new ArrayStack<Object>(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, buffer.size());\n         Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalBuffer.add(els[i]);\n         }\n-        Buffer buffer = TransformedBuffer.decorateTransform(originalBuffer, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, buffer.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, buffer.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n     //-----------------------------------------------------------------------\n     @Override\n     public Collection<E> makeObject() {\n-        return UnmodifiableBuffer.decorate(new UnboundedFifoBuffer<E>());\n+        return UnmodifiableBuffer.unmodifiableBuffer(new UnboundedFifoBuffer<E>());\n     }\n \n     @Override\n     public Collection<E> makeFullCollection() {\n         Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n         buffer.addAll(Arrays.asList(getFullElements()));\n-        return UnmodifiableBuffer.decorate(buffer);\n+        return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/collection/TestPredicatedCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestPredicatedCollection.java\n \n     protected Collection<E> decorateCollection(\n                 Collection<E> collection, Predicate<E> predicate) {\n-        return PredicatedCollection.decorate(collection, predicate);\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/collection/TestSynchronizedCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestSynchronizedCollection.java\n     //-----------------------------------------------------------------------\n     @Override\n     public Collection<E> makeObject() {\n-        return SynchronizedCollection.decorate(new ArrayList<E>());\n+        return SynchronizedCollection.synchronizedCollection(new ArrayList<E>());\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/collection/TestTransformedCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestTransformedCollection.java\n     \n     @Override\n     public Collection<Object> makeObject() {\n-        return TransformedCollection.decorate(new ArrayList<Object>(), NOOP_TRANSFORMER);\n+        return TransformedCollection.transformingCollection(new ArrayList<Object>(), NOOP_TRANSFORMER);\n     }\n \n     @Override\n     public Collection<Object> makeFullCollection() {\n         List<Object> list = new ArrayList<Object>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return TransformedCollection.decorate(list, NOOP_TRANSFORMER);\n+        return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n     }\n     \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     public void testTransformedCollection() {\n-        Collection<Object> coll = TransformedCollection.decorate(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n+        Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, coll.size());\n         Object[] els = getFullElements();\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalCollection.add(els[i]);\n         }\n-        Collection collection = TransformedCollection.decorateTransform(originalCollection, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Collection collection = TransformedCollection.transformedCollection(originalCollection, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, collection.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, collection.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/collection/TestUnmodifiableCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestUnmodifiableCollection.java\n     //-----------------------------------------------------------------------\n     @Override\n     public Collection<E> makeObject() {\n-        return UnmodifiableCollection.decorate(new ArrayList<E>());\n+        return UnmodifiableCollection.unmodifiableCollection(new ArrayList<E>());\n     }\n \n     @Override\n     public Collection<E> makeFullCollection() {\n         List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return UnmodifiableCollection.decorate(list);\n+        return UnmodifiableCollection.unmodifiableCollection(list);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/comparators/TestBooleanComparator.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestBooleanComparator.java\n \n     public void testStaticFactoryMethods() {\n         allTests(false,BooleanComparator.getFalseFirstComparator());\n-        allTests(false,BooleanComparator.getBooleanComparator(false));\n+        allTests(false,BooleanComparator.booleanComparator(false));\n         allTests(true,BooleanComparator.getTrueFirstComparator());\n-        allTests(true,BooleanComparator.getBooleanComparator(true));\n+        allTests(true,BooleanComparator.booleanComparator(true));\n     }\n \n     public void testEqualsCompatibleInstance() {\n         assertEquals(new BooleanComparator(),new BooleanComparator(false));\n         assertEquals(new BooleanComparator(false),new BooleanComparator(false));\n         assertEquals(new BooleanComparator(false),BooleanComparator.getFalseFirstComparator());\n-        assertSame(BooleanComparator.getFalseFirstComparator(),BooleanComparator.getBooleanComparator(false));\n+        assertSame(BooleanComparator.getFalseFirstComparator(),BooleanComparator.booleanComparator(false));\n \n         assertEquals(new BooleanComparator(true),new BooleanComparator(true));\n         assertEquals(new BooleanComparator(true),BooleanComparator.getTrueFirstComparator());\n-        assertSame(BooleanComparator.getTrueFirstComparator(),BooleanComparator.getBooleanComparator(true));\n+        assertSame(BooleanComparator.getTrueFirstComparator(),BooleanComparator.booleanComparator(true));\n \n         assertTrue(!(new BooleanComparator().equals(new BooleanComparator(true))));\n         assertTrue(!(new BooleanComparator(true).equals(new BooleanComparator(false))));\n--- a/src/test/org/apache/commons/collections/functors/TestComparatorPredicate.java\n+++ b/src/test/org/apache/commons/collections/functors/TestComparatorPredicate.java\n     @Test\n     public void compareEquals() {\n         Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = getInstance(value, new TestComparator<Integer>());\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n         assertFalse(p, Integer.valueOf(value.intValue() - 1));\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertFalse(p, Integer.valueOf(value.intValue() + 1));\n     @Test\n     public void compareGreater() {\n         Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = getInstance(value, new TestComparator<Integer>(), Criterion.GREATER);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n         assertTrue(p, Integer.valueOf(value.intValue() - 1));\n         assertFalse(p, Integer.valueOf(value.intValue()));\n         assertFalse(p, Integer.valueOf(value.intValue() + 1));\n     @Test\n     public void compareLess() {\n         Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = getInstance(value, new TestComparator<Integer>(), Criterion.LESS);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n         assertFalse(p, Integer.valueOf(value.intValue() - 1));\n         assertFalse(p, Integer.valueOf(value.intValue()));\n         assertTrue(p, Integer.valueOf(value.intValue() + 1));\n     @Test\n     public void compareGreaterOrEqual() {\n         Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = getInstance(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n         assertTrue(p, Integer.valueOf(value.intValue() - 1));\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertFalse(p, Integer.valueOf(value.intValue() + 1));\n     @Test\n     public void compareLessOrEqual() {\n         Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = getInstance(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n         assertFalse(p, Integer.valueOf(value.intValue() - 1));\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertTrue(p, Integer.valueOf(value.intValue() + 1));\n     \n     @Override\n     protected Predicate<?> generatePredicate() {\n-        return getInstance(Integer.valueOf(10), new TestComparator<Integer>());\n+        return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());\n     }    \n }\n--- a/src/test/org/apache/commons/collections/iterators/TestFilterIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestFilterIterator.java\n         assertEquals(true, filterIterator.hasNext());\n \n         // this predicate doesn't match\n-        filterIterator.setPredicate(NotNullPredicate.getInstance());\n+        filterIterator.setPredicate(NotNullPredicate.notNullPredicate());\n         assertEquals(false, filterIterator.hasNext());\n     }\n \n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableIterator.java\n \n     @Override\n     public Iterator<E> makeEmptyIterator() {\n-        return UnmodifiableIterator.decorate(Collections.<E>emptyList().iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(Collections.<E>emptyList().iterator());\n     }\n \n     @Override\n     public Iterator<E> makeObject() {\n-        return UnmodifiableIterator.decorate(testList.iterator());\n+        return UnmodifiableIterator.unmodifiableIterator(testList.iterator());\n     }\n \n     @Override\n \n     public void testDecorateFactory() {\n         Iterator<E> it = makeObject();\n-        assertSame(it, UnmodifiableIterator.decorate(it));\n+        assertSame(it, UnmodifiableIterator.unmodifiableIterator(it));\n \n         it = testList.iterator();\n-        assertTrue(it != UnmodifiableIterator.decorate(it));\n+        assertTrue(it != UnmodifiableIterator.unmodifiableIterator(it));\n \n         try {\n-            UnmodifiableIterator.decorate(null);\n+            UnmodifiableIterator.unmodifiableIterator(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableListIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableListIterator.java\n \n     @Override\n     public ListIterator<E> makeEmptyIterator() {\n-        return UnmodifiableListIterator.decorate(Collections.<E>emptyList().listIterator());\n+        return UnmodifiableListIterator.umodifiableListIterator(Collections.<E>emptyList().listIterator());\n     }\n \n     @Override\n     public ListIterator<E> makeObject() {\n-        return UnmodifiableListIterator.decorate(testList.listIterator());\n+        return UnmodifiableListIterator.umodifiableListIterator(testList.listIterator());\n     }\n \n     @Override\n \n     public void testDecorateFactory() {\n         ListIterator<E> it = makeObject();\n-        assertSame(it, UnmodifiableListIterator.decorate(it));\n+        assertSame(it, UnmodifiableListIterator.umodifiableListIterator(it));\n \n         it = testList.listIterator();\n-        assertTrue(it != UnmodifiableListIterator.decorate(it));\n+        assertTrue(it != UnmodifiableListIterator.umodifiableListIterator(it));\n \n         try {\n-            UnmodifiableListIterator.decorate(null);\n+            UnmodifiableListIterator.umodifiableListIterator(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n \n     @Override\n     public MapIterator<K, V> makeEmptyIterator() {\n-        return UnmodifiableMapIterator.decorate(new DualHashBidiMap<K, V>().mapIterator());\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(new DualHashBidiMap<K, V>().mapIterator());\n     }\n \n     @Override\n     public MapIterator<K, V> makeObject() {\n-        return UnmodifiableMapIterator.decorate(getMap().mapIterator());\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(getMap().mapIterator());\n     }\n \n     @Override\n \n     public void testDecorateFactory() {\n         MapIterator<K, V> it = makeObject();\n-        assertSame(it, UnmodifiableMapIterator.decorate(it));\n+        assertSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));\n \n         it = getMap().mapIterator() ;\n-        assertTrue(it != UnmodifiableMapIterator.decorate(it));\n+        assertTrue(it != UnmodifiableMapIterator.unmodifiableMapIterator(it));\n \n         try {\n-            UnmodifiableMapIterator.decorate(null);\n+            UnmodifiableMapIterator.unmodifiableMapIterator(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/iterators/TestUnmodifiableOrderedMapIterator.java\n+++ b/src/test/org/apache/commons/collections/iterators/TestUnmodifiableOrderedMapIterator.java\n \n     @Override\n     public OrderedMapIterator<K, V> makeEmptyIterator() {\n-        return UnmodifiableOrderedMapIterator.decorate(\n-                ListOrderedMap.decorate(new HashMap<K, V>()).mapIterator());\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(\n+                ListOrderedMap.listOrderedMap(new HashMap<K, V>()).mapIterator());\n     }\n \n     @Override\n     public OrderedMapIterator<K, V> makeObject() {\n-        return UnmodifiableOrderedMapIterator.decorate(getMap().mapIterator());\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(getMap().mapIterator());\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public OrderedMap<K, V> getMap() {\n-        OrderedMap<K, V> testMap = ListOrderedMap.decorate(new HashMap<K, V>());\n+        OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n         testMap.put((K) \"A\", (V) \"a\");\n         testMap.put((K) \"B\", (V) \"b\");\n         testMap.put((K) \"C\", (V) \"c\");\n \n     public void testDecorateFactory() {\n         OrderedMapIterator<K, V> it = makeObject();\n-        assertSame(it, UnmodifiableOrderedMapIterator.decorate(it));\n+        assertSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n \n         it = getMap().mapIterator() ;\n-        assertTrue(it != UnmodifiableOrderedMapIterator.decorate(it));\n+        assertTrue(it != UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n \n         try {\n-            UnmodifiableOrderedMapIterator.decorate(null);\n+            UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/list/TestFixedSizeList.java\n+++ b/src/test/org/apache/commons/collections/list/TestFixedSizeList.java\n \n     @Override\n     public List<E> makeObject() {\n-        return FixedSizeList.decorate(new ArrayList<E>());\n+        return FixedSizeList.fixedSizeList(new ArrayList<E>());\n     }\n \n     @Override\n     public List<E> makeFullCollection() {\n         List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return FixedSizeList.decorate(list);\n+        return FixedSizeList.fixedSizeList(list);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/list/TestGrowthList.java\n+++ b/src/test/org/apache/commons/collections/list/TestGrowthList.java\n     public List<E> makeFullCollection() {\n         List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return GrowthList.decorate(list);\n+        return GrowthList.growthList(list);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/org/apache/commons/collections/list/TestPredicatedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestPredicatedList.java\n     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n \n     protected List<E> decorateList(List<E> list, Predicate<E> predicate) {\n-        return PredicatedList.decorate(list, predicate);\n+        return PredicatedList.predicatedList(list, predicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/list/TestSetUniqueList.java\n+++ b/src/test/org/apache/commons/collections/list/TestSetUniqueList.java\n     public void testFactory() {\n         Integer[] array = new Integer[] { new Integer(1), new Integer(2), new Integer(1) };\n         ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(array));\n-        final SetUniqueList<Integer> lset = SetUniqueList.decorate(list);\n+        final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);\n \n         assertEquals(\"Duplicate element was added.\", 2, lset.size());\n         assertEquals(new Integer(1), lset.get(0));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testUniqueListReInsert() {\n-        List<E> l = SetUniqueList.decorate(new LinkedList<E>());\n+        List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n         l.add((E) new Object());\n         l.add((E) new Object());\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testUniqueListDoubleInsert() {\n-        List<E> l = SetUniqueList.decorate(new LinkedList<E>());\n+        List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n         l.add((E) new Object());\n         l.add((E) new Object());\n \n     // TODO: Generics\n     public void testCollections304() {\n         List list = new LinkedList();\n-        SetUniqueList decoratedList = SetUniqueList.decorate(list);\n+        SetUniqueList decoratedList = SetUniqueList.setUniqueList(list);\n         String s1 = \"Apple\";\n         String s2 = \"Lemon\";\n         String s3 = \"Orange\";\n     @SuppressWarnings(\"unchecked\")\n     public void testCollections307() {\n         List<E> list = new ArrayList<E>();\n-        List<E> uniqueList = SetUniqueList.decorate(list);\n+        List<E> uniqueList = SetUniqueList.setUniqueList(list);\n \n         String hello = \"Hello\";\n         String world = \"World\";\n--- a/src/test/org/apache/commons/collections/list/TestSynchronizedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestSynchronizedList.java\n \n     @Override\n     public List<E> makeObject() {\n-        return SynchronizedList.decorate(new ArrayList<E>());\n+        return SynchronizedList.synchronizedList(new ArrayList<E>());\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/list/TestTransformedList.java\n+++ b/src/test/org/apache/commons/collections/list/TestTransformedList.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public List<E> makeObject() {\n-        return TransformedList.decorate(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     @Override\n     public List<E> makeFullCollection() {\n         List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return TransformedList.decorate(list, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedList.transformingList(list, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedList() {\n-        List<E> list = TransformedList.decorate(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, list.size());\n         E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n         for (int i = 0; i < els.length; i++) {\n             originalList.add(els[i]);\n         }\n-        List list = TransformedList.decorateTransform(originalList, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        List list = TransformedList.transformedList(originalList, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, list.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, list.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/map/TestDefaultedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestDefaultedMap.java\n     //-----------------------------------------------------------------------\n     @Override\n     public IterableMap<K, V> makeObject() {\n-        return DefaultedMap.decorate(new HashMap<K, V>(), nullFactory);\n+        return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet2() {\n         HashMap<K, V> base = new HashMap<K, V>();\n-        Map<K, V> map = DefaultedMap.decorate(base, (V) \"NULL\");\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n \n         assertEquals(0, map.size());\n         assertEquals(0, base.size());\n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet3() {\n         HashMap<K, V> base = new HashMap<K, V>();\n-        Map<K, V> map = DefaultedMap.decorate(base, ConstantFactory.getInstance((V) \"NULL\"));\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n \n         assertEquals(0, map.size());\n         assertEquals(0, base.size());\n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet4() {\n         HashMap<K, V> base = new HashMap<K, V>();\n-        Map<K, V> map = DefaultedMap.decorate(base, new Transformer<K, V>() {\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, new Transformer<K, V>() {\n             public V transform(K input) {\n                 if (input instanceof String) {\n                     return (V) \"NULL\";\n--- a/src/test/org/apache/commons/collections/map/TestFixedSizeMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestFixedSizeMap.java\n \n     @Override\n     public IterableMap<K, V> makeObject() {\n-        return FixedSizeMap.decorate(new HashMap<K, V>());\n+        return FixedSizeMap.fixedSizeMap(new HashMap<K, V>());\n     }\n \n     @Override\n     public IterableMap<K, V> makeFullMap() {\n         Map<K, V> map = new HashMap<K, V>();\n         addSampleMappings(map);\n-        return FixedSizeMap.decorate(map);\n+        return FixedSizeMap.fixedSizeMap(map);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/map/TestFixedSizeSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestFixedSizeSortedMap.java\n     //-----------------------------------------------------------------------\n     @Override\n     public SortedMap<K, V> makeObject() {\n-        return FixedSizeSortedMap.decorate(new TreeMap<K, V>());\n+        return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<K, V>());\n     }\n \n     @Override\n     public SortedMap<K, V> makeFullMap() {\n         SortedMap<K, V> map = new TreeMap<K, V>();\n         addSampleMappings(map);\n-        return FixedSizeSortedMap.decorate(map);\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/map/TestLazyMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLazyMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import static org.apache.commons.collections.map.LazyMap.getLazyMap;\n+import static org.apache.commons.collections.map.LazyMap.lazyMap;\n \n import java.util.HashMap;\n import java.util.Map;\n \n     @Override\n     public LazyMap<K,V> makeObject() {\n-        return getLazyMap(new HashMap<K,V>(), FactoryUtils.<V>nullFactory());\n+        return lazyMap(new HashMap<K,V>(), FactoryUtils.<V>nullFactory());\n     }\n \n     //-----------------------------------------------------------------------\n \n     @Test\n     public void mapGetWithFactory() {\n-        Map<Integer, Number> map = getLazyMap(new HashMap<Integer,Number>(), oneFactory);\n+        Map<Integer, Number> map = lazyMap(new HashMap<Integer,Number>(), oneFactory);\n         assertEquals(0, map.size());\n         Number i1 = map.get(\"Five\");\n         assertEquals(1, i1);\n         assertEquals(1, map.size());\n         assertSame(i1, i2);\n \n-        map = getLazyMap(new HashMap<Integer,Number>(), FactoryUtils.<Long>nullFactory());\n+        map = lazyMap(new HashMap<Integer,Number>(), FactoryUtils.<Long>nullFactory());\n         Object o = map.get(\"Five\");\n         assertEquals(null,o);\n         assertEquals(1, map.size());\n                 return input.intValue();\n             }\n         };\n-        Map<Long, Number> map = getLazyMap(new HashMap<Long,Number>(), intConverter );\n+        Map<Long, Number> map = lazyMap(new HashMap<Long,Number>(), intConverter );\n         assertEquals(0, map.size());\n         Number i1 = map.get(123L);\n         assertEquals(123, i1);\n--- a/src/test/org/apache/commons/collections/map/TestLazySortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLazySortedMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import static org.apache.commons.collections.map.LazySortedMap.getLazySortedMap;\n+import static org.apache.commons.collections.map.LazySortedMap.lazySortedMap;\n \n import java.util.Comparator;\n import java.util.Map;\n     \n     @Override\n     public SortedMap<K,V> makeObject() {\n-        return getLazySortedMap(new TreeMap<K,V>(), FactoryUtils.<V>nullFactory());\n+        return lazySortedMap(new TreeMap<K,V>(), FactoryUtils.<V>nullFactory());\n     }\n     \n     @Override\n     \n     @Test\n     public void mapGet() {\n-        Map<Integer, Number> map = getLazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n+        Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n         assertEquals(0, map.size());\n         Number i1 = map.get(5);\n         assertEquals(1, i1);\n         assertEquals(1, map.size());\n \n-        map = getLazySortedMap(new TreeMap<Integer,Number>(), FactoryUtils.<Number>nullFactory());\n+        map = lazySortedMap(new TreeMap<Integer,Number>(), FactoryUtils.<Number>nullFactory());\n         Number o = map.get(5);\n         assertEquals(null,o);\n         assertEquals(1, map.size());\n     \n     //-----------------------------------------------------------------------\n     public void testSortOrder() {\n-        SortedMap<String, Number> map = getLazySortedMap(new TreeMap<String,Number>(), oneFactory);\n+        SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n         map.put(\"A\",  5);\n         map.get(\"B\"); // Entry with value \"One\" created\n         map.put(\"C\", 8);\n     \n     public void testTransformerDecorate() {\n         Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n-        SortedMap<Integer, Number> map = getLazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n+        SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n         assertTrue(map instanceof LazySortedMap);  \n          try {\n-            map = getLazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n+            map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n             fail(\"Expecting IllegalArgumentException for null transformer\");\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n         try {\n-            map = getLazySortedMap((SortedMap<Integer,Number>) null, transformer);\n+            map = lazySortedMap((SortedMap<Integer,Number>) null, transformer);\n             fail(\"Expecting IllegalArgumentException for null map\");\n         } catch (IllegalArgumentException e) {\n             // expected\n--- a/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestListOrderedMap.java\n \n     @Override\n     public ListOrderedMap<K, V> makeObject() {\n-        return (ListOrderedMap<K, V>) ListOrderedMap.decorate(new HashMap<K, V>());\n+        return (ListOrderedMap<K, V>) ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n     }\n \n     /**\n--- a/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testLRUMultiKeyMap() {\n-        MultiKeyMap<K, V> map = MultiKeyMap.decorate(new LRUMap<MultiKey<? extends K>, V>(2));\n+        MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));\n         map.put((K) I1, (K) I2, (V) \"1-2\");\n         map.put((K) I1, (K) I3, (V) \"1-1\");\n         assertEquals(2, map.size());\n--- a/src/test/org/apache/commons/collections/map/TestMultiValueMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestMultiValueMap.java\n \n     @SuppressWarnings(\"unchecked\")\n     private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(Class<C> collectionClass) {\n-        final MultiValueMap<K, V> map = MultiValueMap.decorate(new HashMap<K, C>(), collectionClass);\n+        final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);\n         map.put((K) \"one\", (V) \"uno\");\n         map.put((K) \"one\", (V) \"un\");\n         map.put((K) \"two\", (V) \"dos\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithList() {\n-        MultiValueMap<K, V> test = MultiValueMap.decorate(new HashMap<K, Collection>(), ArrayList.class);\n+        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);\n         assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n         assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n         assertEquals(1, test.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithSet() {\n-        MultiValueMap<K, V> test = MultiValueMap.decorate(new HashMap<K, HashSet>(), HashSet.class);\n+        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);\n         assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n         assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n         assertEquals(null, test.put((K) \"A\", \"a\"));\n--- a/src/test/org/apache/commons/collections/map/TestPredicatedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestPredicatedMap.java\n     //-----------------------------------------------------------------------\n     protected IterableMap<K, V> decorateMap(Map<K, V> map, Predicate<? super K> keyPredicate,\n         Predicate<? super V> valuePredicate) {\n-        return PredicatedMap.decorate(map, keyPredicate, valuePredicate);\n+        return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/map/TestPredicatedSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestPredicatedSortedMap.java\n     //-----------------------------------------------------------------------\n     protected SortedMap<K, V> decorateMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n         Predicate<? super V> valuePredicate) {\n-        return PredicatedSortedMap.decorate(map, keyPredicate, valuePredicate);\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/map/TestSingletonMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestSingletonMap.java\n     public OrderedMap<K, V> makeObject() {\n         // need an empty singleton map, but thats not possible\n         // use a ridiculous fake instead to make the tests pass\n-        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap<K, V>()));\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/map/TestTransformedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestTransformedMap.java\n     //-----------------------------------------------------------------------\n     @Override\n     public IterableMap<K, V> makeObject() {\n-        return TransformedMap.decorate(new HashMap<K, V>(), TransformerUtils.<K> nopTransformer(),\n+        return TransformedMap.transformingMap(new HashMap<K, V>(), TransformerUtils.<K> nopTransformer(),\n                 TransformerUtils.<V> nopTransformer());\n     }\n \n         Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n \n         Map<K, V> map = TransformedMap\n-                .decorate(\n+                .transformingMap(\n                         new HashMap<K, V>(),\n                         (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n                         null);\n         assertEquals(null, map.remove(els[0]));\n         assertEquals(els[0], map.remove(new Integer((String) els[0])));\n \n-        map = TransformedMap.decorate(new HashMap(), null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        map = TransformedMap.transformingMap(new HashMap(), null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, map.size());\n         for (int i = 0; i < els.length; i++) {\n             map.put((K) els[i], (V) els[i]);\n         base.put((K) \"C\", (V) \"3\");\n \n         Map<K, V> trans = TransformedMap\n-                .decorate(\n+                .transformingMap(\n                         base,\n                         null,\n                         (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         base.put((K) \"C\", (V) \"3\");\n \n         Map<K, V> trans = TransformedMap\n-                .decorateTransform(\n+                .transformedMap(\n                         base,\n                         null,\n                         (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n--- a/src/test/org/apache/commons/collections/map/TestTransformedSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestTransformedSortedMap.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SortedMap<K, V> makeObject() {\n-        return TransformedSortedMap.decorate(new TreeMap<K, V>(),\n+        return TransformedSortedMap.transformingSortedMap(new TreeMap<K, V>(),\n                 (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),\n                 (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());\n     }\n         Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n \n         SortedMap<K, V> map = TransformedSortedMap\n-                .decorate(\n+                .transformingSortedMap(\n                         new TreeMap<K, V>(),\n                         (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n                         null);\n         assertEquals(els[0], map.remove(new Integer((String) els[0])));\n \n         map = TransformedSortedMap\n-                .decorate(\n+                .transformingSortedMap(\n                         new TreeMap<K, V>(),\n                         null,\n                         (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         base.put((K) \"C\", (V) \"3\");\n \n         SortedMap<K, V> trans = TransformedSortedMap\n-                .decorate(\n+                .transformingSortedMap(\n                         base,\n                         null,\n                         (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         base.put((K) \"C\", (V) \"3\");\n \n         SortedMap<K, V> trans = TransformedSortedMap\n-                .decorateTransform(\n+                .transformedSortedMap(\n                         base,\n                         null,\n                         (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n--- a/src/test/org/apache/commons/collections/map/TestUnmodifiableMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestUnmodifiableMap.java\n \n     @Override\n     public IterableMap<K, V> makeObject() {\n-        return (IterableMap<K, V>) UnmodifiableMap.decorate(new HashMap<K, V>());\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<K, V>());\n     }\n \n     @Override\n     public IterableMap<K, V> makeFullMap() {\n         Map<K, V> m = new HashMap<K, V>();\n         addSampleMappings(m);\n-        return (IterableMap<K, V>) UnmodifiableMap.decorate(m);\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);\n     }\n \n     //-----------------------------------------------------------------------\n \n     public void testDecorateFactory() {\n         Map<K, V> map = makeFullMap();\n-        assertSame(map, UnmodifiableMap.decorate(map));\n+        assertSame(map, UnmodifiableMap.unmodifiableMap(map));\n \n         try {\n-            UnmodifiableMap.decorate(null);\n+            UnmodifiableMap.unmodifiableMap(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/map/TestUnmodifiableOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestUnmodifiableOrderedMap.java\n \n     @Override\n     public OrderedMap<K, V> makeObject() {\n-        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap<K, V>()));\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n     }\n \n     @Override\n \n     @Override\n     public OrderedMap<K, V> makeFullMap() {\n-        OrderedMap<K, V> m = ListOrderedMap.decorate(new HashMap<K, V>());\n+        OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n         addSampleMappings(m);\n-        return UnmodifiableOrderedMap.decorate(m);\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);\n     }\n \n     //-----------------------------------------------------------------------\n \n     public void testDecorateFactory() {\n         OrderedMap<K, V> map = makeFullMap();\n-        assertSame(map, UnmodifiableOrderedMap.decorate(map));\n+        assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));\n \n         try {\n-            UnmodifiableOrderedMap.decorate(null);\n+            UnmodifiableOrderedMap.unmodifiableOrderedMap(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/map/TestUnmodifiableSortedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestUnmodifiableSortedMap.java\n \n     @Override\n     public SortedMap<K, V> makeObject() {\n-        return UnmodifiableSortedMap.decorate(new TreeMap<K, V>());\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<K, V>());\n     }\n \n     @Override\n     public SortedMap<K, V> makeFullMap() {\n         SortedMap<K, V> m = new TreeMap<K, V>();\n         addSampleMappings(m);\n-        return UnmodifiableSortedMap.decorate(m);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n     }\n \n     //-----------------------------------------------------------------------\n \n     public void testDecorateFactory() {\n         SortedMap<K, V> map = makeFullMap();\n-        assertSame(map, UnmodifiableSortedMap.decorate(map));\n+        assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n \n         try {\n-            UnmodifiableSortedMap.decorate(null);\n+            UnmodifiableSortedMap.unmodifiableSortedMap(null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/set/TestListOrderedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestListOrderedSet.java\n \n     @Override\n     public ListOrderedSet<E> makeObject() {\n-        return ListOrderedSet.decorate(new HashSet<E>());\n+        return ListOrderedSet.listOrderedSet(new HashSet<E>());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n \n     public void testDecorator() {\n         try {\n-            ListOrderedSet.decorate((List<E>) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            ListOrderedSet.decorate((Set<E>) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            ListOrderedSet.decorate(null, null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            ListOrderedSet.decorate(new HashSet<E>(), null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        try {\n-            ListOrderedSet.decorate(null, new ArrayList<E>());\n+            ListOrderedSet.listOrderedSet((List<E>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet((Set<E>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet(new HashSet<E>(), null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet(null, new ArrayList<E>());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/src/test/org/apache/commons/collections/set/TestMapBackedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestMapBackedSet.java\n \n     @Override\n     public Set<E> makeObject() {\n-        return MapBackedSet.decorate(new HashedMap<E, Object>());\n+        return MapBackedSet.mapBackedSet(new HashedMap<E, Object>());\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/set/TestMapBackedSet2.java\n+++ b/src/test/org/apache/commons/collections/set/TestMapBackedSet2.java\n \n     @Override\n     public Set<E> makeObject() {\n-        return MapBackedSet.decorate(new LinkedMap<E, Object>());\n+        return MapBackedSet.mapBackedSet(new LinkedMap<E, Object>());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n--- a/src/test/org/apache/commons/collections/set/TestPredicatedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestPredicatedSet.java\n     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n \n     protected PredicatedSet<E> decorateSet(Set<E> set, Predicate<? super E> predicate) {\n-        return (PredicatedSet<E>) PredicatedSet.decorate(set, predicate);\n+        return (PredicatedSet<E>) PredicatedSet.predicatedSet(set, predicate);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/set/TestPredicatedSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestPredicatedSortedSet.java\n \n     @Override\n     public SortedSet<E> makeObject() {\n-        return PredicatedSortedSet.decorate(new TreeSet<E>(), truePredicate);\n+        return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), truePredicate);\n     }\n \n     @Override\n     public SortedSet<E> makeFullCollection() {\n         TreeSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return PredicatedSortedSet.decorate(set, truePredicate);\n+        return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);\n     }\n \n //--------------------------------------------------------------------\n         };\n \n     protected PredicatedSortedSet<E> makeTestSet() {\n-        return (PredicatedSortedSet<E>) PredicatedSortedSet.decorate(new TreeSet<E>(), testPredicate);\n+        return (PredicatedSortedSet<E>) PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), testPredicate);\n     }\n \n     public void testGetSet() {\n--- a/src/test/org/apache/commons/collections/set/TestSynchronizedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestSynchronizedSet.java\n    //-------------------------------------------------------------------\n     @Override\n     public Set<E> makeObject() {\n-        return SynchronizedSet.decorate(new HashSet<E>());\n+        return SynchronizedSet.synchronizedSet(new HashSet<E>());\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/set/TestSynchronizedSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestSynchronizedSortedSet.java\n    //-------------------------------------------------------------------\n     @Override\n     public SortedSet<E> makeObject() {\n-        return SynchronizedSortedSet.decorate(new TreeSet<E>());\n+        return SynchronizedSortedSet.synchronizedSortedSet(new TreeSet<E>());\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/set/TestTransformedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestTransformedSet.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Set<E> makeObject() {\n-        return TransformedSet.decorate(new HashSet<E>(),\n+        return TransformedSet.transformingSet(new HashSet<E>(),\n                 (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     public Set<E> makeFullCollection() {\n         Set<E> list = new HashSet<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n-        return TransformedSet.decorate(list,\n+        return TransformedSet.transformingSet(list,\n                 (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n-        Set<E> set = TransformedSet.decorate(new HashSet<E>(),\n+        Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),\n                 (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n         E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             originalSet.add(els[i]);\n         }\n-        Set<?> set = TransformedSet.decorateTransform(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Set<?> set = TransformedSet.transformedSet(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, set.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, set.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/set/TestTransformedSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestTransformedSortedSet.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SortedSet<E> makeObject() {\n-        return TransformedSortedSet.decorate(new TreeSet<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     @Override\n     public SortedSet<E> makeFullCollection() {\n         SortedSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return TransformedSortedSet.decorate(set, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+        return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n-        SortedSet<E> set = TransformedSortedSet.decorate(new TreeSet<E>(),\n+        SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),\n                 (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n         E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             originalSet.add(els[i]);\n         }\n-        Set<?> set = TransformedSortedSet.decorateTransform(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        Set<?> set = TransformedSortedSet.transformedSet(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, set.size());\n         for (int i = 0; i < els.length; i++) {\n             assertEquals(true, set.contains(new Integer((String) els[i])));\n--- a/src/test/org/apache/commons/collections/set/TestUnmodifiableSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestUnmodifiableSet.java\n     //-------------------------------------------------------------------\n     @Override\n     public Set<E> makeObject() {\n-        return UnmodifiableSet.decorate(new HashSet<E>());\n+        return UnmodifiableSet.unmodifiableSet(new HashSet<E>());\n     }\n \n     @Override\n     public Set<E> makeFullCollection() {\n         HashSet<E> set = new HashSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return UnmodifiableSet.decorate(set);\n+        return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/set/TestUnmodifiableSortedSet.java\n+++ b/src/test/org/apache/commons/collections/set/TestUnmodifiableSortedSet.java\n     //-------------------------------------------------------------------\n     @Override\n     public SortedSet<E> makeObject() {\n-        return UnmodifiableSortedSet.decorate(new TreeSet<E>());\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<E>());\n     }\n \n     @Override\n     public UnmodifiableSortedSet<E> makeFullCollection() {\n         TreeSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n-        return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.decorate(set);\n+        return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);\n     }\n \n     @Override\n--- a/src/test/org/apache/commons/collections/splitmap/TestSplitMapUtils.java\n+++ b/src/test/org/apache/commons/collections/splitmap/TestSplitMapUtils.java\n     protected void setUp() throws Exception {\n         super.setUp();\n         backingMap = new HashMap<String, Integer>();\n-        transformedMap = TransformedMap.decorate(backingMap, NOPTransformer.<String> getInstance(),\n+        transformedMap = TransformedMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n                 stringToInt);\n         for (int i = 0; i < 10; i++) {\n             transformedMap.put(String.valueOf(i), String.valueOf(i));\n--- a/src/test/org/apache/commons/collections/splitmap/TestTransformedMap.java\n+++ b/src/test/org/apache/commons/collections/splitmap/TestTransformedMap.java\n \n     // -----------------------------------------------------------------------\n     public void testTransformedMap() {\n-        TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.decorate(\n+        TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.transformingMap(\n                 new HashMap<String, Class<?>>(), intToString, objectToClass);\n \n         Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n         assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n         assertEquals(--sz, map.size());\n \n-        TransformedMap<String, String, String, Integer> map2 = TransformedMap.decorate(\n-                new HashMap<String, Integer>(), NOPTransformer.<String> getInstance(), stringToInt);\n+        TransformedMap<String, String, String, Integer> map2 = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n         assertEquals(0, map2.size());\n         for (int i = 0; i < 6; i++) {\n             map2.put(String.valueOf(i), String.valueOf(i));\n     // -----------------------------------------------------------------------\n \n     public void testMapIterator() {\n-        TransformedMap<String, String, String, Integer> map = TransformedMap.decorate(\n-                new HashMap<String, Integer>(), NOPTransformer.<String> getInstance(), stringToInt);\n+        TransformedMap<String, String, String, Integer> map = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n         assertEquals(0, map.size());\n         for (int i = 0; i < 6; i++) {\n             map.put(String.valueOf(i), String.valueOf(i));\n     }\n \n     public void testEmptyMap() throws IOException, ClassNotFoundException {\n-        TransformedMap<String, String, String, String> map = TransformedMap.decorate(\n+        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n                 new HashMap<String, String>(),\n-                NOPTransformer.<String>getInstance(),\n-                NOPTransformer.<String>getInstance() );\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n \n         ObjectInputStream in = new ObjectInputStream( new FileInputStream( \"data/test/TransformedMap.emptyCollection.version3.2.obj\" ) );\n         Object readObject = in.readObject();\n     }\n \n     public void testFullMap() throws IOException, ClassNotFoundException {\n-        TransformedMap<String, String, String, String> map = TransformedMap.decorate(\n+        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n                 new HashMap<String, String>(),\n-                NOPTransformer.<String>getInstance(),\n-                NOPTransformer.<String>getInstance() );\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n         map.put( \"a\", \"b\" );\n         map.put( \"c\", \"d\" );\n         map.put( \"e\", \"f\" );", "timestamp": 1311173086, "metainfo": ""}