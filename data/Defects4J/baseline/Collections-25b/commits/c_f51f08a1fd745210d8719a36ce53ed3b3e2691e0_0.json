{"sha": "f51f08a1fd745210d8719a36ce53ed3b3e2691e0", "log": "Added more controlling if methods into Collection test hierarchy - isNullSupported - isFailFastSupported   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestBinaryHeap.java\n+++ b/src/test/org/apache/commons/collections/TestBinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBinaryHeap.java,v 1.7 2002/10/13 12:59:52 scolebourne Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/10/13 12:59:52 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBinaryHeap.java,v 1.8 2003/07/12 15:11:25 scolebourne Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/07/12 15:11:25 $\n  *\n  * ====================================================================\n  *\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections;\n \n import java.util.ArrayList;\n  * Tests the BinaryHeap.\n  * \n  * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n- * @version $Id: TestBinaryHeap.java,v 1.7 2002/10/13 12:59:52 scolebourne Exp $\n+ * @version $Id: TestBinaryHeap.java,v 1.8 2003/07/12 15:11:25 scolebourne Exp $\n  */\n public class TestBinaryHeap extends TestCollection {\n-    \n-  public static Test suite() {\n-    return new TestSuite(TestBinaryHeap.class);\n-  }\n-  \n-  public TestBinaryHeap(String testName) {\n-    super(testName);\n-  }\n-  \n-  /**\n-   * Return a new, empty {@link Object} to used for testing.\n-   */\n-  public Collection makeCollection() {\n-    return new BinaryHeap();\n-  }\n-  \n-\n-  public Collection makeConfirmedCollection() {\n-    return new ArrayList();\n-  }\n-\n-  public Collection makeConfirmedFullCollection() {\n-    ArrayList list = new ArrayList();\n-    list.addAll(Arrays.asList(getFullElements()));\n-    return list;\n-  }\n-\n-  public Object[] getFullElements() {\n-      return getFullNonNullStringElements();\n-  }\n-\n-  public Object[] getOtherElements() {\n-      return getOtherNonNullStringElements();\n-  }\n-\n-  public void testCollectionIteratorFailFast() {\n-  }\n-\n-  public void testBasicOps() {\n-    BinaryHeap heap = new BinaryHeap();\n-    \n-    assertTrue(\"heap should be empty after create\", heap.isEmpty());\n-    \n-    try {\n-      heap.peek();\n-      fail(\"NoSuchElementException should be thrown if peek is called \" +\n-           \"before any elements are inserted\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }\n-    \n-    try {\n-      heap.pop();\n-      fail(\"NoSuchElementException should be thrown if pop is called \" +\n-           \"before any elements are inserted\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }\n-    \n-    heap.insert(\"a\");\n-    heap.insert(\"c\");\n-    heap.insert(\"e\");\n-    heap.insert(\"b\");\n-    heap.insert(\"d\");\n-    heap.insert(\"n\");\n-    heap.insert(\"m\");\n-    heap.insert(\"l\");\n-    heap.insert(\"k\");\n-    heap.insert(\"j\");\n-    heap.insert(\"i\");\n-    heap.insert(\"h\");\n-    heap.insert(\"g\");\n-    heap.insert(\"f\");\n-    \n-    assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n-    \n-    for(int i = 0; i < 14; i++) {\n-      assertEquals(\"peek using default constructor should return \" +\n-                   \"minimum value in the binary heap\", \n-                   String.valueOf((char)('a' + i)), heap.peek());\n-      \n-      assertEquals(\"pop using default constructor should return minimum \" +\n-                   \"value in the binary heap\", \n-                   String.valueOf((char)('a' + i)), heap.pop());\n-      \n-      if(i + 1 < 14) {\n-        assertTrue(\"heap should not be empty before all elements are popped\",\n-                   !heap.isEmpty());\n-      } else {\n-        assertTrue(\"heap should be empty after all elements are popped\", \n-                   heap.isEmpty());\n-      }\n-    }\n-\n-    try {\n-      heap.peek();\n-      fail(\"NoSuchElementException should be thrown if peek is called \" +\n-           \"after all elements are popped\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }\n-    \n-    try {\n-      heap.pop();\n-      fail(\"NoSuchElementException should be thrown if pop is called \" +\n-           \"after all elements are popped\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }     \n-  }\n-  \n-  public void testBasicComparatorOps() {\n-    BinaryHeap heap = \n-      new BinaryHeap(new ReverseComparator(new ComparableComparator()));\n-    \n-    assertTrue(\"heap should be empty after create\", heap.isEmpty());\n-    \n-    try {\n-      heap.peek();\n-      fail(\"NoSuchElementException should be thrown if peek is called \" +\n-           \"before any elements are inserted\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }\n-    \n-    try {\n-      heap.pop();\n-      fail(\"NoSuchElementException should be thrown if pop is called \" +\n-           \"before any elements are inserted\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }\n-    \n-    heap.insert(\"a\");\n-    heap.insert(\"c\");\n-    heap.insert(\"e\");\n-    heap.insert(\"b\");\n-    heap.insert(\"d\");\n-    heap.insert(\"n\");\n-    heap.insert(\"m\");\n-    heap.insert(\"l\");\n-    heap.insert(\"k\");\n-    heap.insert(\"j\");\n-    heap.insert(\"i\");\n-    heap.insert(\"h\");\n-    heap.insert(\"g\");\n-    heap.insert(\"f\");\n-    \n-    assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n-    \n-    for(int i = 0; i < 14; i++) {\n-\n-      // note: since we're using a comparator that reverses items, the\n-      // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n-\n-      assertEquals(\"peek using default constructor should return \" +\n-                   \"minimum value in the binary heap\", \n-                   String.valueOf((char)('n' - i)), heap.peek());\n-      \n-      assertEquals(\"pop using default constructor should return minimum \" +\n-                   \"value in the binary heap\", \n-                   String.valueOf((char)('n' - i)), heap.pop());\n-      \n-      if(i + 1 < 14) {\n-        assertTrue(\"heap should not be empty before all elements are popped\",\n-                   !heap.isEmpty());\n-      } else {\n-        assertTrue(\"heap should be empty after all elements are popped\", \n-                   heap.isEmpty());\n-      }\n-    }\n-\n-    try {\n-      heap.peek();\n-      fail(\"NoSuchElementException should be thrown if peek is called \" +\n-           \"after all elements are popped\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }\n-    \n-    try {\n-      heap.pop();\n-      fail(\"NoSuchElementException should be thrown if pop is called \" +\n-           \"after all elements are popped\");\n-    } catch (NoSuchElementException e) {\n-      // expected\n-    }     \n-  }\n-\n-\n-  public void verify() {\n-      super.verify();\n-      BinaryHeap heap = (BinaryHeap)collection;\n-\n-      Comparator c = heap.m_comparator;\n-      if (c == null) c = ComparatorUtils.naturalComparator();\n-      if (!heap.m_isMinHeap) c = ComparatorUtils.reversedComparator(c);\n-\n-      Object[] tree = heap.m_elements;\n-      for (int i = 1; i <= heap.m_size; i++) {\n-          Object parent = tree[i];\n-          if (i * 2 <= heap.m_size) {\n-              assertTrue(\"Parent is less than or equal to its left child\", \n-                c.compare(parent, tree[i * 2]) <= 0);\n-          }\n-          if (i * 2 + 1 < heap.m_size) {\n-              assertTrue(\"Parent is less than or equal to its right child\", \n-                c.compare(parent, tree[i * 2 + 1]) <= 0);\n-          }\n-      }\n-  }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestBinaryHeap.class);\n+    }\n+\n+    public TestBinaryHeap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    protected void verify() {\n+        super.verify();\n+        BinaryHeap heap = (BinaryHeap) collection;\n+\n+        Comparator c = heap.m_comparator;\n+        if (c == null)\n+            c = ComparatorUtils.naturalComparator();\n+        if (!heap.m_isMinHeap)\n+            c = ComparatorUtils.reversedComparator(c);\n+\n+        Object[] tree = heap.m_elements;\n+        for (int i = 1; i <= heap.m_size; i++) {\n+            Object parent = tree[i];\n+            if (i * 2 <= heap.m_size) {\n+                assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n+            }\n+            if (i * 2 + 1 < heap.m_size) {\n+                assertTrue(\"Parent is less than or equal to its right child\", c.compare(parent, tree[i * 2 + 1]) <= 0);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    protected boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    protected Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    protected Collection makeConfirmedFullCollection() {\n+        ArrayList list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Return a new, empty {@link Object} to used for testing.\n+     */\n+    protected Collection makeCollection() {\n+        return new BinaryHeap();\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    protected Object[] getFullElements() {\n+        return getFullNonNullStringElements();\n+    }\n+\n+    protected Object[] getOtherElements() {\n+        return getOtherNonNullStringElements();\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public void testBasicOps() {\n+        BinaryHeap heap = new BinaryHeap();\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        heap.insert(\"a\");\n+        heap.insert(\"c\");\n+        heap.insert(\"e\");\n+        heap.insert(\"b\");\n+        heap.insert(\"d\");\n+        heap.insert(\"n\");\n+        heap.insert(\"m\");\n+        heap.insert(\"l\");\n+        heap.insert(\"k\");\n+        heap.insert(\"j\");\n+        heap.insert(\"i\");\n+        heap.insert(\"h\");\n+        heap.insert(\"g\");\n+        heap.insert(\"f\");\n+\n+        assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+            assertEquals(\n+                \"peek using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.peek());\n+\n+            assertEquals(\n+                \"pop using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.pop());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are popped\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are popped\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testBasicComparatorOps() {\n+        BinaryHeap heap = new BinaryHeap(new ReverseComparator(new ComparableComparator()));\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        heap.insert(\"a\");\n+        heap.insert(\"c\");\n+        heap.insert(\"e\");\n+        heap.insert(\"b\");\n+        heap.insert(\"d\");\n+        heap.insert(\"n\");\n+        heap.insert(\"m\");\n+        heap.insert(\"l\");\n+        heap.insert(\"k\");\n+        heap.insert(\"j\");\n+        heap.insert(\"i\");\n+        heap.insert(\"h\");\n+        heap.insert(\"g\");\n+        heap.insert(\"f\");\n+\n+        assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+\n+            // note: since we're using a comparator that reverses items, the\n+            // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n+\n+            assertEquals(\n+                \"peek using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.peek());\n+\n+            assertEquals(\n+                \"pop using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.pop());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are popped\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are popped\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n }\n-\n--- a/src/test/org/apache/commons/collections/TestBoundedFifoBuffer.java\n+++ b/src/test/org/apache/commons/collections/TestBoundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBoundedFifoBuffer.java,v 1.5 2003/04/26 15:12:28 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBoundedFifoBuffer.java,v 1.6 2003/07/12 15:11:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n         return BulkTest.makeSuite(TestBoundedFifoBuffer.class);\n     }\n \n-    /**\n-     *  Returns an empty BoundedFifoBuffer that won't overflow.  \n-     *  \n-     *  @return an empty BoundedFifoBuffer\n-     */\n-    public Collection makeCollection() {\n-        return new BoundedFifoBuffer(100);\n-    }\n-\n-    /**\n-     *  Returns an empty ArrayList.\n-     *\n-     *  @return an empty ArrayList\n-     */\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n-    }\n-\n-    /**\n-     *  Returns a full ArrayList.\n-     *\n-     *  @return a full ArrayList\n-     */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection c = makeConfirmedCollection();\n-        c.addAll(java.util.Arrays.asList(getFullElements()));\n-        return c;\n-    }\n-\n-    /**\n-     *  Overridden because BoundedFifoBuffer doesn't support null elements.\n-     *\n-     *  @return an array of random objects without a null element\n-     */\n-    public Object[] getFullElements() {\n-        return getFullNonNullElements();\n-    }\n-\n-    /**\n-     *  Overridden, because BoundedFifoBuffer's iterators aren't fail-fast.\n-     */\n-    public void testCollectionIteratorFailFast() {\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Runs through the regular verifications, but also verifies that \n      *  the buffer contains the same elements in the same sequence as the\n      *  list.\n      */\n-    public void verify() {\n+    protected void verify() {\n         super.verify();\n         Iterator iterator1 = collection.iterator();\n         Iterator iterator2 = confirmed.iterator();\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    protected boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    protected boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    protected Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty BoundedFifoBuffer that won't overflow.  \n+     *  \n+     *  @return an empty BoundedFifoBuffer\n+     */\n+    protected Collection makeCollection() {\n+        return new BoundedFifoBuffer(100);\n+    }\n+\n+    //-----------------------------------------------------------------------  \n     /**\n      * Tests that the removal operation actually removes the first element.\n      */\n--- a/src/test/org/apache/commons/collections/TestCircularFifoBuffer.java\n+++ b/src/test/org/apache/commons/collections/TestCircularFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCircularFifoBuffer.java,v 1.1 2003/04/26 15:13:22 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCircularFifoBuffer.java,v 1.2 2003/07/12 15:11:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Test cases for CircularFifoBuffer.\n  * \n- * @version $Revision: 1.1 $ $Date: 2003/04/26 15:13:22 $\n+ * @version $Revision: 1.2 $ $Date: 2003/07/12 15:11:25 $\n  * \n  * @author Stephen Colebourne\n  */\n         return BulkTest.makeSuite(TestCircularFifoBuffer.class);\n     }\n \n-    /**\n-     * Returns an empty BoundedFifoBuffer that won't overflow.  \n-     *  \n-     * @return an empty BoundedFifoBuffer\n-     */\n-    public Collection makeCollection() {\n-        return new CircularFifoBuffer(100);\n-    }\n-\n-    /**\n-     * Returns an empty ArrayList.\n-     *\n-     * @return an empty ArrayList\n-     */\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n-    }\n-\n-    /**\n-     * Returns a full ArrayList.\n-     *\n-     * @return a full ArrayList\n-     */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection c = makeConfirmedCollection();\n-        c.addAll(java.util.Arrays.asList(getFullElements()));\n-        return c;\n-    }\n-\n-    /**\n-     *  Overridden because CircularFifoBuffer doesn't support null elements.\n-     *\n-     *  @return an array of random objects without a null element\n-     */\n-    public Object[] getFullElements() {\n-        return getFullNonNullElements();\n-    }\n-\n-    /**\n-     *  Overridden, because CircularFifoBuffer's iterators aren't fail-fast.\n-     */\n-    public void testCollectionIteratorFailFast() {\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Runs through the regular verifications, but also verifies that \n      *  the buffer contains the same elements in the same sequence as the\n      *  list.\n      */\n-    public void verify() {\n+    protected void verify() {\n         super.verify();\n         Iterator iterator1 = collection.iterator();\n         Iterator iterator2 = confirmed.iterator();\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    protected boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    protected boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty ArrayList.\n+     *\n+     * @return an empty ArrayList\n+     */\n+    protected Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    /**\n+     * Returns a full ArrayList.\n+     *\n+     * @return a full ArrayList\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Returns an empty BoundedFifoBuffer that won't overflow.  \n+     *  \n+     * @return an empty BoundedFifoBuffer\n+     */\n+    protected Collection makeCollection() {\n+        return new CircularFifoBuffer(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Tests that the removal operation actually removes the first element.\n      */\n--- a/src/test/org/apache/commons/collections/TestCollection.java\n+++ b/src/test/org/apache/commons/collections/TestCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.11 2003/05/09 18:34:19 scolebourne Exp $\n- * $Revision: 1.11 $\n- * $Date: 2003/05/09 18:34:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.12 2003/07/12 15:11:25 scolebourne Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/07/12 15:11:25 $\n  *\n  * ====================================================================\n  *\n  * <http://www.apache.org/>.\n  *\n  */\n-\n package org.apache.commons.collections;\n \n import java.lang.reflect.Array;\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-\n /**\n  * Tests base {@link java.util.Collection} methods and contracts.\n  * <p>\n  * You should create a concrete subclass of this class to test any custom\n  * {@link Collection} implementation.  At minimum, you'll have to \n  * implement the {@link #makeCollection()} method.  You might want to \n- * override some of the additional protected methods as well:<P>\n- *\n- * <B>Element Population Methods</B><P>\n- * \n+ * override some of the additional protected methods as well:\n+ * <p>\n+ * <B>Element Population Methods</B>\n+ * <p>\n  * Override these if your collection restricts what kind of elements are\n  * allowed (for instance, if <Code>null</Code> is not permitted):\n  * <UL>\n  * <Li>{@link #getFullElements()}\n  * <Li>{@link #getOtherElements()}\n  * </UL>\n- *\n- * <B>Supported Operation Methods</B><P>\n- *\n+ * <p>\n+ * <B>Supported Operation Methods</B>\n+ * <p>\n  * Override these if your collection doesn't support certain operations:\n  * <UL>\n  * <LI>{@link #isAddSuppoted()}\n  * <LI>{@link #isRemoveSupported()}\n  * <li>{@link #areEqualElementsDistinguishable()}\n+ * <LI>{@link #isNullSupported()}\n  * </UL>\n- *\n- * <B>Fixture Methods</B><P>\n- *\n+ * <p>\n+ * <B>Fixture Methods</B>\n+ * <p>\n  * Fixtures are used to verify that the the operation results in correct state\n  * for the collection.  Basically, the operation is performed against your\n  * collection implementation, and an identical operation is performed against a\n  * if their state is identical.  The comparison is usually much more involved\n  * than a simple <Code>equals</Code> test.  This verification is used to ensure\n  * proper modifications are made along with ensuring that the collection does\n- * not change when read-only modifications are made.<P>\n- *\n+ * not change when read-only modifications are made.\n+ * <p>\n  * The {@link #collection} field holds an instance of your collection\n  * implementation; the {@link #confirmed} field holds an instance of the\n  * confirmed collection implementation.  The {@link #resetEmpty()} and \n  * {@link #resetFull()} methods set these fields to empty or full collections,\n- * so that tests can proceed from a known state.<P>\n- *\n+ * so that tests can proceed from a known state.\n+ * <p>\n  * After a modification operation to both {@link #collection} and\n  * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n  * the results.  You may want to override {@link #verify()} to perform\n  * additional verifications.  For instance, when testing the collection\n  * views of a map, {@link TestMap} would override {@link #verify()} to make\n  * sure the map is changed after the collection view is changed.\n- *\n+ * <p>\n  * If you're extending this class directly, you will have to provide \n  * implementations for the following:\n  * <UL>\n  * <LI>{@link #makeConfirmedCollection()}\n  * <LI>{@link #makeConfirmedFullCollection()}\n  * </UL>\n- *\n+ * <p>\n  * Those methods should provide a confirmed collection implementation \n- * that's compatible with your collection implementation.<P>\n- *\n+ * that's compatible with your collection implementation.\n+ * <p>\n  * If you're extending {@link TestList}, {@link TestSet},\n  * or {@link TestBag}, you probably don't have to worry about the\n  * above methods, because those three classes already override the methods\n  * to provide standard JDK confirmed collections.<P>\n- *\n- * <B>Other notes</B><P>\n- *\n+ * <p>\n+ * <B>Other notes</B>\n+ * <p>\n  * If your {@link Collection} fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n  * test case (method) your {@link Collection} fails.  For instance, the\n  * {@link #testIteratorFailFast()} method is provided since most collections\n  * have fail-fast iterators; however, that's not strictly required by the\n  * collection contract, so you may want to override that method to do \n- * nothing.<P>\n+ * nothing.\n  *\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n  * @author Neil O'Toole\n- * @version $Id: TestCollection.java,v 1.11 2003/05/09 18:34:19 scolebourne Exp $\n+ * @author Stephen Colebourne\n+ * @version $Id: TestCollection.java,v 1.12 2003/07/12 15:11:25 scolebourne Exp $\n  */\n public abstract class TestCollection extends TestObject {\n \n      */\n     protected Collection confirmed;\n \n-\n+    /**\n+     * Constructor.\n+     * \n+     * @param testName  the test name\n+     */\n     public TestCollection(String testName) {\n         super(testName);\n     }\n \n-\n-    /**\n-     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n-     *  collections.  Invoke this method before performing a modification\n-     *  test.\n-     */\n-    protected void resetEmpty() {\n-        this.collection = makeCollection();\n-        this.confirmed = makeConfirmedCollection();\n-    }\n-\n-\n-    /**\n-     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n-     *  collections.  Invoke this method before performing a modification\n-     *  test.\n-     */\n-    protected void resetFull() {\n-        this.collection = makeFullCollection();\n-        this.confirmed = makeConfirmedFullCollection();\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Specifies whether equal elements in the collection are, in fact,\n      *  distinguishable with information not readily available.  That is, if a\n         return false;\n     }\n \n+    /**\n+     *  Returns true if the collections produced by \n+     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n+     *  support the <Code>add</Code> and <Code>addAll</Code>\n+     *  operations.<P>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support add or addAll.\n+     */\n+    protected boolean isAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by \n+     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n+     *  support the <Code>remove</Code>, <Code>removeAll</Code>,\n+     *  <Code>retainAll</Code>, <Code>clear</Code> and\n+     *  <Code>iterator().remove()</Code> methods.\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support removal operations.\n+     */\n+    protected boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports holding null.\n+     * The default implementation returns true;\n+     */\n+    protected boolean isNullSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports fail fast iterators.\n+     * The default implementation returns true;\n+     */\n+    protected boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Verifies that {@link #collection} and {@link #confirmed} have \n      *  identical state.\n         }\n     }\n     \n-    \n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    protected void resetEmpty() {\n+        this.collection = makeCollection();\n+        this.confirmed = makeConfirmedCollection();\n+    }\n+\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    protected void resetFull() {\n+        this.collection = makeFullCollection();\n+        this.confirmed = makeConfirmedFullCollection();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Returns a confirmed empty collection.\n      *  For instance, an {@link java.util.ArrayList} for lists or a\n      *  @return a confirmed empty collection\n      */\n     protected abstract Collection makeConfirmedCollection();\n-\n-\n \n     /**\n      *  Returns a confirmed full collection.\n      */\n     protected abstract Collection makeConfirmedFullCollection();\n \n-\n-    /**\n-     *  Returns true if the collections produced by \n-     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n-     *  support the <Code>add</Code> and <Code>addAll</Code>\n-     *  operations.<P>\n-     *  Default implementation returns true.  Override if your collection\n-     *  class does not support add or addAll.\n-     */\n-    protected boolean isAddSupported() {\n-        return true;\n-    }\n-\n-\n-    /**\n-     *  Returns true if the collections produced by \n-     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n-     *  support the <Code>remove</Code>, <Code>removeAll</Code>,\n-     *  <Code>retainAll</Code>, <Code>clear</Code> and\n-     *  <Code>iterator().remove()</Code> methods.\n-     *  Default implementation returns true.  Override if your collection\n-     *  class does not support removal operations.\n-     */\n-    protected boolean isRemoveSupported() {\n-        return true;\n-    }\n-\n-\n+    /**\n+     * Return a new, empty {@link Collection} to be used for testing.\n+     */\n+    protected abstract Collection makeCollection();\n+\n+    /**\n+     *  Returns a full collection to be used for testing.  The collection\n+     *  returned by this method should contain every element returned by\n+     *  {@link #getFullElements()}.  The default implementation, in fact,\n+     *  simply invokes <Code>addAll</Code> on an empty collection with\n+     *  the results of {@link #getFullElements()}.  Override this default\n+     *  if your collection doesn't support addAll.\n+     */\n+    protected Collection makeFullCollection() {\n+        Collection c = makeCollection();\n+        c.addAll(Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty collection for Object tests.\n+     */\n+    protected Object makeObject() {\n+        return makeCollection();\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Returns an array of objects that are contained in a collection\n      *  produced by {@link #makeFullCollection()}.  Every element in the\n      *  returned array <I>must</I> be an element in a full collection.<P>\n      *  The default implementation returns a heterogenous array of \n-     *  objects with some duplicates and with the null element.  \n+     *  objects with some duplicates. null is added if allowed.\n      *  Override if you require specific testing elements.  Note that if you\n      *  override {@link #makeFullCollection()}, you <I>must</I> override\n      *  this method to reflect the contents of a full collection.\n      */\n     protected Object[] getFullElements() {\n-        ArrayList list = new ArrayList();\n-        list.addAll(Arrays.asList(getFullNonNullElements()));\n-        list.add(4, null);\n-        return list.toArray();\n-    }\n-\n+        if (isNullSupported()) {\n+            ArrayList list = new ArrayList();\n+            list.addAll(Arrays.asList(getFullNonNullElements()));\n+            list.add(4, null);\n+            return list.toArray();\n+        } else {\n+            return (Object[]) getFullNonNullElements().clone();\n+        }\n+    }\n \n     /**\n      *  Returns an array of elements that are <I>not</I> contained in a\n         return getOtherNonNullElements();\n     }\n     \n-\n-    /**\n-     * Return a new, empty {@link Collection} to be used for testing.\n-     */\n-    protected abstract Collection makeCollection();\n-\n-\n-    /**\n-     *  Returns a full collection to be used for testing.  The collection\n-     *  returned by this method should contain every element returned by\n-     *  {@link #getFullElements()}.  The default implementation, in fact,\n-     *  simply invokes <Code>addAll</Code> on an empty collection with\n-     *  the results of {@link #getFullElements()}.  Override this default\n-     *  if your collection doesn't support addAll.\n-     */\n-    protected Collection makeFullCollection() {\n-        Collection c = makeCollection();\n-        c.addAll(Arrays.asList(getFullElements()));\n-        return c;\n-    }\n-\n-\n-    /**\n-     *  Returns an empty collection for Object tests.\n-     */\n-    public Object makeObject() {\n-        return makeCollection();\n-    }\n-\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Tests {@link Collection#add(Object)}.\n      */\n      *  Tests that the collection's iterator is fail-fast.  \n      */\n     public void testCollectionIteratorFailFast() {\n+        if (!isFailFastSupported()) return;\n+        \n         if (isAddSupported()) {\n             resetFull();\n             try {\n--- a/src/test/org/apache/commons/collections/TestList.java\n+++ b/src/test/org/apache/commons/collections/TestList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.17 2003/04/26 10:27:59 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.18 2003/07/12 15:11:25 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * you may still use this base set of cases.  Simply override the\n  * test case (method) your {@link List} fails.\n  *\n- * @version $Revision: 1.17 $ $Date: 2003/04/26 10:27:59 $\n+ * @version $Revision: 1.18 $ $Date: 2003/07/12 15:11:25 $\n  * \n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  */\n public abstract class TestList extends TestCollection {\n \n-\n+    /**\n+     * Constructor.\n+     * @param testName\n+     */\n     public TestList(String testName) {\n         super(testName);\n     }\n \n-\n-    /**\n-     *  Return a new, empty {@link List} to be used for testing.\n-     *\n-     *  @return an empty list for testing.\n-     */\n-    protected abstract List makeEmptyList();\n-\n-\n-    /**\n-     *  Return a new, full {@link List} to be used for testing.\n-     *\n-     *  @return a full list for testing\n-     */\n-    protected List makeFullList() {\n-        // only works if list supports optional \"addAll(Collection)\" \n-        List list = makeEmptyList();\n-        list.addAll(Arrays.asList(getFullElements()));\n-        return list;\n-    }\n-\n-\n-    /**\n-     *  Returns {@link makeEmptyList()}.\n-     *\n-     *  @return an empty list to be used for testing\n-     */\n-    final protected Collection makeCollection() {\n-        return makeEmptyList();\n-    }\n-\n-\n-    /**\n-     *  Returns {@link makeFullList()}.\n-     *\n-     *  @return a full list to be used for testing\n-     */\n-    final protected Collection makeFullCollection() {\n-        return makeFullList();\n-    }\n-\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Returns true if the collections produced by \n      *  {@link #makeCollection()} and {@link #makeFullCollection()}\n         return true;\n     }\n \n-\n-    /**\n-     *  Returns the {@link collection} field cast to a {@link List}.\n-     *\n-     *  @return the collection field as a List\n-     */\n-    protected List getList() {\n-        return (List)collection;\n-    } \n-\n-\n-    /**\n-     *  Returns the {@link confirmed} field cast to a {@link List}.\n-     *\n-     *  @return the confirmed field as a List\n-     */\n-    protected List getConfirmedList() {\n-        return (List)confirmed;\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#add(int, Object)} on an\n-     *  empty list.\n-     */\n-    public void testListAddByIndexBoundsChecking() {\n-        if (!isAddSupported()) return;\n-\n-        List list = makeEmptyList();\n-        Object element = getOtherElements()[0];\n-\n-        try {\n-            list.add(Integer.MIN_VALUE, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(-1, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(1, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(Integer.MAX_VALUE, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException \" + \n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#add(int, Object)} on a\n-     *  full list.\n-     */\n-    public void testListAddByIndexBoundsChecking2() {\n-        if (!isAddSupported()) return;\n-\n-        List list = makeFullList();\n-        Object element = getOtherElements()[0];\n-\n-        try {\n-            list.add(Integer.MIN_VALUE, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(-1, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(list.size() + 1, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.add(Integer.MAX_VALUE, element);\n-            fail(\"List.add should throw IndexOutOfBoundsException \" + \n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#add(int,Object)}.\n-     */\n-    public void testListAddByIndex() {\n-        if (!isAddSupported()) return;\n-\n-        Object element = getOtherElements()[0];\n-        int max = getFullElements().length;\n-\n-        for (int i = 0; i <= max; i++) {\n-            resetFull();\n-            ((List)collection).add(i, element);\n-            ((List)confirmed).add(i, element);\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#equals(Object)}.\n-     */\n-    public void testListEquals() {\n-        resetEmpty();\n-        List list = getList();\n-        assertTrue(\"Empty lists should be equal\", list.equals(confirmed));\n-        verify();\n-        assertTrue(\"Empty list should equal self\", list.equals(list));\n-        verify();\n-\n-        List list2 = Arrays.asList(getFullElements());\n-        assertTrue(\"Empty list shouldn't equal full\", !list.equals(list2));\n-        verify();\n-\n-        list2 = Arrays.asList(getOtherElements());\n-        assertTrue(\"Empty list shouldn't equal other\", !list.equals(list2));\n-        verify();\n-\n-        resetFull();\n-        list = getList();\n-        assertTrue(\"Full lists should be equal\", list.equals(confirmed));\n-        verify();\n-        assertTrue(\"Full list should equal self\", list.equals(list));\n-        verify();\n-\n-        list2 = makeEmptyList();\n-        assertTrue(\"Full list shouldn't equal empty\", !list.equals(list2));\n-        verify();\n-\n-        list2 = Arrays.asList(getOtherElements());\n-        assertTrue(\"Full list shouldn't equal other\", !list.equals(list2));\n-        verify();\n-\n-        list2 = Arrays.asList(getFullElements());\n-        Collections.reverse(list2);\n-        assertTrue(\"Full list shouldn't equal full list with same elements\" +\n-          \" but different order\", !list.equals(list2));\n-        verify();\n-\n-        assertTrue(\"List shouldn't equal String\", !list.equals(\"\"));\n-        verify();\n-\n-        final List listForC = Arrays.asList(getFullElements());\n-        Collection c = new AbstractCollection() {\n-            public int size() {\n-                return listForC.size();\n-            }\n-\n-            public Iterator iterator() {\n-                return listForC.iterator();\n-            }\n-        };\n-\n-        assertTrue(\"List shouldn't equal nonlist with same elements \" +\n-          \" in same order\", !list.equals(c));\n-        verify();\n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#hashCode()}.\n-     */\n-    public void testListHashCode() {\n-        resetEmpty();\n-        int hash1 = collection.hashCode();\n-        int hash2 = confirmed.hashCode();\n-        assertEquals(\"Empty lists should have equal hashCodes\", hash1, hash2);\n-        verify();\n-\n-        resetFull();\n-        hash1 = collection.hashCode();\n-        hash2 = confirmed.hashCode();\n-        assertEquals(\"Full lists should have equal hashCodes\", hash1, hash2);\n-        verify();\n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#get(int)}.\n-     */\n-    public void testListGetByIndex() {\n-        resetFull();\n-        List list = getList();\n-        Object[] elements = getFullElements();\n-        for (int i = 0; i < elements.length; i++) {\n-            assertEquals(\"List should contain correct elements\", \n-              elements[i], list.get(i));\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#get(int)} on an\n-     *  empty list.\n-     */\n-    public void testListGetByIndexBoundsChecking() {\n-        List list = makeEmptyList();\n-\n-        try {\n-            list.get(Integer.MIN_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(-1);\n-            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(0);\n-            fail(\"List.get should throw IndexOutOfBoundsException [0]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(1);\n-            fail(\"List.get should throw IndexOutOfBoundsException [1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(Integer.MAX_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#get(int)} on a\n-     *  full list.\n-     */\n-    public void testListGetByIndexBoundsChecking2() {\n-        List list = makeFullList();\n-\n-        try {\n-            list.get(Integer.MIN_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException \" + \n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(-1);\n-            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(getFullElements().length);\n-            fail(\"List.get should throw IndexOutOfBoundsException [size]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-\n-        try {\n-            list.get(Integer.MAX_VALUE);\n-            fail(\"List.get should throw IndexOutOfBoundsException \" + \n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#indexOf()}.\n-     */\n-    public void testListIndexOf() {\n-        resetFull();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Iterator iterator = list2.iterator();\n-        while (iterator.hasNext()) {\n-            Object element = iterator.next();\n-            assertEquals(\"indexOf should return correct result\", \n-              list1.indexOf(element), list2.indexOf(element));            \n-            verify();\n-        }\n-\n-        Object[] other = getOtherElements();\n-        for (int i = 0; i < other.length; i++) {\n-            assertEquals(\"indexOf should return -1 for nonexistent element\",\n-              list1.indexOf(other[i]), -1);\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#lastIndexOf()}.\n-     */\n-    public void testListLastIndexOf() {\n-        resetFull();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Iterator iterator = list2.iterator();\n-        while (iterator.hasNext()) {\n-            Object element = iterator.next();\n-            assertEquals(\"lastIndexOf should return correct result\",\n-              list1.lastIndexOf(element), list2.lastIndexOf(element));\n-            verify();\n-        }\n-\n-        Object[] other = getOtherElements();\n-        for (int i = 0; i < other.length; i++) {\n-            assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n-              \"element\", list1.lastIndexOf(other[i]), -1);\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#set(int,Object)} on an\n-     *  empty list.\n-     */\n-    public void testListSetByIndexBoundsChecking() {\n-        if (!isSetSupported()) return;\n-\n-        List list = makeEmptyList();\n-        Object element = getOtherElements()[0];\n-\n-        try {\n-            list.set(Integer.MIN_VALUE, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(-1, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(0, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException [0]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(1, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException [1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(Integer.MAX_VALUE, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#set(int,Object)} on a\n-     *  full list.\n-     */\n-    public void testListSetByIndexBoundsChecking2() {\n-        if (!isSetSupported()) return;\n-\n-        List list = makeFullList();\n-        Object element = getOtherElements()[0];\n-\n-        try {\n-            list.set(Integer.MIN_VALUE, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(-1, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(getFullElements().length, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.set(Integer.MAX_VALUE, element);\n-            fail(\"List.set should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-    }\n-\n-\n-    /**\n-     *  Test {@link List#set(int,Object)}.\n-     */\n-    public void testListSetByIndex() {\n-        if (!isSetSupported()) return;\n-\n-        resetFull();\n-        Object[] elements = getFullElements();\n-        Object[] other = getOtherElements();\n-\n-        for (int i = 0; i < elements.length; i++) {\n-            Object n = other[i % other.length];\n-            Object v = ((List)collection).set(i, n);\n-            assertEquals(\"Set should return correct element\", elements[i], v);\n-            ((List)confirmed).set(i, n);\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  If {@link #isSetSupported()} returns false, tests that set operation\n-     *  raises <Code>UnsupportedOperationException.\n-     */\n-    public void testUnsupportedSet() {\n-        if (isSetSupported()) return;\n-        \n-        resetFull();\n-        try {\n-            ((List) collection).set(0, new Object());\n-            fail(\"Emtpy collection should not support set.\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n-        }\n-        // make sure things didn't change even if the expected exception was\n-        // thrown.\n-        verify();\n-    }\n-    \n-\n-    /**\n-     *  Tests bounds checking for {@link List#remove(int)} on an\n-     *  empty list.\n-     */\n-    public void testListRemoveByIndexBoundsChecking() {\n-        if (!isRemoveSupported()) return;\n-\n-        List list = makeEmptyList();\n-\n-        try {\n-            list.remove(Integer.MIN_VALUE);\n-            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(-1);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(0);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(1);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(Integer.MAX_VALUE);\n-            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests bounds checking for {@link List#remove(int)} on a\n-     *  full list.\n-     */\n-    public void testListRemoveByIndexBoundsChecking2() {\n-        if (!isRemoveSupported()) return;\n-\n-        List list = makeFullList();\n-\n-        try {\n-            list.remove(Integer.MIN_VALUE);\n-            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(-1);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(getFullElements().length);\n-            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-\n-        try {\n-            list.remove(Integer.MAX_VALUE);\n-            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n-              \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n-            // expected\n-        } \n-    }\n-\n-\n-    /**\n-     *  Tests {@link List#remove(int)}.\n-     */\n-    public void testListRemoveByIndex() {\n-        if (!isRemoveSupported()) return;\n-\n-        int max = getFullElements().length;\n-        for (int i = 0; i < max; i++) {\n-            resetFull();\n-            Object o1 = ((List)collection).remove(i);\n-            Object o2 = ((List)confirmed).remove(i);\n-            assertEquals(\"remove should return correct element\", o1, o2);\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests the read-only bits of {@link List#listIterator()}.\n-     */\n-    public void testListListIterator() {\n-        resetFull();\n-        forwardTest(getList().listIterator(), 0);\n-        backwardTest(getList().listIterator(), 0);\n-    }\n-\n-\n-    /**\n-     *  Tests the read-only bits of {@link List#listIterator(int)}.\n-     */\n-    public void testListListIteratorByIndex() {\n-        resetFull();\n-        for (int i = 0; i < confirmed.size(); i++) {\n-            forwardTest(getList().listIterator(i), i);\n-            backwardTest(getList().listIterator(i), i);\n-        }\n-    }\n-\n-\n-    /**\n-     *  Traverses to the end of the given iterator.\n-     *\n-     *  @param iter  the iterator to traverse\n-     *  @param i     the starting index\n-     */\n-    private void forwardTest(ListIterator iter, int i) {\n-        List list = getList();\n-        int max = getFullElements().length;\n-\n-        while (i < max) {\n-            assertTrue(\"Iterator should have next\", iter.hasNext());\n-            assertEquals(\"Iterator.nextIndex should work\", \n-              iter.nextIndex(), i);\n-            assertEquals(\"Iterator.previousIndex should work\",\n-              iter.previousIndex(), i - 1);\n-            Object o = iter.next();\n-            assertEquals(\"Iterator returned correct element\", list.get(i), o);\n-            i++;\n-        }\n-\n-        assertTrue(\"Iterator shouldn't have next\", !iter.hasNext());\n-        assertEquals(\"nextIndex should be size\", iter.nextIndex(), max);\n-        assertEquals(\"previousIndex should be size - 1\", \n-          iter.previousIndex(), max - 1);\n-\n-        try {\n-            iter.next();\n-            fail(\"Exhausted iterator should raise NoSuchElement\");\n-        } catch (NoSuchElementException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Traverses to the beginning of the given iterator.\n-     *\n-     *  @param iter  the iterator to traverse\n-     *  @param i     the starting index\n-     */\n-    private void backwardTest(ListIterator iter, int i) {\n-        List list = getList();\n-\n-        while (i > 0) {\n-            assertTrue(\"Iterator should have previous, i:\" + i, iter.hasPrevious());\n-            assertEquals(\"Iterator.nextIndex should work, i:\" + i, iter.nextIndex(), i);\n-            assertEquals(\"Iterator.previousIndex should work, i:\" + i, iter.previousIndex(), i - 1);\n-            Object o = iter.previous();\n-            assertEquals(\"Iterator returned correct element\", list.get(i - 1), o);\n-            i--;\n-        }\n-\n-        assertTrue(\"Iterator shouldn't have previous\", !iter.hasPrevious());\n-        int nextIndex = iter.nextIndex();\n-        assertEquals(\"nextIndex should be 0, actual value: \" + nextIndex, nextIndex, 0);\n-        int prevIndex = iter.previousIndex();\n-        assertEquals(\"previousIndex should be -1, actual value: \" + prevIndex, prevIndex, -1);\n-\n-        try {\n-            iter.previous();\n-            fail(\"Exhausted iterator should raise NoSuchElement\");\n-        } catch (NoSuchElementException e) {\n-            // expected\n-        }\n-\n-    }\n-\n-\n-    /**\n-     *  Tests the {@link ListIterator#add(Object)} method of the list\n-     *  iterator.\n-     */\n-    public void testListIteratorAdd() {\n-        if (!isAddSupported()) return;\n-\n-        resetEmpty();\n-        List list1 = getList();\n-        List list2 = getConfirmedList();\n-\n-        Object[] elements = getFullElements();\n-        ListIterator iter1 = list1.listIterator();\n-        ListIterator iter2 = list2.listIterator();\n-\n-        for (int i = 0; i < elements.length; i++) {\n-            iter1.add(elements[i]);\n-            iter2.add(elements[i]);\n-            verify();\n-        }\n-\n-        resetFull();\n-        iter1 = getList().listIterator();\n-        iter2 = getConfirmedList().listIterator();\n-        for (int i = 0; i < elements.length; i++) {\n-            iter1.next();\n-            iter2.next();\n-            iter1.add(elements[i]);\n-            iter2.add(elements[i]);\n-            verify();\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests the {@link ListIterator#set(Object)} method of the list\n-     *  iterator.\n-     */\n-    public void testListIteratorSet() {\n-        if (!isSetSupported()) return;\n-\n-        Object[] elements = getFullElements();\n-\n-        resetFull();\n-        ListIterator iter1 = getList().listIterator();\n-        ListIterator iter2 = getConfirmedList().listIterator();\n-        for (int i = 0; i < elements.length; i++) {\n-            iter1.next();\n-            iter2.next();\n-            iter1.set(elements[i]);\n-            iter2.set(elements[i]);\n-            verify();\n-        }\n-    }\n-\n-\n-    public void testEmptyListSerialization() \n-    throws IOException, ClassNotFoundException {\n-        List list = makeEmptyList();\n-        if (!(list instanceof Serializable)) return;\n-        \n-        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n-        List list2 = (List) readExternalFormFromBytes(objekt);\n-\n-        assertTrue(\"Both lists are empty\",list.size()  == 0);\n-        assertTrue(\"Both lists are empty\",list2.size() == 0);\n-    }\n-\n-    public void testFullListSerialization() \n-    throws IOException, ClassNotFoundException {\n-        List list = makeFullList();\n-        int size = getFullElements().length;\n-        if (!(list instanceof Serializable)) return;\n-        \n-        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n-        List list2 = (List) readExternalFormFromBytes(objekt);\n-\n-        assertEquals(\"Both lists are same size\",list.size(), size);\n-        assertEquals(\"Both lists are same size\",list2.size(), size);\n-    }\n-\n-    /**\n-     * Compare the current serialized form of the List\n-     * against the canonical version in CVS.\n-     */\n-    public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {\n-        /**\n-         * Create canonical objects with this code\n-        List list = makeEmptyList();\n-        if (!(list instanceof Serializable)) return;\n-        \n-        writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));\n-        */\n-\n-        // test to make sure the canonical form has been preserved\n-        List list = makeEmptyList();\n-        if(list instanceof Serializable && !skipSerializedCanonicalTests()) {\n-            List list2 = (List) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n-            assertTrue(\"List is empty\",list2.size()  == 0);\n-        }\n-    }\n-\n-    /**\n-     * Compare the current serialized form of the List\n-     * against the canonical version in CVS.\n-     */\n-    public void testFullListCompatibility() throws IOException, ClassNotFoundException {\n-        /**\n-         * Create canonical objects with this code\n-        List list = makeFullList();\n-        if (!(list instanceof Serializable)) return;\n-        \n-        writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));\n-        */\n-\n-        // test to make sure the canonical form has been preserved\n-        List list = makeFullList();\n-        if(list instanceof Serializable && !skipSerializedCanonicalTests()) {\n-            List list2 = (List) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n-            assertEquals(\"List is the right size\",list2.size(), 4);\n-        }\n-    }\n-\n-\n-    /**\n-     *  Returns an empty {@link ArrayList}.\n-     */\n-    protected Collection makeConfirmedCollection() {\n-        ArrayList list = new ArrayList();\n-        return list;\n-    }\n-\n-\n-    /**\n-     *  Returns a full {@link ArrayList}.\n-     */\n-    protected Collection makeConfirmedFullCollection() {\n-        ArrayList list = new ArrayList();\n-        list.addAll(Arrays.asList(getFullElements()));\n-        return list;\n-    }\n-\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Verifies that the test list implementation matches the confirmed list\n      *  implementation.\n         }\n     }\n \n-\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty {@link ArrayList}.\n+     */\n+    protected Collection makeConfirmedCollection() {\n+        ArrayList list = new ArrayList();\n+        return list;\n+    }\n+\n+    /**\n+     *  Returns a full {@link ArrayList}.\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        ArrayList list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     *  Return a new, empty {@link List} to be used for testing.\n+     *\n+     *  @return an empty list for testing.\n+     */\n+    protected abstract List makeEmptyList();\n+\n+    /**\n+     *  Return a new, full {@link List} to be used for testing.\n+     *\n+     *  @return a full list for testing\n+     */\n+    protected List makeFullList() {\n+        // only works if list supports optional \"addAll(Collection)\" \n+        List list = makeEmptyList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     *  Returns {@link makeEmptyList()}.\n+     *\n+     *  @return an empty list to be used for testing\n+     */\n+    final protected Collection makeCollection() {\n+        return makeEmptyList();\n+    }\n+\n+    /**\n+     *  Returns {@link makeFullList()}.\n+     *\n+     *  @return a full list to be used for testing\n+     */\n+    final protected Collection makeFullCollection() {\n+        return makeFullList();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns the {@link collection} field cast to a {@link List}.\n+     *\n+     *  @return the collection field as a List\n+     */\n+    protected List getList() {\n+        return (List)collection;\n+    } \n+\n+    /**\n+     *  Returns the {@link confirmed} field cast to a {@link List}.\n+     *\n+     *  @return the confirmed field as a List\n+     */\n+    protected List getConfirmedList() {\n+        return (List)confirmed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on an\n+     *  empty list.\n+     */\n+    public void testListAddByIndexBoundsChecking() {\n+        if (!isAddSupported()) return;\n+\n+        List list = makeEmptyList();\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on a\n+     *  full list.\n+     */\n+    public void testListAddByIndexBoundsChecking2() {\n+        if (!isAddSupported()) return;\n+\n+        List list = makeFullList();\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(list.size() + 1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#add(int,Object)}.\n+     */\n+    public void testListAddByIndex() {\n+        if (!isAddSupported()) return;\n+\n+        Object element = getOtherElements()[0];\n+        int max = getFullElements().length;\n+\n+        for (int i = 0; i <= max; i++) {\n+            resetFull();\n+            ((List)collection).add(i, element);\n+            ((List)confirmed).add(i, element);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#equals(Object)}.\n+     */\n+    public void testListEquals() {\n+        resetEmpty();\n+        List list = getList();\n+        assertTrue(\"Empty lists should be equal\", list.equals(confirmed));\n+        verify();\n+        assertTrue(\"Empty list should equal self\", list.equals(list));\n+        verify();\n+\n+        List list2 = Arrays.asList(getFullElements());\n+        assertTrue(\"Empty list shouldn't equal full\", !list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertTrue(\"Empty list shouldn't equal other\", !list.equals(list2));\n+        verify();\n+\n+        resetFull();\n+        list = getList();\n+        assertTrue(\"Full lists should be equal\", list.equals(confirmed));\n+        verify();\n+        assertTrue(\"Full list should equal self\", list.equals(list));\n+        verify();\n+\n+        list2 = makeEmptyList();\n+        assertTrue(\"Full list shouldn't equal empty\", !list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertTrue(\"Full list shouldn't equal other\", !list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getFullElements());\n+        Collections.reverse(list2);\n+        assertTrue(\"Full list shouldn't equal full list with same elements\" +\n+          \" but different order\", !list.equals(list2));\n+        verify();\n+\n+        assertTrue(\"List shouldn't equal String\", !list.equals(\"\"));\n+        verify();\n+\n+        final List listForC = Arrays.asList(getFullElements());\n+        Collection c = new AbstractCollection() {\n+            public int size() {\n+                return listForC.size();\n+            }\n+\n+            public Iterator iterator() {\n+                return listForC.iterator();\n+            }\n+        };\n+\n+        assertTrue(\"List shouldn't equal nonlist with same elements \" +\n+          \" in same order\", !list.equals(c));\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#hashCode()}.\n+     */\n+    public void testListHashCode() {\n+        resetEmpty();\n+        int hash1 = collection.hashCode();\n+        int hash2 = confirmed.hashCode();\n+        assertEquals(\"Empty lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+\n+        resetFull();\n+        hash1 = collection.hashCode();\n+        hash2 = confirmed.hashCode();\n+        assertEquals(\"Full lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#get(int)}.\n+     */\n+    public void testListGetByIndex() {\n+        resetFull();\n+        List list = getList();\n+        Object[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertEquals(\"List should contain correct elements\", \n+              elements[i], list.get(i));\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on an\n+     *  empty list.\n+     */\n+    public void testListGetByIndexBoundsChecking() {\n+        List list = makeEmptyList();\n+\n+        try {\n+            list.get(Integer.MIN_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(-1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(0);\n+            fail(\"List.get should throw IndexOutOfBoundsException [0]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(Integer.MAX_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on a\n+     *  full list.\n+     */\n+    public void testListGetByIndexBoundsChecking2() {\n+        List list = makeFullList();\n+\n+        try {\n+            list.get(Integer.MIN_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(-1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(getFullElements().length);\n+            fail(\"List.get should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(Integer.MAX_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException \" + \n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#indexOf()}.\n+     */\n+    public void testListIndexOf() {\n+        resetFull();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Iterator iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            Object element = iterator.next();\n+            assertEquals(\"indexOf should return correct result\", \n+              list1.indexOf(element), list2.indexOf(element));            \n+            verify();\n+        }\n+\n+        Object[] other = getOtherElements();\n+        for (int i = 0; i < other.length; i++) {\n+            assertEquals(\"indexOf should return -1 for nonexistent element\",\n+              list1.indexOf(other[i]), -1);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#lastIndexOf()}.\n+     */\n+    public void testListLastIndexOf() {\n+        resetFull();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Iterator iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            Object element = iterator.next();\n+            assertEquals(\"lastIndexOf should return correct result\",\n+              list1.lastIndexOf(element), list2.lastIndexOf(element));\n+            verify();\n+        }\n+\n+        Object[] other = getOtherElements();\n+        for (int i = 0; i < other.length; i++) {\n+            assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n+              \"element\", list1.lastIndexOf(other[i]), -1);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on an\n+     *  empty list.\n+     */\n+    public void testListSetByIndexBoundsChecking() {\n+        if (!isSetSupported()) return;\n+\n+        List list = makeEmptyList();\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(0, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [0]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on a\n+     *  full list.\n+     */\n+    public void testListSetByIndexBoundsChecking2() {\n+        if (!isSetSupported()) return;\n+\n+        List list = makeFullList();\n+        Object element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(getFullElements().length, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+    }\n+\n+\n+    /**\n+     *  Test {@link List#set(int,Object)}.\n+     */\n+    public void testListSetByIndex() {\n+        if (!isSetSupported()) return;\n+\n+        resetFull();\n+        Object[] elements = getFullElements();\n+        Object[] other = getOtherElements();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            Object n = other[i % other.length];\n+            Object v = ((List)collection).set(i, n);\n+            assertEquals(\"Set should return correct element\", elements[i], v);\n+            ((List)confirmed).set(i, n);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  If {@link #isSetSupported()} returns false, tests that set operation\n+     *  raises <Code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedSet() {\n+        if (isSetSupported()) return;\n+        \n+        resetFull();\n+        try {\n+            ((List) collection).set(0, new Object());\n+            fail(\"Emtpy collection should not support set.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+    \n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on an\n+     *  empty list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking() {\n+        if (!isRemoveSupported()) return;\n+\n+        List list = makeEmptyList();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(0);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on a\n+     *  full list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking2() {\n+        if (!isRemoveSupported()) return;\n+\n+        List list = makeFullList();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(getFullElements().length);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#remove(int)}.\n+     */\n+    public void testListRemoveByIndex() {\n+        if (!isRemoveSupported()) return;\n+\n+        int max = getFullElements().length;\n+        for (int i = 0; i < max; i++) {\n+            resetFull();\n+            Object o1 = ((List)collection).remove(i);\n+            Object o2 = ((List)confirmed).remove(i);\n+            assertEquals(\"remove should return correct element\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator()}.\n+     */\n+    public void testListListIterator() {\n+        resetFull();\n+        forwardTest(getList().listIterator(), 0);\n+        backwardTest(getList().listIterator(), 0);\n+    }\n+\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator(int)}.\n+     */\n+    public void testListListIteratorByIndex() {\n+        resetFull();\n+        for (int i = 0; i < confirmed.size(); i++) {\n+            forwardTest(getList().listIterator(i), i);\n+            backwardTest(getList().listIterator(i), i);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Traverses to the end of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void forwardTest(ListIterator iter, int i) {\n+        List list = getList();\n+        int max = getFullElements().length;\n+\n+        while (i < max) {\n+            assertTrue(\"Iterator should have next\", iter.hasNext());\n+            assertEquals(\"Iterator.nextIndex should work\", \n+              iter.nextIndex(), i);\n+            assertEquals(\"Iterator.previousIndex should work\",\n+              iter.previousIndex(), i - 1);\n+            Object o = iter.next();\n+            assertEquals(\"Iterator returned correct element\", list.get(i), o);\n+            i++;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have next\", !iter.hasNext());\n+        assertEquals(\"nextIndex should be size\", iter.nextIndex(), max);\n+        assertEquals(\"previousIndex should be size - 1\", \n+          iter.previousIndex(), max - 1);\n+\n+        try {\n+            iter.next();\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Traverses to the beginning of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void backwardTest(ListIterator iter, int i) {\n+        List list = getList();\n+\n+        while (i > 0) {\n+            assertTrue(\"Iterator should have previous, i:\" + i, iter.hasPrevious());\n+            assertEquals(\"Iterator.nextIndex should work, i:\" + i, iter.nextIndex(), i);\n+            assertEquals(\"Iterator.previousIndex should work, i:\" + i, iter.previousIndex(), i - 1);\n+            Object o = iter.previous();\n+            assertEquals(\"Iterator returned correct element\", list.get(i - 1), o);\n+            i--;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have previous\", !iter.hasPrevious());\n+        int nextIndex = iter.nextIndex();\n+        assertEquals(\"nextIndex should be 0, actual value: \" + nextIndex, nextIndex, 0);\n+        int prevIndex = iter.previousIndex();\n+        assertEquals(\"previousIndex should be -1, actual value: \" + prevIndex, prevIndex, -1);\n+\n+        try {\n+            iter.previous();\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests the {@link ListIterator#add(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorAdd() {\n+        if (!isAddSupported()) return;\n+\n+        resetEmpty();\n+        List list1 = getList();\n+        List list2 = getConfirmedList();\n+\n+        Object[] elements = getFullElements();\n+        ListIterator iter1 = list1.listIterator();\n+        ListIterator iter2 = list2.listIterator();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            verify();\n+        }\n+\n+        resetFull();\n+        iter1 = getList().listIterator();\n+        iter2 = getConfirmedList().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests the {@link ListIterator#set(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorSet() {\n+        if (!isSetSupported()) return;\n+\n+        Object[] elements = getFullElements();\n+\n+        resetFull();\n+        ListIterator iter1 = getList().listIterator();\n+        ListIterator iter2 = getConfirmedList().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.set(elements[i]);\n+            iter2.set(elements[i]);\n+            verify();\n+        }\n+    }\n+\n+\n+    public void testEmptyListSerialization() \n+    throws IOException, ClassNotFoundException {\n+        List list = makeEmptyList();\n+        if (!(list instanceof Serializable)) return;\n+        \n+        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        List list2 = (List) readExternalFormFromBytes(objekt);\n+\n+        assertTrue(\"Both lists are empty\",list.size()  == 0);\n+        assertTrue(\"Both lists are empty\",list2.size() == 0);\n+    }\n+\n+    public void testFullListSerialization() \n+    throws IOException, ClassNotFoundException {\n+        List list = makeFullList();\n+        int size = getFullElements().length;\n+        if (!(list instanceof Serializable)) return;\n+        \n+        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        List list2 = (List) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Both lists are same size\",list.size(), size);\n+        assertEquals(\"Both lists are same size\",list2.size(), size);\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the List\n+     * against the canonical version in CVS.\n+     */\n+    public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        List list = makeEmptyList();\n+        if (!(list instanceof Serializable)) return;\n+        \n+        writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        List list = makeEmptyList();\n+        if(list instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            List list2 = (List) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n+            assertTrue(\"List is empty\",list2.size()  == 0);\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the List\n+     * against the canonical version in CVS.\n+     */\n+    public void testFullListCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        List list = makeFullList();\n+        if (!(list instanceof Serializable)) return;\n+        \n+        writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        List list = makeFullList();\n+        if(list instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            List list2 = (List) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n+            assertEquals(\"List is the right size\",list2.size(), 4);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.\n      *  The returned bulk test will run through every <Code>TestList</Code>\n     *  if elements are added to the original list.\n     */\n    public void testListSubListFailFastOnAdd() {\n+       if (!isFailFastSupported()) return;\n        if (!isAddSupported()) return;\n \n        resetFull();\n     *  if elements are removed from the original list.\n     */\n    public void testListSubListFailFastOnRemove() {\n+       if (!isFailFastSupported()) return;\n        if (!isRemoveSupported()) return;\n \n        resetFull();\n--- a/src/test/org/apache/commons/collections/TestSet.java\n+++ b/src/test/org/apache/commons/collections/TestSet.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestSet.java,v 1.2 2002/06/18 03:06:45 mas Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/18 03:06:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestSet.java,v 1.3 2003/07/12 15:11:25 scolebourne Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2003/07/12 15:11:25 $\n  *\n  * ====================================================================\n  *\n  *  elements may be added; see {@link TestCollection} for more details.<P>\n  *\n  *  @author Paul Jack\n- *  @version $Id: TestSet.java,v 1.2 2002/06/18 03:06:45 mas Exp $\n+ *  @version $Id: TestSet.java,v 1.3 2003/07/12 15:11:25 scolebourne Exp $\n  */\n public abstract class TestSet extends TestCollection {\n \n-\n     /**\n      *  Constructor.\n      *\n         super(name);\n     }\n \n-\n-    /**\n-     *  Makes an empty collection by invoking {@link #makeEmptySet()}.  \n-     *\n-     *  @return an empty collection\n-     */\n-    protected final Collection makeCollection() {\n-        return makeEmptySet();\n-    }\n-\n-\n-    /**\n-     *  Makes a full collection by invoking {@link #makeFullSet()}.\n-     *\n-     *  @return a full collection\n-     */\n-    protected final Collection makeFullCollection() {\n-        return makeFullSet();\n-    }\n-\n-    /**\n-     *  Return the {@link TestCollection#collection} fixture, but cast as a\n-     *  Set.  \n-     */\n-    protected Set getSet() {\n-        return (Set)collection;\n-    }\n-\n-    /**\n-     *  Returns an empty {@link HashSet} for use in modification testing.\n-     *\n-     *  @return a confirmed empty collection\n-     */\n-    protected Collection makeConfirmedCollection() {\n-        return new HashSet();\n-    }\n-\n-\n-    /**\n-     *  Returns a full {@link HashSet} for use in modification testing.\n-     *\n-     *  @return a confirmed full collection\n-     */\n-    protected Collection makeConfirmedFullCollection() {\n-        HashSet set = new HashSet();\n-        set.addAll(Arrays.asList(getFullElements()));\n-        return set;\n-    }\n-\n-    /**\n-     *  Return the {@link TestCollection#confirmed} fixture, but cast as a \n-     *  Set.\n-     **/\n-    protected Set getConfirmedSet() {\n-        return (Set)confirmed;\n-    }\n-\n-    /**\n-     *  Makes an empty set.  The returned set should have no elements.\n-     *\n-     *  @return an empty set\n-     */\n-    protected abstract Set makeEmptySet();\n-\n-\n-    /**\n-     *  Makes a full set by first creating an empty set and then adding\n-     *  all the elements returned by {@link #getFullElements()}.\n-     *\n-     *  Override if your set does not support the add operation.\n-     *\n-     *  @return a full set\n-     */\n-    protected Set makeFullSet() {\n-        Set set = makeEmptySet();\n-        set.addAll(Arrays.asList(getFullElements()));\n-        return set;\n-    }\n-\n-\n-    /**\n-     *  Tests {@link Set#equals(Object)}.\n-     */\n-    public void testSetEquals() {\n-        resetEmpty();\n-        assertEquals(\"Empty sets should be equal\", \n-                     getSet(), getConfirmedSet());\n-        verify();\n-\n-        HashSet set2 = new HashSet();\n-        set2.add(\"foo\");\n-        assertTrue(\"Empty set shouldn't equal nonempty set\", \n-                   !getSet().equals(set2));\n-\n-        resetFull();\n-        assertEquals(\"Full sets should be equal\", getSet(), getConfirmedSet());\n-        verify();\n-\n-        set2.clear();\n-        set2.addAll(Arrays.asList(getOtherElements()));\n-        assertTrue(\"Sets with different contents shouldn't be equal\", \n-                   !getSet().equals(set2));\n-    }\n-\n-\n-    /**\n-     *  Tests {@link Set#hashCode()}.\n-     */\n-    public void testSetHashCode() {\n-        resetEmpty();\n-        assertEquals(\"Empty sets have equal hashCodes\", \n-                     getSet().hashCode(), getConfirmedSet().hashCode());\n-\n-        resetFull();\n-        assertEquals(\"Equal sets have equal hashCodes\", \n-                     getSet().hashCode(), getConfirmedSet().hashCode());\n-    }\n-\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Provides additional verifications for sets.\n      */\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty {@link HashSet} for use in modification testing.\n+     *\n+     *  @return a confirmed empty collection\n+     */\n+    protected Collection makeConfirmedCollection() {\n+        return new HashSet();\n+    }\n+\n+    /**\n+     *  Returns a full {@link HashSet} for use in modification testing.\n+     *\n+     *  @return a confirmed full collection\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        HashSet set = new HashSet();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    /**\n+     *  Makes an empty set.  The returned set should have no elements.\n+     *\n+     *  @return an empty set\n+     */\n+    protected abstract Set makeEmptySet();\n+\n+    /**\n+     *  Makes a full set by first creating an empty set and then adding\n+     *  all the elements returned by {@link #getFullElements()}.\n+     *\n+     *  Override if your set does not support the add operation.\n+     *\n+     *  @return a full set\n+     */\n+    protected Set makeFullSet() {\n+        Set set = makeEmptySet();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    /**\n+     *  Makes an empty collection by invoking {@link #makeEmptySet()}.  \n+     *\n+     *  @return an empty collection\n+     */\n+    protected final Collection makeCollection() {\n+        return makeEmptySet();\n+    }\n+\n+    /**\n+     *  Makes a full collection by invoking {@link #makeFullSet()}.\n+     *\n+     *  @return a full collection\n+     */\n+    protected final Collection makeFullCollection() {\n+        return makeFullSet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Return the {@link TestCollection#collection} fixture, but cast as a\n+     *  Set.  \n+     */\n+    protected Set getSet() {\n+        return (Set)collection;\n+    }\n+\n+    /**\n+     *  Return the {@link TestCollection#confirmed} fixture, but cast as a \n+     *  Set.\n+     **/\n+    protected Set getConfirmedSet() {\n+        return (Set)confirmed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link Set#equals(Object)}.\n+     */\n+    public void testSetEquals() {\n+        resetEmpty();\n+        assertEquals(\"Empty sets should be equal\", \n+                     getSet(), getConfirmedSet());\n+        verify();\n+\n+        HashSet set2 = new HashSet();\n+        set2.add(\"foo\");\n+        assertTrue(\"Empty set shouldn't equal nonempty set\", \n+                   !getSet().equals(set2));\n+\n+        resetFull();\n+        assertEquals(\"Full sets should be equal\", getSet(), getConfirmedSet());\n+        verify();\n+\n+        set2.clear();\n+        set2.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Sets with different contents shouldn't be equal\", \n+                   !getSet().equals(set2));\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Set#hashCode()}.\n+     */\n+    public void testSetHashCode() {\n+        resetEmpty();\n+        assertEquals(\"Empty sets have equal hashCodes\", \n+                     getSet().hashCode(), getConfirmedSet().hashCode());\n+\n+        resetFull();\n+        assertEquals(\"Equal sets have equal hashCodes\", \n+                     getSet().hashCode(), getConfirmedSet().hashCode());\n+    }\n+\n+\n }\n--- a/src/test/org/apache/commons/collections/TestUnboundedFifoBuffer.java\n+++ b/src/test/org/apache/commons/collections/TestUnboundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestUnboundedFifoBuffer.java,v 1.4 2003/02/19 20:33:11 scolebourne Exp $\n- * $Revision: 1.4 $\n- * $Date: 2003/02/19 20:33:11 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestUnboundedFifoBuffer.java,v 1.5 2003/07/12 15:11:25 scolebourne Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2003/07/12 15:11:25 $\n  *\n  * ====================================================================\n  *\n         return BulkTest.makeSuite(TestUnboundedFifoBuffer.class);\n     }\n \n-    /**\n-     *  Returns an empty UnboundedFifoBuffer with a small capacity.\n-     *\n-     *  @return an empty UnboundedFifoBuffer\n-     */\n-    public Collection makeCollection() {\n-        return new UnboundedFifoBuffer(5);\n-    }\n-\n-\n-    /**\n-     *  Returns an empty ArrayList.\n-     *\n-     *  @return an empty ArrayList\n-     */\n-    public Collection makeConfirmedCollection() {\n-        return new ArrayList();\n-    }\n-\n-\n-    /**\n-     *  Returns a full ArrayList.\n-     *\n-     *  @return a full ArrayList\n-     */\n-    public Collection makeConfirmedFullCollection() {\n-        Collection c = makeConfirmedCollection();\n-        c.addAll(java.util.Arrays.asList(getFullElements()));\n-        return c;\n-    }\n-\n-\n-    /**\n-     *  Overridden because UnboundedFifoBuffer doesn't allow null elements.\n-     *\n-     *  @return an array of random elements without the null element\n-     */\n-    public Object[] getFullElements() {\n-        return getFullNonNullElements();\n-    }\n-\n-\n-    /**\n-     *  Overridden because UnboundedFifoBuffer's iterators aren't fail-fast.\n-     */\n-    public void testCollectionIteratorFailFast() {\n-    }\n-\n-\n+    //-----------------------------------------------------------------------\n     /**\n      *  Verifies that the ArrayList has the same elements in the same \n      *  sequence as the UnboundedFifoBuffer.\n      */\n-    public void verify() {\n+    protected void verify() {\n         super.verify();\n         Iterator iterator1 = collection.iterator();\n         Iterator iterator2 = confirmed.iterator();\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    protected boolean isNullSupported() {\n+        return false;\n+    }\n \n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    protected boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    protected Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty UnboundedFifoBuffer with a small capacity.\n+     *\n+     *  @return an empty UnboundedFifoBuffer\n+     */\n+    protected Collection makeCollection() {\n+        return new UnboundedFifoBuffer(5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      *  Tests that UnboundedFifoBuffer removes elements in the right order.\n      */\n--- a/src/test/org/apache/commons/collections/decorators/TestTransformedCollection.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestTransformedCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedCollection.java,v 1.1 2003/05/11 13:18:27 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedCollection.java,v 1.2 2003/07/12 15:11:26 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/05/11 13:18:27 $\n+ * @version $Revision: 1.2 $ $Date: 2003/07/12 15:11:26 $\n  * \n  * @author Stephen Colebourne\n  */\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n+    //-----------------------------------------------------------------------\n     public Collection makeConfirmedCollection() {\n         return new ArrayList();\n     }\n         return TransformedCollection.decorate(list, NOOP_TRANSFORMER);\n     }\n     \n+    //-----------------------------------------------------------------------\n     protected Object[] getFullElements() {\n         return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n     }\n         return new Object[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n     }\n \n+    //-----------------------------------------------------------------------\n     public void testTransformedCollection() {\n         Collection coll = TransformedCollection.decorate(new ArrayList(), STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, coll.size());", "timestamp": 1058022686, "metainfo": ""}