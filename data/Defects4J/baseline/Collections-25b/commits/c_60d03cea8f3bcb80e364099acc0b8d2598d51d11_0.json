{"sha": "60d03cea8f3bcb80e364099acc0b8d2598d51d11", "log": "Add behaviour to scan map to find a removable element when full bug 28887, from Mario Ivankovits   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/map/LRUMap.java\n  * <code>ResettableIterator</code> and calling <code>reset()</code>.\n  * \n  * @since Commons Collections 3.0 (previously in main package v1.0)\n- * @version $Revision: 1.12 $ $Date: 2004/04/25 23:30:07 $\n+ * @version $Revision: 1.13 $ $Date: 2004/05/12 19:51:28 $\n  *\n  * @author James Strachan\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  * @author Mike Pettypiece\n+ * @author Mario Ivankovits\n  */\n public class LRUMap\n         extends AbstractLinkedMap implements BoundedMap, Serializable, Cloneable {\n     static final long serialVersionUID = -612114643488955218L;\n     /** Default maximum size */\n     protected static final int DEFAULT_MAX_SIZE = 100;\n+    /** Default scan behaviour */\n+    protected static final boolean DEFAULT_SCAN_UNTIL_REMOVABLE = false;\n     \n     /** Maximum size */\n     private transient int maxSize;\n+    /** Scan behaviour */\n+    private boolean scanUntilRemovable;\n \n     /**\n      * Constructs a new empty map with a maximum size of 100.\n      */\n     public LRUMap() {\n-        this(DEFAULT_MAX_SIZE, DEFAULT_LOAD_FACTOR);\n+        this(DEFAULT_MAX_SIZE, DEFAULT_LOAD_FACTOR, DEFAULT_SCAN_UNTIL_REMOVABLE);\n     }\n \n     /**\n      */\n     public LRUMap(int maxSize) {\n         this(maxSize, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified maximum size.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     */\n+    public LRUMap(int maxSize, boolean scanUntilRemovable) {\n+        this(maxSize, DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n     public LRUMap(int maxSize, float loadFactor) {\n+        this(maxSize, loadFactor, DEFAULT_SCAN_UNTIL_REMOVABLE);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param maxSize  the maximum size of the map, -1 for no limit,\n+     * @param loadFactor  the load factor\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public LRUMap(int maxSize, float loadFactor, boolean scanUntilRemovable) {\n         super((maxSize < 1 ? DEFAULT_CAPACITY : maxSize), loadFactor);\n         if (maxSize < 1) {\n             throw new IllegalArgumentException(\"LRUMap max size must be greater than 0\");\n         }\n         this.maxSize = maxSize;\n+        this.scanUntilRemovable = scanUntilRemovable;\n     }\n \n     /**\n      * @throws IllegalArgumentException if the map is empty\n      */\n     public LRUMap(Map map) {\n-        this(map.size(), DEFAULT_LOAD_FACTOR);\n+        this(map, DEFAULT_SCAN_UNTIL_REMOVABLE);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p/>\n+     * The maximum size is set from the map's size.\n+     *\n+     * @param map  the map to copy\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     */\n+    public LRUMap(Map map, boolean scanUntilRemovable) {\n+        this(map.size(), DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n         putAll(map);\n     }\n \n      * <p>\n      * From Commons Collections 3.1 this method uses {@link #isFull()} rather\n      * than accessing <code>size</code> and <code>maxSize</code> directly.\n+     * It also handles the scanUntilRemovable functionality.\n      * \n      * @param hashIndex  the index into the data array to store at\n      * @param hashCode  the hash code of the key to add\n      * @param value  the value to add\n      */\n     protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n-        if (isFull() && removeLRU(header.after)) {\n-            reuseMapping(header.after, hashIndex, hashCode, key, value);\n+        if (isFull()) {\n+            LinkEntry reuse = header.after;\n+            boolean removeLRUEntry = false;\n+            if (scanUntilRemovable) {\n+                while (reuse != header) {\n+                    if (removeLRU(reuse)) {\n+                        removeLRUEntry = true;\n+                        break;\n+                    }\n+                    reuse = reuse.after;\n+                }\n+            } else {\n+                removeLRUEntry = removeLRU(reuse);\n+            }\n+            \n+            if (removeLRUEntry) {\n+                reuseMapping(reuse, hashIndex, hashCode, key, value);\n+            } else {\n+                super.addMapping(hashIndex, hashCode, key, value);\n+            }\n         } else {\n             super.addMapping(hashIndex, hashCode, key, value);\n         }\n      *   }\n      * }\n      * </pre>\n-     * Note that the effect of not removing an LRU is for the Map to exceed the maximum size.\n+     * The effect of returning false is dependent on the scanUntilRemovable flag.\n+     * If the flag is true, the next LRU entry will be passed to this method and so on\n+     * until one returns false and is removed, or every entry in the map has been passed.\n+     * If the scanUntilRemovable flag is false, the map will exceed the maximum size.\n      * <p>\n      * NOTE: Commons Collections 3.0 passed the wrong entry to this method.\n      * This is fixed in version 3.1 onwards.\n      */\n     public int maxSize() {\n         return maxSize;\n+    }\n+\n+    /**\n+     * Whether this LRUMap will scan until a removable entry is found when the\n+     * map is full.\n+     *\n+     * @return true if this map scans\n+     */\n+    public boolean scanUntilRemovable() {\n+        return scanUntilRemovable;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/org/apache/commons/collections/map/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLRUMap.java\n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.7 $ $Date: 2004/04/16 23:53:59 $\n+ * @version $Revision: 1.8 $ $Date: 2004/05/12 19:51:28 $\n  * \n  * @author Stephen Colebourne\n  */\n         LinkEntry entry;\n         Object key;\n         Object value;\n+\n         MockLRUMapSubclass(int size) {\n             super(size);\n         }\n+\n         protected boolean removeLRU(LinkEntry entry) {\n             this.entry = entry;\n             this.key = entry.getKey();\n     }\n     \n     public void testRemoveLRUBlocksRemove() {\n-        MockLRUMapSubclassBlocksRemove map = new MockLRUMapSubclassBlocksRemove(2);\n+        MockLRUMapSubclassBlocksRemove map = new MockLRUMapSubclassBlocksRemove(2, false);\n         assertEquals(0, map.size());\n         map.put(\"A\", \"a\");\n         assertEquals(1, map.size());\n         assertEquals(true, map.containsKey(\"B\"));\n         assertEquals(true, map.containsKey(\"C\"));\n     }\n+\n+    public void testRemoveLRUBlocksRemoveScan() {\n+        MockLRUMapSubclassBlocksRemove map = new MockLRUMapSubclassBlocksRemove(2, true);\n+        assertEquals(0, map.size());\n+        map.put(\"A\", \"a\");\n+        assertEquals(1, map.size());\n+        map.put(\"B\", \"b\");\n+        assertEquals(2, map.size());\n+        map.put(\"C\", \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n     \n     static class MockLRUMapSubclassBlocksRemove extends LRUMap {\n-        MockLRUMapSubclassBlocksRemove(int size) {\n-            super(size);\n-        }\n+        MockLRUMapSubclassBlocksRemove(int size, boolean scanUntilRemove) {\n+            super(size, scanUntilRemove);\n+        }\n+\n         protected boolean removeLRU(LinkEntry entry) {\n             return false;\n         }\n     }\n     \n+    public void testRemoveLRUFirstBlocksRemove() {\n+        MockLRUMapSubclassFirstBlocksRemove map = new MockLRUMapSubclassFirstBlocksRemove(2);\n+        assertEquals(0, map.size());\n+        map.put(\"A\", \"a\");\n+        assertEquals(1, map.size());\n+        map.put(\"B\", \"b\");\n+        assertEquals(2, map.size());\n+        map.put(\"C\", \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n+        assertEquals(2, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(false, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    static class MockLRUMapSubclassFirstBlocksRemove extends LRUMap {\n+        MockLRUMapSubclassFirstBlocksRemove(int size) {\n+            super(size, true);\n+        }\n+\n+        protected boolean removeLRU(LinkEntry entry) {\n+            if (\"a\".equals(entry.getValue())) {\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.emptyCollection.version3.obj\");", "timestamp": 1084391756, "metainfo": ""}