{"sha": "6a5c4a72c6a74802025906c1d9a256d50cefc8cb", "log": "Committed the DoubleOrderedMap class and associated unit tests (gotta love it when the unit test source is 50% longer than the class being tested :-). The only change I made was to use the long-form version of the Apache license -- according to the Apache board, that is the only acceptable approach at the moment.  Any remaining classes in commons-collections (or elsewhere) using the short form license should be updated.  Submitted by:\tMarc Johnson <marc_johnson27591@hotmail.com>   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/DoubleOrderedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DoubleOrderedMap.java,v 1.1 2002/01/20 04:36:08 craigmcc Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/01/20 04:36:08 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+\n+\n+import java.lang.reflect.Array;\n+\n+import java.util.*;\n+\n+\n+/**\n+* Red-Black tree-based implementation of Map. This class guarantees\n+* that the map will be in both ascending key order and ascending\n+* value order, sorted according to the natural order for the key's\n+* and value's classes.<p>\n+*\n+* This Map is intended for applications that need to be able to look\n+* up a key-value pairing by either key or value, and need to do so\n+* with equal efficiency.<p>\n+*\n+* While that goal could be accomplished by taking a pair of TreeMaps\n+* and redirecting requests to the appropriate TreeMap (e.g.,\n+* containsKey would be directed to the TreeMap that maps values to\n+* keys, containsValue would be directed to the TreeMap that maps keys\n+* to values), there are problems with that implementation,\n+* particularly when trying to keep the two TreeMaps synchronized with\n+* each other. And if the data contained in the TreeMaps is large, the\n+* cost of redundant storage becomes significant.<p>\n+*\n+* This solution keeps the data properly synchronized and minimizes\n+* the data storage. The red-black algorithm is based on TreeMap's,\n+* but has been modified to simultaneously map a tree node by key and\n+* by value. This doubles the cost of put operations (but so does\n+* using two TreeMaps), and nearly doubles the cost of remove\n+* operations (there is a savings in that the lookup of the node to be\n+* removed only has to be performed once). And since only one node\n+* contains the key and value, storage is significantly less than that\n+* required by two TreeMaps.<p>\n+*\n+* There are some limitations placed on data kept in this Map. The\n+* biggest one is this:<p>\n+*\n+* When performing a put operation, neither the key nor the value may\n+* already exist in the Map. In the java.util Map implementations\n+* (HashMap, TreeMap), you can perform a put with an already mapped\n+* key, and neither cares about duplicate values at all ... but this\n+* implementation's put method with throw an IllegalArgumentException\n+* if either the key or the value is already in the Map.<p>\n+*\n+* Obviously, that same restriction (and consequence of failing to\n+* heed that restriction) applies to the putAll method.<p>\n+*\n+* The Map.Entry instances returned by the appropriate methods will\n+* not allow setValue() and will throw an\n+* UnsupportedOperationException on attempts to call that method.<p>\n+*\n+* New methods are added to take advantage of the fact that values are\n+* kept sorted independently of their keys:<p>\n+*\n+* Object getKeyForValue(Object value) is the opposite of get; it\n+* takes a value and returns its key, if any.<p>\n+*\n+* Object removeValue(Object value) finds and removes the specified\n+* value and returns the now un-used key.<p>\n+*\n+* Set entrySetByValue() returns the Map.Entry's in a Set whose\n+* iterator will iterate over the Map.Entry's in ascending order by\n+* their corresponding values.<p>\n+*\n+* Set keySetByValue() returns the keys in a Set whose iterator will\n+* iterate over the keys in ascending order by their corresponding\n+* values.<p>\n+*\n+* Collection valuesByValue() returns the values in a Collection whose\n+* iterator will iterate over the values in ascending order.<p>\n+*\n+* @author Marc Johnson (marcj at users dot sourceforge dot net)\n+*/\n+\n+// final for performance\n+public final class DoubleOrderedMap extends AbstractMap {\n+\n+    private Node[]                rootNode           = new Node[]{ null,\n+                                                           null };\n+    private int                   nodeCount          = 0;\n+    private int                   modifications      = 0;\n+    private Set[]                 setOfKeys          = new Set[]{ null,\n+                                                           null };\n+    private Set[]                 setOfEntries       = new Set[]{ null,\n+                                                           null };\n+    private Collection[]          collectionOfValues = new Collection[]{ \n+null,\n+                                                                         \n+null };\n+    private static final int      KEY                = 0;\n+    private static final int      VALUE              = 1;\n+    private static final int      SUM_OF_INDICES     = KEY + VALUE;\n+    private static final int      FIRST_INDEX        = 0;\n+    private static final int      NUMBER_OF_INDICES  = 2;\n+    private static final String[] dataName           = new String[]{ \"key\",\n+                                                                     \"value\" \n+};\n+\n+    /**\n+     * Construct a new DoubleOrderedMap\n+     */\n+    public DoubleOrderedMap() {}\n+\n+    /**\n+     * Constructs a new DoubleOrderedMap from an existing Map, with keys and\n+     * values sorted\n+     *\n+     * @param map the map whose mappings are to be placed in this map.\n+     *\n+     * @exception ClassCastException if the keys in the map are not\n+     *                               Comparable, or are not mutually\n+     *                               comparable; also if the values in\n+     *                               the map are not Comparable, or\n+     *                               are not mutually Comparable\n+     * @exception NullPointerException if any key or value in the map\n+     *                                 is null\n+     * @exception IllegalArgumentException if there are duplicate keys\n+     *                                     or duplicate values in the\n+     *                                     map\n+     */\n+    public DoubleOrderedMap(final Map map)\n+            throws ClassCastException, NullPointerException,\n+                   IllegalArgumentException {\n+        putAll(map);\n+    }\n+\n+    /**\n+     * Returns the key to which this map maps the specified value.\n+     * Returns null if the map contains no mapping for this value.\n+     *\n+     * @param value value whose associated key is to be returned.\n+     *\n+     * @return the key to which this map maps the specified value, or\n+     *         null if the map contains no mapping for this value.\n+     *\n+     * @exception ClassCastException if the value is of an\n+     *                               inappropriate type for this map.\n+     * @exception NullPointerException if the value is null\n+     */\n+    public Object getKeyForValue(final Object value)\n+            throws ClassCastException, NullPointerException {\n+        return doGet((Comparable) value, VALUE);\n+    }\n+\n+    /**\n+     * Removes the mapping for this value from this map if present\n+     *\n+     * @param value value whose mapping is to be removed from the map.\n+     *\n+     * @return previous key associated with specified value, or null\n+     *         if there was no mapping for value.\n+     */\n+    public Object removeValue(final Object value) {\n+        return doRemove((Comparable) value, VALUE);\n+    }\n+\n+    /**\n+     * Returns a set view of the mappings contained in this map. Each\n+     * element in the returned set is a Map.Entry. The set is backed\n+     * by the map, so changes to the map are reflected in the set, and\n+     * vice-versa.  If the map is modified while an iteration over the\n+     * set is in progress, the results of the iteration are\n+     * undefined. The set supports element removal, which removes the\n+     * corresponding mapping from the map, via the Iterator.remove,\n+     * Set.remove, removeAll, retainAll and clear operations.  It does\n+     * not support the add or addAll operations.<p>\n+     *\n+     * The difference between this method and entrySet is that\n+     * entrySet's iterator() method returns an iterator that iterates\n+     * over the mappings in ascending order by key. This method's\n+     * iterator method iterates over the mappings in ascending order\n+     * by value.\n+     *\n+     * @return a set view of the mappings contained in this map.\n+     */\n+    public Set entrySetByValue() {\n+\n+        if (setOfEntries[VALUE] == null) {\n+            setOfEntries[VALUE] = new AbstractSet() {\n+\n+                public Iterator iterator() {\n+\n+                    return new DoubleOrderedMapIterator(VALUE) {\n+\n+                        protected Object doGetNext() {\n+                            return lastReturnedNode;\n+                        }\n+                    };\n+                }\n+\n+                public boolean contains(Object o) {\n+\n+                    if (!(o instanceof Map.Entry)) {\n+                        return false;\n+                    }\n+\n+                    Map.Entry entry = (Map.Entry) o;\n+                    Object    key   = entry.getKey();\n+                    Node      node  = lookup((Comparable) entry.getValue(),\n+                                             VALUE);\n+\n+                    return (node != null) && node.getData(KEY).equals(key);\n+                }\n+\n+                public boolean remove(Object o) {\n+\n+                    if (!(o instanceof Map.Entry)) {\n+                        return false;\n+                    }\n+\n+                    Map.Entry entry = (Map.Entry) o;\n+                    Object    key   = entry.getKey();\n+                    Node      node  = lookup((Comparable) entry.getValue(),\n+                                             VALUE);\n+\n+                    if ((node != null) && node.getData(KEY).equals(key)) {\n+                        doRedBlackDelete(node);\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+\n+                public int size() {\n+                    return DoubleOrderedMap.this.size();\n+                }\n+\n+                public void clear() {\n+                    DoubleOrderedMap.this.clear();\n+                }\n+            };\n+        }\n+\n+        return setOfEntries[VALUE];\n+    }\n+\n+    /**\n+     * Returns a set view of the keys contained in this map.  The set\n+     * is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an\n+     * iteration over the set is in progress, the results of the\n+     * iteration are undefined. The set supports element removal,\n+     * which removes the corresponding mapping from the map, via the\n+     * Iterator.remove, Set.remove, removeAll, retainAll, and clear\n+     * operations. It does not support the add or addAll\n+     * operations.<p>\n+     *\n+     * The difference between this method and keySet is that keySet's\n+     * iterator() method returns an iterator that iterates over the\n+     * keys in ascending order by key. This method's iterator method\n+     * iterates over the keys in ascending order by value.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set keySetByValue() {\n+\n+        if (setOfKeys[VALUE] == null) {\n+            setOfKeys[VALUE] = new AbstractSet() {\n+\n+                public Iterator iterator() {\n+\n+                    return new DoubleOrderedMapIterator(VALUE) {\n+\n+                        protected Object doGetNext() {\n+                            return lastReturnedNode.getData(KEY);\n+                        }\n+                    };\n+                }\n+\n+                public int size() {\n+                    return DoubleOrderedMap.this.size();\n+                }\n+\n+                public boolean contains(Object o) {\n+                    return containsKey(o);\n+                }\n+\n+                public boolean remove(Object o) {\n+\n+                    int oldnodeCount = nodeCount;\n+\n+                    DoubleOrderedMap.this.remove(o);\n+\n+                    return nodeCount != oldnodeCount;\n+                }\n+\n+                public void clear() {\n+                    DoubleOrderedMap.this.clear();\n+                }\n+            };\n+        }\n+\n+        return setOfKeys[VALUE];\n+    }\n+\n+    /**\n+     * Returns a collection view of the values contained in this\n+     * map. The collection is backed by the map, so changes to the map\n+     * are reflected in the collection, and vice-versa. If the map is\n+     * modified while an iteration over the collection is in progress,\n+     * the results of the iteration are undefined. The collection\n+     * supports element removal, which removes the corresponding\n+     * mapping from the map, via the Iterator.remove,\n+     * Collection.remove, removeAll, retainAll and clear operations.\n+     * It does not support the add or addAll operations.<p>\n+     *\n+     * The difference between this method and values is that values's\n+     * iterator() method returns an iterator that iterates over the\n+     * values in ascending order by key. This method's iterator method\n+     * iterates over the values in ascending order by key.\n+     *\n+     * @return a collection view of the values contained in this map.\n+     */\n+    public Collection valuesByValue() {\n+\n+        if (collectionOfValues[VALUE] == null) {\n+            collectionOfValues[VALUE] = new AbstractCollection() {\n+\n+                public Iterator iterator() {\n+\n+                    return new DoubleOrderedMapIterator(VALUE) {\n+\n+                        protected Object doGetNext() {\n+                            return lastReturnedNode.getData(VALUE);\n+                        }\n+                    };\n+                }\n+\n+                public int size() {\n+                    return DoubleOrderedMap.this.size();\n+                }\n+\n+                public boolean contains(Object o) {\n+                    return containsValue(o);\n+                }\n+\n+                public boolean remove(Object o) {\n+\n+                    int oldnodeCount = nodeCount;\n+\n+                    removeValue(o);\n+\n+                    return nodeCount != oldnodeCount;\n+                }\n+\n+                public boolean removeAll(Collection c) {\n+\n+                    boolean  modified = false;\n+                    Iterator iter     = c.iterator();\n+\n+                    while (iter.hasNext()) {\n+                        if (removeValue(iter.next()) != null) {\n+                            modified = true;\n+                        }\n+                    }\n+\n+                    return modified;\n+                }\n+\n+                public void clear() {\n+                    DoubleOrderedMap.this.clear();\n+                }\n+            };\n+        }\n+\n+        return collectionOfValues[VALUE];\n+    }\n+\n+    /**\n+     * common remove logic (remove by key or remove by value)\n+     *\n+     * @param o the key, or value, that we're looking for\n+     * @param index KEY or VALUE\n+     *\n+     * @return the key, if remove by value, or the value, if remove by\n+     *         key. null if the specified key or value could not be\n+     *         found\n+     */\n+    private Object doRemove(final Comparable o, final int index) {\n+\n+        Node   node = lookup(o, index);\n+        Object rval = null;\n+\n+        if (node != null) {\n+            rval = node.getData(oppositeIndex(index));\n+\n+            doRedBlackDelete(node);\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * common get logic, used to get by key or get by value\n+     *\n+     * @param o the key or value that we're looking for\n+     * @param index KEY or VALUE\n+     *\n+     * @return the key (if the value was mapped) or the value (if the\n+     *         key was mapped); null if we couldn't find the specified\n+     *         object\n+     */\n+    private Object doGet(final Comparable o, final int index) {\n+\n+        checkNonNullComparable(o, index);\n+\n+        Node node = lookup(o, index);\n+\n+        return ((node == null)\n+                ? null\n+                : node.getData(oppositeIndex(index)));\n+    }\n+\n+    /**\n+     * Get the opposite index of the specified index\n+     *\n+     * @param index KEY or VALUE\n+     *\n+     * @return VALUE (if KEY was specified), else KEY\n+     */\n+    private int oppositeIndex(final int index) {\n+\n+        // old trick ... to find the opposite of a value, m or n,\n+        // subtract the value from the sum of the two possible\n+        // values. (m + n) - m = n; (m + n) - n = m\n+        return SUM_OF_INDICES - index;\n+    }\n+\n+    /**\n+     * do the actual lookup of a piece of data\n+     *\n+     * @param data the key or value to be looked up\n+     * @param index KEY or VALUE\n+     *\n+     * @return the desired Node, or null if there is no mapping of the\n+     *         specified data\n+     */\n+    private Node lookup(final Comparable data, final int index) {\n+\n+        Node rval = null;\n+        Node node = rootNode[index];\n+\n+        while (node != null) {\n+            int cmp = compare(data, node.getData(index));\n+\n+            if (cmp == 0) {\n+                rval = node;\n+\n+                break;\n+            } else {\n+                node = (cmp < 0)\n+                       ? node.getLeft(index)\n+                       : node.getRight(index);\n+            }\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * Compare two objects\n+     *\n+     * @param o1 the first object\n+     * @param o2 the second object\n+     *\n+     * @return negative value if o1 < o2; 0 if o1 == o2; positive\n+     *         value if o1 > o2\n+     */\n+    private static int compare(final Comparable o1, final Comparable o2) {\n+        return ((Comparable) o1).compareTo(o2);\n+    }\n+\n+    /**\n+     * find the least node from a given node. very useful for starting\n+     * a sorting iterator ...\n+     *\n+     * @param node the node from which we will start searching\n+     * @param index KEY or VALUE\n+     *\n+     * @return the smallest node, from the specified node, in the\n+     *         specified mapping\n+     */\n+    private static Node leastNode(final Node node, final int index) {\n+\n+        Node rval = node;\n+\n+        if (rval != null) {\n+            while (rval.getLeft(index) != null) {\n+                rval = rval.getLeft(index);\n+            }\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index KEY or VALUE\n+     *\n+     * @return the specified node\n+     */\n+    private Node nextGreater(final Node node, final int index) {\n+\n+        Node rval = null;\n+\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getRight(index) != null) {\n+\n+            // everything to the node's right is larger. The least of\n+            // the right node's descendents is the next larger node\n+            rval = leastNode(node.getRight(index), index);\n+        } else {\n+\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose left child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's left\n+            // ... and that ancestor is the next greatest node\n+            Node parent = node.getParent(index);\n+            Node child  = node;\n+\n+            while ((parent != null) && (child == parent.getRight(index))) {\n+                child  = parent;\n+                parent = parent.getParent(index);\n+            }\n+\n+            rval = parent;\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * copy the color from one node to another, dealing with the fact\n+     * that one or both nodes may, in fact, be null\n+     *\n+     * @param from the node whose color we're copying; may be null\n+     * @param to the node whose color we're changing; may be null\n+     * @param index KEY or VALUE\n+     */\n+    private static void copyColor(final Node from, final Node to,\n+                                  final int index) {\n+\n+        if (to != null) {\n+            if (from == null) {\n+\n+                // by default, make it black\n+                to.setBlack(index);\n+            } else {\n+                to.copyColor(from, index);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * is the specified node red? if the node does not exist, no, it's\n+     * black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static boolean isRed(final Node node, final int index) {\n+\n+        return ((node == null)\n+                ? false\n+                : node.isRed(index));\n+    }\n+\n+    /**\n+     * is the specified black red? if the node does not exist, sure,\n+     * it's black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static boolean isBlack(final Node node, final int index) {\n+\n+        return ((node == null)\n+                ? true\n+                : node.isBlack(index));\n+    }\n+\n+    /**\n+     * force a node (if it exists) red\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static void makeRed(final Node node, final int index) {\n+\n+        if (node != null) {\n+            node.setRed(index);\n+        }\n+    }\n+\n+    /**\n+     * force a node (if it exists) black\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static void makeBlack(final Node node, final int index) {\n+\n+        if (node != null) {\n+            node.setBlack(index);\n+        }\n+    }\n+\n+    /**\n+     * get a node's grandparent. mind you, the node, its parent, or\n+     * its grandparent may not exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static Node getGrandParent(final Node node, final int index) {\n+        return getParent(getParent(node, index), index);\n+    }\n+\n+    /**\n+     * get a node's parent. mind you, the node, or its parent, may not\n+     * exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static Node getParent(final Node node, final int index) {\n+\n+        return ((node == null)\n+                ? null\n+                : node.getParent(index));\n+    }\n+\n+    /**\n+     * get a node's right child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static Node getRightChild(final Node node, final int index) {\n+\n+        return (node == null)\n+               ? null\n+               : node.getRight(index);\n+    }\n+\n+    /**\n+     * get a node's left child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static Node getLeftChild(final Node node, final int index) {\n+\n+        return (node == null)\n+               ? null\n+               : node.getLeft(index);\n+    }\n+\n+    /**\n+     * is this node its parent's left child? mind you, the node, or\n+     * its parent, may not exist. no problem. if the node doesn't\n+     * exist ... it's its non-existent parent's left child. If the\n+     * node does exist but has no parent ... no, we're not the\n+     * non-existent parent's left child. Otherwise (both the specified\n+     * node AND its parent exist), check.\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static boolean isLeftChild(final Node node, final int index) {\n+\n+        return (node == null)\n+               ? true\n+               : ((node.getParent(index) == null)\n+                  ? false\n+                  : (node == node.getParent(index).getLeft(index)));\n+    }\n+\n+    /**\n+     * is this node its parent's right child? mind you, the node, or\n+     * its parent, may not exist. no problem. if the node doesn't\n+     * exist ... it's its non-existent parent's right child. If the\n+     * node does exist but has no parent ... no, we're not the\n+     * non-existent parent's right child. Otherwise (both the\n+     * specified node AND its parent exist), check.\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index KEY or VALUE\n+     */\n+    private static boolean isRightChild(final Node node, final int index) {\n+\n+        return (node == null)\n+               ? true\n+               : ((node.getParent(index) == null)\n+                  ? false\n+                  : (node == node.getParent(index).getRight(index)));\n+    }\n+\n+    /**\n+     * do a rotate left. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index KEY or VALUE\n+     */\n+    private void rotateLeft(final Node node, final int index) {\n+\n+        Node rightChild = node.getRight(index);\n+\n+        node.setRight(rightChild.getLeft(index), index);\n+\n+        if (rightChild.getLeft(index) != null) {\n+            rightChild.getLeft(index).setParent(node, index);\n+        }\n+\n+        rightChild.setParent(node.getParent(index), index);\n+\n+        if (node.getParent(index) == null) {\n+\n+            // node was the root ... now its right child is the root\n+            rootNode[index] = rightChild;\n+        } else if (node.getParent(index).getLeft(index) == node) {\n+            node.getParent(index).setLeft(rightChild, index);\n+        } else {\n+            node.getParent(index).setRight(rightChild, index);\n+        }\n+\n+        rightChild.setLeft(node, index);\n+        node.setParent(rightChild, index);\n+    }\n+\n+    /**\n+     * do a rotate right. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index KEY or VALUE\n+     */\n+    private void rotateRight(final Node node, final int index) {\n+\n+        Node leftChild = node.getLeft(index);\n+\n+        node.setLeft(leftChild.getRight(index), index);\n+\n+        if (leftChild.getRight(index) != null) {\n+            leftChild.getRight(index).setParent(node, index);\n+        }\n+\n+        leftChild.setParent(node.getParent(index), index);\n+\n+        if (node.getParent(index) == null) {\n+\n+            // node was the root ... now its left child is the root\n+            rootNode[index] = leftChild;\n+        } else if (node.getParent(index).getRight(index) == node) {\n+            node.getParent(index).setRight(leftChild, index);\n+        } else {\n+            node.getParent(index).setLeft(leftChild, index);\n+        }\n+\n+        leftChild.setRight(node, index);\n+        node.setParent(leftChild, index);\n+    }\n+\n+    /**\n+     * complicated red-black insert stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizeable any more\n+     *\n+     * @param insertedNode the node to be inserted\n+     * @param index KEY or VALUE\n+     */\n+    private void doRedBlackInsert(final Node insertedNode, final int index) \n+{\n+\n+        Node currentNode = insertedNode;\n+\n+        makeRed(currentNode, index);\n+\n+        while ((currentNode != null) && (currentNode != rootNode[index])\n+                && (isRed(currentNode.getParent(index), index))) {\n+            if (isLeftChild(getParent(currentNode, index), index)) {\n+                Node y = getRightChild(getGrandParent(currentNode, index),\n+                                       index);\n+\n+                if (isRed(y, index)) {\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(y, index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    currentNode = getGrandParent(currentNode, index);\n+                } else {\n+                    if (isRightChild(currentNode, index)) {\n+                        currentNode = getParent(currentNode, index);\n+\n+                        rotateLeft(currentNode, index);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    if (getGrandParent(currentNode, index) != null) {\n+                        rotateRight(getGrandParent(currentNode, index),\n+                                    index);\n+                    }\n+                }\n+            } else {\n+\n+                // just like clause above, except swap left for right\n+                Node y = getLeftChild(getGrandParent(currentNode, index),\n+                                      index);\n+\n+                if (isRed(y, index)) {\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(y, index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    currentNode = getGrandParent(currentNode, index);\n+                } else {\n+                    if (isLeftChild(currentNode, index)) {\n+                        currentNode = getParent(currentNode, index);\n+\n+                        rotateRight(currentNode, index);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    if (getGrandParent(currentNode, index) != null) {\n+                        rotateLeft(getGrandParent(currentNode, index), \n+index);\n+                    }\n+                }\n+            }\n+        }\n+\n+        makeBlack(rootNode[index], index);\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizeable any more\n+     *\n+     * @param deletedNode the node to be deleted\n+     */\n+    private void doRedBlackDelete(final Node deletedNode) {\n+\n+        for (int index = FIRST_INDEX; index < NUMBER_OF_INDICES; index++) {\n+\n+            // if deleted node has both left and children, swap with\n+            // the next greater node\n+            if ((deletedNode.getLeft(index) != null)\n+                    && (deletedNode.getRight(index) != null)) {\n+                swapPosition(nextGreater(deletedNode, index), deletedNode,\n+                             index);\n+            }\n+\n+            Node replacement = ((deletedNode.getLeft(index) != null)\n+                                ? deletedNode.getLeft(index)\n+                                : deletedNode.getRight(index));\n+\n+            if (replacement != null) {\n+                replacement.setParent(deletedNode.getParent(index), index);\n+\n+                if (deletedNode.getParent(index) == null) {\n+                    rootNode[index] = replacement;\n+                } else if (deletedNode\n+                           == deletedNode.getParent(index).getLeft(index)) {\n+                    deletedNode.getParent(index).setLeft(replacement, \n+index);\n+                } else {\n+                    deletedNode.getParent(index).setRight(replacement, \n+index);\n+                }\n+\n+                deletedNode.setLeft(null, index);\n+                deletedNode.setRight(null, index);\n+                deletedNode.setParent(null, index);\n+\n+                if (isBlack(deletedNode, index)) {\n+                    doRedBlackDeleteFixup(replacement, index);\n+                }\n+            } else {\n+\n+                // replacement is null\n+                if (deletedNode.getParent(index) == null) {\n+\n+                    // empty tree\n+                    rootNode[index] = null;\n+                } else {\n+\n+                    // deleted node had no children\n+                    if (isBlack(deletedNode, index)) {\n+                        doRedBlackDeleteFixup(deletedNode, index);\n+                    }\n+\n+                    if (deletedNode.getParent(index) != null) {\n+                        if (deletedNode\n+                                == deletedNode.getParent(index)\n+                                    .getLeft(index)) {\n+                            deletedNode.getParent(index).setLeft(null, \n+index);\n+                        } else {\n+                            deletedNode.getParent(index).setRight(null,\n+                                                  index);\n+                        }\n+\n+                        deletedNode.setParent(null, index);\n+                    }\n+                }\n+            }\n+        }\n+\n+        shrink();\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizeable any more. This\n+     * rebalances the tree (somewhat, as red-black trees are not\n+     * perfectly balanced -- perfect balancing takes longer)\n+     *\n+     * @param replacementNode the node being replaced\n+     * @param index KEY or VALUE\n+     */\n+    private void doRedBlackDeleteFixup(final Node replacementNode,\n+                                       final int index) {\n+\n+        Node currentNode = replacementNode;\n+\n+        while ((currentNode != rootNode[index])\n+                && (isBlack(currentNode, index))) {\n+            if (isLeftChild(currentNode, index)) {\n+                Node siblingNode =\n+                    getRightChild(getParent(currentNode, index), index);\n+\n+                if (isRed(siblingNode, index)) {\n+                    makeBlack(siblingNode, index);\n+                    makeRed(getParent(currentNode, index), index);\n+                    rotateLeft(getParent(currentNode, index), index);\n+\n+                    siblingNode = getRightChild(getParent(currentNode, \n+index),\n+                                                index);\n+                }\n+\n+                if (isBlack(getLeftChild(siblingNode, index), index)\n+                        && isBlack(getRightChild(siblingNode, index),\n+                                   index)) {\n+                    makeRed(siblingNode, index);\n+\n+                    currentNode = getParent(currentNode, index);\n+                } else {\n+                    if (isBlack(getRightChild(siblingNode, index), index)) {\n+                        makeBlack(getLeftChild(siblingNode, index), index);\n+                        makeRed(siblingNode, index);\n+                        rotateRight(siblingNode, index);\n+\n+                        siblingNode =\n+                            getRightChild(getParent(currentNode, index),\n+                                          index);\n+                    }\n+\n+                    copyColor(getParent(currentNode, index), siblingNode,\n+                              index);\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(getRightChild(siblingNode, index), index);\n+                    rotateLeft(getParent(currentNode, index), index);\n+\n+                    currentNode = rootNode[index];\n+                }\n+            } else {\n+                Node siblingNode = getLeftChild(getParent(currentNode, \n+index),\n+                                                index);\n+\n+                if (isRed(siblingNode, index)) {\n+                    makeBlack(siblingNode, index);\n+                    makeRed(getParent(currentNode, index), index);\n+                    rotateRight(getParent(currentNode, index), index);\n+\n+                    siblingNode = getLeftChild(getParent(currentNode, \n+index),\n+                                               index);\n+                }\n+\n+                if (isBlack(getRightChild(siblingNode, index), index)\n+                        && isBlack(getLeftChild(siblingNode, index), index)) \n+{\n+                    makeRed(siblingNode, index);\n+\n+                    currentNode = getParent(currentNode, index);\n+                } else {\n+                    if (isBlack(getLeftChild(siblingNode, index), index)) {\n+                        makeBlack(getRightChild(siblingNode, index), index);\n+                        makeRed(siblingNode, index);\n+                        rotateLeft(siblingNode, index);\n+\n+                        siblingNode =\n+                            getLeftChild(getParent(currentNode, index),\n+                                         index);\n+                    }\n+\n+                    copyColor(getParent(currentNode, index), siblingNode,\n+                              index);\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(getLeftChild(siblingNode, index), index);\n+                    rotateRight(getParent(currentNode, index), index);\n+\n+                    currentNode = rootNode[index];\n+                }\n+            }\n+        }\n+\n+        makeBlack(currentNode, index);\n+    }\n+\n+    /**\n+     * swap two nodes (except for their content), taking care of\n+     * special cases where one is the other's parent ... hey, it\n+     * happens.\n+     *\n+     * @param x one node\n+     * @param y another node\n+     * @param index KEY or VALUE\n+     */\n+    private void swapPosition(final Node x, final Node y, final int index) {\n+\n+        // Save initial values.\n+        Node    xFormerParent     = x.getParent(index);\n+        Node    xFormerLeftChild  = x.getLeft(index);\n+        Node    xFormerRightChild = x.getRight(index);\n+        Node    yFormerParent     = y.getParent(index);\n+        Node    yFormerLeftChild  = y.getLeft(index);\n+        Node    yFormerRightChild = y.getRight(index);\n+        boolean xWasLeftChild     =\n+            (x.getParent(index) != null)\n+            && (x == x.getParent(index).getLeft(index));\n+        boolean yWasLeftChild     =\n+            (y.getParent(index) != null)\n+            && (y == y.getParent(index).getLeft(index));\n+\n+        // Swap, handling special cases of one being the other's parent.\n+        if (x == yFormerParent) {    // x was y's parent\n+            x.setParent(y, index);\n+\n+            if (yWasLeftChild) {\n+                y.setLeft(x, index);\n+                y.setRight(xFormerRightChild, index);\n+            } else {\n+                y.setRight(x, index);\n+                y.setLeft(xFormerLeftChild, index);\n+            }\n+        } else {\n+            x.setParent(yFormerParent, index);\n+\n+            if (yFormerParent != null) {\n+                if (yWasLeftChild) {\n+                    yFormerParent.setLeft(x, index);\n+                } else {\n+                    yFormerParent.setRight(x, index);\n+                }\n+            }\n+\n+            y.setLeft(xFormerLeftChild, index);\n+            y.setRight(xFormerRightChild, index);\n+        }\n+\n+        if (y == xFormerParent) {    // y was x's parent\n+            y.setParent(x, index);\n+\n+            if (xWasLeftChild) {\n+                x.setLeft(y, index);\n+                x.setRight(yFormerRightChild, index);\n+            } else {\n+                x.setRight(y, index);\n+                x.setLeft(yFormerLeftChild, index);\n+            }\n+        } else {\n+            y.setParent(xFormerParent, index);\n+\n+            if (xFormerParent != null) {\n+                if (xWasLeftChild) {\n+                    xFormerParent.setLeft(y, index);\n+                } else {\n+                    xFormerParent.setRight(y, index);\n+                }\n+            }\n+\n+            x.setLeft(yFormerLeftChild, index);\n+            x.setRight(yFormerRightChild, index);\n+        }\n+\n+        // Fix children's parent pointers\n+        if (x.getLeft(index) != null) {\n+            x.getLeft(index).setParent(x, index);\n+        }\n+\n+        if (x.getRight(index) != null) {\n+            x.getRight(index).setParent(x, index);\n+        }\n+\n+        if (y.getLeft(index) != null) {\n+            y.getLeft(index).setParent(y, index);\n+        }\n+\n+        if (y.getRight(index) != null) {\n+            y.getRight(index).setParent(y, index);\n+        }\n+\n+        x.swapColors(y, index);\n+\n+        // Check if root changed\n+        if (rootNode[index] == x) {\n+            rootNode[index] = y;\n+        } else if (rootNode[index] == y) {\n+            rootNode[index] = x;\n+        }\n+    }\n+\n+    /**\n+     * check if an object is fit to be proper input ... has to be\n+     * Comparable and non-null\n+     *\n+     * @param o the object being checked\n+     * @param index KEY or VALUE (used to put the right word in the\n+     *              exception message)\n+     *\n+     * @exception NullPointerException if o is null\n+     * @exception ClassCastException if o is not Comparable\n+     */\n+    private static void checkNonNullComparable(final Object o,\n+                                               final int index) {\n+\n+        if (o == null) {\n+            throw new NullPointerException(dataName[index]\n+                                           + \" cannot be null\");\n+        }\n+\n+        if (!(o instanceof Comparable)) {\n+            throw new ClassCastException(dataName[index]\n+                                         + \" must be Comparable\");\n+        }\n+    }\n+\n+    /**\n+     * check a key for validity (non-null and implements Comparable)\n+     *\n+     * @param key the key to be checked\n+     *\n+     * @exception NullPointerException if key is null\n+     * @exception ClassCastException if key is not Comparable\n+     */\n+    private static void checkKey(final Object key) {\n+        checkNonNullComparable(key, KEY);\n+    }\n+\n+    /**\n+     * check a value for validity (non-null and implements Comparable)\n+     *\n+     * @param value the value to be checked\n+     *\n+     * @exception NullPointerException if value is null\n+     * @exception ClassCastException if value is not Comparable\n+     */\n+    private static void checkValue(final Object value) {\n+        checkNonNullComparable(value, VALUE);\n+    }\n+\n+    /**\n+     * check a key and a value for validity (non-null and implements\n+     * Comparable)\n+     *\n+     * @param key the key to be checked\n+     * @param value the value to be checked\n+     *\n+     * @exception NullPointerException if key or value is null\n+     * @exception ClassCastException if key or value is not Comparable\n+     */\n+    private static void checkKeyAndValue(final Object key,\n+                                         final Object value) {\n+        checkKey(key);\n+        checkValue(value);\n+    }\n+\n+    /**\n+     * increment the modification count -- used to check for\n+     * concurrent modification of the map through the map and through\n+     * an Iterator from one of its Set or Collection views\n+     */\n+    private void modify() {\n+        modifications++;\n+    }\n+\n+    /**\n+     * bump up the size and note that the map has changed\n+     */\n+    private void grow() {\n+\n+        modify();\n+\n+        nodeCount++;\n+    }\n+\n+    /**\n+     * decrement the size and note that the map has changed\n+     */\n+    private void shrink() {\n+\n+        modify();\n+\n+        nodeCount--;\n+    }\n+\n+    /**\n+     * insert a node by its value\n+     *\n+     * @param newNode the node to be inserted\n+     *\n+     * @exception IllegalArgumentException if the node already exists\n+     *                                     in the value mapping\n+     */\n+    private void insertValue(final Node newNode)\n+            throws IllegalArgumentException {\n+\n+        Node node = rootNode[VALUE];\n+\n+        while (true) {\n+            int cmp = compare(newNode.getData(VALUE), node.getData(VALUE));\n+\n+            if (cmp == 0) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot store a duplicate value (\\\"\"\n+                    + newNode.getData(VALUE) + \"\\\") in this Map\");\n+            } else if (cmp < 0) {\n+                if (node.getLeft(VALUE) != null) {\n+                    node = node.getLeft(VALUE);\n+                } else {\n+                    node.setLeft(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            } else {    // cmp > 0\n+                if (node.getRight(VALUE) != null) {\n+                    node = node.getRight(VALUE);\n+                } else {\n+                    node.setRight(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /* ********** START implementation of Map ********** */\n+\n+    /**\n+     * Returns the number of key-value mappings in this map. If the\n+     * map contains more than Integer.MAXVALUE elements, returns\n+     * Integer.MAXVALUE.\n+     *\n+     * @return the number of key-value mappings in this map.\n+     */\n+    public int size() {\n+        return nodeCount;\n+    }\n+\n+    /**\n+     * Returns true if this map contains a mapping for the specified\n+     * key.\n+     *\n+     * @param key key whose presence in this map is to be tested.\n+     *\n+     * @return true if this map contains a mapping for the specified\n+     *         key.\n+     *\n+     * @exception ClassCastException if the key is of an inappropriate\n+     *                               type for this map.\n+     * @exception NullPointerException if the key is null\n+     */\n+    public boolean containsKey(final Object key)\n+            throws ClassCastException, NullPointerException {\n+\n+        checkKey(key);\n+\n+        return lookup((Comparable) key, KEY) != null;\n+    }\n+\n+    /**\n+     * Returns true if this map maps one or more keys to the\n+     * specified value.\n+     *\n+     * @param value value whose presence in this map is to be tested.\n+     *\n+     * @return true if this map maps one or more keys to the specified\n+     *         value.\n+     */\n+    public boolean containsValue(final Object value) {\n+\n+        checkValue(value);\n+\n+        return lookup((Comparable) value, VALUE) != null;\n+    }\n+\n+    /**\n+     * Returns the value to which this map maps the specified\n+     * key. Returns null if the map contains no mapping for this key.\n+     *\n+     * @param key key whose associated value is to be returned.\n+     *\n+     * @return the value to which this map maps the specified key, or\n+     *         null if the map contains no mapping for this key.\n+     *\n+     * @exception ClassCastException if the key is of an inappropriate\n+     *                               type for this map.\n+     * @exception NullPointerException if the key is null\n+     */\n+    public Object get(final Object key)\n+            throws ClassCastException, NullPointerException {\n+        return doGet((Comparable) key, KEY);\n+    }\n+\n+    /**\n+     * Associates the specified value with the specified key in this\n+     * map.\n+     *\n+     * @param key key with which the specified value is to be\n+     *            associated.\n+     * @param value value to be associated with the specified key.\n+     *\n+     * @return null\n+     *\n+     * @exception ClassCastException if the class of the specified key\n+     *                               or value prevents it from being\n+     *                               stored in this map.\n+     * @exception NullPointerException if the specified key or value\n+     *                                 is null\n+     * @exception IllegalArgumentException if the key duplicates an\n+     *                                     existing key, or if the\n+     *                                     value duplicates an\n+     *                                     existing value\n+     */\n+    public Object put(final Object key, final Object value)\n+            throws ClassCastException, NullPointerException,\n+                   IllegalArgumentException {\n+\n+        checkKeyAndValue(key, value);\n+\n+        Node node = rootNode[KEY];\n+\n+        if (node == null) {\n+            Node root = new Node((Comparable) key, (Comparable) value);\n+\n+            rootNode[KEY]   = root;\n+            rootNode[VALUE] = root;\n+\n+            grow();\n+        } else {\n+            while (true) {\n+                int cmp = compare((Comparable) key, node.getData(KEY));\n+\n+                if (cmp == 0) {\n+                    throw new IllegalArgumentException(\n+                        \"Cannot store a duplicate key (\\\"\" + key\n+                        + \"\\\") in this Map\");\n+                } else if (cmp < 0) {\n+                    if (node.getLeft(KEY) != null) {\n+                        node = node.getLeft(KEY);\n+                    } else {\n+                        Node newNode = new Node((Comparable) key,\n+                                                (Comparable) value);\n+\n+                        insertValue(newNode);\n+                        node.setLeft(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+\n+                        break;\n+                    }\n+                } else {    // cmp > 0\n+                    if (node.getRight(KEY) != null) {\n+                        node = node.getRight(KEY);\n+                    } else {\n+                        Node newNode = new Node((Comparable) key,\n+                                                (Comparable) value);\n+\n+                        insertValue(newNode);\n+                        node.setRight(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the mapping for this key from this map if present\n+     *\n+     * @param key key whose mapping is to be removed from the map.\n+     *\n+     * @return previous value associated with specified key, or null\n+     *         if there was no mapping for key.\n+     */\n+    public Object remove(final Object key) {\n+        return doRemove((Comparable) key, KEY);\n+    }\n+\n+    /**\n+     * Removes all mappings from this map\n+     */\n+    public void clear() {\n+\n+        modify();\n+\n+        nodeCount   = 0;\n+        rootNode[KEY]   = null;\n+        rootNode[VALUE] = null;\n+    }\n+\n+    /**\n+     * Returns a set view of the keys contained in this map.  The set\n+     * is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an\n+     * iteration over the set is in progress, the results of the\n+     * iteration are undefined. The set supports element removal,\n+     * which removes the corresponding mapping from the map, via the\n+     * Iterator.remove, Set.remove, removeAll, retainAll, and clear\n+     * operations.  It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set keySet() {\n+\n+        if (setOfKeys[KEY] == null) {\n+            setOfKeys[KEY] = new AbstractSet() {\n+\n+                public Iterator iterator() {\n+\n+                    return new DoubleOrderedMapIterator(KEY) {\n+\n+                        protected Object doGetNext() {\n+                            return lastReturnedNode.getData(KEY);\n+                        }\n+                    };\n+                }\n+\n+                public int size() {\n+                    return DoubleOrderedMap.this.size();\n+                }\n+\n+                public boolean contains(Object o) {\n+                    return containsKey(o);\n+                }\n+\n+                public boolean remove(Object o) {\n+\n+                    int oldNodeCount = nodeCount;\n+\n+                    DoubleOrderedMap.this.remove(o);\n+\n+                    return nodeCount != oldNodeCount;\n+                }\n+\n+                public void clear() {\n+                    DoubleOrderedMap.this.clear();\n+                }\n+            };\n+        }\n+\n+        return setOfKeys[KEY];\n+    }\n+\n+    /**\n+     * Returns a collection view of the values contained in this\n+     * map. The collection is backed by the map, so changes to the map\n+     * are reflected in the collection, and vice-versa. If the map is\n+     * modified while an iteration over the collection is in progress,\n+     * the results of the iteration are undefined. The collection\n+     * supports element removal, which removes the corresponding\n+     * mapping from the map, via the Iterator.remove,\n+     * Collection.remove, removeAll, retainAll and clear operations.\n+     * It does not support the add or addAll operations.\n+     *\n+     * @return a collection view of the values contained in this map.\n+     */\n+    public Collection values() {\n+\n+        if (collectionOfValues[KEY] == null) {\n+            collectionOfValues[KEY] = new AbstractCollection() {\n+\n+                public Iterator iterator() {\n+\n+                    return new DoubleOrderedMapIterator(KEY) {\n+\n+                        protected Object doGetNext() {\n+                            return lastReturnedNode.getData(VALUE);\n+                        }\n+                    };\n+                }\n+\n+                public int size() {\n+                    return DoubleOrderedMap.this.size();\n+                }\n+\n+                public boolean contains(Object o) {\n+                    return containsValue(o);\n+                }\n+\n+                public boolean remove(Object o) {\n+\n+                    int oldNodeCount = nodeCount;\n+\n+                    removeValue(o);\n+\n+                    return nodeCount != oldNodeCount;\n+                }\n+\n+                public boolean removeAll(Collection c) {\n+\n+                    boolean  modified = false;\n+                    Iterator iter     = c.iterator();\n+\n+                    while (iter.hasNext()) {\n+                        if (removeValue(iter.next()) != null) {\n+                            modified = true;\n+                        }\n+                    }\n+\n+                    return modified;\n+                }\n+\n+                public void clear() {\n+                    DoubleOrderedMap.this.clear();\n+                }\n+            };\n+        }\n+\n+        return collectionOfValues[KEY];\n+    }\n+\n+    /**\n+     * Returns a set view of the mappings contained in this map. Each\n+     * element in the returned set is a Map.Entry. The set is backed\n+     * by the map, so changes to the map are reflected in the set, and\n+     * vice-versa.  If the map is modified while an iteration over the\n+     * set is in progress, the results of the iteration are\n+     * undefined. The set supports element removal, which removes the\n+     * corresponding mapping from the map, via the Iterator.remove,\n+     * Set.remove, removeAll, retainAll and clear operations.  It does\n+     * not support the add or addAll operations.\n+     *\n+     * @return a set view of the mappings contained in this map.\n+     */\n+    public Set entrySet() {\n+\n+        if (setOfEntries[KEY] == null) {\n+            setOfEntries[KEY] = new AbstractSet() {\n+\n+                public Iterator iterator() {\n+\n+                    return new DoubleOrderedMapIterator(KEY) {\n+\n+                        protected Object doGetNext() {\n+                            return lastReturnedNode;\n+                        }\n+                    };\n+                }\n+\n+                public boolean contains(Object o) {\n+\n+                    if (!(o instanceof Map.Entry)) {\n+                        return false;\n+                    }\n+\n+                    Map.Entry entry = (Map.Entry) o;\n+                    Object    value = entry.getValue();\n+                    Node      node  = lookup((Comparable) entry.getKey(),\n+                                             KEY);\n+\n+                    return (node != null)\n+                           && node.getData(VALUE).equals(value);\n+                }\n+\n+                public boolean remove(Object o) {\n+\n+                    if (!(o instanceof Map.Entry)) {\n+                        return false;\n+                    }\n+\n+                    Map.Entry entry = (Map.Entry) o;\n+                    Object    value = entry.getValue();\n+                    Node      node  = lookup((Comparable) entry.getKey(),\n+                                             KEY);\n+\n+                    if ((node != null) && node.getData(VALUE).equals(value)) \n+{\n+                        doRedBlackDelete(node);\n+\n+                        return true;\n+                    }\n+\n+                    return false;\n+                }\n+\n+                public int size() {\n+                    return DoubleOrderedMap.this.size();\n+                }\n+\n+                public void clear() {\n+                    DoubleOrderedMap.this.clear();\n+                }\n+            };\n+        }\n+\n+        return setOfEntries[KEY];\n+    }\n+\n+    /* **********  END  implementation of Map ********** */\n+    private abstract class DoubleOrderedMapIterator implements Iterator {\n+\n+        private int    expectedModifications;\n+        protected Node lastReturnedNode;\n+        private Node   nextNode;\n+        private int    iteratorType;\n+\n+        /**\n+         * Constructor\n+         *\n+         * @param type\n+         */\n+        DoubleOrderedMapIterator(final int type) {\n+\n+            iteratorType          = type;\n+            expectedModifications = DoubleOrderedMap.this.modifications;\n+            lastReturnedNode      = null;\n+            nextNode              = leastNode(rootNode[iteratorType],\n+                                              iteratorType);\n+        }\n+\n+        /**\n+         * @return 'next', whatever that means for a given kind of\n+         *         DoubleOrderedMapIterator\n+         */\n+        protected abstract Object doGetNext();\n+\n+        /* ********** START implementation of Iterator ********** */\n+\n+        /**\n+         * @return true if the iterator has more elements.\n+         */\n+        public final boolean hasNext() {\n+            return nextNode != null;\n+        }\n+\n+        /**\n+         * @return the next element in the iteration.\n+         *\n+         * @exception NoSuchElementException if iteration has no more\n+         *                                   elements.\n+         * @exception ConcurrentModificationException if the\n+         *                                            DoubleOrderedMap is\n+         *                                            modified behind\n+         *                                            the iterator's\n+         *                                            back\n+         */\n+        public final Object next()\n+                throws NoSuchElementException,\n+                       ConcurrentModificationException {\n+\n+            if (nextNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+\n+            lastReturnedNode = nextNode;\n+            nextNode         = nextGreater(nextNode, iteratorType);\n+\n+            return doGetNext();\n+        }\n+\n+        /**\n+         * Removes from the underlying collection the last element\n+         * returned by the iterator. This method can be called only\n+         * once per call to next. The behavior of an iterator is\n+         * unspecified if the underlying collection is modified while\n+         * the iteration is in progress in any way other than by\n+         * calling this method.\n+         *\n+         * @exception IllegalStateException if the next method has not\n+         *                                  yet been called, or the\n+         *                                  remove method has already\n+         *                                  been called after the last\n+         *                                  call to the next method.\n+         * @exception ConcurrentModificationException if the\n+         *                                            DoubleOrderedMap is\n+         *                                            modified behind\n+         *                                            the iterator's\n+         *                                            back\n+         */\n+        public final void remove()\n+                throws IllegalStateException,\n+                       ConcurrentModificationException {\n+\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException();\n+            }\n+\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+\n+            doRedBlackDelete(lastReturnedNode);\n+\n+            expectedModifications++;\n+\n+            lastReturnedNode = null;\n+        }\n+\n+        /* **********  END  implementation of Iterator ********** */\n+    }    // end private abstract class DoubleOrderedMapIterator\n+\n+    // final for performance\n+    private static final class Node implements Map.Entry {\n+\n+        private Comparable[] data;\n+        private Node[]       leftNode;\n+        private Node[]       rightNode;\n+        private Node[]       parentNode;\n+        private boolean[]    blackColor;\n+        private int          hashcodeValue;\n+        private boolean      calculatedHashCode;\n+\n+        /**\n+         * Make a new cell with given key and value, and with null\n+         * links, and black (true) colors.\n+         *\n+         * @param key\n+         * @param value\n+         */\n+        Node(final Comparable key, final Comparable value) {\n+\n+            data               = new Comparable[]{ key, value };\n+            leftNode           = new Node[]{ null, null };\n+            rightNode          = new Node[]{ null, null };\n+            parentNode         = new Node[]{ null, null };\n+            blackColor         = new boolean[]{ true, true };\n+            calculatedHashCode = false;\n+        }\n+\n+        /**\n+         * get the specified data\n+         *\n+         * @param index KEY or VALUE\n+         *\n+         * @return the key or value\n+         */\n+        private Comparable getData(final int index) {\n+            return data[index];\n+        }\n+\n+        /**\n+         * Set this node's left node\n+         *\n+         * @param node the new left node\n+         * @param index KEY or VALUE\n+         */\n+        private void setLeft(final Node node, final int index) {\n+            leftNode[index] = node;\n+        }\n+\n+        /**\n+         * get the left node\n+         *\n+         * @param index KEY or VALUE\n+         *\n+         * @return the left node -- may be null\n+         */\n+        private Node getLeft(final int index) {\n+            return leftNode[index];\n+        }\n+\n+        /**\n+         * Set this node's right node\n+         *\n+         * @param node the new right node\n+         * @param index KEY or VALUE\n+         */\n+        private void setRight(final Node node, final int index) {\n+            rightNode[index] = node;\n+        }\n+\n+        /**\n+         * get the right node\n+         *\n+         * @param index KEY or VALUE\n+         *\n+         * @return the right node -- may be null\n+         */\n+        private Node getRight(final int index) {\n+            return rightNode[index];\n+        }\n+\n+        /**\n+         * Set this node's parent node\n+         *\n+         * @param node the new parent node\n+         * @param index KEY or VALUE\n+         */\n+        private void setParent(final Node node, final int index) {\n+            parentNode[index] = node;\n+        }\n+\n+        /**\n+         * get the parent node\n+         *\n+         * @param index KEY or VALUE\n+         *\n+         * @return the parent node -- may be null\n+         */\n+        private Node getParent(final int index) {\n+            return parentNode[index];\n+        }\n+\n+        /**\n+         * exchange colors with another node\n+         *\n+         * @param node the node to swap with\n+         * @param index KEY or VALUE\n+         */\n+        private void swapColors(final Node node, final int index) {\n+\n+            // Swap colors -- old hacker's trick\n+            blackColor[index]      ^= node.blackColor[index];\n+            node.blackColor[index] ^= blackColor[index];\n+            blackColor[index]      ^= node.blackColor[index];\n+        }\n+\n+        /**\n+         * is this node black?\n+         *\n+         * @param index KEY or VALUE\n+         *\n+         * @return true if black (which is represented as a true boolean)\n+         */\n+        private boolean isBlack(final int index) {\n+            return blackColor[index];\n+        }\n+\n+        /**\n+         * is this node red?\n+         *\n+         * @param index KEY or VALUE\n+         *\n+         * @return true if non-black\n+         */\n+        private boolean isRed(final int index) {\n+            return !blackColor[index];\n+        }\n+\n+        /**\n+         * make this node black\n+         *\n+         * @param index KEY or VALUE\n+         */\n+        private void setBlack(final int index) {\n+            blackColor[index] = true;\n+        }\n+\n+        /**\n+         * make this node red\n+         *\n+         * @param index KEY or VALUE\n+         */\n+        private void setRed(final int index) {\n+            blackColor[index] = false;\n+        }\n+\n+        /**\n+         * make this node the same color as another\n+         *\n+         * @param node the node whose color we're adopting\n+         * @param index KEY or VALUE\n+         */\n+        private void copyColor(final Node node, final int index) {\n+            blackColor[index] = node.blackColor[index];\n+        }\n+\n+        /* ********** START implementation of Map.Entry ********** */\n+\n+        /**\n+         * @return the key corresponding to this entry.\n+         */\n+        public Object getKey() {\n+            return data[KEY];\n+        }\n+\n+        /**\n+         * @return the value corresponding to this entry.\n+         */\n+        public Object getValue() {\n+            return data[VALUE];\n+        }\n+\n+        /**\n+         * Optional operation that is not permitted in this\n+         * implementation\n+         *\n+         * @param ignored\n+         *\n+         * @return does not return\n+         *\n+         * @exception UnsupportedOperationException\n+         */\n+        public Object setValue(Object ignored)\n+                throws UnsupportedOperationException {\n+            throw new UnsupportedOperationException(\n+                \"Map.Entry.setValue is not supported\");\n+        }\n+\n+        /**\n+         * Compares the specified object with this entry for equality.\n+         * Returns true if the given object is also a map entry and\n+         * the two entries represent the same mapping.\n+         *\n+         * @param o object to be compared for equality with this map\n+         *          entry.\n+         * @return true if the specified object is equal to this map\n+         *         entry.\n+         */\n+        public boolean equals(Object o) {\n+\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            Map.Entry e = (Map.Entry) o;\n+\n+            return data[KEY].equals(e.getKey())\n+                   && data[VALUE].equals(e.getValue());\n+        }\n+\n+        /**\n+         * @return the hash code value for this map entry.\n+         */\n+        public int hashCode() {\n+\n+            if (!calculatedHashCode) {\n+                hashcodeValue      = data[KEY].hashCode()\n+                                     ^ data[VALUE].hashCode();\n+                calculatedHashCode = true;\n+            }\n+\n+            return hashcodeValue;\n+        }\n+\n+        /* **********  END  implementation of Map.Entry ********** */\n+    }\n+}    // end public class DoubleOrderedMap\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/LocalTestNode.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/LocalTestNode.java,v 1.1 2002/01/20 04:36:08 craigmcc Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/01/20 04:36:08 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+\n+\n+/**\n+* Class LocalTestNode\n+*\n+* a helper class for TestDoubleOrderedMap\n+*\n+* @author Marc Johnson (marcj at users dot sourceforge dot net)\n+*/\n+class LocalTestNode implements Comparable {\n+\n+    private Comparable key;\n+    private Comparable value;\n+\n+    /**\n+     * construct a LocalTestNode\n+     *\n+     * @param key value used to create the key and value\n+     */\n+    LocalTestNode(final int key) {\n+        this.key   = new Integer(key);\n+        this.value = String.valueOf(key);\n+    }\n+\n+    /**\n+     * @param key the unique key associated with the current node.\n+     */\n+    void setKey(Comparable key) {\n+        this.key = key;\n+    }\n+\n+    /**\n+     * @return the unique key associated with the current node\n+     */\n+    Comparable getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * @param value the unique value associated with the current node.\n+     */\n+    void setValue(Comparable value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * @return the unique value associated with the current node\n+     */\n+    Comparable getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Method compareTo\n+     *\n+     * @param o\n+     *\n+     * @return\n+     */\n+    public int compareTo(Object o) {\n+\n+        LocalTestNode other = (LocalTestNode) o;\n+        int           rval  = getKey().compareTo(other.getKey());\n+\n+        if (rval == 0) {\n+            rval = getValue().compareTo(other.getValue());\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * Method equals\n+     *\n+     * @param o\n+     *\n+     * @return true if equal\n+     */\n+    public boolean equals(Object o) {\n+\n+        if (o == null) {\n+            return false;\n+        }\n+\n+        if (!(o.getClass().equals(this.getClass()))) {\n+            return false;\n+        }\n+\n+        LocalTestNode node = (LocalTestNode) o;\n+\n+        return (getKey().equals(node.getKey())\n+                && getValue().equals(node.getValue()));\n+    }\n+\n+    /**\n+     * @return hash code\n+     */\n+    public int hashCode() {\n+        return getKey().hashCode() ^ getValue().hashCode();\n+    }\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.13 2001/09/18 10:41:39 jstrachan Exp $\n- * $Revision: 1.13 $\n- * $Date: 2001/09/18 10:41:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.14 2002/01/20 04:36:08 craigmcc Exp $\n+ * $Revision: 1.14 $\n+ * $Date: 2002/01/20 04:36:08 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.13 2001/09/18 10:41:39 jstrachan Exp $\n+ * @version $Id: TestAll.java,v 1.14 2002/01/20 04:36:08 craigmcc Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestSingletonIterator.suite());\n         suite.addTest(TestTreeBag.suite());\n         suite.addTest(TestTreeMap.suite());\n+        suite.addTest(TestDoubleOrderedMap.suite());\n         return suite;\n     }\n         \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.1 2002/01/20 04:36:08 craigmcc Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/01/20 04:36:08 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+\n+\n+import junit.framework.*;\n+\n+import java.util.*;\n+\n+\n+/**\n+* Class TestDoubleOrderedMap\n+*\n+* Test cases for DoubleOrderedMap\n+*\n+* @author Marc Johnson (marcj at users dot sourceforge dot net)\n+*/\n+public class TestDoubleOrderedMap extends TestCase {\n+\n+    /**\n+     * constructor\n+     *\n+     * @param name\n+     */\n+    public TestDoubleOrderedMap(final String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * create a suite of the tests in this class\n+     *\n+     * @return the test suite\n+     */\n+    public static Test suite() {\n+        return new TestSuite(TestDoubleOrderedMap.class);\n+    }\n+\n+    /**\n+     * test size() method\n+     */\n+    public void testSize() {\n+\n+        Map m = new DoubleOrderedMap();\n+\n+        assertEquals(0, m.size());\n+\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k].getValue());\n+            assertEquals(k + 1, m.size());\n+        }\n+\n+        int count = m.size();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.remove(nodes[k].getKey());\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+\n+            // failed remove should not affect size\n+            m.remove(nodes[k].getKey());\n+            assertEquals(count, m.size());\n+        }\n+    }\n+\n+    /**\n+     * test IsEmpty() method\n+     */\n+    public void testIsEmpty() {\n+\n+        Map m = new DoubleOrderedMap();\n+\n+        assertTrue(m.isEmpty());\n+\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k].getValue());\n+            assertTrue(!m.isEmpty());\n+        }\n+\n+        int count = m.size();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.remove(nodes[k].getKey());\n+\n+            --count;\n+\n+            if (count == 0) {\n+                assertTrue(m.isEmpty());\n+            } else {\n+                assertTrue(!m.isEmpty());\n+            }\n+\n+            // failed remove should not affect emptiness\n+            m.remove(nodes[k].getKey());\n+\n+            if (count == 0) {\n+                assertTrue(m.isEmpty());\n+            } else {\n+                assertTrue(!m.isEmpty());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * test containsKey() method\n+     */\n+    public void testContainsKey() {\n+\n+        Map m = new DoubleOrderedMap();\n+\n+        try {\n+            m.containsKey(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        try {\n+            m.containsKey(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        assertTrue(!m.containsKey(\"foo\"));\n+\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            assertTrue(m.containsKey(nodes[k].getKey()));\n+        }\n+\n+        assertTrue(!m.containsKey(new Integer(-1)));\n+\n+        try {\n+            m.containsKey(\"foo\");\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.remove(nodes[k].getKey());\n+            assertTrue(!m.containsKey(nodes[k].getKey()));\n+        }\n+    }\n+\n+    /**\n+     * test containsValue() method\n+     */\n+    public void testContainsValue() {\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            assertTrue(m.containsValue(nodes[k]));\n+        }\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.remove(nodes[k].getKey());\n+            assertTrue(!m.containsValue(nodes[k]));\n+        }\n+    }\n+\n+    /**\n+     * test get() method\n+     */\n+    public void testGet() {\n+\n+        Map m = new DoubleOrderedMap();\n+\n+        try {\n+            m.get(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        try {\n+            m.get(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        assertNull(m.get(\"foo\"));\n+\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            assertSame(m.get(nodes[k].getKey()), nodes[k]);\n+        }\n+\n+        assertNull(m.get(new Integer(-1)));\n+\n+        try {\n+            m.get(\"foo\");\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            assertNotNull(m.get(nodes[k].getKey()));\n+            m.remove(nodes[k].getKey());\n+            assertNull(m.get(nodes[k].getKey()));\n+        }\n+    }\n+\n+    /**\n+     * test put() method\n+     */\n+    public void testPut() {\n+\n+        Map m = new DoubleOrderedMap();\n+\n+        try {\n+            m.put(new Object(), \"foo\");\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        try {\n+            m.put(null, \"foo\");\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            m.put(\"foo\", null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            m.put(\"foo\", new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        LocalTestNode[] nodes = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            assertNull(m.put(nodes[k].getKey(), nodes[k].getValue()));\n+\n+            try {\n+                m.put(nodes[k].getKey(), \"foo\");\n+            } catch (IllegalArgumentException ignored) {}\n+        }\n+    }\n+\n+    /**\n+     * test remove() method\n+     */\n+    public void testRemove() {\n+\n+        DoubleOrderedMap m       = new DoubleOrderedMap();\n+        LocalTestNode    nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        try {\n+            m.remove(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            m.remove(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        assertNull(m.remove(new Integer(-1)));\n+\n+        try {\n+            m.remove(\"foo\");\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k += 2) {\n+            Comparable key = nodes[k].getKey();\n+\n+            assertNotNull(m.get(key));\n+            assertSame(nodes[k], m.remove(key));\n+            assertNull(m.remove(key));\n+            assertNull(m.get(key));\n+        }\n+\n+        for (int k = 1; k < nodes.length; k += 2) {\n+            Comparable key = nodes[k].getKey();\n+\n+            assertNotNull(m.get(key));\n+            assertSame(nodes[k], m.remove(key));\n+            assertNull(m.remove(key));\n+            assertNull(m.get(key));\n+        }\n+\n+        assertTrue(m.isEmpty());\n+    }\n+\n+    /**\n+     * Method testPutAll\n+     */\n+    public void testPutAll() {\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        Map m1 = new HashMap();\n+\n+        m1.put(null, \"foo\");\n+\n+        try {\n+            m.putAll(m1);\n+            fail(\"Should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        m1 = new HashMap();\n+\n+        m1.put(new Object(), \"bar\");\n+\n+        try {\n+            m.putAll(m1);\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        m1 = new HashMap();\n+\n+        m1.put(\"fubar\", null);\n+\n+        try {\n+            m.putAll(m1);\n+            fail(\"Should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        m1 = new HashMap();\n+\n+        m1.put(\"fubar\", new Object());\n+\n+        try {\n+            m.putAll(m1);\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        m1 = new HashMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m1.put(nodes[k].getKey(), nodes[k].getValue());\n+        }\n+\n+        m.putAll(m1);\n+        assertEquals(nodes.length, m.size());\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            assertSame(nodes[k].getValue(), m.get(nodes[k].getKey()));\n+        }\n+    }\n+\n+    /**\n+     * test clear() method\n+     */\n+    public void testClear() {\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k].getValue());\n+            assertTrue(!m.isEmpty());\n+        }\n+\n+        assertTrue(!m.isEmpty());\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            assertTrue(m.containsKey(nodes[k].getKey()));\n+            assertTrue(m.containsValue(nodes[k].getValue()));\n+        }\n+\n+        m.clear();\n+        assertTrue(m.isEmpty());\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            assertTrue(!m.containsKey(nodes[k].getKey()));\n+            assertTrue(!m.containsValue(nodes[k].getValue()));\n+        }\n+    }\n+\n+    /**\n+     * test keySet() method\n+     */\n+    public void testKeySet() {\n+\n+        testKeySet(new DoubleOrderedMap());\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        testKeySet(m);\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        int count = m.size();\n+\n+        for (Iterator iter = m.keySet().iterator(); iter.hasNext(); ) {\n+            iter.next();\n+            iter.remove();\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        Set s = m.keySet();\n+\n+        try {\n+            s.remove(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            s.remove(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            Comparable key = nodes[k].getKey();\n+\n+            assertTrue(s.remove(key));\n+            assertTrue(!s.contains(key));\n+            assertTrue(!m.containsKey(key));\n+            assertTrue(!m.containsValue(nodes[k]));\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        Collection c1 = new LinkedList();\n+        Collection c2 = new LinkedList();\n+\n+        c2.add(new Integer(-99));\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+            c2.add(nodes[k].getKey());\n+        }\n+\n+        assertTrue(m.keySet().containsAll(c1));\n+        assertTrue(!m.keySet().containsAll(c2));\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        c1.add(new Integer(-55));\n+\n+        try {\n+            m.keySet().addAll(c1);\n+            fail(\"should have caught exception of addAll()\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+        }\n+\n+        assertTrue(!m.keySet().retainAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 1) {\n+                c1.add(nodes[k].getKey());\n+            }\n+        }\n+\n+        assertTrue(m.keySet().retainAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(m.keySet().retainAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(!m.keySet().removeAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 0) {\n+                c1.add(nodes[k].getKey());\n+            }\n+        }\n+\n+        assertTrue(m.keySet().removeAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+        }\n+\n+        assertTrue(m.keySet().removeAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m.keySet().clear();\n+        assertEquals(0, m.size());\n+    }\n+\n+    /**\n+     * test values() method\n+     */\n+    public void testValues() {\n+\n+        testValues(new DoubleOrderedMap());\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        testValues(m);\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        int count = m.size();\n+\n+        for (Iterator iter = m.values().iterator(); iter.hasNext(); ) {\n+            iter.next();\n+            iter.remove();\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        count = m.size();\n+\n+        Collection s = m.values();\n+\n+        for (int k = 0; k < count; k++) {\n+            assertTrue(s.remove(nodes[k]));\n+            assertTrue(!s.contains(nodes[k]));\n+            assertTrue(!m.containsKey(nodes[k].getKey()));\n+            assertTrue(!m.containsValue(nodes[k]));\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        Collection c1 = new LinkedList();\n+        Collection c2 = new LinkedList();\n+\n+        c2.add(new LocalTestNode(-123));\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+            c2.add(nodes[k]);\n+        }\n+\n+        assertTrue(m.values().containsAll(c1));\n+        assertTrue(!m.values().containsAll(c2));\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+        }\n+\n+        try {\n+            m.values().addAll(c1);\n+            fail(\"should have caught exception of addAll()\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+        }\n+\n+        assertTrue(!m.values().retainAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 1) {\n+                c1.add(nodes[k]);\n+            }\n+        }\n+\n+        assertTrue(m.values().retainAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(m.values().retainAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(!m.values().removeAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 0) {\n+                c1.add(nodes[k]);\n+            }\n+        }\n+\n+        assertTrue(m.values().removeAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+        }\n+\n+        assertTrue(m.values().removeAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m.values().clear();\n+        assertEquals(0, m.size());\n+    }\n+\n+    /**\n+     * test entrySet() method\n+     */\n+    public void testEntrySet() {\n+\n+        testEntrySet(new DoubleOrderedMap());\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        testEntrySet(m);\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        try {\n+            ((Map.Entry) m.entrySet().iterator().next())\n+                .setValue(new LocalTestNode(-1));\n+            fail(\"Should have caught UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        int count = m.size();\n+\n+        for (Iterator iter = m.entrySet().iterator(); iter.hasNext(); ) {\n+            iter.next();\n+            iter.remove();\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        Collection c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+        }\n+\n+        try {\n+            m.entrySet().addAll(c1);\n+            fail(\"should have caught exception of addAll()\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m.entrySet().clear();\n+        assertEquals(0, m.size());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        int x = 0;\n+\n+        for (Iterator iter = m.entrySet().iterator(); iter.hasNext(); ) {\n+            Map.Entry entry = (Map.Entry) iter.next();\n+\n+            assertSame(entry.getKey(), nodes[x].getKey());\n+            assertSame(entry.getValue(), nodes[x]);\n+\n+            x++;\n+        }\n+    }\n+\n+    /**\n+     * Method testEquals\n+     */\n+    public void testEquals() {\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(!m.equals(null));\n+        assertEquals(m, m);\n+\n+        Map m1 = new HashMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m1.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertEquals(m, m1);\n+\n+        m1 = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < (nodes.length - 1); k++) {\n+            m1.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(!m.equals(m1));\n+\n+        m1 = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m1.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        LocalTestNode node1 = new LocalTestNode(-1000);\n+\n+        m1.put(node1.getKey(), node1);\n+        assertTrue(!m.equals(m1));\n+\n+        m1 = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m1.put(nodes[k].getKey(), nodes[nodes.length - (k + 1)]);\n+        }\n+\n+        assertTrue(!m.equals(m1));\n+\n+        m1 = new DoubleOrderedMap();\n+\n+        for (int k = nodes.length - 1; k >= 0; k--) {\n+            m1.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertEquals(m, m1);\n+    }\n+\n+    /**\n+     * test hashCode() method\n+     */\n+    public void testHashCode() {\n+\n+        Map           m       = new DoubleOrderedMap();\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        Map m1 = new DoubleOrderedMap();\n+\n+        for (int k = nodes.length - 1; k >= 0; k--) {\n+            m1.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertEquals(m.hashCode(), m1.hashCode());\n+    }\n+\n+    /**\n+     * test constructors\n+     */\n+    public void testConstructors() {\n+\n+        DoubleOrderedMap m = new DoubleOrderedMap();\n+\n+        assertTrue(m.isEmpty());\n+\n+        DoubleOrderedMap m1 = new DoubleOrderedMap(m);\n+\n+        assertTrue(m1.isEmpty());\n+\n+        m1 = new DoubleOrderedMap();\n+\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m1.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m = new DoubleOrderedMap(m1);\n+\n+        assertEquals(m, m1);\n+\n+        Map m2 = new HashMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m2.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m = new DoubleOrderedMap(m2);\n+\n+        assertEquals(m, m2);\n+\n+        // reject duplicated values\n+        m2 = new HashMap();\n+\n+        m2.put(\"1\", \"foo\");\n+        m2.put(\"2\", \"foo\");\n+\n+        try {\n+            m = new DoubleOrderedMap(m2);\n+\n+            fail(\"Should have caught IllegalArgumentException\");\n+        } catch (IllegalArgumentException ignored) {}\n+\n+        // reject null values\n+        m2.put(\"2\", null);\n+\n+        try {\n+            m = new DoubleOrderedMap(m2);\n+\n+            fail(\"Should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        // reject non-Comparable values\n+        m2.put(\"2\", new Object());\n+\n+        try {\n+            m = new DoubleOrderedMap(m2);\n+\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        // reject incompatible values\n+        m2.put(\"2\", new Integer(2));\n+\n+        try {\n+            m = new DoubleOrderedMap(m2);\n+\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        // reject incompatible keys\n+        m2.remove(\"2\");\n+        m2.put(new Integer(2), \"bad key\");\n+\n+        try {\n+            m = new DoubleOrderedMap(m2);\n+\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        // reject non-Comparable keys\n+        m2.clear();\n+        m2.put(\"1\", \"foo\");\n+        m2.put(new Object(), \"bad key\");\n+\n+        try {\n+            m = new DoubleOrderedMap(m2);\n+\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+    }\n+\n+    /**\n+     * test getKeyForValue() method\n+     */\n+    public void testGetKeyForValue() {\n+\n+        DoubleOrderedMap m = new DoubleOrderedMap();\n+\n+        try {\n+            m.getKeyForValue(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        try {\n+            m.getKeyForValue(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        assertNull(m.getKeyForValue(\"foo\"));\n+\n+        LocalTestNode nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            assertSame(m.getKeyForValue(nodes[k]), nodes[k].getKey());\n+        }\n+\n+        assertNull(m.getKeyForValue(new LocalTestNode(-1)));\n+\n+        try {\n+            m.getKeyForValue(\"foo\");\n+            fail(\"Should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            assertNotNull(m.getKeyForValue(nodes[k]));\n+            m.remove(nodes[k].getKey());\n+            assertNull(m.getKeyForValue(nodes[k]));\n+        }\n+    }\n+\n+    /**\n+     * test removeValue() method\n+     */\n+    public void testRemoveValue() {\n+\n+        DoubleOrderedMap m       = new DoubleOrderedMap();\n+        LocalTestNode    nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        try {\n+            m.removeValue(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            m.removeValue(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        assertNull(m.remove(new Integer(-1)));\n+\n+        try {\n+            m.removeValue(\"foo\");\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k += 2) {\n+            assertNotNull(m.getKeyForValue(nodes[k]));\n+            assertSame(nodes[k].getKey(), m.removeValue(nodes[k]));\n+            assertNull(m.removeValue(nodes[k]));\n+            assertNull(m.getKeyForValue(nodes[k]));\n+        }\n+\n+        for (int k = 1; k < nodes.length; k += 2) {\n+            assertNotNull(m.getKeyForValue(nodes[k]));\n+            assertSame(nodes[k].getKey(), m.removeValue(nodes[k]));\n+            assertNull(m.removeValue(nodes[k]));\n+            assertNull(m.getKeyForValue(nodes[k]));\n+        }\n+\n+        assertTrue(m.isEmpty());\n+    }\n+\n+    /**\n+     * test entrySetByValue() method\n+     */\n+    public void testEntrySetByValue() {\n+\n+        testEntrySetByValue(new DoubleOrderedMap());\n+\n+        DoubleOrderedMap m       = new DoubleOrderedMap();\n+        LocalTestNode    nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        testEntrySetByValue(m);\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        try {\n+            ((Map.Entry) m.entrySetByValue().iterator().next())\n+                .setValue(new LocalTestNode(-1));\n+            fail(\"Should have caught UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        int count = m.size();\n+\n+        for (Iterator iter = m.entrySetByValue().iterator();\n+                iter.hasNext(); ) {\n+            iter.next();\n+            iter.remove();\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        Collection c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+        }\n+\n+        try {\n+            m.entrySetByValue().addAll(c1);\n+            fail(\"should have caught exception of addAll()\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m.entrySetByValue().clear();\n+        assertEquals(0, m.size());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        int x = 0;\n+\n+        for (Iterator iter = m.entrySetByValue().iterator();\n+                iter.hasNext(); ) {\n+            Map.Entry entry = (Map.Entry) iter.next();\n+\n+            assertSame(entry.getKey(), nodes[x].getKey());\n+            assertSame(entry.getValue(), nodes[x]);\n+\n+            x++;\n+        }\n+    }\n+\n+    /**\n+     * test keySetByValue() method\n+     */\n+    public void testKeySetByValue() {\n+\n+        testKeySetByValue(new DoubleOrderedMap());\n+\n+        DoubleOrderedMap m       = new DoubleOrderedMap();\n+        LocalTestNode    nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        testKeySetByValue(m);\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        int count = m.size();\n+\n+        for (Iterator iter = m.keySetByValue().iterator(); iter.hasNext(); ) \n+{\n+            iter.next();\n+            iter.remove();\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        Set s = m.keySetByValue();\n+\n+        try {\n+            s.remove(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            s.remove(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            Comparable key = nodes[k].getKey();\n+\n+            assertTrue(s.remove(key));\n+            assertTrue(!s.contains(key));\n+            assertTrue(!m.containsKey(key));\n+            assertTrue(!m.containsValue(nodes[k]));\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        Collection c1 = new LinkedList();\n+        Collection c2 = new LinkedList();\n+\n+        c2.add(new Integer(-99));\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+            c2.add(nodes[k].getKey());\n+        }\n+\n+        assertTrue(m.keySetByValue().containsAll(c1));\n+        assertTrue(!m.keySetByValue().containsAll(c2));\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        c1.add(new Integer(-55));\n+\n+        try {\n+            m.keySetByValue().addAll(c1);\n+            fail(\"should have caught exception of addAll()\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+        }\n+\n+        assertTrue(!m.keySetByValue().retainAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 1) {\n+                c1.add(nodes[k].getKey());\n+            }\n+        }\n+\n+        assertTrue(m.keySetByValue().retainAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(m.keySetByValue().retainAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(!m.keySetByValue().removeAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 0) {\n+                c1.add(nodes[k].getKey());\n+            }\n+        }\n+\n+        assertTrue(m.keySetByValue().removeAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k].getKey());\n+        }\n+\n+        assertTrue(m.keySetByValue().removeAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m.keySetByValue().clear();\n+        assertEquals(0, m.size());\n+    }\n+\n+    /**\n+     * test valuesByValue() method\n+     */\n+    public void testValuesByValue() {\n+\n+        testValuesByValue(new DoubleOrderedMap());\n+\n+        DoubleOrderedMap m       = new DoubleOrderedMap();\n+        LocalTestNode    nodes[] = makeLocalNodes();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        testValuesByValue(m);\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        int count = m.size();\n+\n+        for (Iterator iter = m.valuesByValue().iterator(); iter.hasNext(); ) \n+{\n+            iter.next();\n+            iter.remove();\n+\n+            --count;\n+\n+            assertEquals(count, m.size());\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        count = m.size();\n+\n+        Collection s = m.valuesByValue();\n+\n+        for (int k = 0; k < count; k++) {\n+            assertTrue(s.remove(nodes[k]));\n+            assertTrue(!s.contains(nodes[k]));\n+            assertTrue(!m.containsKey(nodes[k].getKey()));\n+            assertTrue(!m.containsValue(nodes[k]));\n+        }\n+\n+        assertTrue(m.isEmpty());\n+\n+        m = new DoubleOrderedMap();\n+\n+        Collection c1 = new LinkedList();\n+        Collection c2 = new LinkedList();\n+\n+        c2.add(new LocalTestNode(-123));\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+            c2.add(nodes[k]);\n+        }\n+\n+        assertTrue(m.valuesByValue().containsAll(c1));\n+        assertTrue(!m.valuesByValue().containsAll(c2));\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+        }\n+\n+        try {\n+            m.valuesByValue().addAll(c1);\n+            fail(\"should have caught exception of addAll()\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+        }\n+\n+        assertTrue(!m.valuesByValue().retainAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 1) {\n+                c1.add(nodes[k]);\n+            }\n+        }\n+\n+        assertTrue(m.valuesByValue().retainAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(m.valuesByValue().retainAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        assertTrue(!m.valuesByValue().removeAll(c1));\n+        assertEquals(nodes.length, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+\n+            if (k % 2 == 0) {\n+                c1.add(nodes[k]);\n+            }\n+        }\n+\n+        assertTrue(m.valuesByValue().removeAll(c1));\n+        assertEquals(nodes.length / 2, m.size());\n+\n+        m  = new DoubleOrderedMap();\n+        c1 = new LinkedList();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+            c1.add(nodes[k]);\n+        }\n+\n+        assertTrue(m.valuesByValue().removeAll(c1));\n+        assertEquals(0, m.size());\n+\n+        m = new DoubleOrderedMap();\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            m.put(nodes[k].getKey(), nodes[k]);\n+        }\n+\n+        m.valuesByValue().clear();\n+        assertEquals(0, m.size());\n+    }\n+\n+    /* ********** START helper methods ********** */\n+    private void testKeySet(final Map m) {\n+\n+        Set s = m.keySet();\n+\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        LocalTestNode node = new LocalTestNode(-1);\n+\n+        m.put(node.getKey(), node);\n+        assertTrue(s.contains(node.getKey()));\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        m.remove(node.getKey());\n+        assertTrue(!s.contains(node.getKey()));\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        try {\n+            s.contains(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            s.contains(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < m.size(); k++) {\n+            assertTrue(s.contains(new Integer(k)));\n+        }\n+\n+        int count = 0;\n+\n+        for (Iterator iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            ++count;\n+        }\n+\n+        assertEquals(count, s.size());\n+\n+        // force the map to have some content\n+        m.put(node.getKey(), node);\n+\n+        Iterator      iter  = m.keySet().iterator();\n+        LocalTestNode node2 = new LocalTestNode(-2);\n+\n+        m.put(node2.getKey(), node2);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a put\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.remove(node2.getKey());\n+\n+        iter = s.iterator();\n+\n+        m.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Map remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        s.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Set remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        iter  = s.iterator();\n+        count = 0;\n+\n+        boolean terminated = false;\n+\n+        try {\n+            while (true) {\n+                iter.next();\n+\n+                ++count;\n+            }\n+        } catch (NoSuchElementException ignored) {\n+            terminated = true;\n+        }\n+\n+        assertTrue(terminated);\n+        assertEquals(m.size(), count);\n+\n+        iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        iter.next();\n+        m.put(node2.getKey(), node2);\n+\n+        try {\n+            iter.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        Iterator iter2 = s.iterator();\n+\n+        iter2.next();\n+\n+        LocalTestNode node3 = new LocalTestNode(-3);\n+\n+        m.put(node3.getKey(), node3);\n+\n+        try {\n+            iter2.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        int removalCount = 0;\n+\n+        for (iter = s.iterator(); iter.hasNext(); ) {\n+            if (iter.next().equals(node.getKey())) {\n+                try {\n+                    iter.remove();\n+\n+                    ++removalCount;\n+\n+                    iter.remove();\n+                    fail(\"2nd remove should have failed\");\n+                } catch (IllegalStateException ignored) {\n+                    assertEquals(1, removalCount);\n+                }\n+            }\n+        }\n+\n+        assertEquals(1, removalCount);\n+        assertTrue(!s.contains(node.getKey()));\n+\n+        removalCount = 0;\n+\n+        m.put(node.getKey(), node);\n+\n+        Object[] a1 = s.toArray();\n+\n+        assertEquals(s.size(), a1.length);\n+\n+        if (a1.length > 1) {\n+            Comparable first = (Comparable) a1[0];\n+\n+            for (int k = 1; k < a1.length; k++) {\n+                Comparable second = (Comparable) a1[k];\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+\n+            iter  = s.iterator();\n+            first = (Comparable) iter.next();\n+\n+            for (; iter.hasNext(); ) {\n+                Comparable second = (Comparable) iter.next();\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            String array2[] = (String[]) s.toArray(new String[0]);\n+\n+            if (s.size() != 0) {\n+                fail(\"should have caught exception creating an invalid array\");\n+            }\n+        } catch (ArrayStoreException ignored) {}\n+\n+        Comparable array2[] = (Comparable[]) s.toArray(new Comparable[0]);\n+        Integer    array3[] = (Integer[]) s.toArray(new Integer[s.size()]);\n+\n+        if (array3.length > 1) {\n+            Integer first = array3[0];\n+\n+            for (int k = 1; k < array3.length; k++) {\n+                Integer second = array3[k];\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            s.add(\"foo\");\n+            fail(\"should have thrown an exception\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        assertTrue(!s.equals(null));\n+        assertEquals(s, s);\n+\n+        Set hs = new HashSet(s);\n+\n+        assertEquals(s, hs);\n+        assertEquals(hs, s);\n+        assertEquals(s.hashCode(), hs.hashCode());\n+    }\n+\n+    private void testKeySetByValue(final DoubleOrderedMap m) {\n+\n+        Set s = m.keySetByValue();\n+\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        LocalTestNode node = new LocalTestNode(-1);\n+\n+        m.put(node.getKey(), node);\n+        assertTrue(s.contains(node.getKey()));\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        m.remove(node.getKey());\n+        assertTrue(!s.contains(node.getKey()));\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        try {\n+            s.contains(null);\n+            fail(\"should have caught NullPointerException\");\n+        } catch (NullPointerException ignored) {}\n+\n+        try {\n+            s.contains(new Object());\n+            fail(\"should have caught ClassCastException\");\n+        } catch (ClassCastException ignored) {}\n+\n+        for (int k = 0; k < m.size(); k++) {\n+            assertTrue(s.contains(new Integer(k)));\n+        }\n+\n+        int count = 0;\n+\n+        for (Iterator iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            ++count;\n+        }\n+\n+        assertEquals(count, s.size());\n+\n+        // force the map to have some content\n+        m.put(node.getKey(), node);\n+\n+        Iterator      iter  = m.keySetByValue().iterator();\n+        LocalTestNode node2 = new LocalTestNode(-2);\n+\n+        m.put(node2.getKey(), node2);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a put\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.remove(node2.getKey());\n+\n+        iter = s.iterator();\n+\n+        m.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Map remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        s.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Set remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        iter  = s.iterator();\n+        count = 0;\n+\n+        boolean terminated = false;\n+\n+        try {\n+            while (true) {\n+                iter.next();\n+\n+                ++count;\n+            }\n+        } catch (NoSuchElementException ignored) {\n+            terminated = true;\n+        }\n+\n+        assertTrue(terminated);\n+        assertEquals(m.size(), count);\n+\n+        iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        iter.next();\n+        m.put(node2.getKey(), node2);\n+\n+        try {\n+            iter.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        Iterator iter2 = s.iterator();\n+\n+        iter2.next();\n+\n+        LocalTestNode node3 = new LocalTestNode(-3);\n+\n+        m.put(node3.getKey(), node3);\n+\n+        try {\n+            iter2.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        int removalCount = 0;\n+\n+        for (iter = s.iterator(); iter.hasNext(); ) {\n+            if (iter.next().equals(node.getKey())) {\n+                try {\n+                    iter.remove();\n+\n+                    ++removalCount;\n+\n+                    iter.remove();\n+                    fail(\"2nd remove should have failed\");\n+                } catch (IllegalStateException ignored) {\n+                    assertEquals(1, removalCount);\n+                }\n+            }\n+        }\n+\n+        assertEquals(1, removalCount);\n+        assertTrue(!s.contains(node.getKey()));\n+\n+        removalCount = 0;\n+\n+        m.put(node.getKey(), node);\n+\n+        Object[] a1 = s.toArray();\n+\n+        assertEquals(s.size(), a1.length);\n+\n+        //          if (a1.length > 1)\n+        //          {\n+        //              Comparable first = ( Comparable ) a1[ 0 ];\n+        //              for (int k = 1; k < a1.length; k++)\n+        //              {\n+        //                  Comparable second = ( Comparable ) a1[ k ];\n+        //                  assertTrue(first.compareTo(second) < 0);\n+        //                  first = second;\n+        //              }\n+        //              iter  = s.iterator();\n+        //              first = ( Comparable ) iter.next();\n+        //              for (; iter.hasNext(); )\n+        //              {\n+        //                  Comparable second = ( Comparable ) iter.next();\n+        //                  assertTrue(first.compareTo(second) < 0);\n+        //                  first = second;\n+        //              }\n+        //          }\n+        try {\n+            String array2[] = (String[]) s.toArray(new String[0]);\n+\n+            if (s.size() != 0) {\n+                fail(\"should have caught exception creating an invalid array\");\n+            }\n+        } catch (ArrayStoreException ignored) {}\n+\n+        Comparable array2[] = (Comparable[]) s.toArray(new Comparable[0]);\n+        Integer    array3[] = (Integer[]) s.toArray(new Integer[s.size()]);\n+\n+        //          if (array3.length > 1)\n+        //          {\n+        //              Integer first = array3[ 0 ];\n+        //              for (int k = 1; k < array3.length; k++)\n+        //              {\n+        //                  Integer second = array3[ k ];\n+        //                  assertTrue(first.compareTo(second) < 0);\n+        //                  first = second;\n+        //              }\n+        //          }\n+        try {\n+            s.add(\"foo\");\n+            fail(\"should have thrown an exception\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        assertTrue(!s.equals(null));\n+        assertEquals(s, s);\n+\n+        Set hs = new HashSet(s);\n+\n+        assertEquals(s, hs);\n+        assertEquals(hs, s);\n+        assertEquals(s.hashCode(), hs.hashCode());\n+    }\n+\n+    private void testValues(Map m) {\n+\n+        Collection s = m.values();\n+\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        LocalTestNode node = new LocalTestNode(-1);\n+\n+        m.put(node.getKey(), node);\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        m.remove(node.getKey());\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        assertTrue(!s.contains(node));\n+\n+        for (int k = 0; k < m.size(); k++) {\n+            assertTrue(s.contains(new LocalTestNode(k)));\n+        }\n+\n+        m.put(node.getKey(), node);\n+        assertTrue(s.contains(node));\n+        m.remove(node.getKey());\n+        assertTrue(!s.contains(node));\n+\n+        int count = 0;\n+\n+        for (Iterator iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            ++count;\n+        }\n+\n+        assertEquals(s.size(), count);\n+\n+        LocalTestNode node4 = new LocalTestNode(-4);\n+\n+        m.put(node4.getKey(), node4);\n+\n+        Iterator iter = s.iterator();\n+\n+        m.put(node.getKey(), node);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a put\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        iter = s.iterator();\n+\n+        m.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Map remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        s.remove(node);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Set remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        iter  = s.iterator();\n+        count = 0;\n+\n+        boolean terminated = false;\n+\n+        try {\n+            while (true) {\n+                iter.next();\n+\n+                ++count;\n+            }\n+        } catch (NoSuchElementException ignored) {\n+            terminated = true;\n+        }\n+\n+        assertTrue(terminated);\n+        assertEquals(m.size(), count);\n+\n+        iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        Iterator iter2 = s.iterator();\n+\n+        try {\n+            iter2.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        iter.next();\n+\n+        LocalTestNode node2 = new LocalTestNode(-2);\n+\n+        m.put(node2.getKey(), node2);\n+\n+        try {\n+            iter.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        LocalTestNode node3 = new LocalTestNode(-3);\n+\n+        m.put(node3.getKey(), node3);\n+\n+        iter2 = s.iterator();\n+\n+        while (iter2.hasNext()) {\n+            iter2.next();\n+        }\n+\n+        int removalCount = 0;\n+\n+        for (iter = s.iterator(); iter.hasNext(); ) {\n+            if (iter.next().equals(node3)) {\n+                try {\n+                    iter.remove();\n+\n+                    ++removalCount;\n+\n+                    iter.remove();\n+                    fail(\"2nd remove should have failed\");\n+                } catch (IllegalStateException ignored) {\n+                    assertEquals(1, removalCount);\n+                }\n+            }\n+        }\n+\n+        assertEquals(1, removalCount);\n+        assertTrue(!s.contains(node3));\n+\n+        Object[] a1 = s.toArray();\n+\n+        assertEquals(s.size(), a1.length);\n+\n+        if (a1.length > 1) {\n+            Comparable first = (Comparable) a1[0];\n+\n+            for (int k = 1; k < a1.length; k++) {\n+                Comparable second = (Comparable) a1[k];\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+\n+            iter  = s.iterator();\n+            first = (Comparable) iter.next();\n+\n+            for (; iter.hasNext(); ) {\n+                Comparable second = (Comparable) iter.next();\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            String array2[] = (String[]) s.toArray(new String[0]);\n+\n+            if (s.size() != 0) {\n+                fail(\"should have caught exception creating an invalid array\");\n+            }\n+        } catch (ArrayStoreException ignored) {}\n+\n+        m.remove(node.getKey());\n+        m.remove(node2.getKey());\n+        m.remove(node3.getKey());\n+\n+        LocalTestNode array2[] =\n+            (LocalTestNode[]) s.toArray(new LocalTestNode[0]);\n+        LocalTestNode array3[] =\n+            (LocalTestNode[]) s.toArray(new LocalTestNode[s.size()]);\n+\n+        if (array3.length > 1) {\n+            LocalTestNode first = array3[0];\n+\n+            for (int k = 1; k < array3.length; k++) {\n+                LocalTestNode second = array3[k];\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            s.add(node.getKey());\n+            fail(\"should have thrown an exception\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        assertTrue(!s.equals(null));\n+        assertEquals(s, s);\n+\n+        Set hs = new HashSet(s);\n+\n+        assertTrue(!s.equals(hs));\n+        assertTrue(!hs.equals(s));\n+    }\n+\n+    private void testValuesByValue(DoubleOrderedMap m) {\n+\n+        Collection s = m.valuesByValue();\n+\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        LocalTestNode node = new LocalTestNode(-1);\n+\n+        m.put(node.getKey(), node);\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        m.remove(node.getKey());\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        assertTrue(!s.contains(node));\n+\n+        for (int k = 0; k < m.size(); k++) {\n+            assertTrue(s.contains(new LocalTestNode(k)));\n+        }\n+\n+        m.put(node.getKey(), node);\n+        assertTrue(s.contains(node));\n+        m.remove(node.getKey());\n+        assertTrue(!s.contains(node));\n+\n+        int count = 0;\n+\n+        for (Iterator iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            ++count;\n+        }\n+\n+        assertEquals(s.size(), count);\n+\n+        LocalTestNode node4 = new LocalTestNode(-4);\n+\n+        m.put(node4.getKey(), node4);\n+\n+        Iterator iter = s.iterator();\n+\n+        m.put(node.getKey(), node);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a put\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        iter = s.iterator();\n+\n+        m.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Map remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        s.remove(node);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Set remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        iter  = s.iterator();\n+        count = 0;\n+\n+        boolean terminated = false;\n+\n+        try {\n+            while (true) {\n+                iter.next();\n+\n+                ++count;\n+            }\n+        } catch (NoSuchElementException ignored) {\n+            terminated = true;\n+        }\n+\n+        assertTrue(terminated);\n+        assertEquals(m.size(), count);\n+\n+        iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        Iterator iter2 = s.iterator();\n+\n+        try {\n+            iter2.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter = s.iterator();\n+\n+        iter.next();\n+\n+        LocalTestNode node2 = new LocalTestNode(-2);\n+\n+        m.put(node2.getKey(), node2);\n+\n+        try {\n+            iter.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        LocalTestNode node3 = new LocalTestNode(-3);\n+\n+        m.put(node3.getKey(), node3);\n+\n+        iter2 = s.iterator();\n+\n+        while (iter2.hasNext()) {\n+            iter2.next();\n+        }\n+\n+        int removalCount = 0;\n+\n+        for (iter = s.iterator(); iter.hasNext(); ) {\n+            if (iter.next().equals(node3)) {\n+                try {\n+                    iter.remove();\n+\n+                    ++removalCount;\n+\n+                    iter.remove();\n+                    fail(\"2nd remove should have failed\");\n+                } catch (IllegalStateException ignored) {\n+                    assertEquals(1, removalCount);\n+                }\n+            }\n+        }\n+\n+        assertEquals(1, removalCount);\n+        assertTrue(!s.contains(node3));\n+\n+        Object[] a1 = s.toArray();\n+\n+        assertEquals(s.size(), a1.length);\n+\n+        try {\n+            String array2[] = (String[]) s.toArray(new String[0]);\n+\n+            if (s.size() != 0) {\n+                fail(\"should have caught exception creating an invalid array\");\n+            }\n+        } catch (ArrayStoreException ignored) {}\n+\n+        m.remove(node.getKey());\n+        m.remove(node2.getKey());\n+        m.remove(node3.getKey());\n+\n+        LocalTestNode array2[] =\n+            (LocalTestNode[]) s.toArray(new LocalTestNode[0]);\n+        LocalTestNode array3[] =\n+            (LocalTestNode[]) s.toArray(new LocalTestNode[s.size()]);\n+\n+        try {\n+            s.add(node.getKey());\n+            fail(\"should have thrown an exception\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        assertTrue(!s.equals(null));\n+        assertEquals(s, s);\n+\n+        Set hs = new HashSet(s);\n+\n+        assertTrue(!s.equals(hs));\n+        assertTrue(!hs.equals(s));\n+    }\n+\n+    private void testEntrySet(Map m) {\n+\n+        Set s = m.entrySet();\n+\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        LocalTestNode node = new LocalTestNode(-1);\n+\n+        m.put(node.getKey(), node);\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        m.remove(node.getKey());\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        int count = 0;\n+\n+        for (Iterator iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            ++count;\n+        }\n+\n+        assertEquals(s.size(), count);\n+\n+        LocalTestNode node2 = new LocalTestNode(-2);\n+\n+        if (m.size() == 0) {\n+            m.put(node2.getKey(), node2);\n+        }\n+\n+        Iterator iter = s.iterator();\n+\n+        m.put(node.getKey(), node);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a put\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.remove(node2.getKey());\n+\n+        iter = s.iterator();\n+\n+        m.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Map remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter  = s.iterator();\n+        count = 0;\n+\n+        boolean terminated = false;\n+\n+        try {\n+            while (true) {\n+                iter.next();\n+\n+                ++count;\n+            }\n+        } catch (NoSuchElementException ignored) {\n+            terminated = true;\n+        }\n+\n+        assertTrue(terminated);\n+        assertEquals(m.size(), count);\n+\n+        iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        iter = s.iterator();\n+\n+        iter.next();\n+\n+        LocalTestNode node3 = new LocalTestNode(-3);\n+\n+        m.put(node3.getKey(), node3);\n+\n+        try {\n+            iter.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        int removalCount = 0;\n+        int when         = m.size() / 2;\n+        int timer        = 0;\n+\n+        for (iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            if (timer == when) {\n+                try {\n+                    iter.remove();\n+\n+                    ++removalCount;\n+\n+                    iter.remove();\n+                    fail(\"2nd remove should have failed\");\n+                } catch (IllegalStateException ignored) {\n+                    assertEquals(1, removalCount);\n+                }\n+            }\n+\n+            timer++;\n+        }\n+\n+        assertEquals(1, removalCount);\n+\n+        Iterator iter2 = s.iterator();\n+\n+        try {\n+            iter2.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        iter2 = s.iterator();\n+\n+        while (iter2.hasNext()) {\n+            iter2.next();\n+        }\n+\n+        LocalTestNode node4 = new LocalTestNode(-4);\n+\n+        m.put(node4.getKey(), node4);\n+\n+        try {\n+            iter2.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        Object[] a1 = s.toArray();\n+\n+        assertEquals(s.size(), a1.length);\n+\n+        if (a1.length > 1) {\n+            Map.Entry first = (Map.Entry) a1[0];\n+\n+            for (int k = 1; k < a1.length; k++) {\n+                Map.Entry second = (Map.Entry) a1[k];\n+\n+                assertTrue(((Comparable) first.getKey())\n+                    .compareTo((Comparable) second.getKey()) < 0);\n+\n+                first = second;\n+            }\n+\n+            iter  = s.iterator();\n+            first = (Map.Entry) iter.next();\n+\n+            for (; iter.hasNext(); ) {\n+                Map.Entry second = (Map.Entry) iter.next();\n+\n+                assertTrue(((Comparable) first.getKey())\n+                    .compareTo((Comparable) second.getKey()) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            Integer array2[] = (Integer[]) s.toArray(new Integer[0]);\n+\n+            if (s.size() != 0) {\n+                fail(\"should have caught exception creating an invalid array\");\n+            }\n+        } catch (ArrayStoreException ignored) {}\n+\n+        Map.Entry array2[] = (Map.Entry[]) s.toArray(new Map.Entry[0]);\n+        Map.Entry array3[] = (Map.Entry[]) s.toArray(new Map.Entry[s.size()]);\n+\n+        if (array3.length > 1) {\n+            Comparable first = (Comparable) ((Map.Entry) array3[0]).getKey();\n+\n+            for (int k = 1; k < array3.length; k++) {\n+                Comparable second =\n+                    (Comparable) ((Map.Entry) array3[k]).getKey();\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            s.add(node.getKey());\n+            fail(\"should have thrown an exception\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        assertTrue(!s.equals(null));\n+        assertEquals(\"SetEquality 1\", s, s);\n+\n+        Set hs = new HashSet(s);\n+\n+        assertEquals(\"SetEquality 2\", s, hs);\n+        assertEquals(\"SetEquality 3\", hs, s);\n+        assertEquals(s.hashCode(), hs.hashCode());\n+    }\n+\n+    private void testEntrySetByValue(DoubleOrderedMap m) {\n+\n+        Set s = m.entrySetByValue();\n+\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        LocalTestNode node = new LocalTestNode(-1);\n+\n+        m.put(node.getKey(), node);\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+        m.remove(node.getKey());\n+        assertEquals(m.size(), s.size());\n+        assertEquals(m.isEmpty(), s.isEmpty());\n+\n+        int count = 0;\n+\n+        for (Iterator iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            ++count;\n+        }\n+\n+        assertEquals(s.size(), count);\n+\n+        LocalTestNode node2 = new LocalTestNode(-2);\n+\n+        if (m.size() == 0) {\n+            m.put(node2.getKey(), node2);\n+        }\n+\n+        Iterator iter = s.iterator();\n+\n+        m.put(node.getKey(), node);\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a put\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.remove(node2.getKey());\n+\n+        iter = s.iterator();\n+\n+        m.remove(node.getKey());\n+\n+        try {\n+            iter.next();\n+            fail(\"next() should have thrown an exception after a Map remove\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        m.put(node.getKey(), node);\n+\n+        iter  = s.iterator();\n+        count = 0;\n+\n+        boolean terminated = false;\n+\n+        try {\n+            while (true) {\n+                iter.next();\n+\n+                ++count;\n+            }\n+        } catch (NoSuchElementException ignored) {\n+            terminated = true;\n+        }\n+\n+        assertTrue(terminated);\n+        assertEquals(m.size(), count);\n+\n+        iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        iter = s.iterator();\n+\n+        iter.next();\n+\n+        LocalTestNode node3 = new LocalTestNode(-3);\n+\n+        m.put(node3.getKey(), node3);\n+\n+        try {\n+            iter.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        int removalCount = 0;\n+        int when         = m.size() / 2;\n+        int timer        = 0;\n+\n+        for (iter = s.iterator(); iter.hasNext(); ) {\n+            iter.next();\n+\n+            if (timer == when) {\n+                try {\n+                    iter.remove();\n+\n+                    ++removalCount;\n+\n+                    iter.remove();\n+                    fail(\"2nd remove should have failed\");\n+                } catch (IllegalStateException ignored) {\n+                    assertEquals(1, removalCount);\n+                }\n+            }\n+\n+            timer++;\n+        }\n+\n+        assertEquals(1, removalCount);\n+\n+        Iterator iter2 = s.iterator();\n+\n+        try {\n+            iter2.remove();\n+            fail(\"Should have thrown exception\");\n+        } catch (IllegalStateException ignored) {}\n+\n+        iter2 = s.iterator();\n+\n+        while (iter2.hasNext()) {\n+            iter2.next();\n+        }\n+\n+        LocalTestNode node4 = new LocalTestNode(-4);\n+\n+        m.put(node4.getKey(), node4);\n+\n+        try {\n+            iter2.remove();\n+            fail(\"should have thrown exception\");\n+        } catch (ConcurrentModificationException ignored) {}\n+\n+        Object[] a1 = s.toArray();\n+\n+        assertEquals(s.size(), a1.length);\n+\n+        if (a1.length > 1) {\n+            Map.Entry first = (Map.Entry) a1[0];\n+\n+            for (int k = 1; k < a1.length; k++) {\n+                Map.Entry second = (Map.Entry) a1[k];\n+\n+                assertTrue(((Comparable) first.getKey())\n+                    .compareTo((Comparable) second.getKey()) < 0);\n+\n+                first = second;\n+            }\n+\n+            iter  = s.iterator();\n+            first = (Map.Entry) iter.next();\n+\n+            for (; iter.hasNext(); ) {\n+                Map.Entry second = (Map.Entry) iter.next();\n+\n+                assertTrue(((Comparable) first.getKey())\n+                    .compareTo((Comparable) second.getKey()) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            Integer array2[] = (Integer[]) s.toArray(new Integer[0]);\n+\n+            if (s.size() != 0) {\n+                fail(\"should have caught exception creating an invalid array\");\n+            }\n+        } catch (ArrayStoreException ignored) {}\n+\n+        Map.Entry array2[] = (Map.Entry[]) s.toArray(new Map.Entry[0]);\n+        Map.Entry array3[] = (Map.Entry[]) s.toArray(new Map.Entry[s.size()]);\n+\n+        if (array3.length > 1) {\n+            Comparable first =\n+                (Comparable) ((Map.Entry) array3[0]).getValue();\n+\n+            for (int k = 1; k < array3.length; k++) {\n+                Comparable second =\n+                    (Comparable) ((Map.Entry) array3[k]).getValue();\n+\n+                assertTrue(first.compareTo(second) < 0);\n+\n+                first = second;\n+            }\n+        }\n+\n+        try {\n+            s.add(node.getKey());\n+            fail(\"should have thrown an exception\");\n+        } catch (UnsupportedOperationException ignored) {}\n+\n+        assertTrue(!s.equals(null));\n+        assertEquals(\"SetEquality 1\", s, s);\n+\n+        Set hs = new HashSet(s);\n+\n+        assertEquals(\"SetEquality 2\", s, hs);\n+        assertEquals(\"SetEquality 3\", hs, s);\n+        assertEquals(s.hashCode(), hs.hashCode());\n+    }\n+\n+    private LocalTestNode[] makeLocalNodes() {\n+\n+        LocalTestNode nodes[] = new LocalTestNode[1023];\n+\n+        for (int k = 0; k < nodes.length; k++) {\n+            nodes[k] = new LocalTestNode(k);\n+        }\n+\n+        return nodes;\n+    }\n+\n+    /* **********  END  helper methods ********** */\n+\n+    /**\n+     * Method main\n+     *\n+     * @param unusedArgs\n+     */\n+    public static void main(final String unusedArgs[]) {\n+        junit.textui.TestRunner.run(TestDoubleOrderedMap.class);\n+    }\n+}", "timestamp": 1011501368, "metainfo": ""}