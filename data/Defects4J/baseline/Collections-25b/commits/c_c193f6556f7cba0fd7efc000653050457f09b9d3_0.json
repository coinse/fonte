{"sha": "c193f6556f7cba0fd7efc000653050457f09b9d3", "log": "Add unit test for SkippingIterator, fix bug.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java\n  * before that position.\n  *\n  * @since 4.1\n- * @version $Id: $\n+ * @version $Id$\n  */\n public class SkippingIterator<E> extends AbstractIteratorDecorator<E> {\n \n     private void init() {\n         while (pos < offset && hasNext()) {\n             next();\n-            pos++;\n         }\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.junit.Test;\n+\n+/**\n+ * A unit test to test the basic functions of {@link SkippingIterator}.\n+ *\n+ * @version $Id$\n+ */\n+public class SkippingIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    /** Test array of size 7 */\n+    private String[] testArray = {\n+        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n+    };\n+\n+    private List<E> testList;\n+\n+    public SkippingIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void setUp()\n+        throws Exception {\n+        super.setUp();\n+        testList = Arrays.asList((E[]) testArray);\n+    }\n+\n+    @Override\n+    public Iterator<E> makeEmptyIterator() {\n+        return new SkippingIterator<E>(Collections.<E>emptyList().iterator(), 0);\n+    }\n+\n+    @Override\n+    public Iterator<E> makeObject() {\n+        return new SkippingIterator<E>(new ArrayList<E>(testList).iterator(), 1);\n+    }\n+\n+    // ---------------- Tests ---------------------\n+\n+    /**\n+     * Test a decorated iterator bounded such that the first element returned is\n+     * at an index greater its first element, and the last element returned is\n+     * at an index less than its last element.\n+     */\n+    @Test\n+    public void testSkipping() {\n+        Iterator<E> iter = new SkippingIterator<E>(testList.iterator(), 2);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test a decorated iterator bounded such that the <code>offset</code> is\n+     * zero, in that the SkippingIterator should return all the same elements\n+     * as its decorated iterator.\n+     */\n+    @Test\n+    public void testSameAsDecorated() {\n+        Iterator<E> iter = new SkippingIterator<E>(testList.iterator(), 0);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"a\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if the <code>offset</code> passed to the constructor is\n+     * greater than the decorated iterator's size. The SkippingIterator should\n+     * behave as if there are no more elements to return.\n+     */\n+    @Test\n+    public void testOffsetGreaterThanSize() {\n+        Iterator<E> iter = new SkippingIterator<E>(testList.iterator(), 10);\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if a negative <code>offset</code> is passed to the\n+     * constructor. {@link IllegalArgumentException} is expected.\n+     */\n+    @Test\n+    public void testNegativeOffset() {\n+        try {\n+            new SkippingIterator<E>(testList.iterator(), -1);\n+            fail(\"Expected IllegalArgumentException.\");\n+        } catch (IllegalArgumentException iae) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the <code>remove()</code> method being called without\n+     * <code>next()</code> being called first.\n+     */\n+    @Test\n+    public void testRemoveWithoutCallingNext() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new SkippingIterator<E>(testListCopy.iterator(), 1);\n+\n+        try {\n+            iter.remove();\n+            fail(\"Expected IllegalStateException.\");\n+        } catch (IllegalStateException ise) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the <code>remove()</code> method being called twice without calling\n+     * <code>next()</code> in between.\n+     */\n+    @Test\n+    public void testRemoveCalledTwice() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new SkippingIterator<E>(testListCopy.iterator(), 1);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        iter.remove();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Expected IllegalStateException.\");\n+        } catch (IllegalStateException ise) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test removing the first element. Verify that the element is removed from\n+     * the underlying collection.\n+     */\n+    @Test\n+    public void testRemoveFirst() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new SkippingIterator<E>(testListCopy.iterator(), 4);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+\n+        iter.remove();\n+        assertFalse(testListCopy.contains(\"e\"));\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test removing an element in the middle of the iterator. Verify that the\n+     * element is removed from the underlying collection.\n+     */\n+    @Test\n+    public void testRemoveMiddle() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new SkippingIterator<E>(testListCopy.iterator(), 3);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+\n+        iter.remove();\n+        assertFalse(testListCopy.contains(\"d\"));\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test removing the last element. Verify that the element is removed from\n+     * the underlying collection.\n+     */\n+    @Test\n+    public void testRemoveLast() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new SkippingIterator<E>(testListCopy.iterator(), 5);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+\n+        iter.remove();\n+        assertFalse(testListCopy.contains(\"g\"));\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if the decorated iterator does not support the\n+     * <code>remove()</code> method and throws an {@link UnsupportedOperationException}.\n+     */\n+    @Test\n+    public void testRemoveUnsupported() {\n+        Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+\n+        Iterator<E> iter = new SkippingIterator<E>(mockIterator, 1);\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        try {\n+            iter.remove();\n+            fail(\"Expected UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException usoe) { /* Success case */\n+        }\n+    }\n+}", "timestamp": 1432806121, "metainfo": ""}