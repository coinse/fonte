{"sha": "10e245918f6e23756cdaa02380a687f0a1aa01ba", "log": "Renamed supportsAdd and supportsRemove to isAddSupported and isRemoveSupported.  Removed commented out tests for equals and hashCode (the collection contract does not specify a specific contract on equals and hashCode), and added a comment at the top of the class so that no one comes in later and re-adds the test cases.  Removed dependence on HashBag.  If HashBag has a bug, this may adversly affect the tests that are using it.  Reimplemented without using HashBag.  Modified tests that used makeFullCollection and makeCollection to use the fixture field \"collection\" along with resetEmpty() and resetFull().  This allowed for more calls to verify to ensure that calls to methods that should not modify a collection don't actually modify it.  When removing using the iterator, an equivalent operation cannot really be performed on the confirmed collection for verification.  After some investigation, changed the existing tests (tested for instances of Set, List and Bag) to one that is a bit more generic: A new flag (that test subclasses can override) which specifies whether the elements in the collection are distinguishable from each other (and such that it might matter which element is actually removed from the collection when the iterator's remove method is called).   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestCollection.java\n+++ b/src/test/org/apache/commons/collections/TestCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.6 2002/06/18 01:14:23 mas Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/06/18 01:14:23 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCollection.java,v 1.7 2002/06/18 02:51:12 mas Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/06/18 02:51:12 $\n  *\n  * ====================================================================\n  *\n  * <p>\n  * You should create a concrete subclass of this class to test any custom\n  * {@link Collection} implementation.  At minimum, you'll have to \n- * implement the {@link #makeCollection} method.  You might want to \n+ * implement the {@link #makeCollection()} method.  You might want to \n  * override some of the additional protected methods as well:<P>\n  *\n  * <B>Element Population Methods</B><P>\n  * Override these if your collection restricts what kind of elements are\n  * allowed (for instance, if <Code>null</Code> is not permitted):\n  * <UL>\n- * <Li>{@link #getFullElements}\n- * <Li>{@link #getOtherElements}\n+ * <Li>{@link #getFullElements()}\n+ * <Li>{@link #getOtherElements()}\n  * </UL>\n  *\n  * <B>Supported Operation Methods</B><P>\n  *\n  * Override these if your collection doesn't support certain operations:\n  * <UL>\n- * <LI>{@link #supportsAdd}\n- * <LI>{@link #supportsRemove}\n+ * <LI>{@link #isAddSuppoted()}\n+ * <LI>{@link #isRemoveSupported()}\n+ * <li>{@link #areEqualElementsDistinguishable()}\n  * </UL>\n  *\n  * <B>Fixture Methods</B><P>\n  *\n- * For tests on modification operations (adds and removes), fixtures are \n- * used to verify that the the operation results in correct state for the\n- * collection.  Basically, the modification is performed against your \n- * collection implementation, and an identical modification is performed\n- * against a <I>confirmed</I> collection implementation.  A confirmed \n- * collection implementation is something like \n- * <Code>java.util.ArrayList</Code>, which is known to conform exactly to\n- * its collection interface's contract.  After the modification takes \n- * place on both your collection implementation and the confirmed \n- * collection implementation, the two collections are compared to see if\n- * their state is identical.  The comparison is usually much more \n- * involved than a simple <Code>equals</Code> test.<P>\n+ * Fixtures are used to verify that the the operation results in correct state\n+ * for the collection.  Basically, the operation is performed against your\n+ * collection implementation, and an identical operation is performed against a\n+ * <I>confirmed</I> collection implementation.  A confirmed collection\n+ * implementation is something like <Code>java.util.ArrayList</Code>, which is\n+ * known to conform exactly to its collection interface's contract.  After the\n+ * operation takes place on both your collection implementation and the\n+ * confirmed collection implementation, the two collections are compared to see\n+ * if their state is identical.  The comparison is usually much more involved\n+ * than a simple <Code>equals</Code> test.  This verification is used to ensure\n+ * proper modifications are made along with ensuring that the collection does\n+ * not change when read-only modifications are made.<P>\n  *\n  * The {@link #collection} field holds an instance of your collection\n  * implementation; the {@link #confirmed} field holds an instance of the\n- * confirmed collection implementation.  The {@link #resetEmpty} and\n- * {@link #resetFull} methods set these fields to empty or full collections,\n+ * confirmed collection implementation.  The {@link #resetEmpty()} and \n+ * {@link #resetFull()} methods set these fields to empty or full collections,\n  * so that tests can proceed from a known state.<P>\n  *\n  * After a modification operation to both {@link #collection} and\n- * {@link #confirmed}, the {@link #verify} method is invoked to compare\n- * the results.  You may want to override {@link #verify} to perform\n+ * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n+ * the results.  You may want to override {@link #verify()} to perform\n  * additional verifications.  For instance, when testing the collection\n- * views of a map, {@link TestMap} overrides {@link #verify} to make sure\n- * the map is changed after the collection view is changed.\n+ * views of a map, {@link TestMap} would override {@link #verify()} to make\n+ * sure the map is changed after the collection view is changed.\n  *\n  * If you're extending this class directly, you will have to provide \n  * implementations for the following:\n  * If your {@link Collection} fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n  * test case (method) your {@link Collection} fails.  For instance, the\n- * {@link #testIteratorFailFast} method is provided since most collections\n+ * {@link #testIteratorFailFast()} method is provided since most collections\n  * have fail-fast iterators; however, that's not strictly required by the\n  * collection contract, so you may want to override that method to do \n  * nothing.<P>\n  *\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n- * @version $Id: TestCollection.java,v 1.6 2002/06/18 01:14:23 mas Exp $\n+ * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n+ * @version $Id: TestCollection.java,v 1.7 2002/06/18 02:51:12 mas Exp $\n  */\n public abstract class TestCollection extends TestObject {\n+\n+    //\n+    // NOTE: \n+    //\n+    // Collection doesn't define any semantics for equals, and recommends you\n+    // use reference-based default behavior of Object.equals.  (And a test for\n+    // that already exists in TestObject).  Tests for equality of lists, sets\n+    // and bags will have to be written in test subclasses.  Thus, there is no\n+    // tests on Collection.equals nor any for Collection.hashCode.\n+    //\n+\n \n     // These fields are used by reset() and verify(), and any test\n     // method that tests a modification.\n \n \n     /**\n-     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n      *  collections.  Invoke this method before performing a modification\n      *  test.\n      */\n         this.confirmed = makeConfirmedFullCollection();\n     }\n \n+    /**\n+     *  Specifies whether equal elements in the collection are, in fact,\n+     *  distinguishable with information not readily available.  That is, if a\n+     *  particular value is to be removed from the collection, then there is\n+     *  one and only one value that can be removed, even if there are other\n+     *  elements which are equal to it.  \n+     *\n+     *  <P>In most collection cases, elements are not distinguishable (equal is\n+     *  equal), thus this method defaults to return false.  In some cases,\n+     *  however, they are.  For example, the collection returned from the map's\n+     *  values() collection view are backed by the map, so while there may be\n+     *  two values that are equal, their associated keys are not.  Since the\n+     *  keys are distinguishable, the values are.\n+     *\n+     *  <P>This flag is used to skip some verifications for iterator.remove()\n+     *  where it is impossible to perform an equivalent modification on the\n+     *  confirmed collection because it is not possible to determine which\n+     *  value in the confirmed collection to actually remove.  Tests that\n+     *  override the default (i.e. where equal elements are distinguishable),\n+     *  should provide additional tests on iterator.remove() to make sure the\n+     *  proper elements are removed when remove() is called on the iterator.\n+     **/\n+    protected boolean areEqualElementsDistinguishable() {\n+        return false;\n+    }\n \n     /**\n      *  Verifies that {@link #collection} and {@link #confirmed} have \n      *  identical state.\n      */\n     protected void verify() {\n+        int confirmedSize = confirmed.size();\n         assertEquals(\"Collection size should match confirmed collection's\",\n-                     confirmed.size(), collection.size());\n+                     confirmedSize, collection.size());\n         assertEquals(\"Collection isEmpty() result should match confirmed \" +\n                      \" collection's\", \n                      confirmed.isEmpty(), collection.isEmpty());\n-        Bag bag1 = new HashBag(confirmed);\n-        Bag bag2 = new HashBag(collection);\n-        assertEquals(\"Collections should contain same elements with \" + \n-                     \" the same cardinality\", bag1, bag2);\n+\n+        // verify the collections are the same by attempting to match each\n+        // object in the collection and confirmed collection.  To account for\n+        // duplicates and differing orders, each confirmed element is copied\n+        // into an array and a flag is maintained for each element to determine\n+        // whether it has been matched once and only once.  If all elements in\n+        // the confirmed collection are matched once and only once and there\n+        // aren't any elements left to be matched in the collection,\n+        // verification is a success.\n+\n+        // copy each collection value into an array\n+        Object[] confirmedValues = new Object[confirmedSize];\n+\n+        Iterator iter;\n+\n+        iter = confirmed.iterator(); \n+        int pos = 0;\n+        while(iter.hasNext()) {\n+            confirmedValues[pos++] = iter.next();\n+        }\n+\n+        // allocate an array of boolean flags for tracking values that have\n+        // been matched once and only once.\n+        boolean[] matched = new boolean[confirmedSize];\n+        \n+        // now iterate through the values of the collection and try to match\n+        // the value with one in the confirmed array.\n+        iter = collection.iterator();\n+        while(iter.hasNext()) {\n+            Object o = iter.next();\n+            boolean match = false;\n+            for(int i = 0; i < confirmedSize; i++) {\n+                if(matched[i]) {\n+                    // skip values already matched\n+                    continue;\n+                }\n+                if(o == confirmedValues[i] ||\n+                   (o != null && o.equals(confirmedValues[i]))) {\n+                    // values matched\n+                    matched[i] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            // no match found!\n+            if(!match) {\n+                fail(\"Collection should not contain a value that the \" +\n+                     \"confirmed collection does not have.\");\n+            }\n+        }\n+        \n+        // make sure there aren't any unmatched values\n+        for(int i = 0; i < confirmedSize; i++) {\n+            if(!matched[i]) {\n+                // the collection didn't match all the confirmed values\n+                fail(\"Collection should contain all values that are in the \" +\n+                     \"confirmed collection\");\n+            }\n+        }\n     }\n     \n     \n      *  Returns a confirmed full collection.\n      *  For instance, an {@link java.util.ArrayList} for lists or a\n      *  {@link java.util.HashSet} for sets.  The returned collection\n-     *  should contain the elements returned by {@link #getFullElements}.\n+     *  should contain the elements returned by {@link #getFullElements()}.\n      *\n      *  @return a confirmed full collection\n      */\n \n     /**\n      *  Returns true if the collections produced by \n-     *  {@link #makeCollection} and {@link #makeFullCollection}\n+     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n      *  support the <Code>add</Code> and <Code>addAll</Code>\n      *  operations.<P>\n      *  Default implementation returns true.  Override if your collection\n      *  class does not support add or addAll.\n      */\n-    protected boolean supportsAdd() {\n+    protected boolean isAddSupported() {\n         return true;\n     }\n \n \n     /**\n      *  Returns true if the collections produced by \n-     *  {@link #makeCollection} and {@link #makeFullCollection}\n+     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n      *  support the <Code>remove</Code>, <Code>removeAll</Code>,\n      *  <Code>retainAll</Code>, <Code>clear</Code> and\n-     *  <Code>iterator().remove</Code> methods.\n+     *  <Code>iterator().remove()</Code> methods.\n      *  Default implementation returns true.  Override if your collection\n      *  class does not support removal operations.\n      */\n-    protected boolean supportsRemove() {\n+    protected boolean isRemoveSupported() {\n         return true;\n     }\n \n \n     /**\n      *  Returns an array of objects that are contained in a collection\n-     *  produced by {@link #makeFullCollection}.  Every element in the\n+     *  produced by {@link #makeFullCollection()}.  Every element in the\n      *  returned array <I>must</I> be an element in a full collection.<P>\n      *  The default implementation returns a heterogenous array of \n      *  objects with some duplicates and with the null element.  \n      *  Override if you require specific testing elements.  Note that if you\n-     *  override {@link #makeFullCollection}, you <I>must</I> override\n+     *  override {@link #makeFullCollection()}, you <I>must</I> override\n      *  this method to reflect the contents of a full collection.\n      */\n     protected Object[] getFullElements() {\n     /**\n      *  Returns an array of elements that are <I>not</I> contained in a\n      *  full collection.  Every element in the returned array must \n-     *  not exist in a collection returned by {@link #makeFullCollection}.\n+     *  not exist in a collection returned by {@link #makeFullCollection()}.\n      *  The default implementation returns a heterogenous array of elements\n      *  without null.  Note that some of the tests add these elements\n      *  to an empty or full collection, so if your collection restricts\n     /**\n      *  Returns a full collection to be used for testing.  The collection\n      *  returned by this method should contain every element returned by\n-     *  {@link #getFullElements}.  The default implementation, in fact,\n+     *  {@link #getFullElements()}.  The default implementation, in fact,\n      *  simply invokes <Code>addAll</Code> on an empty collection with\n-     *  the results of {@link #getFullElements}.  Override this default\n+     *  the results of {@link #getFullElements()}.  Override this default\n      *  if your collection doesn't support addAll.\n      */\n     protected Collection makeFullCollection() {\n \n \n     /**\n-     *  Tests {@link Collection#add}.\n+     *  Tests {@link Collection#add(Object)}.\n      */\n     public void testCollectionAdd() {\n-        if (!supportsAdd()) return;\n+        if (!isAddSupported()) return;\n         \n         Object[] elements = getFullElements();\n         for (int i = 0; i < elements.length; i++) {\n     \n     \n     /**\n-     *  Tests {@link Collection#addAll}.\n+     *  Tests {@link Collection#addAll(Collection)}.\n      */\n     public void testCollectionAddAll() {\n-        if (!supportsAdd()) return;\n+        if (!isAddSupported()) return;\n \n         resetEmpty();\n         Object[] elements = getFullElements();\n         }\n         assertEquals(\"Size should increase after addAll\", \n                      size + elements.length, collection.size());\n-\n+        \n         resetFull();\n         size = collection.size();\n         r = collection.addAll(Arrays.asList(getFullElements()));\n             assertTrue(\"Size should increase if addAll returns true\", \n                        size < collection.size());\n         } else {\n-            assertTrue(\"Size should not change if addAll returns false\",\n-                       size == collection.size());\n+            assertEquals(\"Size should not change if addAll returns false\",\n+                         size, collection.size());\n         } \n     }\n \n \n     /**\n-     *  If {@link #supportsAdd} returns false, tests that add operations\n+     *  If {@link #isAddSupported()} returns false, tests that add operations\n      *  raise <Code>UnsupportedOperationException.\n      */\n     public void testUnsupportedAdd() {\n-        if (supportsAdd()) return;\n-        \n-        try {\n-            makeCollection().add(new Object());\n+        if (isAddSupported()) return;\n+        \n+        resetEmpty();\n+        try {\n+            collection.add(new Object());\n             fail(\"Emtpy collection should not support add.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            makeCollection().addAll(Arrays.asList(getFullElements()));\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            collection.addAll(Arrays.asList(getFullElements()));\n             fail(\"Emtpy collection should not support addAll.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            makeFullCollection().add(new Object());\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        resetFull();\n+        try {\n+            collection.add(new Object());\n             fail(\"Full collection should not support add.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            makeFullCollection().addAll(Arrays.asList(getOtherElements()));\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+        \n+        try {\n+            collection.addAll(Arrays.asList(getOtherElements()));\n             fail(\"Full collection should not support addAll.\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-    }\n-\n-\n-    /**\n-     *  Test {@link Collection#clear}.\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Test {@link Collection#clear()}.\n      */\n     public void testCollectionClear() {\n-        if (!supportsRemove()) return;\n+        if (!isRemoveSupported()) return;\n \n         resetEmpty();\n         collection.clear(); // just to make sure it doesn't raise anything\n \n     \n     /**\n-     *  Tests {@link Collection#contains}.\n+     *  Tests {@link Collection#contains(Object)}.\n      */\n     public void testCollectionContains() {\n-        Collection c = makeCollection();\n-        ArrayList elements = new ArrayList();\n-        elements.addAll(Arrays.asList(getFullElements()));\n-        elements.addAll(Arrays.asList(getOtherElements()));\n-        Iterator iter = elements.iterator();\n-        while (iter.hasNext()) {\n-            assertTrue(\"Empty collection shouldn't contain element\", \n-                       !c.contains(iter.next()));\n-        }\n-        \n-        elements.clear();\n-        elements.addAll(Arrays.asList(getFullElements()));\n-        c = makeFullCollection();\n-        iter = elements.iterator();\n-        while (iter.hasNext()) {\n-            Object o = iter.next();\n-            assertTrue(\"Full collection should contain element \" + o, \n-                       c.contains(o));\n-        }\n-        \n-        elements.clear();\n-        elements.addAll(Arrays.asList(getOtherElements()));\n-        iter = elements.iterator();\n-        while (iter.hasNext()) {\n+        Object[] elements;\n+\n+        resetEmpty();\n+        elements = getFullElements();\n+        for(int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn'y contain element\",\n+                       !collection.contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        elements = getOtherElements();\n+        for(int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn'y contain element\",\n+                       !collection.contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getFullElements();\n+        for(int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain element.\", \n+                       collection.contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getOtherElements();\n+        for(int i = 0; i < elements.length; i++) {\n             assertTrue(\"Full collection shouldn't contain element\", \n-                       !c.contains(iter.next()));\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests {@link Collection#containsAll}.\n+                       !collection.contains(elements[i]));\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link Collection#containsAll(Collection)}.\n      */\n     public void testCollectionContainsAll() {\n-        Collection c = makeCollection();\n+        resetEmpty();\n         Collection col = new HashSet();\n         assertTrue(\"Every Collection should contain all elements of an \" +\n-                   \"empty Collection.\",c.containsAll(col));\n+                   \"empty Collection.\", collection.containsAll(col));\n         col.addAll(Arrays.asList(getOtherElements()));\n         assertTrue(\"Empty Collection shouldn't contain all elements of \" +\n-                   \"a non-empty Collection.\",!c.containsAll(col));\n-        \n-        c = makeFullCollection();\n+                   \"a non-empty Collection.\", !collection.containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        resetFull();\n         assertTrue(\"Full collection shouldn't contain other elements\", \n-                   !c.containsAll(col));\n+                   !collection.containsAll(col));\n         \n         col.clear();\n         col.addAll(Arrays.asList(getFullElements()));\n-        assertTrue(\"Full collection should containAll full elements \" + \n-                   c + \" \" + col, c.containsAll(col));\n+        assertTrue(\"Full collection should containAll full elements\",\n+                   collection.containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n         col = Arrays.asList(getFullElements()).subList(2, 5);\n         assertTrue(\"Full collection should containAll partial full \" +\n-                   \"elements\", c.containsAll(col));\n+                   \"elements\", collection.containsAll(col));\n         assertTrue(\"Full collection should containAll itself\", \n-                   c.containsAll(c));\n+                   collection.containsAll(collection));\n+\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n         \n         col = new ArrayList();\n         col.addAll(Arrays.asList(getFullElements()));\n         col.addAll(Arrays.asList(getFullElements()));\n         assertTrue(\"Full collection should containAll duplicate full \" +\n-                   \"elements\", c.containsAll(col));\n-    }\n-\n-\n-    /* ---------------------------------\n-\n-     // Got rid of the equals() tests -- Collection doesn't define\n-     // any semantics for equals, and recommends you use reference-based\n-     // default behavior of Object.equals.  (And a test for that already\n-     // exists in TestObject).  Tests for equality of lists,\n-     // sets and bags will have to be written in test subclasses.\n-     \n-    public void testCollectionEqualsSelf() {\n-        Collection c = makeCollection();\n-        assertEquals(\"A Collection should equal itself\",c,c);\n-        tryToAdd(c,\"element1\");\n-        assertEquals(\"A Collection should equal itself\",c,c);\n-        tryToAdd(c,\"element1\");\n-        tryToAdd(c,\"element2\");\n-        assertEquals(\"A Collection should equal itself\",c,c);\n-    }\n-\n-    public void testCollectionEquals() {\n-        Collection c1 = makeCollection();\n-        Collection c2 = makeCollection();\n-        assertEquals(\"Empty Collections are equal.\",c1,c2);\n-\n-        boolean added1_1 = tryToAdd(c1,\"element1\");\n-        if(added1_1) {\n-            assertTrue(\"Empty Collection not equal to non-empty Collection.\",!c2.equals(c1));\n-            assertTrue(\"Non-empty Collection not equal to empty Collection.\",!c1.equals(c2));\n-        }\n-\n-        boolean added1_2 = tryToAdd(c2,\"element1\");\n-        assertEquals(\"After duplicate adds, Collections should be equal.\",c1,c2);\n-\n-        boolean added2_1 = tryToAdd(c1,\"element2\");\n-        boolean added3_2 = tryToAdd(c2,\"element3\");\n-        if(added2_1 || added3_2) {\n-            assertTrue(\"Should not be equal.\",!c1.equals(c2));\n-        }\n-    }\n-\n-    public void testCollectionHashCodeEqualsSelfHashCode() {\n-        Collection c = makeCollection();\n-        assertEquals(\"hashCode should be repeatable\",c.hashCode(),c.hashCode());\n-        tryToAdd(c,\"element1\");\n-        assertEquals(\"after add, hashCode should be repeatable\",c.hashCode(),c.hashCode());\n-    }\n-\n-    public void testCollectionHashCodeEqualsContract() {\n-        Collection c1 = makeCollection();\n-        if(c1.equals(c1)) {\n-            assertEquals(\"[1] When two objects are equal, their hashCodes should be also.\",c1.hashCode(),c1.hashCode());\n-        }\n-        Collection c2 = makeCollection();\n-        if(c1.equals(c2)) {\n-            assertEquals(\"[2] When two objects are equal, their hashCodes should be also.\",c1.hashCode(),c2.hashCode());\n-        }\n-        tryToAdd(c1,\"element1\");\n-        tryToAdd(c2,\"element1\");\n-        if(c1.equals(c2)) {\n-            assertEquals(\"[3] When two objects are equal, their hashCodes should be also.\",c1.hashCode(),c2.hashCode());\n-        }\n-    }\n-\n-    -------------------------- */\n-\n-\n-    /**\n-     *  Tests {@link Collection#isEmpty}.\n+                   \"elements\", collection.containsAll(col));\n+\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#isEmpty()}.\n      */\n     public void testCollectionIsEmpty() {\n-        Collection c = makeCollection();\n-        assertTrue(\"New Collection should be empty.\",c.isEmpty());\n-\n-        c =  makeFullCollection();\n-        assertTrue(\"Full collection shouldn't be empty\", !c.isEmpty());\n-    }\n-\n-\n-    /**\n-     *  Tests the read-only functionality of {@link Collection#iterator}.\n+        resetEmpty();\n+        assertEquals(\"New Collection should be empty.\", \n+                     true, collection.isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Full collection shouldn't be empty\", \n+                     false, collection.isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests the read-only functionality of {@link Collection#iterator()}.\n      */\n     public void testCollectionIterator() {\n-        Collection c = makeCollection();\n-        Iterator it1 = c.iterator();\n-        assertTrue(\"Iterator for empty Collection shouldn't have next.\",\n-                   !it1.hasNext());\n+        resetEmpty();\n+        Iterator it1 = collection.iterator();\n+        assertEquals(\"Iterator for empty Collection shouldn't have next.\",\n+                     false, it1.hasNext());\n         try {\n             it1.next();\n             fail(\"Iterator at end of Collection should throw \" +\n         } catch(NoSuchElementException e) {\n             // expected\n         } \n-        \n-        c = makeFullCollection();\n-        it1 = c.iterator();\n-        for (int i = 0; i < c.size(); i++) {\n+        // make sure nothing has changed after non-modification\n+        verify();\n+\n+        resetFull();\n+        it1 = collection.iterator();\n+        for (int i = 0; i < collection.size(); i++) {\n             assertTrue(\"Iterator for full collection should haveNext\", \n                        it1.hasNext());\n             it1.next();\n         assertTrue(\"Iterator should be finished\", !it1.hasNext());\n         \n         ArrayList list = new ArrayList();\n-        it1 = c.iterator();\n-        for (int i = 0; i < c.size(); i++) {\n+        it1 = collection.iterator();\n+        for (int i = 0; i < collection.size(); i++) {\n             Object next = it1.next();\n             assertTrue(\"Collection should contain element returned by \" +\n-                       \"its iterator\", c.contains(next));\n+                       \"its iterator\", collection.contains(next));\n             list.add(next);\n         }\n         try {\n         } catch (NoSuchElementException e) {\n             // expected\n         }\n-        \n-        /*\n-           Removed -- TestSet, TestBag and TestList should do this\n-        Collection elements = Arrays.asList(getFullElements());\n-        if (c instanceof Set) {\n-            assertTrue(\"Iterator should return unique elements\", \n-              new HashSet(list).equals(new HashSet(elements)));\n-        }\n-        if (c instanceof List) {\n-            assertTrue(\"Iterator should return sequenced elements\",\n-              list.equals(elements));\n-        }\n-        if (c instanceof Bag) {\n-            assertTrue(\"Iterator should return duplicate elements\",\n-              new HashBag(list).equals(new HashBag(elements)));\n-        }\n-\n-        */\n-    }\n-\n-\n-    /**\n-     *  Tests removals from {@link Collection#iterator}.\n+        // make sure nothing has changed after non-modification\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests removals from {@link Collection#iterator()}.\n      */\n     public void testCollectionIteratorRemove() {\n-        if (!supportsRemove()) return;\n+        if (!isRemoveSupported()) return;\n \n         resetEmpty();\n         try {\n         } catch (IllegalStateException e) {\n             // expected\n         }\n+        verify();\n \n         try {\n             Iterator iter = collection.iterator();\n         } catch (IllegalStateException e) {\n             // expected\n         }\n+        verify();\n \n         resetFull();\n         int size = collection.size();\n-        HashBag bag = new HashBag(collection);\n         Iterator iter = collection.iterator();\n         while (iter.hasNext()) {\n             Object o = iter.next();\n-            bag.remove(o, 1);\n             iter.remove();\n-            if ((collection instanceof Set) || (collection instanceof List) ||\n-                (collection instanceof Bag)) {\n-                // Unfortunately, we can't get away with this for a straight\n-                // collection that might have unordered duplicate elements,\n-                // but it works for Bag, Set and List.\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how). \n+            //\n+            // see areEqualElementsDistinguishable()\n+            if(!areEqualElementsDistinguishable()) {\n                 confirmed.remove(o);\n                 verify();\n             }\n+\n             size--;\n-            assertEquals(\"Collection should shrink after iterator.remove\",\n-                         collection.size(), size);\n-            if (bag.getCount(o) == 0) {\n-                assertTrue(\"Collection shouldn't contain element after \" +\n-                           \"iterator.remove\", !collection.contains(o));\n-            } else {\n-                assertTrue(\"Collection should still contain element after \" +\n-                           \"iterator.remove\", collection.contains(o));\n-            }\n+            assertEquals(\"Collection should shrink by one after \" +\n+                         \"iterator.remove\", size, collection.size());\n         }\n         assertTrue(\"Collection should be empty after iterator purge\",\n                    collection.isEmpty());\n \n \n     /**\n-     *  Tests {@link Collection#remove}.\n+     *  Tests {@link Collection#remove(Object)}.\n      */\n     public void testCollectionRemove() {\n-        if (!supportsRemove()) return;\n+        if (!isRemoveSupported()) return;\n \n         resetEmpty();\n         Object[] elements = getFullElements();\n         int size = collection.size();\n         for (int i = 0; i < elements.length; i++) {\n             resetFull();\n-            HashBag bag = new HashBag(collection);\n             assertTrue(\"Collection should remove extant element\",\n                        collection.remove(elements[i]));\n-            if ((collection instanceof Set) || (collection instanceof List) ||\n-                (collection instanceof Bag)) {\n-                // Can't do this for unordered straight collection...\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how). \n+            //\n+            // see areEqualElementsDistinguishable()\n+            if(!areEqualElementsDistinguishable()) {\n                 confirmed.remove(elements[i]);\n                 verify();\n             }\n+\n             assertEquals(\"Collection should shrink after remove\", \n                          size - 1, collection.size());\n-            bag.remove(elements[i], 1);\n-            if (bag.getCount(elements[i]) == 0) {\n-                assertTrue(\"Collection shouldn't contain removed element\",\n-                           !collection.contains(elements[i]));\n-            } else {\n-                assertTrue(\"Collection should still contain removed element\",\n-                           collection.contains(elements[i]));\n-            }\n         }\n     }\n     \n \n     /**\n-     *  Tests {@link Collection#removeAll}.\n+     *  Tests {@link Collection#removeAll(Collection)}.\n      */\n     public void testCollectionRemoveAll() {\n-        if (!supportsRemove()) return;\n+        if (!isRemoveSupported()) return;\n \n         resetEmpty();\n         assertTrue(\"Emtpy collection removeAll should return false for \" +\n                    \"nonempty input\", \n                    !collection.removeAll(new ArrayList(collection)));\n         verify();\n-\n+        \n         resetFull();\n         assertTrue(\"Full collection removeAll should return false for \" + \n                    \"empty input\", \n \n \n     /**\n-     *  Tests {@link Collection#retainAll}.\n+     *  Tests {@link Collection#retainAll(Collection)}.\n      */\n     public void testCollectionRetainAll() {\n-        if (!supportsRemove()) return;\n+        if (!isRemoveSupported()) return;\n \n         resetEmpty();\n         List elements = Arrays.asList(getFullElements());\n     \n     \n     /**\n-     *  Tests {@link Collection#size}.\n+     *  Tests {@link Collection#size()}.\n      */\n     public void testCollectionSize() {\n-        Collection c = makeCollection();\n-        assertEquals(\"Size of new Collection is 0.\",0,c.size());\n-\n-        c = makeFullCollection();\n-        assertTrue(\"Size of full collection should be nonzero\", c.size() != 0);\n+        resetEmpty();\n+        assertEquals(\"Size of new Collection is 0.\", 0, collection.size());\n+\n+        resetFull();\n+        assertTrue(\"Size of full collection should be greater than zero\", \n+                   collection.size() > 0);\n     }\n \n \n      *  Tests {@link Collection#toArray()}.\n      */\n     public void testCollectionToArray() {\n-        Collection c = makeCollection();\n+        resetEmpty();\n         assertEquals(\"Empty Collection should return empty array for toArray\",\n-                     0, c.toArray().length);\n-\n-        c = makeFullCollection();\n-        HashBag bag = new HashBag(c);\n-        Object[] array = c.toArray();\n+                     0, collection.toArray().length);\n+\n+        resetFull();\n+        Object[] array = collection.toArray();\n         assertEquals(\"Full collection toArray should be same size as \" +\n-                     \"collection\", array.length, c.size());\n+                     \"collection\", array.length, collection.size());\n+        Object[] confirmedArray = confirmed.toArray();\n+        assertEquals(\"length of array from confirmed collection should \" +\n+                     \"match the length of the collection's array\", \n+                     confirmedArray.length, array.length);\n+        boolean[] matched = new boolean[array.length];\n+\n         for (int i = 0; i < array.length; i++) {\n             assertTrue(\"Collection should contain element in toArray\",\n-                       c.contains(array[i]));\n-            bag.remove(array[i], 1);\n-        }\n-        assertTrue(\"Collection should return all its elements in toArray\",\n-                   bag.isEmpty());\n+                       collection.contains(array[i]));\n+\n+            boolean match = false;\n+            // find a match in the confirmed array\n+            for(int j = 0; j < array.length; j++) {\n+                // skip already matched\n+                if(matched[j]) continue;\n+                if(array[i] == confirmedArray[j] ||\n+                   (array[i] != null && array[i].equals(confirmedArray[j]))) {\n+                    matched[j] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            if(!match) {\n+                fail(\"element \" + i + \" in returned array should be found \" +\n+                     \"in the confirmed collection's array\");\n+            }\n+        }\n+        for(int i = 0; i < matched.length; i++) {\n+            assertEquals(\"Collection should return all its elements in \" +\n+                         \"toArray\", true, matched[i]);\n+        }\n     }\n \n \n      *  Tests {@link Collection.toArray(Object[])}.\n      */\n     public void testCollectionToArray2() {\n-        Collection c = makeCollection();\n+        resetEmpty();\n         Object[] a = new Object[] { new Object(), null, null };\n-        Object[] array = c.toArray(a);\n+        Object[] array = collection.toArray(a);\n         assertEquals(\"Given array shouldn't shrink\", array, a);\n         assertEquals(\"Last element should be set to null\", a[0], null);\n-        \n-        c = makeFullCollection();\n-        try {\n-            array = c.toArray(new Void[0]);\n+        verify();\n+\n+        resetFull();\n+        try {\n+            array = collection.toArray(new Void[0]);\n             fail(\"toArray(new Void[0]) should raise ArrayStore\");\n         } catch (ArrayStoreException e) {\n             // expected\n         }\n-\n-        try {\n-            array = c.toArray(null);\n+        verify();\n+\n+        try {\n+            array = collection.toArray(null);\n             fail(\"toArray(null) should raise NPE\");\n         } catch (NullPointerException e) {\n             // expected\n         }\n-        \n-        array = c.toArray(new Object[0]);\n-        a = c.toArray();\n+        verify();\n+        \n+        array = collection.toArray(new Object[0]);\n+        a = collection.toArray();\n         assertEquals(\"toArrays should be equal\", \n                      Arrays.asList(array), Arrays.asList(a));\n \n         \n         Class cl = (Class)classes.iterator().next();\n         a = (Object[])Array.newInstance(cl, 0);\n-        array = c.toArray(a);\n+        array = collection.toArray(a);\n         assertEquals(\"toArray(Object[]) should return correct array type\",\n                      a.getClass(), array.getClass());\n         assertEquals(\"type-specific toArrays should be equal\", \n-                     Arrays.asList(array), Arrays.asList(c.toArray()));\n+                     Arrays.asList(array), \n+                     Arrays.asList(collection.toArray()));\n+        verify();\n     }\n \n \n      *  Tests <Code>toString</Code> on a collection.\n      */\n     public void testCollectionToString() {\n-        Collection c = makeCollection();\n-        assertTrue(\"toString shouldn't return null\", c.toString() != null);\n-\n-        c = makeFullCollection();\n-        assertTrue(\"toString shouldn't return null\", c.toString() != null);\n-    }\n-\n-\n-    /**\n-     *  If supportsRemove() returns false, tests to see that remove\n+        resetEmpty();\n+        assertTrue(\"toString shouldn't return null\", \n+                   collection.toString() != null);\n+\n+        resetFull();\n+        assertTrue(\"toString shouldn't return null\", \n+                   collection.toString() != null);\n+    }\n+\n+\n+    /**\n+     *  If isRemoveSupported() returns false, tests to see that remove\n      *  operations raise an UnsupportedOperationException.\n      */\n     public void testUnsupportedRemove() {\n-        if (supportsRemove()) return;\n-\n-        try {\n-            makeCollection().clear();\n+        if (isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            collection.clear();\n             fail(\"clear should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            makeCollection().remove(null);\n+        verify();\n+\n+        try {\n+            collection.remove(null);\n             fail(\"remove should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            makeCollection().removeAll(null);\n+        verify();\n+\n+        try {\n+            collection.removeAll(null);\n             fail(\"removeAll should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            makeCollection().retainAll(null);\n+        verify();\n+\n+        try {\n+            collection.retainAll(null);\n             fail(\"removeAll should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n-\n-        try {\n-            Collection c = makeFullCollection();\n-            Iterator iterator = c.iterator();\n+        verify();\n+\n+        resetFull();\n+        try {\n+            Iterator iterator = collection.iterator();\n             iterator.next();\n             iterator.remove();\n             fail(\"iterator.remove should raise UnsupportedOperationException\");\n         } catch (UnsupportedOperationException e) {\n             // expected\n         }\n+        verify();\n \n     }\n \n      *  Tests that the collection's iterator is fail-fast.  \n      */\n     public void testCollectionIteratorFailFast() {\n-        if (supportsAdd()) {\n+        if (isAddSupported()) {\n+            resetFull();\n             try {\n-                Collection c = makeFullCollection();\n-                Iterator iter = c.iterator();\n-                c.add(getOtherElements()[0]);\n+                Iterator iter = collection.iterator();\n+                Object o = getOtherElements()[0];\n+                collection.add(o);\n+                confirmed.add(o);\n                 iter.next();\n                 fail(\"next after add should raise ConcurrentModification\");\n             } catch (ConcurrentModificationException e) {\n                 // expected\n             }\n+            verify();\n             \n+            resetFull();\n             try {\n-                Collection c = makeFullCollection();\n-                Iterator iter = c.iterator();\n-                c.addAll(Arrays.asList(getOtherElements()));\n+                Iterator iter = collection.iterator();\n+                collection.addAll(Arrays.asList(getOtherElements()));\n+                confirmed.addAll(Arrays.asList(getOtherElements()));\n                 iter.next();\n                 fail(\"next after addAll should raise ConcurrentModification\");\n             } catch (ConcurrentModificationException e) {\n                 // expected\n             }\n-        }\n-\n-        if (!supportsRemove()) return;\n-\n-        try {\n-            Collection c = makeFullCollection();\n-            Iterator iter = c.iterator();\n-            c.clear();\n+            verify();\n+        }\n+\n+        if (!isRemoveSupported()) return;\n+\n+        resetFull();\n+        try {\n+            Iterator iter = collection.iterator();\n+            collection.clear();\n             iter.next();\n             fail(\"next after clear should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n             // (also legal given spec)\n         }\n         \n-        try {\n-            Collection c = makeFullCollection();\n-            Iterator iter = c.iterator();\n-            c.remove(getFullElements()[0]);\n+        resetFull();\n+        try {\n+            Iterator iter = collection.iterator();\n+            collection.remove(getFullElements()[0]);\n             iter.next();\n             fail(\"next after remove should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n             // expected\n         }\n \n-        try {\n-            Collection c = makeFullCollection();\n-            Iterator iter = c.iterator();\n-            c.removeAll(Arrays.asList(getFullElements()).subList(2,5));\n+        resetFull();\n+        try {\n+            Iterator iter = collection.iterator();\n+            List sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            collection.removeAll(sublist);\n             iter.next();\n             fail(\"next after removeAll should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n             // expected\n         }\n \n-        try {\n-            Collection c = makeFullCollection();\n-            Iterator iter = c.iterator();\n-            c.retainAll(Arrays.asList(getFullElements()).subList(2,5));\n+        resetFull();\n+        try {\n+            Iterator iter = collection.iterator();\n+            List sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            collection.retainAll(sublist);\n             iter.next();\n             fail(\"next after retainAll should raise ConcurrentModification\");\n         } catch (ConcurrentModificationException e) {\n      *\n      * Fails any Throwable except UnsupportedOperationException,\n      * ClassCastException, or IllegalArgumentException is thrown.\n+     *\n+     * @deprecated explicitly check for allowed exceptions rather than using\n+     * this method to assume any of UnsupportedOperationException,\n+     * ClassCaseException, or IllegalArgumentException are allowed.  \n      */\n     protected boolean tryToAdd(Collection c,Object obj) {\n         // FIXME: Delete this method after TestList is patched\n     \n     /**\n      *  Returns a list of elements suitable for return by\n-     *  {@link getFullElements}.  The array returned by this method\n+     *  {@link getFullElements()}.  The array returned by this method\n      *  does not include null, but does include a variety of objects \n      *  of different types.  Override getFullElements to return\n      *  the results of this method if your collection does not support\n \n     /**\n      *  Returns the default list of objects returned by \n-     *  {@link getOtherElements}.  Includes many objects\n+     *  {@link getOtherElements()}.  Includes many objects\n      *  of different types.\n      */\n     public static Object[] getOtherNonNullElements() {\n \n     /**\n      *  Returns a list of string elements suitable for return by\n-     *  {@link getFullElements}.  Override getFullElements to return\n+     *  {@link getFullElements()}.  Override getFullElements to return\n      *  the results of this method if your collection does not support\n      *  heterogenous elements or the null element.\n      */\n \n     /**\n      *  Returns a list of string elements suitable for return by\n-     *  {@link getOtherElements}.  Override getOtherElements to return\n+     *  {@link getOtherElements()}.  Override getOtherElements to return\n      *  the results of this method if your collection does not support\n      *  heterogenous elements or the null element.\n      */", "timestamp": 1024368672, "metainfo": ""}