{"sha": "0574dfb035bc8e9f1724dce6dc5bfd788a2b0c01", "log": "[COLLECTIONS-422] Added CollectionUtils.permutations(Collection) and PermutationIterator. Thanks for Benoit Corne for the patch.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.ListIterator;\n import java.util.Map;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n import org.apache.commons.collections4.functors.Equator;\n import org.apache.commons.collections4.functors.TruePredicate;\n+import org.apache.commons.collections4.iterators.PermutationIterator;\n \n /**\n  * Provides utility methods and decorators for {@link Collection} instances.\n     }\n \n     //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a {@link Collection} of all the permutations of the input collection.\n+     * <p>\n+     * NOTE: the number of permutations of a given collection is equal to n!, where\n+     * n is the size of the collection. Thus, the resulting collection will become\n+     * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n+     * <p>\n+     * For larger collections it is advised to use a {@link PermutationIterator} to\n+     * iterate over all permutations.\n+     * \n+     * @see PermutationIterator\n+     * \n+     * @param <E>  the element type\n+     * @param collection  the collection to create permutations for, may not be null\n+     * @return an unordered collection of all permutations of the input collection\n+     * @throws NullPointerException if collection is null\n+     */\n+    public static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n+        final PermutationIterator<E> it = new PermutationIterator<E>(collection);\n+        final Collection<List<E>> result = new LinkedList<List<E>>();\n+        while (it.hasNext()) {\n+            result.add(it.next());\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a collection containing all the elements in <code>collection</code>\n      * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * This iterator creates permutations of an input collection, using the\n+ * Steinhaus-Johnson-Trotter algorithm (also called plain changes).\n+ * <p>\n+ * The iterator will return exactly n! permutations of the input collection.\n+ * The {@code remove()} operation is not supported, and will throw an\n+ * {@code UnsupportedOperationException}.\n+ * <p>\n+ * NOTE: in case an empty collection is provided, the iterator will\n+ * return exactly one empty list as result, as 0! = 1. \n+ *\n+ * @param <E>  the type of the objects being permuted\n+ *\n+ * @version $Id$\n+ * @since 4.0\n+ */\n+public class PermutationIterator<E> implements Iterator<List<E>> {\n+\n+    /**\n+     * Permutation is done on theses keys to handle equal objects.\n+     */\n+    private int[] keys;\n+\n+    /**\n+     * Mapping between keys and objects.\n+     */\n+    private Map<Integer, E> objectMap;\n+\n+    /**\n+     * Direction table used in the algorithm:\n+     * <ul>\n+     *   <li>false is left</li>\n+     *   <li>true is right</li>\n+     * </ul>\n+     */\n+    private boolean[] direction;\n+\n+    /**\n+     * Next permutation to return. When a permutation is requested\n+     * this instance is provided and the next one is computed.\n+     */\n+    private List<E> nextPermutation;\n+\n+    /**\n+     * Standard constructor for this class.\n+     * @param coll  the collection to generate permutations for\n+     * @throws NullPointerException if coll is null\n+     */\n+    public PermutationIterator(final Collection<E> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+\n+        keys = new int[coll.size()];\n+        direction = new boolean[coll.size()];\n+        Arrays.fill(direction, false);\n+        int value = 1;\n+        objectMap = new HashMap<Integer, E>();\n+        for (E e : coll) {\n+            objectMap.put(value, e);\n+            keys[value - 1] = value;\n+            value++;\n+        }\n+        nextPermutation = new ArrayList<E>(coll);\n+    }\n+\n+    /**\n+     * Indicates if there are more permutation available.\n+     * @return true if there are more permutations, otherwise false\n+     */\n+    public boolean hasNext() {\n+        return nextPermutation != null;\n+    }\n+\n+    /**\n+     * Returns the next permutation of the input collection.\n+     * @return a list of the permutator's elements representing a permutation\n+     * @throws NoSuchElementException if there are no more permutations\n+     */\n+    public List<E> next() {\n+        if (!hasNext()) {\n+            throw new NoSuchElementException();\n+        }\n+\n+        // find the largest mobile integer k\n+        int indexOfLargestMobileInteger = -1;\n+        int largestKey = -1;\n+        for (int i = 0; i < keys.length; i++) {\n+            if ((direction[i] && i < keys.length - 1 && keys[i] > keys[i + 1]) ||\n+                (!direction[i] && i > 0 && keys[i] > keys[i - 1])) {\n+                if (keys[i] > largestKey) {\n+                    largestKey = keys[i];\n+                    indexOfLargestMobileInteger = i;\n+                }\n+            }\n+        }\n+        if (largestKey == -1) {\n+            List<E> toReturn = nextPermutation;\n+            nextPermutation = null;\n+            return toReturn;\n+        }\n+\n+        // swap k and the adjacent integer it is looking at\n+        final int offset = direction[indexOfLargestMobileInteger] ? 1 : -1;\n+        final int tmpKey = keys[indexOfLargestMobileInteger];\n+        keys[indexOfLargestMobileInteger] = keys[indexOfLargestMobileInteger + offset];\n+        keys[indexOfLargestMobileInteger + offset] = tmpKey;\n+        boolean tmpDirection = direction[indexOfLargestMobileInteger];\n+        direction[indexOfLargestMobileInteger] = direction[indexOfLargestMobileInteger + offset];\n+        direction[indexOfLargestMobileInteger + offset] = tmpDirection;\n+\n+        // reverse the direction of all integers larger than k and build the result\n+        final List<E> nextP = new ArrayList<E>();\n+        for (int i = 0; i < keys.length; i++) {\n+            if (keys[i] > largestKey) {\n+                direction[i] = !direction[i];\n+            }\n+            nextP.add(objectMap.get(keys[i]));\n+        }\n+        final List<E> result = nextPermutation;\n+        nextPermutation = nextP;\n+        return result;\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n         assertEquals(\"Merge two lists 2 - ignore duplicates\", combinedList, result2);\n     }\n     \n+    @Test(expected=NullPointerException.class)\n+    public void testPermutationsWithNullCollection() {\n+        CollectionUtils.permutations(null);\n+    }\n+    \n+    @Test\n+    public void testPermutations() {\n+        List<Integer> sample = collectionA.subList(0, 5);\n+        Collection<List<Integer>> permutations = CollectionUtils.permutations(sample);\n+        \n+        // result size = n!\n+        int collSize = sample.size();\n+        int factorial = 1;\n+        for (int i = 1; i <= collSize; i++) {\n+            factorial *= i;\n+        }\n+        assertEquals(factorial, permutations.size());\n+    }\n+    \n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * Test class for PermutationIterator.\n+ *\n+ * @version $Id$\n+ * @since 4.0\n+ */\n+public class PermutationIteratorTest extends AbstractIteratorTest<List<Character>> {\n+\n+    protected Character[] testArray = { 'A', 'B', 'C' };\n+    protected List<Character> testList;\n+\n+    public PermutationIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        testList = new ArrayList<Character>();\n+        testList.addAll(Arrays.asList(testArray));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+    \n+    public boolean supportsEmptyIterator() {\n+        return false;\n+    }\n+\n+    @Override\n+    public PermutationIterator<Character> makeEmptyIterator() {\n+        return new PermutationIterator<Character>(new ArrayList<Character>());\n+    }\n+\n+    @Override\n+    public PermutationIterator<Character> makeObject() {\n+        return new PermutationIterator<Character>(testList);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testPermutationResultSize() {\n+        int factorial = 1;\n+        for (int i = 0; i < 8; i++, factorial*=i) {\n+            List<Integer> list = new ArrayList<Integer>();\n+            for (int j = 0; j < i; j++) {\n+                list.add(j);\n+            }\n+            Iterator<List<Integer>> it = new PermutationIterator<Integer>(list);\n+            int count = 0;\n+            while (it.hasNext()) {\n+                it.next();\n+                count++;\n+            }\n+            assertEquals(factorial, count);\n+        }\n+    }\n+\n+    /**\n+     * test checking that all the permutations are returned\n+     */\n+    public void testPermutationExhaustivity() {\n+        List<Character> perm1 = new ArrayList<Character>();\n+        List<Character> perm2 = new ArrayList<Character>();\n+        List<Character> perm3 = new ArrayList<Character>();\n+        List<Character> perm4 = new ArrayList<Character>();\n+        List<Character> perm5 = new ArrayList<Character>();\n+        List<Character> perm6 = new ArrayList<Character>();\n+\n+        perm1.add('A');\n+        perm2.add('A');\n+        perm3.add('B');\n+        perm4.add('B');\n+        perm5.add('C');\n+        perm6.add('C');\n+\n+        perm1.add('B');\n+        perm2.add('C');\n+        perm3.add('A');\n+        perm4.add('C');\n+        perm5.add('A');\n+        perm6.add('B');\n+\n+        perm1.add('C');\n+        perm2.add('B');\n+        perm3.add('C');\n+        perm4.add('A');\n+        perm5.add('B');\n+        perm6.add('A');\n+\n+        List<List<Character>> results = new ArrayList<List<Character>>();\n+        \n+        PermutationIterator<Character> it = makeObject();\n+        while (it.hasNext()) {\n+            List<Character> next = it.next();\n+            results.add(next);\n+        }\n+        //3! permutation for 3 elements\n+        assertEquals(6, results.size());\n+        assertTrue(results.contains(perm1));\n+        assertTrue(results.contains(perm2));\n+        assertTrue(results.contains(perm3));\n+        assertTrue(results.contains(perm4));\n+        assertTrue(results.contains(perm5));\n+        assertTrue(results.contains(perm6));\n+    }\n+\n+    /**\n+     * test checking that all the permutations are returned only once.\n+     */    \n+    public void testPermutationUnicity() {\n+        List<List<Character>> resultsList = new ArrayList<List<Character>>();\n+        Set<List<Character>> resultsSet = new HashSet<List<Character>>();\n+        \n+        PermutationIterator<Character> it = makeObject();\n+        while (it.hasNext()) {\n+            List<Character> permutation = it.next();\n+            resultsList.add(permutation);\n+            resultsSet.add(permutation);\n+        }\n+        //3! permutation for 3 elements\n+        assertEquals(6, resultsList.size());\n+        assertEquals(6, resultsSet.size());\n+    }\n+\n+    public void testPermutationException() {\n+        List<List<Character>> resultsList = new ArrayList<List<Character>>();\n+        \n+        PermutationIterator<Character> it = makeObject();\n+        while (it.hasNext()) {\n+            List<Character> permutation = it.next();\n+            resultsList.add(permutation);\n+        }\n+        //asking for another permutation should throw an exception\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPermutatorHasMore() {\n+        PermutationIterator<Character> it = makeObject();\n+        for (int i = 0; i < 6; i++) {\n+            assertTrue(it.hasNext());\n+            it.next();\n+        }\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testEmptyCollection() {\n+        PermutationIterator<Character> it = makeEmptyIterator();\n+        // there is one permutation for an empty set: 0! = 1\n+        assertTrue(it.hasNext());\n+        \n+        List<Character> nextPermutation = it.next();\n+        assertEquals(0, nextPermutation.size());\n+        \n+        assertFalse(it.hasNext());\n+    }\n+}", "timestamp": 1366557418, "metainfo": ""}