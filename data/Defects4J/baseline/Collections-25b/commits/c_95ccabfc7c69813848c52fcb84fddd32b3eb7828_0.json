{"sha": "95ccabfc7c69813848c52fcb84fddd32b3eb7828", "log": "Added a bunch of generic tests to the TestMap.java class.  Also added cooresponding changes to other tests.  These tests expose a few deviations from the Map contract in BeanMap.  These should either be fixed, or BeanMap should be documented to describe how it differs from the Map contract.   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestBeanMap.java\n+++ b/src/test/org/apache/commons/collections/TestBeanMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBeanMap.java,v 1.1 2002/02/20 23:33:23 morgand Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/02/20 23:33:23 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBeanMap.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n         return new TestSuite(TestBeanMap.class);\n     }\n \n-    public Map makeMap() {\n+/*\n+  note to self.  The getter and setter methods were generated by copying the\n+  field declarations and using the following regular expression search and\n+  replace:\n+\n+  From:\n+        private \\(.*\\) some\\(.*\\);\n+  To:\n+        public \\1 getSome\\2Value() {\n+            return some\\2;\n+        }\n+        public void setSome\\2Value(\\1 value) {\n+            some\\2 = value;\n+        } \n+\n+  Also note:  The sample keys and mappings were generated manually.\n+*/\n+\n+\n+    public static class BeanWithProperties {\n+        private int someInt;\n+        private long someLong;\n+        private double someDouble;\n+        private float someFloat;\n+        private short someShort;\n+        private byte someByte;\n+        private char someChar;\n+        private Integer someInteger;\n+        private String someString;\n+        private Object someObject;\n+\n+        public int getSomeIntValue() {\n+            return someInt;\n+        }\n+        public void setSomeIntValue(int value) {\n+            someInt = value;\n+        }\n+\n+        public long getSomeLongValue() {\n+            return someLong;\n+        }\n+        public void setSomeLongValue(long value) {\n+            someLong = value;\n+        }\n+\n+        public double getSomeDoubleValue() {\n+            return someDouble;\n+        }\n+        public void setSomeDoubleValue(double value) {\n+            someDouble = value;\n+        }\n+\n+        public float getSomeFloatValue() {\n+            return someFloat;\n+        }\n+        public void setSomeFloatValue(float value) {\n+            someFloat = value;\n+        }\n+\n+        public short getSomeShortValue() {\n+            return someShort;\n+        }\n+        public void setSomeShortValue(short value) {\n+            someShort = value;\n+        }\n+\n+        public byte getSomeByteValue() {\n+            return someByte;\n+        }\n+        public void setSomeByteValue(byte value) {\n+            someByte = value;\n+        }\n+\n+        public char getSomeCharValue() {\n+            return someChar;\n+        }\n+        public void setSomeCharValue(char value) {\n+            someChar = value;\n+        }\n+\n+        public String getSomeStringValue() {\n+            return someString;\n+        }\n+        public void setSomeStringValue(String value) {\n+            someString = value;\n+        }\n+\n+        public Integer getSomeIntegerValue() {\n+            return someInteger;\n+        }\n+        public void setSomeIntegerValue(Integer value) {\n+            someInteger = value;\n+        }\n+\n+        public Object getSomeObjectValue() {\n+            return someObject;\n+        }\n+        public void setSomeObjectValue(Object value) {\n+            someObject = value;\n+        }\n+    }\n+\n+\n+/*\n+  note to self.  The Sample keys were generated by copying the field\n+  declarations and using the following regular expression search and replace:\n+\n+  From:\n+        private \\(.*\\) some\\(.*\\);\n+  To:\n+            \"some\\2Value\", \n+\n+  Then, I manually added the \"class\" key, which is a property that exists for\n+  all beans (and all objects for that matter.\n+*/\n+\n+    public Object[] getSampleKeys() {\n+        Object[] keys = new Object[] {\n+            \"someIntValue\",\n+            \"someLongValue\",\n+            \"someDoubleValue\",\n+            \"someFloatValue\",\n+            \"someShortValue\",\n+            \"someByteValue\",\n+            \"someCharValue\",\n+            \"someIntegerValue\",\n+            \"someStringValue\",\n+            \"someObjectValue\",\n+            \"class\",\n+        };\n+        return keys;\n+    }\n+\n+/*\n+    note to self: the sample values were created manually\n+*/\n+\n+    public Object[] getSampleValues() {\n+        Object[] values = new Object[] {\n+            new Integer(1234),\n+            new Long(1298341928234L),\n+            new Double(123423.34),\n+            new Float(1213332.12f),\n+            new Short((short)134),\n+            new Byte((byte)10),\n+            new Character('a'),\n+            new Integer(1432),\n+            \"SomeStringValue\",\n+            new Object(),\n+            BeanWithProperties.class,\n+        };\n+        return values;\n+    }\n+\n+    public Object[] getNewSampleValues() {\n+        Object[] values = new Object[] {\n+            new Integer(223),\n+            new Long(23341928234L),\n+            new Double(23423.34),\n+            new Float(213332.12f),\n+            new Short((short)234),\n+            new Byte((byte)20),\n+            new Character('b'),\n+            new Integer(232),\n+            \"SomeNewStringValue\",\n+            new Object(),\n+            null,\n+        };\n+        return values;\n+    }\n+\n+    public boolean isAddRemoveModifiable() {\n+        return false;\n+    }\n+  \n+    public Map makeFullMap() {\n+        return new BeanMap(new BeanWithProperties());\n+    }\n+\n+    public Map makeEmptyMap() {\n         return new BeanMap();\n     }\n-\n }\n--- a/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.2 2002/02/20 23:48:13 morgand Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/02/20 23:48:13 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n         return new TestSuite(TestDoubleOrderedMap.class);\n     }\n \n+    /**\n+     *  The default comparator in double ordered map does not allow null keys.\n+     **/\n+    public boolean useNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     *  The default comparator in double ordered map does not allow null keys,\n+     *  and values are keys in this map.\n+     **/\n+    public boolean useNullValue() {\n+        return false;\n+    }\n+\n+    /**\n+     *  Double ordered map does not support duplicate values\n+     **/\n+    public boolean useDuplicateValues() {\n+        return false;\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new DoubleOrderedMap();\n+    }\n+\n     public Map makeMap() {\n         return new DoubleOrderedMap();\n     }\n--- a/src/test/org/apache/commons/collections/TestFastHashMap1.java\n+++ b/src/test/org/apache/commons/collections/TestFastHashMap1.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap1.java,v 1.1 2001/04/21 12:22:30 craigmcc Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/04/21 12:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap1.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n  * Test FastHashMap in <strong>fast</strong> mode.\n  *\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastHashMap1.java,v 1.1 2001/04/21 12:22:30 craigmcc Exp $\n+ * @version $Id: TestFastHashMap1.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n  */\n public class TestFastHashMap1 extends TestFastHashMap\n {\n         return (fhm);\n     }\n \n+    /**\n+     *  When the fast hash map is in fast mode, the underlying hash map is\n+     *  cloned on modification (i.e. on a put).  Because of that, any\n+     *  previously existing entry set will be representing the old (pre-clone)\n+     *  map and will not reflect changes made to the map after the clone.  So,\n+     *  we must override this test.\n+     **/\n+    public void testEntrySetChangesWithMapPut() {\n+    }\n+\n+    /**\n+     *  When the fast hash map is in fast mode, the underlying hash map is\n+     *  cloned on modification (i.e. on a remove).  Because of that, any\n+     *  previously existing entry set will be representing the old (pre-clone)\n+     *  map and will not reflect changes made to the map after the clone.  So,\n+     *  we must override this test.\n+     **/\n+    public void testEntrySetChangesWithMapRemove() {\n+    }\n+\n+    /**\n+     *  When the fast hash map is in fast mode, the underlying hash map is\n+     *  cloned on modification (i.e. on a put).  Because of that, any\n+     *  previously existing entry set will be representing the old (pre-clone)\n+     *  map, so changes to the set will not be seen in the map. So, we must\n+     *  override this test.\n+     **/\n+    public void testEntrySetRemoveCausesMapModification() {\n+    }\n+\n     public void setUp()\n     {\n         map = (HashMap) makeMap();\n--- a/src/test/org/apache/commons/collections/TestFastTreeMap.java\n+++ b/src/test/org/apache/commons/collections/TestFastTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap.java,v 1.3 2001/04/21 12:22:30 craigmcc Exp $\n- * $Revision: 1.3 $\n- * $Date: 2001/04/21 12:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap.java,v 1.4 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastTreeMap.java,v 1.3 2001/04/21 12:22:30 craigmcc Exp $\n+ * @version $Id: TestFastTreeMap.java,v 1.4 2002/02/22 02:18:50 mas Exp $\n  */\n public class TestFastTreeMap extends TestTreeMap\n {\n         ftm.setFast(false);\n         return (ftm);\n     }\n+  \n+    /**\n+     *  The comparator for the fast tree map does not support null keys.\n+     **/\n+    public boolean useNullKey() {\n+      return false;\n+    }\n \n     public void setUp()\n     {\n--- a/src/test/org/apache/commons/collections/TestFastTreeMap1.java\n+++ b/src/test/org/apache/commons/collections/TestFastTreeMap1.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap1.java,v 1.1 2001/04/21 12:22:30 craigmcc Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/04/21 12:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap1.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n  * Test FastTreeMap in <strong>fast</strong> mode.\n  *\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastTreeMap1.java,v 1.1 2001/04/21 12:22:30 craigmcc Exp $\n+ * @version $Id: TestFastTreeMap1.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n  */\n public class TestFastTreeMap1 extends TestFastTreeMap\n {\n         map = (TreeMap) makeMap();\n     }\n \n+    /**\n+     *  When the fast tree map is in fast mode, the underlying tree map is\n+     *  cloned on modification (i.e. on a put).  Because of that, any\n+     *  previously existing entry set will be representing the old (pre-clone)\n+     *  map and will not reflect changes made to the map after the clone.  So,\n+     *  we must override this test.\n+     **/\n+    public void testMapEntrySetChangesWithMapPut() {\n+    }\n+\n+    /**\n+     *  When the fast tree map is in fast mode, the underlying tree map is\n+     *  cloned on modification (i.e. on a put).  Because of that, any\n+     *  previously existing entry set will be representing the old (pre-clone)\n+     *  map and will not reflect changes made to the map after the clone.  So,\n+     *  we must override this test.\n+     **/\n+    public void testMapEntrySetChangesWithMapRemove() {\n+    }\n+\n+    /**\n+     *  When the fast tree map is in fast mode, the underlying tree map is\n+     *  cloned on modification (i.e. on a put).  Because of that, any\n+     *  previously existing entry set will be representing the old (pre-clone)\n+     *  map, so changes to the set will not be seen in the map. So, we must\n+     *  override this test.\n+     **/\n+    public void testMapEntrySetRemoveCausesMapModification() {\n+    }\n }\n--- a/src/test/org/apache/commons/collections/TestHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestHashMap.java,v 1.2 2001/07/14 23:33:27 craigmcc Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/07/14 23:33:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestHashMap.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestHashMap.java,v 1.2 2001/07/14 23:33:27 craigmcc Exp $\n+ * @version $Id: TestHashMap.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n  */\n public class TestHashMap extends TestMap\n {\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeMap() {\n+    public Map makeEmptyMap() {\n         HashMap hm = new HashMap();\n         return (hm);\n     }\n \n     public void setUp()\n     {\n-        map = (HashMap) makeMap();\n+        map = (HashMap) makeEmptyMap();\n     }\n \n     public void testNewMap()\n--- a/src/test/org/apache/commons/collections/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/TestLRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.14 2002/02/20 22:38:46 morgand Exp $\n- * $Revision: 1.14 $\n- * $Date: 2002/02/20 22:38:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.15 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.15 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n- * @version $Id: TestLRUMap.java,v 1.14 2002/02/20 22:38:46 morgand Exp $\n+ * @version $Id: TestLRUMap.java,v 1.15 2002/02/22 02:18:50 mas Exp $\n  */\n public class TestLRUMap extends TestSequencedHashMap\n {\n         map2.put(new Integer(1),\"foo\");\n         map2.put(new Integer(2),\"foo\");\n         map2.put(new Integer(3),\"foo\");\n-        map2.put(new Integer(4),\"foo\");\n-\n-        assertTrue(\"last value should exist\",map2.get(new Integer(4)).equals(\"foo\"));\n+        map2.put(new Integer(4),\"foo\"); // removes 1 since max size exceeded\n+        map2.removeLRU();  // should be Integer(2)\n+\n+        assertTrue(\"Second to last value should exist\",map2.get(new Integer(3)).equals(\"foo\"));\n+        assertTrue(\"First value inserted should not exist\", map2.get(new Integer(1)) == null);\n+    }\n+\n+    public void testMultiplePuts() {\n+        LRUMap map2 = new LRUMap(2);\n+        map2.put(new Integer(1),\"foo\");\n+        map2.put(new Integer(2),\"bar\");\n+        map2.put(new Integer(3),\"foo\");\n+        map2.put(new Integer(4),\"bar\");\n+\n+        assertTrue(\"last value should exist\",map2.get(new Integer(4)).equals(\"bar\"));\n         assertTrue(\"LRU should not exist\", map2.get(new Integer(1)) == null);\n     }\n \n--- a/src/test/org/apache/commons/collections/TestMap.java\n+++ b/src/test/org/apache/commons/collections/TestMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.7 2002/02/21 20:14:37 morgand Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/02/21 20:14:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.8 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n import junit.framework.*;\n import java.util.Collection;\n import java.util.Map;\n+import java.util.Collection;\n import java.util.Set;\n+import java.util.Iterator;\n+import java.util.HashSet;\n+import java.util.NoSuchElementException;\n \n /**\n  * Tests base {@link java.util.Map} methods and contracts.\n  * <p>\n- * To use, simply extend this class, and implement\n- * the {@link #makeMap} method.\n+ * If your class implements the full Map interface, including optional\n+ * operations, simply extend this class, and implement the {@link\n+ * #makeEmptyMap()} method.\n  * <p>\n- * If your {@link Map} fails one of these tests by design,\n- * you may still use this base set of cases.  Simply override the\n- * test case (method) your {@link Map} fails.\n- *\n+ * If your {@link Map} fails one of these tests by design, you may still use\n+ * this base set of cases.  Simply override the test case (method) your {@link\n+ * Map} fails and/or the methods that define the assumptions used by the test\n+ * cases.  For example, if your map does not allow duplicate values, override\n+ * {@link useDuplicateValues()} and have it return <code>false</code>\n+ *\n+ * @author Michael Smith\n  * @author Rodney Waldhoff\n- * @version $Id: TestMap.java,v 1.7 2002/02/21 20:14:37 morgand Exp $\n+ * @version $Id: TestMap.java,v 1.8 2002/02/22 02:18:50 mas Exp $\n  */\n public abstract class TestMap extends TestObject {\n     public TestMap(String testName) {\n     }\n \n     /**\n-     * Return a new, empty {@link Map} to used for testing.\n+     *  Override if your map does not allow a <code>null</code> key.  The\n+     *  default implementation returns <code>true</code>\n+     **/\n+    public boolean useNullKey() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map does not allow <code>null</code> values.  The\n+     *  default implementation returns <code>true</code>.\n+     **/\n+    public boolean useNullValue() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map does not allow duplicate values.  The default\n+     *  implementation returns <code>true</code>.\n+     **/\n+    public boolean useDuplicateValues() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map allows its mappings to be changed to new values.\n+     *  The default implementation returns <code>true</code>.\n+     **/\n+    public boolean isChangeable() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map does not allow add/remove modifications.  The\n+     *  default implementation returns <code>true</code>.\n+     **/\n+    public boolean isAddRemoveModifiable() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns the set of keys in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleValues()} and all array elements must be different. The\n+     *  default implementation constructs a set of String keys, and includes a\n+     *  single null key if {@link #useNullKey()} returns <code>true</code>.\n+     **/\n+    public Object[] getSampleKeys() {\n+        Object[] result = new Object[] {\n+            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\", \n+            \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n+            \"key\",\n+            \"key2\",\n+            (useNullKey()) ? null : \"nonnullkey\"\n+        };\n+        return result;\n+    }\n+\n+    /**\n+     *  Returns the set of values in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleKeys()}.  The default implementation contructs a set of\n+     *  String values and includes a single null value if {@link\n+     *  #useNullValue()} returns <code>true</code>, and includes two values\n+     *  that are the same if {@link #useDuplicateValues()} returns\n+     *  <code>true</code>.\n+     **/\n+    public Object[] getSampleValues() {\n+        Object[] result = new Object[] {\n+            \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n+            \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n+            (useNullValue()) ? null : \"nonnullvalue\",\n+            \"value\",\n+            (useDuplicateValues()) ? \"value\" : \"value2\",\n+        };\n+        return result;\n+    }\n+\n+    /**\n+     *  Returns a the set of values that can be used to replace the values\n+     *  returned from {@link #getSampleValues()}.  This method must return an\n+     *  array with the same length as {@link #getSampleValues()}.  The values\n+     *  returned from this method should not be the same as those returned from\n+     *  {@link #getSampleValues()}.  The default implementation constructs a\n+     *  set of String values and includes a single null value if {@link\n+     *  #useNullValue()} returns <code>true</code>, and includes two values\n+     *  that are the same if {@link #useDuplicateValues()} returns\n+     *  <code>true</code>.  \n+     **/\n+    public Object[] getNewSampleValues() {\n+        Object[] result = new Object[] {\n+            (useNullValue()) ? null : \"newnonnullvalue\",\n+            \"newvalue\",\n+            (useDuplicateValues()) ? \"newvalue\" : \"newvalue2\",\n+            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\", \n+            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\", \n+            \"newseev\", \"newyouv\", \"newallv\", \"newagainv\",\n+        };\n+        return result;\n+    }\n+\n+    /**\n+     *  Helper method to add all the mappings described by {@link\n+     *  #getSampleKeys()} and {@link #getSampleValues()}.\n+     **/\n+    public void addSampleMappings(Map m) {\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        \n+        for(int i = 0; i < keys.length; i++) {\n+            try {\n+                m.put(keys[i], values[i]);\n+            } catch (NullPointerException exception) {\n+                assertTrue(\"NullPointerException only allowed to be thrown \" +\n+                           \"if either the key or value is null.\", \n+                           keys[i] == null || values[i] == null);\n+                \n+                assertTrue(\"NullPointerException on null key, but \" +\n+                           \"useNullKey is not overridden to return false.\", \n+                           keys[i] == null || !useNullKey());\n+                \n+                assertTrue(\"NullPointerException on null value, but \" +\n+                           \"useNullValue is not overridden to return false.\",\n+                           values[i] == null || !useNullValue());\n+                \n+                assertTrue(\"Unknown reason for NullPointer.\", false);\n+            }\n+        }\n+        assertEquals(\"size must reflect number of mappings added.\",\n+                     keys.length, m.size());\n+    }\n+\n+    /**\n+     * Return a new, empty {@link Map} to be used for testing. \n      */\n-    public abstract Map makeMap();\n+    public abstract Map makeEmptyMap();\n+\n+    /**\n+     *  Return a new, populated map.  The mappings in the map should match the\n+     *  keys and values returned from {@linke #getSampleKeys()} and {@link\n+     *  #getSampleValues()}.  The default implementation uses makeEmptyMap()\n+     *  and calls {@link #addSampleMappings()} to add all the mappings to the\n+     *  map.\n+     **/\n+    public Map makeFullMap() {\n+        Map m = makeEmptyMap();\n+        addSampleMappings(m);\n+        return m;\n+    }\n \n     public Object makeObject() {\n-        return makeMap();\n-    }\n-\n-        /**\n-     * Try to put the given pair into the given Collection.\n+        return makeEmptyMap();\n+    }\n+\n+    /**\n+     *  Test to ensure the test setup is working properly.  This method checks\n+     *  to ensure that the getSampleKeys and getSampleValues methods are\n+     *  returning results that look appropriate.  That is, they both return a\n+     *  non-null array of equal length.  The keys array must not have any\n+     *  duplicate values, and may only contain a (single) null key if\n+     *  useNullKey() returns true.  The values array must only have a null\n+     *  value if useNullValue() is true and may only have duplicate values if\n+     *  useDuplicateValues() returns true.  \n+     **/\n+    public void testSampleMappings() {\n+      Object[] keys = getSampleKeys();\n+      Object[] values = getSampleValues();\n+      Object[] newValues = getNewSampleValues();\n+\n+      assertTrue(\"failure in test: Must have keys returned from \" +\n+                 \"getSampleKeys.\", keys != null);\n+\n+      assertTrue(\"failure in test: Must have values returned from \" +\n+                 \"getSampleValues.\", values != null);\n+\n+      // verify keys and values have equivalent lengths (in case getSampleX are\n+      // overridden)\n+      assertEquals(\"failure in test: not the same number of sample \" +\n+                   \"keys and values.\",  keys.length, values.length);\n+      \n+      assertEquals(\"failure in test: not the same number of values and new values.\",\n+                   values.length, newValues.length);\n+\n+      // verify there aren't duplicate keys, and check values\n+      for(int i = 0; i < keys.length - 1; i++) {\n+          for(int j = i + 1; j < keys.length; j++) {\n+              assertTrue(\"failure in test: duplicate null keys.\",\n+                         (keys[i] != null || keys[j] != null));\n+              assertTrue(\"failure in test: duplicate non-null key.\",\n+                         (keys[i] == null || keys[j] == null || \n+                          (!keys[i].equals(keys[j]) && \n+                           !keys[j].equals(keys[i]))));\n+          }\n+          assertTrue(\"failure in test: found null key, but useNullKey \" +\n+                     \"is false.\", keys[i] != null || useNullKey());\n+          assertTrue(\"failure in test: found null value, but useNullValue \" +\n+                     \"is false.\", values[i] != null || useNullValue());\n+          assertTrue(\"failure in test: found null new value, but useNullValue \" +\n+                     \"is false.\", newValues[i] != null || useNullValue());\n+          assertTrue(\"failure in test: values should not be the same as new value\",\n+                     values[i] != newValues[i] && \n+                     (values[i] == null || !values[i].equals(newValues[i])));\n+      }\n+    }\n+    \n+    // tests begin here.  Each test adds a little bit of tested functionality.\n+    // Many methods assume previous methods passed.  That is, they do not\n+    // exhaustively recheck things that have already been checked in a previous\n+    // test methods.  \n+\n+    /**\n+     *  Test to ensure that makeEmptyMap and makeFull returns a new non-null\n+     *  map with each invocation.  \n+     **/\n+    public void testMakeMap() {\n+        Map em = makeEmptyMap();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+        \n+        Map em2 = makeEmptyMap();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n+                   \"with each invocation.\", em != em2);\n+\n+        Map fm = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+        \n+        Map fm2 = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        assertTrue(\"failure in test: makeFullMap must return a new map \" +\n+                   \"with each invocation.\", fm != fm2);\n+    }\n+\n+    /**\n+     *  Tests Map.isEmpty()\n+     **/\n+    public void testIsEmpty() {\n+        Map em = makeEmptyMap();\n+        assertEquals(\"Map.isEmpty() should return true with an empty map\", \n+                     true, em.isEmpty());\n+\n+        Map fm = makeFullMap();\n+        assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n+                     false, fm.isEmpty());\n+    }\n+\n+    /**\n+     *  Tests Map.size()\n+     **/\n+    public void testSize() {\n+        Map em = makeEmptyMap();\n+        assertEquals(\"Map.size() should be 0 with an empty map\",\n+                     0, em.size());\n+\n+        Map fm = makeFullMap();\n+        assertEquals(\"Map.size() should equal the number of entries in the map\",\n+                     getSampleKeys().length, fm.size());\n+    }\n+\n+    /**\n+     *  Tests {@link Map#clear()}.  If the map {@link #isAddRemoveModifiable()\n+     *  can add and remove elements}, then {@link Map#size()} and {@link\n+     *  Map#isEmpty()} are used to ensure that map has no elements after a call\n+     *  to clear.  If the map does not support adding and removing elements,\n+     *  this method checks to ensure clear throws an\n+     *  UnsupportedOperationException.  This method checks that the both maps\n+     *  returned by makeEmptyMap and makeFullMap have correct behavior.\n+     **/\n+    public void testClear() {\n+        Map em = makeEmptyMap();\n+        try {\n+            em.clear();\n+            assertTrue(\"Map must throw UnsupportedOperationException if the \" +\n+                       \"map does not support removing elements\", \n+                       isAddRemoveModifiable());\n+            assertEquals(\"size() must return zero after clear.\", \n+                         0, em.size());\n+            assertEquals(\"isEmpty() must return true after clear.\", \n+                         true, em.isEmpty());\n+        } catch (UnsupportedOperationException exception) {\n+            assertTrue(\"Map must not throw UnsupportedOperationException if the \" +\n+                       \"map supports removing elements\", !isAddRemoveModifiable());\n+        }\n+\n+        Map fm = makeFullMap();\n+        try {\n+            fm.clear();\n+            assertTrue(\"Map must throw UnsupportedOperationException if the \" +\n+                       \"map does not support removing elements\", \n+                       isAddRemoveModifiable());\n+            assertEquals(\"size() must return zero after clear.\", \n+                         0, fm.size());\n+            assertEquals(\"isEmpty() must return true after clear.\", \n+                         true, fm.isEmpty());\n+        } catch (UnsupportedOperationException exception) {\n+            assertTrue(\"Map must not throw UnsupportedOperationException if the \" +\n+                       \"map supports removing elements\", !isAddRemoveModifiable());\n+        }\n+    }\n+\n+    /**\n+     *  Tests:\n+     *  <ul>\n+     *  <li> Map.entrySet().isEmpty()\n+     *  <li> Map.entrySet().size()\n+     *  </ul>\n+     **/\n+    public void testEntrySetIsEmpty() {\n+        Map em = makeEmptyMap();\n+        Set es = em.entrySet();\n+        \n+        assertEquals(\"entrySet() must return an empty set when map is empty.\", \n+                     em.isEmpty(), es.isEmpty());\n+        assertEquals(\"entrySet() must return a set with the same size as \" +\n+                     \"the map.\", em.size(), es.size());\n+\n+        Map fm = makeEmptyMap();\n+        Set fs = fm.entrySet();\n+        \n+        assertEquals(\"entrySet() must return a non-empty set when map is not empty.\", \n+                     fm.isEmpty(), fs.isEmpty());\n+        assertEquals(\"entrySet() must return a set with the same size as \" +\n+                     \"the map.\", fm.size(), fs.size());\n+    }\n+\n+    /**\n+     *  Tests Map.containsKey(Object) by verifying it returns false for all\n+     *  sample keys on a map created using makeEmptyMap() and returns true for\n+     *  all sample keys returned on a map created using makeFullMap()\n+     **/\n+    public void testContainsKey() {\n+        Object[] keys = getSampleKeys();\n+\n+        Map em = makeEmptyMap();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must not contain key when map is empty\", \n+                       !em.containsKey(keys[i]));\n+        }\n+\n+        Map fm = makeFullMap();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must contain key for a mapping in the map.\", \n+                       fm.containsKey(keys[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests Map.containsValue(Object) by verifying it returns false for all\n+     *  sample alues on a map created using makeEmptyMap() and returns true for\n+     *  all sample values returned on a map created using makeFullMap.\n+     **/\n+    public void testContainsValue() {\n+        Object[] values = getSampleValues();\n+\n+        Map em = makeEmptyMap();\n+\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Empty map must not contain value\", \n+                       !em.containsValue(values[i]));\n+        }\n+\n+        Map fm = makeFullMap();\n+\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Map must contain value for a mapping in the map.\", \n+                       fm.containsValue(values[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Test to ensure that Map.entrySet() returns a non-null set.\n+     **/\n+    public void testEntrySet() {\n+        Map em = makeEmptyMap();\n+        Set es = em.entrySet();\n+        \n+        assertTrue(\"entrySet() must return a non-null set.\", es != null);\n+\n+        Map fm = makeEmptyMap();\n+        Set fs = fm.entrySet();\n+        \n+        assertTrue(\"entrySet() must return a non-null set.\", fs != null);\n+    }\n+    \n+    /**\n+     *  Tests:\n+     *  <ul>\n+     *  <li> Map.entrySet().contains(Object)\n+     *  <li> Map.entrySet().containsAll(Collection)\n+     *  </ul>\n      *\n-     * Fails any Throwable except UnsupportedOperationException,\n-     * ClassCastException, or IllegalArgumentException\n-     * or NullPointerException is thrown.\n-     */\n-    protected Object tryToPut(Map map, Object key, Object val) {\n+     *  Note:  This test relies on a working commons.collections.DefaultMapEntry class.\n+     **/\n+    public void testEntrySetContainsProperMappings() {\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Map.Entry[] entries = new Map.Entry[keys.length];\n+        HashSet mappings = new HashSet();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            entries[i] = new DefaultMapEntry(keys[i], values[i]);\n+            mappings.add(entries[i]);\n+        }\n+\n+        // test an empty map\n+        Map em = makeEmptyMap();\n+        Set es = em.entrySet();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            assertEquals(\"entrySet().contains(Object) must return false when map \" +\n+                         \"is empty\", false, es.contains(entries[i]));\n+        }\n+\n+        assertEquals(\"entrySet().containsAll(Collection) must return false when the \" +\n+                     \"map is empty\", false, es.containsAll(mappings));\n+\n+\n+        Map fm = makeFullMap();\n+        Set fs = fm.entrySet();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            assertEquals(\"entrySet().contains(Object) must return true when map \" +\n+                         \"contains the mapping\", true, fs.contains(entries[i]));\n+        }\n+        assertEquals(\"entrySet().containsAll(Collection) must return true when the \" +\n+                     \"map contains the mapping\", true, fs.containsAll(mappings));\n+\n         try {\n-            return map.put(key,val);\n-        } catch(UnsupportedOperationException e) {\n-            return null;\n-        } catch(ClassCastException e) {\n-            return null;\n-        } catch(IllegalArgumentException e) {\n-            return null;\n-        } catch(NullPointerException e) {\n-            return null;\n-        } catch(Throwable t) {\n-            t.printStackTrace();\n-            fail(\"Map.put should only throw UnsupportedOperationException, ClassCastException, IllegalArgumentException or NullPointerException. Found \" + t.toString());\n-            return null; // never get here, since fail throws exception\n-        }\n-    }\n-\n-    /*\n-\n-    public void testMapContainsKey() {\n-        // XXX finish me\n-    }\n-\n-    public void testMapContainsValue() {\n-        // XXX finish me\n-    }\n-\n-    public void testMapEntrySet() {\n-        // XXX finish me\n-    }\n+            es.containsAll((Collection)null);\n+            fail(\"entrySet().containsAll(null) should \" +\n+                 \"throw a NullPointerException\");\n+        } catch (NullPointerException exception) {\n+            // expected\n+        }\n+        try {\n+            fs.containsAll((Collection)null);\n+            fail(\"entrySet().containsAll(null) should \" +\n+                 \"throw a NullPointerException\");\n+        } catch (NullPointerException exception) {\n+            // expected\n+        }\n+    }\n+\n+    // TODO: test entrySet().clear()\n+    // TODO: test entrySet().add() throws OperationNotSupported\n+    // TODO: test entrySet().addAll() throws OperationNotSupported\n+    // TODO: test entrySet().contains(Object)\n+    // TODO: test entrySet().containsAll(Collection)\n+    // TODO: test entrySet().equals(Object)\n+    // TODO: test entrySet().hashCode()\n+    // TODO: test entrySet().toArray()\n+    // TODO: test entrySet().toArray(Object[] a)\n+    // TODO: test entrySet().remove(Object)\n+    // TODO: test entrySet().removeAll(Collection)\n+    // TODO: test entrySet().retainAll(Collection)\n+\n+    /**\n+     *  Tests:\n+     *  <ul>\n+     *  <li> Map.entrySet().iterator()\n+     *  <li> Map.entrySet().iterator().hasNext()\n+     *  <li> Map.entrySet().iterator().next()\n+     *  </ul>\n+     **/\n+    public void testEntrySetIterator() {\n+        Map em = makeEmptyMap();\n+        Set es = em.entrySet();\n+        Iterator eiter = es.iterator();\n+\n+        assertEquals(\"entrySet().iterator().hasNext() must return false \" +\n+                     \"when then the map is empty.\", \n+                     false, eiter.hasNext());\n+\n+        // note: we make a new map to test for this because some impls in the\n+        // past have required a call to hasMoreElements before a call to next\n+        // for it to work properly.  By using a new map, we make sure this test\n+        // will catch those broken impls.\n+        em = makeEmptyMap();\n+        es = em.entrySet();\n+        eiter = es.iterator();\n+        \n+        try {\n+            eiter.next();\n+            fail(\"entrySet().iterator().next() must throw a NoSuchElementException \" +\n+                 \"when the map is empty\");\n+        } catch (NoSuchElementException exception) {\n+            // expected\n+        }\n+\n+\n+        Map fm = makeFullMap();\n+\n+        Set fs = fm.entrySet();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        boolean[] found = new boolean[keys.length];\n+\n+        Iterator iter = fs.iterator();\n+\n+        assertTrue(\"entrySet().iterator() must return a non-null \" +\n+                   \"iterator.\", iter != null);\n+\n+        while(iter.hasNext()) {\n+            Object obj = iter.next();\n+            assertTrue(\"Null is not allowed to be returned from the \" +\n+                       \"entrySet().iterator()'s next().\", obj != null);\n+            assertTrue(\"Objects returned from entrySet().iterator() must be \" +\n+                       \"instances of Map.Entry.\", obj instanceof Map.Entry);\n+                \n+            Map.Entry entry = (Map.Entry)obj;\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+\n+            assertTrue(\"the key for an entry returned from the entry \" +\n+                       \"set's iterator can only be null if useNullKey \" +\n+                       \"is true.\",\n+                       key != null || (key == null && useNullKey()));\n+            \n+            assertTrue(\"the value for an entry returned from the entry \" +\n+                       \"set's iterator can only be null if useNullValue \" +\n+                       \"is true.\",\n+                       value != null || (value == null && useNullValue()));\n+\n+            for(int i = 0; i < keys.length; i++) {\n+                if((key == null && keys[i] == null) ||\n+                   (key != null && key.equals(keys[i]))) {\n+                    assertTrue(\"entrySet().iterator() must not return \" +\n+                               \"multiple entries with the same key.\", \n+                               !found[i]);\n+                        \n+                    found[i] = true;\n+\n+                    assertTrue\n+                        (\"value of entry returned from iterator \" +\n+                         \"must be the value for the added mapping.\",\n+                         (value == null && values[i] == null) ||\n+                         (value != null && value.equals(values[i])));\n+                }\n+            }\n+        }\n+        for(int i = 0; i < found.length; i++) {\n+            assertTrue(\"must find all added elements through entrySet's \" +\n+                       \"iterator().\", found[i]);\n+        }\n+    }\n+  \n+    /**\n+     *  Tests Map.entrySet().iterator().remove()\n+     **/\n+    public void testEntrySetIteratorRemove() {\n+        Map m = makeFullMap();\n+        Set s = m.entrySet();\n+        Iterator iter = s.iterator();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Entry set iterator must not allow a call to remove \" +\n+                 \"before any calls to next\");\n+        } catch (IllegalStateException exception) {\n+            // expected exception provided add/remove modifiable\n+            assertTrue(\"iterator should throw UnsupportedOperationException \" +\n+                       \"if remove is not allowed from the entrySet().iterator()\",\n+                       isAddRemoveModifiable());\n+        } catch (UnsupportedOperationException exception) {\n+            assertTrue(\"iterator should not throw UnsupportedOperationException \" +\n+                       \"if the map supports adding and removing elements\",\n+                       !isAddRemoveModifiable());\n+        }\n+\n+        while(iter.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iter.next();\n+            \n+            assertTrue(\"Entry key from entry set iterator must exist in map\",\n+                       m.containsKey(entry.getKey()));\n+            try {\n+                iter.remove();\n+                // note: we do not check that the mapping was actually removed\n+                // from the map because some classes do not have their\n+                // entrySet().iterator() backed by the map.  That test occurs\n+                // below in testEntrySetIteratorRemoveCausesMapModification\n+            } catch (UnsupportedOperationException exception) {\n+                assertTrue(\"iterator should not throw UnsupportedOperationException \" +\n+                           \"if the map supports adding and removing elements\",\n+                           !isAddRemoveModifiable());\n+            }\n+\n+            try {\n+                iter.remove();\n+                fail(\"Entry set iterator must not allow two calls to \" +\n+                     \"remove without a call to next.\");\n+            } catch (IllegalStateException exception) {\n+                // expected exception provided add/remove modifiable\n+                assertTrue(\"iterator should throw UnsupportedOperationException \" +\n+                           \"if remove is not allowed from the entrySet().iterator()\",\n+                           isAddRemoveModifiable());\n+            } catch (UnsupportedOperationException exception) {\n+                assertTrue(\"iterator should not throw UnsupportedOperationException \" +\n+                           \"if the map supports adding and removing elements\",\n+                           !isAddRemoveModifiable());\n+            }\n+        }\n+    }\n+\n+    /**\n+     *  Tests whether the map's entrySet() is backed by the map by making sure\n+     *  a put in the map is reflected in the entrySet.  This test does nothing\n+     *  if add/remove modifications are not supported.\n+     **/\n+    public void testEntrySetChangesWithMapPut() {\n+        if(!isAddRemoveModifiable()) return;\n+\n+        Map m = makeEmptyMap();\n+\n+        // test insert reflected in entry set\n+        Set s = m.entrySet();\n+        addSampleMappings(m);\n+        assertEquals(\"entrySet() must only be empty if map is empty.\",\n+                     m.isEmpty(), s.isEmpty());\n+        assertEquals(\"entrySet() must adjust size when map changes.\",\n+                     m.size(), s.size());\n+        // TODO: test set and map reflect the same contents\n+    }\n+\n+    /**\n+     *  Tests whether the map's entrySet() is backed by the map by making sure\n+     *  a remove from the map is reflected in the entrySet.  This test does nothing\n+     *  if add/remove modifications are not supported.\n+     **/\n+    public void testEntrySetChangesWithMapRemove() {\n+        if(!isAddRemoveModifiable()) return;\n+\n+        Map m = makeFullMap();\n+        Set s = m.entrySet();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            m.remove(keys[i]);\n+            assertEquals(\"entrySet() must only be empty if map is empty.\",\n+                         m.isEmpty(), s.isEmpty());\n+            assertEquals(\"entrySet() must adjust size when map changes.\",\n+                         m.size(), s.size());\n+            //TODO: test set and map reflect the same contents\n+        }\n+    }\n+\n+    // TODO: test entrySet() changes after Map.remove\n+    // TODO: test entrySet() changes after Map.clear\n+    // TODO: test entrySet() changes after Map.putAll\n+\n+    /**\n+     *  Tests whether the map's entrySet() is backed by the map by making sure\n+     *  a remove from the entrySet's iterator is reflected in the map. This\n+     *  test does nothing if add/remove modifications are not supported.\n+     **/\n+    public void testEntrySetIteratorRemoveCausesMapModification() {\n+        if(!isAddRemoveModifiable()) return;\n+        \n+        Map m = makeFullMap();\n+        Set s = m.entrySet();\n+        Iterator iter = s.iterator();\n+        \n+        while(iter.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iter.next();\n+            \n+            try {\n+                iter.remove();\n+                assertTrue(\"Entry key from entry set iterator must \" +\n+                           \"no longer exist in map\",\n+                           !m.containsKey(entry.getKey()));\n+            } catch (UnsupportedOperationException exception) {\n+                // isAddRemoveModifiable is true -- we've checked that above\n+                fail(\"iterator should not throw UnsupportedOperationException \" +\n+                     \"if the map supports adding and removing elements\");\n+            }\n+        }\n+    }\n+\n+    // TODO: test map changes after entrySet().remove\n+    // TODO: test map changes after entrySet().removeAll\n+    // TODO: test map changes after entrySet().retainAll\n \n     public void testMapEquals() {\n         // XXX finish me\n         // XXX finish me\n     }\n \n-    public void testMapIsEmpty() {\n-        // XXX finish me\n-    }\n-\n     public void testMapKeySet() {\n         // XXX finish me\n     }\n     \n-    */\n-    \n     //-------TEST AGAINST OPTIONAL OPERATIONS, ENABLE IN TEST SUBCLASSES\n \n     public void testMapSupportsNullValues() {\n             return;\n         }\n \n-        Map map = makeMap();\n+        Map map = makeEmptyMap();\n         map.put(new Integer(1),\"foo\");\n         \n         assertTrue(\"no null values in Map\",map.containsValue(null) == false);\n             return;\n         }\n \n-        Map map = makeMap();\n+        Map map = makeEmptyMap();\n         map.put(new Integer(4),\"foo\");\n         map.put(new Integer(4),\"bar\");\n         map.put(new Integer(4),\"foo\");\n             return;\n         }\n \n-        Map map = makeMap();\n+        Map map = makeEmptyMap();\n         map.put(new Integer(1),\"foo\");\n         map.put(new Integer(2),\"foo\");\n         map.put(new Integer(3),\"foo\");\n             return;\n         }\n \n-        Map map = makeMap();\n+        Map map = makeEmptyMap();\n         map.put(\"1\",\"1\");\n         map.put(\"2\",\"2\");\n         map.put(\"3\",\"3\");\n             return;\n         }\n \n-        Map map = makeMap();\n+        Map map = makeEmptyMap();\n         map.put(\"1\",\"1\");\n         map.put(\"2\",\"2\");\n         map.put(\"3\",\"3\");\n         // XXX finish me\n     }\n \n-    public void testMapSize() {\n-        // XXX finish me\n-    }\n-\n     public void testMapValues() {\n         // XXX finish me\n     }\n-\n-    */\n \n     /**\n      * Marker interface, indicating that a TestMap subclass\n--- a/src/test/org/apache/commons/collections/TestMultiHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestMultiHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.1 2001/09/18 10:41:39 jstrachan Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/09/18 10:41:39 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.2 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeMap() {\n+    public Map makeEmptyMap() {\n         return new MultiHashMap();\n     }\n     \n         return len;\n     }\n     \n+\n+    public void testEntrySetIterator() {\n+    }\n+    public void testEntrySetContainsProperMappings() {\n+    }\n+    public void testEntrySetIteratorHasProperMappings() {\n+        // override and ignore test -- it will fail when verifying the iterator for\n+        // the set contains the right value -- we're not returning the value, we're\n+        // returning a collection.\n+        // TODO: re-implement this test to ensure the values of the iterator match\n+        // the proper collection rather than the value the superclass is checking\n+        // for.\n+        return;\n+    }\n }\n--- a/src/test/org/apache/commons/collections/TestObject.java\n+++ b/src/test/org/apache/commons/collections/TestObject.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestObject.java,v 1.2 2002/02/20 21:50:16 morgand Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/02/20 21:50:16 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestObject.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n  * Tests base {@link java.util.Object} methods and contracts.\n  * <p>\n  * To use, simply extend this class, and implement\n- * the {@link #makeObject} method.\n+ * the {@link #makeObject()} method.\n  * <p>\n  * If your {@link Object} fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n  * test case (method) your {@link Object} fails.\n  *\n  * @author Rodney Waldhoff\n- * @version $Id: TestObject.java,v 1.2 2002/02/20 21:50:16 morgand Exp $\n+ * @version $Id: TestObject.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n  */\n public abstract class TestObject extends TestCase {\n     public TestObject(String testName) {\n         Object obj2 = makeObject();\n         if(obj1.equals(obj2)) {\n             assertEquals(\"[2] When two objects are equal, their hashCodes should be also.\",obj1.hashCode(),obj2.hashCode());\n+            assertTrue(\"When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true\", obj2.equals(obj1));\n         }\n     }\n \n--- a/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n         super.setUp();\n         // use makeMap and cast the result to a SeqHashMap\n         // so that subclasses of SeqHashMap can share these tests\n-        labRat = (SequencedHashMap) makeMap();\n+        labRat = (SequencedHashMap) makeEmptyMap();\n     }\n \n-    public Map makeMap() {\n+    public Map makeEmptyMap() {\n         return new SequencedHashMap();\n     }\n \n     protected Object[] getValues() {\n         return new Object[] { \"bar\", \"frob\", new Object() };\n     }\n-\n+ \n     public void testSequenceMap() throws Throwable {\n         Object[] keys = getKeys();\n         int expectedSize = keys.length;\n     protected void tearDown() {\n         labRat = null;\n     }\n-}\n+}\n--- a/src/test/org/apache/commons/collections/TestTreeMap.java\n+++ b/src/test/org/apache/commons/collections/TestTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestTreeMap.java,v 1.2 2001/07/14 23:33:27 craigmcc Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/07/14 23:33:27 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestTreeMap.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/02/22 02:18:50 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestTreeMap.java,v 1.2 2001/07/14 23:33:27 craigmcc Exp $\n+ * @version $Id: TestTreeMap.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n  */\n public class TestTreeMap extends TestMap\n {\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeMap() {\n+    public Map makeEmptyMap() {\n         TreeMap tm = new TreeMap();\n         return (tm);\n+    }\n+\n+    public boolean useNullKey() {\n+      return false;\n     }\n \n     protected TreeMap map = null;\n \n     public void setUp()\n     {\n-        map = (TreeMap) makeMap();\n+        map = (TreeMap) makeEmptyMap();\n     }\n \n     public void testNewMap()", "timestamp": 1014344330, "metainfo": ""}