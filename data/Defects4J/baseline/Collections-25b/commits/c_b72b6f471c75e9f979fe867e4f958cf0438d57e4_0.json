{"sha": "b72b6f471c75e9f979fe867e4f958cf0438d57e4", "log": "Improve capacity handling and checks for large maps   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n  * need for unusual subclasses is here.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.18 $ $Date: 2004/05/26 21:56:05 $\n+ * @version $Revision: 1.19 $ $Date: 2004/06/04 23:27:30 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n         if (mapSize == 0) {\n             return;\n         }\n-        ensureCapacity(calculateNewCapacity(size + mapSize));\n+        int newSize = (int) ((size + mapSize) / loadFactor + 1);\n+        ensureCapacity(calculateNewCapacity(newSize));\n         for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n             Map.Entry entry = (Map.Entry) it.next();\n             put(entry.getKey(), entry.getValue());\n      */\n     protected void checkCapacity() {\n         if (size >= threshold) {\n-            ensureCapacity(data.length * 2);\n+            int newCapacity = data.length * 2;\n+            if (newCapacity <= MAXIMUM_CAPACITY) {\n+                ensureCapacity(newCapacity);\n+            }\n         }\n     }\n     \n     /**\n      * Changes the size of the data structure to the capacity proposed.\n      * \n-     * @param newCapacity  the new capacity of the array\n+     * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)\n      */\n     protected void ensureCapacity(int newCapacity) {\n         int oldCapacity = data.length;\n         if (newCapacity <= oldCapacity) {\n             return;\n         }\n-        HashEntry oldEntries[] = data;\n-        HashEntry newEntries[] = new HashEntry[newCapacity];\n-\n-        modCount++;\n-        for (int i = oldCapacity - 1; i >= 0; i--) {\n-            HashEntry entry = oldEntries[i];\n-            if (entry != null) {\n-                oldEntries[i] = null;  // gc\n-                do {\n-                    HashEntry next = entry.next;\n-                    int index = hashIndex(entry.hashCode, newCapacity);  \n-                    entry.next = newEntries[index];\n-                    newEntries[index] = entry;\n-                    entry = next;\n-                } while (entry != null);\n-            }\n-        }\n-        threshold = calculateThreshold(newCapacity, loadFactor);\n-        data = newEntries;\n+        if (size == 0) {\n+            threshold = calculateThreshold(newCapacity, loadFactor);\n+            data = new HashEntry[newCapacity];\n+        } else {\n+            HashEntry oldEntries[] = data;\n+            HashEntry newEntries[] = new HashEntry[newCapacity];\n+\n+            modCount++;\n+            for (int i = oldCapacity - 1; i >= 0; i--) {\n+                HashEntry entry = oldEntries[i];\n+                if (entry != null) {\n+                    oldEntries[i] = null;  // gc\n+                    do {\n+                        HashEntry next = entry.next;\n+                        int index = hashIndex(entry.hashCode, newCapacity);  \n+                        entry.next = newEntries[index];\n+                        newEntries[index] = entry;\n+                        entry = next;\n+                    } while (entry != null);\n+                }\n+            }\n+            threshold = calculateThreshold(newCapacity, loadFactor);\n+            data = newEntries;\n+        }\n     }\n \n     /**\n             while (newCapacity < proposedCapacity) {\n                 newCapacity <<= 1;  // multiply by two\n             }\n-            if (proposedCapacity > MAXIMUM_CAPACITY) {\n+            if (newCapacity > MAXIMUM_CAPACITY) {\n                 newCapacity = MAXIMUM_CAPACITY;\n             }\n         }", "timestamp": 1086391650, "metainfo": ""}