{"sha": "c8de9e8066bd95b5d3ce7f90364fcfdf571e69fa", "log": "Applied fixes from Julien Buret to improve MultiMap including  - values() backed by real map - clone works properly - ArrayLists can be added to a MultiMap Javadoc class   ", "commit": "\n--- a/src/java/org/apache/commons/collections/MultiHashMap.java\n+++ b/src/java/org/apache/commons/collections/MultiHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MultiHashMap.java,v 1.7 2002/11/01 19:41:00 rwaldhoff Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/11/01 19:41:00 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MultiHashMap.java,v 1.8 2002/11/24 19:36:48 scolebourne Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/11/24 19:36:48 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.util.AbstractCollection;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n /** \n  * <code>MultiHashMap</code> is the default implementation of the \n  * {@link org.apache.commons.collections.MultiMap MultiMap} interface.\n+ * <p>\n  * A <code>MultiMap</code> is a Map with slightly different semantics.\n- * Instead of returning an Object, it returns a Collection.\n- * So for example, you can put( key, new Integer(1) ); \n- * and then a Object get( key ); will return you a Collection \n- * instead of an Integer.\n+ * Putting a value into the map will add the value to a Collection at that\n+ * key. Getting a value will always return a Collection, holding all the\n+ * values put to that key. This implementation uses an ArrayList as the \n+ * collection.\n+ * <p>\n+ * For example:\n+ * <pre>\n+ * MultiMap mhm = new MultiHashMap();\n+ * mhm.put(key, \"A\");\n+ * mhm.put(key, \"B\");\n+ * mhm.put(key, \"C\");\n+ * Collection coll = mhm.get(key);</pre>\n+ * <p>\n+ * <code>coll</code> will be a list containing \"A\", \"B\", \"C\".\n  *\n  * @since 2.0\n  * @author Christopher Berry\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author Steve Downey\n  * @author Stephen Colebourne\n+ * @author <a href=\"mailto:jburet@yahoo.com\">Julien Buret</a>\n  */\n-public class MultiHashMap extends HashMap implements MultiMap\n-{\n-    //----------------- Data\n+public class MultiHashMap extends HashMap implements MultiMap {\n+    // deprecated name concept\n     private static int sCount = 0;\n     private String mName = null;\n     \n-    public MultiHashMap()\n-    {\n+    //backed values collection\n+    private transient Collection values = null;\n+    \n+    // compatibility with commons-collection releases 2.0/2.1\n+    private static final long serialVersionUID = 1943563828307035349L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public MultiHashMap() {\n         super();\n         setName();\n     }\n-    \n-    public MultiHashMap( int initialCapacity )\n-    {\n-        super( initialCapacity );\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param initialCapacity  the initial map capacity\n+     */\n+    public MultiHashMap(int initialCapacity) {\n+        super(initialCapacity);\n         setName();\n     }\n-    \n-    public MultiHashMap(int initialCapacity, float loadFactor )\n-    {\n-        super( initialCapacity, loadFactor);\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param initialCapacity  the initial map capacity\n+     * @param loadFactor  the amount 0.0-1.0 at which to resize the map\n+     */\n+    public MultiHashMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n         setName();\n     }\n-    \n-    public MultiHashMap( Map mapToCopy )\n-    {\n-        super( mapToCopy );\n-    }\n-    \n-    private void setName()\n-    {\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param mapToCopy  a Map to copy\n+     */\n+    public MultiHashMap(Map mapToCopy) {\n+        super(mapToCopy);\n+    }\n+\n+    /**\n+     * Read the object during deserialization.\n+     */\n+    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n+        // This method is needed because the 1.2/1.3 Java deserialisation called\n+        // put and thus messed up that method\n+        \n+        // default read object\n+        s.defaultReadObject();\n+\n+        // problem only with jvm <1.4\n+        String version = \"1.2\";\n+        try {\n+            version = System.getProperty(\"java.version\");\n+        } catch (SecurityException ex) {\n+            // ignore and treat as 1.2/1.3\n+        }\n+\n+        if (version.startsWith(\"1.2\") || version.startsWith(\"1.3\")) {\n+            for (Iterator iterator = entrySet().iterator(); iterator.hasNext();) {\n+                Map.Entry entry = (Map.Entry) iterator.next();\n+                // put has created a extra collection level, remove it\n+                super.put(entry.getKey(), ((Collection) entry.getValue()).iterator().next());\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Create a name for the map.\n+     */    \n+    private void setName() {\n         sCount++;\n         mName = \"MultiMap-\" + sCount;\n     }\n     \n-    public String getName()\n-    { return mName; }\n-    \n-    public Object put( Object key, Object value )\n-    {\n-        // NOTE:: put might be called during deserialization !!!!!!\n-        //        so we must provide a hook to handle this case\n-        //        This means that we cannot make MultiMaps of ArrayLists !!!\n-        \n-        if ( value instanceof ArrayList ) {\n-            return ( super.put( key, value ) );\n-        }\n-        \n-        ArrayList keyList = (ArrayList)(super.get( key ));\n-        if ( keyList == null ) {\n-            keyList = new ArrayList(10);\n-            \n-            super.put( key, keyList );\n-        }\n-        \n-        boolean results = keyList.add( value );\n-        \n-        return ( results ? value : null );\n-    }\n-    \n-    public boolean containsValue( Object value )\n-    {\n+    /**\n+     * Gets the name of the map.\n+     * \n+     * @deprecated no replacement. There is no good reason for a MultiMap to have a name\n+     * @return the name\n+     */    \n+    public String getName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * Put a key and value into the map.\n+     * <p>\n+     * The value is added to a collection mapped to the key instead of \n+     * replacing the previous value.\n+     * \n+     * @param key  the key to set\n+     * @param value  the value to set the key to\n+     * @return the value added if the add is successful, <code>null</code> otherwise\n+     */    \n+    public Object put(Object key, Object value) {\n+        // NOTE:: put is called during deserialization in JDK < 1.4 !!!!!!\n+        //        so we must have a readObject()\n+        Collection coll = (Collection) super.get(key);\n+        if (coll == null) {\n+            coll = createCollection(null);\n+            super.put(key, coll);\n+        }\n+        boolean results = coll.add(value);\n+\n+        return (results ? value : null);\n+    }\n+    \n+    /**\n+     * Does the map contain a specific value.\n+     * <p>\n+     * This searches the collection mapped to each key, and thus could be slow.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the list contains the value\n+     */\n+    public boolean containsValue(Object value) {\n         Set pairs = super.entrySet();\n-        \n-        if ( pairs == null )\n+\n+        if (pairs == null) {\n             return false;\n-        \n+        }\n         Iterator pairsIterator = pairs.iterator();\n-        while ( pairsIterator.hasNext() ) {\n-            Map.Entry keyValuePair = (Map.Entry)(pairsIterator.next());\n-            ArrayList list = (ArrayList)(keyValuePair.getValue());\n-            if( list.contains( value ) )\n+        while (pairsIterator.hasNext()) {\n+            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+            Collection coll = (Collection) keyValuePair.getValue();\n+            if (coll.contains(value)) {\n                 return true;\n+            }\n         }\n         return false;\n     }\n-    \n-    public Object remove( Object key, Object item )\n-    {\n-        ArrayList valuesForKey = (ArrayList) super.get( key );\n-        \n-        if ( valuesForKey == null )\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * \n+     * @param key  the key to remove from\n+     * @param value  the value to remove\n+     * @return the value removed (which was passed in)\n+     */\n+    public Object remove(Object key, Object item) {\n+        Collection valuesForKey = (Collection) super.get(key);\n+        if (valuesForKey == null) {\n             return null;\n-        \n-        valuesForKey.remove( item );\n+        }\n+        valuesForKey.remove(item);\n         return item;\n     }\n-    \n-    public void clear()\n-    {\n+\n+    /**\n+     * Clear the map.\n+     * <p>\n+     * This clears each collection in the map, and so may be slow.\n+     */\n+    public void clear() {\n+        // For gc, clear each list in the map\n         Set pairs = super.entrySet();\n         Iterator pairsIterator = pairs.iterator();\n-        while ( pairsIterator.hasNext() ) {\n-            Map.Entry keyValuePair = (Map.Entry)(pairsIterator.next());\n-            ArrayList list = (ArrayList)(keyValuePair.getValue());\n-            list.clear();\n+        while (pairsIterator.hasNext()) {\n+            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+            Collection coll = (Collection) keyValuePair.getValue();\n+            coll.clear();\n         }\n         super.clear();\n     }\n-    \n-    public void putAll( Map mapToPut )\n-    {\n-        super.putAll( mapToPut );\n-    }\n-    \n+\n     /** \n-     * Note: Currently the returned {@link Collection} is <i>not</i>\n-     * backed by this map.\n-     * @see Map#values\n-     * @see http://issues.apache.org/bugzilla/show_bug.cgi?id=9573\n-     */\n-    public Collection values()\n-    {\n-        ArrayList returnList = new ArrayList( super.size() );\n-        \n-        Set pairs = super.entrySet();\n-        Iterator pairsIterator = pairs.iterator();\n-        while ( pairsIterator.hasNext() ) {\n-            Map.Entry keyValuePair = (Map.Entry)(pairsIterator.next());\n-            ArrayList list = (ArrayList)(keyValuePair.getValue());\n-            \n-            Object[] values = list.toArray();\n-            for ( int ii=0; ii < values.length; ii++ ) {\n-                returnList.add( values[ii] );\n-            }\n-        }\n-        return returnList;\n-    }\n-    \n-    // FIXME:: do we need to implement this??\n-    // public boolean equals( Object obj ) {}\n-    \n-    // --------------- From Cloneable\n-    public Object clone()\n-    {\n-        MultiHashMap obj = (MultiHashMap)(super.clone());\n+     * Gets a view over all the values in the map.\n+     * <p>\n+     * The values view includes all the entries in the collections at each map key.\n+     * \n+     * @return the collection view of all the values in the map\n+     */\n+    public Collection values() {\n+        Collection vs = values;\n+        return (vs != null ? vs : (values = new Values()));\n+    }\n+\n+    /**\n+     * Inner class to view the elements.\n+     */\n+    private class Values extends AbstractCollection {\n+\n+        public Iterator iterator() {\n+            return new ValueIterator();\n+        }\n+\n+        public int size() {\n+            int compt = 0;\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                compt++;\n+            }\n+            return compt;\n+        }\n+\n+        public void clear() {\n+            MultiHashMap.this.clear();\n+        }\n+\n+    }\n+\n+    /**\n+     * Inner iterator to view the elements.\n+     */\n+    private class ValueIterator implements Iterator {\n+        private Iterator backedIterator;\n+        private Iterator tempIterator;\n+\n+        private ValueIterator() {\n+            backedIterator = MultiHashMap.super.values().iterator();\n+        }\n+\n+        private boolean searchNextIterator() {\n+            while (tempIterator == null || tempIterator.hasNext() == false) {\n+                if (backedIterator.hasNext() == false) {\n+                    return false;\n+                }\n+                tempIterator = ((Collection) backedIterator.next()).iterator();\n+            }\n+            return true;\n+        }\n+\n+        public boolean hasNext() {\n+            return searchNextIterator();\n+        }\n+\n+        public Object next() {\n+            if (searchNextIterator() == false) {\n+                throw new NoSuchElementException();\n+            }\n+            return tempIterator.next();\n+        }\n+\n+        public void remove() {\n+            if (tempIterator == null) {\n+                throw new IllegalStateException();\n+            }\n+            tempIterator.remove();\n+        }\n+\n+    }\n+\n+    /**\n+     * Clone the map.\n+     * <p>\n+     * The clone will shallow clone the collections as well as the map.\n+     * \n+     * @return the cloned map\n+     */\n+    public Object clone() {\n+        MultiHashMap obj = (MultiHashMap) super.clone();\n         obj.mName = mName;\n+\n+        // clone each Collection container\n+        for (Iterator it = entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            Collection coll = (Collection) entry.getValue();\n+            Collection newColl = createCollection(coll);\n+            entry.setValue(newColl);\n+        }\n         return obj;\n     }\n     \n+    /** \n+     * Creates a new instance of the map value Collection container.\n+     * <p>\n+     * This method can be overridden to use your own collection type.\n+     *\n+     * @param coll  the collection to copy, may be null\n+     * @return the new collection\n+     */\n+    protected Collection createCollection(Collection coll) {\n+        if (coll == null) {\n+            return new ArrayList();\n+        } else {\n+            return new ArrayList(coll);\n+        }\n+    }\n+\n }", "timestamp": 1038166608, "metainfo": ""}