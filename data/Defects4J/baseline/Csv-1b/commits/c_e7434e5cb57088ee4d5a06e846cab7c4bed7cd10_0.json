{"sha": "e7434e5cb57088ee4d5a06e846cab7c4bed7cd10", "log": "Changed CSVPrinter to print to any Appendable and optimized the internals to avoid string copies  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n package org.apache.commons.csv;\n \n+import java.io.Flushable;\n import java.io.IOException;\n-import java.io.Writer;\n \n /**\n  * Print values as a comma separated list.\n public class CSVPrinter {\n \n     /** The place that the values get written. */\n-    private final Writer out;\n+    private final Appendable out;\n     private final CSVFormat format;\n \n     /** True if we just began a new line. */\n     private boolean newLine = true;\n-\n-    /** Temporary buffer */\n-    private char[] buf = new char[0];  \n \n     /**\n      * Create a printer that will print values to the given stream following the CSVFormat.\n      * @param out    stream to which to print.\n      * @param format describes the CSV variation.\n      */\n-    public CSVPrinter(Writer out, CSVFormat format) {\n+    public CSVPrinter(Appendable out, CSVFormat format) {\n         this.out = out;\n         this.format = format == null ? CSVFormat.DEFAULT : format;\n     }\n      * Output a blank line\n      */\n     public void println() throws IOException {\n-        out.write(format.getLineSeparator());\n+        out.append(format.getLineSeparator());\n         newLine = true;\n     }\n \n      * @throws IOException\n      */\n     public void flush() throws IOException {\n-        out.flush();\n-    }\n-\n+        if (out instanceof Flushable) {\n+            ((Flushable) out).flush();\n+        }\n+    }\n \n     /**\n      * Print a single line of comma separated values.\n         if (!newLine) {\n             println();\n         }\n-        out.write(format.getCommentStart());\n-        out.write(' ');\n+        out.append(format.getCommentStart());\n+        out.append(' ');\n         for (int i = 0; i < comment.length(); i++) {\n             char c = comment.charAt(i);\n             switch (c) {\n                     // break intentionally excluded.\n                 case '\\n':\n                     println();\n-                    out.write(format.getCommentStart());\n-                    out.write(' ');\n+                    out.append(format.getCommentStart());\n+                    out.append(' ');\n                     break;\n                 default:\n-                    out.write(c);\n+                    out.append(c);\n                     break;\n             }\n         }\n     }\n \n \n-    private void print(char[] value, int offset, int len) throws IOException {        \n+    private void print(CharSequence value, int offset, int len) throws IOException {        \n         if (format.isEncapsulating()) {\n             printAndEncapsulate(value, offset, len);\n         } else if (format.isEscaping()) {\n             printAndEscape(value, offset, len);\n         } else {\n             printSep();\n-            out.write(value, offset, len);\n+            out.append(value, offset, offset + len);\n         }\n     }\n \n         if (newLine) {\n             newLine = false;\n         } else {\n-            out.write(format.getDelimiter());\n-        }\n-    }\n-\n-    void printAndEscape(char[] value, int offset, int len) throws IOException {\n+            out.append(format.getDelimiter());\n+        }\n+    }\n+\n+    void printAndEscape(CharSequence value, int offset, int len) throws IOException {\n         int start = offset;\n         int pos = offset;\n         int end = offset + len;\n         char escape = format.getEscape();\n \n         while (pos < end) {\n-            char c = value[pos];\n+            char c = value.charAt(pos);\n             if (c == '\\r' || c == '\\n' || c == delim || c == escape) {\n                 // write out segment up until this char\n-                int l = pos - start;\n-                if (l > 0) {\n-                    out.write(value, start, l);\n+                if (pos > start) {\n+                    out.append(value, start, pos);\n                 }\n                 if (c == '\\n') {\n                     c = 'n';\n                     c = 'r';\n                 }\n \n-                out.write(escape);\n-                out.write(c);\n+                out.append(escape);\n+                out.append(c);\n \n                 start = pos + 1; // start on the current char after this one\n             }\n         }\n \n         // write last segment\n-        int l = pos - start;\n-        if (l > 0) {\n-            out.write(value, start, l);\n-        }\n-    }\n-\n-    void printAndEncapsulate(char[] value, int offset, int len) throws IOException {\n+        if (pos > start) {\n+            out.append(value, start, pos);\n+        }\n+    }\n+\n+    void printAndEncapsulate(CharSequence value, int offset, int len) throws IOException {\n         boolean first = newLine;  // is this the first value on this line?\n         boolean quote = false;\n         int start = offset;\n                 quote = true;\n             }\n         } else {\n-            char c = value[pos];\n+            char c = value.charAt(pos);\n \n             // Hmmm, where did this rule come from?\n             if (first\n                 quote = true;\n             } else {\n                 while (pos < end) {\n-                    c = value[pos];\n+                    c = value.charAt(pos);\n                     if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n                         quote = true;\n                         break;\n \n                 if (!quote) {\n                     pos = end - 1;\n-                    c = value[pos];\n+                    c = value.charAt(pos);\n                     // if (c == ' ' || c == '\\f' || c == '\\t') {\n                     // Some other chars at the end caused the parser to fail, so for now\n                     // encapsulate if we end in anything less than ' '\n \n         if (!quote) {\n             // no encapsulation needed - write out the original value\n-            out.write(value, offset, len);\n+            out.append(value, start, end);\n             return;\n         }\n \n         // we hit something that needed encapsulation\n-        out.write(encapsulator);\n+        out.append(encapsulator);\n \n         // Pick up where we left off: pos should be positioned on the first character that caused\n         // the need for encapsulation.\n         while (pos < end) {\n-            char c = value[pos];\n+            char c = value.charAt(pos);\n             if (c == encapsulator) {\n                 // write out the chunk up until this point\n \n                 // add 1 to the length to write out the encapsulator also\n-                out.write(value, start, pos - start + 1);\n+                out.append(value, start, pos + 1);\n                 // put the next starting position on the encapsulator so we will\n                 // write it out again with the next string (effectively doubling it)\n                 start = pos;\n         }\n \n         // write the last segment\n-        out.write(value, start, pos - start);\n-        out.write(encapsulator);\n+        out.append(value, start, pos);\n+        out.append(encapsulator);\n     }\n \n     /**\n         if (!checkForEscape) {\n             // write directly from string\n             printSep();\n-            out.write(value);\n-            return;\n-        }\n-\n-        if (buf.length < value.length()) {\n-            buf = new char[value.length()];\n-        }\n-\n-        value.getChars(0, value.length(), buf, 0);\n-        print(buf, 0, value.length());\n+            out.append(value);\n+        } else {\n+            print(value, 0, value.length());\n+        }\n     }\n \n     /**", "timestamp": 1330994914, "metainfo": ""}