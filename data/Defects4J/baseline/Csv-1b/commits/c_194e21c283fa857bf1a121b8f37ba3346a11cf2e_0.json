{"sha": "194e21c283fa857bf1a121b8f37ba3346a11cf2e", "log": "More Javadoc for CSVFormat  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n         this.emptyLinesIgnored = emptyLinesIgnored;\n     }\n \n+    /**\n+     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n+     * \n+     * @return the delimiter character\n+     */\n     public char getDelimiter() {\n         return delimiter;\n     }\n \n+    /**\n+     * Returns a copy of this format using the specified delimiter character.\n+     * \n+     * @param delimiter the delimiter character\n+     * @return A copy of this format using the specified delimiter character\n+     */\n     public CSVFormat withDelimiter(char delimiter) {\n         CSVFormat format = clone();\n         format.delimiter = delimiter;\n         return format;\n     }\n \n+    /**\n+     * Returns the character used to encapsulate values containing special characters.\n+     * \n+     * @return the encapsulator character\n+     */\n     public char getEncapsulator() {\n         return encapsulator;\n     }\n \n+    /**\n+     * Returns a copy of this format using the specified encapsulator character.\n+     * \n+     * @param encapsulator the encapsulator character\n+     * @return A copy of this format using the specified encapsulator character\n+     */\n     public CSVFormat withEncapsulator(char encapsulator) {\n         CSVFormat format = clone();\n         format.encapsulator = encapsulator;\n         return this.encapsulator != DISABLED;\n     }\n \n+    /**\n+     * Returns the character marking the start of a line comment.\n+     * \n+     * @return the comment start marker.\n+     */\n     public char getCommentStart() {\n         return commentStart;\n     }\n \n+    /**\n+     * Returns a copy of this format using the specified character as the comment start marker.\n+     * \n+     * @param commentStart the comment start marker\n+     * @return A copy of this format using the specified character as the comment start marker\n+     */\n     public CSVFormat withCommentStart(char commentStart) {\n         CSVFormat format = clone();\n         format.commentStart = commentStart;\n         return format;\n     }\n \n+    /**\n+     * Tells if comments are supported by this format.\n+     * \n+     * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n+     */\n     public boolean isCommentingDisabled() {\n         return this.commentStart == DISABLED;\n     }\n \n+    /**\n+     * Returns the escape character.\n+     * \n+     * @return the escape character\n+     */\n     public char getEscape() {\n         return escape;\n     }\n \n+    /**\n+     * Returns a copy of this format using the specified escape character.\n+     * \n+     * @param escape the escape character\n+     * @return A copy of this format using the specified escape character\n+     */\n     public CSVFormat withEscape(char escape) {\n         CSVFormat format = clone();\n         format.escape = escape;\n         return this.escape != DISABLED;\n     }\n \n+    /**\n+     * Tells if the spaces characters at the beginning of the values are ignored when parsing a file.\n+     * \n+     * @return <tt>true</tt> if leading spaces are removed, <tt>false</tt> if they are preserved.\n+     */\n     public boolean isLeadingSpacesIgnored() {\n         return leadingSpacesIgnored;\n     }\n \n+    /**\n+     * Returns a copy of this format with the specified left trimming behavior.\n+     *\n+     * @param leadingSpacesIgnored the left trimming behavior, <tt>true</tt> to remove the leading spaces,\n+     *                             <tt>false</tt> to leave the spaces as is.\n+     * @return A copy of this format with the specified left trimming behavior.\n+     */\n     public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n         CSVFormat format = clone();\n         format.leadingSpacesIgnored = leadingSpacesIgnored;\n         return format;\n     }\n \n+    /**\n+     * Tells if the spaces characters at the end of the values are ignored when parsing a file.\n+     * \n+     * @return <tt>true</tt> if trailing spaces are removed, <tt>false</tt> if they are preserved.\n+     */\n     public boolean isTrailingSpacesIgnored() {\n         return trailingSpacesIgnored;\n     }\n \n+    /**\n+     * Returns a copy of this format with the specified right trimming behavior.\n+     *\n+     * @param trailingSpacesIgnored the right trimming behavior, <tt>true</tt> to remove the trailing spaces,\n+     *                              <tt>false</tt> to leave the spaces as is.\n+     * @return A copy of this format with the specified right trimming behavior.\n+     */\n     public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n         CSVFormat format = clone();\n         format.trailingSpacesIgnored = trailingSpacesIgnored;\n         return format;\n     }\n \n+    /**\n+     * Returns a copy of this format with the specified trimming behavior.\n+     *\n+     * @param surroundingSpacesIgnored the trimming behavior, <tt>true</tt> to remove the surrounding spaces,\n+     *                                 <tt>false</tt> to leave the spaces as is.\n+     * @return A copy of this format with the specified trimming behavior.\n+     */\n     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n         CSVFormat format = clone();\n         format.leadingSpacesIgnored = surroundingSpacesIgnored;\n         format.trailingSpacesIgnored = surroundingSpacesIgnored;\n         return format;\n     }\n-    \n+\n+    /**\n+     * Tells if unicode escape sequences (i.e <span>\\</span>u1234) are turned into their corresponding character.\n+     * \n+     * @return <tt>true</tt> if unicode escape sequences are interpreted, <tt>false</tt> if they are left as is.\n+     */\n     public boolean isUnicodeEscapesInterpreted() {\n         return unicodeEscapesInterpreted;\n     }\n \n+    /**\n+     * Returns a copy of this format with the specified unicode escaping behavior.\n+     *\n+     * @param unicodeEscapesInterpreted the escaping behavior, <tt>true</tt> to interpret unicode escape sequences,\n+     *                                  <tt>false</tt> to leave the escape sequences as is.\n+     * @return A copy of this format with the specified unicode escaping behavior.\n+     */\n     public CSVFormat withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {\n         CSVFormat format = clone();\n         format.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n         return format;\n     }\n \n+    /**\n+     * Tells if the empty lines between the records are ignored.\n+     * \n+     * @return <tt>true</tt> if empty lines between records are ignore, <tt>false</tt> if they are turned into empty records.\n+     */\n     public boolean isEmptyLinesIgnored() {\n         return emptyLinesIgnored;\n     }\n \n+    /**\n+     * Returns a copy of this format with the specified empty line skipping behavior.\n+     *\n+     * @param emptyLinesIgnored the empty line skipping behavior, <tt>true</tt> to ignore the empty lines\n+     *                          between the records, <tt>false</tt> to translate empty lines to empty records.\n+     * @return A copy of this format  with the specified empty line skipping behavior.\n+     */\n     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n         CSVFormat format = clone();\n         format.emptyLinesIgnored = emptyLinesIgnored;\n         return format;\n     }\n \n+    /**\n+     * Returns the line separator delimiting the records.\n+     * \n+     * @return the line separator\n+     */\n     public String getLineSeparator() {\n         return lineSeparator;\n     }\n \n+    /**\n+     * Returns a copy of this format using the specified line separator.\n+     * \n+     * @param lineSeparator the line separator\n+     * @return A copy of this format using the specified line separator\n+     */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n         CSVFormat format = clone();\n         format.lineSeparator = lineSeparator;\n     /**\n      * Parses the specified content.\n      * \n-     * @param in\n+     * @param in the input stream\n      */\n     public Iterable<String[]> parse(Reader in) {\n         return new CSVParser(in, this);", "timestamp": 1331159691, "metainfo": ""}