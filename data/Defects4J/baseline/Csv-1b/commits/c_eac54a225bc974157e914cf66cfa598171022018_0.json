{"sha": "eac54a225bc974157e914cf66cfa598171022018", "log": "Extracted the strategy concept into its own class  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n   /** Token with content when end of a line is reached. */\n   protected static final int TT_EORECORD = 2;\n    \n-  // the csv definition\n-  private char delimiter;\n-  private char encapsulator;\n-  private char commentStart;\n-  private boolean ignoreLeadingWhitespaces;\n-  private boolean interpretUnicodeEscapes;\n-  private boolean ignoreEmptyLines;\n-  \n   // the input stream\n   private ExtendedBufferedReader in;\n+\n+  private CSVStrategy strategy;\n   \n   /**\n    * Token is an internal token representation.\n    * @param s CSV String to be parsed.\n    * @return parsed String matrix (which is never null)\n    * @throws IOException in case of error\n-   * @see #setCSVStrategy()\n+   * @see #setStrategy()\n    */\n   public static String[][] parse(String s) throws IOException {\n     if (s == null) {\n    * @param s CSV String to be parsed.\n    * @return parsed String vector (which is never null)\n    * @throws IOException in case of error\n-   * @see #setCSVStrategy()\n+   * @see #setStrategy()\n    */\n   public static String[] parseLine(String s) throws IOException {\n     if (s == null) {\n    * Default strategy for the parser follows the default CSV Strategy.\n    * \n    * @param input an InputStream containing \"csv-formatted\" stream\n-   * @see #setCSVStrategy()\n+   * @see #setStrategy()\n    */\n   public CSVParser(InputStream input) {\n     this(new InputStreamReader(input));\n    * Default strategy for the parser follows the default CSV Strategy.\n    * \n    * @param input a Reader based on \"csv-formatted\" input\n-   * @see #setCSVStrategy()\n+   * @see #setStrategy()\n    */\n   public CSVParser(Reader input) {\n     // note: must match default-CSV-strategy !!\n    * Customized value delimiter parser.\n    * \n    * The parser follows the default CSV strategy as defined in \n-   * {@link #setCSVStrategy()} except for the delimiter setting.\n+   * {@link #setStrategy()} except for the delimiter setting.\n    * \n    * @param input a Reader based on \"csv-formatted\" input\n    * @param delimiter a Char used for value separation\n    * @param encapsulator a Char used as value encapsulation marker\n    * @param commentStart a Char used for comment identification\n    */\n-  public CSVParser(\n-    Reader input,\n-    char delimiter,\n-    char encapsulator,\n-    char commentStart) {\n+  public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {\n     this.in = new ExtendedBufferedReader(input);\n-    this.setDelimiter(delimiter);\n-    this.setEncapsulator(encapsulator);\n-    this.setCommentStart(commentStart);\n-    this.setIgnoreLeadingWhitespaces(true);\n-    this.setUnicodeEscapeInterpretation(false);\n-    this.setIgnoreEmptyLines(true);\n+    this.strategy = new CSVStrategy(delimiter, encapsulator, commentStart);\n   }\n   \n   // ======================================================\n     c = in.readAgain();\n      \n     //  empty line detection: eol AND (last char was EOL or beginning)\n-    while (ignoreEmptyLines && eol \n+    while (strategy.getIgnoreEmptyLines() && eol \n       && (lastChar == '\\n' \n       || lastChar == ExtendedBufferedReader.UNDEFINED) \n       && !isEndOfFile(lastChar)) {\n     }\n \n     // did we reached eof during the last iteration already ? TT_EOF\n-    if (isEndOfFile(lastChar) || (lastChar != delimiter && isEndOfFile(c))) {\n+    if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {\n       tkn.type = TT_EOF;\n       return tkn;\n     } \n         eol = isEndOfLine(c);\n       }\n       // ok, start of token reached: comment, encapsulated, or token\n-      if (c == commentStart) {\n+      if (c == strategy.getCommentStart()) {\n         // ignore everything till end of line and continue (incr linecount)\n         in.readLine();\n         tkn = nextToken();\n-      } else if (c == delimiter) {\n+      } else if (c == strategy.getDelimiter()) {\n         // empty token return TT_TOKEN(\"\")\n         tkn.type = TT_TOKEN;\n         tkn.isReady = true;\n         tkn.content.append(\"\");\n         tkn.type = TT_EORECORD;\n         tkn.isReady = true;\n-      } else if (c == encapsulator) {\n+      } else if (c == strategy.getEncapsulator()) {\n         // consume encapsulated token\n         encapsulatedTokenLexer(tkn, c);\n       } else if (isEndOfFile(c)) {\n       } else {\n         // next token must be a simple token\n         // add removed blanks when not ignoring whitespace chars...\n-        if (!this.ignoreLeadingWhitespaces) {\n+        if (!strategy.getIgnoreLeadingWhitespaces()) {\n           tkn.content.append(wsBuf.toString());\n         }\n         simpleTokenLexer(tkn, c);\n         // end of file\n         tkn.type = TT_EOF;\n         tkn.isReady = true;\n-      } else if (c == delimiter) {\n+      } else if (c == strategy.getDelimiter()) {\n         // end of token\n         tkn.type = TT_TOKEN;\n         tkn.isReady = true;\n-      } else if (c == '\\\\' && interpretUnicodeEscapes && in.lookAhead() == 'u') {\n+      } else if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n         // interpret unicode escaped chars (like \\u0070 -> p)\n         tkn.content.append((char) unicodeEscapeLexer(c));\n       } else if (isWhitespace(c)) {\n     // assert c == delimiter;\n     c = in.read();\n     while (!tkn.isReady) {\n-      if (c == encapsulator || c == '\\\\') {\n+      if (c == strategy.getEncapsulator() || c == '\\\\') {\n         // check lookahead\n-        if (in.lookAhead() == encapsulator) {\n+        if (in.lookAhead() == strategy.getEncapsulator()) {\n           // double or escaped encapsulator -> add single encapsulator to token\n           c = in.read();\n           tkn.content.append((char) c);\n           c = in.read();\n           tkn.content.append((char) c);\n         } else if (\n-          interpretUnicodeEscapes \n+          strategy.getUnicodeEscapeInterpretation()\n           && c == '\\\\' \n           && in.lookAhead() == 'u') {\n           // interpret unicode escaped chars (like \\u0070 -> p)\n           // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n           while (!tkn.isReady) {\n             int n = in.lookAhead();\n-            if (n == delimiter) {\n+            if (n == strategy.getDelimiter()) {\n               tkn.type = TT_TOKEN;\n               tkn.isReady = true;\n             } else if (isEndOfFile(n)) {\n   }\n   \n   // ======================================================\n-  //  strategy utilities\n-  // ======================================================\n-  \n-  /**\n-   * Sets the \"Default CSV\" settings.\n-   * \n-   * The default csv settings are relatively restrictive but implement\n-   * something like the \"least-common-basis\" of CSV:\n-   * <ul>\n-   * <li> Delimiter of values is comma ',' (as the C in \"CSV\") </li>\n-   * <li> Complex values encapsulated by '\"' </li>\n-   * <li> Comments are not supported </li>\n-   * <li> Leading whitespaces are ignored </li>\n-   * <li> Unicode escapes are not interpreted </li>\n-   * <li> empty lines are skiped </li>\n-   * </ul>\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setCSVStrategy() {\n-    setStrategy(',', '\"', (char) 0, true, false, true);\n-    return this;\n-  }\n-  \n-  /**\n-   * Sets the \"Excel CSV\" settings. There are companies out there which\n-   * interpret \"C\" as an abbreviation for \"Semicolon\". For these companies the\n-   * following settings might be appropriate:\n-   * <ul>\n-   * <li> Delimiter of values is semicolon ';' </li>\n-   * <li> Complex values encapsulated by '\"' </li>\n-   * <li> Comments are not supported </li>\n-   * <li> Leading whitespaces are not ignored </li>\n-   * <li> Unicode escapes are not interpreted </li>\n-   * <li> empty lines are not skiped </li>\n-   * </ul>\n+  //  strategies\n+  // ======================================================\n+  \n+  /**\n+   * Sets the specified CSV Strategy\n    *\n    * @return current instance of CSVParser to allow chained method calls\n    */\n-  public CSVParser setExcelStrategy() {\n-    setStrategy(';', '\"', (char) 0, false, false, false);\n+  public CSVParser setStrategy(CSVStrategy strategy) {\n+    this.strategy = strategy;\n     return this;\n   }\n   \n   /**\n-   * Customized CSV strategy setter.\n-   * \n-   * @param delimiter a Char used for value separation\n-   * @param encapsulator a Char used as value encapsulation marker\n-   * @param commentStart a Char used for comment identification\n-   * @param ignoreLeadingWhitespace TRUE when leading whitespaces should be\n-   *                                ignored\n-   * @param interpretUnicodeEscapes TRUE when unicode escapes should be \n-   *                                interpreted\n-   * @param ignoreEmptyLines TRUE when the parser should skip emtpy lines\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setStrategy(\n-    char delimiter, \n-    char encapsulator, \n-    char commentStart, \n-    boolean ignoreLeadingWhitespace, \n-    boolean interpretUnicodeEscapes,\n-    boolean ignoreEmptyLines) {\n-    this.setDelimiter(delimiter);\n-    this.setEncapsulator(encapsulator);\n-    this.setCommentStart(commentStart);\n-    this.setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);\n-    this.setUnicodeEscapeInterpretation(interpretUnicodeEscapes);\n-    this.setIgnoreEmptyLines(ignoreEmptyLines);\n-    return this;\n-  }\n-  \n-  /**\n-   * Set the desired delimiter.\n-   *\n-   * @param c a Char used for value separation\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setDelimiter(char c) {\n-    this.delimiter = c;\n-    return this;\n-  }\n-  \n-  /**\n-   * Gets the delimiter.\n-   *  \n-   * @return the delimiter character\n-   */\n-  public char getDelimiter() {\n-    return this.delimiter;\n-  }\n-  \n-  /**\n-   * Set the desired encapsulator.\n-   * \n-   * @param c a Char used as value encapsulation marker\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setEncapsulator(char c) {\n-    this.encapsulator = c;\n-    return this;\n-  }\n-  \n-  /**\n-   * Gets the encapsulator character.\n-   *  \n-   * @return the encapsulator marker\n-   */\n-  public char getEncapsulator() {\n-    return this.encapsulator;\n-  }\n-  \n-  /**\n-   * Set the desired comment start character.\n-   * \n-   * @param c a Char used for comment identification\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setCommentStart(char c) {\n-    this.commentStart = c;\n-    return this;\n-  }\n-  \n-  /**\n-   * Gets the comment identifier.\n-   * \n-   * @return the comment identifier character\n-   */\n-  public char getCommentStart() {\n-    return this.commentStart;\n-  }\n-  \n-  /**\n-   * Enables unicode escape interpretation.\n-   * \n-   * @param b TRUE when interpretation should be enabled\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setUnicodeEscapeInterpretation(boolean b) {\n-    this.interpretUnicodeEscapes = b;\n-    return this;\n-  }\n-  \n-  /**\n-   * Shows wether unicode interpretation is enabled.\n-   * \n-   * @return TRUE when unicode interpretation is enabled\n-   */\n-  public boolean getUnicodeEscapeInterpretation() {\n-    return this.interpretUnicodeEscapes;\n-  }\n-  \n-  /**\n-   * Sets the ignore-leading-whitespaces behaviour.\n-   * \n-   * Should the lexer ignore leading whitespaces when parsing non \n-   * encapsulated tokens.\n-   * \n-   * @param b TRUE when leading whitespaces should be ignored\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setIgnoreLeadingWhitespaces(boolean b) {\n-    this.ignoreLeadingWhitespaces = b;\n-    return this;\n-  }\n-  \n-  /**\n-   * Shows whether unicode interpretation is enabled.\n-   * \n-   * @return TRUE when unicode interpretation is enabled\n-   */\n-  public boolean getIgnoreLeadingWhitespaces() {\n-    return this.ignoreLeadingWhitespaces;\n-  }\n-  \n-  /**\n-   * Sets the ignore-empty-line behaviour.\n-   * \n-   * When set to 'true' empty lines in the input will be ignored.\n-   * \n-   * @param b TRUE when empty lines in the input should be ignored\n-   * @return current instance of CSVParser to allow chained method calls\n-   */\n-  public CSVParser setIgnoreEmptyLines(boolean b) {\n-    this.ignoreEmptyLines = b;  \n-    return this;\n-  }\n-  \n-  /**\n-   * Shows whether empty lines in the input are ignored.\n-   * \n-   * @return TRUE when empty lines in the input are ignored\n-   */\n-  public boolean getIgnoreEmptyLines() {\n-    return this.ignoreEmptyLines;\n+   * Obtain the specified CSV Strategy\n+   * \n+   * @return strategy currently being used\n+   */\n+  public CSVStrategy getStrategy() {\n+    return this.strategy;\n   }\n   \n   // ======================================================\n--- /dev/null\n+++ b/src/java/org/apache/commons/csv/CSVStrategy.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+/**\n+ * CSVStrategy\n+ * \n+ * Represents the strategy for a CSV.\n+ */\n+public class CSVStrategy {\n+\n+    private char delimiter;\n+    private char encapsulator;\n+    private char commentStart;\n+    private boolean ignoreLeadingWhitespaces;\n+    private boolean interpretUnicodeEscapes;\n+    private boolean ignoreEmptyLines;\n+\n+    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', (char) 0, true,  false, true);\n+    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(';', '\"', (char) 0, false, false, false);\n+\n+\n+    public CSVStrategy(char delimiter, char encapsulator, char commentStart) {\n+        this(delimiter, encapsulator, commentStart, true, false, true);\n+    }\n+  \n+    /**\n+     * Customized CSV strategy setter.\n+     * \n+     * @param delimiter a Char used for value separation\n+     * @param encapsulator a Char used as value encapsulation marker\n+     * @param commentStart a Char used for comment identification\n+     * @param ignoreLeadingWhitespace TRUE when leading whitespaces should be\n+     *                                ignored\n+     * @param interpretUnicodeEscapes TRUE when unicode escapes should be \n+     *                                interpreted\n+     * @param ignoreEmptyLines TRUE when the parser should skip emtpy lines\n+     * @return current instance of CSVParser to allow chained method calls\n+     */\n+    public CSVStrategy(\n+        char delimiter, \n+        char encapsulator, \n+        char commentStart, \n+        boolean ignoreLeadingWhitespace, \n+        boolean interpretUnicodeEscapes,\n+        boolean ignoreEmptyLines) \n+    {\n+        setDelimiter(delimiter);\n+        setEncapsulator(encapsulator);\n+        setCommentStart(commentStart);\n+        setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);\n+        setUnicodeEscapeInterpretation(interpretUnicodeEscapes);\n+        setIgnoreEmptyLines(ignoreEmptyLines);\n+    }\n+\n+    public void setDelimiter(char delimiter) { this.delimiter = delimiter; }\n+    public char getDelimiter() { return this.delimiter; }\n+\n+    public void setEncapsulator(char encapsulator) { this.encapsulator = encapsulator; }\n+    public char getEncapsulator() { return this.encapsulator; }\n+\n+    public void setCommentStart(char commentStart) { this.commentStart = commentStart; }\n+    public char getCommentStart() { return this.commentStart; }\n+\n+    public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) { this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces; }\n+    public boolean getIgnoreLeadingWhitespaces() { return this.ignoreLeadingWhitespaces; }\n+\n+    public void setUnicodeEscapeInterpretation(boolean interpretUnicodeEscapes) { this.interpretUnicodeEscapes = interpretUnicodeEscapes; }\n+    public boolean getUnicodeEscapeInterpretation() { return this.interpretUnicodeEscapes; }\n+\n+    public void setIgnoreEmptyLines(boolean ignoreEmptyLines) { this.ignoreEmptyLines = ignoreEmptyLines; }\n+    public boolean getIgnoreEmptyLines() { return this.ignoreEmptyLines; }\n+\n+}\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n \n \n   // ======================================================\n-  //   getters / setters\n-  // ======================================================\n-  public void testGetSetCommentStart() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    parser.setCommentStart('#');\n-    assertEquals(parser.getCommentStart(), '#');\n-    parser.setCommentStart('!');\n-    assertEquals(parser.getCommentStart(), '!');\n-  }\n-\n-  public void testGetSetEncapsulator() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    parser.setEncapsulator('\"');\n-    assertEquals(parser.getEncapsulator(), '\"');\n-    parser.setEncapsulator('\\'');\n-    assertEquals(parser.getEncapsulator(), '\\'');\n-  }\n-\n-  public void testGetSetDelimiter() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    parser.setDelimiter(';');\n-    assertEquals(parser.getDelimiter(), ';');\n-    parser.setDelimiter(',');\n-    assertEquals(parser.getDelimiter(), ',');\n-    parser.setDelimiter('\\t');\n-    assertEquals(parser.getDelimiter(), '\\t');\n-  }\n-\n-  public void testSetCSVStrategy() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    // default settings\n-    assertEquals(parser.getDelimiter(), ',');\n-    assertEquals(parser.getEncapsulator(), '\"');\n-    assertEquals(parser.getCommentStart(), '\\0');\n-    assertEquals(true,  parser.getIgnoreLeadingWhitespaces());\n-    assertEquals(false, parser.getUnicodeEscapeInterpretation());\n-    assertEquals(true,  parser.getIgnoreEmptyLines());\n-    // explicit csv settings\n-    parser.setCSVStrategy();\n-    assertEquals(parser.getDelimiter(), ',');\n-    assertEquals(parser.getEncapsulator(), '\"');\n-    assertEquals(parser.getCommentStart(), '\\0');\n-    assertEquals(true,  parser.getIgnoreLeadingWhitespaces());\n-    assertEquals(false, parser.getUnicodeEscapeInterpretation());\n-    assertEquals(true,  parser.getIgnoreEmptyLines());\n-  }\n-  \n-  public void testSetExcelStrategy() {\n-    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n-    // explicit Excel settings\n-    parser.setExcelStrategy();\n-    assertEquals(parser.getDelimiter(), ';');\n-    assertEquals(parser.getEncapsulator(), '\"');\n-    assertEquals(parser.getCommentStart(), '\\0');\n-    assertEquals(false,  parser.getIgnoreLeadingWhitespaces());\n-    assertEquals(false, parser.getUnicodeEscapeInterpretation());\n-    assertEquals(false, parser.getIgnoreEmptyLines());\n-  }\n-  \n-  \n-  // ======================================================\n   //   lexer tests\n   // ======================================================\n   \n   public void testNextToken1() throws IOException {\n     String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setCSVStrategy();\n+    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";abc;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";def;\", parser.testNextToken());\n      */\n     String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setIgnoreEmptyLines(false);\n-    parser.setCSVStrategy();\n-    parser.setCommentStart('#');\n+    parser.getStrategy().setIgnoreEmptyLines(false);\n+    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n+    parser.getStrategy().setCommentStart('#');\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";2;\", parser.testNextToken());\n      */\n     String code = \"a,\\\\,,b\\n\\\\,,\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setCSVStrategy();\n-    parser.setCommentStart('#');\n+    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n+    parser.getStrategy().setCommentStart('#');\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     // an unquoted single backslash is not an escape char\n      String code = \n       \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n      TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-     parser.setCSVStrategy();\n+     parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n      System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n      assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n      assertEquals(CSVParser.TT_TOKEN + \";foo;\", parser.testNextToken());\n       + \",\\\"\\\\,\\\"\" \n       + \",\\\"\\\"\\\"\\\"\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setCSVStrategy();\n+    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n      */\n     String code = \"a;'b and \\\\' more\\n'\\n!comment;;;;\\n;;\";\n     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    parser.setDelimiter(';');\n-    parser.setEncapsulator('\\'');\n-    parser.setCommentStart('!');\n+    parser.setStrategy( new CSVStrategy(';', '\\'', '!') );\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n     assertEquals(\n       {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n     };\n     CSVParser parser = new CSVParser(new StringReader(code));\n-    parser.setExcelStrategy();\n+    parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String[][] tmp = parser.getAllValues();\n     assertEquals(res.length, tmp.length);\n       {\"world\", \"\"}\n     };\n     CSVParser parser = new CSVParser(new StringReader(code));\n-    parser.setExcelStrategy();\n+    parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n     String[][] tmp = parser.getAllValues();\n     assertEquals(res.length, tmp.length);\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n       CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setExcelStrategy();\n+      parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n       CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setCSVStrategy();\n+      parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n       CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setExcelStrategy();\n+      parser.setStrategy(CSVStrategy.EXCEL_STRATEGY);\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n     for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n       code = codes[codeIndex];\n       CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.setCSVStrategy();\n+      parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       String[][] tmp = parser.getAllValues();\n       assertEquals(res.length, tmp.length);\n       String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n       CSVParser parser = new CSVParser(new StringReader(code));\n       System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n-      parser.setUnicodeEscapeInterpretation(true);\n+      parser.getStrategy().setUnicodeEscapeInterpretation(true);\n       String[] data = parser.getLine();\n       assertEquals(2, data.length);\n       assertEquals(\"abc\", data[0]);\n--- /dev/null\n+++ b/src/test/org/apache/commons/csv/CSVStrategyTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * CSVStrategyTest\n+ *\n+ * The test are organized in three different sections:\n+ * The 'setter/getter' section, the lexer section and finally the strategy \n+ * section. In case a test fails, you should follow a top-down approach for \n+ * fixing a potential bug (its likely that the strategy itself fails if the lexer\n+ * has problems...).\n+ */\n+public class CSVStrategyTest extends TestCase {\n+  \n+  /**\n+   * Constructor for JUnit.\n+   * @param name Name to be used in JUnit Test Environment\n+   */\n+  public CSVStrategyTest(String name) {\n+    super(name);\n+  }\n+\n+  /**\n+   * Returns a Test suite for JUnit.\n+   * @return Test suite for JUnit\n+   */\n+  public static Test suite() {\n+    return new TestSuite(CSVStrategyTest.class);\n+  }\n+\n+\n+  // ======================================================\n+  //   getters / setters\n+  // ======================================================\n+  public void testGetSetCommentStart() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    CSVStrategy strategy = parser.getStrategy();\n+    strategy.setCommentStart('#');\n+    assertEquals(strategy.getCommentStart(), '#');\n+    strategy.setCommentStart('!');\n+    assertEquals(strategy.getCommentStart(), '!');\n+  }\n+\n+  public void testGetSetEncapsulator() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    CSVStrategy strategy = parser.getStrategy();\n+    strategy.setEncapsulator('\"');\n+    assertEquals(strategy.getEncapsulator(), '\"');\n+    strategy.setEncapsulator('\\'');\n+    assertEquals(strategy.getEncapsulator(), '\\'');\n+  }\n+\n+  public void testGetSetDelimiter() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    CSVStrategy strategy = parser.getStrategy();\n+    strategy.setDelimiter(';');\n+    assertEquals(strategy.getDelimiter(), ';');\n+    strategy.setDelimiter(',');\n+    assertEquals(strategy.getDelimiter(), ',');\n+    strategy.setDelimiter('\\t');\n+    assertEquals(strategy.getDelimiter(), '\\t');\n+  }\n+\n+  public void testSetCSVStrategy() {\n+    CSVParser parser = new CSVParser(new StringReader(\"hello world\"));\n+    CSVStrategy strategy = parser.getStrategy();\n+    // default settings\n+    assertEquals(strategy.getDelimiter(), ',');\n+    assertEquals(strategy.getEncapsulator(), '\"');\n+    assertEquals(strategy.getCommentStart(), '\\0');\n+    assertEquals(true,  strategy.getIgnoreLeadingWhitespaces());\n+    assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n+    assertEquals(true,  strategy.getIgnoreEmptyLines());\n+    // explicit csv settings\n+    parser.setStrategy(CSVStrategy.DEFAULT_STRATEGY);\n+    assertEquals(strategy.getDelimiter(), ',');\n+    assertEquals(strategy.getEncapsulator(), '\"');\n+    assertEquals(strategy.getCommentStart(), '\\0');\n+    assertEquals(true,  strategy.getIgnoreLeadingWhitespaces());\n+    assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n+    assertEquals(true,  strategy.getIgnoreEmptyLines());\n+  }\n+  \n+  public void testSetExcelStrategy() {\n+    CSVStrategy strategy = CSVStrategy.EXCEL_STRATEGY;\n+    assertEquals(strategy.getDelimiter(), ';');\n+    assertEquals(strategy.getEncapsulator(), '\"');\n+    assertEquals(strategy.getCommentStart(), '\\0');\n+    assertEquals(false,  strategy.getIgnoreLeadingWhitespaces());\n+    assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n+    assertEquals(false, strategy.getIgnoreEmptyLines());\n+  }\n+  \n+} ", "timestamp": 1146810274, "metainfo": ""}