{"sha": "be94f5547d6b8f15ee48117afe46ae302c361464", "log": "Added support to optionally keep track of errors while tokenising and tree-building.", "commit": "\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n     void error(HtmlTreeBuilderState state) {\n         if (trackErrors)\n-            errors.add(new ParseError(\"Unexpected token\", state, currentToken, reader.pos()));\n+            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n     }\n \n     Element insert(Token.StartTag startTag) {\n--- a/src/main/java/org/jsoup/parser/ParseError.java\n+++ b/src/main/java/org/jsoup/parser/ParseError.java\n /**\n  * A Parse Error records an error in the input HTML that occurs in either the tokenisation or the tree building phase.\n  */\n-// todo: currently not ready for public consumption. revisit api, and exposure methods\n class ParseError {\n+    private int pos;\n     private String errorMsg;\n-    private int pos;\n-    private char c;\n-    private TokeniserState tokeniserState;\n-    private HtmlTreeBuilderState treeBuilderState;\n-    private Token token;\n \n-    ParseError(String errorMsg, char c, TokeniserState tokeniserState, int pos) {\n+    ParseError(int pos, String errorMsg) {\n+        this.pos = pos;\n         this.errorMsg = errorMsg;\n-        this.c = c;\n-        this.tokeniserState = tokeniserState;\n+    }\n+\n+    ParseError(int pos, String errorFormat, Object... args) {\n+        this.errorMsg = String.format(errorFormat, args);\n         this.pos = pos;\n     }\n \n-    ParseError(String errorMsg, TokeniserState tokeniserState, int pos) {\n-        this.errorMsg = errorMsg;\n-        this.tokeniserState = tokeniserState;\n-        this.pos = pos;\n-    }\n-\n-    ParseError(String errorMsg, int pos) {\n-        this.errorMsg = errorMsg;\n-        this.pos = pos;\n-    }\n-\n-    ParseError(String errorMsg, HtmlTreeBuilderState treeBuilderState, Token token, int pos) {\n-        this.errorMsg = errorMsg;\n-        this.treeBuilderState = treeBuilderState;\n-        this.token = token;\n-        this.pos = pos;\n-    }\n-\n-    String getErrorMsg() {\n+    public String getErrorMessage() {\n         return errorMsg;\n     }\n \n-    int getPos() {\n+    public int getPosition() {\n         return pos;\n     }\n+\n+    @Override\n+    public String toString() {\n+        return pos + \": \" + errorMsg;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     /**\n      * Update the TreeBuilder used when parsing content.\n      * @param treeBuilder current TreeBuilder\n+     * @return this, for chaining\n      */\n-    public void setTreeBuilder(TreeBuilder treeBuilder) {\n+    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n         this.treeBuilder = treeBuilder;\n+        return this;\n     }\n \n     /**\n     /**\n      * Enable or disable parse error tracking for the next parse/\n      * @param trackErrors on/off\n+     * @return this, for chaining\n      */\n-    public void setTrackErrors(boolean trackErrors) {\n+    public Parser setTrackErrors(boolean trackErrors) {\n         this.trackErrors = trackErrors;\n+        return this;\n     }\n \n     /**\n      * Retrieve the parse errors, if any, from the last parse.\n-     * @return list of parse errors, if error tracking was enabled and errors occurred.\n+     * @return list of parse errors, if error tracking was enabled and errors occurred. If not enabled, returns null.\n      */\n     public List<ParseError> getErrors() {\n         return errors;\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n     TokenType type;\n \n     private Token() {\n+    }\n+    \n+    String tokenType() {\n+        return this.getClass().getSimpleName();\n     }\n \n     static class Doctype extends Token {\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n \n     private CharacterReader reader; // html input\n-    private boolean trackErrors = true;\n-    private List<ParseError> errors = new ArrayList<ParseError>(); // errors found while tokenising\n+    private boolean trackErrors;\n+    private List<ParseError> errors; // errors found while tokenising\n \n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n     private boolean selfClosingFlagAcknowledged = true;\n \n-    Tokeniser(CharacterReader reader) {\n+    Tokeniser(CharacterReader reader, List<ParseError> errors) {\n         this.reader = reader;\n+        this.errors = errors;\n+        this.trackErrors = errors != null;\n     }\n \n     Token read() {\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n             if (numRef.length() == 0) { // didn't match anything\n-                characterReferenceError();\n+                characterReferenceError(\"numeric reference with no numerals\");\n                 reader.rewindToMark();\n                 return null;\n             }\n             if (!reader.matchConsume(\";\"))\n-                characterReferenceError(); // missing semi\n+                characterReferenceError(\"missing semicolon\"); // missing semi\n             int charval = -1;\n             try {\n                 int base = isHexMode ? 16 : 10;\n             } catch (NumberFormatException e) {\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n-                characterReferenceError();\n+                characterReferenceError(\"character outside of valid range\");\n                 return replacementChar;\n             } else {\n                 // todo: implement number replacement table\n         } else { // named\n             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n             String nameRef = reader.consumeLetterSequence();\n+            String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n             boolean looksLegit = reader.matches(';');\n             boolean found = false;\n             while (nameRef.length() > 0 && !found) {\n             }\n             if (!found) {\n                 if (looksLegit) // named with semicolon\n-                    characterReferenceError();\n+                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                 reader.rewindToMark();\n                 return null;\n             }\n                 return null;\n             }\n             if (!reader.matchConsume(\";\"))\n-                characterReferenceError(); // missing semi\n+                characterReferenceError(\"missing semicolon\"); // missing semi\n             return Entities.getCharacterByName(nameRef);\n         }\n     }\n         return lastStartTag.tagName;\n     }\n \n-    boolean isTrackErrors() {\n-        return trackErrors;\n-    }\n-\n-    void setTrackErrors(boolean trackErrors) {\n-        this.trackErrors = trackErrors;\n-    }\n-\n     void error(TokeniserState state) {\n         if (trackErrors)\n-            errors.add(new ParseError(\"Unexpected character in input\", reader.current(), state, reader.pos()));\n+            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n     }\n \n     void eofError(TokeniserState state) {\n         if (trackErrors)\n-            errors.add(new ParseError(\"Unexpectedly reached end of file (EOF)\", state, reader.pos()));\n-    }\n-\n-    private void characterReferenceError() {\n-        if (trackErrors)\n-            errors.add(new ParseError(\"Invalid character reference\", reader.pos()));\n+            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n+    }\n+\n+    private void characterReferenceError(String message) {\n+        if (trackErrors)\n+            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n     }\n \n     private void error(String errorMsg) {\n         if (trackErrors)\n-            errors.add(new ParseError(errorMsg, reader.pos()));\n+            errors.add(new ParseError(reader.pos(), errorMsg));\n     }\n \n     boolean currentNodeInHtmlNS() {\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected boolean trackErrors = false;\n-    protected List<ParseError> errors;\n+    protected List<ParseError> errors; // null when not tracking errors\n \n     protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n         Validate.notNull(input, \"String input must not be null\");\n \n         doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n-        tokeniser = new Tokeniser(reader);\n+        this.trackErrors = trackErrors;\n+        errors = trackErrors ? new ArrayList<ParseError>() : null;\n+        tokeniser = new Tokeniser(reader, errors);\n         stack = new DescendableLinkedList<Element>();\n         this.baseUri = baseUri;\n-        errors = new ArrayList<ParseError>();\n-        this.trackErrors = trackErrors;\n     }\n \n     Document parse(String input, String baseUri) {\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n \n /**\n         Document doc = Jsoup.parse(html);\n         assertEquals(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\", doc.childNode(0).outerHtml());\n     }\n+    \n+    @Test public void tracksErrorsWhenRequested() {\n+        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n+        Parser parser = Parser.htmlParser().setTrackErrors(true);\n+        Document doc = parser.parseInput(html, \"http://example.com\");\n+        \n+        List<ParseError> errors = parser.getErrors();\n+        assertEquals(5, errors.size());\n+        assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());\n+        assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());\n+        assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());\n+        assertEquals(\"50: Self closing flag not acknowledged\", errors.get(3).toString());\n+        assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());\n+    }\n+\n+    @Test public void noErrorsByDefault() {\n+        String html = \"<p>One</p href='no'>&arrgh;<font /><br /><foo\";\n+        Parser parser = Parser.htmlParser();\n+        Document doc = parser.parseInput(html, \"http://example.com\");\n+\n+        List<ParseError> errors = parser.getErrors();\n+        assertNull(errors);\n+    }\n }", "timestamp": 1332216123, "metainfo": ""}