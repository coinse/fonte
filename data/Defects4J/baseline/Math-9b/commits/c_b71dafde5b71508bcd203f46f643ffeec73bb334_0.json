{"sha": "b71dafde5b71508bcd203f46f643ffeec73bb334", "log": "Removed FieldDecompositionSolver<T>.solve(T[]). This is in accordance with JIRA MATH-661.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n      * @throws SingularMatrixException\n      * if the decomposed matrix is singular.\n      */\n-    T[] solve(final T[] b);\n+    //T[] solve(final T[] b);\n \n     /** Solve the linear equation A &times; X = B for matrices A.\n      * <p>The A matrix is implicit, it is provided by the underlying\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n         }\n \n         /** {@inheritDoc} */\n-        public T[] solve(T[] b) {\n-            final int m = pivot.length;\n-            if (b.length != m) {\n-                throw new DimensionMismatchException(b.length, m);\n-            }\n-            if (singular) {\n-                throw new SingularMatrixException();\n-            }\n-\n-            @SuppressWarnings(\"unchecked\") // field is of type T\n-            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n-\n-            // Apply permutations to b\n-            for (int row = 0; row < m; row++) {\n-                bp[row] = b[pivot[row]];\n-            }\n-\n-            // Solve LY = b\n-            for (int col = 0; col < m; col++) {\n-                final T bpCol = bp[col];\n-                for (int i = col + 1; i < m; i++) {\n-                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n-                }\n-            }\n-\n-            // Solve UX = Y\n-            for (int col = m - 1; col >= 0; col--) {\n-                bp[col] = bp[col].divide(lu[col][col]);\n-                final T bpCol = bp[col];\n-                for (int i = 0; i < col; i++) {\n-                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n-                }\n-            }\n-\n-            return bp;\n-\n-        }\n-\n-        /** {@inheritDoc} */\n         public FieldVector<T> solve(FieldVector<T> b) {\n             try {\n                 return solve((ArrayFieldVector<T>) b);\n          * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         public ArrayFieldVector<T> solve(ArrayFieldVector<T> b) {\n-            return new ArrayFieldVector<T>(field, solve(b.getDataRef()), false);\n+            final int m = pivot.length;\n+            if (b.data.length != m) {\n+                throw new DimensionMismatchException(b.data.length, m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            // field is of type T\n+            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(),\n+                                                   m);\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b.data[pivot[row]];\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] = bp[col].divide(lu[col][col]);\n+                final T bpCol = bp[col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            return new ArrayFieldVector<T>(bp, false);\n         }\n \n         /** {@inheritDoc} */", "timestamp": 1316413176, "metainfo": ""}