{"sha": "74cd1e53b5ba7e9ef148c0e99c2b11e44ab5f5e7", "log": "MATH-432 Made \"Pair\" immutable.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n         }\n \n         final int len = x.length;\n-        final List<Map.Entry<Double, double[]>> list\n-            = new ArrayList<Map.Entry<Double, double[]>>(len);\n+        final List<Pair<Double, double[]>> list\n+            = new ArrayList<Pair<Double, double[]>>(len);\n \n         final int yListLen = yList.length;\n         for (int i = 0; i < len; i++) {\n             list.add(new Pair<Double, double[]>(x[i], yValues));\n         }\n \n-        final Comparator<Map.Entry<Double, double[]>> comp\n-            = new Comparator<Map.Entry<Double, double[]>>() {\n-            public int compare(Map.Entry<Double, double[]> o1,\n-                               Map.Entry<Double, double[]> o2) {\n+        final Comparator<Pair<Double, double[]>> comp\n+            = new Comparator<Pair<Double, double[]>>() {\n+            public int compare(Pair<Double, double[]> o1,\n+                               Pair<Double, double[]> o2) {\n                 int val;\n                 switch (dir) {\n                 case INCREASING:\n         Collections.sort(list, comp);\n \n         for (int i = 0; i < len; i++) {\n-            final Map.Entry<Double, double[]> e = list.get(i);\n+            final Pair<Double, double[]> e = list.get(i);\n             x[i] = e.getKey();\n             final double[] yValues = e.getValue();\n             for (int j = 0; j < yListLen; j++) {\n--- a/src/main/java/org/apache/commons/math/util/Pair.java\n+++ b/src/main/java/org/apache/commons/math/util/Pair.java\n  */\n package org.apache.commons.math.util;\n \n-import java.util.Map;\n-\n /**\n  * Generic pair.\n  * It is provided as a replacement for the standard\n  * {@code AbstractMap.SimpleEntry} that is available only in Java 1.6\n  * and later.\n+ * Immutable class.\n  *\n  * @param <K> Key type.\n  * @param <V> Value type.\n  * @version $Revision$ $Date$\n  * @since 3.0\n  */\n-public class Pair<K, V> implements Map.Entry<K, V> {\n+public class Pair<K, V> {\n     /** Key. */\n-    private K key;\n+    private final K key;\n     /** Value. */\n-    private V value;\n+    private final V value;\n \n     /**\n      * Create an entry representing a mapping from the specified key to the\n      *\n      * @param entry Entry to copy.\n      */\n-    Pair(Map.Entry<? extends K, ? extends V> entry) {\n+    Pair(Pair<? extends K, ? extends V> entry) {\n         key = entry.getKey();\n         value = entry.getValue();\n     }\n     }\n \n     /**\n-     * Set the value.\n-     *\n-     * @param v Value to be stored.\n-     * @return the old value.\n-     */\n-    public V setValue(V v) {\n-        V old = value;\n-        value = v;\n-        return old;\n-    }\n-\n-    /**\n      * Compare the specified object with this entry for equality.\n      *\n      * @param o Object.\n         if (o == null) {\n             return false;\n         }\n-        if (!(o instanceof Map.Entry)) {\n+        if (!(o instanceof Pair)) {\n             return false;\n         } else {\n-            Map.Entry<? extends K, ? extends V> ome\n-                = (Map.Entry<? extends K, ? extends V>) o;\n+            Pair<? extends K, ? extends V> oP\n+                = (Pair<? extends K, ? extends V>) o;\n             return (key == null ?\n-                    ome.getKey() == null :\n-                    key.equals(ome.getKey())) &&\n+                    oP.getKey() == null :\n+                    key.equals(oP.getKey())) &&\n                 (value == null ?\n-                 ome.getValue() == null :\n-                 value.equals(ome.getValue()));\n+                 oP.getValue() == null :\n+                 value.equals(oP.getValue()));\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/util/PairTest.java\n+++ b/src/test/java/org/apache/commons/math/util/PairTest.java\n             = new Pair<Integer, Double>(new Integer(1), new Double(2));\n         Assert.assertEquals(new Integer(1), p.getKey());\n         Assert.assertEquals(new Double(2), p.getValue(), Math.ulp(1d));\n-\n-        final Double old = p.setValue(new Double(3));\n-        Assert.assertEquals(new Double(2), old, Math.ulp(1d));\n-        Assert.assertEquals(new Double(3), p.getValue(), Math.ulp(1d));\n     }\n \n     @Test\n         p1 = new Pair<Integer, Double>(new Integer(1), new Double(2));\n         Assert.assertFalse(p1.equals(p2));\n \n-        Pair<Integer, Number> p3 = new Pair<Integer, Number>(new Integer(1), null);\n-        Assert.assertFalse(p1.equals(p3));\n-        p3.setValue(new Double(3));\n-        Assert.assertFalse(p1.equals(p3));\n-        p3.setValue(new Double(2));\n-        Assert.assertTrue(p1.equals(p3));\n+        p2 = new Pair<Integer, Double>(new Integer(1), new Double(2));\n+        Assert.assertTrue(p1.equals(p2));\n     }\n }", "timestamp": 1289043488, "metainfo": ""}