{"sha": "5aa7ce72fa3214561ac7919cc87dcc602fa97a40", "log": "MATH-786 Allow caching of the hash code computation. User is expected to not change the pair contents if he requested the hash code to be cached.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/Pair.java\n+++ b/src/main/java/org/apache/commons/math3/util/Pair.java\n \n /**\n  * Generic pair.\n- * Immutable class.\n+ * <br/>\n+ * Although the instances of this class are immutable, it is impossible\n+ * to ensure that the references passed to the constructor will not be\n+ * modified by the caller.\n  *\n  * @param <K> Key type.\n  * @param <V> Value type.\n     private final K key;\n     /** Value. */\n     private final V value;\n+    /** Whether the pair contents can be assumed to be immutable. */\n+    private final boolean isImmutable;\n+    /** Cached has code. */\n+    private final int cachedHashCode;\n+\n+    /**\n+     * Create an entry representing a mapping from the specified key to the\n+     * specified value.\n+     * If the pair can be assumed to be immutable, the hash code will be\n+     * cached.\n+     *\n+     * @param k Key.\n+     * @param v Value.\n+     * @param assumeImmutable Whether the pair contents can be assumed to\n+     * be immutable.\n+     */\n+    public Pair(K k, V v, boolean assumeImmutable) {\n+        key = k;\n+        value = v;\n+        isImmutable = assumeImmutable;\n+        cachedHashCode = computeHashCode();\n+    }\n \n     /**\n      * Create an entry representing a mapping from the specified key to the\n      * @param v Value.\n      */\n     public Pair(K k, V v) {\n-        key = k;\n-        value = v;\n+        this(k, v, false);\n+    }\n+\n+    /**\n+     * Create an entry representing the same mapping as the specified entry.\n+     * If the pair can be assumed to be immutable, the hash code will be\n+     * cached.\n+     *\n+     * @param entry Entry to copy.\n+     * @param assumeImmutable Whether the pair contents can be assumed to\n+     * be immutable.\n+     */\n+    public Pair(Pair<? extends K, ? extends V> entry, boolean assumeImmutable) {\n+        this(entry.getKey(), entry.getValue(), assumeImmutable);\n     }\n \n     /**\n      * @param entry Entry to copy.\n      */\n     public Pair(Pair<? extends K, ? extends V> entry) {\n-        key = entry.getKey();\n-        value = entry.getValue();\n+        this(entry, false);\n     }\n \n     /**\n      */\n     @Override\n     public int hashCode() {\n-        return (key == null ? 0 : key.hashCode()) ^\n-            (value == null ? 0 : value.hashCode());\n+        return isImmutable ? cachedHashCode : computeHashCode();\n+    }\n+\n+    /**\n+     * Compute a hash code.\n+     *\n+     * @return the hash code value.\n+     */\n+    private final int computeHashCode() {\n+        int result = key == null ? 0 : key.hashCode();\n+\n+        final int h = value == null ? 0 : value.hashCode();\n+        result = 37 * result + h ^ (h >>> 16);\n+\n+        return result;\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/util/PairTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/PairTest.java\n         Pair<Integer, Float> p3 = new Pair<Integer, Float>(new Integer(1), new Float(2));\n         Assert.assertFalse(p1.equals(p3));\n     }\n+\n+    @Test\n+    public void testHashCode() {\n+        final MyInteger m1 = new MyInteger(1);\n+        final MyInteger m2 = new MyInteger(1);\n+\n+        final Pair<MyInteger, MyInteger> p1 = new Pair<MyInteger, MyInteger>(m1, m1);\n+        final Pair<MyInteger, MyInteger> p2 = new Pair<MyInteger, MyInteger>(m2, m2);\n+        // Same contents, same hash code.\n+        Assert.assertTrue(p1.hashCode() == p2.hashCode());\n+\n+        // Different contents, different hash codes.\n+        m2.set(2);\n+        Assert.assertFalse(p1.hashCode() == p2.hashCode());\n+\n+        // Test cache.\n+\n+        final MyInteger m3 = new MyInteger(1);\n+        final Pair<MyInteger, MyInteger> p3 = new Pair<MyInteger, MyInteger>(m3, m3, true);\n+        final int hC3 = p3.hashCode();\n+        // Contents change will not affect the hash code because it is cached.\n+        m3.set(3);\n+        Assert.assertTrue(hC3 == p3.hashCode());\n+\n+        final Pair<MyInteger, MyInteger> p4 = new Pair<MyInteger, MyInteger>(p3, false);\n+        // p3 and p4 do not have the same hash code because p4 was contructed after m3\n+        // was changed.\n+        Assert.assertFalse(p4.hashCode() == p3.hashCode());\n+        final int hC4 = p4.hashCode();\n+        // Contents change will affect the hash code because it is not cached.\n+        m3.set(4);\n+        Assert.assertFalse(hC4 == p4.hashCode());\n+    }\n+\n+    /**\n+     * A mutable integer.\n+     */\n+    private static class MyInteger {\n+        private int i;\n+\n+        public MyInteger(int i) {\n+            this.i = i;\n+        }\n+\n+        public void set(int i) {\n+            this.i = i;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null) {\n+                return false;\n+            }\n+            if (!(o instanceof MyInteger)) {\n+                return false;\n+            } else {\n+                return i == ((MyInteger) o).i;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return i;\n+        }\n+    }\n }", "timestamp": 1336608848, "metainfo": ""}