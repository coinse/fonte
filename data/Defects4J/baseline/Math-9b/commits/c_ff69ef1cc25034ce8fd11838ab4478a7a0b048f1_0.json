{"sha": "ff69ef1cc25034ce8fd11838ab4478a7a0b048f1", "log": "[MATH-156] use initial guess provided by the caller to BrentSolver.solve(), thus improving speed  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n     }\n \n     /**\n-     * Find a zero in the given interval.\n-     * <p>\n-     * Throws <code>ConvergenceException</code> if the values of the function\n-     * at the endpoints of the interval have the same sign.\n+     * Find a zero in the given interval with an initial guess.\n+     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n+     * function at the three points have the same sign (note that it is\n+     * allowed to have endpoints with the same signe if the initial point has\n+     * opposite sign function-wise).</p>\n      * \n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n-     * @param initial the start value to use (ignored).\n+     * @param initial the start value to use (must be set to x0 if no\n+     * initial point is known).\n      * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException the maximum iteration count\n+     * is exceeded \n      * @throws FunctionEvaluationException if an error occurs evaluating\n      *  the function\n      * @throws IllegalArgumentException if initial is not between min and max\n+     * (even if it <em>is</em> a root)\n      */\n     public double solve(double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-            \n-        return solve(min, max);\n+\n+        if (((initial - min) * (max -initial)) < 0) {\n+            throw new IllegalArgumentException(\"Initial guess is not in search\"\n+                    + \" interval.\" + \"  Initial: \" + initial\n+                    +  \"  Endpoints: [\" + min + \",\" + max + \"]\");\n+        }\n+\n+        // return the initial guess if it is good enough\n+        double yInitial = f.value(initial);\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+            setResult(initial, 0);\n+            return result;\n+        }\n+\n+        // return the first endpoint if it is good enough\n+        double yMin = f.value(min);\n+        if (Math.abs(yMin) <= functionValueAccuracy) {\n+            setResult(yMin, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if min and initial bracket the root\n+        if (yInitial * yMin < 0) {\n+            return solve(min, yMin, initial, yInitial, min, yMin);\n+        }\n+\n+        // return the second endpoint if it is good enough\n+        double yMax = f.value(max);\n+        if (Math.abs(yMax) <= functionValueAccuracy) {\n+            setResult(yMax, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if initial and max bracket the root\n+        if (yInitial * yMax < 0) {\n+            return solve(initial, yInitial, max, yMax, initial, yInitial);\n+        }\n+\n+        // full Brent algorithm starting with provided initial guess\n+        return solve(min, yMin, max, yMax, initial, yInitial);\n+\n     }\n     \n     /**\n         clearResult();\n         verifyInterval(min, max);\n         \n-        // Index 0 is the old approximation for the root.\n-        // Index 1 is the last calculated approximation  for the root.\n-        // Index 2 is a bracket for the root with respect to x1.\n-        double x0 = min;\n-        double x1 = max;\n-        double y0;\n-        double y1;\n-        y0 = f.value(x0);\n-        y1 = f.value(x1);\n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n         \n         // Verify bracketing\n-        if (y0 * y1 >= 0) {\n+        if (yMin * yMax >= 0) {\n             throw new IllegalArgumentException\n             (\"Function values at endpoints do not have different signs.\" +\n                     \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                    \"  Values: [\" + y0 + \",\" + y1 + \"]\");       \n-        }\n-   \n-        double x2 = x0;\n-        double y2 = y0;\n+                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");       \n+        }\n+\n+        // solve using only the first endpoint as initial guess\n+        return solve(min, yMin, max, yMax, min, yMin);\n+\n+    }\n+        \n+    /**\n+     * Find a zero starting search according to the three provided points.\n+     * @param x0 old approximation for the root\n+     * @param y0 function value at the approximation for the root\n+     * @param x1 last calculated approximation for the root\n+     * @param y1 function value at the last calculated approximation\n+     * for the root\n+     * @param x2 bracket point (must be set to x0 if no bracket point is\n+     * known, this will force starting with linear interpolation)\n+     * @param y3 function value at the bracket point.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function \n+     */\n+    private double solve(double x0, double y0,\n+                         double x1, double y1,\n+                         double x2, double y2)\n+    throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n         double delta = x1 - x0;\n         double oldDelta = delta;\n \n         int i = 0;\n         while (i < maximalIterationCount) {\n             if (Math.abs(y2) < Math.abs(y1)) {\n+                // use the bracket point if is better than last approximation\n                 x0 = x1;\n                 x1 = x2;\n                 x2 = x0;\n--- a/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n             // expected\n         }\n     }\n+\n+    public void testInitialGuess() throws MathException {\n+\n+        MonitoredFunction f = new MonitoredFunction(new QuinticFunction());\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        double result;\n+\n+        // no guess\n+        result = solver.solve(0.6, 7.0);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        int referenceCallsCount = f.getCallsCount();\n+        assertTrue(referenceCallsCount >= 13);\n+ \n+        // invalid guess (it *is* a root, but outside of the range)\n+        try {\n+          result = solver.solve(0.6, 7.0, 0.0);\n+          fail(\"an IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behaviour\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+ \n+        // bad guess\n+        f.setCallsCount(0);\n+        result = solver.solve(0.6, 7.0, 0.61);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertTrue(f.getCallsCount() > referenceCallsCount);\n+ \n+        // good guess\n+        f.setCallsCount(0);\n+        result = solver.solve(0.6, 7.0, 0.999999);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertTrue(f.getCallsCount() < referenceCallsCount);\n+\n+        // perfect guess\n+        f.setCallsCount(0);\n+        result = solver.solve(0.6, 7.0, 1.0);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(0, solver.getIterationCount());\n+        assertEquals(1, f.getCallsCount());\n+ \n+    }\n+    \n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/MonitoredFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Wrapper class for counting functions calls.\n+ *\n+ * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $ \n+ */\n+public class MonitoredFunction implements UnivariateRealFunction {\n+\n+    public MonitoredFunction(UnivariateRealFunction f) {\n+        callsCount = 0;\n+        this.f = f;\n+    }\n+\n+    public void setCallsCount(int callsCount) {\n+        this.callsCount = callsCount;\n+    }\n+\n+    public int getCallsCount() {\n+        return callsCount;\n+    }\n+\n+    public double value(double x) throws FunctionEvaluationException {\n+        ++callsCount;\n+        return f.value(x);\n+    }\n+\n+    private int callsCount;\n+    private UnivariateRealFunction f;\n+\n+}", "timestamp": 1178648212, "metainfo": ""}