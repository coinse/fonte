{"sha": "722d5d9867bbaa135e3d7347b7ff4f7c52762938", "log": "MATH-698 Bounds passed as arguments in \"optimize\" method.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n public class BOBYQAOptimizer\n     extends BaseAbstractScalarOptimizer<MultivariateRealFunction>\n     implements MultivariateRealOptimizer {\n+    /** Minimum dimension of the problem: {@value} */\n+    public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n+    /** Default value for {@link #initialTrustRegionRadius}: {@value} . */\n+    public static final double DEFAULT_INITIAL_RADIUS = 10.0;\n+    /** Default value for {@link #stoppingTrustRegionRadius}: {@value} . */\n+    public static final double DEFAULT_STOPPING_RADIUS = 1E-8;\n+\n     private static final double ZERO = 0d;\n     private static final double ONE = 1d;\n     private static final double TWO = 2d;\n     private static final double ONE_OVER_TEN = ONE / 10;\n     private static final double ONE_OVER_A_THOUSAND = ONE / 1000;\n \n-    /** Minimum dimension of the problem: {@value} */\n-    public static final int MINIMUM_PROBLEM_DIMENSION = 2;\n-    /** Default value for {@link #initialTrustRegionRadius}: {@value} . */\n-    public static final double DEFAULT_INITIAL_RADIUS = 10.0;\n-    /** Default value for {@link #stoppingTrustRegionRadius}: {@value} . */\n-    public static final double DEFAULT_STOPPING_RADIUS = 1E-8;\n-\n     /**\n      * numberOfInterpolationPoints XXX\n      */\n      * stoppingTrustRegionRadius XXX\n      */\n     private final double stoppingTrustRegionRadius;\n-    /**\n-     * Lower bounds of the objective variables.\n-     * {@code null} means no bounds.\n-     * XXX Should probably be passed to the \"optimize\" method (overload not existing yet).\n-     */\n-    private double[] lowerBound;\n-    /**\n-     * Upper bounds of the objective variables.\n-     * {@code null} means no bounds.\n-     * XXX Should probably be passed to the \"optimize\" method (overload not existing yet).\n-     */\n-    private double[] upperBound;\n-\n     /** Goal type (minimize or maximize). */\n     private boolean isMinimize;\n     /**\n      */\n     private ArrayRealVector gradientAtTrustRegionCenter;\n     /**\n-     * Differences {@link #lowerBound} - {@link #originShift}.\n+     * Differences {@link #getLowerBound()} - {@link #originShift}.\n      * All the components of every {@link #trustRegionCenterOffset} are going\n      * to satisfy the bounds<br/>\n-     * {@link #lowerBound}<sub>i</sub> &le;\n+     * {@link #getLowerBound() lowerBound}<sub>i</sub> &le;\n      * {@link #trustRegionCenterOffset}<sub>i</sub>,<br/>\n      * with appropriate equalities when {@link #trustRegionCenterOffset} is\n      * on a constraint boundary.\n      */\n     private ArrayRealVector lowerDifference;\n     /**\n-     * Differences {@link #upperBound} - {@link #originShift}\n+     * Differences {@link #getUpperBound()} - {@link #originShift}\n      * All the components of every {@link #trustRegionCenterOffset} are going\n      * to satisfy the bounds<br/>\n      *  {@link #trustRegionCenterOffset}<sub>i</sub> &le;\n-     *  {@link #upperBound}<sub>i</sub>,<br/>\n+     *  {@link #getUpperBound() upperBound}<sub>i</sub>,<br/>\n      * with appropriate equalities when {@link #trustRegionCenterOffset} is\n      * on a constraint boundary.\n      * XXX \"su\" in the original code.\n      * Choices that exceed {@code 2n+1} are not recommended.\n      */\n     public BOBYQAOptimizer(int numberOfInterpolationPoints) {\n-        this(numberOfInterpolationPoints, null, null);\n+        this(numberOfInterpolationPoints,\n+             DEFAULT_INITIAL_RADIUS,\n+             DEFAULT_STOPPING_RADIUS);\n     }\n \n     /**\n      * For a problem of dimension {@code n}, its value must be in the interval\n      * {@code [n+2, (n+1)(n+2)/2]}.\n      * Choices that exceed {@code 2n+1} are not recommended.\n-     * @param lowerBound Lower bounds (constraints) of the objective variables.\n-     * @param upperBound Upperer bounds (constraints) of the objective variables.\n-     */\n-    public BOBYQAOptimizer(int numberOfInterpolationPoints,\n-                           double[] lowerBound,\n-                           double[] upperBound) {\n-        this(numberOfInterpolationPoints,\n-             lowerBound,\n-             upperBound,\n-             DEFAULT_INITIAL_RADIUS,\n-             DEFAULT_STOPPING_RADIUS);\n-    }\n-\n-    /**\n-     * @param numberOfInterpolationPoints Number of interpolation conditions.\n-     * For a problem of dimension {@code n}, its value must be in the interval\n-     * {@code [n+2, (n+1)(n+2)/2]}.\n-     * Choices that exceed {@code 2n+1} are not recommended.\n-     * @param lowerBound Lower bounds (constraints) of the objective variables.\n-     * @param upperBound Upperer bounds (constraints) of the objective variables.\n      * @param initialTrustRegionRadius Initial trust region radius.\n      * @param stoppingTrustRegionRadius Stopping trust region radius.\n      */\n     public BOBYQAOptimizer(int numberOfInterpolationPoints,\n-                           double[] lowerBound,\n-                           double[] upperBound,\n                            double initialTrustRegionRadius,\n                            double stoppingTrustRegionRadius) {\n-        this.lowerBound = lowerBound == null ? null : MathArrays.copyOf(lowerBound);\n-        this.upperBound = upperBound == null ? null : MathArrays.copyOf(upperBound);\n         this.numberOfInterpolationPoints = numberOfInterpolationPoints;\n         this.initialTrustRegionRadius = initialTrustRegionRadius;\n         this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n     /** {@inheritDoc} */\n     @Override\n     protected RealPointValuePair doOptimize() {\n+        final double[] lowerBound = getLowerBound();\n+        final double[] upperBound = getUpperBound();\n+\n         // Validity checks.\n-        setup();\n+        setup(lowerBound, upperBound);\n \n         isMinimize = (getGoalType() == GoalType.MINIMIZE);\n         currentBest = new ArrayRealVector(getStartPoint());\n \n-        final double value = bobyqa();\n+        final double value = bobyqa(lowerBound, upperBound);\n \n         return new RealPointValuePair(currentBest.getDataRef(),\n                                       isMinimize ? value : -value);\n      *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.\n      *     The array W will be used for working space. Its length must be at least\n      *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.\n-     * @return\n-     */\n-    private double bobyqa() {\n+     *\n+     * @param lowerBound Lower bounds.\n+     * @param upperBound Upper bounds.\n+     * @return the value of the objective at the optimum.\n+     */\n+    private double bobyqa(double[] lowerBound,\n+                          double[] upperBound) {\n         printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n \n         // Make the call of BOBYQB.\n \n-        return bobyqb();\n+        return bobyqb(lowerBound, upperBound);\n     } // bobyqa\n \n     // ----------------------------------------------------------------------------------------\n      *     W is a one-dimensional array that is used for working space. Its length\n      *       must be at least 3*NDIM = 3*(NPT+N).\n      *\n-     * @return\n-     */\n-    private double bobyqb() {\n+     * @param lowerBound Lower bounds.\n+     * @param upperBound Upper bounds.\n+     * @return the value of the objective at the optimum.\n+     */\n+    private double bobyqb(double[] lowerBound,\n+                          double[] upperBound) {\n         printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n \n         trustRegionCenterInterpolationPointIndex = 0;\n \n-        prelim();\n+        prelim(lowerBound, upperBound);\n         double xoptsq = ZERO;\n         for (int i = 0; i < n; i++) {\n             trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n      *     KOPT will be such that the least calculated value of F so far is at\n      *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n      *\n-     */\n-    private void prelim() {\n+     * @param lowerBound Lower bounds.\n+     * @param upperBound Upper bounds.\n+     */\n+    private void prelim(double[] lowerBound,\n+                        double[] upperBound) {\n         printMethod(); // XXX\n \n         final int n = currentBest.getDimension();\n     } // update\n \n     /**\n-     * Performs validity checks and adapt the {@link #lowerBound} and\n-     * {@link #upperBound} array if no constraints were provided.\n-     */\n-    private void setup() {\n+     * Performs validity checks.\n+     *\n+     * @param lowerBound Lower bounds (constraints) of the objective variables.\n+     * @param upperBound Upperer bounds (constraints) of the objective variables.\n+     */\n+    private void setup(double[] lowerBound,\n+                       double[] upperBound) {\n         printMethod(); // XXX\n \n         double[] init = getStartPoint();\n                                           nPointsInterval[1]);\n         }\n \n-        // Check (and possibly adapt) bounds.\n-        if (lowerBound == null) {\n-            lowerBound = fillNewArray(dimension, Double.NEGATIVE_INFINITY);\n-        } else if (lowerBound.length != init.length) {\n-            throw new DimensionMismatchException(lowerBound.length, dimension);\n-        }\n-\n-        if (upperBound == null) {\n-            upperBound = fillNewArray(dimension, Double.POSITIVE_INFINITY);\n-        } else if (upperBound.length != init.length) {\n-            throw new DimensionMismatchException(upperBound.length, dimension);\n-        }\n-\n-       for (int i = 0; i < dimension; i++) {\n-            final double v = init[i];\n-            final double lo = lowerBound[i];\n-            final double hi = upperBound[i];\n-            if (v < lo || v > hi) {\n-                throw new OutOfRangeException(v, lo, hi);\n-            }\n-        }\n-\n         // Initialize bound differences.\n         boundDifference = new double[dimension];\n \n         double requiredMinDiff = 2 * initialTrustRegionRadius;\n         double minDiff = Double.POSITIVE_INFINITY;\n-       for (int i = 0; i < dimension; i++) {\n+        for (int i = 0; i < dimension; i++) {\n             boundDifference[i] = upperBound[i] - lowerBound[i];\n             minDiff = Math.min(minDiff, boundDifference[i]);\n         }\n--- a/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NoDataException;\n-import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n \n     static final int DIM = 13;\n    \n-    @Test(expected=OutOfRangeException.class)\n+    @Test(expected=NumberIsTooLargeException.class)\n     public void testInitOutOfBounds() {\n         double[] startPoint = point(DIM, 3);\n         double[][] boundaries = boundaries(DIM, -1, 2);\n //        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);\n         final double[] lB = boundaries == null ? null : boundaries[0];\n         final double[] uB = boundaries == null ? null : boundaries[1];\n-        MultivariateRealOptimizer optim =\n-            new BOBYQAOptimizer(2 * dim + 1, lB, uB);\n-        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);        \n+        MultivariateRealOptimizer optim = new BOBYQAOptimizer(2 * dim + 1);\n+        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n //        System.out.println(func.getClass().getName() + \" = \" \n //              + optim.getEvaluations() + \" f(\");\n //        for (double x: result.getPoint())  System.out.print(x + \" \");", "timestamp": 1319916936, "metainfo": ""}