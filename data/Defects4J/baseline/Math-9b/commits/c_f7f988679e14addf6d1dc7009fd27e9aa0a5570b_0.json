{"sha": "f7f988679e14addf6d1dc7009fd27e9aa0a5570b", "log": "Added sampling methods to the distribution classes, based on the random data generation methods in the random package. JIRA: MATH-310  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n    { \"Discrete cumulative probability function returned NaN for argument {0}\",\n      \"Discr\\u00e8tes fonction de probabilit\\u00e9 cumulative retourn\\u00e9 NaN \\u00e0 l''argument de {0}\" },\n \n+   // org.apache.commons.math.distribution.AbstractIntegerDistribution\n+   // org.apache.commons.math.distribution.AbstractContinuousDistribution\n+   { \"Sample size must be positive\",\n+     \"Taille de l'\\u00e9chantillon doit \\u00eatre positif\" },\n \n    // org.apache.commons.math.distribution.BinomialDistributionImpl\n    { \"number of trials must be non-negative ({0})\",\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+import org.apache.commons.math.random.RandomDataImpl;\n \n /**\n  * Base class for continuous distributions.  Default implementations are\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n+    \n+    /**\n+     * RandomData instance used to generate samples from the distribution\n+     * @since 2.2\n+     */\n+    protected final RandomDataImpl randomData = new RandomDataImpl();\n \n     /**\n      * Solver absolute accuracy for inverse cum computation\n             }\n         };\n \n-        // Try to bracket root, test domain endoints if this fails\n+        // Try to bracket root, test domain endpoints if this fails\n         double lowerBound = getDomainLowerBound(p);\n         double upperBound = getDomainUpperBound(p);\n         double[] bracket = null;\n     }\n \n     /**\n+     * Reseeds the random generator used to generate samples.\n+     *\n+     * @param seed the new seed\n+     * @since 2.2\n+     */\n+    public void reseedRandomGenerator(long seed) {\n+        randomData.reSeed(seed);\n+    }\n+\n+    /**\n+     * Generates a random value sampled from this distribution. The default\n+     * implementation uses the\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\"> inversion method.</a>\n+     *\n+     * @return random value\n+     * @since 2.2\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public double sample() throws MathException {\n+        return randomData.nextInversionDeviate(this);\n+    }\n+\n+    /**\n+     * Generates a random sample from the distribution.  The default implementation\n+     * generates the sample by calling {@link #sample()} in a loop.\n+     *\n+     * @param sampleSize number of random values to generate\n+     * @since 2.2\n+     * @return an array representing the random sample\n+     * @throws MathException if an error occurs generating the sample\n+     * @throws IllegalArgumentException if sampleSize is not positive\n+     */\n+    public double[] sample(int sampleSize) throws MathException {\n+        if (sampleSize <= 0) {\n+            MathRuntimeException.createIllegalArgumentException(\"Sample size must be positive\");\n+        }\n+        double[] out = new double[sampleSize];\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+        return out;\n+    }\n+\n+    /**\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n     protected double getSolverAbsoluteAccuracy() {\n         return solverAbsoluteAccuracy;\n     }\n+\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.random.RandomDataImpl;\n \n \n /**\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n+\n+    /**\n+     * RandomData instance used to generate samples from the distribution\n+     * @since 2.2\n+     */\n+    protected final RandomDataImpl randomData = new RandomDataImpl();\n \n     /**\n      * Default constructor.\n     }\n \n     /**\n-     * Computes the cumulative probablity function and checks for NaN values returned.\n+     * Reseeds the random generator used to generate samples.\n+     *\n+     * @param seed the new seed\n+     * @since 2.2\n+     */\n+    public void reseedRandomGenerator(long seed) {\n+        randomData.reSeed(seed);\n+    }\n+\n+    /**\n+     * Generates a random value sampled from this distribution. The default\n+     * implementation uses the\n+     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\"> inversion method.</a>\n+     *\n+     * @return random value\n+     * @since 2.2\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    public int sample() throws MathException {\n+        return randomData.nextInversionDeviate(this);\n+    }\n+\n+    /**\n+     * Generates a random sample from the distribution.  The default implementation\n+     * generates the sample by calling {@link #sample()} in a loop.\n+     *\n+     * @param sampleSize number of random values to generate\n+     * @since 2.2\n+     * @return an array representing the random sample\n+     * @throws MathException if an error occurs generating the sample\n+     * @throws IllegalArgumentException if sampleSize is not positive\n+     */\n+    public int[] sample(int sampleSize) throws MathException {\n+        if (sampleSize <= 0) {\n+            MathRuntimeException.createIllegalArgumentException(\"Sample size must be positive\");\n+        }\n+        int[] out = new int[sampleSize];\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Computes the cumulative probability function and checks for NaN values returned.\n      * Throws MathException if the value is NaN. Wraps and rethrows any MathException encountered\n      * evaluating the cumulative probability function in a FunctionEvaluationException. Throws\n      * FunctionEvaluationException of the cumulative probability function returns NaN.\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n     }\n \n     /**\n+     * Generates a random value sampled from this distribution.\n+     *\n+     * <p><strong>Algorithm Description</strong>: Uses the <a\n+     * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n+     * Method</a> to generate exponentially distributed random values from\n+     * uniform deviates. </p>\n+     *\n+     * @return random value\n+     * @since 2.2\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    @Override\n+    public double sample() throws MathException {\n+        return randomData.nextExponential(mean);\n+    }\n+\n+    /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.\n      *\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n     }\n \n     /**\n+     * Generates a random value sampled from this distribution.\n+     *\n+     * @return random value\n+     * @since 2.2\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    @Override\n+    public double sample() throws MathException {\n+        return randomData.nextGaussian(mean, standardDeviation);\n+    }\n+\n+    /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n     }\n \n     /**\n+     * Generates a random value sampled from this distribution.\n+     *\n+     * <p><strong>Algorithm Description</strong>:\n+     * <ul><li> For small means, uses simulation of a Poisson process\n+     * using Uniform deviates, as described\n+     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li><\n+     *\n+     * <li> For large means, uses the rejection algorithm described in <br/>\n+     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n+     *\n+     * @return random value\n+     * @since 2.2\n+     * @throws MathException if an error occurs generating the random value\n+     */\n+    @Override\n+    public int sample() throws MathException {\n+        return (int) Math.min(randomData.nextPoisson(mean), Integer.MAX_VALUE);\n+    }\n+\n+    /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root. This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n \n import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.complex.ComplexFormat;\n+import org.apache.commons.math.distribution.ContinuousDistribution;\n import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n         }\n         assertChiSquareAccept(labels, expected, observed, alpha);\n     }\n-\n+    \n+    /**\n+     * Asserts the null hypothesis for a ChiSquare test.  Fails and dumps arguments and test\n+     * statistics if the null hypothesis can be rejected with confidence 100 * (1 - alpha)%\n+     * \n+     * @param expected expected counts\n+     * @param observed observed counts\n+     * @param alpha significance level of the test\n+     */\n+    public static void assertChiSquareAccept(double[] expected, long[] observed, double alpha) throws Exception {\n+        String[] labels = new String[expected.length];\n+        for (int i = 0; i < labels.length; i++) {\n+            labels[i] = Integer.toString(i + 1);\n+        }\n+        assertChiSquareAccept(labels, expected, observed, alpha);\n+    }\n+    \n+    /**\n+     * Computes the 25th, 50th and 75th percentiles of the given distribution and returns\n+     * these values in an array.\n+     */\n+    public static double[] getDistributionQuartiles(ContinuousDistribution distribution) throws Exception {\n+        double[] quantiles = new double[3];\n+        quantiles[0] = distribution.inverseCumulativeProbability(0.25d);\n+        quantiles[1] = distribution.inverseCumulativeProbability(0.5d);\n+        quantiles[2] = distribution.inverseCumulativeProbability(0.75d);\n+        return quantiles;\n+    }\n+    \n+    /**\n+     * Updates observed counts of values in quartiles.\n+     * counts[0] <-> 1st quartile ... counts[3] <-> top quartile\n+     */\n+    public static void updateCounts(double value, long[] counts, double[] quartiles) {\n+        if (value < quartiles[0]) {\n+            counts[0]++;\n+        } else if (value > quartiles[2]) {\n+            counts[3]++;\n+        } else if (value > quartiles[1]) {\n+            counts[2]++;\n+        } else {\n+            counts[1]++;\n+        }  \n+    }\n+    \n+    /**\n+     * Eliminates points with zero mass from densityPoints and densityValues parallel\n+     * arrays.  Returns the number of positive mass points and collapses the arrays so\n+     * that the first <returned value> elements of the input arrays represent the positive\n+     * mass points.\n+     */\n+    public static int eliminateZeroMassPoints(int[] densityPoints, double[] densityValues) {\n+        int positiveMassCount = 0;\n+        for (int i = 0; i < densityValues.length; i++) {\n+            if (densityValues[i] > 0) {\n+                positiveMassCount++;\n+            }\n+        }\n+        if (positiveMassCount < densityValues.length) {\n+            int[] newPoints = new int[positiveMassCount];\n+            double[] newValues = new double[positiveMassCount];\n+            int j = 0;\n+            for (int i = 0; i < densityValues.length; i++) {\n+                if (densityValues[i] > 0) {\n+                    newPoints[j] = densityPoints[i];\n+                    newValues[j] = densityValues[i];\n+                    j++;\n+                }\n+            }\n+            System.arraycopy(newPoints,0,densityPoints,0,positiveMassCount);\n+            System.arraycopy(newValues,0,densityValues,0,positiveMassCount);\n+        }\n+        return positiveMassCount;\n+    } \n }\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n             // expected\n         }\n     }\n+    \n+    /**\n+     * Test sampling\n+     */\n+    public void testSampling() throws Exception {\n+        AbstractContinuousDistribution dist = (AbstractContinuousDistribution) makeDistribution();\n+        final int sampleSize = 1000;\n+        double[] sample = dist.sample(sampleSize);\n+        double[] quartiles = TestUtils.getDistributionQuartiles(dist);\n+        double[] expected = {250, 250, 250, 250};\n+        long[] counts = new long[4];\n+        dist.reseedRandomGenerator(1000);  // Use fixed seed\n+        for (int i = 0; i < sampleSize; i++) {\n+            TestUtils.updateCounts(sample[i], counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n \n     //------------------ Getters / Setters for test instance data -----------\n     /**\n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.TestUtils;\n \n import junit.framework.TestCase;\n \n             // expected\n         }\n     }\n+    \n+    /**\n+     * Test sampling\n+     */\n+    public void testSampling() throws Exception {\n+        int[] densityPoints = makeDensityTestPoints();\n+        double[] densityValues = makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n+        AbstractIntegerDistribution distribution = (AbstractIntegerDistribution) makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        distribution.reseedRandomGenerator(1000); // Use fixed seed\n+        int[] sample = distribution.sample(sampleSize);\n+        for (int i = 0; i < sampleSize; i++) {\n+          for (int j = 0; j < length; j++) {\n+              if (sample[i] == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n \n     //------------------ Getters / Setters for test instance data -----------\n     /**\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n     }\n     \n     public void testNextBeta() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new BetaDistributionImpl(2,5));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistributionImpl(2,5));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextBeta(2, 5);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextCauchy() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextCauchy(1.2, 2.1);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextChiSquare() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new ChiSquaredDistributionImpl(12));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistributionImpl(12));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextChiSquare(12);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextF() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new FDistributionImpl(12, 5));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new FDistributionImpl(12, 5));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextF(12, 5);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextGamma() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextGamma(4, 2);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextT() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new TDistributionImpl(10));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new TDistributionImpl(10));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextT(10);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextWeibull() throws Exception {\n-        double[] quartiles = getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {\n             double value = randomData.nextWeibull(1.2, 2.1);\n-            updateCounts(value, counts, quartiles);\n-        }\n-        TestUtils.assertChiSquareAccept(quartiles, expected, counts, 0.001);\n-    }\n-    \n-    /**\n-     * Computes the 25th, 50th and 75th percentiles of the given distribution and returns\n-     * these values in an array.\n-     */\n-    private double[] getDistributionQuartiles(ContinuousDistribution distribution) throws Exception {\n-        double[] quantiles = new double[3];\n-        quantiles[0] = distribution.inverseCumulativeProbability(0.25d);\n-        quantiles[1] = distribution.inverseCumulativeProbability(0.5d);\n-        quantiles[2] = distribution.inverseCumulativeProbability(0.75d);\n-        return quantiles;\n-    }\n-    \n-    /**\n-     * Updates observed counts of values in quartiles.\n-     * counts[0] <-> 1st quartile ... counts[3] <-> top quartile\n-     */\n-    private void updateCounts(double value, long[] counts, double[] quantiles) {\n-        if (value < quantiles[0]) {\n-            counts[0]++;\n-        } else if (value > quantiles[2]) {\n-            counts[3]++;\n-        } else if (value > quantiles[1]) {\n-            counts[2]++;\n-        } else {\n-            counts[1]++;\n-        }  \n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n     \n     public void testNextBinomial() throws Exception {\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n-        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n         BinomialDistributionImpl distribution = (BinomialDistributionImpl) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n-        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n         HypergeometricDistributionImpl distribution = (HypergeometricDistributionImpl) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n-        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n         PascalDistributionImpl distribution = (PascalDistributionImpl) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         int[] densityPoints = testInstance.makeDensityTestPoints();\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n-        int length = eliminateZeroMassPoints(densityPoints, densityValues);\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n         ZipfDistributionImpl distribution = (ZipfDistributionImpl) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n     \n-    /**\n-     * Eliminates points with zero mass from densityPoints and densityValues parallel\n-     * arrays.  Returns the number of positive mass points and collapses the arrays so\n-     * that the first <returned value> elements of the input arrays represent the positive\n-     * mass points.\n-     */\n-    private int eliminateZeroMassPoints(int[] densityPoints, double[] densityValues) {\n-        int positiveMassCount = 0;\n-        for (int i = 0; i < densityValues.length; i++) {\n-            if (densityValues[i] > 0) {\n-                positiveMassCount++;\n-            }\n-        }\n-        if (positiveMassCount < densityValues.length) {\n-            int[] newPoints = new int[positiveMassCount];\n-            double[] newValues = new double[positiveMassCount];\n-            int j = 0;\n-            for (int i = 0; i < densityValues.length; i++) {\n-                if (densityValues[i] > 0) {\n-                    newPoints[j] = densityPoints[i];\n-                    newValues[j] = densityValues[i];\n-                    j++;\n-                }\n-            }\n-            System.arraycopy(newPoints,0,densityPoints,0,positiveMassCount);\n-            System.arraycopy(newValues,0,densityValues,0,positiveMassCount);\n-        }\n-        return positiveMassCount;\n-    } \n-    \n }", "timestamp": 1275349165, "metainfo": ""}