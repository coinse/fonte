{"sha": "b8a46f6657147be4ddc194c04bcbd5aa00abf23f", "log": "added equals and hash methods for double arrays (supporting null) in MathUtils  ", "commit": "\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     /**\n+     * Returns true iff both arguments aren null or have same dimensions\n+     * and all their elements are {@link #equals(double,double) equals}\n+     * \n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension\n+     * and equal elements\n+     */\n+    public static boolean equals(double[] x, double[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n      * Returns n!. Shorthand for <code>n</code> <a\n      * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n      * product of the numbers <code>1,...,n</code>.\n     public static int hash(double value) {\n         long bits = Double.doubleToLongBits(value);\n         return (int)(bits ^ (bits >>> 32));\n+    }\n+\n+    /**\n+     * Returns an integer hash code representing the given double array value.\n+     * \n+     * @param value the value to be hashed (may be null)\n+     * @return the hash code\n+     */\n+    public static int hash(double[] value) {\n+        if (value == null) {\n+            return 0;\n+        }\n+        int result = value.length;\n+        for (int i = 0; i < value.length; ++i) {\n+            result = result * 31 + hash(value[i]);\n+        }\n+        return result;\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n                 }\n             }\n         }\n+    }\n+\n+    public void testArrayEquals() {\n+        assertFalse(MathUtils.equals(new double[] { 1d }, null));\n+        assertFalse(MathUtils.equals(null, new double[] { 1d }));\n+        assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n+\n+        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n+        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n+        assertTrue(MathUtils.equals(new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }, new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }));\n+        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n+                                     new double[] { Double.NEGATIVE_INFINITY }));\n+        assertFalse(MathUtils.equals(new double[] { 1d },\n+                                     new double[] { MathUtils.nextAfter(1d, 2d) }));\n+\n     }\n \n     public void testFactorial() {\n         }\n     }\n \n+    public void testArrayHash() {\n+        assertEquals(0, MathUtils.hash((double[]) null));\n+        assertEquals(MathUtils.hash(new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }),\n+                     MathUtils.hash(new double[] {\n+                                      Double.NaN, Double.POSITIVE_INFINITY,\n+                                      Double.NEGATIVE_INFINITY, 1d, 0d\n+                                    }));\n+        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n+                    MathUtils.hash(new double[] { MathUtils.nextAfter(1d, 2d) }));\n+        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n+                    MathUtils.hash(new double[] { 1d, 1d }));\n+    }\n+\n     public void testIndicatorByte() {\n         assertEquals((byte)1, MathUtils.indicator((byte)2));\n         assertEquals((byte)1, MathUtils.indicator((byte)0));", "timestamp": 1202469755, "metainfo": ""}