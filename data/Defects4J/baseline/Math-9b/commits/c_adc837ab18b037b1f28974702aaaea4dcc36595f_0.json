{"sha": "adc837ab18b037b1f28974702aaaea4dcc36595f", "log": "Partially fixing MATH-370 (full resolution is delayed to a major release).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n             return false;\n         }\n         AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;\n-        return MathUtils.equals(stat.getResult(), this.getResult()) &&\n-               MathUtils.equals(stat.getN(), this.getN());\n+        return MathUtils.equalsIncludingNaN(stat.getResult(), this.getResult()) &&\n+               MathUtils.equalsIncludingNaN(stat.getN(), this.getN());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n             return false;\n         }\n         MultivariateSummaryStatistics stat = (MultivariateSummaryStatistics) object;\n-        return MathUtils.equals(stat.getGeometricMean(), getGeometricMean()) &&\n-               MathUtils.equals(stat.getMax(),           getMax())           &&\n-               MathUtils.equals(stat.getMean(),          getMean())          &&\n-               MathUtils.equals(stat.getMin(),           getMin())           &&\n-               MathUtils.equals(stat.getN(),             getN())             &&\n-               MathUtils.equals(stat.getSum(),           getSum())           &&\n-               MathUtils.equals(stat.getSumSq(),         getSumSq())         &&\n-               MathUtils.equals(stat.getSumLog(),        getSumLog())        &&\n+        return MathUtils.equalsIncludingNaN(stat.getGeometricMean(), getGeometricMean()) &&\n+               MathUtils.equalsIncludingNaN(stat.getMax(),           getMax())           &&\n+               MathUtils.equalsIncludingNaN(stat.getMean(),          getMean())          &&\n+               MathUtils.equalsIncludingNaN(stat.getMin(),           getMin())           &&\n+               MathUtils.equalsIncludingNaN(stat.getN(),             getN())             &&\n+               MathUtils.equalsIncludingNaN(stat.getSum(),           getSum())           &&\n+               MathUtils.equalsIncludingNaN(stat.getSumSq(),         getSumSq())         &&\n+               MathUtils.equalsIncludingNaN(stat.getSumLog(),        getSumLog())        &&\n                stat.getCovariance().equals( getCovariance());\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n             return false;\n         }\n         StatisticalSummaryValues stat = (StatisticalSummaryValues) object;\n-        return MathUtils.equals(stat.getMax(),      getMax())  &&\n-               MathUtils.equals(stat.getMean(),     getMean()) &&\n-               MathUtils.equals(stat.getMin(),      getMin())  &&\n-               MathUtils.equals(stat.getN(),        getN())    &&\n-               MathUtils.equals(stat.getSum(),      getSum())  &&\n-               MathUtils.equals(stat.getVariance(), getVariance());\n+        return MathUtils.equalsIncludingNaN(stat.getMax(),      getMax())  &&\n+               MathUtils.equalsIncludingNaN(stat.getMean(),     getMean()) &&\n+               MathUtils.equalsIncludingNaN(stat.getMin(),      getMin())  &&\n+               MathUtils.equalsIncludingNaN(stat.getN(),        getN())    &&\n+               MathUtils.equalsIncludingNaN(stat.getSum(),      getSum())  &&\n+               MathUtils.equalsIncludingNaN(stat.getVariance(), getVariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n             return false;\n         }\n         SummaryStatistics stat = (SummaryStatistics)object;\n-        return MathUtils.equals(stat.getGeometricMean(), getGeometricMean()) &&\n-               MathUtils.equals(stat.getMax(),           getMax())           &&\n-               MathUtils.equals(stat.getMean(),          getMean())          &&\n-               MathUtils.equals(stat.getMin(),           getMin())           &&\n-               MathUtils.equals(stat.getN(),             getN())             &&\n-               MathUtils.equals(stat.getSum(),           getSum())           &&\n-               MathUtils.equals(stat.getSumsq(),         getSumsq())         &&\n-               MathUtils.equals(stat.getVariance(),      getVariance());\n+        return MathUtils.equalsIncludingNaN(stat.getGeometricMean(), getGeometricMean()) &&\n+               MathUtils.equalsIncludingNaN(stat.getMax(),           getMax())           &&\n+               MathUtils.equalsIncludingNaN(stat.getMean(),          getMean())          &&\n+               MathUtils.equalsIncludingNaN(stat.getMin(),           getMin())           &&\n+               MathUtils.equalsIncludingNaN(stat.getN(),             getN())             &&\n+               MathUtils.equalsIncludingNaN(stat.getSum(),           getSum())           &&\n+               MathUtils.equalsIncludingNaN(stat.getSumsq(),         getSumsq())         &&\n+               MathUtils.equalsIncludingNaN(stat.getVariance(),      getVariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     /**\n-     * Returns true iff both arguments are NaN or neither is NaN and they are\n-     * equal\n+     * Returns true iff they are equal as defined by\n+     * {@link #equals(double,double,int) this method}.\n      *\n      * @param x first value\n      * @param y second value\n-     * @return true if the values are equal or both are NaN\n+     * @return {@code true} if the values are equal.\n+     * @deprecated This method considers that {@code NaN == NaN}. In release\n+     * 3.0, the semantics will change in order to comply with IEEE754 where it\n+     * is specified that {@code NaN != NaN}.\n+     * New methods have been added for those cases wher the old semantics is\n+     * useful (see e.g. {@link equalsIncludingNaN(double,double)\n+     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n     }\n \n     /**\n-     * Returns true iff both arguments are equal or within the range of allowed\n-     * error (inclusive).\n-     * <p>\n-     * Two NaNs are considered equals, as are two infinities with same sign.\n-     * </p>\n+     * Returns true if both arguments are NaN or neither is NaN and they are\n+     * equal as defined by {@link #equals(double,double) this method}.\n      *\n      * @param x first value\n      * @param y second value\n-     * @param eps the amount of absolute error to allow\n-     * @return true if the values are equal or within range of each other\n+     * @return {@code true} if the values are equal or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(double x, double y) {\n+        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other.\n      */\n     public static boolean equals(double x, double y, double eps) {\n-      return equals(x, y) || (Math.abs(y - x) <= eps);\n-    }\n-\n-    /**\n-     * Returns true iff both arguments are equal or within the range of allowed\n+        return equals(x, y, 1) || Math.abs(y - x) <= eps;\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or are equal or within the range\n+     * of allowed error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other,\n+     * or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(double x, double y, double eps) {\n+        return equalsIncludingNaN(x, y) || (Math.abs(y - x) <= eps);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n      * error (inclusive).\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or less) floating point numbers between them (i.e. two adjacent floating\n+     * point numbers are considered equal.\n      * Adapted from <a\n      * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n      * Bruce Dawson</a>\n      * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n      * values between {@code x} and {@code y}.\n      * @return {@code true} if there are less than {@code maxUlps} floating\n-     * point values between {@code x} and {@code y}\n+     * point values between {@code x} and {@code y}.\n      */\n     public static boolean equals(double x, double y, int maxUlps) {\n-        // Check that \"maxUlps\" is non-negative and small enough so that the\n-        // default NAN won't compare as equal to anything.\n+        // Check that \"maxUlps\" is non-negative and small enough so that\n+        // NaN won't compare as equal to anything (except another NaN).\n         assert maxUlps > 0 && maxUlps < NAN_GAP;\n \n         long xInt = Double.doubleToLongBits(x);\n             yInt = SGN_MASK - yInt;\n         }\n \n-        return Math.abs(xInt - yInt) <= maxUlps;\n-    }\n-\n-    /**\n-     * Returns true iff both arguments are null or have same dimensions\n-     * and all their elements are {@link #equals(double,double) equals}\n+        final boolean isEqual = (Math.abs(xInt - yInt) <= maxUlps);\n+\n+        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or if they are equal as defined\n+     * by {@link #equals(double,double,int) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if both arguments are NaN or if there are less than\n+     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n+        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equals(double,double) this method}.\n      *\n      * @param x first array\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n-     * and equal elements\n-     * @since 1.2\n+     * and equal elements.\n+     * @deprecated This method considers that {@code NaN == NaN}. In release\n+     * 3.0, the semantics will change in order to comply with IEEE754 where it\n+     * is specified that {@code NaN != NaN}.\n+     * New methods have been added for those cases wher the old semantics is\n+     * useful (see e.g. {@link equalsIncludingNaN(double[],double[])\n+     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n         }\n         for (int i = 0; i < x.length; ++i) {\n             if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equalsIncludingNaN(double,double) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension and\n+     * equal elements\n+     */\n+    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equalsIncludingNaN(x[i], y[i])) {\n                 return false;\n             }\n         }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n             dstat.addValue(i);\n         }\n \n-        assertTrue(MathUtils.equals(mean1, dstat.getMean()));\n+        assertTrue(MathUtils.equalsIncludingNaN(mean1, dstat.getMean()));\n         dstat.replaceMostRecentValue(0);\n-        assertTrue(MathUtils.equals(mean2, dstat.getMean()));\n+        assertTrue(MathUtils.equalsIncludingNaN(mean2, dstat.getMean()));\n         dstat.removeMostRecentValue();\n-        assertTrue(MathUtils.equals(mean3, dstat.getMean()));\n+        assertTrue(MathUtils.equalsIncludingNaN(mean3, dstat.getMean()));\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n     }\n \n-    public void testEquals() {\n+    public void testEqualsIncludingNaN() {\n         double[] testArray = {\n             Double.NaN,\n             Double.POSITIVE_INFINITY,\n         for (int i = 0; i < testArray.length; i++) {\n             for (int j = 0; j < testArray.length; j++) {\n                 if (i == j) {\n-                    assertTrue(MathUtils.equals(testArray[i], testArray[j]));\n-                    assertTrue(MathUtils.equals(testArray[j], testArray[i]));\n+                    assertTrue(MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n+                    assertTrue(MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n                 } else {\n-                    assertTrue(!MathUtils.equals(testArray[i], testArray[j]));\n-                    assertTrue(!MathUtils.equals(testArray[j], testArray[i]));\n+                    assertTrue(!MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n+                    assertTrue(!MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n                 }\n             }\n         }\n         assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));\n         assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));\n         assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));\n-        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1.0));\n+        assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1.0));\n         assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n         assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n         assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n         assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));\n     }\n \n+    public void testEqualsIncludingNaNWithAllowedDelta() {\n+        assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0000, .0625));\n+        assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0625));\n+        assertTrue(MathUtils.equalsIncludingNaN(152.9375, 153.0000, .0625));\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n+        assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        assertFalse(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0624));\n+        assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));\n+    }\n+\n     public void testEqualsWithAllowedUlps() {\n-        assertTrue(MathUtils.equals(153, 153, 1));\n-\n-        assertTrue(MathUtils.equals(153, 153.00000000000003, 1));\n-        assertFalse(MathUtils.equals(153, 153.00000000000006, 1));\n-        assertTrue(MathUtils.equals(153, 152.99999999999997, 1));\n+        assertTrue(MathUtils.equals(0.0, -0.0, 1));\n+\n+        assertTrue(MathUtils.equals(1.0, 1 + Math.ulp(1d), 1));\n+        assertFalse(MathUtils.equals(1.0, 1 + 2 * Math.ulp(1d), 1));\n+\n+        final double nUp1 = Math.nextUp(1d);\n+        final double nnUp1 = Math.nextUp(nUp1);\n+        assertTrue(MathUtils.equals(1.0, nUp1, 1));\n+        assertTrue(MathUtils.equals(nUp1, nnUp1, 1));\n+        assertFalse(MathUtils.equals(1.0, nnUp1, 1));\n+\n+        assertTrue(MathUtils.equals(0.0, Math.ulp(0d), 1));\n+        assertTrue(MathUtils.equals(0.0, -Math.ulp(0d), 1));\n+\n+        assertTrue(MathUtils.equals(153.0, 153.0, 1));\n+\n+        assertTrue(MathUtils.equals(153.0, 153.00000000000003, 1));\n+        assertFalse(MathUtils.equals(153.0, 153.00000000000006, 1));\n+        assertTrue(MathUtils.equals(153.0, 152.99999999999997, 1));\n         assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n \n-        assertTrue(MathUtils.equals(-128, -127.99999999999999, 1));\n-        assertFalse(MathUtils.equals(-128, -127.99999999999997, 1));\n-        assertTrue(MathUtils.equals(-128, -128.00000000000003, 1));\n-        assertFalse(MathUtils.equals(-128, -128.00000000000006, 1));\n+        assertTrue(MathUtils.equals(-128.0, -127.99999999999999, 1));\n+        assertFalse(MathUtils.equals(-128.0, -127.99999999999997, 1));\n+        assertTrue(MathUtils.equals(-128.0, -128.00000000000003, 1));\n+        assertFalse(MathUtils.equals(-128.0, -128.00000000000006, 1));\n \n         assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n         assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n         assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n         assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n \n-\n-        assertTrue(MathUtils.equals(Double.NaN, Double.NaN, 1));\n+        assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1));\n \n         assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n     }\n \n+    public void testEqualsIncludingNaNWithAllowedUlps() {\n+        assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + Math.ulp(1d), 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * Math.ulp(1d), 1));\n+\n+        final double nUp1 = Math.nextUp(1d);\n+        final double nnUp1 = Math.nextUp(nUp1);\n+        assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(0.0, Math.ulp(0d), 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(0.0, -Math.ulp(0d), 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.00000000000003, 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(153.0, 153.00000000000006, 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(153.0, 152.99999999999997, 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(153, 152.99999999999994, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999999, 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999997, 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000003, 1));\n+        assertFalse(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000006, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        assertTrue(MathUtils.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+        assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1));\n+\n+        assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    /**\n+     * @deprecated To be removed in release 3.0 (replaced by {@link\n+     * #testArrayEqualsIncludingNaN()}.\n+     */\n     public void testArrayEquals() {\n         assertFalse(MathUtils.equals(new double[] { 1d }, null));\n         assertFalse(MathUtils.equals(null, new double[] { 1d }));\n         assertFalse(MathUtils.equals(new double[] { 1d },\n                                      new double[] { MathUtils.nextAfter(1d, 2d) }));\n \n+    }\n+\n+    public void testArrayEqualsIncludingNaN() {\n+        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, null));\n+        assertFalse(MathUtils.equalsIncludingNaN(null, new double[] { 1d }));\n+        assertTrue(MathUtils.equalsIncludingNaN((double[]) null, (double[]) null));\n+\n+        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[0]));\n+        assertTrue(MathUtils.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d }));\n+        assertTrue(MathUtils.equalsIncludingNaN(new double[] {\n+                    Double.NaN, Double.POSITIVE_INFINITY,\n+                    Double.NEGATIVE_INFINITY, 1d, 0d\n+                }, new double[] {\n+                    Double.NaN, Double.POSITIVE_INFINITY,\n+                    Double.NEGATIVE_INFINITY, 1d, 0d\n+                }));\n+        assertFalse(MathUtils.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY },\n+                                                 new double[] { Double.NEGATIVE_INFINITY }));\n+        assertFalse(MathUtils.equalsIncludingNaN(new double[] { 1d },\n+                                                 new double[] { MathUtils.nextAfter(MathUtils.nextAfter(1d, 2d), 2d) }));\n     }\n \n     public void testFactorial() {", "timestamp": 1276080086, "metainfo": ""}