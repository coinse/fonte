{"sha": "2052f37c16df13b85c7f2b807e3074a95149abd0", "log": "Merged NormalDistribution and NormalDistributionImpl (MATH-711). Merged PascalDistribution and PascalDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n \n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Erf;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * Normal (Gauss) Distribution.\n+ * Implementation of the normal (gaussian) distribution.\n  *\n- * <p>\n- * References:</p><p>\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">\n- * Normal Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Normal_distribution\">Normal distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">Normal distribution (MathWorld)</a>\n  * @version $Id$\n  */\n-public interface NormalDistribution extends ContinuousDistribution {\n+public class NormalDistribution extends AbstractContinuousDistribution\n+        implements Serializable {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+    /** &radic;(2 &pi;) */\n+    private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n+    /** &radic;(2) */\n+    private static final double SQRT2 = FastMath.sqrt(2.0);\n+    /** Mean of this distribution. */\n+    private final double mean;\n+    /** Standard deviation of this distribution. */\n+    private final double standardDeviation;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a normal distribution using the given mean and standard deviation.\n+     *\n+     * @param mean Mean for this distribution.\n+     * @param sd Standard deviation for this distribution.\n+     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n+     */\n+    public NormalDistribution(double mean, double sd)\n+        throws NotStrictlyPositiveException {\n+        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a normal distribution using the given mean, standard deviation and\n+     * inverse cumulative distribution accuracy.\n+     *\n+     * @param mean Mean for this distribution.\n+     * @param sd Standard deviation for this distribution.\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code sd <= 0}.\n+     * @since 2.1\n+     */\n+    public NormalDistribution(double mean, double sd, double inverseCumAccuracy) {\n+        if (sd <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n+        }\n+\n+        this.mean = mean;\n+        standardDeviation = sd;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Create a normal distribution with mean equal to zero and standard\n+     * deviation equal to one.\n+     */\n+    public NormalDistribution(){\n+        this(0, 1);\n+    }\n+\n     /**\n      * Access the mean.\n      *\n      * @return the mean for this distribution.\n      */\n-    double getMean();\n+    public double getMean() {\n+        return mean;\n+    }\n \n     /**\n      * Access the standard deviation.\n      *\n      * @return the standard deviation for this distribution.\n      */\n-    double getStandardDeviation();\n+    public double getStandardDeviation() {\n+        return standardDeviation;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        final double x0 = x - mean;\n+        final double x1 = x0 / standardDeviation;\n+        return FastMath.exp(-0.5 * x1 * x1) / (standardDeviation * SQRT2PI);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * If {@code x} is more than 40 standard deviations from the mean, 0 or 1\n+     * is returned, as in these cases the actual value is within\n+     * {@code Double.MIN_VALUE} of 0 or 1.\n+     */\n+    public double cumulativeProbability(double x)  {\n+        final double dev = x - mean;\n+        if (FastMath.abs(dev) > 40 * standardDeviation) {\n+            return dev < 0 ? 0.0d : 1.0d;\n+        }\n+        return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(double x0, double x1)\n+        throws NumberIsTooLargeException {\n+        if (x0 > x1) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                                                x0, x1, true);\n+        }\n+        final double denom = standardDeviation * SQRT2;\n+        final double v0 = (x0 - mean) / denom;\n+        final double v1 = (x1 - mean) / denom;\n+        return 0.5 * Erf.erf(v0, v1);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code Double.NEGATIVE_INFINITY} when {@code p == 0}\n+     * and {@code Double.POSITIVE_INFINITY} for {@code p == 1}.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) {\n+        if (p == 0) {\n+            return Double.NEGATIVE_INFINITY;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double sample()  {\n+        return randomData.nextGaussian(mean, standardDeviation);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        double ret;\n+\n+        if (p < 0.5) {\n+            ret = -Double.MAX_VALUE;\n+        } else {\n+            ret = mean;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        double ret;\n+\n+        if (p < 0.5) {\n+            ret = mean;\n+        } else {\n+            ret = Double.MAX_VALUE;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        double ret;\n+\n+        if (p < 0.5) {\n+            ret = mean - standardDeviation;\n+        } else if (p > 0.5) {\n+            ret = mean + standardDeviation;\n+        } else {\n+            ret = mean;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always negative infinity\n+     * no matter the parameters.\n+     *\n+     * @return lower bound of the support (always\n+     * {@code Double.NEGATIVE_INFINITY})\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For mean parameter {@code mu}, the mean is {@code mu}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For standard deviation parameter {@code s}, the variance is {@code s^2}.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double s = getStandardDeviation();\n+        return s * s;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.ArithmeticUtils;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * The Pascal distribution.  The Pascal distribution is a special case of the\n- * Negative Binomial distribution where the number of successes parameter is an\n- * integer.\n- *\n+ * <p>\n+ * Implementation of the Pascal distribution. The Pascal distribution is a\n+ * special case of the Negative Binomial distribution where the number of\n+ * successes parameter is an integer.\n+ * </p>\n+ * <p>\n  * There are various ways to express the probability mass and distribution\n  * functions for the Pascal distribution.  The convention employed by the\n  * library is to express these functions in terms of the number of failures in\n- * a Bernoulli experiment [2].\n- *\n- * <p>\n- * References:\n- * <ol>\n- * <li><a href=\"http://mathworld.wolfram.com/NegativeBinomialDistribution.html\">\n- * Negative Binomial Distribution</a></li>\n- * <oi><a href=\"http://en.wikipedia.org/wiki/Negative_binomial_distribution#Waiting_time_in_a_Bernoulli_process\">Waiting Time in a Bernoulli Process</a></li>\n- * </ul>\n+ * a Bernoulli experiment\n+ * (see <a href=\"http://en.wikipedia.org/wiki/Negative_binomial_distribution#Waiting_time_in_a_Bernoulli_process\">Waiting Time in a Bernoulli Process</a>).\n  * </p>\n  *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Negative_binomial_distribution\">\n+ * Negative binomial distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/NegativeBinomialDistribution.html\">\n+ * Negative binomial distribution (MathWorld)</a>\n  * @version $Id$\n- * @since 1.2\n+ * @since 1.2 (changed to concrete class in 3.0)\n  */\n-public interface PascalDistribution extends IntegerDistribution {\n+public class PascalDistribution extends AbstractIntegerDistribution\n+    implements Serializable {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6751309484392813623L;\n+    /** The number of successes. */\n+    private final int numberOfSuccesses;\n+    /** The probability of success. */\n+    private final double probabilityOfSuccess;\n+\n+    /**\n+     * Create a Pascal distribution with the given number of trials and\n+     * probability of success.\n+     *\n+     * @param r Number of successes.\n+     * @param p Probability of success.\n+     * @throws NotPositiveException if the number of successes is not positive\n+     * @throws OutOfRangeException if the probability of success is not in the\n+     * range [0, 1]\n+     */\n+    public PascalDistribution(int r, double p)\n+        throws NotPositiveException, OutOfRangeException {\n+        if (r < 0) {\n+            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n+                                           r);\n+        }\n+        if (p < 0 || p > 1) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        numberOfSuccesses = r;\n+        probabilityOfSuccess = p;\n+    }\n+\n     /**\n      * Access the number of successes for this distribution.\n      *\n      * @return the number of successes.\n      */\n-    int getNumberOfSuccesses();\n+    public int getNumberOfSuccesses() {\n+        return numberOfSuccesses;\n+    }\n \n     /**\n      * Access the probability of success for this distribution.\n      *\n      * @return the probability of success.\n      */\n-    double getProbabilityOfSuccess();\n+    public double getProbabilityOfSuccess() {\n+        return probabilityOfSuccess;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return -1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        // use MAX - 1 because MAX causes loop\n+        return Integer.MAX_VALUE - 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(int x) {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = Beta.regularizedBeta(probabilityOfSuccess,\n+                numberOfSuccesses, x + 1);\n+        }\n+        return ret;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double probability(int x) {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = ArithmeticUtils.binomialCoefficientDouble(x +\n+                  numberOfSuccesses - 1, numberOfSuccesses - 1) *\n+                  FastMath.pow(probabilityOfSuccess, numberOfSuccesses) *\n+                  FastMath.pow(1.0 - probabilityOfSuccess, x);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns {@code -1} when {@code p == 0} and\n+     * {@code Integer.MAX_VALUE} when {@code p == 1}.\n+     */\n+    @Override\n+    public int inverseCumulativeProbability(final double p) {\n+        int ret;\n+\n+        // handle extreme values explicitly\n+        if (p == 0) {\n+            ret = -1;\n+        } else if (p == 1) {\n+            ret = Integer.MAX_VALUE;\n+        } else {\n+            ret = super.inverseCumulativeProbability(p);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public int getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity no matter the\n+     * parameters. Positive infinity is symbolised by {@code Integer.MAX_VALUE}\n+     * together with {@link #isSupportUpperBoundInclusive()} being\n+     * {@code false}.\n+     *\n+     * @return upper bound of the support (always {@code Integer.MAX_VALUE}\n+     * for positive infinity)\n+     */\n+    @Override\n+    public int getSupportUpperBound() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For number of successes {@code r} and probability of success {@code p},\n+     * the mean is {@code (r * p) / (1 - p)}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double p = getProbabilityOfSuccess();\n+        final double r = getNumberOfSuccesses();\n+        return (r * p) / (1 - p);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For number of successes {@code r} and probability of success {@code p},\n+     * the mean is {@code (r * p) / (1 - p)^2}.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double p = getProbabilityOfSuccess();\n+        final double r = getNumberOfSuccesses();\n+        final double pInv = 1 - p;\n+        return (r * p) / (pInv * pInv);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Always returns {@code false}.\n+     *\n+     * @see {@link PascalDistribution#getSupportUpperBound() getSupportUpperBound()}\n+     */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n         mean = p;\n-        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n+        normal = new NormalDistribution(p, FastMath.sqrt(p));\n         this.epsilon = epsilon;\n         this.maxIterations = maxIterations;\n     }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.FDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistribution;\n import org.apache.commons.math.distribution.IntegerDistribution;\n-import org.apache.commons.math.distribution.PascalDistributionImpl;\n+import org.apache.commons.math.distribution.PascalDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.distribution.WeibullDistributionImpl;\n import org.apache.commons.math.distribution.ZipfDistributionImpl;\n     }\n \n     /**\n-     * Generates a random value from the {@link PascalDistributionImpl Pascal Distribution}.\n+     * Generates a random value from the {@link PascalDistribution Pascal Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public int nextPascal(int r, double p) {\n-        return nextInversionDeviate(new PascalDistributionImpl(r, p));\n+        return nextInversionDeviate(new PascalDistribution(r, p));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/MannWhitneyUTestImpl.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.distribution.NormalDistributionImpl;\n+import org.apache.commons.math.distribution.NormalDistribution;\n import org.apache.commons.math.stat.ranking.NaNStrategy;\n import org.apache.commons.math.stat.ranking.NaturalRanking;\n import org.apache.commons.math.stat.ranking.TiesStrategy;\n \n         final double z = (Umin - EU) / FastMath.sqrt(VarU);\n \n-        final NormalDistributionImpl standardNormal = new NormalDistributionImpl(\n+        final NormalDistribution standardNormal = new NormalDistribution(\n                 0, 1);\n \n         return 2 * standardNormal.cumulativeProbability(z);\n--- a/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/WilcoxonSignedRankTestImpl.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.distribution.NormalDistributionImpl;\n+import org.apache.commons.math.distribution.NormalDistribution;\n import org.apache.commons.math.stat.ranking.NaNStrategy;\n import org.apache.commons.math.stat.ranking.NaturalRanking;\n import org.apache.commons.math.stat.ranking.TiesStrategy;\n         // - 0.5 is a continuity correction\n         final double z = (Wmin - ES - 0.5) / FastMath.sqrt(VarS);\n \n-        final NormalDistributionImpl standardNormal = new NormalDistributionImpl(0, 1);\n+        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n \n         return 2*standardNormal.cumulativeProbability(z);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n \n     // --------------------- Override tolerance  --------------\n-    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n+    protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n     public void setUp() throws Exception {\n         super.setUp();\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public NormalDistribution makeDistribution() {\n-        return new NormalDistributionImpl(2.1, 1.4);\n+        return new NormalDistribution(2.1, 1.4);\n     }\n \n     /** Creates the default cumulative probability distribution test input values */\n     }\n \n     // --------------------- Override tolerance  --------------\n-    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n+    protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n     public void setUp() throws Exception {\n         super.setUp();\n         verifyQuantiles();\n         verifyDensities();\n \n-        setDistribution(new NormalDistributionImpl(0, 1));\n+        setDistribution(new NormalDistribution(0, 1));\n         setDensityTestValues(new double[] {0.0539909665132, 0.241970724519, 0.398942280401, 0.241970724519, 0.0539909665132,\n                 0.00443184841194, 0.000133830225765, 1.48671951473e-06});\n         verifyQuantiles();\n         verifyDensities();\n \n-        setDistribution(new NormalDistributionImpl(0, 0.1));\n+        setDistribution(new NormalDistribution(0, 0.1));\n         setDensityTestValues(new double[] {0.539909665132, 2.41970724519, 3.98942280401, 2.41970724519,\n                 0.539909665132, 0.0443184841194, 0.00133830225765, 1.48671951473e-05});\n         verifyQuantiles();\n \n     @Test(expected=NotStrictlyPositiveException.class)\n     public void testPreconditions() {\n-        new NormalDistributionImpl(1, 0);\n+        new NormalDistribution(1, 0);\n     }\n \n     @Test\n     }\n \n     private void checkDensity(double mean, double sd, double[] x, double[] expected) {\n-        NormalDistribution d = new NormalDistributionImpl(mean, sd);\n+        NormalDistribution d = new NormalDistribution(mean, sd);\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);\n         }\n      */\n     @Test\n     public void testExtremeValues() throws Exception {\n-        NormalDistribution distribution = new NormalDistributionImpl(0, 1);\n+        NormalDistribution distribution = new NormalDistribution(0, 1);\n         for (int i = 0; i < 100; i++) { // make sure no convergence exception\n             double lowerTail = distribution.cumulativeProbability(-i);\n             double upperTail = distribution.cumulativeProbability(i);\n-            if (i < 9) { // make sure not top-coded \n+            if (i < 9) { // make sure not top-coded\n                 // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned\n                 // TODO: once MATH-364 is resolved, replace 9 with 30\n                 Assert.assertTrue(lowerTail > 0.0d);\n                 Assert.assertTrue(upperTail > 0.99999);\n             }\n         }\n-        \n+\n         Assert.assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n         Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n         Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n         Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n-        \n+\n    }\n \n     @Test\n     public void testMath280() {\n-        NormalDistribution normal = new NormalDistributionImpl(0,1);\n+        NormalDistribution normal = new NormalDistribution(0,1);\n         double result = normal.inverseCumulativeProbability(0.9986501019683698);\n         Assert.assertEquals(3.0, result, defaultTolerance);\n         result = normal.inverseCumulativeProbability(0.841344746068543);\n     public void testMoments() {\n         final double tol = 1e-9;\n         NormalDistribution dist;\n-        \n-        dist = new NormalDistributionImpl(0, 1);        \n+\n+        dist = new NormalDistribution(0, 1);\n         Assert.assertEquals(dist.getNumericalMean(), 0, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 1, tol);        \n- \n-        dist = new NormalDistributionImpl(2.2, 1.4);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1, tol);\n+\n+        dist = new NormalDistribution(2.2, 1.4);\n         Assert.assertEquals(dist.getNumericalMean(), 2.2, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol);\n-        \n-        dist = new NormalDistributionImpl(-2000.9, 10.4);\n+\n+        dist = new NormalDistribution(-2000.9, 10.4);\n         Assert.assertEquals(dist.getNumericalMean(), -2000.9, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n public class PascalDistributionTest extends IntegerDistributionAbstractTest {\n \n     // --------------------- Override tolerance  --------------\n-    protected double defaultTolerance = NormalDistributionImpl.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n+    protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY;\n     @Override\n     public void setUp() {\n         super.setUp();\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new PascalDistributionImpl(10,0.70);\n+        return new PascalDistribution(10,0.70);\n     }\n \n     /** Creates the default probability density test input values */\n     /** Test degenerate case p = 0   */\n     @Test\n     public void testDegenerate0() throws Exception {\n-        setDistribution(new PascalDistributionImpl(5,0.0d));\n+        setDistribution(new PascalDistribution(5,0.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });\n         setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});\n     /** Test degenerate case p = 1   */\n     @Test\n     public void testDegenerate1() throws Exception {\n-        setDistribution(new PascalDistributionImpl(5,1.0d));\n+        setDistribution(new PascalDistribution(5,1.0d));\n         setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });\n         setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});\n         setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});\n     public void testMoments() {\n         final double tol = 1e-9;\n         PascalDistribution dist;\n-        \n-        dist = new PascalDistributionImpl(10, 0.5);\n+\n+        dist = new PascalDistribution(10, 0.5);\n         Assert.assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol); \n-        \n-        dist = new PascalDistributionImpl(25, 0.3);\n+        Assert.assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol);\n+\n+        dist = new PascalDistribution(25, 0.3);\n         Assert.assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol);\n         Assert.assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol);\n     }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.GammaDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistribution;\n import org.apache.commons.math.distribution.HypergeometricDistributionTest;\n-import org.apache.commons.math.distribution.PascalDistributionImpl;\n+import org.apache.commons.math.distribution.PascalDistribution;\n import org.apache.commons.math.distribution.PascalDistributionTest;\n import org.apache.commons.math.distribution.PoissonDistribution;\n import org.apache.commons.math.distribution.PoissonDistributionImpl;\n         double[] densityValues = testInstance.makeDensityTestValues();\n         int sampleSize = 1000;\n         int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n-        PascalDistributionImpl distribution = (PascalDistributionImpl) testInstance.makeDistribution();\n+        PascalDistribution distribution = (PascalDistribution) testInstance.makeDistribution();\n         double[] expectedCounts = new double[length];\n         long[] observedCounts = new long[length];\n         for (int i = 0; i < length; i++) {", "timestamp": 1322302669, "metainfo": ""}