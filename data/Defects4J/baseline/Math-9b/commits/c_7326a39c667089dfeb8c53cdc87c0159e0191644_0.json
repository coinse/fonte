{"sha": "7326a39c667089dfeb8c53cdc87c0159e0191644", "log": "Fixed initialization of multistep ODE integrators. Relying on the interpolation model of the starter integrator inside only one step was wrong. The model may have a too low order to compute high degrees derivatives in the Nordsieck vector. Now we use several steps and use only grid points instead of interpolated points.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     DIMENSION(\"dimension ({0})\"), /* keep */\n     INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE(\"sample contains {0} observed points, at least {1} are required\"),\n     INSUFFICIENT_ROWS_AND_COLUMNS(\"insufficient data: only {0} rows and {1} columns.\"),\n-    INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT(\"{0} method needs at least one previous point\"),\n+    INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS(\"{0} method needs at least two previous points\"),\n     INTERNAL_ERROR(\"internal error, please fill a bug report at {0}\"),\n     INVALID_BRACKETING_PARAMETERS(\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\"),\n     INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS(\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\"),\n--- a/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n  * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n  * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n  * ...\n- * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative\n  * </pre></p>\n  * <p>Rather than storing several previous steps separately, this implementation uses\n  * the Nordsieck vector with higher degrees scaled derivatives all taken at the same\n  * (we omit the k index in the notation for clarity)</p>\n  * <p>\n  * Multistep integrators with Nordsieck representation are highly sensitive to\n- * large step changes because when the step is multiplied by a factor a, the\n+ * large step changes because when the step is multiplied by factor a, the\n  * k<sup>th</sup> component of the Nordsieck vector is multiplied by a<sup>k</sup>\n  * and the last components are the least accurate ones. The default max growth\n  * factor is therefore set to a quite low value: 2<sup>1/order</sup>.\n     protected double[] scaled;\n \n     /** Nordsieck matrix of the higher scaled derivatives.\n-     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y(k))</p>\n+     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y<sup>(k)</sup>)</p>\n      */\n     protected Array2DRowRealMatrix nordsieck;\n \n \n         super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n \n-        if (nSteps <= 0) {\n+        if (nSteps <= 1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT,\n+                  LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS,\n                   name);\n         }\n \n         starter.clearStepHandlers();\n \n         // set up one specific step handler to extract initial Nordsieck vector\n-        starter.addStepHandler(new NordsieckInitializer(y0.length));\n+        starter.addStepHandler(new NordsieckInitializer(nSteps, y0.length));\n \n         // start integration, expecting a InitializationCompletedMarkerException\n         try {\n             starter.integrate(new CountingDifferentialEquations(y0.length),\n                               t0, y0, t, new double[y0.length]);\n-        } catch (MathUserException mue) {\n-            if (!(mue instanceof InitializationCompletedMarkerException)) {\n-                // this is not the expected nominal interruption of the start integrator\n-                throw mue;\n-            }\n+        } catch (InitializationCompletedMarkerException icme) {\n+            // this is the expected nominal interruption of the start integrator\n         }\n \n         // remove the specific step handler\n     }\n \n     /** Initialize the high order scaled derivatives at step start.\n-     * @param first first scaled derivative at step start\n-     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n-     * will be modified\n-     * @return high order scaled derivatives at step start\n-     */\n-    protected abstract Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n-                                                                           final double[][] multistep);\n+     * @param h step size to use for scaling\n+     * @param t first steps times\n+     * @param y first steps states\n+     * @param yDot first steps derivatives\n+     * @return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,\n+     * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)\n+     */\n+    protected abstract Array2DRowRealMatrix initializeHighOrderDerivatives(final double h, final double[] t,\n+                                                                           final double[][] y,\n+                                                                           final double[][] yDot);\n \n     /** Get the minimal reduction factor for stepsize control.\n      * @return minimal reduction factor\n     /** Transformer used to convert the first step to Nordsieck representation. */\n     public static interface NordsieckTransformer {\n         /** Initialize the high order scaled derivatives at step start.\n-         * @param first first scaled derivative at step start\n-         * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n-         * will be modified\n-         * @return high order derivatives at step start\n+         * @param h step size to use for scaling\n+         * @param t first steps times\n+         * @param y first steps states\n+         * @param yDot first steps derivatives\n+         * @return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>,\n+         * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)\n          */\n-        RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\n+        Array2DRowRealMatrix initializeHighOrderDerivatives(final double h, final double[] t,\n+                                                            final double[][] y,\n+                                                            final double[][] yDot);\n     }\n \n     /** Specialized step handler storing the first step. */\n     private class NordsieckInitializer implements StepHandler {\n \n-        /** Problem dimension. */\n-        private final int n;\n+        /** Steps counter. */\n+        int count;\n+\n+        /** First steps times. */\n+        final double[] t;\n+\n+        /** First steps states. */\n+        final double[][] y;\n+\n+        /** First steps derivatives. */\n+        final double[][] yDot;\n \n         /** Simple constructor.\n+         * @param nSteps number of steps of the multistep method (excluding the one being computed)\n          * @param n problem dimension\n          */\n-        public NordsieckInitializer(final int n) {\n-            this.n = n;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void handleStep(StepInterpolator interpolator, boolean isLast)\n-            throws MathUserException {\n+        public NordsieckInitializer(final int nSteps, final int n) {\n+            this.count = 0;\n+            this.t     = new double[nSteps];\n+            this.y     = new double[nSteps][n];\n+            this.yDot  = new double[nSteps][n];\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n \n             final double prev = interpolator.getPreviousTime();\n             final double curr = interpolator.getCurrentTime();\n-            stepStart = prev;\n-            stepSize  = (curr - prev) / (nSteps + 1);\n-\n-            // compute the first scaled derivative\n-            interpolator.setInterpolatedTime(prev);\n-            scaled = interpolator.getInterpolatedDerivatives().clone();\n-            for (int j = 0; j < n; ++j) {\n-                scaled[j] *= stepSize;\n+\n+            if (count == 0) {\n+                // first step, we need to store also the beginning of the step\n+                interpolator.setInterpolatedTime(prev);\n+                t[0] = prev;\n+                System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                                 y[0],    0, y[0].length);\n+                System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n+                                 yDot[0], 0, yDot[0].length);\n             }\n \n-            // compute the high order scaled derivatives\n-            final double[][] multistep = new double[nSteps][];\n-            for (int i = 1; i <= nSteps; ++i) {\n-                interpolator.setInterpolatedTime(prev + stepSize * i);\n-                final double[] msI = interpolator.getInterpolatedDerivatives().clone();\n-                for (int j = 0; j < n; ++j) {\n-                    msI[j] *= stepSize;\n+            // store the end of the step\n+            ++count;\n+            interpolator.setInterpolatedTime(curr);\n+            t[count] = curr;\n+            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                             y[count],    0, y[count].length);\n+            System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n+                             yDot[count], 0, yDot[count].length);\n+\n+            if (count == t.length - 1) {\n+\n+                // this was the last step we needed, we can compute the derivatives\n+                stepStart = t[0];\n+                stepSize  = (t[t.length - 1] - t[0]) / (t.length - 1);\n+\n+                // first scaled derivative\n+                scaled = yDot[0].clone();\n+                for (int j = 0; j < scaled.length; ++j) {\n+                    scaled[j] *= stepSize;\n                 }\n-                multistep[i - 1] = msI;\n+\n+                // higher order derivatives\n+                nordsieck = initializeHighOrderDerivatives(stepSize, t, y, yDot);\n+\n+                // stop the integrator now that all needed steps have been handled\n+                throw new InitializationCompletedMarkerException();\n+\n             }\n-            nordsieck = initializeHighOrderDerivatives(scaled, multistep);\n-\n-            // stop the integrator after the first step has been handled\n-            throw new InitializationCompletedMarkerException();\n \n         }\n \n \n     /** Marker exception used ONLY to stop the starter integrator after first step. */\n     private static class InitializationCompletedMarkerException\n-        extends MathUserException {\n+        extends MathRuntimeException {\n \n         /** Serializable version identifier. */\n-        private static final long serialVersionUID = -4105805787353488365L;\n+        private static final long serialVersionUID = -1914085471038046418L;\n \n         /** Simple constructor. */\n         public InitializationCompletedMarkerException() {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n  * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n  * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n  * ...\n- * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative\n  * </pre></p>\n  *\n  * <p>The definitions above use the classical representation with several previous first\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n     private final AdamsNordsieckTransformer transformer;\n \n     /**\n-     * Build an Adams integrator with the given order and step control prameters.\n+     * Build an Adams integrator with the given order and step control parameters.\n      * @param name name of the method\n      * @param nSteps number of steps of the method excluding the one being computed\n      * @param order order of the method\n \n     /** {@inheritDoc} */\n     @Override\n-    protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n-                                                        final double[][] multistep) {\n-        return transformer.initializeHighOrderDerivatives(first, multistep);\n+    protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double h, final double[] t,\n+                                                                  final double[][] y,\n+                                                                  final double[][] yDot) {\n+        return transformer.initializeHighOrderDerivatives(h, t, y, yDot);\n     }\n \n     /** Update the high order scaled derivatives for Adams integrators (phase 1).\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n  * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n  * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n  * ...\n- * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative\n  * </pre></p>\n  *\n  * <p>The definitions above use the classical representation with several previous first\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n import org.apache.commons.math.fraction.BigFraction;\n import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor;\n import org.apache.commons.math.linear.FieldDecompositionSolver;\n import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n import org.apache.commons.math.linear.FieldMatrix;\n import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.QRDecomposition;\n+import org.apache.commons.math.linear.QRDecompositionImpl;\n \n /** Transformer to Nordsieck vectors for Adams integrators.\n- * <p>This class i used by {@link AdamsBashforthIntegrator Adams-Bashforth} and\n+ * <p>This class is used by {@link AdamsBashforthIntegrator Adams-Bashforth} and\n  * {@link AdamsMoultonIntegrator Adams-Moulton} integrators to convert between\n  * classical representation with several previous first derivatives and Nordsieck\n  * representation with higher order scaled derivatives.</p>\n  * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n  * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n  * ...\n- * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative\n  * </pre></p>\n  *\n  * <p>With the previous definition, the classical representation of multistep methods\n     private static final Map<Integer, AdamsNordsieckTransformer> CACHE =\n         new HashMap<Integer, AdamsNordsieckTransformer>();\n \n-    /** Initialization matrix for the higher order derivatives wrt y'', y''' ... */\n-    private final Array2DRowRealMatrix initialization;\n-\n     /** Update matrix for the higher order derivatives h<sup>2</sup>/2y'', h<sup>3</sup>/6 y''' ... */\n     private final Array2DRowRealMatrix update;\n \n         FieldMatrix<BigFraction> bigMSupdate =\n             pSolver.solve(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n \n-        // initialization coefficients, computed from a R matrix = abs(P)\n-        bigP.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<BigFraction>(BigFraction.ZERO) {\n-            /** {@inheritDoc} */\n-            @Override\n-            public BigFraction visit(int row, int column, BigFraction value) {\n-                return ((column & 0x1) == 0x1) ? value : value.negate();\n-            }\n-        });\n-        FieldMatrix<BigFraction> bigRInverse =\n-            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver().getInverse();\n-\n         // convert coefficients to double\n-        initialization = MatrixUtils.bigFractionMatrixToRealMatrix(bigRInverse);\n         update         = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n         c1             = new double[nSteps];\n         for (int i = 0; i < nSteps; ++i) {\n \n     }\n \n-    /** Initialize the high order scaled derivatives at step start.\n-     * @param first first scaled derivative at step start\n-     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n-     * will be modified\n-     * @return high order derivatives at step start\n-     */\n-    public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n-                                                     final double[][] multistep) {\n-        for (int i = 0; i < multistep.length; ++i) {\n-            final double[] msI = multistep[i];\n-            for (int j = 0; j < first.length; ++j) {\n-                msI[j] -= first[j];\n-            }\n-        }\n-        return initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n+    /** {@inheritDoc} */\n+    public Array2DRowRealMatrix initializeHighOrderDerivatives(final double h, final double[] t,\n+                                                               final double[][] y,\n+                                                               final double[][] yDot) {\n+\n+        // using Taylor series with di = ti - t0, we get:\n+        //  y(ti)  - y(t0)  - di y'(t0) =   di^2 / h^2 s2 + ... +   di^k     / h^k sk + O(h^(k+1))\n+        //  y'(ti) - y'(t0)             = 2 di   / h^2 s2 + ... + k di^(k-1) / h^k sk + O(h^k)\n+        // we write these relations for i = 1 to i= n-1 as a set of 2(n-1) linear\n+        // equations depending on the Nordsieck vector [s2 ... sk]\n+        final double[][] a     = new double[2 * (y.length - 1)][c1.length];\n+        final double[][] b     = new double[2 * (y.length - 1)][y[0].length];\n+        final double[]   y0    = y[0];\n+        final double[]   yDot0 = yDot[0];\n+        for (int i = 1; i < y.length; ++i) {\n+\n+            final double di    = t[i] - t[0];\n+            final double ratio = di / h;\n+            double dikM1Ohk    =  1 / h;\n+\n+            // linear coefficients of equations\n+            // y(ti) - y(t0) - di y'(t0) and y'(ti) - y'(t0)\n+            final double[] aI    = a[2 * i - 2];\n+            final double[] aDotI = a[2 * i - 1];\n+            for (int j = 0; j < aI.length; ++j) {\n+                dikM1Ohk *= ratio;\n+                aI[j]     = di      * dikM1Ohk;\n+                aDotI[j]  = (j + 2) * dikM1Ohk;\n+            }\n+\n+            // expected value of the previous equations\n+            final double[] yI    = y[i];\n+            final double[] yDotI = yDot[i];\n+            final double[] bI    = b[2 * i - 2];\n+            final double[] bDotI = b[2 * i - 1];\n+            for (int j = 0; j < yI.length; ++j) {\n+                bI[j]    = yI[j] - y0[j] - di * yDot0[j];\n+                bDotI[j] = yDotI[j] - yDot0[j];\n+            }\n+\n+        }\n+\n+        // solve the rectangular system in the least square sense\n+        // to get the best estimate of the Nordsieck vector [s2 ... sk]\n+        QRDecomposition decomposition = new QRDecompositionImpl(new Array2DRowRealMatrix(a, false));\n+        return new Array2DRowRealMatrix(decomposition.getSolver().solve(b), false);\n+\n     }\n \n     /** Update the high order scaled derivatives for Adams integrators (phase 1).\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n                             pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n \n-            // the 31 and 36 factors are only valid for this test\n+            // the 50 and 300 factors are only valid for this test\n             // and has been obtained from trial and error\n             // there is no general relation between local and global errors\n-            Assert.assertTrue(handler.getMaximalValueError() > (31.0 * scalAbsoluteTolerance));\n-            Assert.assertTrue(handler.getMaximalValueError() < (36.0 * scalAbsoluteTolerance));\n+            Assert.assertTrue(handler.getMaximalValueError() > (50.0 * scalAbsoluteTolerance));\n+            Assert.assertTrue(handler.getMaximalValueError() < (300.0 * scalAbsoluteTolerance));\n             Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n \n             int calls = pb.getCalls();\n         integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                         pb.getFinalTime(), new double[pb.getDimension()]);\n \n-        Assert.assertTrue(handler.getLastError() < 1.0e-8);\n-        Assert.assertTrue(handler.getMaximalValueError() < 1.0e-8);\n+        Assert.assertTrue(handler.getLastError() < 1.5e-8);\n+        Assert.assertTrue(handler.getMaximalValueError() < 1.5e-8);\n         Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n         Assert.assertEquals(\"Adams-Bashforth\", integ.getName());\n     }\n         TestProblem6 pb = new TestProblem6();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        for (int nSteps = 1; nSteps < 8; ++nSteps) {\n+        for (int nSteps = 2; nSteps < 8; ++nSteps) {\n             AdamsBashforthIntegrator integ =\n-                new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-10, 1.0e-10);\n+                new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (nSteps < 4) {\n-                Assert.assertTrue(integ.getEvaluations() > 150);\n+                Assert.assertTrue(handler.getMaximalValueError() > 1.0e-03);\n             } else {\n-                Assert.assertTrue(integ.getEvaluations() < 70);\n+                Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12);\n             }\n         }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n                             pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n \n-            // the 0.15 and 3.0 factors are only valid for this test\n+            // the 0.5 and 11.0 factors are only valid for this test\n             // and has been obtained from trial and error\n             // there is no general relation between local and global errors\n-            Assert.assertTrue(handler.getMaximalValueError() > (0.15 * scalAbsoluteTolerance));\n-            Assert.assertTrue(handler.getMaximalValueError() < (3.0 * scalAbsoluteTolerance));\n+            Assert.assertTrue(handler.getMaximalValueError() > ( 0.5 * scalAbsoluteTolerance));\n+            Assert.assertTrue(handler.getMaximalValueError() < (11.0 * scalAbsoluteTolerance));\n             Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16);\n \n             int calls = pb.getCalls();\n         TestProblem6 pb = new TestProblem6();\n         double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime());\n \n-        for (int nSteps = 1; nSteps < 7; ++nSteps) {\n+        for (int nSteps = 2; nSteps < 8; ++nSteps) {\n             AdamsMoultonIntegrator integ =\n-                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n+                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5);\n             TestProblemHandler handler = new TestProblemHandler(pb, integ);\n             integ.addStepHandler(handler);\n             integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                             pb.getFinalTime(), new double[pb.getDimension()]);\n             if (nSteps < 4) {\n-                Assert.assertTrue(integ.getEvaluations() > 140);\n+                Assert.assertTrue(handler.getMaximalValueError() > 7.0e-04);\n             } else {\n-                Assert.assertTrue(integ.getEvaluations() < 90);\n+                Assert.assertTrue(handler.getMaximalValueError() < 3.0e-13);\n             }\n         }\n ", "timestamp": 1304097359, "metainfo": ""}