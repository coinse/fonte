{"sha": "a71b17a9d1c6da3a3572ef3f4a55da742c0734b4", "log": "javadoc   ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n  * Represents a polynomial spline function.\n  * <p>\n  * A <strong>polynomial spline function</strong> consists of a set of \n- * <i>interpolating polynomials</i> and an ascending array of  domain \n+ * <i>interpolating polynomials</i> and an ascending array of domain \n  * <i>knot points</i>, determining the intervals over which the spline function\n  * is defined by the constituent polynomials.  The polynomials are assumed to\n  * have been computed to match the values of another function at the knot\n  * than or equal to <code>x</code>.  The value returned is <br>\n  * <code>polynomials[j](x - knot[j])</code></li></ol>\n  *\n- * @version $Revision: 1.8 $ $Date: 2004/07/20 12:55:01 $\n+ * @version $Revision: 1.9 $ $Date: 2004/07/22 02:34:25 $\n  */\n public class PolynomialSplineFunction implements UnivariateRealFunction, Serializable {\n    \n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n  * generate random values \"like\" those in the input file -- i.e., the values\n  * generated will follow the distribution of the values in the file.\n  * \n- * @version $Revision: 1.21 $ $Date: 2004/07/18 23:57:11 $\n+ * @version $Revision: 1.22 $ $Date: 2004/07/22 02:34:25 $\n  */\n public interface EmpiricalDistribution {\n \n \n \n     /**\n-     * Returns a {@link StatisticalSummary} describing this distribution.\n+     * Returns a \n+     * {@link org.apache.commons.math.stat.univariate.StatisticalSummary} \n+     * describing this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li>\n      * </ul>\n     int getBinCount();\n \n     /**\n-     * Returns a list of {@link SummaryStatistics} containing statistics\n-     * describing the values in each of the bins.  The List is indexed on\n-     * the bin number.\n+     * Returns a list of \n+     * {@link org.apache.commons.math.stat.univariate.SummaryStatistics}\n+     * containing statistics describing the values in each of the bins.  The\n+     * List is indexed on the bin number.\n      * \n      * @return List of bin statistics\n      */\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.util.Collection;\n \n /**\n- * Implements the <code>RandomData</code> interface using\n- * <code>java.util.Random</code> and\n- * <code>java.util.Random.SecureRandom</code> instances to generate data.\n+ * Implements the {@link RandomData} interface using\n+ * {@link java.util.Random} and {@link java.util.Random.SecureRandom} instances\n+ * to generate data.\n  * <p>\n- * Supports reseeding the underlying\n- * <a href=\"http://en.wikipedia.org/wiki/Pseudorandom_number_generator\">\n- * PRNG</a>. The <code>SecurityProvider</code> and <code>Algorithm</code>\n+ * Supports reseeding the underlying pseudo-random number generator (PRNG). \n+ * The <code>SecurityProvider</code> and <code>Algorithm</code>\n  * used by the <code>SecureRandom</code> instance can also be reset.\n  * <p>\n- * For details on the PRNGs, see the JDK documentation for\n- * <code>java.util.Random</code> and\n- * <code>java.util.Random.SecureRandom</code>\n+ * For details on the PRNGs, see {@link java.util.Random} and\n+ * {@link java.util.Random.SecureRandom}.\n  * <p>\n  * <strong>Usage Notes</strong>: <ul>\n  * <li>\n  * to generate a random sequence of values or strings, you should use just\n  * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n  * <li>\n- * The \"secure\" methods are *much* slower.  These should be used only when\n- * a <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n- * Secure Random Sequence</a> is required.</li>\n+ * The \"secure\" methods are *much* slower.  These should be used only when a\n+ * cryptographically secure random sequence is required.  A secure random\n+ * sequence is a sequence of pseudo-random values which, in addition to being\n+ * well-dispersed (so no subsequence of values is an any more likely than other\n+ * subsequence of the the same length), also has the additional property that\n+ * knowledge of values generated up to any point in the sequence does not make\n+ * it any easier to predict subsequent values.</li>\n  * <li>\n  * When a new <code>RandomDataImpl</code> is created, the underlying random\n  * number generators are <strong>not</strong> intialized.  The first call to a\n  * results in the same subsequent random sequence); whereas reSeedSecure(long)\n  * does <strong>not</strong> reinitialize the secure random number generator\n  * (so secure sequences started with calls to reseedSecure(long) won't be\n- * identical).</li></ul>\n+ * identical).</li>\n+ * <li>\n+ * This implementation is not synchronized.\n+ * </ul>\n  *\n- * @version $Revision: 1.15 $ $Date: 2004/06/14 23:15:15 $\n+ * @version $Revision: 1.16 $ $Date: 2004/07/22 02:34:25 $\n  */\n public class RandomDataImpl implements RandomData, Serializable {\n \n     /**\n      * Generate a random int value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.\n+     * \n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n     /**\n      * Generate a random long value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.\n+     * \n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n      * <li>\n      * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n      * <li>\n-     * Each byte of the binary digest is converted to 2 hex digits</li></ol>\n-     * <p>\n-     * TODO: find external reference or provide justification for the claim\n-     * that this yields a cryptographically secure sequence of hex strings.\n-     * @param len the desired string length.\n-     * @return the random string.\n+     * Each byte of the binary digest is converted to 2 hex digits.</li></ol>\n+     *\n+     * @param len the length of the generated string\n+     * @return the random string\n      */\n     public String nextSecureHexString(int len) {\n         if (len <= 0) {\n     /**\n      * Generate a random int value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n-     * using a secure random number generator for its engine.\n+     * uses a secure random number generator.\n+     * \n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n     /**\n      * Generate a random long value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.  This algorithm\n-     * using a secure random number generator for its engine.\n+     * uses a secure random number generator.\n+     * \n      * @param lower the lower bound.\n      * @param upper the upper bound.\n      * @return the random integer.\n     }\n \n     /**\n-     * Generates a random long value from the Poisson distribution with the given mean.\n+     * Generates a random long value from the Poisson distribution with the\n+     * given mean.\n      * <p>\n      * <strong>Algorithm Description</strong>:\n      * Uses simulation of a Poisson process using Uniform deviates, as\n      * <a href =\"http://dmawww.epfl.ch/benarous/Pmmi/interactive/rng7.htm\">\n      * here.</a>\n      * <p>\n-     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n+     * The Poisson process (and hence value returned) is bounded by \n+     * 1000 * mean.\n+     * \n      * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n      */\n     }\n \n     /**\n-     * Generate a random value from a Normal distribution.  This algorithm\n-     * generates random values for the general Normal distribution with the\n-     * given mean, <code>mu</code> and the given standard deviation,\n+     * Generate a random value from a Normal (a.k.a. Gaussian) distribution\n+     * with the given mean, <code>mu</code> and the given standard deviation,\n      * <code>sigma</code>.\n-     * @param mu the mean of the distribution.\n-     * @param sigma the standard deviation of the distribution.\n-     * @return the random Normal value.\n+     * \n+     * @param mu the mean of the distribution\n+     * @param sigma the standard deviation of the distribution\n+     * @return the random Normal value\n      */\n     public double nextGaussian(double mu, double sigma) {\n         if (sigma <= 0) {\n     }\n \n     /**\n+     * Returns a random value from an Exponential distribution with the given\n+     * mean.\n+     * <p>\n      * <strong>Algorithm Description</strong>:  Uses the\n      * <a href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\">\n-     * Inversion Method</a> to generate exponential from uniform deviates.\n-     * @param mean the mean of the distribution.\n-     * @return the random Exponential value.\n+     * Inversion Method</a> to generate exponentially distributed random values\n+     * from uniform deviates.\n+     * \n+     * @param mean the mean of the distribution\n+     * @return the random Exponential value\n      */\n     public double nextExponential(double mean)  {\n         if (mean < 0.0)  {", "timestamp": 1090463665, "metainfo": ""}