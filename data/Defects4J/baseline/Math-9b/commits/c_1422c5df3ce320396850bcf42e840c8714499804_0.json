{"sha": "1422c5df3ce320396850bcf42e840c8714499804", "log": "extracted a superinterface ConvergingAlgorithm from UnivariateRealSolver for later reuse by upcoming minimization algorithms  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ConvergingAlgorithm.java\n+package org.apache.commons.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Interface for algorithms handling convergence settings.\n+ * <p>\n+ * This interface only deals with convergence parameters setting, not\n+ * execution of the algorithms per se.\n+ * </p>\n+ * @see ConvergenceException\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ConvergingAlgorithm extends Serializable {\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * <p>\n+     * Usually a high iteration count indicates convergence problems. However,\n+     * the \"reasonable value\" varies widely for different algorithms. Users are\n+     * advised to use the default value supplied by the algorithm.</p>\n+     * <p>\n+     * A {@link ConvergenceException} will be thrown if this number\n+     * is exceeded.</p>\n+     *  \n+     * @param count maximum number of iterations\n+     */\n+    public abstract void setMaximalIterationCount(int count);\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    public abstract int getMaximalIterationCount();\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the algorithm implementation.</p>\n+     * \n+     * @see #setMaximalIterationCount(int)\n+     */\n+    public abstract void resetMaximalIterationCount();\n+\n+    /**\n+     * Set the absolute accuracy.\n+     * <p>\n+     * The default is usually chosen so that results in the interval\n+     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n+     * expected absolute value of your results is of much smaller magnitude, set\n+     * this to a smaller value.</p>\n+     * <p>\n+     * Algorithms are advised to do a plausibility check with the relative\n+     * accuracy, but clients should not rely on this.</p>\n+     *  \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    public abstract void setAbsoluteAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual absolute accuracy.\n+     * \n+     * @return the accuracy\n+     */\n+    public abstract double getAbsoluteAccuracy();\n+\n+    /**\n+     * Reset the absolute accuracy to the default.\n+     * <p>\n+     * The default value is provided by the algorithm implementation.</p>\n+     */\n+    public abstract void resetAbsoluteAccuracy();\n+\n+    /**\n+     * Set the relative accuracy.\n+     * <p>\n+     * This is used to stop iterations if the absolute accuracy can't be\n+     * achieved due to large values or short mantissa length.</p>\n+     * <p>\n+     * If this should be the primary criterion for convergence rather then a\n+     * safety measure, set the absolute accuracy to a ridiculously small value,\n+     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n+     * \n+     * @param accuracy the relative accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the algorithm or is otherwise deemed unreasonable. \n+     */\n+    public abstract void setRelativeAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    public abstract double getRelativeAccuracy();\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     * The default value is provided by the algorithm implementation.\n+     */\n+    public abstract void resetRelativeAccuracy();\n+\n+    /**\n+     * Get the number of iterations in the last run of the algorithm.\n+     * <p>\n+     * This is mainly meant for testing purposes. It may occasionally\n+     * help track down performance problems: if the iteration count\n+     * is notoriously high, check whether the problem is evaluated\n+     * properly, and whether another algorithm is more amenable to the\n+     * problem.</p>\n+     * \n+     * @return the last iteration count.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    public abstract int getIterationCount();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * converging algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class ConvergingAlgorithmImpl implements ConvergingAlgorithm {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4059567655915789396L;\n+\n+    /** Maximum absolute error. */\n+    protected double absoluteAccuracy;\n+\n+    /** Maximum relative error. */\n+    protected double relativeAccuracy;\n+\n+    /** Maximum number of iterations. */\n+    protected int maximalIterationCount;\n+\n+    /** Default maximum absolute error. */\n+    protected double defaultAbsoluteAccuracy;\n+\n+    /** Default maximum relative error. */\n+    protected double defaultRelativeAccuracy;\n+\n+    /** Default maximum number of iterations. */\n+    protected int defaultMaximalIterationCount;\n+\n+    // Mainly for test framework.\n+    /** The last iteration count. */\n+    protected int iterationCount;\n+\n+    /**\n+     * Construct an algorithm with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n+                                      final double defaultAbsoluteAccuracy) {\n+        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.defaultRelativeAccuracy = 1.0e-14;\n+        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+        this.iterationCount = 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterationCount() {\n+        return iterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAbsoluteAccuracy(double accuracy) {\n+        absoluteAccuracy = accuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetAbsoluteAccuracy() {\n+        absoluteAccuracy = defaultAbsoluteAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaximalIterationCount(int count) {\n+        maximalIterationCount = count;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaximalIterationCount() {\n+        return maximalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetMaximalIterationCount() {\n+        maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRelativeAccuracy(double accuracy) {\n+        relativeAccuracy = accuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetRelativeAccuracy() {\n+        relativeAccuracy = defaultRelativeAccuracy;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"Overflow trying to convert {0} to fraction ({1}/{2})\",\n       \"D\\u00e9passement de capacit\\u00e9 lors de la conversion de {0} en fraction ({1}/{2})\" },\n \n-    // org.apache.commons.math.analysis.UnivariateRealSolverUtils\n+    // org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils\n     { \"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4},\" +\n           \" final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n       \"Nombre d''it\\u00e9rations = {0}, it\\u00e9rations maximum = {1}, valeur initiale = {2},\" +\n    { \"cannot substitute an element from an empty array\",\n      \"impossible de substituer un \\u00e9l\\u00e9ment dans un tableau vide\" },\n \n-   // org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm\n+   // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm\n    { \"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n      \"division par z\\u00e9ro caus\\u00e9e par les abscisses identiques x[{0}] == x[{1}] == {2}\" },\n \n-   // org.apache.commons.math.analysis.UnivariateRealSolverImpl\n+   // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n    { \"function to solve cannot be null\",\n      \"la fonction \\u00e0 r\\u00e9soudre ne peux pas \\u00eatre nulle\" },\n-\n-   // org.apache.commons.math.analysis.LaguerreSolver\n+   { \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+     \"param\\u00e8tres de l''intervalle initial invalides : borne inf = {0}, valeur initiale = {1}, borne sup = {2}\" },\n+\n+   // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n+   // org.apache.commons.math.analysis.solvers.BrentSolver\n+   { \"function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+     \"les valeurs de la fonction aux bornes n''ont pas des signes diff\\u00e9rents. Bornes : [{0}, {1}], valeurs : [{2}, {3}]\" },\n+\n+   // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n+   // org.apache.commons.math.transform.FastFourierTransformer\n+   { \"endpoints do not specify an interval: [{0}, {1}]\",\n+     \"les extr\\u00e9mit\\u00e9s ne constituent pas un intervalle : [{0}, {1}]\" },\n+\n+   // org.apache.commons.math.analysis.solvers.LaguerreSolver\n    { \"function is not polynomial\",\n      \"la fonction n''est pas p\\u00f4lynomiale\" },\n \n-   // org.apache.commons.math.analysis.NewtonSolver\n+   // org.apache.commons.math.analysis.solvers.NewtonSolver\n    { \"function is not differentiable\",\n      \"la fonction n''est pas diff\\u00e9rentiable\" },\n \n    { \"zero norm\",\n      \"norme nulle\" },\n \n-   // org.apache.commons.math.analysis.UnivariateRealIntegratorImpl\n-   // org.apache.commons.math.analysis.UnivariateRealSolverImpl\n+   // org.apache.commons.math.ConvergingAlgorithmImpl\n    { \"no result available\",\n      \"aucun r\\u00e9sultat n''est disponible\" },\n \n      \"le nombre d''\\u00e9chantillons n''est pas positif : {0}\" },\n    { \"{0} is not a power of 2, consider padding for fix\",\n      \"{0} n''est pas une puissance de 2, ajoutez des \\u00e9l\\u00e9ments pour corriger\" },\n-   { \"endpoints do not specify an interval: [{0}, {1}]\",\n-     \"les extr\\u00e9mit\\u00e9s ne constituent pas un intervalle : [{0}, {1}]\" },\n    { \"some dimensions don't math: {0} != {1}\",\n      \"certaines dimensions sont incoh\\u00e9rentes : {0} != {1}\" },\n \n--- a/src/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n \n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        if (((initial - min) * (max -initial)) < 0) {\n-            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n-                      \" interval.\" + \"  Initial: \" + initial +\n-                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n-        }\n+        clearResult();\n+        verifySequence(min, initial, max);\n \n         // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n                 ret = max;\n             } else {\n                 // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"function values at endpoints do not have different signs.  \" +\n+                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+                        new Object[] { min, max, yMin, yMax });       \n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n package org.apache.commons.math.analysis.solvers;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n  *  \n  * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (Sun, 07 Dec 2008) $\n  */\n-public interface UnivariateRealSolver {\n-\n-    /**\n-     * Set the upper limit for the number of iterations.\n-     * <p>\n-     * Usually a high iteration count indicates convergence problems. However,\n-     * the \"reasonable value\" varies widely for different solvers.  Users are\n-     * advised to use the default value supplied by the solver.</p>\n-     * <p>\n-     * A <code>ConvergenceException</code> will be thrown if this number\n-     * is exceeded.</p>\n-     *  \n-     * @param count maximum number of iterations\n-     */\n-    void setMaximalIterationCount(int count);\n-\n-    /**\n-     * Get the upper limit for the number of iterations.\n-     * \n-     * @return the actual upper limit\n-     */\n-    int getMaximalIterationCount();\n-\n-    /**\n-     * Reset the upper limit for the number of iterations to the default.\n-     * <p>\n-     * The default value is supplied by the solver implementation.</p>\n-     * \n-     * @see #setMaximalIterationCount(int)\n-     */\n-    void resetMaximalIterationCount();\n-\n-    /**\n-     * Set the absolute accuracy.\n-     * <p>\n-     * The default is usually choosen so that roots in the interval\n-     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n-     * expected absolute value of your roots is of much smaller magnitude, set\n-     * this to a smaller value.</p>\n-     * <p>\n-     * Solvers are advised to do a plausibility check with the relative\n-     * accuracy, but clients should not rely on this.</p>\n-     *  \n-     * @param accuracy the accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the solver or is otherwise deemed unreasonable. \n-     */\n-    void setAbsoluteAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual absolute accuracy.\n-     * \n-     * @return the accuracy\n-     */\n-    double getAbsoluteAccuracy();\n-\n-    /**\n-     * Reset the absolute accuracy to the default.\n-     * <p>\n-     * The default value is provided by the solver implementation.</p>\n-     */\n-    void resetAbsoluteAccuracy();\n-\n-    /**\n-     * Set the relative accuracy.\n-     * <p>\n-     * This is used to stop iterations if the absolute accuracy can't be\n-     * achieved due to large values or short mantissa length.</p>\n-     * <p>\n-     * If this should be the primary criterion for convergence rather then a\n-     * safety measure, set the absolute accuracy to a ridiculously small value,\n-     * like 1E-1000.</p>\n-     * \n-     * @param accuracy the relative accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     *  the solver or is otherwise deemed unreasonable. \n-     */\n-    void setRelativeAccuracy(double accuracy);\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     * @return the accuracy\n-     */\n-    double getRelativeAccuracy();\n-\n-    /**\n-     * Reset the relative accuracy to the default.\n-     * The default value is provided by the solver implementation.\n-     */\n-    void resetRelativeAccuracy();\n+public interface UnivariateRealSolver extends ConvergingAlgorithm {\n \n     /**\n      * Set the function value accuracy.\n      * because no result was yet computed or the last attempt failed.\n      */\n     double getFunctionValue();\n-\n-    /**\n-     * Get the number of iterations in the last run of the solver.\n-     * <p>\n-     * This is mainly meant for testing purposes. It may occasionally\n-     * help track down performance problems: if the iteration count\n-     * is notoriously high, check whether the function is evaluated\n-     * properly, and whether another solver is more amenable to the\n-     * problem.</p>\n-     * \n-     * @return the last iteration count.\n-     * @throws IllegalStateException if there is no result available, either\n-     * because no result was yet computed or the last attempt failed.\n-     */\n-    int getIterationCount();\n }\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n \n package org.apache.commons.math.analysis.solvers;\n \n-import java.io.Serializable;\n-\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n  *  \n  * @version $Revision: 724191 $ $Date: 2008-12-07 21:24:10 +0100 (Sun, 07 Dec 2008) $\n  */\n-public abstract class UnivariateRealSolverImpl implements UnivariateRealSolver,\n-    Serializable {\n+public abstract class UnivariateRealSolverImpl\n+    extends ConvergingAlgorithmImpl implements UnivariateRealSolver {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 1112491292565386596L;\n     \n-    /** Maximum absolute error. */\n-    protected double absoluteAccuracy;\n-\n-    /** Maximum relative error. */\n-    protected double relativeAccuracy;\n-\n     /** Maximum error of function. */\n     protected double functionValueAccuracy;\n \n-    /** Maximum number of iterations. */\n-    protected int maximalIterationCount;\n-\n-    /** Default maximum absolute error. */\n-    protected double defaultAbsoluteAccuracy;\n-\n-    /** Default maximum relative error. */\n-    protected double defaultRelativeAccuracy;\n-\n     /** Default maximum error of function. */\n     protected double defaultFunctionValueAccuracy;\n \n-    /** Default maximum number of iterations. */\n-    protected int defaultMaximalIterationCount;\n-\n     /** Indicates where a root has been computed. */\n     protected boolean resultComputed = false;\n \n \n     /** Value of the function at the last computed result. */\n     protected double functionValue;\n-\n-    // Mainly for test framework.\n-    /** The last iteration count. */\n-    protected int iterationCount;\n \n     /** The function to solve.\n      * @deprecated as of 2.0 the function to solve is passed as an argument\n      * method.\n      */\n     @Deprecated\n-    protected UnivariateRealSolverImpl(\n-        UnivariateRealFunction f,\n-        int defaultMaximalIterationCount,\n-        double defaultAbsoluteAccuracy) {\n-        \n+    protected UnivariateRealSolverImpl(final UnivariateRealFunction f,\n+                                       final int defaultMaximalIterationCount,\n+                                       final double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n         if (f == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\",\n                                                                       null);\n         }\n         this.f = f;\n-\n-        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n-        this.defaultRelativeAccuracy = 1E-14;\n-        this.defaultFunctionValueAccuracy = 1E-15;\n-        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n-        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n         this.functionValueAccuracy = defaultFunctionValueAccuracy;\n-        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n-        this.maximalIterationCount = defaultMaximalIterationCount;\n     }\n \n     /**\n      * @throws IllegalArgumentException if f is null or the \n      * defaultAbsoluteAccuracy is not valid\n      */\n-    protected UnivariateRealSolverImpl(int defaultMaximalIterationCount,\n-                                       double defaultAbsoluteAccuracy) {\n-        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n-        this.defaultRelativeAccuracy = 1E-14;\n-        this.defaultFunctionValueAccuracy = 1E-15;\n-        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n-        this.relativeAccuracy = defaultRelativeAccuracy;\n+    protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\n+                                       final double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n         this.functionValueAccuracy = defaultFunctionValueAccuracy;\n-        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n-        this.maximalIterationCount = defaultMaximalIterationCount;\n-    }\n-\n-    /**\n-     * Access the last computed root.\n-     * \n-     * @return the last computed root\n-     * @throws IllegalStateException if no root has been computed\n-     */\n-    public double getResult() {\n-        if (resultComputed) {\n-            return result;\n-        } else {\n+    }\n+\n+    /** Check if a result has been computed.\n+     * @exception IllegalStateException if no result has been computed\n+     */\n+    protected void checkResultComputed() throws IllegalArgumentException {\n+        if (!resultComputed) {\n             throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n     }\n \n-    /**\n-     * Access the value of the function at the last computed result.\n-     * \n-     * @return the function value at the last result.\n-     * @throws IllegalStateException if no value has been computed.\n-     */\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        checkResultComputed();\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        if (resultComputed) {\n-            return functionValue;\n-        } else {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n-        }\n-    }\n-\n-    /**\n-     * Access the last iteration count.\n-     * \n-     * @return the last iteration count\n-     * @throws IllegalStateException if no root has been computed\n-     *  \n-     */\n-    public int getIterationCount() {\n-        if (resultComputed) {\n-            return iterationCount;\n-        } else {\n-            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n-        }\n+        checkResultComputed();\n+        return functionValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setFunctionValueAccuracy(final double accuracy) {\n+        functionValueAccuracy = accuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetFunctionValueAccuracy() {\n+        functionValueAccuracy = defaultFunctionValueAccuracy;\n     }\n \n     /**\n      * @param result the result to set\n      * @param iterationCount the iteration count to set\n      */\n-    protected final void setResult(double result, int iterationCount) {\n-        this.result = result;\n+    protected final void setResult(final double result, final int iterationCount) {\n+        this.result         = result;\n         this.iterationCount = iterationCount;\n         this.resultComputed = true;\n     }\n      * @param fx the result to set\n      * @param iterationCount the iteration count to set\n      */\n-    protected final void setResult(double x, double fx, int iterationCount) {\n-        this.result = x;\n-        this.functionValue = fx;\n+    protected final void setResult(final double x, final double fx,\n+                                   final int iterationCount) {\n+        this.result         = x;\n+        this.functionValue  = fx;\n         this.iterationCount = iterationCount;\n         this.resultComputed = true;\n     }\n      * Convenience function for implementations.\n      */\n     protected final void clearResult() {\n+        this.iterationCount = 0;\n         this.resultComputed = false;\n     }\n \n-    /**\n-     * Set the absolute accuracy.\n-     * \n-     * @param accuracy the accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     *  the solver or is otherwise deemed unreasonable. \n-     */\n-    public void setAbsoluteAccuracy(double accuracy) {\n-        absoluteAccuracy = accuracy;\n-    }\n-\n-    /**\n-     * Get the actual absolute accuracy.\n-     * \n-     * @return the accuracy\n-     */\n-    public double getAbsoluteAccuracy() {\n-        return absoluteAccuracy;\n-    }\n-\n-    /**\n-     * Reset the absolute accuracy to the default.\n-     */\n-    public void resetAbsoluteAccuracy() {\n-        absoluteAccuracy = defaultAbsoluteAccuracy;\n-    }\n-\n-    /**\n-     * Set the upper limit for the number of iterations.\n-     * \n-     * @param count maximum number of iterations\n-     */\n-    public void setMaximalIterationCount(int count) {\n-        maximalIterationCount = count;\n-    }\n-\n-    /**\n-     * Get the upper limit for the number of iterations.\n-     * \n-     * @return the actual upper limit\n-     */\n-    public int getMaximalIterationCount() {\n-        return maximalIterationCount;\n-    }\n-\n-    /**\n-     * Reset the upper limit for the number of iterations to the default.\n-     */\n-    public void resetMaximalIterationCount() {\n-        maximalIterationCount = defaultMaximalIterationCount;\n-    }\n-\n-    /**\n-     * Set the relative accuracy.\n-     * \n-     * @param accuracy the relative accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     *  the solver or is otherwise deemed unreasonable. \n-     */\n-    public void setRelativeAccuracy(double accuracy) {\n-        relativeAccuracy = accuracy;\n-    }\n-\n-    /**\n-     * Get the actual relative accuracy.\n-     * @return the accuracy\n-     */\n-    public double getRelativeAccuracy() {\n-        return relativeAccuracy;\n-    }\n-\n-    /**\n-     * Reset the relative accuracy to the default.\n-     */\n-    public void resetRelativeAccuracy() {\n-        relativeAccuracy = defaultRelativeAccuracy;\n-    }\n-\n-    /**\n-     * Set the function value accuracy.\n-     * \n-     * @param accuracy the accuracy.\n-     * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the solver or is otherwise deemed unreasonable. \n-     */\n-    public void setFunctionValueAccuracy(double accuracy) {\n-        functionValueAccuracy = accuracy;\n-    }\n-\n-    /**\n-     * Get the actual function value accuracy.\n-     * @return the accuracy\n-     */\n-    public double getFunctionValueAccuracy() {\n-        return functionValueAccuracy;\n-    }\n-\n-    /**\n-     * Reset the actual function accuracy to the default.\n-     */\n-    public void resetFunctionValueAccuracy() {\n-        functionValueAccuracy = defaultFunctionValueAccuracy;\n-    }\n-    \n-    \n     /**\n      * Returns true iff the function takes opposite signs at the endpoints.\n      * \n      * @throws FunctionEvaluationException if an error occurs evaluating the \n      * function at the endpoints\n      */\n-    protected boolean isBracketing(double lower, double upper, \n-            UnivariateRealFunction f) throws FunctionEvaluationException {\n-        double f1 = f.value(lower);\n-        double f2 = f.value(upper);\n+    protected boolean isBracketing(final double lower, final double upper, \n+                                   final UnivariateRealFunction f)\n+        throws FunctionEvaluationException {\n+        final double f1 = f.value(lower);\n+        final double f2 = f.value(upper);\n         return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n     }\n     \n      * @param end  third number\n      * @return true if the arguments form an increasing sequence\n      */\n-    protected boolean isSequence(double start, double mid, double end) {\n+    protected boolean isSequence(final double start, final double mid, final double end) {\n         return (start < mid) && (mid < end);\n     }\n     \n      * @param upper upper endpoint\n      * @throws IllegalArgumentException\n      */\n-    protected void verifyInterval(double lower, double upper) {\n+    protected void verifyInterval(final double lower, final double upper) {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException\n-                (\"Endpoints do not specify an interval: [\" + lower + \n-                        \",\" + upper + \"]\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"endpoints do not specify an interval: [{0}, {1}]\",\n+                    new Object[] { lower, upper });\n         }       \n     }\n     \n      * @param upper upper endpoint\n      * @throws IllegalArgumentException\n      */\n-    protected void verifySequence(double lower, double initial, double upper) {\n+    protected void verifySequence(final double lower, final double initial, final double upper) {\n         if (!isSequence(lower, initial, upper)) {\n-            throw new IllegalArgumentException\n-                (\"Invalid interval, initial value parameters:  lower=\" + \n-                   lower + \" initial=\" + initial + \" upper=\" + upper);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+                    new Object[] { lower, initial, upper });\n         }       \n     }\n     \n      * @throws FunctionEvaluationException if an error occurs evaluating the \n      * function at the endpoints\n      */\n-    protected void verifyBracketing(double lower, double upper, \n-            UnivariateRealFunction f) throws FunctionEvaluationException {\n+    protected void verifyBracketing(final double lower, final double upper, \n+                                    final UnivariateRealFunction f)\n+        throws FunctionEvaluationException {\n         \n         verifyInterval(lower, upper);\n         if (!isBracketing(lower, upper, f)) {\n-            throw new IllegalArgumentException\n-            (\"Function values at endpoints do not have different signs.\" +\n-                    \"  Endpoints: [\" + lower + \",\" + upper + \"]\" + \n-                    \"  Values: [\" + f.value(lower) + \",\" + f.value(upper) + \"]\");       \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"function values at endpoints do not have different signs.  \" +\n+                    \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+                    new Object[] { lower, upper, f.value(lower), f.value(upper) });       \n         }\n     }\n }", "timestamp": 1232290071, "metainfo": ""}