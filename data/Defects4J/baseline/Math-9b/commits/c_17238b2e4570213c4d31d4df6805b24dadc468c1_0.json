{"sha": "17238b2e4570213c4d31d4df6805b24dadc468c1", "log": "improved matrix decomposition API. solving a linear system AX = B is now done by a call like:   RealVector x = new XyzSolver(new XyzDecomposition(a)).solve(b);  ", "commit": "\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUSolver;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n \n \n         try {\n             // compute the covariances matrix\n-            DecompositionSolver solver = new DecompositionSolver(new RealMatrixImpl(jTj, false));\n-            RealMatrix inverse = solver.getInverse(solver.luDecompose());\n+            RealMatrix inverse =\n+                new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(jTj, false))).getInverse();\n             return ((RealMatrixImpl) inverse).getDataRef();\n         } catch (InvalidMatrixException ime) {\n             throw new EstimationException(\"unable to compute covariances: singular problem\",\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUSolver;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n import org.apache.commons.math.linear.RealVector;\n             try {\n \n                 // solve the linearized least squares problem\n-                DecompositionSolver solver = new DecompositionSolver(a);\n-                RealVector dX = solver.solve(b, solver.luDecompose());\n+                RealVector dX = new LUSolver(new LUDecompositionImpl(a)).solve(b);\n \n                 // update the estimated parameters\n                 for (int i = 0; i < parameters.length; ++i) {\n--- a/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Class handling decomposition algorithms that can solve A &times; X = B.\n- * <p>This class is the entry point for decomposition algorithms like\n- * {@link QRDecomposition}, {@link LUDecomposition}, {@link\n- * SingularValueDecomposition} or {@link EigenDecomposition}. All these\n- * algorithms decompose an A matrix has a product of several specific matrices\n- * from which they can solve A &times; X = B in least squares sense: they find X\n+ * Interface handling decomposition algorithms that can solve A &times; X = B.\n+ * <p>Decomposition algorithms decompose an A matrix has a product of several specific\n+ * matrices from which they can solve A &times; X = B in least squares sense: they find X\n  * such that ||A &times; X - B|| is minimal.</p>\n  * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n  * square matrices and when the solution is an exact linear solution, i.e. when\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public class DecompositionSolver implements Serializable {\n+public interface DecompositionSolver extends Serializable {\n \n-    /** Serializable version identifier. */\n-    private static final long serialVersionUID = 182675257956465253L;\n-\n-    /** Matrix to decompose. */\n-    private final RealMatrix matrix;\n-\n-    /**\n-     * Build a decomposition solver for a matrix.\n-     * @param matrix matrix to decompose\n-     */\n-    public DecompositionSolver(final RealMatrix matrix) {\n-        this.matrix = matrix;\n-    }\n-\n-    /**\n-     * Decompose a matrix using eigendecomposition.\n-     * <p>The split tolerance is set by default to {@link MathUtils#SAFE_MIN}.</p>\n-     * @exception InvalidMatrixException if matrix does not fulfill\n-     * the decomposition requirements (for example non-square matrix\n-     * for {@link LUDecomposition})\n-     */\n-    public EigenDecomposition eigenDecompose()\n-        throws InvalidMatrixException {\n-        return new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n-    }\n-\n-    /**\n-     * Decompose a matrix using eigendecomposition.\n-     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n-     * geometric mean to split the tridiagonal matrix (a suggested value is\n-     * {@link MathUtils#SAFE_MIN})\n-     * @exception InvalidMatrixException if matrix does not fulfill\n-     * the decomposition requirements (for example non-square matrix\n-     * for {@link LUDecomposition})\n-     */\n-    public EigenDecomposition eigenDecompose(final double splitTolerance)\n-        throws InvalidMatrixException {\n-        return new EigenDecompositionImpl(matrix, splitTolerance);\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n      * @return a vector X that minimizes the two norm of A &times; X - B\n      * @exception IllegalArgumentException if matrices dimensions don't match\n      * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n-    public double[] solve(final double[] b, final EigenDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+    double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n \n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] bp = new double[m];\n-        for (int i = 0; i < m; ++i) {\n-            final RealVector v = decomposition.getEigenvector(i);\n-            final double s = v.dotProduct(b) / eigenvalues[i];\n-            for (int j = 0; j < m; ++j) {\n-                bp[j] += s * v.getEntry(j);\n-            }\n-        }\n-\n-        return bp;\n-\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n      * @return a vector X that minimizes the two norm of A &times; X - B\n      * @exception IllegalArgumentException if matrices dimensions don't match\n      * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n-    public RealVector solve(final RealVector b, final EigenDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+    RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n \n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        if (b.getDimension() != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] bp = new double[m];\n-        for (int i = 0; i < m; ++i) {\n-            final RealVector v = decomposition.getEigenvector(i);\n-            final double s = v.dotProduct(b) / eigenvalues[i];\n-            for (int j = 0; j < m; ++j) {\n-                bp[j] += s * v.getEntry(j);\n-            }\n-        }\n-\n-        return new RealVectorImpl(bp, false);\n-\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n      * @exception IllegalArgumentException if matrices dimensions don't match\n      * @exception InvalidMatrixException if decomposed matrix is singular\n      */\n-    public RealMatrix solve(final RealMatrix b, final EigenDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-\n-        final int nColB = b.getColumnDimension();\n-        final double[][] bp = new double[m][nColB];\n-        for (int k = 0; k < nColB; ++k) {\n-            for (int i = 0; i < m; ++i) {\n-                final RealVector v = decomposition.getEigenvector(i);\n-                double s = 0;\n-                for (int j = 0; j < m; ++j) {\n-                    s += v.getEntry(j) * b.getEntry(j, k);\n-                }\n-                s /= eigenvalues[i];\n-                for (int j = 0; j < m; ++j) {\n-                    bp[j][k] += s * v.getEntry(j);\n-                }\n-            }\n-        }\n-\n-        return new RealMatrixImpl(bp, false);\n-\n-    }\n-\n-    /**\n-     * Return the determinant of the matrix\n-     * @param decomposition decomposition of the matrix A\n-     * @return determinant of the matrix\n-     * @see #isNonSingular()\n-     */\n-    public double getDeterminant(final EigenDecomposition decomposition) {\n-        double determinant = 1;\n-        for (double lambda : decomposition.getEigenvalues()) {\n-            determinant *= lambda;\n-        }\n-        return determinant;\n-    }\n+    RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n \n     /**\n      * Check if the decomposed matrix is non-singular.\n-     * @param decomposition decomposition of the matrix A\n      * @return true if the decomposed matrix is non-singular\n      */\n-    public boolean isNonSingular(final EigenDecomposition decomposition) {\n-        for (double lambda : decomposition.getEigenvalues()) {\n-            if (lambda == 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n+    boolean isNonSingular();\n \n-    /** Get the inverse of the decomposed matrix.\n+    /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n      * @param decomposition decomposition of the matrix A\n      * @return inverse matrix\n      * @throws InvalidMatrixException if decomposed matrix is singular\n      */\n-    public RealMatrix getInverse(final EigenDecomposition decomposition)\n-        throws InvalidMatrixException {\n-\n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] eigenvalues = decomposition.getEigenvalues();\n-        final int m = eigenvalues.length;\n-        final double[][] invData = new double[m][m];\n-\n-        for (int i = 0; i < m; ++i) {\n-            final double[] invI = invData[i];\n-            for (int j = 0; j < m; ++j) {\n-                double invIJ = 0;\n-                for (int k = 0; k < m; ++k) {\n-                    final RealVector vK = decomposition.getEigenvector(k);\n-                    invIJ += vK.getEntry(i) * vK.getEntry(j) / eigenvalues[k];\n-                }\n-                invI[j] = invIJ;\n-            }\n-        }\n-        return new RealMatrixImpl(invData, false);\n-\n-    }\n-\n-    /**\n-     * Decompose a matrix using singular value composition.\n-     * @exception InvalidMatrixException if matrix does not fulfill\n-     * the decomposition requirements (for example non-square matrix\n-     * for {@link LUDecomposition})\n-     */\n-    public SingularValueDecomposition singularDecompose()\n-        throws InvalidMatrixException {\n-        return new SingularValueDecompositionImpl(matrix);\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public double[] solve(final double[] b, final SingularValueDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final double[] singularValues = decomposition.getSingularValues();\n-        if (b.length != singularValues.length) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] w = decomposition.getUT().operate(b);\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            w[i] /= si;\n-        }\n-        return decomposition.getV().operate(w);\n-\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVector solve(final RealVector b, final SingularValueDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final double[] singularValues = decomposition.getSingularValues();\n-        if (b.getDimension() != singularValues.length) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final RealVector w = decomposition.getUT().operate(b);\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            w.set(i, w.getEntry(i) / si);\n-        }\n-        return decomposition.getV().operate(w);\n-\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealMatrix solve(final RealMatrix b, final SingularValueDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final double[] singularValues = decomposition.getSingularValues();\n-        if (b.getRowDimension() != singularValues.length) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-\n-        final RealMatrixImpl w = (RealMatrixImpl) decomposition.getUT().multiply(b);\n-        final double[][] wData = w.getDataRef();\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si  = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            final double inv = 1.0 / si;\n-            final double[] wi = wData[i];\n-            for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                wi[j] *= inv;\n-            }\n-        }\n-        return decomposition.getV().multiply(w);\n-\n-    }\n-\n-    /**\n-     * Check if the decomposed matrix is non-singular.\n-     * @param decomposition decomposition of the matrix A\n-     * @return true if the decomposed matrix is non-singular\n-     */\n-    public boolean isNonSingular(final SingularValueDecomposition decomposition) {\n-        return decomposition.getRank() == decomposition.getSingularValues().length;\n-    }\n-\n-    /** Get the inverse of the decomposed matrix.\n-     * @param decomposition decomposition of the matrix A\n-     * @return inverse matrix\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealMatrix getInverse(final SingularValueDecomposition decomposition)\n-        throws InvalidMatrixException {\n-\n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        return solve(MatrixUtils.createRealIdentityMatrix(decomposition.getSingularValues().length),\n-                     decomposition);\n-\n-    }\n-\n-    /**\n-     * Decompose a matrix using QR decomposition.\n-     */\n-    public QRDecomposition qrDecompose() {\n-        return new QRDecompositionImpl(matrix);\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public double[] solve(final double[] b, final QRDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (decomposition.getR().getRowDimension() != b.length) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");            \n-        }\n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        // solve Q.y = b, using the fact Q is orthogonal\n-        final double[] y = decomposition.getQT().operate(b);\n-\n-        // solve triangular system R.x = y\n-        final RealMatrix r = decomposition.getR();\n-        final double[] x = new double[r.getColumnDimension()];\n-        System.arraycopy(y, 0, x, 0, r.getRowDimension());\n-        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n-            x[i] /= r.getEntry(i, i);\n-            final double lastX = x[i];\n-            for (int j = i - 1; j >= 0; --j) {\n-                x[j] -= lastX * r.getEntry(j, i);\n-            }\n-        }\n-\n-        return x;\n-\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVector solve(final RealVector b, final QRDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getData(), decomposition), false);\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealMatrix solve(final RealMatrix b, final QRDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        if (decomposition.getR().getRowDimension() != b.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");            \n-        }\n-        if (!isNonSingular(decomposition)) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        // solve Q.y = b, using the fact Q is orthogonal\n-        final RealMatrix y = decomposition.getQT().multiply(b);\n-\n-        // solve triangular system R.x = y\n-        final RealMatrix r = decomposition.getR();\n-        final double[][] xData =\n-            new double[r.getColumnDimension()][b.getColumnDimension()];\n-        for (int i = 0; i < r.getRowDimension(); ++i) {\n-            final double[] xi = xData[i];\n-            for (int k = 0; k < xi.length; ++k) {\n-                xi[k] = y.getEntry(i, k);\n-            }\n-        }\n-        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n-            final double rii = r.getEntry(i, i);\n-            final double[] xi = xData[i];\n-            for (int k = 0; k < xi.length; ++k) {\n-                xi[k] /= rii;\n-                final double lastX = xi[k];\n-                for (int j = i - 1; j >= 0; --j) {\n-                    xData[j][k] -= lastX * r.getEntry(j, i);\n-                }\n-            }\n-        }\n-\n-        return new RealMatrixImpl(xData, false);\n-\n-    }\n-\n-    /**\n-     * Check if the decomposed matrix is non-singular.\n-     * @param decomposition decomposition of the matrix A\n-     * @return true if the decomposed matrix is non-singular\n-     */\n-    public boolean isNonSingular(final QRDecomposition decomposition) {\n-        final RealMatrix r = decomposition.getR();\n-        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n-        for (int i = 0; i < p; ++i) {\n-            if (r.getEntry(i, i) == 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /** Get the inverse of the decomposed matrix.\n-     * @param decomposition decomposition of the matrix A\n-     * @return inverse matrix\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealMatrix getInverse(final QRDecomposition decomposition)\n-        throws InvalidMatrixException {\n-        final RealMatrix r = decomposition.getR();\n-        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n-        return solve(MatrixUtils.createRealIdentityMatrix(p), decomposition);\n-    }\n-\n-    /**\n-     * Decompose a matrix using LU decomposition.\n-     * @exception InvalidMatrixException if matrix is non-square)\n-     */\n-    public LUDecomposition luDecompose()\n-        throws InvalidMatrixException {\n-        return new LUDecompositionImpl(matrix);\n-    }\n-\n-    /**\n-     * Decompose a matrix using LU decomposition.\n-     * @param singularityThreshold threshold (based on partial row norm)\n-     * under which a matrix is considered singular\n-     * @exception InvalidMatrixException if matrix is non-square)\n-     */\n-    public LUDecomposition luDecompose(final double singularityThreshold)\n-        throws InvalidMatrixException {\n-        return new LUDecompositionImpl(matrix, singularityThreshold);\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public double[] solve(final double[] b, final LUDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int[] pivot = decomposition.getPivot();\n-        final int m = pivot.length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        if (decomposition.isSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] bp = new double[m];\n-\n-        // Apply permutations to b\n-        for (int row = 0; row < m; row++) {\n-            bp[row] = b[pivot[row]];\n-        }\n-\n-        // Solve LY = b\n-        final RealMatrix l = decomposition.getL();\n-        for (int col = 0; col < m; col++) {\n-            for (int i = col + 1; i < m; i++) {\n-                bp[i] -= bp[col] * l.getEntry(i, col);\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        final RealMatrix u = decomposition.getU();\n-        for (int col = m - 1; col >= 0; col--) {\n-            bp[col] /= u.getEntry(col, col);\n-            for (int i = 0; i < col; i++) {\n-                bp[i] -= bp[col] * u.getEntry(i, col);\n-            }\n-        }\n-\n-        return bp;\n-\n-    }\n-\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVector solve(final RealVector b, final LUDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int[] pivot = decomposition.getPivot();\n-        final int m = pivot.length;\n-        if (b.getDimension() != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        if (decomposition.isSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] bp = new double[m];\n-\n-        // Apply permutations to b\n-        for (int row = 0; row < m; row++) {\n-            bp[row] = b.getEntry(pivot[row]);\n-        }\n-\n-        // Solve LY = b\n-        final RealMatrix l = decomposition.getL();\n-        for (int col = 0; col < m; col++) {\n-            for (int i = col + 1; i < m; i++) {\n-                bp[i] -= bp[col] * l.getEntry(i, col);\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        final RealMatrix u = decomposition.getU();\n-        for (int col = m - 1; col >= 0; col--) {\n-            bp[col] /= u.getEntry(col, col);\n-            for (int i = 0; i < col; i++) {\n-                bp[i] -= bp[col] * u.getEntry(i, col);\n-            }\n-        }\n-\n-        return new RealVectorImpl(bp, false);\n-  \n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @param decomposition decomposition of the matrix A\n-     * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealMatrix solve(final RealMatrix b, final LUDecomposition decomposition)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        final int[] pivot = decomposition.getPivot();\n-        final int m = pivot.length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (decomposition.isSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final int nColB = b.getColumnDimension();\n-\n-        // Apply permutations to b\n-        final double[][] bp = new double[m][nColB];\n-        for (int row = 0; row < m; row++) {\n-            final double[] bpRow = bp[row];\n-            final int pRow = pivot[row];\n-            for (int col = 0; col < nColB; col++) {\n-                bpRow[col] = b.getEntry(pRow, col);\n-            }\n-        }\n-\n-        // Solve LY = b\n-        final RealMatrix l = decomposition.getL();\n-        for (int col = 0; col < m; col++) {\n-            final double[] bpCol = bp[col];\n-            for (int i = col + 1; i < m; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = l.getEntry(i, col);\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        final RealMatrix u = decomposition.getU();\n-        for (int col = m - 1; col >= 0; col--) {\n-            final double[] bpCol = bp[col];\n-            final double luDiag = u.getEntry(col, col);\n-            for (int j = 0; j < nColB; j++) {\n-                bpCol[j] /= luDiag;\n-            }\n-            for (int i = 0; i < col; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = u.getEntry(i, col);\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        return new RealMatrixImpl(bp, false);\n-\n-    }\n-\n-\n-    /**\n-     * Return the determinant of the matrix\n-     * @param decomposition decomposition of the matrix A\n-     * @return determinant of the matrix\n-     * @see #isNonSingular()\n-     */\n-    public double getDeterminant(final LUDecomposition decomposition) {\n-        if (decomposition.isSingular()) {\n-            return 0;\n-        } else {\n-            final int m = decomposition.getPivot().length;\n-            final RealMatrix u = decomposition.getU();\n-            double determinant = decomposition.evenPermutation() ? 1 : -1;\n-            for (int i = 0; i < m; i++) {\n-                determinant *= u.getEntry(i, i);\n-            }\n-            return determinant;\n-        }\n-    }\n-\n-    /**\n-     * Check if the decomposed matrix is non-singular.\n-     * @param decomposition decomposition of the matrix A\n-     * @return true if the decomposed matrix is non-singular\n-     */\n-    public boolean isNonSingular(final LUDecomposition decomposition) {\n-        return !decomposition.isSingular();\n-    }\n-\n-    /** Get the inverse of the decomposed matrix.\n-     * @param decomposition decomposition of the matrix A\n-     * @return inverse matrix\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealMatrix getInverse(final LUDecomposition decomposition)\n-        throws InvalidMatrixException {\n-        final int m = decomposition.getPivot().length;\n-        return solve(MatrixUtils.createRealIdentityMatrix(m), decomposition);\n-    }\n+    RealMatrix getInverse()\n+        throws InvalidMatrixException;\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/EigenSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Solver using eigen decomposition to solve A &times; X = B for symmetric matrices A.\n+ * <p>This class finds only exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0.</p>\n+ *   \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EigenSolver implements DecompositionSolver {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4339008311386325953L;\n+\n+    /** Underlying decomposition. */\n+    private final EigenDecomposition decomposition;\n+\n+    /**\n+     * Simple constructor.\n+     * @param decomposition decomposition to use\n+     */\n+    public EigenSolver(final EigenDecomposition decomposition) {\n+        this.decomposition = decomposition;\n+    }\n+\n+    /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+     * <p>This method only find exact linear solutions, i.e. solutions for\n+     * which ||A &times; X - B|| is exactly 0.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] bp = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+            final RealVector v = decomposition.getEigenvector(i);\n+            final double s = v.dotProduct(b) / eigenvalues[i];\n+            for (int j = 0; j < m; ++j) {\n+                bp[j] += s * v.getEntry(j);\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+     * <p>This method only find exact linear solutions, i.e. solutions for\n+     * which ||A &times; X - B|| is exactly 0.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        if (b.getDimension() != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] bp = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+            final RealVector v = decomposition.getEigenvector(i);\n+            final double s = v.dotProduct(b) / eigenvalues[i];\n+            for (int j = 0; j < m; ++j) {\n+                bp[j] += s * v.getEntry(j);\n+            }\n+        }\n+\n+        return new RealVectorImpl(bp, false);\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+     * <p>This method only find exact linear solutions, i.e. solutions for\n+     * which ||A &times; X - B|| is exactly 0.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+        final double[][] bp = new double[m][nColB];\n+        for (int k = 0; k < nColB; ++k) {\n+            for (int i = 0; i < m; ++i) {\n+                final RealVector v = decomposition.getEigenvector(i);\n+                double s = 0;\n+                for (int j = 0; j < m; ++j) {\n+                    s += v.getEntry(j) * b.getEntry(j, k);\n+                }\n+                s /= eigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j][k] += s * v.getEntry(j);\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @see #isNonSingular()\n+     */\n+    public double getDeterminant() {\n+        double determinant = 1;\n+        for (double lambda : decomposition.getEigenvalues()) {\n+            determinant *= lambda;\n+        }\n+        return determinant;\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular() {\n+        for (double lambda : decomposition.getEigenvalues()) {\n+            if (lambda == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** Get the inverse of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse()\n+        throws InvalidMatrixException {\n+\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        final double[][] invData = new double[m][m];\n+\n+        for (int i = 0; i < m; ++i) {\n+            final double[] invI = invData[i];\n+            for (int j = 0; j < m; ++j) {\n+                double invIJ = 0;\n+                for (int k = 0; k < m; ++k) {\n+                    final RealVector vK = decomposition.getEigenvector(k);\n+                    invIJ += vK.getEntry(i) * vK.getEntry(j) / eigenvalues[k];\n+                }\n+                invI[j] = invIJ;\n+            }\n+        }\n+        return new RealMatrixImpl(invData, false);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/LUSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Solver using LU decomposition to solve A &times; X = B for square matrices A.\n+ * <p>This class finds only exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0.</p>\n+ *   \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LUSolver implements DecompositionSolver {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -8775006035077527661L;\n+\n+    /** Underlying decomposition. */\n+    private final LUDecomposition decomposition;\n+\n+    /**\n+     * Simple constructor.\n+     * @param decomposition decomposition to use\n+     */\n+    public LUSolver(final LUDecomposition decomposition) {\n+        this.decomposition = decomposition;\n+    }\n+\n+    /** Solve the linear equation A &times; X = B for square matrices A.\n+     * <p>This method only find exact linear solutions, i.e. solutions for\n+     * which ||A &times; X - B|| is exactly 0.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final int[] pivot = decomposition.getPivot();\n+        final int m = pivot.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        if (decomposition.isSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] bp = new double[m];\n+\n+        // Apply permutations to b\n+        for (int row = 0; row < m; row++) {\n+            bp[row] = b[pivot[row]];\n+        }\n+\n+        // Solve LY = b\n+        final RealMatrix l = decomposition.getL();\n+        for (int col = 0; col < m; col++) {\n+            for (int i = col + 1; i < m; i++) {\n+                bp[i] -= bp[col] * l.getEntry(i, col);\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        final RealMatrix u = decomposition.getU();\n+        for (int col = m - 1; col >= 0; col--) {\n+            bp[col] /= u.getEntry(col, col);\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * u.getEntry(i, col);\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+\n+    /** Solve the linear equation A &times; X = B for square matrices A.\n+     * <p>This method only find exact linear solutions, i.e. solutions for\n+     * which ||A &times; X - B|| is exactly 0.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final int[] pivot = decomposition.getPivot();\n+        final int m = pivot.length;\n+        if (b.getDimension() != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        if (decomposition.isSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] bp = new double[m];\n+\n+        // Apply permutations to b\n+        for (int row = 0; row < m; row++) {\n+            bp[row] = b.getEntry(pivot[row]);\n+        }\n+\n+        // Solve LY = b\n+        final RealMatrix l = decomposition.getL();\n+        for (int col = 0; col < m; col++) {\n+            for (int i = col + 1; i < m; i++) {\n+                bp[i] -= bp[col] * l.getEntry(i, col);\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        final RealMatrix u = decomposition.getU();\n+        for (int col = m - 1; col >= 0; col--) {\n+            bp[col] /= u.getEntry(col, col);\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * u.getEntry(i, col);\n+            }\n+        }\n+\n+        return new RealVectorImpl(bp, false);\n+  \n+    }\n+\n+    /** Solve the linear equation A &times; X = B for square matrices A.\n+     * <p>This method only find exact linear solutions, i.e. solutions for\n+     * which ||A &times; X - B|| is exactly 0.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final int[] pivot = decomposition.getPivot();\n+        final int m = pivot.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (decomposition.isSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+\n+        // Apply permutations to b\n+        final double[][] bp = new double[m][nColB];\n+        for (int row = 0; row < m; row++) {\n+            final double[] bpRow = bp[row];\n+            final int pRow = pivot[row];\n+            for (int col = 0; col < nColB; col++) {\n+                bpRow[col] = b.getEntry(pRow, col);\n+            }\n+        }\n+\n+        // Solve LY = b\n+        final RealMatrix l = decomposition.getL();\n+        for (int col = 0; col < m; col++) {\n+            final double[] bpCol = bp[col];\n+            for (int i = col + 1; i < m; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = l.getEntry(i, col);\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        final RealMatrix u = decomposition.getU();\n+        for (int col = m - 1; col >= 0; col--) {\n+            final double[] bpCol = bp[col];\n+            final double luDiag = u.getEntry(col, col);\n+            for (int j = 0; j < nColB; j++) {\n+                bpCol[j] /= luDiag;\n+            }\n+            for (int i = 0; i < col; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = u.getEntry(i, col);\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @see #isNonSingular()\n+     */\n+    public double getDeterminant() {\n+        if (decomposition.isSingular()) {\n+            return 0;\n+        } else {\n+            final int m = decomposition.getPivot().length;\n+            final RealMatrix u = decomposition.getU();\n+            double determinant = decomposition.evenPermutation() ? 1 : -1;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= u.getEntry(i, i);\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular() {\n+        return !decomposition.isSingular();\n+    }\n+\n+    /** Get the inverse of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse()\n+        throws InvalidMatrixException {\n+        final int m = decomposition.getPivot().length;\n+        return solve(MatrixUtils.createRealIdentityMatrix(m));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/QRSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Class using QR decomposition to solve A &times; X = B in least square sense\n+ * for any matrices A.\n+ * <p>This class solve A &times; X = B in least squares sense: it finds X\n+ * such that ||A &times; X - B|| is minimal.</p>\n+ *   \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class QRSolver implements DecompositionSolver {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -579465076068393818L;\n+\n+    /** Underlying decomposition. */\n+    private final QRDecomposition decomposition;\n+\n+    /**\n+     * Simple constructor.\n+     * @param decomposition decomposition to use\n+     */\n+    public QRSolver(final QRDecomposition decomposition) {\n+        this.decomposition = decomposition;\n+    }\n+\n+    /** Solve the linear equation A &times; X = B in least square sense.\n+     * <p>The m&times;n matrix A may not be square, the solution X is\n+     * such that ||A &times; X - B|| is minimal.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (decomposition.getR().getRowDimension() != b.length) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");            \n+        }\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        // solve Q.y = b, using the fact Q is orthogonal\n+        final double[] y = decomposition.getQT().operate(b);\n+\n+        // solve triangular system R.x = y\n+        final RealMatrix r = decomposition.getR();\n+        final double[] x = new double[r.getColumnDimension()];\n+        System.arraycopy(y, 0, x, 0, r.getRowDimension());\n+        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n+            x[i] /= r.getEntry(i, i);\n+            final double lastX = x[i];\n+            for (int j = i - 1; j >= 0; --j) {\n+                x[j] -= lastX * r.getEntry(j, i);\n+            }\n+        }\n+\n+        return x;\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B in least square sense.\n+     * <p>The m&times;n matrix A may not be square, the solution X is\n+     * such that ||A &times; X - B|| is minimal.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getData()), false);\n+    }\n+\n+    /** Solve the linear equation A &times; X = B in least square sense.\n+     * <p>The m&times;n matrix A may not be square, the solution X is\n+     * such that ||A &times; X - B|| is minimal.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (decomposition.getR().getRowDimension() != b.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");            \n+        }\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        // solve Q.y = b, using the fact Q is orthogonal\n+        final RealMatrix y = decomposition.getQT().multiply(b);\n+\n+        // solve triangular system R.x = y\n+        final RealMatrix r = decomposition.getR();\n+        final double[][] xData =\n+            new double[r.getColumnDimension()][b.getColumnDimension()];\n+        for (int i = 0; i < r.getRowDimension(); ++i) {\n+            final double[] xi = xData[i];\n+            for (int k = 0; k < xi.length; ++k) {\n+                xi[k] = y.getEntry(i, k);\n+            }\n+        }\n+        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n+            final double rii = r.getEntry(i, i);\n+            final double[] xi = xData[i];\n+            for (int k = 0; k < xi.length; ++k) {\n+                xi[k] /= rii;\n+                final double lastX = xi[k];\n+                for (int j = i - 1; j >= 0; --j) {\n+                    xData[j][k] -= lastX * r.getEntry(j, i);\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(xData, false);\n+\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular() {\n+        final RealMatrix r = decomposition.getR();\n+        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n+        for (int i = 0; i < p; ++i) {\n+            if (r.getEntry(i, i) == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** Get the pseudo-inverse of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse()\n+        throws InvalidMatrixException {\n+        final RealMatrix r = decomposition.getR();\n+        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n+        return solve(MatrixUtils.createRealIdentityMatrix(p));\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n public class RealMatrixImpl implements RealMatrix, Serializable {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 4970229902484487012L;\n+    private static final long serialVersionUID = -391443069570048115L;\n \n     /** Entries of the matrix */\n     protected double data[][];\n \n-    /** Cached decomposition solver.\n+    /** Cached LU solver.\n      * @deprecated as of release 2.0, since all methods using this are deprecated\n      */\n-    private DecompositionSolver ds;\n-\n-    /** Cached LU decomposition.\n-     * @deprecated as of release 2.0, since all methods using this are deprecated\n-     */\n-    private LUDecomposition lu;\n+    private LUSolver lu;\n \n     /**\n      * Creates a matrix with no data\n                     \"row and column dimensions must be postive\");\n         }\n         data = new double[rowDimension][columnDimension];\n-        ds = null;\n+        lu = null;\n     }\n \n     /**\n      */\n     public RealMatrixImpl(double[][] d) {\n         copyIn(d);\n-        ds = null;\n+        lu = null;\n     }\n \n     /**\n             }       \n             data = d;\n         }\n-        ds = null;\n+        lu = null;\n     }\n \n     /**\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n         } \n \n-        ds = null;\n+        lu = null;\n \n     }\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public RealMatrix inverse() throws InvalidMatrixException {\n-        if (ds == null) {\n-            ds = new DecompositionSolver(this);\n-            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n-        }\n-        return ds.getInverse(lu);\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.getInverse();\n     }\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public double getDeterminant() throws InvalidMatrixException {\n-        if (ds == null) {\n-            ds = new DecompositionSolver(this);\n-            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n-        }\n-        return ds.getDeterminant(lu);\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.getDeterminant();\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     @Deprecated\n     public boolean isSingular() {\n-        if (ds == null) {\n-            ds = new DecompositionSolver(this);\n-            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n-        }\n-        return !ds.isNonSingular(lu);\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+       }\n+        return !lu.isNonSingular();\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     @Deprecated\n     public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        if (ds == null) {\n-            ds = new DecompositionSolver(this);\n-            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n-        }\n-        return ds.solve(b, lu);\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.solve(b);\n     }\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-        if (ds == null) {\n-            ds = new DecompositionSolver(this);\n-            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n-        }\n-        return ds.solve(b, lu);\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n+        }\n+        return lu.solve(b);\n     }\n \n     /**\n      */\n     @Deprecated\n     public void luDecompose() throws InvalidMatrixException {\n-        if (ds == null) {\n-            ds = new DecompositionSolver(this);\n-            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n+        if (lu == null) {\n+            lu = new LUSolver(new LUDecompositionImpl(this, MathUtils.SAFE_MIN));\n         }\n     }\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SingularValueSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Class using singular value decomposition decomposition to solve A &times;\n+ * X = B in least square sense for any matrices A.\n+ * <p>This class solve A &times; X = B in least squares sense: it finds X\n+ * such that ||A &times; X - B|| is minimal.</p>\n+ *   \n+ * @version $Revision: 723496 $ $Date: 2008-12-05 00:48:18 +0100 (ven., 05 d\u00e9c. 2008) $\n+ * @since 2.0\n+ */\n+public class SingularValueSolver implements DecompositionSolver {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -33167987924870528L;\n+\n+    /** Underlying decomposition. */\n+    private final SingularValueDecomposition decomposition;\n+\n+    /**\n+     * Simple constructor.\n+     * @param decomposition decomposition to use\n+     */\n+    public SingularValueSolver(final SingularValueDecomposition decomposition) {\n+        this.decomposition = decomposition;\n+    }\n+\n+    /** Solve the linear equation A &times; X = B in least square sense.\n+     * <p>The m&times;n matrix A may not be square, the solution X is\n+     * such that ||A &times; X - B|| is minimal.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final double[] singularValues = decomposition.getSingularValues();\n+        if (b.length != singularValues.length) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] w = decomposition.getUT().operate(b);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            w[i] /= si;\n+        }\n+        return decomposition.getV().operate(w);\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B in least square sense.\n+     * <p>The m&times;n matrix A may not be square, the solution X is\n+     * such that ||A &times; X - B|| is minimal.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final double[] singularValues = decomposition.getSingularValues();\n+        if (b.getDimension() != singularValues.length) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final RealVector w = decomposition.getUT().operate(b);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            w.set(i, w.getEntry(i) / si);\n+        }\n+        return decomposition.getV().operate(w);\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B in least square sense.\n+     * <p>The m&times;n matrix A may not be square, the solution X is\n+     * such that ||A &times; X - B|| is minimal.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final double[] singularValues = decomposition.getSingularValues();\n+        if (b.getRowDimension() != singularValues.length) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        final RealMatrixImpl w = (RealMatrixImpl) decomposition.getUT().multiply(b);\n+        final double[][] wData = w.getDataRef();\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si  = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            final double inv = 1.0 / si;\n+            final double[] wi = wData[i];\n+            for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                wi[j] *= inv;\n+            }\n+        }\n+        return decomposition.getV().multiply(w);\n+\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular() {\n+        return decomposition.getRank() == decomposition.getSingularValues().length;\n+    }\n+\n+    /** Get the pseudo-inverse of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse()\n+        throws InvalidMatrixException {\n+\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        return solve(MatrixUtils.createRealIdentityMatrix(decomposition.getSingularValues().length));\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n-import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUSolver;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n \n      */\n     protected RealMatrix getOmegaInverse() {\n         if (OmegaInverse == null) {\n-            DecompositionSolver solver = new DecompositionSolver(Omega);\n-            OmegaInverse = solver.getInverse(solver.luDecompose());\n+            OmegaInverse = new LUSolver(new LUDecompositionImpl(Omega)).getInverse();\n         }\n         return OmegaInverse;\n     }\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XT = X.transpose();\n         RealMatrix XTOIX = XT.multiply(OI).multiply(X);\n-        DecompositionSolver solver = new DecompositionSolver(XTOIX);\n-        return solver.getInverse(solver.luDecompose()).multiply(XT).multiply(OI).multiply(Y);\n+        RealMatrix inverse = new LUSolver(new LUDecompositionImpl(XTOIX)).getInverse();\n+        return inverse.multiply(XT).multiply(OI).multiply(Y);\n     }\n \n     /**\n     protected RealMatrix calculateBetaVariance() {\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n-        DecompositionSolver solver = new DecompositionSolver(XTOIX);\n-        return solver.getInverse(solver.luDecompose());\n+        return new LUSolver(new LUDecompositionImpl(XTOIX)).getInverse();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n-import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.LUSolver;\n import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n      */\n     protected RealMatrix calculateBetaVariance() {\n         RealMatrix XTX = X.transpose().multiply(X);\n-        DecompositionSolver solver = new DecompositionSolver(XTX);\n-        return solver.getInverse(solver.luDecompose());\n+        return new LUSolver(new LUDecompositionImpl(XTX)).getInverse();\n     }\n     \n \n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n             new RealMatrixImpl(new double[][] {\n                                    { 1.5 }\n                                }, false);\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15);\n     }\n \n                                    {       59.0, 12.0 },\n                                    { Double.NaN, 66.0 }\n                                }, false);\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15);\n     }\n                                    { Double.NaN,     8693.0,   7920.0 },\n                                    { Double.NaN, Double.NaN,  17300.0 }\n                                }, false);\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11);\n         assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11);\n         assertEquals( 3125.0, ed.getEigenvalue(2), 3.0e-11);\n                                    { Double.NaN, Double.NaN,       0.164, -0.048 },\n                                    { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n                                }, false);\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n         assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n                                    {  0.1152, -0.2304,  0.3088, -0.1344 },\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n                                }, false);\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n         assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n     /** test dimensions */\n     public void testDimensions() {\n         final int m = matrix.getRowDimension();\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         assertEquals(m, ed.getV().getRowDimension());\n         assertEquals(m, ed.getV().getColumnDimension());\n         assertEquals(m, ed.getD().getColumnDimension());\n \n     /** test eigenvalues */\n     public void testEigenvalues() {\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         double[] eigenValues = ed.getEigenvalues();\n         assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n         }\n         Arrays.sort(bigValues);\n         EigenDecomposition ed =\n-            new DecompositionSolver(createTestMatrix(r, bigValues)).eigenDecompose();\n+            new EigenDecompositionImpl(createTestMatrix(r, bigValues), MathUtils.SAFE_MIN);\n         double[] eigenValues = ed.getEigenvalues();\n         assertEquals(bigValues.length, eigenValues.length);\n         for (int i = 0; i < bigValues.length; ++i) {\n \n     /** test eigenvectors */\n     public void testEigenvectors() {\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n             double lambda = ed.getEigenvalue(i);\n             RealVector v  = ed.getEigenvector(i);\n \n     /** test A = VDVt */\n     public void testAEqualVDVt() {\n-        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n         RealMatrix v  = ed.getV();\n         RealMatrix d  = ed.getD();\n         RealMatrix vT = ed.getVT();\n \n     /** test that V is orthogonal */\n     public void testVOrthogonal() {\n-        RealMatrix v = new DecompositionSolver(matrix).eigenDecompose().getV();\n+        RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();\n         RealMatrix vTv = v.transpose().multiply(v);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n         assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n-    }\n-\n-    /** test non invertible matrix */\n-    public void testNonInvertible() {\n-        Random r = new Random(9994100315209l);\n-        DecompositionSolver ds =\n-            new DecompositionSolver(createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 }));\n-        EigenDecomposition ed = ds.eigenDecompose();\n-        assertFalse(ds.isNonSingular(ed));\n-        try {\n-            ds.getInverse(ed);\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test invertible matrix */\n-    public void testInvertible() {\n-        Random r = new Random(9994100315209l);\n-        RealMatrix m =\n-            createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n-        DecompositionSolver ds = new DecompositionSolver(m);\n-        EigenDecomposition ed = ds.eigenDecompose();\n-        assertTrue(ds.isNonSingular(ed));\n-        RealMatrix inverse = ds.getInverse(ed);\n-        RealMatrix error =\n-            m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));\n-        assertEquals(0, error.getNorm(), 4.0e-15);\n     }\n \n     /** test diagonal matrix */\n     public void testDiagonal() {\n         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n         RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n-        EigenDecomposition ed = new DecompositionSolver(m).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);\n         assertEquals(diagonal[0], ed.getEigenvalue(3), 2.0e-15);\n         assertEquals(diagonal[1], ed.getEigenvalue(2), 2.0e-15);\n         assertEquals(diagonal[2], ed.getEigenvalue(1), 2.0e-15);\n         assertEquals(diagonal[3], ed.getEigenvalue(0), 2.0e-15);\n     }\n \n-    /** test solve dimension errors */\n-    public void testSolveDimensionErrors() {\n-        DecompositionSolver ds = new DecompositionSolver(matrix);\n-        EigenDecomposition  ed = ds.eigenDecompose();\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n-        try {\n-            ds.solve(b, ed);\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(b.getColumn(0), ed);\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)), ed);\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve */\n-    public void testSolve() {\n-        RealMatrix m = new RealMatrixImpl(new double[][] {\n-                { 91,  5, 29, 32, 40, 14 },\n-                {  5, 34, -1,  0,  2, -1 },\n-                { 29, -1, 12,  9, 21,  8 },\n-                { 32,  0,  9, 14,  9,  0 },\n-                { 40,  2, 21,  9, 51, 19 },\n-                { 14, -1,  8,  0, 19, 14 }\n-        });\n-        DecompositionSolver ds = new DecompositionSolver(m);\n-        EigenDecomposition  ed = ds.eigenDecompose();\n-        assertEquals(184041, ds.getDeterminant(ed), 2.0e-8);\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n-                { 1561, 269, 188 },\n-                {   69, -21,  70 },\n-                {  739, 108,  63 },\n-                {  324,  86,  59 },\n-                { 1624, 194, 107 },\n-                {  796,  69,  36 }\n-        });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n-                { 1,   2, 1 },\n-                { 2,  -1, 2 },\n-                { 4,   2, 3 },\n-                { 8,  -1, 0 },\n-                { 16,  2, 0 },\n-                { 32, -1, 0 }\n-        });\n-\n-        // using RealMatrix\n-        assertEquals(0, ds.solve(b, ed).subtract(xRef).getNorm(), 2.0e-12);\n-\n-        // using double[]\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         new RealVectorImpl(ds.solve(b.getColumn(i), ed)).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         2.0e-11);\n-        }\n-\n-        // using RealMatrixImpl\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         ds.solve(b.getColumnVector(i), ed).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         2.0e-11);\n-        }\n-\n-        // using RealMatrix with an alternate implementation\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n-                         ds.solve(v, ed).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         2.0e-11);\n-        }\n-\n-    }\n-    \n     /**\n      * Matrix with eigenvalues {8, -1, -1}\n      */\n                 {2,  0,  2},\n                 {4,  2,  3}\n         }); \n-        EigenDecomposition ed = new DecompositionSolver(repeated).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);\n         checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n         checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n     }\n                 {1, 3, -4}, \n                 {-4, -4, 8}\n         });\n-        EigenDecomposition ed = new DecompositionSolver(distinct).eigenDecompose();\n+        EigenDecomposition ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);\n         checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n         checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n         checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n         matrix    = null;\n     }\n \n-    private RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n+    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n         final int n = eigenValues.length;\n         final RealMatrix v = createOrthogonalMatrix(r, n);\n         final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/EigenSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+public class EigenSolverTest extends TestCase {\n+\n+    private double[] refValues;\n+    private RealMatrix matrix;\n+\n+    public EigenSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EigenSolverTest.class);\n+        suite.setName(\"EigenSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test non invertible matrix */\n+    public void testNonInvertible() {\n+        Random r = new Random(9994100315209l);\n+        RealMatrix m =\n+            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });\n+        EigenSolver es = new EigenSolver(new EigenDecompositionImpl(m, MathUtils.SAFE_MIN));\n+        assertFalse(es.isNonSingular());\n+        try {\n+            es.getInverse();\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test invertible matrix */\n+    public void testInvertible() {\n+        Random r = new Random(9994100315209l);\n+        RealMatrix m =\n+            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n+        EigenSolver es = new EigenSolver(new EigenDecompositionImpl(m, MathUtils.SAFE_MIN));\n+        assertTrue(es.isNonSingular());\n+        RealMatrix inverse = es.getInverse();\n+        RealMatrix error =\n+            m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));\n+        assertEquals(0, error.getNorm(), 4.0e-15);\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        EigenSolver es = new EigenSolver(new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            es.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            es.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            es.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        RealMatrix m = new RealMatrixImpl(new double[][] {\n+                { 91,  5, 29, 32, 40, 14 },\n+                {  5, 34, -1,  0,  2, -1 },\n+                { 29, -1, 12,  9, 21,  8 },\n+                { 32,  0,  9, 14,  9,  0 },\n+                { 40,  2, 21,  9, 51, 19 },\n+                { 14, -1,  8,  0, 19, 14 }\n+        });\n+        EigenSolver  es = new EigenSolver(new EigenDecompositionImpl(m, MathUtils.SAFE_MIN));\n+        assertEquals(184041, es.getDeterminant(), 2.0e-8);\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1561, 269, 188 },\n+                {   69, -21,  70 },\n+                {  739, 108,  63 },\n+                {  324,  86,  59 },\n+                { 1624, 194, 107 },\n+                {  796,  69,  36 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 1,   2, 1 },\n+                { 2,  -1, 2 },\n+                { 4,   2, 3 },\n+                { 8,  -1, 0 },\n+                { 16,  2, 0 },\n+                { 32, -1, 0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, es.solve(b).subtract(xRef).getNorm(), 2.0e-12);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(es.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrixImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+    }\n+\n+    public void setUp() {\n+        refValues = new double[] {\n+                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);\n+    }\n+\n+    public void tearDown() {\n+        refValues = null;\n+        matrix    = null;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n         }\n     }\n \n-    /** test threshold impact */\n-    public void testThreshold() {\n-        final RealMatrix matrix = new RealMatrixImpl(new double[][] {\n-                                                       { 1.0, 2.0, 3.0},\n-                                                       { 2.0, 5.0, 3.0},\n-                                                       { 4.000001, 9.0, 9.0}\n-                                                     }, false);\n-        DecompositionSolver solver = new DecompositionSolver(matrix);\n-        assertFalse(solver.isNonSingular(solver.luDecompose(1.0e-5)));\n-        assertTrue(solver.isNonSingular(solver.luDecompose(1.0e-10)));\n-    }\n-\n     /** test PA = LU */\n     public void testPAEqualLU() {\n         RealMatrix matrix = new RealMatrixImpl(testData, false);\n         assertTrue(lu.isSingular());\n     }\n \n-    /** test solve dimension errors */\n-    public void testSolveDimensionErrors() {\n-        DecompositionSolver solver =\n-            new DecompositionSolver(new RealMatrixImpl(testData, false));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n-        try {\n-            solver.solve(b, solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumn(0), solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)),\n-                         solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve singularity errors */\n-    public void testSolveSingularityErrors() {\n-        DecompositionSolver solver =\n-            new DecompositionSolver(new RealMatrixImpl(singular, false));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n-        try {\n-            solver.solve(b, solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumn(0), solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumnVector(0), solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)),\n-                         solver.luDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve */\n-    public void testSolve() {\n-        DecompositionSolver solver =\n-            new DecompositionSolver(new RealMatrixImpl(testData, false));\n-        LUDecomposition lu = solver.luDecompose();\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n-                { 1, 0 }, { 2, -5 }, { 3, 1 }\n-        });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n-                { 19, -71 }, { -6, 22 }, { -2, 9 }\n-        });\n-\n-        // using RealMatrix\n-        assertEquals(0, solver.solve(b, lu).subtract(xRef).getNorm(), 1.0e-13);\n-\n-        // using double[]\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         new RealVectorImpl(solver.solve(b.getColumn(i), lu)).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-        // using RealVectorImpl\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         solver.solve(b.getColumnVector(i), lu).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-        // using RealVector with an alternate implementation\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n-                         solver.solve(v, lu).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-    }\n-\n     /** test matrices values */\n     public void testMatricesValues1() {\n        LUDecomposition lu =\n         \n     }\n \n-    /** test determinant */\n-    public void testDeterminant() {\n-        assertEquals( -1, getDeterminant(new RealMatrixImpl(testData, false)), 1.0e-15);\n-        assertEquals(-10, getDeterminant(new RealMatrixImpl(luData, false)), 1.0e-14);\n-        assertEquals(  0, getDeterminant(new RealMatrixImpl(singular, false)), 1.0e-17);\n-        assertEquals(  0, getDeterminant(new RealMatrixImpl(bigSingular, false)), 1.0e-10);\n-    }\n-\n-    private double getDeterminant(RealMatrix m) {\n-        DecompositionSolver ds = new DecompositionSolver(m);\n-        return ds.getDeterminant(ds.luDecompose());\n-    }\n-\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/LUSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class LUSolverTest extends TestCase {\n+    private double[][] testData = {\n+            { 1.0, 2.0, 3.0},\n+            { 2.0, 5.0, 3.0},\n+            { 1.0, 0.0, 8.0}\n+    };\n+    private double[][] luData = {\n+            { 2.0, 3.0, 3.0 },\n+            { 0.0, 5.0, 7.0 },\n+            { 6.0, 9.0, 8.0 }\n+    };\n+    \n+    // singular matrices\n+    private double[][] singular = {\n+            { 2.0, 3.0 },\n+            { 2.0, 3.0 }\n+    };\n+    private double[][] bigSingular = {\n+            { 1.0, 2.0,   3.0,    4.0 },\n+            { 2.0, 5.0,   3.0,    4.0 },\n+            { 7.0, 3.0, 256.0, 1930.0 },\n+            { 3.0, 7.0,   6.0,    8.0 }\n+    }; // 4th row = 1st + 2nd\n+\n+    public LUSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LUSolverTest.class);\n+        suite.setName(\"LUSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test threshold impact */\n+    public void testThreshold() {\n+        final RealMatrix matrix = new RealMatrixImpl(new double[][] {\n+                                                       { 1.0, 2.0, 3.0},\n+                                                       { 2.0, 5.0, 3.0},\n+                                                       { 4.000001, 9.0, 9.0}\n+                                                     }, false);\n+        assertFalse(new LUSolver(new LUDecompositionImpl(matrix, 1.0e-5)).isNonSingular());\n+        assertTrue(new LUSolver(new LUDecompositionImpl(matrix, 1.0e-10)).isNonSingular());\n+    }\n+\n+    /** test singular */\n+    public void testSingular() {\n+        LUSolver lu =\n+            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(testData, false)));\n+        assertTrue(lu.isNonSingular());\n+        lu = new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(singular, false)));\n+        assertFalse(lu.isNonSingular());\n+        lu = new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)));\n+        assertFalse(lu.isNonSingular());\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        LUSolver solver =\n+            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(testData, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        LUSolver solver =\n+            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(singular, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        LUSolver solver =\n+            new LUSolver(new LUDecompositionImpl(new RealMatrixImpl(testData, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1, 0 }, { 2, -5 }, { 3, 1 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 19, -71 }, { -6, 22 }, { -2, 9 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test determinant */\n+    public void testDeterminant() {\n+        assertEquals( -1, getDeterminant(new RealMatrixImpl(testData, false)), 1.0e-15);\n+        assertEquals(-10, getDeterminant(new RealMatrixImpl(luData, false)), 1.0e-14);\n+        assertEquals(  0, getDeterminant(new RealMatrixImpl(singular, false)), 1.0e-17);\n+        assertEquals(  0, getDeterminant(new RealMatrixImpl(bigSingular, false)), 1.0e-10);\n+    }\n+\n+    private double getDeterminant(RealMatrix m) {\n+        return new LUSolver(new LUDecompositionImpl(m)).getDeterminant();\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n     }\n \n-    /** test rank */\n-    public void testRank() {\n-        DecompositionSolver ds =\n-            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n-        assertTrue(ds.isNonSingular(ds.qrDecompose()));\n-\n-        ds = new DecompositionSolver(new RealMatrixImpl(testData3x3Singular, false));\n-        assertFalse(ds.isNonSingular(ds.qrDecompose()));\n-\n-        ds = new DecompositionSolver(new RealMatrixImpl(testData3x4, false));\n-        assertTrue(ds.isNonSingular(ds.qrDecompose()));\n-\n-        ds = new DecompositionSolver(new RealMatrixImpl(testData4x3, false));\n-        assertTrue(ds.isNonSingular(ds.qrDecompose()));\n-\n-    }\n-\n-    /** test solve dimension errors */\n-    public void testSolveDimensionErrors() {\n-        DecompositionSolver solver =\n-            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n-        try {\n-            solver.solve(b, solver.qrDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumn(0), solver.qrDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumnVector(0), solver.qrDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve rank errors */\n-    public void testSolveRankErrors() {\n-        DecompositionSolver solver =\n-            new DecompositionSolver(new RealMatrixImpl(testData3x3Singular, false));\n-        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n-        try {\n-            solver.solve(b, solver.qrDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumn(0), solver.qrDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            solver.solve(b.getColumnVector(0), solver.qrDecompose());\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve */\n-    public void testSolve() {\n-        DecompositionSolver ds =\n-            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n-        QRDecomposition qr = ds.qrDecompose();\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n-                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n-        });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n-                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n-        });\n-\n-        // using RealMatrix\n-        assertEquals(0, ds.solve(b, qr).subtract(xRef).getNorm(), 1.0e-13);\n-\n-        // using double[]\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         new RealVectorImpl(ds.solve(b.getColumn(i), qr)).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-        // using RealVectorImpl\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         ds.solve(b.getColumnVector(i), qr).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-        // using RealVector with an alternate implementation\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n-                         ds.solve(v, qr).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-    }\n-\n     /** test matrices values */\n     public void testMatricesValues() {\n-        DecompositionSolver ds =\n-            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n-        QRDecomposition qr = ds.qrDecompose();\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n         RealMatrix qRef = new RealMatrixImpl(new double[][] {\n                 { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n                 {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/QRSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class QRSolverTest extends TestCase {\n+    double[][] testData3x3NonSingular = { \n+            { 12, -51, 4 }, \n+            { 6, 167, -68 },\n+            { -4, 24, -41 }, };\n+\n+    double[][] testData3x3Singular = { \n+            { 1, 4, 7, }, \n+            { 2, 5, 8, },\n+            { 3, 6, 9, }, };\n+\n+    double[][] testData3x4 = { \n+            { 12, -51, 4, 1 }, \n+            { 6, 167, -68, 2 },\n+            { -4, 24, -41, 3 }, };\n+\n+    double[][] testData4x3 = { \n+            { 12, -51, 4, }, \n+            { 6, 167, -68, },\n+            { -4, 24, -41, }, \n+            { -5, 34, 7, }, };\n+\n+    public QRSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(QRSolverTest.class);\n+        suite.setName(\"QRSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test rank */\n+    public void testRank() {\n+        QRSolver solver =\n+            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)));\n+        assertTrue(solver.isNonSingular());\n+\n+        solver = new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false)));\n+        assertFalse(solver.isNonSingular());\n+\n+        solver = new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false)));\n+        assertTrue(solver.isNonSingular());\n+\n+        solver = new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false)));\n+        assertTrue(solver.isNonSingular());\n+\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        QRSolver solver =\n+            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve rank errors */\n+    public void testSolveRankErrors() {\n+        QRSolver solver =\n+            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        QRSolver solver =\n+            new QRSolver(new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n     /** test transpose */\n     public void testTranspose() {\n         RealMatrix m = new RealMatrixImpl(testData); \n-        DecompositionSolver ds1 = new DecompositionSolver(m);\n-        RealMatrix mIT = ds1.getInverse(ds1.luDecompose()).transpose();\n-        DecompositionSolver ds2 = new DecompositionSolver(m.transpose());\n-        RealMatrix mTI = ds2.getInverse(ds2.luDecompose());\n+        RealMatrix mIT = new LUSolver(new LUDecompositionImpl(m)).getInverse().transpose();\n+        RealMatrix mTI = new LUSolver(new LUDecompositionImpl(m.transpose())).getInverse();\n         assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = new RealMatrixImpl(testData2);\n         RealMatrix mt = new RealMatrixImpl(testData2T);\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        DecompositionSolver ds1 = new DecompositionSolver(p);\n-        RealMatrix pInverse = ds1.getInverse(ds1.luDecompose()); \n+        RealMatrix pInverse = new LUSolver(new LUDecompositionImpl(p)).getInverse(); \n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n         \n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new RealMatrixImpl(coefficientsData);\n         double[] constants = {1, -2, 1};\n-        DecompositionSolver ds2 = new DecompositionSolver(coefficients);\n-        double[] solution = ds2.solve(constants, ds2.luDecompose());\n+        double[] solution = new LUSolver(new LUDecompositionImpl(coefficients)).solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n         assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n--- a/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n         assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);\n     }\n \n-    /** test solve dimension errors */\n-    public void testSolveDimensionErrors() {\n-        DecompositionSolver ds =\n-            new DecompositionSolver(new RealMatrixImpl(testSquare, false));\n-        SingularValueDecomposition svd = ds.singularDecompose();\n-        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n-        try {\n-            ds.solve(b, svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(b.getColumn(0), svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)), svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (IllegalArgumentException iae) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve singularity errors */\n-    public void testSolveSingularityErrors() {\n-        DecompositionSolver ds =\n-            new DecompositionSolver(new RealMatrixImpl(new double[][] {\n-                                                           { 1.0, 0.0 },\n-                                                           { 0.0, 0.0 }\n-                                                       }, false));\n-        SingularValueDecomposition svd = ds.singularDecompose();\n-        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n-        try {\n-            ds.solve(b, svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(b.getColumn(0), svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(b.getColumnVector(0), svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-        try {\n-            ds.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)), svd);\n-            fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n-    /** test solve */\n-    public void testSolve() {\n-        DecompositionSolver ds =\n-            new DecompositionSolver(new RealMatrixImpl(testSquare, false));\n-        SingularValueDecomposition svd = ds.singularDecompose();\n-        RealMatrix b = new RealMatrixImpl(new double[][] {\n-                { 1, 2, 3 }, { 0, -5, 1 }\n-        });\n-        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n-                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },\n-                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }\n-        });\n-\n-        // using RealMatrix\n-        assertEquals(0, ds.solve(b, svd).subtract(xRef).getNorm(), normTolerance);\n-\n-        // using double[]\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         new RealVectorImpl(ds.solve(b.getColumn(i), svd)).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-        // using RealMatrixImpl\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            assertEquals(0,\n-                         ds.solve(b.getColumnVector(i), svd).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-        // using RealMatrix with an alternate implementation\n-        for (int i = 0; i < b.getColumnDimension(); ++i) {\n-            RealVectorImplTest.RealVectorTestImpl v =\n-                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n-            assertEquals(0,\n-                         ds.solve(v, svd).subtract(xRef.getColumnVector(i)).getNorm(),\n-                         1.0e-13);\n-        }\n-\n-    }\n-\n     /** test matrices values */\n     public void testMatricesValues1() {\n        SingularValueDecomposition svd =\n \n         // check values against known references\n         SingularValueDecomposition svd =\n-            new DecompositionSolver(new RealMatrixImpl(testNonSquare, false)).singularDecompose();\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(testNonSquare, false));\n         RealMatrix u = svd.getU();\n         assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n         RealMatrix s = svd.getS();\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/SingularValueSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class SingularValueSolverTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public SingularValueSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SingularValueSolverTest.class);\n+        suite.setName(\"SingularValueSolver Tests\");\n+        return suite;\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        SingularValueSolver solver =\n+            new SingularValueSolver(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        RealMatrix m =\n+            new RealMatrixImpl(new double[][] {\n+                                   { 1.0, 0.0 },\n+                                   { 0.0, 0.0 }\n+                               }, false);\n+        SingularValueSolver solver = new SingularValueSolver(new SingularValueDecompositionImpl(m));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        SingularValueSolver solver =\n+            new SingularValueSolver(new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false)));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1, 2, 3 }, { 0, -5, 1 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 },\n+                { 19.0 / 25.0,   78.0 / 25.0,  49.0 / 25.0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(solver.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealMatrixImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test condition number */\n+    public void testConditionNumber() {\n+        SingularValueDecompositionImpl svd =\n+            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        assertEquals(3.0, svd.getConditionNumber(), 1.0e-15);\n+    }\n+\n+}", "timestamp": 1228485950, "metainfo": ""}