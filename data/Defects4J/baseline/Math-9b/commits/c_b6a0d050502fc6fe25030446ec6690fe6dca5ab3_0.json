{"sha": "b6a0d050502fc6fe25030446ec6690fe6dca5ab3", "log": "added a top-level AbstractIntegrator class to manage events and step handlers  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.DummyStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * Base class managing common boilerplate for all integrators.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n+\n+    /** Name of the method. */\n+    private final String name;\n+\n+    /** Step handler. */\n+    protected StepHandler handler;\n+\n+    /** Current step start time. */\n+    protected double stepStart;\n+\n+    /** Current stepsize. */\n+    protected double stepSize;\n+\n+    /** Events handlers manager. */\n+    protected CombinedEventsManager eventsHandlersManager;\n+\n+    /** Build an instance.\n+     * @param name name of the method\n+     */\n+    public AbstractIntegrator(final String name) {\n+        this.name = name;\n+        handler = DummyStepHandler.getInstance();\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        eventsHandlersManager = new CombinedEventsManager();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setStepHandler(final StepHandler handler) {\n+        this.handler = handler;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public StepHandler getStepHandler() {\n+        return handler;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addEventHandler(final EventHandler function,\n+                                final double maxCheckInterval,\n+                                final double convergence,\n+                                final int maxIterationCount) {\n+        eventsHandlersManager.addEventHandler(function, maxCheckInterval,\n+                                              convergence, maxIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<EventHandler> getEventsHandlers() {\n+        return eventsHandlersManager.getEventsHandlers();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void clearEventsHandlers() {\n+        eventsHandlersManager.clearEventsHandlers();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getCurrentStepStart() {\n+        return stepStart;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getCurrentSignedStepsize() {\n+        return stepSize;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n import java.util.List;\n import java.io.Serializable;\n \n+import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+/**\n+ * This abstract class holds the common part of all adaptive\n+ * stepsize integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These algorithms perform integration with stepsize control, which\n+ * means the user does not specify the integration step but rather a\n+ * tolerance on error. The error threshold is computed as\n+ * <pre>\n+ * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))\n+ * </pre>\n+ * where absTol_i is the absolute tolerance for component i of the\n+ * state vector and relTol_i is the relative tolerance for the same\n+ * component. The user can also use only two scalar values absTol and\n+ * relTol which will be used for all components.</p>\n+ *\n+ * <p>If the estimated error for ym+1 is such that\n+ * <pre>\n+ * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n+ * </pre>\n+ *\n+ * (where n is the state vector dimension) then the step is accepted,\n+ * otherwise the step is rejected and a new attempt is made with a new\n+ * stepsize.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public abstract class AdaptiveStepsizeIntegrator\n+  extends AbstractIntegrator {\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param name name of the method\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(final String name,\n+                                    final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n+\n+    super(name);\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n+    this.scalRelativeTolerance = scalRelativeTolerance;\n+    this.vecAbsoluteTolerance  = null;\n+    this.vecRelativeTolerance  = null;\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param name name of the method\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(final String name,\n+                                    final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n+\n+    super(name);\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = 0;\n+    this.scalRelativeTolerance = 0;\n+    this.vecAbsoluteTolerance  = vecAbsoluteTolerance;\n+    this.vecRelativeTolerance  = vecRelativeTolerance;\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Set the initial step size.\n+   * <p>This method allows the user to specify an initial positive\n+   * step size instead of letting the integrator guess it by\n+   * itself. If this method is not called before integration is\n+   * started, the initial step size will be estimated by the\n+   * integrator.</p>\n+   * @param initialStepSize initial step size to use (must be positive even\n+   * for backward integration ; providing a negative value or a value\n+   * outside of the min/max step interval will lead the integrator to\n+   * ignore the value and compute the initial step size by itself)\n+   */\n+  public void setInitialStepSize(final double initialStepSize) {\n+    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+      initialStep = -1.0;\n+    } else {\n+      initialStep = initialStepSize;\n+    }\n+  }\n+\n+  /** Perform some sanity checks on the integration parameters.\n+   * @param equations differential equations set\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param t target time for the integration\n+   * @param y placeholder where to put the state vector\n+   * @exception IntegratorException if some inconsistency is detected\n+   */\n+  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                              final double t0, final double[] y0, final double t, final double[] y)\n+      throws IntegratorException {\n+      if (equations.getDimension() != y0.length) {\n+          throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n+                                        \" initial state vector has dimension {1}\",\n+                                        new Object[] {\n+                                          Integer.valueOf(equations.getDimension()),\n+                                          Integer.valueOf(y0.length)\n+                                        });\n+      }\n+      if (equations.getDimension() != y.length) {\n+          throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n+                                        \" final state vector has dimension {1}\",\n+                                        new Object[] {\n+                                          Integer.valueOf(equations.getDimension()),\n+                                          Integer.valueOf(y.length)\n+                                        });\n+      }\n+      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n+          throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n+                                        \" absolute tolerance vector has dimension {1}\",\n+                                        new Object[] {\n+                                          Integer.valueOf(y0.length),\n+                                          Integer.valueOf(vecAbsoluteTolerance.length)\n+                                        });\n+      }\n+      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n+          throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n+                                        \" relative tolerance vector has dimension {1}\",\n+                                        new Object[] {\n+                                          Integer.valueOf(y0.length),\n+                                          Integer.valueOf(vecRelativeTolerance.length)\n+                                        });\n+      }\n+      if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+        throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                      new Object[] { Double.valueOf(Math.abs(t - t0)) });\n+      }\n+      \n+  }\n+\n+  /** Initialize the integration step.\n+   * @param equations differential equations set\n+   * @param forward forward integration indicator\n+   * @param order order of the method\n+   * @param scale scaling vector for the state vector\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param yDot0 first time derivative of y0\n+   * @param y1 work array for a state vector\n+   * @param yDot1 work array for the first time derivative of y1\n+   * @return first integration step\n+   * @exception DerivativeException this exception is propagated to\n+   * the caller if the underlying user function triggers one\n+   */\n+  public double initializeStep(final FirstOrderDifferentialEquations equations,\n+                               final boolean forward, final int order, final double[] scale,\n+                               final double t0, final double[] y0, final double[] yDot0,\n+                               final double[] y1, final double[] yDot1)\n+      throws DerivativeException {\n+\n+    if (initialStep > 0) {\n+      // use the user provided value\n+      return forward ? initialStep : -initialStep;\n+    }\n+\n+    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n+    // this guess will be used to perform an Euler step\n+    double ratio;\n+    double yOnScale2 = 0;\n+    double yDotOnScale2 = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = y0[j] / scale[j];\n+      yOnScale2    += ratio * ratio;\n+      ratio         = yDot0[j] / scale[j];\n+      yDotOnScale2 += ratio * ratio;\n+    }\n+\n+    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n+               1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    // perform an Euler step using the preceding rough guess\n+    for (int j = 0; j < y0.length; ++j) {\n+      y1[j] = y0[j] + h * yDot0[j];\n+    }\n+    equations.computeDerivatives(t0 + h, y1, yDot1);\n+\n+    // estimate the second derivative of the solution\n+    double yDDotOnScale = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n+      yDDotOnScale += ratio * ratio;\n+    }\n+    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n+\n+    // step size is computed such that\n+    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n+    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    final double h1 = (maxInv2 < 1.0e-15) ?\n+                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n+                      Math.pow(0.01 / maxInv2, 1.0 / order);\n+    h = Math.min(100.0 * Math.abs(h), h1);\n+    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n+    if (h < getMinStep()) {\n+      h = getMinStep();\n+    }\n+    if (h > getMaxStep()) {\n+      h = getMaxStep();\n+    }\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  /** Filter the integration step.\n+   * @param h signed step\n+   * @param acceptSmall if true, steps smaller than the minimal value\n+   * are silently increased up to this value, if false such small\n+   * steps generate an exception\n+   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n+   * @exception IntegratorException if the step is too small and acceptSmall is false\n+   */\n+  protected double filterStep(final double h, final boolean acceptSmall)\n+    throws IntegratorException {\n+\n+      double filteredH = h;\n+      if (Math.abs(h) < minStep) {\n+          if (acceptSmall) {\n+              filteredH = (filteredH < 0) ? -minStep : minStep;\n+          } else {\n+              throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n+                                            \" integration needs {1}\",\n+                                            new Object[] {\n+                                                Double.valueOf(minStep),\n+                                                Double.valueOf(Math.abs(h))\n+                                            });\n+          }\n+      }\n+\n+      if (filteredH > maxStep) {\n+          filteredH = maxStep;\n+      } else if (h < -maxStep) {\n+          filteredH = -maxStep;\n+      }\n+\n+      return filteredH;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract double integrate (FirstOrderDifferentialEquations equations,\n+                                    double t0, double[] y0,\n+                                    double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+  /** {@inheritDoc} */\n+  public double getCurrentStepStart() {\n+    return stepStart;\n+  }\n+\n+  /** Reset internal state to dummy values. */\n+  protected void resetInternalState() {\n+    stepStart = Double.NaN;\n+    stepSize  = Math.sqrt(minStep * maxStep);\n+  }\n+\n+  /** Get the minimal step.\n+   * @return minimal step\n+   */\n+  public double getMinStep() {\n+    return minStep;\n+  }\n+\n+  /** Get the maximal step.\n+   * @return maximal step\n+   */\n+  public double getMaxStep() {\n+    return maxStep;\n+  }\n+\n+  /** Minimal step. */\n+  private double minStep;\n+\n+  /** Maximal step. */\n+  private double maxStep;\n+\n+  /** User supplied initial step. */\n+  private double initialStep;\n+\n+  /** Allowed absolute scalar error. */\n+  protected double scalAbsoluteTolerance;\n+\n+  /** Allowed relative scalar error. */\n+  protected double scalRelativeTolerance;\n+\n+  /** Allowed absolute vectorial error. */\n+  protected double[] vecAbsoluteTolerance;\n+\n+  /** Allowed relative vectorial error. */\n+  protected double[] vecRelativeTolerance;\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n   extends RungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -8987762131146169612L;\n-\n-  /** Integrator method name. */\n-  private static final String methodName = \"classical Runge-Kutta\";\n+    private static final long serialVersionUID = 3710070023793519840L;\n \n   /** Time steps Butcher array. */\n   private static final double[] c = {\n    * @param step integration step\n    */\n   public ClassicalRungeKuttaIntegrator(final double step) {\n-    super(c, a, b, new ClassicalRungeKuttaStepInterpolator(), step);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n+    super(\"classical Runge-Kutta\", c, a, b,\n+          new ClassicalRungeKuttaStepInterpolator(), step);\n   }\n \n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n   extends EmbeddedRungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -5346655668732043826L;\n+  private static final long serialVersionUID = -7932553613600031791L;\n \n   /** Integrator method name. */\n-  private static final String methodName = \"Dormand-Prince 5(4)\";\n+  private static final String METHOD_NAME = \"Dormand-Prince 5(4)\";\n \n   /** Time steps Butcher array. */\n   private static final double[] staticC = {\n   public DormandPrince54Integrator(final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n-    super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n \n   public DormandPrince54Integrator(final double minStep, final double maxStep,\n                                    final double[] vecAbsoluteTolerance,\n                                    final double[] vecRelativeTolerance) {\n-    super(true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n   }\n \n   /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n   extends EmbeddedRungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = 6175337145090754336L;\n+  private static final long serialVersionUID = -8627142100635188441L;\n \n   /** Integrator method name. */\n-  private static final String methodName = \"Dormand-Prince 8 (5, 3)\";\n+  private static final String METHOD_NAME = \"Dormand-Prince 8 (5, 3)\";\n \n   /** Time steps Butcher array. */\n   private static final double[] staticC = {\n   public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                     final double scalAbsoluteTolerance,\n                                     final double scalRelativeTolerance) {\n-    super(true, staticC, staticA, staticB,\n+    super(METHOD_NAME, true, staticC, staticA, staticB,\n           new DormandPrince853StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n   public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                     final double[] vecAbsoluteTolerance,\n                                     final double[] vecRelativeTolerance) {\n-    super(true, staticC, staticA, staticB,\n+    super(METHOD_NAME, true, staticC, staticA, staticB,\n           new DormandPrince853StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n   }\n \n   /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n   extends AdaptiveStepsizeIntegrator {\n \n   /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param name name of the method\n    * @param fsal indicate that the method is an <i>fsal</i>\n    * @param c time steps from Butcher array (without the first zero)\n    * @param a internal weights from Butcher array (without the first empty row)\n    * @param scalAbsoluteTolerance allowed absolute error\n    * @param scalRelativeTolerance allowed relative error\n    */\n-  protected EmbeddedRungeKuttaIntegrator(final boolean fsal,\n+  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                          final double[] c, final double[][] a, final double[] b,\n                                          final RungeKuttaStepInterpolator prototype,\n                                          final double minStep, final double maxStep,\n                                          final double scalAbsoluteTolerance,\n                                          final double scalRelativeTolerance) {\n \n-    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n \n     this.fsal      = fsal;\n     this.c         = c;\n   }\n \n   /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param name name of the method\n    * @param fsal indicate that the method is an <i>fsal</i>\n    * @param c time steps from Butcher array (without the first zero)\n    * @param a internal weights from Butcher array (without the first empty row)\n    * @param vecAbsoluteTolerance allowed absolute error\n    * @param vecRelativeTolerance allowed relative error\n    */\n-  protected EmbeddedRungeKuttaIntegrator(final boolean fsal,\n+  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                          final double[] c, final double[][] a, final double[] b,\n                                          final RungeKuttaStepInterpolator prototype,\n                                          final double   minStep, final double maxStep,\n                                          final double[] vecAbsoluteTolerance,\n                                          final double[] vecRelativeTolerance) {\n \n-    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n \n     this.fsal      = fsal;\n     this.c         = c;\n     setMaxGrowth(10.0);\n \n   }\n-\n-  /** {@inheritDoc} */\n-  public abstract String getName();\n \n   /** Get the order of the method.\n    * @return order of the method\n--- a/src/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n   extends RungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -3378479003330094013L;\n-\n-  /** Integrator method name. */\n-  private static final String methodName = \"Euler\";\n+  private static final long serialVersionUID = 1828811360890387657L;\n \n   /** Time steps Butcher array. */\n   private static final double[] c = {\n    * @param step integration step\n    */\n   public EulerIntegrator(final double step) {\n-    super(c, a, b, new EulerStepInterpolator(), step);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n+    super(\"Euler\", c, a, b, new EulerStepInterpolator(), step);\n   }\n \n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n   extends RungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -3270987073897562791L;\n-\n-  /** Integrator method name. */\n-  private static final String methodName = \"Gill\";\n+  private static final long serialVersionUID = 5566682259665027132L;\n \n   /** Time steps Butcher array. */\n   private static final double[] c = {\n    * @param step integration step\n    */\n   public GillIntegrator(final double step) {\n-    super(c, a, b, new GillStepInterpolator(), step);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n+    super(\"Gill\", c, a, b, new GillStepInterpolator(), step);\n   }\n \n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n   extends AdaptiveStepsizeIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -1263159462413447366L;\n+  private static final long serialVersionUID = 7364884082146325264L;\n \n   /** Integrator method name. */\n-  private static final String methodName = \"Gragg-Bulirsch-Stoer\";\n+  private static final String METHOD_NAME = \"Gragg-Bulirsch-Stoer\";\n \n   /** Simple constructor.\n    * Build a Gragg-Bulirsch-Stoer integrator with the given step\n   public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n                                       final double scalAbsoluteTolerance,\n                                       final double scalRelativeTolerance) {\n-    super(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+    super(METHOD_NAME, minStep, maxStep,\n+          scalAbsoluteTolerance, scalRelativeTolerance);\n     denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n   public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n                                       final double[] vecAbsoluteTolerance,\n                                       final double[] vecRelativeTolerance) {\n-    super(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+    super(METHOD_NAME, minStep, maxStep,\n+          vecAbsoluteTolerance, vecRelativeTolerance);\n     denseOutput = (handler.requiresDenseOutput() || (! eventsHandlersManager.isEmpty()));\n     setStabilityCheck(true, -1, -1, -1);\n     setStepsizeControl(-1, -1, -1, -1);\n       this.mudif = mudif;\n     }\n \n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n   }\n \n   /** Update scaling array.\n--- a/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n   extends EmbeddedRungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -1499486749907617454L;\n+  private static final long serialVersionUID = 1462328766749870097L;\n \n   /** Integrator method name. */\n-  private static final String methodName = \"Higham-Hall 5(4)\";\n+  private static final String METHOD_NAME = \"Higham-Hall 5(4)\";\n \n   /** Time steps Butcher array. */\n   private static final double[] staticC = {\n   public HighamHall54Integrator(final double minStep, final double maxStep,\n                                 final double scalAbsoluteTolerance,\n                                 final double scalRelativeTolerance) {\n-    super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n           minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n   }\n \n   public HighamHall54Integrator(final double minStep, final double maxStep,\n                                 final double[] vecAbsoluteTolerance,\n                                 final double[] vecRelativeTolerance) {\n-    super(false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n           minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n   }\n \n   /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n   extends RungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = 1871083451154005310L;\n-\n-  /** Integrator method name. */\n-  private static final String methodName = \"midpoint\";\n+  private static final long serialVersionUID = -7690774342890000483L;\n \n   /** Time steps Butcher array. */\n   private static final double[] c = {\n    * @param step integration step\n    */\n   public MidpointIntegrator(final double step) {\n-    super(c, a, b, new MidpointStepInterpolator(), step);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n+    super(\"midpoint\", c, a, b, new MidpointStepInterpolator(), step);\n   }\n \n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import java.util.Collection;\n-\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n-import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n-import org.apache.commons.math.ode.events.EventHandler;\n-import org.apache.commons.math.ode.events.CombinedEventsManager;\n import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n-import org.apache.commons.math.ode.sampling.DummyStepHandler;\n import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n-import org.apache.commons.math.ode.sampling.StepHandler;\n \n /**\n  * This class implements the common part of all fixed step Runge-Kutta\n  * @since 1.2\n  */\n \n-public abstract class RungeKuttaIntegrator\n-  implements FirstOrderIntegrator {\n+public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n \n   /** Simple constructor.\n    * Build a Runge-Kutta integrator with the given\n    * step. The default step handler does nothing.\n+   * @param name name of the method\n    * @param c time steps from Butcher array (without the first zero)\n    * @param a internal weights from Butcher array (without the first empty row)\n    * @param b propagation weights for the high order method from Butcher array\n    * @param prototype prototype of the step interpolator to use\n    * @param step integration step\n    */\n-  protected RungeKuttaIntegrator(final double[] c, final double[][] a, final double[] b,\n+  protected RungeKuttaIntegrator(final String name,\n+                                 final double[] c, final double[][] a, final double[] b,\n                                  final RungeKuttaStepInterpolator prototype,\n                                  final double step) {\n+    super(name);\n     this.c          = c;\n     this.a          = a;\n     this.b          = b;\n     this.prototype  = prototype;\n     this.step       = step;\n-    handler         = DummyStepHandler.getInstance();\n-    eventsHandlersManager = new CombinedEventsManager();\n-    resetInternalState();\n-  }\n-\n-  /** {@inheritDoc} */\n-  public abstract String getName();\n-\n-  /** {@inheritDoc} */\n-  public void setStepHandler (final StepHandler handler) {\n-    this.handler = handler;\n-  }\n-\n-  /** {@inheritDoc} */\n-  public StepHandler getStepHandler() {\n-    return handler;\n-  }\n-\n-  /** {@inheritDoc} */\n-  public void addEventHandler(final EventHandler function,\n-                              final double maxCheckInterval,\n-                              final double convergence,\n-                              final int maxIterationCount) {\n-    eventsHandlersManager.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public Collection<EventHandler> getEventsHandlers() {\n-      return eventsHandlersManager.getEventsHandlers();\n-  }\n-\n-  /** {@inheritDoc} */\n-  public void clearEventsHandlers() {\n-      eventsHandlersManager.clearEventsHandlers();\n   }\n \n   /** Perform some sanity checks on the integration parameters.\n     }\n \n     final double stopTime = stepStart;\n-    resetInternalState();\n-    return stopTime;\n-\n-  }\n-\n-  /** {@inheritDoc} */\n-  public double getCurrentStepStart() {\n-    return stepStart;\n-  }\n-\n-  /** {@inheritDoc} */\n-  public double getCurrentSignedStepsize() {\n-    return stepSize;\n-  }\n-\n-  /** Reset internal state to dummy values. */\n-  private void resetInternalState() {\n     stepStart = Double.NaN;\n     stepSize  = Double.NaN;\n+    return stopTime;\n+\n   }\n \n   /** Time steps from Butcher array (without the first zero). */\n   /** Integration step. */\n   private double step;\n \n-  /** Step handler. */\n-  private StepHandler handler;\n-\n-  /** Events handlers manager. */\n-  protected CombinedEventsManager eventsHandlersManager;\n-\n-  /** Current step start time. */\n-  private double stepStart;\n-\n-  /** Current stepsize. */\n-  private double stepSize;\n-\n }\n--- a/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n   extends RungeKuttaIntegrator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = -5738562635641912717L;\n-\n-  /** Integrator method name. */\n-  private static final String methodName = \"3/8\";\n+  private static final long serialVersionUID = -2480984691453028021L;\n \n   /** Time steps Butcher array. */\n   private static final double[] c = {\n    * @param step integration step\n    */\n   public ThreeEighthesIntegrator(final double step) {\n-    super(c, a, b, new ThreeEighthesStepInterpolator(), step);\n-  }\n-\n-  /** {@inheritDoc} */\n-  public String getName() {\n-    return methodName;\n+    super(\"3/8\", c, a, b, new ThreeEighthesStepInterpolator(), step);\n   }\n \n }\n--- a/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n--- a/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import org.apache.commons.math.ode.AdaptiveStepsizeIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;", "timestamp": 1214915780, "metainfo": ""}