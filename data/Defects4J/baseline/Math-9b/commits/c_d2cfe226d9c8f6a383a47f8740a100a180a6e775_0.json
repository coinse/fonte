{"sha": "d2cfe226d9c8f6a383a47f8740a100a180a6e775", "log": "MATH-637 Several modifications to avoid some potential pitfalls of micro-benchmarking: Attempt to run GC preemptively, keep track of the computation result, output variance of the run times.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math/PerfTestUtils.java\n+++ b/src/test/java/org/apache/commons/math/PerfTestUtils.java\n  */\n package org.apache.commons.math;\n \n-import org.apache.commons.math.analysis.function.Add;\n-import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.analysis.FunctionUtils;\n+import java.util.concurrent.Callable;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n \n /**\n  * Simple benchmarking utilities.\n public class PerfTestUtils {\n     /** Nanoseconds to milliseconds conversion factor ({@value}). */\n     public static final double NANO_TO_MILLI = 1e-6;\n+    /** Default number of code repeat per timed block. */\n+    private static final int DEFAULT_REPEAT_CHUNK = 1000;\n+    /** Default number of code repeats for computing the average run time. */\n+    private static final int DEFAULT_REPEAT_STAT = 10000;\n \n     /**\n      * Timing.\n      *\n      * @param repeatChunk Each timing measurement will done done for that\n      * number of repeats of the code.\n-     * @param repeatStat Timing will be averaged over that number of runs. \n-     * @param methods Code being timed.\n-     * @return for each of the given {@code methods}, the averaged time (in\n-     * milliseconds) taken by a call to {@code run}.\n-     */\n-    public static double[] time(int repeatChunk,\n-                                int repeatStat,\n-                                Runnable ... methods) {\n+     * @param repeatStat Timing will be averaged over that number of runs.\n+     * @param runGC Call {@code System.gc()} between each timed block. When\n+     * set to {@code true}, the test will run much slower.\n+     * @param methods Codes being timed.\n+     * @return for each of the given {@code methods}, a statistics of the\n+     * average times (in milliseconds) taken by a single call to the\n+     * {@code call} method (i.e. the time taken by each timed block divided\n+     * by {@code repeatChunk}).\n+     */\n+    public static DescriptiveStatistics[] time(int repeatChunk,\n+                                               int repeatStat,\n+                                               boolean runGC,\n+                                               Callable<Double> ... methods) {\n+        final double[][][] times = timesAndResults(repeatChunk,\n+                                                   repeatStat,\n+                                                   runGC,\n+                                                   methods);\n+\n+        final int len = methods.length;\n+        final DescriptiveStatistics[] stats = new DescriptiveStatistics[len];\n+        for (int j = 0; j < len; j++) {\n+            final DescriptiveStatistics s = new DescriptiveStatistics();\n+            for (int k = 0; k < repeatStat; k++) {\n+                s.addValue(times[j][k][0]);\n+            }\n+            stats[j] = s;\n+        }\n+\n+        return stats;\n+    }\n+\n+    /**\n+     * Timing.\n+     *\n+     * @param repeatChunk Each timing measurement will done done for that\n+     * number of repeats of the code.\n+     * @param repeatStat Timing will be averaged over that number of runs.\n+     * @param runGC Call {@code System.gc()} between each timed block. When\n+     * set to {@code true}, the test will run much slower.\n+     * @param methods Codes being timed.\n+     * @return for each of the given {@code methods} (first dimension), and\n+     * each of the {@code repeatStat} runs (second dimension):\n+     * <ul>\n+     *  <li>\n+     *   the average time (in milliseconds) taken by a single call to the\n+     *   {@code call} method (i.e. the time taken by each timed block divided\n+     *   by {@code repeatChunk})\n+     * </li>\n+     * <li>\n+     *  the result returned by the {@code call} method.\n+     * </li>\n+     */\n+    public static double[][][] timesAndResults(int repeatChunk,\n+                                               int repeatStat,\n+                                               boolean runGC,\n+                                               Callable<Double> ... methods) {\n         final int numMethods = methods.length;\n-        final double[][] times = new double[numMethods][repeatStat];\n-    \n-        for (int k = 0; k < repeatStat; k++) {\n-            for (int j = 0; j < numMethods; j++) {\n-                final Runnable r = methods[j];\n-                final long start = System.nanoTime();\n-                for (int i = 0; i < repeatChunk; i++) {\n-                    r.run();\n+        final double[][][] timesAndResults = new double[numMethods][repeatStat][2];\n+\n+        try {\n+            for (int k = 0; k < repeatStat; k++) {\n+                for (int j = 0; j < numMethods; j++) {\n+                    if (runGC) {\n+                        // Try to perform GC outside the timed block.\n+                        System.gc();\n+                    }\n+\n+                    final Callable<Double> r = methods[j];\n+                    double result = 0;\n+\n+                    // Timed block.\n+                    final long start = System.nanoTime();\n+                    for (int i = 0; i < repeatChunk; i++) {\n+                        result = r.call();\n+                    }\n+                    final long stop = System.nanoTime();\n+\n+                    // Collect run time and results.\n+                    timesAndResults[j][k][0] = (stop - start) * NANO_TO_MILLI;\n+                    timesAndResults[j][k][1] = result;\n                 }\n-                times[j][k] = (System.nanoTime() - start) * NANO_TO_MILLI;\n             }\n-        }\n-\n-        final MultivariateRealFunction acc = FunctionUtils.collector(new Add(), 0);\n-        final double[] avgTimes = new double[numMethods];\n-\n-        final double normFactor = 1d / (repeatStat * repeatChunk);\n+        } catch (Exception e) {\n+            // Abort benchmarking if codes throw exceptions.\n+            throw new MathIllegalStateException();\n+        }\n+\n+        final double normFactor = 1d / repeatChunk;\n         for (int j = 0; j < numMethods; j++) {\n-            avgTimes[j] = normFactor * acc.value(times[j]);\n-        }\n-\n-        return avgTimes;\n-    }\n-\n-    /**\n-     * Timing and report (to standard output).\n+            for (int k = 0; k < repeatStat; k++) {\n+                timesAndResults[j][k][0] *= normFactor;\n+            }\n+        }\n+\n+        return timesAndResults;\n+    }\n+\n+    /**\n+     * Timing and report (to standard output) the average time and standard\n+     * deviation of a single call.\n      *\n      * @param title Title of the test (for the report).\n      * @param repeatChunk Each timing measurement will done done for that\n      * number of repeats of the code.\n-     * @param repeatStat Timing will be averaged over that number of runs. \n-     * @param methods Code being timed.\n-     * @return for each of the given {@code methods}, the averaged time (in\n-     * milliseconds) taken by a call to {@code run}.\n-     */\n-    public static double[] timeAndReport(String title,\n-                                         int repeatChunk,\n-                                         int repeatStat,\n-                                         RunTest ... methods) {\n-        System.out.println(title);\n-        final double[] time = time(repeatChunk, repeatStat, methods);\n-        for (int i = 0; i < time.length; i++) {\n-            System.out.println(methods[i].getName() + \": \" + time[i] + \" ms\");\n+     * @param repeatStat Timing will be averaged over that number of runs.\n+     * @param runGC Call {@code System.gc()} between each timed block. When\n+     * set to {@code true}, the test will run much slower.\n+     * @param methods Codes being timed.\n+     * @return for each of the given {@code methods}, a statistics of the\n+     * average times (in milliseconds) taken by a single call to the\n+     * {@code call} method (i.e. the time taken by each timed block divided\n+     * by {@code repeatChunk}).\n+     */\n+    public static DescriptiveStatistics[] timeAndReport(String title,\n+                                                        int repeatChunk,\n+                                                        int repeatStat,\n+                                                        boolean runGC,\n+                                                        RunTest ... methods) {\n+        // Header format.\n+        final String headerFormat = \"%s (runs per timed block: %d, timed blocks: %d)\";\n+        // Result format.\n+        final String format = \"%15s: %e (%e) ms\";\n+\n+        System.out.println(String.format(headerFormat,\n+                                         title,\n+                                         repeatChunk,\n+                                         repeatStat));\n+        final DescriptiveStatistics[] time = time(repeatChunk, repeatStat, runGC, methods);\n+        for (int i = 0, max = time.length; i < max; i++) {\n+            final DescriptiveStatistics s = time[i];\n+            System.out.println(String.format(format,\n+                                             methods[i].getName(),\n+                                             s.getMean(),\n+                                             s.getStandardDeviation()));\n         }\n \n         return time;\n     }\n \n     /**\n+     * Timing and report (to standard output).\n+     * This method calls {@link #timeAndReport(String,int,int,boolean,RunTest[])\n+     * timeAndReport(title, 1000, 10000, false, methods)}.\n+     *\n+     * @param title Title of the test (for the report).\n+     * @param methods Codes being timed.\n+     * @return for each of the given {@code methods}, a statistics of the\n+     * average times (in milliseconds) taken by a single call to the\n+     * {@code call} method (i.e. the time taken by each timed block divided\n+     * by {@code repeatChunk}).\n+     */\n+    public static DescriptiveStatistics[] timeAndReport(String title,\n+                                                        RunTest ... methods) {\n+        return timeAndReport(title,\n+                             DEFAULT_REPEAT_CHUNK,\n+                             DEFAULT_REPEAT_STAT,\n+                             false,\n+                             methods);\n+    }\n+\n+    /**\n      * Utility class for storing a test label.\n      */\n-    public static abstract class RunTest implements Runnable {\n+    public static abstract class RunTest implements Callable<Double> {\n         private final String name;\n \n         /**\n         }\n \n         /** {@inheritDoc} */\n-        public abstract void run();\n+        public abstract Double call() throws Exception;\n     }\n }", "timestamp": 1312063197, "metainfo": ""}