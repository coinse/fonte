{"sha": "bd4c0682a71ff99179cc6ab2b0c1f23339267945", "log": "Eliminated tabs.  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialSplineFunction.java\n     public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n         if (knots.length < 2) {\n             throw new IllegalArgumentException\n-            \t(\"Not enough knot values -- spline partition must have at least 2 points.\");\n+                (\"Not enough knot values -- spline partition must have at least 2 points.\");\n         }\n         if (knots.length - 1 != polynomials.length) {\n             throw new IllegalArgumentException \n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n      * @return A formatted number in the form \"Re(c) + Im(c)i\"\n      */\n     public static String formatComplex( Complex c ) {\n-    \treturn getInstance().format( c );\n+        return getInstance().format( c );\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n     public double cumulativeProbability(int x0, int x1) throws MathException {\n         if (x0 > x1) {\n             throw new IllegalArgumentException\n-            \t(\"lower endpoint must be less than or equal to upper endpoint\");\n+                (\"lower endpoint must be less than or equal to upper endpoint\");\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n             ret = 0.0;\n         } else {\n             ret = MathUtils.binomialCoefficientDouble(\n-            \t\tgetNumberOfTrials(), x) *\n-\t\t\t\t  Math.pow(getProbabilityOfSuccess(), x) *\n-\t\t\t\t  Math.pow(1.0 - getProbabilityOfSuccess(),\n-\t\t\t\t  \t\tgetNumberOfTrials() - x);\n+                    getNumberOfTrials(), x) *\n+                  Math.pow(getProbabilityOfSuccess(), x) *\n+                  Math.pow(1.0 - getProbabilityOfSuccess(),\n+                        getNumberOfTrials() - x);\n         }\n         return ret;\n     }\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistribution.java\n  */\n public interface CauchyDistribution extends ContinuousDistribution {\n     \n-\t/**\n-\t * Access the median.\n-\t * @return median for this distribution\n-\t */\n-\tdouble getMedian();\n+    /**\n+     * Access the median.\n+     * @return median for this distribution\n+     */\n+    double getMedian();\n     \n-\t/**\n-\t * Access the scale parameter.\n-\t * @return scale parameter for this distribution\n-\t */\n-\tdouble getScale();\n+    /**\n+     * Access the scale parameter.\n+     * @return scale parameter for this distribution\n+     */\n+    double getScale();\n     \n-\t/**\n-\t * Modify the median.\n-\t * @param median for this distribution\n-\t */\n-\tvoid setMedian(double median);\n+    /**\n+     * Modify the median.\n+     * @param median for this distribution\n+     */\n+    void setMedian(double median);\n     \n-\t/**\n-\t * Modify the scale parameter.\n-\t * @param s scale parameter for this distribution\n-\t */\n-\tvoid setScale(double s);\n+    /**\n+     * Modify the scale parameter.\n+     * @param s scale parameter for this distribution\n+     */\n+    void setScale(double s);\n }\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n  * @version $Revision$ $Date$\n  */\n public class CauchyDistributionImpl extends AbstractContinuousDistribution \n-\t\timplements CauchyDistribution, Serializable {\n+        implements CauchyDistribution, Serializable {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = 8589540077390120676L;\n \n     /** The median of this distribution. */\n-\tprivate double median = 0;\n+    private double median = 0;\n     \n     /** The scale of this distribution. */\n-\tprivate double scale = 1;\n+    private double scale = 1;\n     \n-\t/**\n-\t * Creates cauchy distribution with the medain equal to zero and scale\n-\t * equal to one. \n-\t */\n-\tpublic CauchyDistributionImpl(){\n-\t\tthis(0.0, 1.0);\n-\t}\n-\t\n-\t/**\n-\t * Create a cauchy distribution using the given median and scale.\n-\t * @param median median for this distribution\n-\t * @param s scale parameter for this distribution\n-\t */\n-\tpublic CauchyDistributionImpl(double median, double s){\n-\t\tsuper();\n-\t\tsetMedian(median);\n-\t\tsetScale(s);\n-\t}\n+    /**\n+     * Creates cauchy distribution with the medain equal to zero and scale\n+     * equal to one. \n+     */\n+    public CauchyDistributionImpl(){\n+        this(0.0, 1.0);\n+    }\n+    \n+    /**\n+     * Create a cauchy distribution using the given median and scale.\n+     * @param median median for this distribution\n+     * @param s scale parameter for this distribution\n+     */\n+    public CauchyDistributionImpl(double median, double s){\n+        super();\n+        setMedian(median);\n+        setScale(s);\n+    }\n \n-\t/**\n-\t * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n-\t * @param x the value at which the CDF is evaluated.\n-\t * @return CDF evaluted at <code>x</code>. \n-\t */\n-\tpublic double cumulativeProbability(double x) {\n+    /**\n+     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     */\n+    public double cumulativeProbability(double x) {\n         return 0.5 + (Math.atan((x - median) / scale) / Math.PI);\n-\t}\n+    }\n     \n-\t/**\n-\t * Access the median.\n-\t * @return median for this distribution\n-\t */\t\n-\tpublic double getMedian() {\n-\t\treturn median;\n-\t}\n+    /**\n+     * Access the median.\n+     * @return median for this distribution\n+     */ \n+    public double getMedian() {\n+        return median;\n+    }\n \n-\t/**\n+    /**\n      * Access the scale parameter.\n      * @return scale parameter for this distribution\n-\t */\n-\tpublic double getScale() {\n-\t\treturn scale;\n-\t}\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n     \n     /**\n      * For this distribution, X, this method returns the critical point x, such\n         return ret;\n     }\n     \n-\t/**\n-\t * Modify the median.\n-\t * @param median for this distribution\n-\t */\n-\tpublic void setMedian(double median) {\n-\t\tthis.median = median;\n-\t}\n+    /**\n+     * Modify the median.\n+     * @param median for this distribution\n+     */\n+    public void setMedian(double median) {\n+        this.median = median;\n+    }\n \n-\t/**\n+    /**\n      * Modify the scale parameter.\n      * @param s scale parameter for this distribution\n      * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-\t */\n-\tpublic void setScale(double s) {\n-\t\tif (s <= 0.0) {\n-\t\t\tthrow new IllegalArgumentException(\n+     */\n+    public void setScale(double s) {\n+        if (s <= 0.0) {\n+            throw new IllegalArgumentException(\n                 \"Scale must be positive.\");\n-\t\t}\t\t\n-\t\tscale = s;\n-\t}\n-\t\n-\t/**\n-\t * Access the domain value lower bound, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return domain value lower bound, i.e.\n-\t *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n-\t */\n-\tprotected double getDomainLowerBound(double p) {\n+        }       \n+        scale = s;\n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected double getDomainLowerBound(double p) {\n         double ret;\n \n         if (p < .5) {\n         return ret;\n     }\n \n-\t/**\n-\t * Access the domain value upper bound, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return domain value upper bound, i.e.\n-\t *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-\t */\n-\tprotected double getDomainUpperBound(double p) {\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n         double ret;\n \n         if (p < .5) {\n         return ret;\n     }\n \n-\t/**\n-\t * Access the initial domain value, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return initial domain value\n-\t */\n-\tprotected double getInitialDomain(double p) {\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n         double ret;\n \n         if (p < .5) {\n         }\n         \n         return ret;\n-\t}\n+    }\n }\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n         createHypergeometricDistribution(int populationSize,\n             int numberOfSuccesses, int sampleSize);\n  \n-\t/**\n-\t * Create a new normal distribution with the given mean and standard\n-\t * deviation.\n+    /**\n+     * Create a new normal distribution with the given mean and standard\n+     * deviation.\n      * \n-\t * @param mean the mean of the distribution\n-\t * @param sd standard deviation\n-\t * @return a new normal distribution  \n-\t */           \n+     * @param mean the mean of the distribution\n+     * @param sd standard deviation\n+     * @return a new normal distribution  \n+     */           \n     public abstract NormalDistribution \n-    \tcreateNormalDistribution(double mean, double sd);\n-    \t\n-\t/**\n-\t * Create a new normal distribution with mean zero and standard\n-\t * deviation one.\n+        createNormalDistribution(double mean, double sd);\n+        \n+    /**\n+     * Create a new normal distribution with mean zero and standard\n+     * deviation one.\n      * \n-\t * @return a new normal distribution.  \n-\t */               \n-\tpublic abstract NormalDistribution createNormalDistribution();\n+     * @return a new normal distribution.  \n+     */               \n+    public abstract NormalDistribution createNormalDistribution();\n     \n     /**\n      * Create a new Poisson distribution with poisson parameter lambda.\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n             numberOfSuccesses, sampleSize);\n     }\n \n-\t/**\n-\t * Create a new normal distribution with the given mean and standard\n-\t * deviation.\n+    /**\n+     * Create a new normal distribution with the given mean and standard\n+     * deviation.\n      *  \n-\t * @param mean the mean of the distribution\n-\t * @param sd standard deviation\n-\t * @return a new normal distribution \n-\t */   \n-\tpublic NormalDistribution createNormalDistribution(double mean, double sd) {\n-\t\treturn new NormalDistributionImpl(mean, sd);\n-\t}\n+     * @param mean the mean of the distribution\n+     * @param sd standard deviation\n+     * @return a new normal distribution \n+     */   \n+    public NormalDistribution createNormalDistribution(double mean, double sd) {\n+        return new NormalDistributionImpl(mean, sd);\n+    }\n \n-\t/**\n-\t * Create a new normal distribution with the mean zero and standard\n-\t * deviation one.\n+    /**\n+     * Create a new normal distribution with the mean zero and standard\n+     * deviation one.\n      * \n-\t * @return a new normal distribution  \n-\t */ \n-\tpublic NormalDistribution createNormalDistribution() {\n-\t\treturn new NormalDistributionImpl();\n-\t}\n+     * @return a new normal distribution  \n+     */ \n+    public NormalDistribution createNormalDistribution() {\n+        return new NormalDistributionImpl();\n+    }\n     \n     /**\n      * Create a new Poisson distribution with poisson parameter lambda.\n--- a/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface NormalDistribution extends ContinuousDistribution {\n-\t/**\n-\t * Access the mean.\n-\t * @return mean for this distribution\n-\t */\n-\tdouble getMean();\n-\t/**\n-\t * Modify the mean.\n-\t * @param mean for this distribution\n-\t */\n-\tvoid setMean(double mean);\n-\t/**\n-\t * Access the standard deviation.\n-\t * @return standard deviation for this distribution\n-\t */\n-\tdouble getStandardDeviation();\n-\t/**\n-\t * Modify the standard deviation.\n-\t * @param sd standard deviation for this distribution\n-\t */\n-\tvoid setStandardDeviation(double sd);\n+    /**\n+     * Access the mean.\n+     * @return mean for this distribution\n+     */\n+    double getMean();\n+    /**\n+     * Modify the mean.\n+     * @param mean for this distribution\n+     */\n+    void setMean(double mean);\n+    /**\n+     * Access the standard deviation.\n+     * @return standard deviation for this distribution\n+     */\n+    double getStandardDeviation();\n+    /**\n+     * Modify the standard deviation.\n+     * @param sd standard deviation for this distribution\n+     */\n+    void setStandardDeviation(double sd);\n }\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n  * @version $Revision$ $Date$\n  */\n public class NormalDistributionImpl extends AbstractContinuousDistribution \n-\t\timplements NormalDistribution, Serializable {\n+        implements NormalDistribution, Serializable {\n     \n     /** Serializable version identifier */\n     static final long serialVersionUID = 8589540077390120676L;\n \n     /** The mean of this distribution. */\n-\tprivate double mean = 0;\n+    private double mean = 0;\n     \n     /** The standard deviation of this distribution. */\n-\tprivate double standardDeviation = 1;\n-\t\n-\t/**\n-\t * Create a normal distribution using the given mean and standard deviation.\n-\t * @param mean mean for this distribution\n-\t * @param sd standard deviation for this distribution\n-\t */\n-\tpublic NormalDistributionImpl(double mean, double sd){\n-\t\tsuper();\n-\t\tsetMean(mean);\n-\t\tsetStandardDeviation(sd);\n-\t}\n+    private double standardDeviation = 1;\n     \n-\t/**\n-\t * Creates normal distribution with the mean equal to zero and standard\n-\t * deviation equal to one. \n-\t */\n-\tpublic NormalDistributionImpl(){\n-\t\tthis(0.0, 1.0);\n-\t}\n+    /**\n+     * Create a normal distribution using the given mean and standard deviation.\n+     * @param mean mean for this distribution\n+     * @param sd standard deviation for this distribution\n+     */\n+    public NormalDistributionImpl(double mean, double sd){\n+        super();\n+        setMean(mean);\n+        setStandardDeviation(sd);\n+    }\n     \n-\t/**\n-\t * Access the mean.\n-\t * @return mean for this distribution\n-\t */\t\n-\tpublic double getMean() {\n-\t\treturn mean;\n-\t}\n+    /**\n+     * Creates normal distribution with the mean equal to zero and standard\n+     * deviation equal to one. \n+     */\n+    public NormalDistributionImpl(){\n+        this(0.0, 1.0);\n+    }\n     \n-\t/**\n-\t * Modify the mean.\n-\t * @param mean for this distribution\n-\t */\n-\tpublic void setMean(double mean) {\n-\t\tthis.mean = mean;\n-\t}\n+    /**\n+     * Access the mean.\n+     * @return mean for this distribution\n+     */ \n+    public double getMean() {\n+        return mean;\n+    }\n+    \n+    /**\n+     * Modify the mean.\n+     * @param mean for this distribution\n+     */\n+    public void setMean(double mean) {\n+        this.mean = mean;\n+    }\n \n-\t/**\n-\t * Access the standard deviation.\n-\t * @return standard deviation for this distribution\n-\t */\n-\tpublic double getStandardDeviation() {\n-\t\treturn standardDeviation;\n-\t}\n+    /**\n+     * Access the standard deviation.\n+     * @return standard deviation for this distribution\n+     */\n+    public double getStandardDeviation() {\n+        return standardDeviation;\n+    }\n \n-\t/**\n-\t * Modify the standard deviation.\n-\t * @param sd standard deviation for this distribution\n+    /**\n+     * Modify the standard deviation.\n+     * @param sd standard deviation for this distribution\n      * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-\t */\n-\tpublic void setStandardDeviation(double sd) {\n-\t\tif (sd <= 0.0) {\n-\t\t\tthrow new IllegalArgumentException(\n+     */\n+    public void setStandardDeviation(double sd) {\n+        if (sd <= 0.0) {\n+            throw new IllegalArgumentException(\n                 \"Standard deviation must be positive.\");\n-\t\t}\t\t\n-\t\tstandardDeviation = sd;\n-\t}\n+        }       \n+        standardDeviation = sd;\n+    }\n \n-\t/**\n-\t * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n-\t * @param x the value at which the CDF is evaluated.\n-\t * @return CDF evaluted at <code>x</code>. \n-\t * @throws MathException if the algorithm fails to converge.\n-\t */\n-\tpublic double cumulativeProbability(double x) throws MathException {\n+    /**\n+     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n         return 0.5 * (1.0 + Erf.erf((x - mean) /\n                 (standardDeviation * Math.sqrt(2.0))));\n-\t}\n+    }\n     \n     /**\n      * For this distribution, X, this method returns the critical point x, such\n         }\n         return super.inverseCumulativeProbability(p);\n     }\n-\t\n-\t/**\n-\t * Access the domain value lower bound, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return domain value lower bound, i.e.\n-\t *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n-\t */\n-\tprotected double getDomainLowerBound(double p) {\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected double getDomainLowerBound(double p) {\n         double ret;\n \n         if (p < .5) {\n         return ret;\n     }\n \n-\t/**\n-\t * Access the domain value upper bound, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return domain value upper bound, i.e.\n-\t *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-\t */\n-\tprotected double getDomainUpperBound(double p) {\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n         double ret;\n \n         if (p < .5) {\n         return ret;\n     }\n \n-\t/**\n-\t * Access the initial domain value, based on <code>p</code>, used to\n-\t * bracket a CDF root.  This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p the desired probability for the critical value\n-\t * @return initial domain value\n-\t */\n-\tprotected double getInitialDomain(double p) {\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n         double ret;\n \n         if (p < .5) {\n         }\n         \n         return ret;\n-\t}\n+    }\n }\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n      * @return A formatted fraction in proper form.\n      */\n     public static String formatFraction(Fraction f) {\n-    \treturn getImproperInstance().format(f);\n+        return getImproperInstance().format(f);\n     }\n     \n     /**", "timestamp": 1119824457, "metainfo": ""}