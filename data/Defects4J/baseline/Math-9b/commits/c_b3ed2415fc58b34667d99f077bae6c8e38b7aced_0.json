{"sha": "b3ed2415fc58b34667d99f077bae6c8e38b7aced", "log": "Fixed an error in handling of very close events during ODE integration JIRA: MATH-322  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n import org.apache.commons.math.ode.DerivativeException;\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n+                    if (ga * gb > 0) {\n+                        // this is a corner case:\n+                        // - there was an event near ta,\n+                        // - there is another event between ta and tb\n+                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n+                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n+                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n+                        // about bracketing\n+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+                            ta += epsilon;\n+                            interpolator.setInterpolatedTime(ta);\n+                            ga = handler.g(ta, interpolator.getInterpolatedState());\n+                        }\n+                        if (ga * gb > 0) {\n+                            // this should never happen\n+                            throw MathRuntimeException.createInternalError(null);\n+                        }\n+                    }\n+                         \n                     // variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n                     final BrentSolver solver = new BrentSolver();\n                     solver.setAbsoluteAccuracy(convergence);\n                     solver.setMaximalIterationCount(maxIterationCount);\n-                    double root;\n-                    try {\n-                        root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n-                    } catch (IllegalArgumentException iae) {\n-                        // the interval did not really bracket a root\n-                        root = Double.NaN;\n-                    }\n-                    if (Double.isNaN(root) ||\n-                        ((Math.abs(root - ta) <= convergence) &&\n-                         (Math.abs(root - previousEventTime) <= convergence))) {\n+                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+                    if ((Math.abs(root - ta) <= convergence) &&\n+                         (Math.abs(root - previousEventTime) <= convergence)) {\n                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n                         ta = tb;\n                         ga = gb;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.junit.Test;\n+\n+public class EventStateTest {\n+\n+    // JIRA: MATH-322\n+    @Test\n+    public void closeEvents()\n+        throws EventException, ConvergenceException, DerivativeException {\n+\n+        final double r1  = 90.0;\n+        final double r2  = 135.0;\n+        final double gap = r2 - r1;\n+        EventHandler closeEventsGenerator = new EventHandler() {\n+            public void resetState(double t, double[] y) {\n+            }\n+            public double g(double t, double[] y) {\n+                return (t - r1) * (r2 - t);\n+            }\n+            public int eventOccurred(double t, double[] y, boolean increasing) {\n+                return CONTINUE;\n+            }\n+        };\n+\n+        final double tolerance = 0.1;\n+        EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);\n+\n+        double t0 = r1 - 0.5 * gap;\n+        es.reinitializeBegin(t0, new double[0]);\n+        AbstractStepInterpolator interpolator =\n+            new DummyStepInterpolator(new double[0], true);\n+        interpolator.storeTime(t0);\n+\n+        interpolator.shift();\n+        interpolator.storeTime(0.5 * (r1 + r2));\n+        Assert.assertTrue(es.evaluateStep(interpolator));\n+        Assert.assertEquals(r1, es.getEventTime(), tolerance);\n+        es.stepAccepted(es.getEventTime(), new double[0]);\n+\n+        interpolator.shift();\n+        interpolator.storeTime(r2 + 0.4 * gap);\n+        Assert.assertTrue(es.evaluateStep(interpolator));\n+        Assert.assertEquals(r2, es.getEventTime(), tolerance);\n+\n+    }\n+\n+}", "timestamp": 1260140695, "metainfo": ""}