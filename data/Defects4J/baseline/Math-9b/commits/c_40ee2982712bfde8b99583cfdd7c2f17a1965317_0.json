{"sha": "40ee2982712bfde8b99583cfdd7c2f17a1965317", "log": "Changes to iterative linear solvers in package o.a.c.m.linear (MATH-735) - PreconditionedIterativeLinearSolver is now provided with the *inverse* of the preconditioner as a RealLinearOperator, rather than the preconditioner as an InvertibleRealLinearOperator - InvertibleRealLinearOperator has become superfluous and is removed - various javadoc fixes  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n+++ b/src/main/java/org/apache/commons/math/linear/ConjugateGradient.java\n      * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n      * stopping criterion</a>.\n      *\n-     * @param maxIterations Maximum number of iterations.\n-     * @param delta &delta; parameter for the default stopping criterion.\n+     * @param maxIterations the maximum number of iterations\n+     * @param delta the &delta; parameter for the default stopping criterion\n      * @param check {@code true} if positive definiteness of both matrix and\n-     * preconditioner should be checked.\n+     * preconditioner should be checked\n      */\n     public ConjugateGradient(final int maxIterations, final double delta,\n                              final boolean check) {\n      * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n      * stopping criterion</a> and custom iteration manager.\n      *\n-     * @param manager Custom iteration manager.\n-     * @param delta &delta; parameter for the default stopping criterion.\n+     * @param manager the custom iteration manager\n+     * @param delta the &delta; parameter for the default stopping criterion\n      * @param check {@code true} if positive definiteness of both matrix and\n-     * preconditioner should be checked.\n+     * preconditioner should be checked\n      */\n     public ConjugateGradient(final IterationManager manager,\n                              final double delta, final boolean check) {\n      * Returns {@code true} if positive-definiteness should be checked for both\n      * matrix and preconditioner.\n      *\n-     * @return {@code true} if the tests are to be performed.\n+     * @return {@code true} if the tests are to be performed\n      */\n     public final boolean getCheck() {\n         return check;\n     /** {@inheritDoc} */\n     @Override\n     public RealVector solveInPlace(final RealLinearOperator a,\n-                                   final InvertibleRealLinearOperator m,\n-                                   final RealVector b, final RealVector x0)\n+        final RealLinearOperator minv, final RealVector b, final RealVector x0)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException {\n-        checkParameters(a, m, b, x0);\n+        checkParameters(a, minv, b, x0);\n         final IterationManager manager = getIterationManager();\n         // Initialization of default stopping criterion\n         manager.resetIterationCount();\n         final RealVector r = b.combine(1, -1, q);\n         double rnorm = r.getNorm();\n         RealVector z;\n-        if (m == null) {\n+        if (minv == null) {\n             z = r;\n         } else {\n             z = null;\n             manager.incrementIterationCount();\n             evt = new ConjugateGradientEvent(this, manager.getIterations(), x, b, r, rnorm);\n             manager.fireIterationStartedEvent(evt);\n-            if (m != null) {\n-                z = m.solve(r);\n+            if (minv != null) {\n+                z = minv.operate(r);\n             }\n             final double rhoNext = r.dotProduct(z);\n             if (check && (rhoNext <= 0.)) {\n                 final NonPositiveDefiniteOperatorException e;\n                 e = new NonPositiveDefiniteOperatorException();\n                 final ExceptionContext context = e.getContext();\n-                context.setValue(OPERATOR, m);\n+                context.setValue(OPERATOR, minv);\n                 context.setValue(VECTOR, r);\n                 throw e;\n             }\n--- a/src/main/java/org/apache/commons/math/linear/IterativeLinearSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolver.java\n     /**\n      * Creates a new instance of this class, with default iteration manager.\n      *\n-     * @param maxIterations Maximum number of iterations.\n+     * @param maxIterations the maximum number of iterations\n      */\n     public IterativeLinearSolver(final int maxIterations) {\n         this.manager = new IterationManager(maxIterations);\n     /**\n      * Creates a new instance of this class, with custom iteration manager.\n      *\n-     * @param manager Custom iteration manager.\n-     * @throws NullArgumentException if {@code manager} is {@code null}.\n+     * @param manager the custom iteration manager\n+     * @throws NullArgumentException if {@code manager} is {@code null}\n      */\n     public IterativeLinearSolver(final IterationManager manager)\n         throws NullArgumentException {\n      * {@link #solveInPlace(RealLinearOperator, RealVector, RealVector) solveInPlace},\n      * and throws an exception if one of the checks fails.\n      *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @param a the linear operator A of the system\n+     * @param b the right-hand side vector\n+     * @param x0 the initial guess of the solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} is not square\n      * @throws DimensionMismatchException if {@code b} or {@code x0} have\n-     * dimensions inconsistent with {@code a}.\n+     * dimensions inconsistent with {@code a}\n      */\n     protected static void checkParameters(final RealLinearOperator a,\n-                                          final RealVector b,\n-                                          final RealVector x0)\n-        throws NullArgumentException, NonSquareOperatorException,\n+        final RealVector b, final RealVector x0) throws\n+        NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException {\n         MathUtils.checkNotNull(a);\n         MathUtils.checkNotNull(b);\n     }\n \n     /**\n-     * Returns the {@link IterationManager} attached to this solver.\n+     * Returns the iteration manager attached to this solver.\n      *\n-     * @return the manager.\n+     * @return the manager\n      */\n     public IterationManager getIterationManager() {\n         return manager;\n      * Returns an estimate of the solution to the linear system A &middot; x =\n      * b.\n      *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @param a the linear operator A of the system\n+     * @param b the right-hand side vector\n+     * @return a new vector containing the solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} is not square\n      * @throws DimensionMismatchException if {@code b} has dimensions\n-     * inconsistent with {@code a}.\n+     * inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      */\n-    public RealVector solve(RealLinearOperator a, RealVector b)\n+    public RealVector solve(final RealLinearOperator a, final RealVector b)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException {\n         MathUtils.checkNotNull(a);\n      * Returns an estimate of the solution to the linear system A &middot; x =\n      * b.\n      *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution.\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @param a the linear operator A of the system\n+     * @param b the right-hand side vector\n+     * @param x0 the initial guess of the solution\n+     * @return a new vector containing the solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} is not square\n      * @throws DimensionMismatchException if {@code b} or {@code x0} have\n-     * dimensions inconsistent with {@code a}.\n+     * dimensions inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      */\n     public RealVector solve(RealLinearOperator a, RealVector b, RealVector x0)\n         throws NullArgumentException, NonSquareOperatorException,\n      * Returns an estimate of the solution to the linear system A &middot; x =\n      * b. The solution is computed in-place (initial guess is modified).\n      *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution.\n-     * @return A reference to {@code x0} (shallow copy) updated with the\n-     * solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @param a the linear operator A of the system\n+     * @param b the right-hand side vector\n+     * @param x0 initial guess of the solution\n+     * @return a reference to {@code x0} (shallow copy) updated with the\n+     * solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} is not square\n      * @throws DimensionMismatchException if {@code b} or {@code x0} have\n-     * dimensions inconsistent with {@code a}.\n+     * dimensions inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      */\n     public abstract RealVector solveInPlace(RealLinearOperator a, RealVector b,\n-                                            RealVector x0)\n-        throws NullArgumentException, NonSquareOperatorException,\n+        RealVector x0) throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException;\n }\n--- a/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n+++ b/src/main/java/org/apache/commons/math/linear/IterativeLinearSolverEvent.java\n     /**\n      * Returns the current right-hand side of the linear system to be solved.\n      * This method should return an unmodifiable view, or a deep copy of the\n-     * actual right-hand side, in order not to compromise subsequent iterations\n-     * of the source {@link IterativeLinearSolver}.\n+     * actual right-hand side vector, in order not to compromise subsequent\n+     * iterations of the source {@link IterativeLinearSolver}.\n      *\n-     * @return The right-hand side vector, b.\n+     * @return the right-hand side vector, b\n      */\n     public abstract RealVector getRightHandSideVector();\n \n      * Computer Science, New York University, 1991 (available\n      * <a href=\"http://www.archive.org/details/predictingbehavi00gree\">here</a>).\n      *\n-     * @return an estimate of the norm of the residual\n+     * @return the norm of the residual, ||r||\n      */\n     public abstract double getNormOfResidual();\n \n      * the actual current solution, in order not to compromise subsequent\n      * iterations of the source {@link IterativeLinearSolver}.\n      *\n-     * @return The solution, x.\n+     * @return the solution, x\n      */\n     public abstract RealVector getSolution();\n }\n--- a/src/main/java/org/apache/commons/math/linear/JacobiPreconditioner.java\n+++ b/src/main/java/org/apache/commons/math/linear/JacobiPreconditioner.java\n package org.apache.commons.math.linear;\n \n /**\n- * This class implements the standard Jacobi (diagonal) preconditioner.\n+ * This class implements the standard Jacobi (diagonal) preconditioner. For a\n+ * matrix A<sub>ij</sub>, this preconditioner is\n+ * M = diag(A<sub>11</sub>, A<sub>22</sub>, &hellip;).\n+ * {@link #create(RealLinearOperator)} returns the <em>inverse</em> of this\n+ * preconditioner,\n+ * M<sup>-1</sup> = diag(1 / A<sub>11</sub>, 1 / A<sub>22</sub>, &hellip;)\n  *\n  * @version $Id$\n  * @since 3.0\n  */\n-public class JacobiPreconditioner\n-    extends InvertibleRealLinearOperator {\n+public class JacobiPreconditioner extends RealLinearOperator {\n \n     /** The diagonal coefficients of the preconditioner. */\n     private final ArrayRealVector diag;\n     /**\n      * Creates a new instance of this class.\n      *\n-     * @param diag Diagonal coefficients of the preconditioner.\n+     * @param diag the diagonal coefficients of the linear operator to be\n+     * preconditioned\n      * @param deep {@code true} if a deep copy of the above array should be\n-     *        performed.\n+     * performed\n      */\n     public JacobiPreconditioner(final double[] diag, final boolean deep) {\n         this.diag = new ArrayRealVector(diag, deep);\n      * matrix-vector products with the basis vectors (and might therefore take\n      * some time). With matrices, direct entry access is carried out.\n      *\n-     * @param a Linear operator for which the preconditioner should be built.\n-     * @return Preconditioner made of the diagonal coefficients of the specified\n-     *         linear operator.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @param a the linear operator for which the preconditioner should be built\n+     * @return the inverse of the preconditioner made of the inverse of the\n+     * diagonal coefficients of the specified linear operator\n+     * @throws NonSquareOperatorException if {@code a} is not square\n      */\n     public static JacobiPreconditioner create(final RealLinearOperator a)\n         throws NonSquareOperatorException {\n     @Override\n     public RealVector operate(final RealVector x) {\n         // Dimension check is carried out by ebeMultiply\n-        return x.ebeMultiply(diag);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public RealVector solve(final RealVector b) {\n-        // Dimension check is carried out by ebeDivide\n-        return b.ebeDivide(diag);\n+        return x.ebeDivide(diag);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/linear/PreconditionedIterativeLinearSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/PreconditionedIterativeLinearSolver.java\n import org.apache.commons.math.util.MathUtils;\n \n /**\n+ * <p>\n  * This abstract class defines preconditioned iterative solvers. When A is\n  * ill-conditioned, instead of solving system A &middot; x = b directly, it is\n  * preferable to solve M<sup>-1</sup> &middot; A &middot; x = M<sup>-1</sup>\n  * &middot; b, where M approximates in some way A, while remaining comparatively\n  * easier to invert. M (not M<sup>-1</sup>!) is called the\n  * <em>preconditionner</em>.\n+ * </p>\n+ * <p>\n+ * Concrete implementations of this abstract class must be provided with\n+ * M<sup>-1</sup>, the inverse of the preconditioner, as a\n+ * {@link RealLinearOperator}.\n+ * </p>\n  *\n  * @version $Id$\n  * @since 3.0\n     /**\n      * Creates a new instance of this class, with default iteration manager.\n      *\n-     * @param maxIterations Maximum number of iterations.\n+     * @param maxIterations the maximum number of iterations\n      */\n     public PreconditionedIterativeLinearSolver(final int maxIterations) {\n         super(maxIterations);\n     /**\n      * Creates a new instance of this class, with custom iteration manager.\n      *\n-     * @param manager Custom iteration manager.\n-     * @throws NullArgumentException if {@code manager} is {@code null}.\n+     * @param manager the custom iteration manager\n+     * @throws NullArgumentException if {@code manager} is {@code null}\n      */\n     public PreconditionedIterativeLinearSolver(final IterationManager manager)\n         throws NullArgumentException {\n      * Returns an estimate of the solution to the linear system A &middot; x =\n      * b.\n      *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution.\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x0}\n-     * have dimensions inconsistent with {@code a}.\n+     * @param a the linear operator A of the system\n+     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+     * (can be {@code null})\n+     * @param b the right-hand side vector\n+     * @param x0 the initial guess of the solution\n+     * @return a new vector containing the solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n+     * square\n+     * @throws DimensionMismatchException if {@code minv}, {@code b} or\n+     * {@code x0} have dimensions inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      */\n     public RealVector solve(final RealLinearOperator a,\n-                            final InvertibleRealLinearOperator m,\n-                            final RealVector b, final RealVector x0)\n+        final RealLinearOperator minv, final RealVector b, final RealVector x0)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException {\n         MathUtils.checkNotNull(x0);\n-        return solveInPlace(a, m, b, x0.copy());\n+        return solveInPlace(a, minv, b, x0.copy());\n     }\n \n     /** {@inheritDoc} */\n \n     /**\n      * Performs all dimension checks on the parameters of\n-     * {@link #solve(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector) solve}\n+     * {@link #solve(RealLinearOperator, RealLinearOperator, RealVector, RealVector) solve}\n      * and\n-     * {@link #solveInPlace(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector) solveInPlace}\n-     * , and throws an exception if one of the checks fails.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x0}\n-     * have dimensions inconsistent with {@code a}.\n+     * {@link #solveInPlace(RealLinearOperator, RealLinearOperator, RealVector, RealVector) solveInPlace},\n+     * and throws an exception if one of the checks fails.\n+     *\n+     * @param a the linear operator A of the system\n+     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+     * (can be {@code null})\n+     * @param b the right-hand side vector\n+     * @param x0 the initial guess of the solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n+     * square\n+     * @throws DimensionMismatchException if {@code minv}, {@code b} or\n+     * {@code x0} have dimensions inconsistent with {@code a}\n      */\n     protected static void checkParameters(final RealLinearOperator a,\n-                                          final InvertibleRealLinearOperator m,\n-                                          final RealVector b,\n-                                          final RealVector x0)\n+        final RealLinearOperator minv, final RealVector b, final RealVector x0)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException {\n         checkParameters(a, b, x0);\n-        if (m != null) {\n-            if (m.getColumnDimension() != m.getRowDimension()) {\n-                throw new NonSquareOperatorException(m.getColumnDimension(),\n-                                                           m.getRowDimension());\n+        if (minv != null) {\n+            if (minv.getColumnDimension() != minv.getRowDimension()) {\n+                throw new NonSquareOperatorException(minv.getColumnDimension(),\n+                                                     minv.getRowDimension());\n             }\n-            if (m.getRowDimension() != a.getRowDimension()) {\n-                throw new DimensionMismatchException(m.getRowDimension(),\n+            if (minv.getRowDimension() != a.getRowDimension()) {\n+                throw new DimensionMismatchException(minv.getRowDimension(),\n                                                      a.getRowDimension());\n             }\n         }\n      * Returns an estimate of the solution to the linear system A &middot; x =\n      * b.\n      *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m} or {@code b} have\n-     * dimensions inconsistent with {@code a}.\n+     * @param a the linear operator A of the system\n+     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+     * (can be {@code null})\n+     * @param b the right-hand side vector\n+     * @return a new vector containing the solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n+     * square\n+     * @throws DimensionMismatchException if {@code minv} or {@code b} have\n+     * dimensions inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n-     */\n-    public RealVector solve(RealLinearOperator a,\n-                            InvertibleRealLinearOperator m, RealVector b)\n-        throws NullArgumentException, NonSquareOperatorException,\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n+     */\n+    public RealVector solve(RealLinearOperator a, RealLinearOperator minv,\n+        RealVector b) throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException {\n         MathUtils.checkNotNull(a);\n         final RealVector x = new ArrayRealVector(a.getColumnDimension());\n-        return solveInPlace(a, m, b, x);\n+        return solveInPlace(a, minv, b, x);\n     }\n \n     /**\n      * Returns an estimate of the solution to the linear system A &middot; x =\n      * b. The solution is computed in-place (initial guess is modified).\n      *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x0 Initial guess of the solution.\n-     * @return A reference to {@code x0} (shallow copy) updated with the\n-     * solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x0}\n-     * have dimensions inconsistent with {@code a}.\n+     * @param a the linear operator A of the system\n+     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+     * (can be {@code null})\n+     * @param b the right-hand side vector\n+     * @param x0 the initial guess of the solution\n+     * @return a reference to {@code x0} (shallow copy) updated with the\n+     * solution\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n+     * square\n+     * @throws DimensionMismatchException if {@code minv}, {@code b} or\n+     * {@code x0} have dimensions inconsistent with {@code a}\n      * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction.\n      */\n     public abstract RealVector solveInPlace(RealLinearOperator a,\n-                                            InvertibleRealLinearOperator m,\n-                                            RealVector b, RealVector x0)\n-        throws NullArgumentException, NonSquareOperatorException,\n+        RealLinearOperator minv, RealVector b, RealVector x0) throws\n+        NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException;\n \n     /** {@inheritDoc} */\n     @Override\n     public RealVector solveInPlace(final RealLinearOperator a,\n-                                   final RealVector b, final RealVector x0)\n-        throws NullArgumentException, NonSquareOperatorException,\n+        final RealVector b, final RealVector x0) throws\n+        NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, MaxCountExceededException {\n         return solveInPlace(a, null, b, x0);\n     }\n--- a/src/main/java/org/apache/commons/math/linear/ProvidesResidual.java\n+++ b/src/main/java/org/apache/commons/math/linear/ProvidesResidual.java\n      * unmodifiable view or a deep copy of the residual, in order not to\n      * compromise the subsequent iterations.\n      *\n-     * @return the current value of the residual.\n+     * @return the current value of the residual\n      */\n     RealVector getResidual();\n }\n--- a/src/main/java/org/apache/commons/math/linear/RealLinearOperator.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealLinearOperator.java\n     /**\n      * Returns the dimension of the codomain of this operator.\n      *\n-     * @return the number of rows of the underlying matrix.\n+     * @return the number of rows of the underlying matrix\n      */\n     public abstract int getRowDimension();\n \n     /**\n      * Returns the dimension of the domain of this operator.\n      *\n-     * @return the number of columns of the underlying matrix.\n+     * @return the number of columns of the underlying matrix\n      */\n     public abstract int getColumnDimension();\n \n     /**\n      * Returns the result of multiplying {@code this} by the vector {@code x}.\n      *\n-     * @param x Vector to operate on.\n-     * @return the product of {@code this} instance with {@code x}.\n+     * @param x the vector to operate on\n+     * @return the product of {@code this} instance with {@code x}\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if the column dimension does not match the size of {@code x}.\n+     * if the column dimension does not match the size of {@code x}\n      */\n     public abstract RealVector operate(final RealVector x);\n \n      * throws an {@link UnsupportedOperationException}. Users overriding this\n      * method must also override {@link #isTransposable()}.\n      *\n-     * @param x Vector to operate on.\n+     * @param x the vector to operate on\n      * @return the product of the transpose of {@code this} instance with\n-     * {@code x}.\n+     * {@code x}\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if the row dimension does not match the size of {@code x}.\n+     * if the row dimension does not match the size of {@code x}\n      * @throws UnsupportedOperationException if this operation is not supported\n      * by {@code this} operator\n      */\n--- a/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math/linear/SymmLQ.java\n  * The {@code x} parameter in\n  * <ul>\n  * <li>{@link #solve(RealLinearOperator, RealVector, RealVector)},</li>\n- * <li>{@link #solve(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector)}},</li>\n+ * <li>{@link #solve(RealLinearOperator, RealLinearOperator, RealVector, RealVector)}},</li>\n  * <li>{@link #solveInPlace(RealLinearOperator, RealVector, RealVector)},</li>\n- * <li>{@link #solveInPlace(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector)},</li>\n- * <li>{@link #solveInPlace(RealLinearOperator, InvertibleRealLinearOperator, RealVector, RealVector, boolean, double)},</li>\n+ * <li>{@link #solveInPlace(RealLinearOperator, RealLinearOperator, RealVector, RealVector)},</li>\n+ * <li>{@link #solveInPlace(RealLinearOperator, RealLinearOperator, RealVector, RealVector, boolean, double)},</li>\n  * </ul>\n  * should not be considered as an initial guess, as it is set to zero in the\n  * initial phase. If x<sub>0</sub> is known to be a good approximation to x, one\n         /** The estimate of the norm of P * rL[k-1]. */\n         private double lqnorm;\n \n-        /** Reference to the preconditioner. */\n-        private final InvertibleRealLinearOperator m;\n+        /** Reference to the inverse of the preconditioner, M<sup>-1</sup>. */\n+        private final RealLinearOperator minv;\n \n         /**\n          * The value of (-eps[k+1] * zeta[k-1]). Was called {@code rhs2} in the\n         private double minusEpsZeta;\n \n         /** The value of M^(-1) * b. */\n-        private final RealVector mSolveB;\n+        private final RealVector minvb;\n \n         /** The value of beta[k]. */\n         private double oldb;\n         /**\n          * Creates and inits to k = 1 a new instance of this class.\n          *\n-         * @param a Linear operator A of the system.\n-         * @param m Preconditioner (can be {@code null}).\n-         * @param b Right-hand side vector.\n-         * @param x Vector to be updated with the solution. {@code x} should not\n-         * be considered as an initial guess (<a href=\"#initguess\">more</a>).\n-         * @param goodb Usually {@code false}, except if {@code x} is expected\n-         * to contain a large multiple of {@code b}.\n-         * @param shift The amount to be subtracted to all diagonal elements of\n-         * A.\n-         */\n-        public State(final RealLinearOperator a,\n-                     final InvertibleRealLinearOperator m, final RealVector b,\n-                     final RealVector x, final boolean goodb, final double shift) {\n+         * @param a the linear operator A of the system\n+         * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+         * (can be {@code null})\n+         * @param b the right-hand side vector\n+         * @param x the vector to be updated with the solution; {@code x} should\n+         * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n+         * @param goodb usually {@code false}, except if {@code x} is expected\n+         * to contain a large multiple of {@code b}\n+         * @param shift the amount to be subtracted to all diagonal elements of\n+         * A\n+         */\n+        public State(final RealLinearOperator a, final RealLinearOperator minv,\n+            final RealVector b, final RealVector x, final boolean goodb,\n+            final double shift) {\n             this.a = a;\n-            this.m = m;\n+            this.minv = minv;\n             this.b = b;\n             this.x = x;\n             this.goodb = goodb;\n             this.shift = shift;\n-            this.mSolveB = m == null ? b : m.solve(b);\n+            this.minvb = minv == null ? b : minv.operate(b);\n             this.hasConverged = false;\n             init();\n         }\n          * the convergence tests involve only cgnorm, so we're unlikely to stop\n          * at an LQ point, except if the iteration limit interferes.\n          *\n-         * @param xRefined Vector to be updated with the refined value of x.\n+         * @param xRefined the vector to be updated with the refined value of x\n          */\n         public void refine(final RealVector xRefined) {\n             final int n = this.x.getDimension();\n                 } else {\n                     final double step = bstep / beta1;\n                     for (int i = 0; i < n; i++) {\n-                        final double bi = mSolveB.getEntry(i);\n+                        final double bi = minvb.getEntry(i);\n                         final double xi = this.x.getEntry(i);\n                         xRefined.setEntry(i, xi + step * bi);\n                     }\n                     for (int i = 0; i < n; i++) {\n                         final double xi = this.x.getEntry(i);\n                         final double wi = wbar.getEntry(i);\n-                        final double bi = mSolveB.getEntry(i);\n+                        final double bi = minvb.getEntry(i);\n                         xRefined.setEntry(i, xi + zbar * wi + step * bi);\n                     }\n                 }\n              * if b = 0.\n              */\n             this.r1 = this.b.copy();\n-            this.y = this.m == null ? this.b.copy() : this.m.solve(this.r1);\n-            if ((this.m != null) && check) {\n-                checkSymmetry(this.m, this.r1, this.y, this.m.solve(this.y));\n+            this.y = this.minv == null ? this.b.copy() : this.minv.operate(this.r1);\n+            if ((this.minv != null) && check) {\n+                checkSymmetry(this.minv, this.r1, this.y, this.minv.operate(this.y));\n             }\n \n             this.beta1 = this.r1.dotProduct(this.y);\n             if (this.beta1 < 0.) {\n-                throwNPDLOException(this.m, this.y);\n+                throwNPDLOException(this.minv, this.y);\n             }\n             if (this.beta1 == 0.) {\n                 /* If b = 0 exactly, stop with x = 0. */\n             final double vtv = v.dotProduct(v);\n             daxpy(-vty / vtv, v, this.y);\n             this.r2 = this.y.copy();\n-            if (this.m != null) {\n-                this.y = this.m.solve(this.r2);\n+            if (this.minv != null) {\n+                this.y = this.minv.operate(this.r2);\n             }\n             this.oldb = this.beta1;\n             this.beta = this.r2.dotProduct(this.y);\n             if (this.beta < 0.) {\n-                throwNPDLOException(this.m, this.y);\n+                throwNPDLOException(this.minv, this.y);\n             }\n             this.beta = FastMath.sqrt(this.beta);\n             /*\n              */\n             r1 = r2;\n             r2 = y;\n-            if (m != null) {\n-                y = m.solve(r2);\n+            if (minv != null) {\n+                y = minv.operate(r2);\n             }\n             oldb = beta;\n             beta = r2.dotProduct(y);\n             if (beta < 0.) {\n-                throwNPDLOException(m, y);\n+                throwNPDLOException(minv, y);\n             }\n             beta = FastMath.sqrt(beta);\n             /*\n \n     /**\n      * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n-     * stopping criterion</a>.\n-     *\n-     * @param maxIterations Maximum number of iterations.\n-     * @param delta &delta; parameter for the default stopping criterion.\n+     * stopping criterion</a>. Note that setting {@code check} to {@code true}\n+     * entails an extra matrix-vector product in the initial phase.\n+     *\n+     * @param maxIterations the maximum number of iterations\n+     * @param delta the &delta; parameter for the default stopping criterion\n      * @param check {@code true} if self-adjointedness of both matrix and\n-     * preconditioner should be checked. This entails an extra matrix-vector\n-     * product in the initial phase.\n+     * preconditioner should be checked\n      */\n     public SymmLQ(final int maxIterations, final double delta,\n                   final boolean check) {\n \n     /**\n      * Creates a new instance of this class, with <a href=\"#stopcrit\">default\n-     * stopping criterion</a> and custom iteration manager.\n-     *\n-     * @param manager Custom iteration manager.\n-     * @param delta &delta; parameter for the default stopping criterion.\n+     * stopping criterion</a> and custom iteration manager. Note that setting\n+     * {@code check} to {@code true} entails an extra matrix-vector product in\n+     * the initial phase.\n+     *\n+     * @param manager the custom iteration manager\n+     * @param delta the &delta; parameter for the default stopping criterion\n      * @param check {@code true} if self-adjointedness of both matrix and\n-     * preconditioner should be checked. This entails an extra matrix-vector\n-     * product in the initial phase.\n+     * preconditioner should be checked\n      */\n     public SymmLQ(final IterationManager manager, final double delta,\n                   final boolean check) {\n     /**\n      * Performs a symmetry check on the specified linear operator, and throws an\n      * exception in case this check fails. Given a linear operator L, and a\n-     * vector x, this method checks that x' L y = y' L x (within a given\n-     * accuracy), where y = L x.\n-     *\n-     * @param l The linear operator L.\n-     * @param x The candidate vector x.\n-     * @param y The candidate vector y = L x.\n-     * @param z The vector z = L y.\n-     * @throws NonSelfAdjointOperatorException when the test fails.\n+     * vector x, this method checks that\n+     * x' &middot; L &middot; y = y' &middot; L &middot; x\n+     * (within a given accuracy), where y = L &middot; x.\n+     *\n+     * @param l the linear operator L\n+     * @param x the candidate vector x\n+     * @param y the candidate vector y = L &middot; x\n+     * @param z the vector z = L &middot; y\n+     * @throws NonSelfAdjointOperatorException when the test fails\n      */\n     private static void checkSymmetry(final RealLinearOperator l,\n-                                      final RealVector x, final RealVector y,\n-                                      final RealVector z)\n+        final RealVector x, final RealVector y, final RealVector z)\n         throws NonSelfAdjointOperatorException {\n         final double s = y.dotProduct(y);\n         final double t = x.dotProduct(z);\n      * &middot; y + z. This is for internal use only: no dimension checks are\n      * provided.\n      *\n-     * @param a The scalar by which {@code x} is to be multiplied.\n-     * @param x The first vector to be added to {@code z}.\n-     * @param b The scalar by which {@code y} is to be multiplied.\n-     * @param y The second vector to be added to {@code z}.\n-     * @param z The vector to be incremented.\n+     * @param a the scalar by which {@code x} is to be multiplied\n+     * @param x the first vector to be added to {@code z}\n+     * @param b the scalar by which {@code y} is to be multiplied\n+     * @param y the second vector to be added to {@code z}\n+     * @param z the vector to be incremented\n      */\n     private static void daxpbypz(final double a, final RealVector x,\n-                                 final double b, final RealVector y,\n-                                 final RealVector z) {\n+        final double b, final RealVector y, final RealVector z) {\n         final int n = z.getDimension();\n         for (int i = 0; i < n; i++) {\n             final double zi;\n      * operation y &larr; a &middot; x + y. This is for internal use only: no\n      * dimension checks are provided.\n      *\n-     * @param a The scalar by which {@code x} is to be multiplied.\n-     * @param x The vector to be added to {@code y}.\n-     * @param y The vector to be incremented.\n+     * @param a the scalar by which {@code x} is to be multiplied\n+     * @param x the vector to be added to {@code y}\n+     * @param y the vector to be incremented\n      */\n     private static void daxpy(final double a, final RealVector x,\n-                              final RealVector y) {\n+        final RealVector y) {\n         final int n = x.getDimension();\n         for (int i = 0; i < n; i++) {\n             y.setEntry(i, a * x.getEntry(i) + y.getEntry(i));\n      * Throws a new {@link NonPositiveDefiniteOperatorException} with\n      * appropriate context.\n      *\n-     * @param l The offending linear operator.\n-     * @param v The offending vector.\n-     * @throws NonPositiveDefiniteOperatorException in any circumstances.\n+     * @param l the offending linear operator\n+     * @param v the offending vector\n+     * @throws NonPositiveDefiniteOperatorException in any circumstances\n      */\n     private static void throwNPDLOException(final RealLinearOperator l,\n-                                            final RealVector v)\n-        throws NonPositiveDefiniteOperatorException {\n+        final RealVector v) throws NonPositiveDefiniteOperatorException {\n         final NonPositiveDefiniteOperatorException e;\n         e = new NonPositiveDefiniteOperatorException();\n         final ExceptionContext context = e.getContext();\n      * Returns {@code true} if symmetry of the matrix, and symmetry as well as\n      * positive definiteness of the preconditioner should be checked.\n      *\n-     * @return {@code true} if the tests are to be performed.\n+     * @return {@code true} if the tests are to be performed\n      */\n     public final boolean getCheck() {\n         return check;\n     }\n \n     /**\n-     * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     * have dimensions inconsistent with {@code a}.\n+     * {@inheritDoc}\n+     *\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n-     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n-     * definite.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * positive definite\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solve(final RealLinearOperator a,\n-                            final InvertibleRealLinearOperator m,\n-                            final RealVector b)\n-        throws NullArgumentException, NonSquareOperatorException,\n-        DimensionMismatchException, NonSelfAdjointOperatorException,\n-        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n-        MaxCountExceededException {\n+        final RealLinearOperator minv, final RealVector b) throws\n+        NullArgumentException, NonSquareOperatorException,\n+        DimensionMismatchException, MaxCountExceededException,\n+        NonSelfAdjointOperatorException, NonPositiveDefiniteOperatorException,\n+        IllConditionedOperatorException {\n         MathUtils.checkNotNull(a);\n         final RealVector x = new ArrayRealVector(a.getColumnDimension());\n-        return solveInPlace(a, m, b, x, false, 0.);\n+        return solveInPlace(a, minv, b, x, false, 0.);\n     }\n \n     /**\n      * normalized, x may be closer to an eigenvector than b.\n      * </p>\n      *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param goodb Usually {@code false}, except if {@code x} is expected to\n-     * contain a large multiple of {@code b}.\n-     * @param shift The amount to be subtracted to all diagonal elements of A.\n-     * @return A reference to {@code x} (shallow copy).\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m} or {@code b} have\n-     * dimensions inconsistent with {@code a}.\n+     * @param a the linear operator A of the system\n+     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+     * (can be {@code null})\n+     * @param b the right-hand side vector\n+     * @param goodb usually {@code false}, except if {@code x} is expected to\n+     * contain a large multiple of {@code b}\n+     * @param shift the amount to be subtracted to all diagonal elements of A\n+     * @return a reference to {@code x} (shallow copy)\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n+     * square\n+     * @throws DimensionMismatchException if {@code minv} or {@code b} have\n+     * dimensions inconsistent with {@code a}\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n-     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n-     * definite.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * positive definite\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     public RealVector solve(final RealLinearOperator a,\n-                            final InvertibleRealLinearOperator m,\n-                            final RealVector b, final boolean goodb,\n-                            final double shift)\n-        throws NullArgumentException, NonSquareOperatorException,\n-        DimensionMismatchException, NonSelfAdjointOperatorException,\n-        NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n-        MaxCountExceededException {\n+        final RealLinearOperator minv, final RealVector b, final boolean goodb,\n+        final double shift) throws NullArgumentException,\n+        NonSquareOperatorException, DimensionMismatchException,\n+        MaxCountExceededException, NonSelfAdjointOperatorException,\n+        NonPositiveDefiniteOperatorException, IllConditionedOperatorException {\n         MathUtils.checkNotNull(a);\n         final RealVector x = new ArrayRealVector(a.getColumnDimension());\n-        return solveInPlace(a, m, b, x, goodb, shift);\n-    }\n-\n-    /**\n-     * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x Not meaningful in this implementation. Should not be considered\n-     * as an initial guess (<a href=\"#initguess\">more</a>).\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     * have dimensions inconsistent with {@code a}.\n+        return solveInPlace(a, minv, b, x, goodb, shift);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param x not meaningful in this implementation; should not be considered\n+     * as an initial guess (<a href=\"#initguess\">more</a>)\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n-     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n-     * definite.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * positive definite\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solve(final RealLinearOperator a,\n-                            final InvertibleRealLinearOperator m,\n-                            final RealVector b, final RealVector x)\n+        final RealLinearOperator minv, final RealVector b, final RealVector x)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n         MaxCountExceededException {\n         MathUtils.checkNotNull(x);\n-        return solveInPlace(a, m, b, x.copy(), false, 0.);\n-    }\n-\n-    /**\n-     * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n-     * @throws DimensionMismatchException if {@code b} has dimensions\n-     * inconsistent with {@code a}.\n+        return solveInPlace(a, minv, b, x.copy(), false, 0.);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} is not self-adjoint.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} is not self-adjoint\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solve(final RealLinearOperator a, final RealVector b)\n      * normalized, x may be closer to an eigenvector than b.\n      * </p>\n      *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @param goodb Usually {@code false}, except if {@code x} is expected to\n-     * contain a large multiple of {@code b}.\n-     * @param shift The amount to be subtracted to all diagonal elements of A.\n-     * @return a reference to {@code x}.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n+     * @param a the linear operator A of the system\n+     * @param b the right-hand side vector\n+     * @param goodb usually {@code false}, except if {@code x} is expected to\n+     * contain a large multiple of {@code b}\n+     * @param shift the amount to be subtracted to all diagonal elements of A\n+     * @return a reference to {@code x}\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} is not square\n      * @throws DimensionMismatchException if {@code b} has dimensions\n-     * inconsistent with {@code a}.\n+     * inconsistent with {@code a}\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} is not self-adjoint.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} is not self-adjoint\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     public RealVector solve(final RealLinearOperator a, final RealVector b,\n-                            final boolean goodb, final double shift)\n-        throws NullArgumentException, NonSquareOperatorException,\n-        DimensionMismatchException, NonSelfAdjointOperatorException,\n-        IllConditionedOperatorException, MaxCountExceededException {\n+        final boolean goodb, final double shift) throws NullArgumentException,\n+        NonSquareOperatorException, DimensionMismatchException,\n+        NonSelfAdjointOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n         MathUtils.checkNotNull(a);\n         final RealVector x = new ArrayRealVector(a.getColumnDimension());\n         return solveInPlace(a, null, b, x, goodb, shift);\n     }\n \n     /**\n-     * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @param x Not meaningful in this implementation. Should not be considered\n-     * as an initial guess (<a href=\"#initguess\">more</a>).\n-     * @return A new vector containing the solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} is not square.\n-     * @throws DimensionMismatchException if {@code b} or {@code x} have\n-     * dimensions inconsistent with {@code a}.\n+     * {@inheritDoc}\n+     *\n+     * @param x not meaningful in this implementation; should not be considered\n+     * as an initial guess (<a href=\"#initguess\">more</a>)\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} is not self-adjoint.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} is not self-adjoint\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solve(final RealLinearOperator a, final RealVector b,\n-                            final RealVector x)\n-        throws NullArgumentException, NonSquareOperatorException,\n-        DimensionMismatchException, NonSelfAdjointOperatorException,\n-        IllConditionedOperatorException, MaxCountExceededException {\n+        final RealVector x) throws NullArgumentException,\n+        NonSquareOperatorException, DimensionMismatchException,\n+        NonSelfAdjointOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n         MathUtils.checkNotNull(x);\n         return solveInPlace(a, null, b, x.copy(), false, 0.);\n     }\n \n     /**\n-     * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b. The solution is computed in-place.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x Vector to be updated with the solution. {@code x} should not be\n-     * considered as an initial guess (<a href=\"#initguess\">more</a>).\n-     * @return A reference to {@code x} (shallow copy) updated with the\n-     * solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     * have dimensions inconsistent with {@code a}.\n+     * {@inheritDoc}\n+     *\n+     * @param x the vector to be updated with the solution; {@code x} should\n+     * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n-     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n-     * definite.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * positive definite\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solveInPlace(final RealLinearOperator a,\n-                                   final InvertibleRealLinearOperator m,\n-                                   final RealVector b, final RealVector x)\n+        final RealLinearOperator minv, final RealVector b, final RealVector x)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n         MaxCountExceededException {\n-        return solveInPlace(a, m, b, x, false, 0.);\n+        return solveInPlace(a, minv, b, x, false, 0.);\n     }\n \n     /**\n      * normalized, x may be closer to an eigenvector than b.\n      * </p>\n      *\n-     * @param a Linear operator A of the system.\n-     * @param m Preconditioner (can be {@code null}).\n-     * @param b Right-hand side vector.\n-     * @param x Vector to be updated with the solution. {@code x} should not be\n-     * considered as an initial guess (<a href=\"#initguess\">more</a>).\n-     * @param goodb Usually {@code false}, except if {@code x} is expected to\n-     * contain a large multiple of {@code b}.\n-     * @param shift The amount to be subtracted to all diagonal elements of A.\n-     * @return A reference to {@code x} (shallow copy).\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     * have dimensions inconsistent with {@code a}.\n+     * @param a the linear operator A of the system\n+     * @param minv the inverse of the preconditioner, M<sup>-1</sup>\n+     * (can be {@code null})\n+     * @param b the right-hand side vector\n+     * @param x the vector to be updated with the solution; {@code x} should\n+     * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n+     * @param goodb usually {@code false}, except if {@code x} is expected to\n+     * contain a large multiple of {@code b}\n+     * @param shift the amount to be subtracted to all diagonal elements of A\n+     * @return a reference to {@code x} (shallow copy).\n+     * @throws NullArgumentException if one of the parameters is {@code null}\n+     * @throws NonSquareOperatorException if {@code a} or {@code minv} is not\n+     * square\n+     * @throws DimensionMismatchException if {@code minv}, {@code b} or\n+     * {@code x} have dimensions inconsistent with {@code a}.\n+     * @throws MaxCountExceededException at exhaustion of the iteration count,\n+     * unless a custom\n+     * {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback}\n+     * has been set at construction\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n-     * @throws NonPositiveDefiniteOperatorException if {@code m} is not positive\n-     * definite.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} or {@code minv} is not self-adjoint\n+     * @throws NonPositiveDefiniteOperatorException if {@code minv} is not\n+     * positive definite\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     public RealVector solveInPlace(final RealLinearOperator a,\n-                                   final InvertibleRealLinearOperator m,\n-                                   final RealVector b, final RealVector x,\n-                                   final boolean goodb, final double shift)\n+        final RealLinearOperator minv, final RealVector b,\n+        final RealVector x, final boolean goodb, final double shift)\n         throws NullArgumentException, NonSquareOperatorException,\n         DimensionMismatchException, NonSelfAdjointOperatorException,\n         NonPositiveDefiniteOperatorException, IllConditionedOperatorException,\n         MaxCountExceededException {\n-        checkParameters(a, m, b, x);\n+        checkParameters(a, minv, b, x);\n \n         final IterationManager manager = getIterationManager();\n         /* Initialization counts as an iteration. */\n         manager.resetIterationCount();\n         manager.incrementIterationCount();\n \n-        final State state = new State(a, m, b, x, goodb, shift);\n+        final State state = new State(a, minv, b, x, goodb, shift);\n         final IterativeLinearSolverEvent event = new SymmLQEvent(this, state);\n         if (state.beta1 == 0.) {\n             /* If b = 0 exactly, stop with x = 0. */\n     }\n \n     /**\n-     * Returns an estimate of the solution to the linear system A &middot; x =\n-     * b. The solution is computed in-place.\n-     *\n-     * @param a Linear operator A of the system.\n-     * @param b Right-hand side vector.\n-     * @param x Vector to be updated with the solution. {@code x} should not be\n-     * considered as an initial guess (<a href=\"#initguess\">more</a>).\n-     * @return A reference to {@code x} (shallow copy) updated with the\n-     * solution.\n-     * @throws NullArgumentException if one of the parameters is {@code null}.\n-     * @throws NonSquareOperatorException if {@code a} or {@code m} is not\n-     * square.\n-     * @throws DimensionMismatchException if {@code m}, {@code b} or {@code x}\n-     * have dimensions inconsistent with {@code a}.\n+     * {@inheritDoc}\n+     *\n+     * @param x the vector to be updated with the solution; {@code x} should\n+     * not be considered as an initial guess (<a href=\"#initguess\">more</a>)\n      * @throws NonSelfAdjointOperatorException if {@link #getCheck()} is\n-     * {@code true}, and {@code a} or {@code m} is not self-adjoint.\n-     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned.\n-     * @throws MaxCountExceededException at exhaustion of the iteration count,\n-     * unless a custom {@link org.apache.commons.math.util.Incrementor.MaxCountExceededCallback callback} has been set at\n-     * construction.\n+     * {@code true}, and {@code a} is not self-adjoint\n+     * @throws IllConditionedOperatorException if {@code a} is ill-conditioned\n      */\n     @Override\n     public RealVector solveInPlace(final RealLinearOperator a,\n-                                   final RealVector b, final RealVector x)\n-        throws NullArgumentException, NonSquareOperatorException,\n-        DimensionMismatchException, NonSelfAdjointOperatorException,\n-        IllConditionedOperatorException, MaxCountExceededException {\n+        final RealVector b, final RealVector x) throws NullArgumentException,\n+        NonSquareOperatorException, DimensionMismatchException,\n+        NonSelfAdjointOperatorException, IllConditionedOperatorException,\n+        MaxCountExceededException {\n         return solveInPlace(a, null, b, x, false, 0.);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ConjugateGradientTest.java\n     @Test(expected = NonSquareOperatorException.class)\n     public void testNonSquarePreconditioner() {\n         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator m = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n             @Override\n             public int getColumnDimension() {\n                 return 3;\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                throw new UnsupportedOperationException();\n             }\n         };\n         final PreconditionedIterativeLinearSolver solver;\n     @Test(expected = DimensionMismatchException.class)\n     public void testMismatchedOperatorDimensions() {\n         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator m = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n             @Override\n             public int getColumnDimension() {\n                 return 3;\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                throw new UnsupportedOperationException();\n             }\n         };\n         final PreconditionedIterativeLinearSolver solver;\n         a.setEntry(0, 1, 2d);\n         a.setEntry(1, 0, 3d);\n         a.setEntry(1, 1, 4d);\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator m = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n             @Override\n             public int getColumnDimension() {\n                 return 2;\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                final ArrayRealVector x = new ArrayRealVector(2);\n-                x.setEntry(0, -b.getEntry(0));\n-                x.setEntry(1, b.getEntry(1));\n-                return x;\n             }\n         };\n         final PreconditionedIterativeLinearSolver solver;\n         final int maxIterations = 100;\n         final RealLinearOperator a = new HilbertMatrix(n);\n         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final PreconditionedIterativeLinearSolver solver;\n         solver = new ConjugateGradient(maxIterations, 1E-15, true);\n         final RealVector b = new ArrayRealVector(n);\n         final int n = 10;\n         final int maxIterations = n;\n         final RealLinearOperator a = new HilbertMatrix(n);\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final ConjugateGradient solver;\n         solver = new ConjugateGradient(maxIterations, 1E-15, true);\n         final RealVector r = new ArrayRealVector(n);\n                 }\n             }\n         }\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final PreconditionedIterativeLinearSolver pcg;\n         final IterativeLinearSolver cg;\n         pcg = new ConjugateGradient(maxIterations, 1E-6, true);\n         final int n = 5;\n         final int maxIterations = 100;\n         final RealLinearOperator a = new HilbertMatrix(n);\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final PreconditionedIterativeLinearSolver solver;\n         final IterationListener listener = new IterationListener() {\n \n--- a/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SymmLQTest.java\n         };\n         final double shiftm = shift;\n         final double pertm = FastMath.abs(pertbn);\n-        final InvertibleRealLinearOperator m;\n+        final RealLinearOperator minv;\n         if (precon) {\n-            m = new InvertibleRealLinearOperator() {\n+            minv = new RealLinearOperator() {\n+                @Override\n+                public int getRowDimension() {\n+                    return n;\n+                }\n+\n+                @Override\n+                public int getColumnDimension() {\n+                    return n;\n+                }\n \n                 @Override\n                 public RealVector operate(final RealVector x) {\n                         if (i % 10 == 0) {\n                             d += pertm;\n                         }\n-                        y[i] = d * x.getEntry(i);\n+                        y[i] = x.getEntry(i) / d;\n                     }\n                     return new ArrayRealVector(y, false);\n                 }\n-\n-                @Override\n-                public int getRowDimension() {\n-                    return n;\n-                }\n-\n-                @Override\n-                public int getColumnDimension() {\n-                    return n;\n-                }\n-\n-                @Override\n-                public RealVector solve(final RealVector b) {\n-                    if (b.getDimension() != n) {\n-                        throw new DimensionMismatchException(b.getDimension(),\n-                                                             n);\n-                    }\n-                    final double[] x = new double[n];\n-                    for (int i = 0; i < n; i++) {\n-                        double d = (i + 1) * 1.1 / n;\n-                        d = FastMath.abs(d - shiftm);\n-                        if (i % 10 == 0) {\n-                            d += pertm;\n-                        }\n-                        x[i] = b.getEntry(i) / d;\n-                    }\n-                    return new ArrayRealVector(x, false);\n-                }\n             };\n         } else {\n-            m = null;\n+            minv = null;\n         }\n         final RealVector xtrue = new ArrayRealVector(n);\n         for (int i = 0; i < n; i++) {\n         final RealVector b = a.operate(xtrue);\n         b.combineToSelf(1.0, -shift, xtrue);\n         final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true);\n-        final RealVector x = solver.solve(a, m, b, goodb, shift);\n+        final RealVector x = solver.solve(a, minv, b, goodb, shift);\n         final RealVector y = a.operate(x);\n         final RealVector r1 = new ArrayRealVector(n);\n         for (int i = 0; i < n; i++) {\n         }\n         final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm();\n         final double etol = 1E-5;\n-        Assert.assertTrue(\"enorm=\"\n-                                  + enorm\n-                                  + \", \"\n-                                  + solver.getIterationManager()\n-                                      .getIterations(),\n-                          enorm <= etol);\n+        Assert.assertTrue(\"enorm=\" + enorm + \", \" +\n+        solver.getIterationManager().getIterations(), enorm <= etol);\n     }\n \n     @Test\n     @Test(expected = NonSquareOperatorException.class)\n     public void testNonSquarePreconditioner() {\n         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator m = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n             @Override\n             public int getColumnDimension() {\n                 return 3;\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                throw new UnsupportedOperationException();\n             }\n         };\n         final PreconditionedIterativeLinearSolver solver;\n     @Test(expected = DimensionMismatchException.class)\n     public void testMismatchedOperatorDimensions() {\n         final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2);\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator m = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n             @Override\n             public int getColumnDimension() {\n                 return 3;\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                throw new UnsupportedOperationException();\n             }\n         };\n         final PreconditionedIterativeLinearSolver solver;\n         a.setEntry(0, 1, 2d);\n         a.setEntry(1, 0, 3d);\n         a.setEntry(1, 1, 4d);\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator m = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n             @Override\n             public int getColumnDimension() {\n                 return 2;\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                final ArrayRealVector x = new ArrayRealVector(2);\n-                x.setEntry(0, -b.getEntry(0));\n-                x.setEntry(1, -b.getEntry(1));\n-                return x;\n             }\n         };\n         final PreconditionedIterativeLinearSolver solver;\n         final int maxIterations = 100;\n         final RealLinearOperator a = new HilbertMatrix(n);\n         final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n);\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final PreconditionedIterativeLinearSolver solver;\n         solver = new SymmLQ(maxIterations, 1E-15, true);\n         final RealVector b = new ArrayRealVector(n);\n                 }\n             }\n         }\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final PreconditionedIterativeLinearSolver prec;\n         final IterativeLinearSolver unprec;\n         prec = new SymmLQ(maxIterations, 1E-15, true);\n             b.setEntry(j, 1.);\n             final RealVector px = prec.solve(a, m, b);\n             final RealVector x = unprec.solve(a, b);\n-            final int npcg = prec.getIterationManager().getIterations();\n-            final int ncg = unprec.getIterationManager().getIterations();\n-            msg = String.format(pattern, npcg, ncg);\n-            Assert.assertTrue(msg, npcg < ncg);\n+            final int np = prec.getIterationManager().getIterations();\n+            final int nup = unprec.getIterationManager().getIterations();\n+            msg = String.format(pattern, np, nup);\n+            System.out.println(np + \", \" + nup);\n             for (int i = 0; i < n; i++) {\n                 msg = String.format(\"row %d, column %d\", i, j);\n                 final double expected = x.getEntry(i);\n         });\n         final DecompositionSolver mSolver;\n         mSolver = new LUDecomposition(mMat).getSolver();\n-        final InvertibleRealLinearOperator m;\n-        m = new InvertibleRealLinearOperator() {\n+        final RealLinearOperator minv = new RealLinearOperator() {\n \n             @Override\n             public RealVector operate(final RealVector x) {\n-                return mMat.operate(x);\n+                return mSolver.solve(x);\n             }\n \n             @Override\n             @Override\n             public int getColumnDimension() {\n                 return mMat.getColumnDimension();\n-            }\n-\n-            @Override\n-            public RealVector solve(final RealVector b) {\n-                return mSolver.solve(b);\n             }\n         };\n         final RealVector b = new ArrayRealVector(new double[] {\n             1., 1., 1.\n         });\n-        new SymmLQ(100, 1., true).solve(a, m, b);\n+        new SymmLQ(100, 1., true).solve(a, minv, b);\n     }\n \n     @Test\n         final int n = 5;\n         final int maxIterations = 100;\n         final RealLinearOperator a = new HilbertMatrix(n);\n-        final InvertibleRealLinearOperator m = JacobiPreconditioner.create(a);\n+        final RealLinearOperator m = JacobiPreconditioner.create(a);\n         final PreconditionedIterativeLinearSolver solver;\n         final IterationListener listener = new IterationListener() {\n ", "timestamp": 1327829970, "metainfo": ""}