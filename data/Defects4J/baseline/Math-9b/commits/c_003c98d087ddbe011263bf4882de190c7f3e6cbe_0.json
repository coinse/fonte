{"sha": "003c98d087ddbe011263bf4882de190c7f3e6cbe", "log": "fixed an error in SparseRealVector.isInfinite, NaN was not checked beforehand fixed an error in SparseRealVector.hashcode, code did not depend on vector entries fixed tests accordingly  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n \n     /** {@inheritDoc} */\n     public boolean isInfinite() {\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            if (Double.isInfinite(iter.value())) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        boolean infiniteFound = false;\n+        boolean nanFound      = false;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            final double value = iter.value();\n+            if (Double.isNaN(value)) {\n+                nanFound = true;\n+            }\n+            if (Double.isInfinite(value)) {\n+                infiniteFound = true;\n+            }\n+        }\n+        return infiniteFound && (!nanFound);\n     }\n \n     /** {@inheritDoc} */\n         temp = Double.doubleToLongBits(epsilon);\n         result = prime * result + (int) (temp ^ (temp >>> 32));\n         result = prime * result + virtualSize;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            temp = Double.doubleToLongBits(iter.value());\n+            result = prime * result + (int) (temp ^ (temp >>> 32));\n+        }\n         return result;\n     }\n \n--- a/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n \n         assertFalse(v.isInfinite());\n         v.setEntry(0, Double.POSITIVE_INFINITY);\n-        assertFalse(v.isInfinite()); // NaN is checked before infinity\n+        assertFalse(v.isInfinite()); // NaN has higher priority than infinity\n         v.setEntry(1, 1);\n         assertTrue(v.isInfinite());\n \n         assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));\n         assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2, 3 }));\n \n-        assertEquals(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+        assertTrue(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n                       new SparseRealVector(new double[] { 0, Double.NaN, 2 }).hashCode());\n \n         assertTrue(new SparseRealVector(new double[] { Double.NaN, 1, 2 }).hashCode() !=", "timestamp": 1240067832, "metainfo": ""}