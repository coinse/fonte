{"sha": "4870fa9a8e5bfd2a11f17e7b16649c5ee9fd58e9", "log": "MATH-485 New \"filter\" package. Initial implementation of Kalman filter provided by Thomas Neidhart.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/filter/DefaultMeasurementModel.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.filter;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Default implementation of a {@link MeasurementModel} for the use with a\n+ * {@link KalmanFilter}.\n+ *\n+ * @version $Id$\n+ */\n+public class DefaultMeasurementModel implements MeasurementModel {\n+\n+    private RealMatrix measurementMatrix;\n+    private RealMatrix measurementNoise;\n+\n+    /**\n+     * Create a new {@link MeasurementModel}, taking double arrays as input\n+     * parameters for the respective measurement matrix and noise.\n+     *\n+     * @param measurementMatrix\n+     *            the measurement matrix\n+     * @param measurementNoise\n+     *            the measurement noise matrix\n+     */\n+    public DefaultMeasurementModel(final double[][] measurementMatrix,\n+            final double[][] measurementNoise) {\n+        this(new Array2DRowRealMatrix(measurementMatrix),\n+                new Array2DRowRealMatrix(measurementNoise));\n+    }\n+\n+    /**\n+     * Create a new {@link MeasurementModel}, taking {@link RealMatrix} objects\n+     * as input parameters for the respective measurement matrix and noise.\n+     *\n+     * @param measurementMatrix\n+     * @param measurementNoise\n+     */\n+    public DefaultMeasurementModel(final RealMatrix measurementMatrix,\n+            final RealMatrix measurementNoise) {\n+        this.measurementMatrix = measurementMatrix;\n+        this.measurementNoise = measurementNoise;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealMatrix getMeasurementMatrix() {\n+        return measurementMatrix;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealMatrix getMeasurementNoise() {\n+        return measurementNoise;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/filter/DefaultProcessModel.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.filter;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+\n+/**\n+ * Default implementation of a {@link ProcessModel} for the use with a\n+ * {@link KalmanFilter}.\n+ *\n+ * @version $Id$\n+ */\n+public class DefaultProcessModel implements ProcessModel {\n+\n+    private RealMatrix stateTransitionMatrix;\n+    private RealMatrix controlMatrix;\n+    private RealMatrix processNoise;\n+    private RealVector initialStateEstimate;\n+    private RealMatrix initialErrorCovariance;\n+\n+    /**\n+     * Create a new {@link ProcessModel}, taking double arrays as input\n+     * parameters.\n+     *\n+     * @param stateTransitionMatrix\n+     *            the state transition matrix\n+     * @param controlMatrix\n+     *            the control matrix\n+     * @param processNoise\n+     *            the process noise matrix\n+     * @param initialStateEstimate\n+     *            the initial state estimate vector\n+     * @param initialErrorCovariance\n+     *            the initial error covariance matrix\n+     */\n+    public DefaultProcessModel(final double[][] stateTransitionMatrix,\n+            final double[][] controlMatrix, final double[][] processNoise,\n+            final double[] initialStateEstimate,\n+            final double[][] initialErrorCovariance) {\n+        this(new Array2DRowRealMatrix(stateTransitionMatrix),\n+                new Array2DRowRealMatrix(controlMatrix),\n+                new Array2DRowRealMatrix(processNoise), new ArrayRealVector(\n+                        initialStateEstimate), new Array2DRowRealMatrix(\n+                        initialErrorCovariance));\n+    }\n+\n+    /**\n+     * Create a new {@link ProcessModel}, taking double arrays as input\n+     * parameters. The initial state estimate and error covariance are omitted\n+     * and will be initialized by the {@link KalmanFilter} to default values.\n+     *\n+     * @param stateTransitionMatrix\n+     *            the state transition matrix\n+     * @param controlMatrix\n+     *            the control matrix\n+     * @param processNoise\n+     *            the process noise matrix\n+     */\n+    public DefaultProcessModel(final double[][] stateTransitionMatrix,\n+            final double[][] controlMatrix, final double[][] processNoise) {\n+        this(new Array2DRowRealMatrix(stateTransitionMatrix),\n+                new Array2DRowRealMatrix(controlMatrix),\n+                new Array2DRowRealMatrix(processNoise), null, null);\n+    }\n+\n+    /**\n+     * Create a new {@link ProcessModel}, taking double arrays as input\n+     * parameters.\n+     *\n+     * @param stateTransitionMatrix\n+     *            the state transition matrix\n+     * @param controlMatrix\n+     *            the control matrix\n+     * @param processNoise\n+     *            the process noise matrix\n+     * @param initialStateEstimate\n+     *            the initial state estimate vector\n+     * @param initialErrorCovariance\n+     *            the initial error covariance matrix\n+     */\n+    public DefaultProcessModel(final RealMatrix stateTransitionMatrix,\n+            final RealMatrix controlMatrix, final RealMatrix processNoise,\n+            final RealVector initialStateEstimate,\n+            final RealMatrix initialErrorCovariance) {\n+        this.stateTransitionMatrix = stateTransitionMatrix;\n+        this.controlMatrix = controlMatrix;\n+        this.processNoise = processNoise;\n+        this.initialStateEstimate = initialStateEstimate;\n+        this.initialErrorCovariance = initialErrorCovariance;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealMatrix getStateTransitionMatrix() {\n+        return stateTransitionMatrix;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealMatrix getControlMatrix() {\n+        return controlMatrix;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealMatrix getProcessNoise() {\n+        return processNoise;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealVector getInitialStateEstimate() {\n+        return initialStateEstimate;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealMatrix getInitialErrorCovariance() {\n+        return initialErrorCovariance;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/filter/KalmanFilter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.filter;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.linear.CholeskyDecompositionImpl;\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.MatrixDimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.NonSquareMatrixException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.SingularMatrixException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implementation of a Kalman filter to estimate the state <i>x<sub>k</sub> of a\n+ * discrete-time controlled process that is governed by the linear stochastic\n+ * difference equation:\n+ *\n+ * <pre>\n+ * <i>x<sub>k</sub> = <b>A</b><i>x<sub>k-1</sub> + <b>B</b><i>u<sub>k-1</sub> + <i>w<sub>k-1</sub>\n+ * </pre>\n+ *\n+ * with a measurement <i>x<sub>k</sub> that is\n+ *\n+ * <pre>\n+ * <i>z<sub>k</sub> = <b>H</b><i>x<sub>k</sub> + <i>v<sub>k</sub>.\n+ * </pre>\n+ *\n+ * The random variables <i>w<sub>k</sub> and <i>v<sub>k</sub> represent the\n+ * process and measurement noise and are assumed to be independent of each other\n+ * and distributed with normal probability (white noise).\n+ * <p>\n+ * The Kalman filter cycle involves the following steps:\n+ * <ol>\n+ * <li>predict: project the current state estimate ahead in time</li>\n+ * <li>correct: adjust the projected estimate by an actual measurement</li>\n+ * </ol>\n+ * </p>\n+ *\n+ * @see <a href=\"http://www.cs.unc.edu/~welch/kalman/\">Kalman filter\n+ *      resources</a>\n+ * @see <a href=\"http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf\">An\n+ *      introduction to the Kalman filter by Greg Welch and Gary Bishop</a>\n+ * @see <a\n+ *      href=\"http://academic.csuohio.edu/simond/courses/eec644/kalman.pdf\">Kalman\n+ *      filter example by Dan Simon</a>\n+ *\n+ * @version $Id$\n+ */\n+public class KalmanFilter {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4878026651422612760L;\n+    /** The transition matrix, equivalent to A */\n+    private transient RealMatrix transitionMatrix;\n+    /** The transposed transition matrix */\n+    private transient RealMatrix transitionMatrixT;\n+    /** The control matrix, equivalent to B */\n+    private transient RealMatrix controlMatrix;\n+    /** The measurement matrix, equivalent to H */\n+    private transient RealMatrix measurementMatrix;\n+    /** The transposed measurement matrix */\n+    private transient RealMatrix measurementMatrixT;\n+    /** The internal state estimation vector, equivalent to x hat */\n+    private transient RealVector stateEstimation;\n+    /** The process noise covariance matrix, equivalent to Q */\n+    private transient RealMatrix processNoise;\n+    /** The measurement noise covariance matrix, equivalent to R */\n+    private transient RealMatrix measurementNoise;\n+    /** The error covariance matrix, equivalent to P */\n+    private transient RealMatrix errorCovariance;\n+\n+    /**\n+     * Creates a new Kalman filter with the given process and measurement\n+     * models.\n+     *\n+     * @param processModel\n+     *            the model defining the underlying process dynamics\n+     * @param measurementModel\n+     *            the model defining the given measurement characteristics\n+     * @throws NullArgumentException\n+     *             if any of the given inputs is null (except for the control\n+     *             matrix)\n+     * @throws NonSquareMatrixException\n+     *             if the transition matrix is non square\n+     * @throws MatrixDimensionMismatchException\n+     *             if the matrix dimensions do not fit together\n+     */\n+    public KalmanFilter(final ProcessModel processModel,\n+            final MeasurementModel measurementModel)\n+            throws NullArgumentException, NonSquareMatrixException,\n+            MatrixDimensionMismatchException {\n+\n+        MathUtils.checkNotNull(processModel);\n+        MathUtils.checkNotNull(measurementModel);\n+\n+        transitionMatrix = processModel.getStateTransitionMatrix();\n+        MathUtils.checkNotNull(transitionMatrix);\n+        transitionMatrixT = transitionMatrix.transpose();\n+\n+        // create an empty matrix if no control matrix was given\n+        controlMatrix = (processModel.getControlMatrix() == null) ?\n+            new Array2DRowRealMatrix() :\n+            processModel.getControlMatrix();\n+\n+        measurementMatrix = measurementModel.getMeasurementMatrix();\n+        MathUtils.checkNotNull(measurementMatrix);\n+        measurementMatrixT = measurementMatrix.transpose();\n+\n+        processNoise = processModel.getProcessNoise();\n+        MathUtils.checkNotNull(processNoise);\n+\n+        measurementNoise = measurementModel.getMeasurementNoise();\n+        MathUtils.checkNotNull(measurementNoise);\n+\n+        // set the initial state estimate to a zero vector if it is not\n+        // available\n+        stateEstimation = (processModel.getInitialStateEstimate() == null) ?\n+            new ArrayRealVector(transitionMatrix.getColumnDimension()) :\n+            processModel.getInitialStateEstimate();\n+        MathUtils.checkNotNull(stateEstimation);\n+\n+        if (transitionMatrix.getColumnDimension() != stateEstimation.getDimension()) {\n+            throw new DimensionMismatchException(transitionMatrix.getColumnDimension(),\n+                                                 stateEstimation.getDimension());\n+        }\n+\n+        // initialize the error covariance to the process noise if it is not\n+        // available\n+        errorCovariance = (processModel.getInitialErrorCovariance() == null) ? processNoise\n+                .copy() : processModel.getInitialErrorCovariance();\n+        MathUtils.checkNotNull(errorCovariance);\n+\n+        // sanity checks, the control matrix B may be null\n+\n+        // A must be a square matrix\n+        if (!transitionMatrix.isSquare()) {\n+            throw new NonSquareMatrixException(\n+                    transitionMatrix.getRowDimension(),\n+                    transitionMatrix.getColumnDimension());\n+        }\n+\n+        // row dimension of B must be equal to A\n+        if (controlMatrix != null &&\n+            controlMatrix.getRowDimension() > 0 &&\n+            controlMatrix.getColumnDimension() > 0 &&\n+            (controlMatrix.getRowDimension() != transitionMatrix.getRowDimension() ||\n+             controlMatrix.getColumnDimension() != 1)) {\n+            throw new MatrixDimensionMismatchException(controlMatrix.getRowDimension(),\n+                                                       controlMatrix.getColumnDimension(),\n+                                                       transitionMatrix.getRowDimension(), 1);\n+        }\n+\n+        // Q must be equal to A\n+        MatrixUtils.checkAdditionCompatible(transitionMatrix, processNoise);\n+\n+        // column dimension of H must be equal to row dimension of A\n+        if (measurementMatrix.getColumnDimension() != transitionMatrix.getRowDimension()) {\n+            throw new MatrixDimensionMismatchException(measurementMatrix.getRowDimension(),\n+                                                       measurementMatrix.getColumnDimension(),\n+                                                       measurementMatrix.getRowDimension(),\n+                                                       transitionMatrix.getRowDimension());\n+        }\n+\n+        // row dimension of R must be equal to row dimension of H\n+        if (measurementNoise.getRowDimension() != measurementMatrix.getRowDimension() ||\n+            measurementNoise.getColumnDimension() != 1) {\n+            throw new MatrixDimensionMismatchException(measurementNoise.getRowDimension(),\n+                                                       measurementNoise.getColumnDimension(),\n+                                                       measurementMatrix.getRowDimension(), 1);\n+        }\n+    }\n+\n+    /**\n+     * Returns the dimension of the state estimation vector.\n+     *\n+     * @return the state dimension\n+     */\n+    public int getStateDimension() {\n+        return stateEstimation.getDimension();\n+    }\n+\n+    /**\n+     * Returns the dimension of the measurement vector.\n+     *\n+     * @return the measurement vector dimension\n+     */\n+    public int getMeasurementDimension() {\n+        return measurementMatrix.getRowDimension();\n+    }\n+\n+    /**\n+     * Returns the current state estimation vector.\n+     *\n+     * @return the state estimation vector\n+     */\n+    public double[] getStateEstimation() {\n+        return stateEstimation.getData();\n+    }\n+\n+    /**\n+     * Returns a copy of the current state estimation vector.\n+     *\n+     * @return the state estimation vector\n+     */\n+    public RealVector getStateEstimationVector() {\n+        return stateEstimation.copy();\n+    }\n+\n+    /**\n+     * Returns the current error covariance matrix.\n+     *\n+     * @return the error covariance matrix\n+     */\n+    public double[][] getErrorCovariance() {\n+        return errorCovariance.getData();\n+    }\n+\n+    /**\n+     * Returns a copy of the current error covariance matrix.\n+     *\n+     * @return the error covariance matrix\n+     */\n+    public RealMatrix getErrorCovarianceMatrix() {\n+        return errorCovariance.copy();\n+    }\n+\n+    /**\n+     * Predict the internal state estimation one time step ahead.\n+     */\n+    public void predict() {\n+        predict((RealVector) null);\n+    }\n+\n+    /**\n+     * Predict the internal state estimation one time step ahead.\n+     *\n+     * @param u\n+     *            the control vector\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the control vector does not fit\n+     */\n+    public void predict(final double[] u) throws DimensionMismatchException {\n+        predict(new ArrayRealVector(u));\n+    }\n+\n+    /**\n+     * Predict the internal state estimation one time step ahead.\n+     *\n+     * @param u\n+     *            the control vector\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the control vector does not fit\n+     */\n+    public void predict(final RealVector u) throws DimensionMismatchException {\n+        // sanity checks\n+        if (u != null &&\n+            u.getDimension() != controlMatrix.getColumnDimension()) {\n+            throw new DimensionMismatchException(u.getDimension(),\n+                                                 controlMatrix.getColumnDimension());\n+        }\n+\n+        // project the state estimation ahead (a priori state)\n+        // xHat(k)- = A * xHat(k-1) + B * u(k-1)\n+        stateEstimation = transitionMatrix.operate(stateEstimation);\n+\n+        // add control input if it is available\n+        if (u != null) {\n+            stateEstimation = stateEstimation.add(controlMatrix.operate(u));\n+        }\n+\n+        // project the error covariance ahead\n+        // P(k)- = A * P(k-1) * A' + Q\n+        errorCovariance = transitionMatrix.multiply(errorCovariance)\n+                .multiply(transitionMatrixT).add(processNoise);\n+    }\n+\n+    /**\n+     * Correct the current state estimate with an actual measurement.\n+     *\n+     * @param z\n+     *            the measurement vector\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the measurement vector does not fit\n+     * @throws SingularMatrixException\n+     *             if the covariance matrix could not be inverted\n+     */\n+    public void correct(final double[] z) throws DimensionMismatchException,\n+                                                 SingularMatrixException {\n+        correct(new ArrayRealVector(z));\n+    }\n+\n+    /**\n+     * Correct the current state estimate with an actual measurement.\n+     *\n+     * @param z\n+     *            the measurement vector\n+     * @throws DimensionMismatchException\n+     *             if the dimension of the measurement vector does not fit\n+     * @throws SingularMatrixException\n+     *             if the covariance matrix could not be inverted\n+     */\n+    public void correct(final RealVector z) throws DimensionMismatchException,\n+                                                   SingularMatrixException {\n+        // sanity checks\n+        if (z != null &&\n+            z.getDimension() != measurementMatrix.getRowDimension()) {\n+            throw new DimensionMismatchException(z.getDimension(),\n+                                                 measurementMatrix.getRowDimension());\n+        }\n+\n+        // S = H * P(k) - * H' + R\n+        RealMatrix S = measurementMatrix.multiply(errorCovariance)\n+            .multiply(measurementMatrixT).add(measurementNoise);\n+\n+        // invert S\n+        // as the error covariance matrix is a symmetric positive\n+        // semi-definite matrix, we can use the cholesky decomposition\n+        DecompositionSolver solver = new CholeskyDecompositionImpl(S).getSolver();\n+        RealMatrix invertedS = solver.getInverse();\n+\n+        // Inn = z(k) - H * xHat(k)-\n+        RealVector innovation = z.subtract(measurementMatrix.operate(stateEstimation));\n+\n+        // calculate gain matrix\n+        // K(k) = P(k)- * H' * (H * P(k)- * H' + R)^-1\n+        // K(k) = P(k)- * H' * S^-1\n+        RealMatrix kalmanGain = errorCovariance.multiply(measurementMatrixT).multiply(invertedS);\n+\n+        // update estimate with measurement z(k)\n+        // xHat(k) = xHat(k)- + K * Inn\n+        stateEstimation = stateEstimation.add(kalmanGain.operate(innovation));\n+\n+        // update covariance of prediction error\n+        // P(k) = (I - K * H) * P(k)-\n+        RealMatrix Identity = MatrixUtils.createRealIdentityMatrix(kalmanGain.getRowDimension());\n+        errorCovariance = Identity.subtract(kalmanGain.multiply(measurementMatrix)).multiply(errorCovariance);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/filter/MeasurementModel.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.filter;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Defines the measurement model for the use with a {@link KalmanFilter}.\n+ *\n+ * @version $Id$\n+ */\n+public interface MeasurementModel {\n+    /**\n+     * Returns the measurement matrix.\n+     *\n+     * @return the measurement matrix\n+     */\n+    RealMatrix getMeasurementMatrix();\n+\n+    /**\n+     * Returns the measurement noise matrix.\n+     *\n+     * @return the measurement noise matrix\n+     */\n+    RealMatrix getMeasurementNoise();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/filter/ProcessModel.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.filter;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+\n+/**\n+ * Defines the process dynamics model for the use with a {@link KalmanFilter}.\n+ *\n+ * @version $Id$\n+ */\n+public interface ProcessModel {\n+    /**\n+     * Returns the state transition matrix.\n+     *\n+     * @return the state transition matrix\n+     */\n+    RealMatrix getStateTransitionMatrix();\n+\n+    /**\n+     * Returns the control matrix.\n+     *\n+     * @return the control matrix\n+     */\n+    RealMatrix getControlMatrix();\n+\n+    /**\n+     * Returns the process noise matrix.\n+     *\n+     * @return the process noise matrix\n+     */\n+    RealMatrix getProcessNoise();\n+\n+    /**\n+     * Returns the initial state estimation vector.\n+     * <p>\n+     * Note: if the return value is zero, the Kalman filter will initialize the\n+     * state estimation with a zero vector.\n+     * </p>\n+     *\n+     * @return the initial state estimation vector\n+     */\n+    RealVector getInitialStateEstimate();\n+\n+    /**\n+     * Returns the initial error covariance matrix.\n+     * <p>\n+     * Note: if the return value is zero, the Kalman filter will initialize the\n+     * error covariance with the process noise matrix.\n+     * </p>\n+     *\n+     * @return the initial error covariance matrix\n+     */\n+    RealMatrix getInitialErrorCovariance();\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.filter;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class KalmanFilterTest {\n+    @Test\n+    public void testConstant() {\n+        double constantValue = 10d;\n+        double measurementNoise = 0.1d;\n+        double processNoise = 1e-5d;\n+\n+        // A = [ 1 ]\n+        RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });\n+        // no control input\n+        RealMatrix B = null;\n+        // H = [ 1 ]\n+        RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });\n+        // x = [ 10 ]\n+        RealVector x = new ArrayRealVector(new double[] { constantValue });\n+        // Q = [ 1e-5 ]\n+        RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });\n+        // R = [ 0.1 ]\n+        RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });\n+\n+        ProcessModel pm\n+            = new DefaultProcessModel(A, B, Q,\n+                                      new ArrayRealVector(new double[] { constantValue }), null);\n+        MeasurementModel mm = new DefaultMeasurementModel(H, R);\n+        KalmanFilter filter = new KalmanFilter(pm, mm);\n+\n+        Assert.assertEquals(1, filter.getMeasurementDimension());\n+        Assert.assertEquals(1, filter.getStateDimension());\n+\n+        assertMatrixEquals(Q.getData(), filter.getErrorCovariance());\n+\n+        // check the initial state\n+        double[] expectedInitialState = new double[] { constantValue };\n+        assertVectorEquals(expectedInitialState, filter.getStateEstimation());\n+\n+        RealVector pNoise = new ArrayRealVector(1);\n+        RealVector mNoise = new ArrayRealVector(1);\n+\n+        RandomGenerator rand = new JDKRandomGenerator();\n+        // iterate 60 steps\n+        for (int i = 0; i < 60; i++) {\n+            filter.predict();\n+\n+            // Simulate the process\n+            pNoise.setEntry(0, processNoise * rand.nextGaussian());\n+\n+            // x = A * x + p_noise\n+            x = A.operate(x).add(pNoise);\n+\n+            // Simulate the measurement\n+            mNoise.setEntry(0, measurementNoise * rand.nextGaussian());\n+\n+            // z = H * x + m_noise\n+            RealVector z = H.operate(x).add(mNoise);\n+\n+            filter.correct(z);\n+\n+            // state estimate should be larger than measurement noise\n+            double diff = Math.abs(constantValue - filter.getStateEstimation()[0]);\n+            // System.out.println(diff);\n+            Assert.assertTrue(MathUtils.compareTo(diff, measurementNoise, 1e-6) < 0);\n+        }\n+\n+        // error covariance should be already very low (< 0.02)\n+        Assert.assertTrue(MathUtils.compareTo(filter.getErrorCovariance()[0][0],\n+                                              0.02d, 1e-6) < 0);\n+    }\n+\n+    private void assertVectorEquals(double[] expected, double[] result) {\n+        Assert.assertEquals(\"Wrong number of rows.\", expected.length,\n+                            result.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            Assert.assertEquals(\"Wrong value at position [\" + i + \"]\",\n+                                expected[i], result[i], 1.0e-15);\n+        }\n+    }\n+\n+    private void assertMatrixEquals(double[][] expected, double[][] result) {\n+        Assert.assertEquals(\"Wrong number of rows.\", expected.length,\n+                            result.length);\n+        for (int i = 0; i < expected.length; i++) {\n+            Assert.assertEquals(\"Wrong number of columns.\", expected[i].length,\n+                                result[i].length);\n+            for (int j = 0; j < expected[i].length; j++) {\n+                Assert.assertEquals(\"Wrong value at position [\" + i + \",\" + j\n+                                    + \"]\", expected[i][j], result[i][j], 1.0e-15);\n+            }\n+        }\n+    }\n+}", "timestamp": 1307828366, "metainfo": ""}