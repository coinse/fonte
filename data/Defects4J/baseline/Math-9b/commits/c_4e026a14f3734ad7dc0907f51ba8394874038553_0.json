{"sha": "4e026a14f3734ad7dc0907f51ba8394874038553", "log": "Implementation of log-normal distributions (MATH-733). Patch contributed by Dennis Hendriks.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/LogNormalDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Erf;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Implementation of the log-normal (gaussian) distribution.\n+ *\n+ * <p>\n+ * <a id=\"parameters\"><strong>Parameters:</strong></a>\n+ * {@code X} is log-normally distributed if its natural logarithm {@code log(X)}\n+ * is normally distributed. The probability distribution function of {@code X}\n+ * is given by (for {@code x >= 0})\n+ * </p>\n+ * <p>\n+ * {@code exp(-0.5 * ((ln(x) - m) / s)^2) / (s * sqrt(2 * pi) * x)}\n+ * </p>\n+ * <ul>\n+ * <li>{@code m} is the <em>scale</em> parameter: this is the mean of the\n+ * normally distributed natural logarithm of this distribution,</li>\n+ * <li>{@code s} is the <em>shape</em> parameter: this is the standard\n+ * deviation of the normally distributed natural logarithm of this\n+ * distribution.\n+ * </ul>\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Log-normal_distribution\">\n+ * Log-normal distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/LogNormalDistribution.html\">\n+ * Log Normal distribution (MathWorld)</a>\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class LogNormalDistribution extends AbstractRealDistribution {\n+    /** Default inverse cumulative probability accuracy. */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20120112;\n+\n+    /** &radic;(2 &pi;) */\n+    private static final double SQRT2PI = FastMath.sqrt(2 * FastMath.PI);\n+\n+    /** &radic;(2) */\n+    private static final double SQRT2 = FastMath.sqrt(2.0);\n+\n+    /** The <a href=\"#parameters\">scale</a> parameter of this distribution. */\n+    private final double scale;\n+\n+    /** The <a href=\"#parameters\">shape</a> parameter of this distribution. */\n+    private final double shape;\n+\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a log-normal distribution using the specified\n+     * <a href=\"#parameters\">scale</a> and\n+     * <a href=\"#parameters\">shape</a>.\n+     *\n+     * @param scale the scale parameter of this distribution\n+     * @param shape the shape parameter of this distribution\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n+     */\n+    public LogNormalDistribution(double scale, double shape)\n+        throws NotStrictlyPositiveException {\n+        this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a log-normal distribution using the specified\n+     * <a href=\"#parameters\">scale</a>, <a href=\"#parameters\">shape</a> and\n+     * inverse cumulative distribution accuracy.\n+     *\n+     * @param scale the scale parameter of this distribution\n+     * @param shape the shape parameter of this distribution\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0}.\n+     */\n+    public LogNormalDistribution(double scale, double shape,\n+        double inverseCumAccuracy) throws NotStrictlyPositiveException {\n+        if (shape <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, shape);\n+        }\n+\n+        this.scale = scale;\n+        this.shape = shape;\n+        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Create a log-normal distribution, where the mean and standard deviation\n+     * of the {@link NormalDistribution normally distributed} natural\n+     * logarithm of the log-normal distribution are equal to zero and one\n+     * respectively. In other words, the scale of the returned distribution is\n+     * {@code 0}, while its shape is {@code 1}.\n+     */\n+    public LogNormalDistribution() {\n+        this(0, 1);\n+    }\n+\n+    /**\n+     * Returns the <a href=\"#parameters\">scale</a> parameter of this distribution.\n+     *\n+     * @return the scale parameter\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"#parameters\">shape</a> parameter of this\n+     * distribution.\n+     *\n+     * @return the shape parameter\n+     */\n+    public double getShape() {\n+        return shape;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For this distribution {@code P(X = x)} always evaluates to 0.\n+     *\n+     * @return 0\n+     */\n+    public double probability(double x) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For scale {@code m}, and shape {@code s} of this distribution, the PDF\n+     * is given by\n+     * <ul>\n+     * <li>{@code 0} if {@code x <= 0},</li>\n+     * <li>{@code exp(-0.5 * ((ln(x) - m) / s)^2) / (s * sqrt(2 * pi) * x)}\n+     * otherwise.</li>\n+     * </ul>\n+     */\n+    public double density(double x) {\n+        if (x <= 0) {\n+            return 0;\n+        }\n+        final double x0 = FastMath.log(x) - scale;\n+        final double x1 = x0 / shape;\n+        return FastMath.exp(-0.5 * x1 * x1) / (shape * SQRT2PI * x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For scale {@code m}, and shape {@code s} of this distribution, the CDF\n+     * is given by\n+     * <ul>\n+     * <li>{@code 0} if {@code x <= 0},</li>\n+     * <li>{@code 0} if {@code ln(x) - m < 0} and {@code m - ln(x) > 40 * s}, as\n+     * in these cases the actual value is within {@code Double.MIN_VALUE} of 0,\n+     * <li>{@code 1} if {@code ln(x) - m >= 0} and {@code ln(x) - m > 40 * s},\n+     * as in these cases the actual value is within {@code Double.MIN_VALUE} of\n+     * 1,</li>\n+     * <li>{@code 0.5 + 0.5 * erf((ln(x) - m) / (s * sqrt(2))} otherwise.</li>\n+     * </ul>\n+     */\n+    public double cumulativeProbability(double x)  {\n+        if (x <= 0) {\n+            return 0;\n+        }\n+        final double dev = FastMath.log(x) - scale;\n+        if (FastMath.abs(dev) > 40 * shape) {\n+            return dev < 0 ? 0.0d : 1.0d;\n+        }\n+        return 0.5 + 0.5 * Erf.erf(dev / (shape * SQRT2));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(double x0, double x1)\n+        throws NumberIsTooLargeException {\n+        if (x0 > x1) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,\n+                                                x0, x1, true);\n+        }\n+        if (x0 <= 0 || x1 <= 0) {\n+            return super.cumulativeProbability(x0, x1);\n+        }\n+        final double denom = shape * SQRT2;\n+        final double v0 = (FastMath.log(x0) - scale) / denom;\n+        final double v1 = (FastMath.log(x1) - scale) / denom;\n+        return 0.5 * Erf.erf(v0, v1);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For scale {@code m} and shape {@code s}, the mean is\n+     * {@code exp(m + s^2 / 2)}.\n+     */\n+    public double getNumericalMean() {\n+        double s = shape;\n+        return FastMath.exp(scale + (s * s / 2));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For scale {@code m} and shape {@code s}, the variance is\n+     * {@code (exp(s^2) - 1) * exp(2 * m + s^2)}.\n+     */\n+    public double getNumericalVariance() {\n+        final double s = shape;\n+        final double ss = s * s;\n+        return (FastMath.exp(ss) - 1) * FastMath.exp(2 * scale + ss);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always positive infinity\n+     * no matter the parameters.\n+     *\n+     * @return upper bound of the support (always\n+     * {@code Double.POSITIVE_INFINITY})\n+     */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double sample()  {\n+        double n = randomData.nextGaussian(0, 1);\n+        return FastMath.exp(scale + shape * n);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/distribution/LogNormalDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for {@link LogNormalDistribution}. Extends\n+ * {@link RealDistributionAbstractTest}. See class javadoc of that class\n+ * for details.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class LogNormalDistributionTest extends RealDistributionAbstractTest {\n+\n+    //-------------- Implementations for abstract methods -----------------------\n+\n+    /** Creates the default real distribution instance to use in tests. */\n+    @Override\n+    public LogNormalDistribution makeDistribution() {\n+        return new LogNormalDistribution(2.1, 1.4);\n+    }\n+\n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R\n+        return new double[] { -2.226325228634938, -1.156887023657177,\n+                              -0.643949578356075, -0.2027950777320613,\n+                              0.305827808237559, 6.42632522863494,\n+                              5.35688702365718, 4.843949578356074,\n+                              4.40279507773206, 3.89417219176244 };\n+    }\n+\n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] { 0, 0, 0, 0, 0.00948199951485, 0.432056525076,\n+                              0.381648158697, 0.354555726206, 0.329513316888,\n+                              0.298422824228 };\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] { 0, 0, 0, 0, 0.0594218160072, 0.0436977691036,\n+                              0.0508364857798, 0.054873528325, 0.0587182664085,\n+                              0.0636229042785 };\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability distribution test\n+     * input values.\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        // Exclude the test points less than zero, as they have cumulative\n+        // probability of zero, meaning the inverse returns zero, and not the\n+        // points less than zero.\n+        double[] points = makeCumulativeTestValues();\n+        double[] points2 = new double[points.length - 4];\n+        System.arraycopy(points, 4, points2, 0, points2.length - 4);\n+        return points2;\n+        //return Arrays.copyOfRange(points, 4, points.length - 4);\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability test expected\n+     * values.\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestValues() {\n+        // Exclude the test points less than zero, as they have cumulative\n+        // probability of zero, meaning the inverse returns zero, and not the\n+        // points less than zero.\n+        double[] points = makeCumulativeTestPoints();\n+        double[] points2 = new double[points.length - 4];\n+        System.arraycopy(points, 4, points2, 0, points2.length - 4);\n+        return points2;\n+        //return Arrays.copyOfRange(points, 1, points.length - 4);\n+    }\n+\n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        setTolerance(LogNormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    //---------------------------- Additional test cases -------------------------\n+\n+    private void verifyQuantiles() throws Exception {\n+        LogNormalDistribution distribution = (LogNormalDistribution)getDistribution();\n+        double mu = distribution.getScale();\n+        double sigma = distribution.getShape();\n+        setCumulativeTestPoints( new double[] { mu - 2 *sigma, mu - sigma,\n+                                                mu, mu + sigma, mu + 2 * sigma,\n+                                                mu + 3 * sigma,mu + 4 * sigma,\n+                                                mu + 5 * sigma });\n+        verifyCumulativeProbabilities();\n+    }\n+\n+    @Test\n+    public void testQuantiles() throws Exception {\n+        setCumulativeTestValues(new double[] {0, 0.0396495152787,\n+                                              0.16601209243, 0.272533253269,\n+                                              0.357618409638, 0.426488363093,\n+                                              0.483255136841, 0.530823013877});\n+        setDensityTestValues(new double[] {0, 0.0873055825147, 0.0847676303432,\n+                                           0.0677935186237, 0.0544105523058,\n+                                           0.0444614628804, 0.0369750288945,\n+                                           0.0312206409653});\n+        verifyQuantiles();\n+        verifyDensities();\n+\n+        setDistribution(new LogNormalDistribution(0, 1));\n+        setCumulativeTestValues(new double[] {0, 0, 0, 0.5, 0.755891404214,\n+                                              0.864031392359, 0.917171480998,\n+                                              0.946239689548});\n+        setDensityTestValues(new double[] {0, 0, 0, 0.398942280401,\n+                                           0.156874019279, 0.07272825614,\n+                                           0.0381534565119, 0.0218507148303});\n+        verifyQuantiles();\n+        verifyDensities();\n+\n+        setDistribution(new LogNormalDistribution(0, 0.1));\n+        setCumulativeTestValues(new double[] {0, 0, 0, 1.28417563064e-117,\n+                                              1.39679883412e-58,\n+                                              1.09839325447e-33,\n+                                              2.52587961726e-20,\n+                                              2.0824223487e-12});\n+        setDensityTestValues(new double[] {0, 0, 0, 2.96247992535e-114,\n+                                           1.1283370232e-55, 4.43812313223e-31,\n+                                           5.85346445002e-18,\n+                                           2.9446618076e-10});\n+        verifyQuantiles();\n+        verifyDensities();\n+    }\n+\n+    @Test\n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0, 1});\n+        setInverseCumulativeTestValues(\n+                new double[] {0, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n+    @Test\n+    public void testGetMean() {\n+        LogNormalDistribution distribution = (LogNormalDistribution)getDistribution();\n+        Assert.assertEquals(2.1, distribution.getScale(), 0);\n+    }\n+\n+    @Test\n+    public void testGetStandardDeviation() {\n+        LogNormalDistribution distribution = (LogNormalDistribution)getDistribution();\n+        Assert.assertEquals(1.4, distribution.getShape(), 0);\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testPreconditions() {\n+        new LogNormalDistribution(1, 0);\n+    }\n+\n+    @Test\n+    public void testDensity() {\n+        double [] x = new double[]{-2, -1, 0, 1, 2};\n+        // R 2.13: print(dlnorm(c(-2,-1,0,1,2)), digits=10)\n+        checkDensity(0, 1, x, new double[] { 0.0000000000, 0.0000000000,\n+                                             0.0000000000, 0.3989422804,\n+                                             0.1568740193 });\n+        // R 2.13: print(dlnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)\n+        checkDensity(1.1, 1, x, new double[] { 0.0000000000, 0.0000000000,\n+                                               0.0000000000, 0.2178521770,\n+                                               0.1836267118});\n+    }\n+\n+    private void checkDensity(double mean, double sd, double[] x, double[] expected) {\n+        LogNormalDistribution d = new LogNormalDistribution(mean, sd);\n+        for (int i = 0; i < x.length; i++) {\n+            Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);\n+        }\n+    }\n+\n+    /**\n+     * Check to make sure top-coding of extreme values works correctly.\n+     * Verifies fixes for JIRA MATH-167, MATH-414\n+     */\n+    @Test\n+    public void testExtremeValues() throws Exception {\n+        LogNormalDistribution d = new LogNormalDistribution(0, 1);\n+        for (int i = 0; i < 1e5; i++) { // make sure no convergence exception\n+            double upperTail = d.cumulativeProbability(i);\n+            if (i <= 72) { // make sure not top-coded\n+                Assert.assertTrue(upperTail < 1.0d);\n+            }\n+            else { // make sure top coding not reversed\n+                Assert.assertTrue(upperTail > 0.99999);\n+            }\n+        }\n+\n+        Assert.assertEquals(d.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n+        Assert.assertEquals(d.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n+        Assert.assertEquals(d.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n+        Assert.assertEquals(d.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n+    }\n+\n+    @Test\n+    public void testMeanVariance() {\n+        final double tol = 1e-9;\n+        LogNormalDistribution dist;\n+\n+        dist = new LogNormalDistribution(0, 1);\n+        Assert.assertEquals(dist.getNumericalMean(), 1.6487212707001282, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(),\n+                            4.670774270471604, tol);\n+\n+        dist = new LogNormalDistribution(2.2, 1.4);\n+        Assert.assertEquals(dist.getNumericalMean(), 24.046753552064498, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(),\n+                            3526.913651880464, tol);\n+\n+        dist = new LogNormalDistribution(-2000.9, 10.4);\n+        Assert.assertEquals(dist.getNumericalMean(), 0.0, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 0.0, tol);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n import org.junit.Test;\n \n /**\n- * Test cases for NormalDistribution.\n- * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n- * ContinuousDistributionAbstractTest for details.\n+ * Test cases for {@link NormalDistribution}. Extends\n+ * {@link RealDistributionAbstractTest}. See class javadoc of that class\n+ * for details.\n  *\n  * @version $Id$\n  */\n \n     //-------------- Implementations for abstract methods -----------------------\n \n-    /** Creates the default continuous distribution instance to use in tests. */\n+    /** Creates the default real distribution instance to use in tests. */\n     @Override\n     public NormalDistribution makeDistribution() {\n         return new NormalDistribution(2.1, 1.4);\n         Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n         Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n         Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n-\n-   }\n+    }\n \n     @Test\n     public void testMath280() {", "timestamp": 1326784322, "metainfo": ""}