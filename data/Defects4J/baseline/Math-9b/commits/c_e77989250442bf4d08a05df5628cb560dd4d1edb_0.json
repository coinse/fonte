{"sha": "e77989250442bf4d08a05df5628cb560dd4d1edb", "log": "Added compose to the public API of DerivativeStructure.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n         }\n     }\n \n+    /** Compute composition of the instance by a univariate function.\n+     * @param f array of value and derivatives of the function at\n+     * the current point (i.e. [f({@link #getValue()}),\n+     * f'({@link #getValue()}), f''({@link #getValue()})...]).\n+     * @return f(this)\n+     * @exception DimensionMismatchException if the number of derivatives\n+     * in the array is not equal to {@link #getOrder() order} + 1\n+     */\n+    public DerivativeStructure compose(final double[] f) {\n+        if (f.length != getOrder() + 1) {\n+            throw new DimensionMismatchException(f.length, getOrder() + 1);\n+        }\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.compose(data, 0, f, result.data, 0);\n+        return result;\n+    }\n+\n     /** {@inheritDoc} */\n     public DerivativeStructure reciprocal() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n import java.util.Arrays;\n import java.util.List;\n \n+import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.util.ArithmeticUtils;\n         }\n     }\n \n+    @Test(expected=DimensionMismatchException.class)\n+    public void testComposeMismatchedDimensions() {\n+        new DerivativeStructure(1, 3, 0, 1.2).compose(new double[3]);\n+    }\n+\n+    @Test\n+    public void testCompose() {\n+        double[] epsilon = new double[] { 1.0e-20, 5.0e-14, 2.0e-13, 3.0e-13, 2.0e-13, 1.0e-20 };\n+        PolynomialFunction poly =\n+                new PolynomialFunction(new double[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 });\n+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {\n+            PolynomialFunction[] p = new PolynomialFunction[maxOrder + 1];\n+            p[0] = poly;\n+            for (int i = 1; i <= maxOrder; ++i) {\n+                p[i] = p[i - 1].polynomialDerivative();\n+            }\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure dsY1 = dsX.getField().getZero();\n+                for (int i = poly.degree(); i >= 0; --i) {\n+                    dsY1 = dsY1.multiply(dsX).add(poly.getCoefficients()[i]);\n+                }\n+                double[] f = new double[maxOrder + 1];\n+                for (int i = 0; i < f.length; ++i) {\n+                    f[i] = p[i].value(x);\n+                }\n+                DerivativeStructure dsY2 = dsX.compose(f);\n+                DerivativeStructure zero = dsY1.subtract(dsY2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n     @Test\n     public void testField() {\n         for (int maxOrder = 1; maxOrder < 5; ++maxOrder) {", "timestamp": 1345313282, "metainfo": ""}