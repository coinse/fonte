{"sha": "446457d7747003d33d1a57db5bdd694b300d2f96", "log": "Initial refactoring of sparse matrix/vector  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n+\n+/**\n+ * Sparse matrix implementation based on an open addressed map.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OpenMapRealMatrix extends AbstractRealMatrix {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5962461716457143437L;\n+\n+    /** Number of rows of the matrix. */\n+    private final int rowDimension;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columnDimension;\n+\n+    /** Storage for (sparse) matrix elements. */\n+    private final OpenIntToDoubleHashMap entries;\n+\n+    /**\n+     * Build a sparse matrix with the supplied row and column dimensions.\n+     * @param rowDimension number of rows of the matrix\n+     * @param columnDimension number of columns of the matrix\n+     */\n+    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n+        super(rowDimension, columnDimension);\n+        this.rowDimension = rowDimension;\n+        this.columnDimension = columnDimension;\n+        this.entries = new OpenIntToDoubleHashMap(0.0);\n+    }\n+  \n+    /**\n+     * Build a matrix by copying another one.\n+     * @param matrix matrix to copy\n+     */\n+    public OpenMapRealMatrix(OpenMapRealMatrix matrix) {\n+        this.rowDimension = matrix.rowDimension;\n+        this.columnDimension = matrix.columnDimension;\n+        this.entries = new OpenIntToDoubleHashMap(matrix.entries);\n+    }\n+  \n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix copy() {\n+        return new OpenMapRealMatrix(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix createMatrix(int rowDimension, int columnDimension)\n+            throws IllegalArgumentException {\n+        return new OpenMapRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columnDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((OpenMapRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix add(OpenMapRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final RealMatrix out = new OpenMapRealMatrix(this);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final int row = iterator.key() / columnDimension;\n+            final int col = iterator.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) + iterator.value());\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((OpenMapRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrix subtract(OpenMapRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final RealMatrix out = new OpenMapRealMatrix(this);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final int row = iterator.key() / columnDimension;\n+            final int col = iterator.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) - iterator.value());\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((OpenMapRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+            final int outCols = m.getColumnDimension();\n+            final DenseRealMatrix out = new DenseRealMatrix(rowDimension, outCols);\n+            for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n+                iterator.advance();\n+                final double value = iterator.value();\n+                final int key      = iterator.key();\n+                final int i        = key / columnDimension;\n+                final int k        = key % columnDimension;\n+                for (int j = 0; j < outCols; ++j) {\n+                    out.addToEntry(i, j, value * m.getEntry(k, j));\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public OpenMapRealMatrix multiply(OpenMapRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int outCols = m.getColumnDimension();\n+        OpenMapRealMatrix out = new OpenMapRealMatrix(rowDimension, outCols);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final double value = iterator.value();\n+            final int key      = iterator.key();\n+            final int i        = key / columnDimension;\n+            final int k        = key % columnDimension;\n+            for (int j = 0; j < outCols; ++j) {\n+                final int rightKey = m.computeKey(k, j);\n+                if (m.entries.containsKey(rightKey)) {\n+                    final int outKey = out.computeKey(i, j);\n+                    final double outValue =\n+                        out.entries.get(outKey) + value * m.entries.get(rightKey);\n+                    if (outValue == 0.0) {\n+                        out.entries.remove(outKey);\n+                    } else {\n+                        out.entries.put(outKey, outValue);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(int row, int column) throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        return entries.get(computeKey(row, column));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rowDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(int row, int column, double value)\n+            throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        if (value == 0.0) {\n+            entries.remove(computeKey(row, column));\n+        } else {\n+            entries.put(computeKey(row, column), value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(int row, int column, double increment)\n+            throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int key = computeKey(row, column);\n+        final double value = entries.get(key) + increment;\n+        if (value == 0.0) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(int row, int column, double factor)\n+            throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int key = computeKey(row, column);\n+        final double value = entries.get(key) * factor;\n+        if (value == 0.0) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Compute the key to access a matrix element\n+     * @param row row index of the matrix element\n+     * @param column column index of the matrix element\n+     * @return key within the map to access the matrix element\n+     */\n+    private int computeKey(int row, int column) {\n+        return row * columnDimension + column;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n+ * @version $Revision: 728186 $ $Date$\n+ * @since 2.0\n+*/\n+public class OpenMapRealVector implements RealVector {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8772222695580707260L;\n+\n+    /** Default Tolerance for having a value considered zero. */\n+    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n+\n+    /** Entries of the vector. */\n+    private final OpenIntToDoubleHashMap entries;\n+\n+    /** Dimension of the vector. */\n+    private final int virtualSize;\n+\n+    /** Tolerance for having a value considered zero. */\n+    private double epsilon;\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #SparseRealVector(OpenMapRealVector, int)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(RealVector)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public OpenMapRealVector() {\n+        this(0, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Construct a (dimension)-length vector of zeros.\n+     * @param dimension size of the vector\n+     */\n+    public OpenMapRealVector(int dimension) {\n+        this(dimension, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n+     * @param dimension Size of the vector\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(int dimension, double epsilon) {\n+        virtualSize = dimension;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Build a resized vector, for use with append.\n+     * @param v The original vector\n+     * @param resize The amount to resize it\n+     */\n+    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n+        virtualSize = v.getDimension() + resize;\n+        entries = new OpenIntToDoubleHashMap(v.entries);\n+        epsilon = v.getEpsilon();\n+    }\n+\n+    /**\n+     * Build a vector with known the sparseness (for advanced use only).\n+     * @param dimension The size of the vector\n+     * @param expectedSize The expected number of non-zero entries\n+     */\n+    public OpenMapRealVector(int dimension, int expectedSize) {\n+        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).\n+     * @param dimension The size of the vector\n+     * @param expectedSize The expected number of non-zero entries\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n+        virtualSize = dimension;\n+        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Create from a double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public OpenMapRealVector(double[] values) {\n+        this(values, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Create from a double array, specifying zero tolerance.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(double[] values, double epsilon) {\n+        virtualSize = values.length;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        this.epsilon = epsilon;\n+        for (int key = 0; key < values.length; key++) {\n+            double value = values[key];\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public OpenMapRealVector(Double[] values) {\n+        this(values, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(Double[] values, double epsilon) {\n+        virtualSize = values.length;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        this.epsilon = epsilon;\n+        for (int key = 0; key < values.length; key++) {\n+            double value = values[key].doubleValue();\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public OpenMapRealVector(OpenMapRealVector v) {\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToDoubleHashMap(v.getEntries());\n+        epsilon = v.getEpsilon();\n+    }\n+\n+    /**\n+     * Generic copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public OpenMapRealVector(RealVector v) {\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        epsilon = DEFAULT_ZERO_TOLERANCE;\n+        for (int key = 0; key < virtualSize; key++) {\n+            double value = v.getEntry(key);\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get the entries of this instance.\n+     * @return entries of this instance\n+     */\n+    private OpenIntToDoubleHashMap getEntries() {\n+        return entries;\n+    }\n+\n+    /**\n+     * Determine if this value is zero.\n+     * @param value The value to test\n+     * @return <code>true</code> if this value is zero, <code>false</code> otherwise\n+     */\n+    protected boolean isZero(double value) {\n+        return value > -epsilon && value < epsilon;\n+    }\n+\n+    /**\n+     * Get the tolerance for having a value considered zero.\n+     * @return The test range for testing if a value is zero\n+     */\n+    public double getEpsilon() {\n+        return epsilon;\n+    }\n+\n+    /**\n+     * Set the tolerance for having a value considered zero.\n+     * @param epsilon The test range for testing if a value is zero\n+     */\n+    public void setEpsilon(double epsilon) {\n+        this.epsilon = epsilon;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return add((OpenMapRealVector) v);\n+        }\n+        return add(v.getData());\n+    }\n+\n+    /**\n+     * Optimized method to add two SparseRealVectors.\n+     * @param v Vector to add with\n+     * @return The sum of <code>this</code> with <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = (OpenMapRealVector)copy();\n+        Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key) + iter.value());\n+            } else {\n+                res.setEntry(key, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n+        for (int i = 0; i < v.length; i++) {\n+            res.setEntry(i, v[i] + getEntry(i));\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Optimized method to append a SparseRealVector.\n+     * @param v vector to append\n+     * @return The result of appending <code>v</code> to self\n+     */\n+    public OpenMapRealVector append(OpenMapRealVector v) {\n+        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n+        Iterator iter = v.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key() + virtualSize, iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(RealVector v) {\n+        if (v instanceof OpenMapRealVector) {\n+            return append((OpenMapRealVector) v);\n+        }\n+        return append(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double d) {\n+        RealVector res = new OpenMapRealVector(this, 1);\n+        res.setEntry(virtualSize, d);\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double[] a) {\n+        RealVector res = new OpenMapRealVector(this, a.length);\n+        for (int i = 0; i < a.length; i++) {\n+            res.setEntry(i + virtualSize, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector copy() {\n+        return new OpenMapRealVector(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += v.getEntry(iter.key()) * iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            int idx = iter.key();\n+            double value = 0;\n+            if (idx < v.length) {\n+                value = v[idx];\n+            }\n+            res += value * iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + n - 1);\n+        OpenMapRealVector res = new OpenMapRealVector(n);\n+        int end = index + n;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (key >= index && key < end) {\n+                res.setEntry(key - index, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        double[] res = new double[virtualSize];\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res[iter.key()] = iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return virtualSize;\n+    }\n+\n+    /**\n+     * Optimized method to compute distance.\n+     * @param v The vector to compute distance to\n+     * @return The distance from <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n+        Iterator iter = entries.iterator();\n+        double res = 0;\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            double delta;\n+            delta = iter.value() - v.getEntry(key);\n+            res += delta * delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                final double value = iter.value();\n+                res += value * value;\n+            }\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return getDistance((OpenMapRealVector) v);\n+        }\n+        return getDistance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double res = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = entries.get(i) - v[i];\n+            res += delta * delta;\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        checkIndex(index);\n+        return entries.get(index);\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     */\n+    public double getL1Distance(OpenMapRealVector v) {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            max += delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                double delta = Math.abs(iter.value());\n+                max +=  Math.abs(delta);\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return getL1Distance((OpenMapRealVector) v);\n+        }\n+        return getL1Distance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = Math.abs(getEntry(i) - v[i]);\n+            max += delta;\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += Math.abs(iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Optimized method to compute LInfDistance.\n+     * @param v The vector to compute from\n+     * @return the LInfDistance\n+     */\n+    private double getLInfDistance(OpenMapRealVector v) {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            if (delta > max) {\n+                max = delta;\n+            }\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                if (iter.value() > max) {\n+                    max = iter.value();\n+                }\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return getLInfDistance((OpenMapRealVector) v);\n+        }\n+        return getLInfDistance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = Math.abs(getEntry(i) - v[i]);\n+            if (delta > max) {\n+                max = delta;\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            max += iter.value();\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += iter.value() * iter.value();\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isInfinite() {\n+        boolean infiniteFound = false;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            final double value = iter.value();\n+            if (Double.isNaN(value)) {\n+                return false;\n+            }\n+            if (Double.isInfinite(value)) {\n+                infiniteFound = true;\n+            }\n+        }\n+        return infiniteFound;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNaN() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            if (Double.isNaN(iter.value())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        return copy().mapAbsToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.abs(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        return copy().mapAcosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.acos(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        return copy().mapAddToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, getEntry(i) + d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        return copy().mapAsinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.asin(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        return copy().mapAtanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.atan(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        return copy().mapCbrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.cbrt(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        return copy().mapCeilToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.ceil(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        return copy().mapCosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.cos(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        return copy().mapCoshToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.cosh(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivideToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() / d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        return copy().mapExpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            entries.put(i, Math.exp(entries.get(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        return copy().mapExpm1ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.expm1(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        return copy().mapFloorToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.floor(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        return copy().mapInvToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInvToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, 1.0/getEntry(i));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        return copy().mapLogToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        return copy().mapLog10ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.log10(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        return copy().mapLog1pToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.log1p(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.log(getEntry(i)));\n+        }\n+       return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() * d);\n+        }\n+        return this;\n+    }\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        return copy().mapPowToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPowToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.pow(iter.value(), d));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        return copy().mapRintToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.rint(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        return copy().mapSignumToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.signum(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        return copy().mapSinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sin(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        return copy().mapSinhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sinh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        return copy().mapSqrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sqrt(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        return copy().mapSubtractToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d) {\n+        return mapAddToSelf(-d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        return copy().mapTanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.tan(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        return copy().mapTanhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.tanh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        return copy().mapUlpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.ulp(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Optimized method to compute the outer product.\n+     * @param v The vector to comput the outer product on\n+     * @return The outer product of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public OpenMapRealMatrix outerproduct(OpenMapRealVector v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            Iterator iter2 = v.getEntries().iterator();\n+            while (iter2.hasNext()) {\n+                iter2.advance();\n+                res.setEntry(iter.key(), iter2.key(), iter.value()*iter2.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+            throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return outerproduct((OpenMapRealVector)v);\n+        }\n+        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, iter.value()*v.getEntry(col));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            double value = iter.value();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, value * v[col]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        return projection(new OpenMapRealVector(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, double value) throws MatrixIndexException {\n+        checkIndex(index);\n+        if (!isZero(value)) {\n+            entries.put(index, value);\n+        } else if (entries.containsKey(index)) {\n+            entries.remove(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.getDimension() - 1);\n+        setSubVector(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.length - 1);\n+        for (int i = 0; i < v.length; i++) {\n+            setEntry(i + index, v[i]);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, value);\n+        }\n+    }\n+\n+    /**\n+     * Optimized method to subtract SparseRealVectors.\n+     * @param v The vector to subtract from <code>this</code>\n+     * @return The difference of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = (OpenMapRealVector)copy();\n+        Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key) - iter.value());\n+            } else {\n+                res.setEntry(key, -iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return subtract((OpenMapRealVector) v);\n+        }\n+        return subtract(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        for (int i = 0; i < v.length; i++) {\n+            if (entries.containsKey(i)) {\n+                res.setEntry(i, entries.get(i) - v[i]);\n+            } else {\n+                res.setEntry(i, -v[i]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() {\n+        RealVector res = copy();\n+        res.unitize();\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() {\n+        double norm = getNorm();\n+        if (isZero(norm)) {\n+            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+        }\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() / norm);\n+        }\n+\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     *\n+     * @param index\n+     *            index to check\n+     * @exception MatrixIndexException\n+     *                if index is not valid\n+     */\n+    private void checkIndex(final int index) throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     *\n+     * @param n\n+     *            expected dimension.\n+     * @exception IllegalArgumentException\n+     *                if the dimension is inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n+        if (getDimension() != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    getDimension(), n);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray() {\n+        return getData();\n+    }\n+\n+    /** {@inheritDoc} \n+     * <p> Implementation Note: This works on exact values, and as a result\n+     * it is possible for {@code a.subtract(b)} to be the zero vector, while\n+     * {@code a.hashCode() != b.hashCode()}.</p>\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        long temp;\n+        temp = Double.doubleToLongBits(epsilon);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        result = prime * result + virtualSize;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            temp = Double.doubleToLongBits(iter.value());\n+            result = prime * result + (int) (temp ^ (temp >>32));\n+        }\n+        return result;\n+    }\n+\n+    /**  \n+     * <p> Implementation Note: This performs an exact comparison, and as a result\n+     * it is possible for {@code a.subtract(b}} to be the zero vector, while \n+     * {@code  a.equals(b) == false}.</p>\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (!(obj instanceof OpenMapRealVector)) {\n+            return false;\n+        }\n+        OpenMapRealVector other = (OpenMapRealVector) obj;\n+        if (virtualSize != other.virtualSize) {\n+            return false;\n+        }\n+        if (Double.doubleToLongBits(epsilon) !=\n+            Double.doubleToLongBits(other.epsilon)) {\n+            return false;\n+        }\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double test = other.getEntry(iter.key());\n+            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n+                return false;\n+            }\n+        }\n+        iter = other.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double test = iter.value();\n+            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}", "timestamp": 1242598370, "metainfo": ""}