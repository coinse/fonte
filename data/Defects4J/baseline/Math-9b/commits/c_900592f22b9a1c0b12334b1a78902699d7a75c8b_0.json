{"sha": "900592f22b9a1c0b12334b1a78902699d7a75c8b", "log": "Added first batch of weighted statistics   * mean   * sum   * product   * variance JIRA: MATH-287 Thanks to Matthew Rowles  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n      * {@inheritDoc}\n      */\n     public abstract double evaluate(final double[] values, final int begin, final int length);\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * to verify that the input parameters designate a subarray of positive length.\n      * <p>\n      * <ul>\n-     * <li>returns <code>true</code> iff the parameters designate a subarray of \n+     * <li>returns <code>true</code> iff the parameters designate a subarray of\n      * positive length</li>\n      * <li>throws <code>IllegalArgumentException</code> if the array is null or\n      * or the indices are invalid</li>\n-     * <li>returns <code>false</li> if the array is non-null, but \n+     * <li>returns <code>false</li> if the array is non-null, but\n      * <code>length</code> is 0.\n      * </ul></p>\n      *\n         if (values == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n         }\n-        \n+\n         if (begin < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"start position cannot be negative ({0})\", begin);\n         }\n-        \n+\n         if (length < 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"length cannot be negative ({0})\", length);\n         }\n-        \n+\n         if (begin + length > values.length) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"subarray ends after array end\");\n         return true;\n \n     }\n-}\n+\n+    /**\n+     * This method is used by <code>evaluate(double[], double[], int, int)</code> methods\n+     * to verify that the begin and length parameters designate a subarray of positive length\n+     * and the weights are all non-negative, non-NaN, finite, and not all zero.\n+     * <p>\n+     * <ul>\n+     * <li>returns <code>true</code> iff the parameters designate a subarray of\n+     * positive length and the weights array contains legitimate values.</li>\n+     * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li></ul>\n+     * </li>\n+     * <li>returns <code>false</li> if the array is non-null, but\n+     * <code>length</code> is 0.\n+     * </ul></p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return true if the parameters are valid and designate a subarray of positive length\n+     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     */\n+    protected boolean test(\n+        final double[] values,\n+        final double[] weights,\n+        final int begin,\n+        final int length) {\n+\n+        if (weights == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"input weights array is null\");\n+        }\n+\n+        if (weights.length !=  values.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"Different number of weights and values\");\n+        }\n+\n+        boolean containsPositiveWeight = false;\n+        for (int i = begin; i < begin + length; i++) {\n+            if (Double.isNaN(weights[i])) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"NaN weight at index {0}\", i);\n+            }\n+            if (Double.isInfinite(weights[i])) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"Infinite weight at index {0}\", i);\n+            }\n+            if (weights[i] < 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"negative weight {0} at index {1} \", weights[i], i);\n+            }\n+            if (!containsPositiveWeight && weights[i] > 0.0) {\n+                containsPositiveWeight = true;\n+            }\n+        }\n+        \n+        if (!containsPositiveWeight) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"weight array must contain at least one non-zero value\");\n+        }\n+\n+        return test(values, begin, length);\n+    }\n+}\n+\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n \n /**\n- * <p>Computes the arithmetic mean of a set of values. Uses the definitional \n+ * <p>Computes the arithmetic mean of a set of values. Uses the definitional\n  * formula:</p>\n  * <p>\n  * mean = sum(x_i) / n\n  * <p>where <code>n</code> is the number of observations.\n  * </p>\n  * <p>When {@link #increment(double)} is used to add data incrementally from a\n- * stream of (unstored) values, the value of the statistic that \n+ * stream of (unstored) values, the value of the statistic that\n  * {@link #getResult()} returns is computed using the following recursive\n  * updating algorithm: </p>\n  * <ol>\n \n     /**\n      * Constructs a Mean with an External Moment.\n-     * \n+     *\n      * @param m1 the moment\n      */\n     public Mean(final FirstMoment m1) {\n         this.moment = m1;\n         incMoment = false;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Mean} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Mean} instance to copy\n      */\n     public Mean(Mean original) {\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * See {@link Mean} for details on the computing algorithm.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         if (test(values, begin, length)) {\n             Sum sum = new Sum();\n             double sampleSize = length;\n-            \n+\n             // Compute initial estimate using definitional formula\n             double xbar = sum.evaluate(values, begin, length) / sampleSize;\n-            \n+\n             // Compute correction factor in second pass\n             double correction = 0;\n             for (int i = begin; i < begin + length; i++) {\n         }\n         return Double.NaN;\n     }\n-    \n+\n+    /**\n+     * Returns the weighted arithmetic mean of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     * <p>\n+     * See {@link Mean} for details on the computing algorithm. The two-pass algorithm\n+     * described above is used here, with weights applied in computing both the original\n+     * estimate and the correction factor.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li>\n+     * </ul></p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the mean of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights,\n+                           final int begin, final int length) {\n+        if (test(values, weights, begin, length)) {\n+            Sum sum = new Sum();\n+\n+            // Compute initial estimate using definitional formula\n+            double sumw = sum.evaluate(weights,begin,length);\n+            double xbarw = sum.evaluate(values, weights, begin, length) / sumw;\n+\n+            // Compute correction factor in second pass\n+            double correction = 0;\n+            for (int i = begin; i < begin + length; i++) {\n+                correction += weights[i] * (values[i] - xbarw);\n+            }\n+            return xbarw + (correction/sumw);\n+        }\n+        return Double.NaN;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n-    \n+\n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Mean to copy\n      * @param dest Mean to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n \n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n \n /**\n  * Computes the variance of the available values.  By default, the unbiased\n- * \"sample variance\" definitional formula is used: \n+ * \"sample variance\" definitional formula is used:\n  * <p>\n  * variance = sum((x_i - mean)^2) / (n - 1) </p>\n  * <p>\n  * The definitional formula does not have good numerical properties, so\n  * this implementation does not compute the statistic using the definitional\n  * formula. <ul>\n- * <li> The <code>getResult</code> method computes the variance using \n+ * <li> The <code>getResult</code> method computes the variance using\n  * updating formulas based on West's algorithm, as described in\n  * <a href=\"http://doi.acm.org/10.1145/359146.359152\"> Chan, T. F. and\n  * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n  * vol. 22 no. 9, pp. 526-531.</a></li>\n  * <li> The <code>evaluate</code> methods leverage the fact that they have the\n- * full array of values in memory to execute a two-pass algorithm. \n+ * full array of values in memory to execute a two-pass algorithm.\n  * Specifically, these methods use the \"corrected two-pass algorithm\" from\n  * Chan, Golub, Levesque, <i>Algorithms for Computing the Sample Variance</i>,\n- * American Statistician, August 1983.</li></ul>\n- * Note that adding values using <code>increment</code> or \n+ * American Statistician, vol. 37, no. 3 (1983) pp. 242-247.</li></ul>\n+ * Note that adding values using <code>increment</code> or\n  * <code>incrementAll</code> and then executing <code>getResult</code> will\n- * sometimes give a different, less accurate, result than executing \n+ * sometimes give a different, less accurate, result than executing\n  * <code>evaluate</code> with the full array of values. The former approach\n  * should only be used when the full array of values is not available.</p>\n  * <p>\n      * constructed with an external SecondMoment as a parameter.\n      */\n     protected boolean incMoment = true;\n-    \n+\n     /**\n      * Determines whether or not bias correction is applied when computing the\n-     * value of the statisic.  True means that bias is corrected.  See \n+     * value of the statisic.  True means that bias is corrected.  See\n      * {@link Variance} for details on the formula.\n      */\n     private boolean isBiasCorrected = true;\n \n     /**\n      * Constructs a Variance based on an external second moment.\n-     * \n+     *\n      * @param m2 the SecondMoment (Third or Fourth moments work\n      * here as well.)\n      */\n         incMoment = false;\n         this.moment = m2;\n     }\n-    \n+\n     /**\n      * Constructs a Variance with the specified <code>isBiasCorrected</code>\n      * property\n-     * \n+     *\n      * @param isBiasCorrected  setting for bias correction - true means\n      * bias will be corrected and is equivalent to using the argumentless\n      * constructor\n         moment = new SecondMoment();\n         this.isBiasCorrected = isBiasCorrected;\n     }\n-    \n+\n     /**\n      * Constructs a Variance with the specified <code>isBiasCorrected</code>\n      * property and the supplied external second moment.\n-     * \n+     *\n      * @param isBiasCorrected  setting for bias correction - true means\n      * bias will be corrected\n      * @param m2 the SecondMoment (Third or Fourth moments work\n     public Variance(boolean isBiasCorrected, SecondMoment m2) {\n         incMoment = false;\n         this.moment = m2;\n-        this.isBiasCorrected = isBiasCorrected;      \n-    }\n-   \n+        this.isBiasCorrected = isBiasCorrected;\n+    }\n+\n     /**\n      * Copy constructor, creates a new {@code Variance} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Variance} instance to copy\n      */\n     public Variance(Variance original) {\n         copy(original, this);\n-    }           \n-    \n-    /**\n-     * {@inheritDoc}  \n-     * <p>If all values are available, it is more accurate to use \n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>If all values are available, it is more accurate to use\n      * {@link #evaluate(double[])} rather than adding values one at a time\n      * using this method and then executing {@link #getResult}, since\n-     * <code>evaluate</code> leverages the fact that is has the full \n-     * list of values together to execute a two-pass algorithm.  \n+     * <code>evaluate</code> leverages the fact that is has the full\n+     * list of values together to execute a two-pass algorithm.\n      * See {@link Variance}.</p>\n      */\n     @Override\n     public long getN() {\n         return moment.getN();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n             moment.clear();\n         }\n     }\n-    \n-    /**\n-     * Returns the variance of the entries in the input array, or \n+\n+    /**\n+     * Returns the variance of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * See {@link Variance} for details on the computing algorithm.</p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @return the variance of the values or Double.NaN if length = 0\n      * @throws IllegalArgumentException if the array is null\n      * Does not change the internal state of the statistic.</p>\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         }\n         return var;\n     }\n-    \n+\n+    /**\n+     * <p>Returns the weighted variance of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.</p>\n+     * <p>\n+     * Uses the formula <pre>\n+     *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n+     * </pre>\n+     * where weightedMean is the weighted mean</p>\n+     * <p>\n+     * This formula will not return the same result as the unweighted variance when all\n+     * weights are equal, unless all weights are equal to 1. The formula assumes that\n+     * weights are to be treated as \"expansion values,\" as will be the case if for example\n+     * the weights represent frequency counts. To normalize weights so that the denominator\n+     * in the variance computation equals the length of the input vector minus one, use <pre>\n+     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length)); </code>\n+     * </pre>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li>\n+     * </ul></p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights,\n+                           final int begin, final int length) {\n+\n+        double var = Double.NaN;\n+\n+        if (test(values, weights,begin, length)) {\n+            clear();\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                Mean mean = new Mean();\n+                double m = mean.evaluate(values, weights, begin, length);\n+                var = evaluate(values, weights, m, begin, length);\n+            }\n+        }\n+        return var;\n+    }\n+\n     /**\n      * Returns the variance of the entries in the specified portion of\n-     * the input array, using the precomputed mean value.  Returns \n+     * the input array, using the precomputed mean value.  Returns\n      * <code>Double.NaN</code> if the designated subarray is empty.\n      * <p>\n      * See {@link Variance} for details on the computing algorithm.</p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @param begin index of the first array element to include\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n-    public double evaluate(final double[] values, final double mean, \n+    public double evaluate(final double[] values, final double mean,\n             final int begin, final int length) {\n-        \n+\n         double var = Double.NaN;\n \n         if (test(values, begin, length)) {\n                     accum += dev * dev;\n                     accum2 += dev;\n                 }\n-                double len = length;            \n+                double len = length;\n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / len)) / (len - 1.0);\n                 } else {\n         }\n         return var;\n     }\n-    \n+\n+    /**\n+     * Returns the weighted variance of the entries in the specified portion of\n+     * the input array, using the precomputed weighted mean value.  Returns\n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * Uses the formula <pre>\n+     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n+     * </pre></p>\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the weighted arithmetic\n+     * mean of the sample data, not a known population parameter. This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * This formula will not return the same result as the unweighted variance when all\n+     * weights are equal, unless all weights are equal to 1. The formula assumes that\n+     * weights are to be treated as \"expansion values,\" as will be the case if for example\n+     * the weights represent frequency counts. To normalize weights so that the denominator\n+     * in the variance computation equals the length of the input vector minus one, use <pre>\n+     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length)); </code>\n+     * </pre>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li>\n+     * </ul></p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param mean the precomputed weighted mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights,\n+                           final double mean, final int begin, final int length) {\n+\n+        double var = Double.NaN;\n+\n+        if (test(values, weights, begin, length)) {\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                double accum = 0.0;\n+                double dev = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    dev = values[i] - mean;\n+                    accum += weights[i] * (dev * dev);\n+                }\n+\n+                double sumWts = 0;\n+                for (int i = 0; i < weights.length; i++) {\n+                    sumWts += weights[i];\n+                }\n+                \n+                if (isBiasCorrected) {\n+                    var = accum / (sumWts - 1);\n+                } else {\n+                    var = accum / sumWts;\n+                }\n+            }\n+        }\n+        return var;\n+    }\n+\n     /**\n      * Returns the variance of the entries in the input array, using the\n      * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the variance of the values or Double.NaN if the array is empty\n     public void setBiasCorrected(boolean isBiasCorrected) {\n         this.isBiasCorrected = isBiasCorrected;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n-    \n+\n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Variance to copy\n      * @param dest Variance to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n \n /**\n  * Returns the product of the available values.\n         n = 0;\n         value = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Product} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Product} instance to copy\n      */\n     public Product(Product original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         }\n         return product;\n     }\n-    \n+\n+    /**\n+     * <p>Returns the weighted product of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.</p>\n+     * \n+     * <p>Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li>\n+     * </ul></p>\n+     * \n+     * <p>Uses the formula, <pre>\n+     *    weighted product = &prod;values[i]<sup>weights[i]</sup>\n+     * </pre>\n+     * that is, the weights are applied as exponents when computing the weighted product.</p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the product of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights,\n+                           final int begin, final int length) {\n+        double product = Double.NaN;\n+        if (test(values, weights, begin, length)) {\n+            product = 1.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                product *= Math.pow(values[i], weights[i]);\n+            }\n+        }\n+        return product;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Product to copy\n      * @param dest Product to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n         n = 0;\n         value = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Sum} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Sum} instance to copy\n      */\n     public Sum(Sum original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         }\n         return sum;\n     }\n-    \n+\n+    /**\n+     * The weighted sum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     *     <li>the start and length arguments do not determine a valid array</li>\n+     * </ul></p>\n+     * <p>\n+     * Uses the formula, <pre>\n+     *    weighted sum = &Sigma;(values[i] * weights[i])\n+     * </pre></p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights,\n+                           final int begin, final int length) {\n+        double sum = Double.NaN;\n+        if (test(values, weights, begin, length)) {\n+            sum = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sum += (values[i] * weights[i]);\n+            }\n+        }\n+        return sum;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Sum to copy\n      * @param dest Sum to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n     }\n     \n     protected double[] testArray = {0, 1, 2, 3, 4, 5};\n+    protected double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};\n+    protected double[] testNegativeWeightsArray = {-0.3, 0.2, -1.3, 1.1, 1.0, 1.8};\n     protected double[] nullArray = null;\n     protected double[] singletonArray = {0};\n     protected Mean testStatistic = new Mean();\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }      \n-    } \n+        }\n+        try {\n+            testStatistic.test(testArray, nullArray, 0, 1);  // null weights array\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(singletonArray, testWeightsArray, 0, 1);  // weights.length != value.length\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, testNegativeWeightsArray, 0, 6);  // can't have negative weights\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n+ *\n+s * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  */\n package org.apache.commons.math.stat.descriptive;\n \n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n import junit.framework.TestCase;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n     protected double thirdMoment = 868.0906859504136;\n     protected double fourthMoment = 9244.080993773481;\n \n+\n+    protected double weightedMean = 12.366995073891626d;\n+    protected double weightedVar =   9.974760968886391d; \n+    protected double weightedStd = Math.sqrt(weightedVar);\n+    protected double weightedProduct = 8517647448765288000000d;\n+    protected double weightedSum = 251.05d;\n+\n     protected double tolerance = 10E-12;\n \n     protected double[] testArray =\n-        {12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3,\n-          14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,\n-           9, 12.3 };\n+        { 12.5, 12.0, 11.8, 14.2, 14.9, 14.5, 21.0,  8.2, 10.3, 11.3,\n+          14.1,  9.9, 12.2, 12.0, 12.1, 11.0, 19.8, 11.0, 10.0,  8.8,\n+           9.0, 12.3 };\n+\n+    protected double[] testWeightsArray =\n+        {  1.5,  0.8,  1.2,  0.4,  0.8,  1.8,  1.2,  1.1,  1.0,  0.7,\n+           1.3,  0.6,  0.7,  1.3,  0.7,  1.0,  0.4,  0.1,  1.4,  0.9,\n+           1.1,  0.3 };\n+\n+    protected double[] identicalWeightsArray =\n+        {  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n+           0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n+           0.5,  0.5 };\n+\n+    protected double[] unitWeightsArray =\n+        {  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,\n+           1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,\n+           1.0,  1.0 };\n+\n \n     public UnivariateStatisticAbstractTest(String name) {\n         super(name);\n         return tolerance;\n     }\n \n-    public void testEvaluation() throws Exception {   \n+    public void testEvaluation() throws Exception {\n         assertEquals(\n             expectedValue(),\n             getUnivariateStatistic().evaluate(testArray),\n             getTolerance());\n     }\n-    \n+\n     public void testCopy() throws Exception {\n         UnivariateStatistic original = getUnivariateStatistic();\n         UnivariateStatistic copy = original.copy();\n                 getTolerance());\n     }\n     \n+    /**\n+     * Tests consistency of weighted statistic computation.\n+     * For statistics that support weighted evaluation, this test case compares\n+     * the result of direct computation on an array with repeated values with\n+     * a weighted computation on the corresponding (shorter) array with each\n+     * value appearing only once but with a weight value equal to its multiplicity\n+     * in the repeating array.\n+     */\n+    \n+    public void testWeightedConsistency() throws Exception {\n+        \n+        // See if this statistic computes weighted statistics\n+        // If not, skip this test\n+        UnivariateStatistic statistic = getUnivariateStatistic();\n+        Method evaluateMethod = null;\n+        try {\n+            evaluateMethod = statistic.getClass().getDeclaredMethod(\"evaluate\",\n+                double[].class, double[].class, int.class, int.class);\n+        } catch (NoSuchMethodException ex) {\n+            return;  // skip test\n+        }\n+        \n+        // Create arrays of values and corresponding integral weights\n+        // and longer array with values repeated according to the weights\n+        final int len = 10;        // length of values array\n+        final double mu = 0;       // mean of test data\n+        final double sigma = 5;    // std dev of test data \n+        double[] values = new double[len];\n+        double[] weights = new double[len];\n+        RandomData randomData = new RandomDataImpl();  \n+        \n+        // Fill weights array with random int values between 1 and 5\n+        int[] intWeights = new int[len];\n+        for (int i = 0; i < len; i++) {\n+            intWeights[i] = randomData.nextInt(1, 5);\n+            weights[i] = intWeights[i];\n+        }\n+        \n+        // Fill values array with random data from N(mu, sigma)\n+        // and fill valuesList with values from values array with\n+        // values[i] repeated weights[i] times, each i\n+        List<Double> valuesList = new ArrayList<Double>();\n+        for (int i = 0; i < len; i++) {\n+            double value = randomData.nextGaussian(mu, sigma);\n+            values[i] = value;\n+            for (int j = 0; j < intWeights[i]; j++) {\n+                valuesList.add(new Double(value));\n+            }\n+        }\n+        \n+        // Dump valuesList into repeatedValues array\n+        int sumWeights = valuesList.size();\n+        double[] repeatedValues = new double[sumWeights];\n+        for (int i = 0; i < sumWeights; i++) {\n+            repeatedValues[i] = valuesList.get(i);\n+        }\n+        \n+        // Compare result of weighted statistic computation with direct computation\n+        // on array of repeated values\n+        double weightedResult = (Double) evaluateMethod.invoke(\n+                statistic, values, weights, 0, values.length);\n+        TestUtils.assertRelativelyEquals(\n+                statistic.evaluate(repeatedValues), weightedResult, 10E-14); \n+        \n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class MeanTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Mean stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Mean  Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.mean;\n     }\n-    \n+\n+    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    public double expectedWeightedValue() {\n+        return this.weightedMean;\n+    }\n+\n     public void testSmallSamples() {\n         Mean mean = new Mean();\n         assertTrue(Double.isNaN(mean.getResult()));\n         assertEquals(1d, mean.getResult(), 0);\n     }\n \n+    public void testWeightedMean() {\n+        Mean mean = new Mean();\n+        assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n+        assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance());\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n         suite.setName(\"Variance Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.var;\n     }\n-    \n+\n+    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    public double expectedWeightedValue() {\n+        return this.weightedVar;\n+    }\n+\n     /**\n      * Make sure Double.NaN is returned iff n = 0\n      *\n         std.increment(1d);\n         assertEquals(0d, std.getResult(), 0);\n     }\n-    \n+\n     /**\n      * Test population version of variance\n-     */ \n+     */\n     public void testPopulation() {\n         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n         SecondMoment m = new SecondMoment();\n         v1.incrementAll(values);\n         assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n         v1 = new Variance(false, m);\n-        assertEquals(populationVariance(values), v1.getResult(), 1E-14);     \n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n         v1 = new Variance(false);\n         assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n         v1.incrementAll(values);\n-        assertEquals(populationVariance(values), v1.getResult(), 1E-14);     \n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n     }\n-    \n+\n     /**\n      * Definitional formula for population variance\n      */\n         double mean = new Mean().evaluate(v);\n         double sum = 0;\n         for (int i = 0; i < v.length; i++) {\n-           sum += (v[i] - mean) * (v[i] - mean); \n+           sum += (v[i] - mean) * (v[i] - mean);\n         }\n         return sum / v.length;\n     }\n \n+    public void testWeightedVariance() {\n+        Variance variance = new Variance();\n+        assertEquals(expectedWeightedValue(), \n+                variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n+        \n+        // All weights = 1 -> weighted variance = unweighted variance\n+        assertEquals(expectedValue(),\n+                variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n+        \n+        // All weights the same -> when weights are normalized to sum to the length of the values array,\n+        // weighted variance = unweighted value\n+        assertEquals(expectedValue(),\n+                variance.evaluate(testArray, MathUtils.normalizeArray(identicalWeightsArray, testArray.length),\n+                        0, testArray.length), getTolerance());\n+        \n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class ProductTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Product stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Product Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double getTolerance() {\n         return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.product;\n     }\n-    \n+\n+    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    public double expectedWeightedValue() {\n+        return this.weightedProduct;\n+    }\n+\n     public void testSpecialValues() {\n         Product product = new Product();\n         assertTrue(Double.isNaN(product.getResult()));\n         product.increment(Double.NEGATIVE_INFINITY);\n         assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);\n         product.increment(Double.NaN);\n-        assertTrue(Double.isNaN(product.getResult())); \n+        assertTrue(Double.isNaN(product.getResult()));\n         product.increment(1);\n-        assertTrue(Double.isNaN(product.getResult())); \n+        assertTrue(Double.isNaN(product.getResult()));\n+    }\n+\n+    public void testWeightedProduct() {\n+        Product product = new Product();\n+        assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance());\n+        assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class SumTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Sum stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Sum Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public UnivariateStatistic getUnivariateStatistic() {\n-        return new Sum();      \n+        return new Sum();\n     }\n \n     /**\n     public double expectedValue() {\n         return this.sum;\n     }\n-    \n+\n+    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    public double expectedWeightedValue() {\n+        return this.weightedSum;\n+    }\n+\n     public void testSpecialValues() {\n         Sum sum = new Sum();\n         assertTrue(Double.isNaN(sum.getResult()));\n         sum.increment(Double.NEGATIVE_INFINITY);\n         assertTrue(Double.isNaN(sum.getResult()));\n         sum.increment(1);\n-        assertTrue(Double.isNaN(sum.getResult())); \n+        assertTrue(Double.isNaN(sum.getResult()));\n+    }\n+\n+    public void testWeightedSum() {\n+        Sum sum = new Sum();\n+        assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n+        assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n     }\n \n }", "timestamp": 1251683769, "metainfo": ""}