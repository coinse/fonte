{"sha": "7c8dd3ccc3dadf928ab961fec5b75ec7897b59c4", "log": "set eol-style property to native  ", "commit": "\n--- a/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/NevilleInterpolator.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import java.io.Serializable;\n-import org.apache.commons.math.MathException;\n-\n-/**\n- * Implements the <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n- * Neville's Algorithm</a> for interpolation of real univariate functions. For\n- * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n- * chapter 2.\n- * <p>\n- * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n- * this class provides an easy-to-use interface to it.\n- *\n- * @version $Revision$ $Date$\n- */\n-public class NevilleInterpolator implements UnivariateRealInterpolator,\n-    Serializable {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = 3003707660147873733L;\n-\n-    /**\n-     * Computes an interpolating function for the data set.\n-     *\n-     * @param x the interpolating points array\n-     * @param y the interpolating values array\n-     * @return a function which interpolates the data set\n-     * @throws MathException if arguments are invalid\n-     */\n-    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n-        MathException {\n-\n-        PolynomialFunctionLagrangeForm p;\n-        p = new PolynomialFunctionLagrangeForm(x, y);\n-        return p;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+ * Neville's Algorithm</a> for interpolation of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 2.\n+ * <p>\n+ * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class NevilleInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 3003707660147873733L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments are invalid\n+     */\n+    public UnivariateRealFunction interpolate(double x[], double y[]) throws\n+        MathException {\n+\n+        PolynomialFunctionLagrangeForm p;\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+        return p;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionNewtonForm.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import java.io.Serializable;\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Implements the representation of a real polynomial function in\n- * Newton Form. For reference, see <b>Elementary Numerical Analysis</b>,\n- * ISBN 0070124477, chapter 2.\n- * <p>\n- * The formula of polynomial in Newton form is\n- *     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n- *            a[n](x-c[0])(x-c[1])...(x-c[n-1])\n- * Note that the length of a[] is one more than the length of c[]\n- *\n- * @version $Revision$ $Date$\n- */\n-public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,\n-    Serializable {\n-\n-    /** serializable version identifier */\n-    static final long serialVersionUID = -3353896576191389897L;\n-\n-    /**\n-     * The coefficients of the polynomial, ordered by degree -- i.e.\n-     * coefficients[0] is the constant term and coefficients[n] is the \n-     * coefficient of x^n where n is the degree of the polynomial.\n-     */\n-    private double coefficients[];\n-\n-    /**\n-     * Members of c[] are called centers of the Newton polynomial.\n-     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n-     * i.e. a[i] = coefficients[i].\n-     */\n-    private double a[], c[];\n-\n-    /**\n-     * Whether the polynomial coefficients are available.\n-     */\n-    private boolean coefficientsComputed;\n-\n-    /**\n-     * Construct a Newton polynomial with the given a[] and c[]. The order of\n-     * centers are important in that if c[] shuffle, then values of a[] would\n-     * completely change, not just a permutation of old a[].\n-     * <p>\n-     * The constructor makes copy of the input arrays and assigns them.\n-     * \n-     * @param a the coefficients in Newton form formula\n-     * @param c the centers\n-     * @throws IllegalArgumentException if input arrays are not valid\n-     */\n-    PolynomialFunctionNewtonForm(double a[], double c[]) throws\n-        IllegalArgumentException {\n-\n-        verifyInputArray(a, c);\n-        this.a = new double[a.length];\n-        this.c = new double[c.length];\n-        System.arraycopy(a, 0, this.a, 0, a.length);\n-        System.arraycopy(c, 0, this.c, 0, c.length);\n-        coefficientsComputed = false;\n-    }\n-\n-    /**\n-     * Calculate the function value at the given point.\n-     *\n-     * @param z the point at which the function value is to be computed\n-     * @return the function value\n-     * @throws FunctionEvaluationException if a runtime error occurs\n-     * @see UnivariateRealFunction#value(double)\n-     */\n-    public double value(double z) throws FunctionEvaluationException {\n-       return evaluate(a, c, z);\n-    }\n-\n-    /**\n-     * Returns the degree of the polynomial.\n-     * \n-     * @return the degree of the polynomial\n-     */\n-    public int degree() {\n-        return c.length;\n-    }\n-\n-    /**\n-     * Returns a copy of coefficients in Newton form formula.\n-     * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n-     * \n-     * @return a fresh copy of coefficients in Newton form formula\n-     */\n-    public double[] getNewtonCoefficients() {\n-        double[] out = new double[a.length];\n-        System.arraycopy(a, 0, out, 0, a.length);\n-        return out;\n-    }\n-\n-    /**\n-     * Returns a copy of the centers array.\n-     * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n-     * \n-     * @return a fresh copy of the centers array\n-     */\n-    public double[] getCenters() {\n-        double[] out = new double[c.length];\n-        System.arraycopy(c, 0, out, 0, c.length);\n-        return out;\n-    }\n-\n-    /**\n-     * Returns a copy of the coefficients array.\n-     * <p>\n-     * Changes made to the returned copy will not affect the polynomial.\n-     * \n-     * @return a fresh copy of the coefficients array\n-     */\n-    public double[] getCoefficients() {\n-        if (!coefficientsComputed) {\n-            computeCoefficients();\n-        }\n-        double[] out = new double[coefficients.length];\n-        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n-        return out;\n-    }\n-\n-    /**\n-     * Evaluate the Newton polynomial using nested multiplication. It is\n-     * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n-     * Horner's Rule</a> and takes O(N) time.\n-     *\n-     * @param a the coefficients in Newton form formula\n-     * @param c the centers\n-     * @param z the point at which the function value is to be computed\n-     * @return the function value\n-     * @throws FunctionEvaluationException if a runtime error occurs\n-     * @throws IllegalArgumentException if inputs are not valid\n-     */\n-    public static double evaluate(double a[], double c[], double z) throws\n-        FunctionEvaluationException, IllegalArgumentException {\n-\n-        verifyInputArray(a, c);\n-\n-        int n = c.length;\n-        double value = a[n];\n-        for (int i = n-1; i >= 0; i--) {\n-            value = a[i] + (z - c[i]) * value;\n-        }\n-\n-        return value;\n-    }\n-\n-    /**\n-     * Calculate the normal polynomial coefficients given the Newton form.\n-     * It also uses nested multiplication but takes O(N^2) time.\n-     */\n-    protected void computeCoefficients() {\n-        int i, j, n = degree();\n-\n-        coefficients = new double[n+1];\n-        for (i = 0; i <= n; i++) {\n-            coefficients[i] = 0.0;\n-        }\n-\n-        coefficients[0] = a[n];\n-        for (i = n-1; i >= 0; i--) {\n-            for (j = n-i; j > 0; j--) {\n-                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n-            }\n-            coefficients[0] = a[i] - c[i] * coefficients[0];\n-        }\n-\n-        coefficientsComputed = true;\n-    }\n-\n-    /**\n-     * Verifies that the input arrays are valid.\n-     * <p>\n-     * The centers must be distinct for interpolation purposes, but not\n-     * for general use. Thus it is not verified here.\n-     * \n-     * @throws IllegalArgumentException if not valid\n-     * @see DividedDifferenceInterpolator#computeDividedDifference(double[],\n-     * double[])\n-     */\n-    protected static void verifyInputArray(double a[], double c[]) throws\n-        IllegalArgumentException {\n-\n-        if (a.length < 1 || c.length < 1) {\n-            throw new IllegalArgumentException\n-                (\"Input arrays must not be empty.\");\n-        }\n-        if (a.length != c.length + 1) {\n-            throw new IllegalArgumentException\n-                (\"Bad input array sizes, should have difference 1.\");\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * Newton Form. For reference, see <b>Elementary Numerical Analysis</b>,\n+ * ISBN 0070124477, chapter 2.\n+ * <p>\n+ * The formula of polynomial in Newton form is\n+ *     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+ *            a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+ * Note that the length of a[] is one more than the length of c[]\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialFunctionNewtonForm implements UnivariateRealFunction,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = -3353896576191389897L;\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Members of c[] are called centers of the Newton polynomial.\n+     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n+     * i.e. a[i] = coefficients[i].\n+     */\n+    private double a[], c[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Newton polynomial with the given a[] and c[]. The order of\n+     * centers are important in that if c[] shuffle, then values of a[] would\n+     * completely change, not just a permutation of old a[].\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.\n+     * \n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    PolynomialFunctionNewtonForm(double a[], double c[]) throws\n+        IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+        this.a = new double[a.length];\n+        this.c = new double[c.length];\n+        System.arraycopy(a, 0, this.a, 0, a.length);\n+        System.arraycopy(c, 0, this.c, 0, c.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+       return evaluate(a, c, z);\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return c.length;\n+    }\n+\n+    /**\n+     * Returns a copy of coefficients in Newton form formula.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of coefficients in Newton form formula\n+     */\n+    public double[] getNewtonCoefficients() {\n+        double[] out = new double[a.length];\n+        System.arraycopy(a, 0, out, 0, a.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the centers array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the centers array\n+     */\n+    public double[] getCenters() {\n+        double[] out = new double[c.length];\n+        System.arraycopy(c, 0, out, 0, c.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Newton polynomial using nested multiplication. It is\n+     * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n+     * Horner's Rule</a> and takes O(N) time.\n+     *\n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double a[], double c[], double z) throws\n+        FunctionEvaluationException, IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+\n+        int n = c.length;\n+        double value = a[n];\n+        for (int i = n-1; i >= 0; i--) {\n+            value = a[i] + (z - c[i]) * value;\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the normal polynomial coefficients given the Newton form.\n+     * It also uses nested multiplication but takes O(N^2) time.\n+     */\n+    protected void computeCoefficients() {\n+        int i, j, n = degree();\n+\n+        coefficients = new double[n+1];\n+        for (i = 0; i <= n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        coefficients[0] = a[n];\n+        for (i = n-1; i >= 0; i--) {\n+            for (j = n-i; j > 0; j--) {\n+                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n+            }\n+            coefficients[0] = a[i] - c[i] * coefficients[0];\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the input arrays are valid.\n+     * <p>\n+     * The centers must be distinct for interpolation purposes, but not\n+     * for general use. Thus it is not verified here.\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     * @see DividedDifferenceInterpolator#computeDividedDifference(double[],\n+     * double[])\n+     */\n+    protected static void verifyInputArray(double a[], double c[]) throws\n+        IllegalArgumentException {\n+\n+        if (a.length < 1 || c.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Input arrays must not be empty.\");\n+        }\n+        if (a.length != c.length + 1) {\n+            throw new IllegalArgumentException\n+                (\"Bad input array sizes, should have difference 1.\");\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistribution.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-/**\n- * Cauchy Distribution.\n- * Instances of CauchyDistribution objects should be created using\n- * {@link DistributionFactory#createCauchyDistribution(double, double)}.<p>\n- *\n- * <p>\n- * References:<p>\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">\n- * Cauchy Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n- * @since 1.1\n- * @version $Revision$ $Date$\n- */\n-public interface CauchyDistribution extends ContinuousDistribution {\n-    \n-    /**\n-     * Access the median.\n-     * @return median for this distribution\n-     */\n-    double getMedian();\n-    \n-    /**\n-     * Access the scale parameter.\n-     * @return scale parameter for this distribution\n-     */\n-    double getScale();\n-    \n-    /**\n-     * Modify the median.\n-     * @param median for this distribution\n-     */\n-    void setMedian(double median);\n-    \n-    /**\n-     * Modify the scale parameter.\n-     * @param s scale parameter for this distribution\n-     */\n-    void setScale(double s);\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Cauchy Distribution.\n+ * Instances of CauchyDistribution objects should be created using\n+ * {@link DistributionFactory#createCauchyDistribution(double, double)}.<p>\n+ *\n+ * <p>\n+ * References:<p>\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">\n+ * Cauchy Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public interface CauchyDistribution extends ContinuousDistribution {\n+    \n+    /**\n+     * Access the median.\n+     * @return median for this distribution\n+     */\n+    double getMedian();\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return scale parameter for this distribution\n+     */\n+    double getScale();\n+    \n+    /**\n+     * Modify the median.\n+     * @param median for this distribution\n+     */\n+    void setMedian(double median);\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param s scale parameter for this distribution\n+     */\n+    void setScale(double s);\n+}\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n-\n-/**\n- * Default implementation of\n- * {@link org.apache.commons.math.distribution.CauchyDistribution}.\n- *\n- * @since 1.1\n- * @version $Revision$ $Date$\n- */\n-public class CauchyDistributionImpl extends AbstractContinuousDistribution \n-        implements CauchyDistribution, Serializable {\n-    \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = 8589540077390120676L;\n-\n-    /** The median of this distribution. */\n-    private double median = 0;\n-    \n-    /** The scale of this distribution. */\n-    private double scale = 1;\n-    \n-    /**\n-     * Creates cauchy distribution with the medain equal to zero and scale\n-     * equal to one. \n-     */\n-    public CauchyDistributionImpl(){\n-        this(0.0, 1.0);\n-    }\n-    \n-    /**\n-     * Create a cauchy distribution using the given median and scale.\n-     * @param median median for this distribution\n-     * @param s scale parameter for this distribution\n-     */\n-    public CauchyDistributionImpl(double median, double s){\n-        super();\n-        setMedian(median);\n-        setScale(s);\n-    }\n-\n-    /**\n-     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>. \n-     */\n-    public double cumulativeProbability(double x) {\n-        return 0.5 + (Math.atan((x - median) / scale) / Math.PI);\n-    }\n-    \n-    /**\n-     * Access the median.\n-     * @return median for this distribution\n-     */ \n-    public double getMedian() {\n-        return median;\n-    }\n-\n-    /**\n-     * Access the scale parameter.\n-     * @return scale parameter for this distribution\n-     */\n-    public double getScale() {\n-        return scale;\n-    }\n-    \n-    /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n-     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n-     */\n-    public double inverseCumulativeProbability(double p) {\n-        double ret;\n-        if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException\n-                (\"probability argument must be between 0 and 1 (inclusive)\");\n-        } else if (p == 0) {\n-            ret = Double.NEGATIVE_INFINITY;\n-        } else  if (p == 1) {\n-            ret = Double.POSITIVE_INFINITY;\n-        } else {\n-            ret = median + scale * Math.tan(Math.PI * (p - .5));\n-        }\n-        return ret;\n-    }\n-    \n-    /**\n-     * Modify the median.\n-     * @param median for this distribution\n-     */\n-    public void setMedian(double median) {\n-        this.median = median;\n-    }\n-\n-    /**\n-     * Modify the scale parameter.\n-     * @param s scale parameter for this distribution\n-     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n-     */\n-    public void setScale(double s) {\n-        if (s <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Scale must be positive.\");\n-        }       \n-        scale = s;\n-    }\n-    \n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n-     */\n-    protected double getDomainLowerBound(double p) {\n-        double ret;\n-\n-        if (p < .5) {\n-            ret = -Double.MAX_VALUE;\n-        } else {\n-            ret = getMedian();\n-        }\n-        \n-        return ret;\n-    }\n-\n-    /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-     */\n-    protected double getDomainUpperBound(double p) {\n-        double ret;\n-\n-        if (p < .5) {\n-            ret = getMedian();\n-        } else {\n-            ret = Double.MAX_VALUE;\n-        }\n-        \n-        return ret;\n-    }\n-\n-    /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n-     */\n-    protected double getInitialDomain(double p) {\n-        double ret;\n-\n-        if (p < .5) {\n-            ret = getMedian() - getScale();\n-        } else if (p > .5) {\n-            ret = getMedian() + getScale();\n-        } else {\n-            ret = getMedian();\n-        }\n-        \n-        return ret;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.CauchyDistribution}.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class CauchyDistributionImpl extends AbstractContinuousDistribution \n+        implements CauchyDistribution, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+\n+    /** The median of this distribution. */\n+    private double median = 0;\n+    \n+    /** The scale of this distribution. */\n+    private double scale = 1;\n+    \n+    /**\n+     * Creates cauchy distribution with the medain equal to zero and scale\n+     * equal to one. \n+     */\n+    public CauchyDistributionImpl(){\n+        this(0.0, 1.0);\n+    }\n+    \n+    /**\n+     * Create a cauchy distribution using the given median and scale.\n+     * @param median median for this distribution\n+     * @param s scale parameter for this distribution\n+     */\n+    public CauchyDistributionImpl(double median, double s){\n+        super();\n+        setMedian(median);\n+        setScale(s);\n+    }\n+\n+    /**\n+     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     */\n+    public double cumulativeProbability(double x) {\n+        return 0.5 + (Math.atan((x - median) / scale) / Math.PI);\n+    }\n+    \n+    /**\n+     * Access the median.\n+     * @return median for this distribution\n+     */ \n+    public double getMedian() {\n+        return median;\n+    }\n+\n+    /**\n+     * Access the scale parameter.\n+     * @return scale parameter for this distribution\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public double inverseCumulativeProbability(double p) {\n+        double ret;\n+        if (p < 0.0 || p > 1.0) {\n+            throw new IllegalArgumentException\n+                (\"probability argument must be between 0 and 1 (inclusive)\");\n+        } else if (p == 0) {\n+            ret = Double.NEGATIVE_INFINITY;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = median + scale * Math.tan(Math.PI * (p - .5));\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the median.\n+     * @param median for this distribution\n+     */\n+    public void setMedian(double median) {\n+        this.median = median;\n+    }\n+\n+    /**\n+     * Modify the scale parameter.\n+     * @param s scale parameter for this distribution\n+     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n+     */\n+    public void setScale(double s) {\n+        if (s <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"Scale must be positive.\");\n+        }       \n+        scale = s;\n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected double getDomainLowerBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = -Double.MAX_VALUE;\n+        } else {\n+            ret = getMedian();\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMedian();\n+        } else {\n+            ret = Double.MAX_VALUE;\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMedian() - getScale();\n+        } else if (p > .5) {\n+            ret = getMedian() + getScale();\n+        } else {\n+            ret = getMedian();\n+        }\n+        \n+        return ret;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistribution.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-/**\n- * Weibull Distribution.  This interface defines the two parameter form of the\n- * distribution as defined by\n- * <a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n- * Weibull Distribution</a>, equations (1) and (2).\n- *\n- * Instances of WeibullDistribution objects should be created using\n- * {@link DistributionFactory#createWeibullDistribution(double, double)}\n- *\n- * <p>\n- * References:\n- * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n- * Weibull Distribution</a></li>\n- * </ul>\n- * </p>\n- *\n- * @since 1.1\n- * @version $Revision: 1.12 $ $Date: 2004-06-23 11:26:18 -0500 (Wed, 23 Jun 2004) $\n- */\n-public interface WeibullDistribution extends ContinuousDistribution {\n-\n-    /**\n-     * Access the shape parameter.\n-     * @return the shape parameter.\n-     */\n-    double getShape();\n-    \n-    /**\n-     * Access the scale parameter.\n-     * @return the scale parameter.\n-     */\n-    double getScale();\n-    \n-    /**\n-     * Modify the shape parameter.\n-     * @param alpha The new shape parameter value.\n-     */\n-    void setShape(double alpha);\n-    \n-    /**\n-     * Modify the scale parameter.\n-     * @param beta The new scale parameter value.\n-     */\n-    void setScale(double beta);\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Weibull Distribution.  This interface defines the two parameter form of the\n+ * distribution as defined by\n+ * <a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n+ * Weibull Distribution</a>, equations (1) and (2).\n+ *\n+ * Instances of WeibullDistribution objects should be created using\n+ * {@link DistributionFactory#createWeibullDistribution(double, double)}\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n+ * Weibull Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @since 1.1\n+ * @version $Revision: 1.12 $ $Date: 2004-06-23 11:26:18 -0500 (Wed, 23 Jun 2004) $\n+ */\n+public interface WeibullDistribution extends ContinuousDistribution {\n+\n+    /**\n+     * Access the shape parameter.\n+     * @return the shape parameter.\n+     */\n+    double getShape();\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return the scale parameter.\n+     */\n+    double getScale();\n+    \n+    /**\n+     * Modify the shape parameter.\n+     * @param alpha The new shape parameter value.\n+     */\n+    void setShape(double alpha);\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param beta The new scale parameter value.\n+     */\n+    void setScale(double beta);\n+}\n--- a/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-import java.io.Serializable;\n-\n-/**\n- * Default implementation of\n- * {@link org.apache.commons.math.distribution.WeibullDistribution}.\n- *\n- * @since 1.1\n- * @version $Revision: 1.13 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n- */\n-public class WeibullDistributionImpl extends AbstractContinuousDistribution\n-        implements WeibullDistribution, Serializable {\n-    \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = 8589540077390120676L;\n-    \n-    /** The shape parameter. */\n-    private double alpha;\n-    \n-    /** The scale parameter. */\n-    private double beta;\n-    \n-    /**\n-     * Creates weibull distribution with the given shape and scale and a\n-     * location equal to zero.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     */\n-    public WeibullDistributionImpl(double alpha, double beta){\n-        super();\n-        setShape(alpha);\n-        setScale(beta);\n-    }\n-\n-    /**\n-     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n-     * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>. \n-     */\n-    public double cumulativeProbability(double x) {\n-        double ret;\n-        if (x <= 0.0) {\n-            ret = 0.0;\n-        } else {\n-            ret = 1.0 - Math.exp(-Math.pow(x / getScale(), getShape()));\n-        }\n-        return ret;\n-    }\n-\n-    /**\n-     * Access the shape parameter.\n-     * @return the shape parameter.\n-     */\n-    public double getShape() {\n-        return alpha;\n-    }\n-    \n-    /**\n-     * Access the scale parameter.\n-     * @return the scale parameter.\n-     */\n-    public double getScale() {\n-        return beta;\n-    }\n-    \n-    /**\n-     * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n-     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n-     */\n-    public double inverseCumulativeProbability(double p) {\n-        double ret;\n-        if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException\n-                (\"probability argument must be between 0 and 1 (inclusive)\");\n-        } else if (p == 0) {\n-            ret = 0.0;\n-        } else  if (p == 1) {\n-            ret = Double.POSITIVE_INFINITY;\n-        } else {\n-            ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());\n-        }\n-        return ret;\n-    }\n-    \n-    /**\n-     * Modify the shape parameter.\n-     * @param alpha the new shape parameter value.\n-     */\n-    public void setShape(double alpha) {\n-        if (alpha <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Shape must be positive.\");\n-        }       \n-        this.alpha = alpha;\n-    }\n-    \n-    /**\n-     * Modify the scale parameter.\n-     * @param beta the new scale parameter value.\n-     */\n-    public void setScale(double beta) {\n-        if (beta <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Scale must be positive.\");\n-        }       \n-        this.beta = beta;\n-    }\n-\n-    /**\n-     * Access the domain value lower bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n-     */\n-    protected double getDomainLowerBound(double p) {\n-        return 0.0;\n-    }\n-\n-    /**\n-     * Access the domain value upper bound, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n-     */\n-    protected double getDomainUpperBound(double p) {\n-        return Double.MAX_VALUE;\n-    }\n-\n-    /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n-     * bracket a CDF root.  This method is used by\n-     * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n-     */\n-    protected double getInitialDomain(double p) {\n-        // use median\n-        return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.WeibullDistribution}.\n+ *\n+ * @since 1.1\n+ * @version $Revision: 1.13 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n+ */\n+public class WeibullDistributionImpl extends AbstractContinuousDistribution\n+        implements WeibullDistribution, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+    \n+    /** The shape parameter. */\n+    private double alpha;\n+    \n+    /** The scale parameter. */\n+    private double beta;\n+    \n+    /**\n+     * Creates weibull distribution with the given shape and scale and a\n+     * location equal to zero.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     */\n+    public WeibullDistributionImpl(double alpha, double beta){\n+        super();\n+        setShape(alpha);\n+        setScale(beta);\n+    }\n+\n+    /**\n+     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     */\n+    public double cumulativeProbability(double x) {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = 1.0 - Math.exp(-Math.pow(x / getScale(), getShape()));\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Access the shape parameter.\n+     * @return the shape parameter.\n+     */\n+    public double getShape() {\n+        return alpha;\n+    }\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return the scale parameter.\n+     */\n+    public double getScale() {\n+        return beta;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public double inverseCumulativeProbability(double p) {\n+        double ret;\n+        if (p < 0.0 || p > 1.0) {\n+            throw new IllegalArgumentException\n+                (\"probability argument must be between 0 and 1 (inclusive)\");\n+        } else if (p == 0) {\n+            ret = 0.0;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the shape parameter.\n+     * @param alpha the new shape parameter value.\n+     */\n+    public void setShape(double alpha) {\n+        if (alpha <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"Shape must be positive.\");\n+        }       \n+        this.alpha = alpha;\n+    }\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param beta the new scale parameter value.\n+     */\n+    public void setScale(double beta) {\n+        if (beta <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"Scale must be positive.\");\n+        }       \n+        this.beta = beta;\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected double getDomainLowerBound(double p) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n+        // use median\n+        return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());\n+    }\n+}\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.fraction;\n-\n-import java.io.Serializable;\n-import java.text.FieldPosition;\n-import java.text.Format;\n-import java.text.NumberFormat;\n-import java.text.ParseException;\n-import java.text.ParsePosition;\n-import java.util.Locale;\n-\n-import org.apache.commons.math.ConvergenceException;\n-\n-/**\n- * Formats a Fraction number in proper format or improper format.  The number\n- * format for each of the whole number, numerator and, denominator can be\n- * configured.\n- *\n- * @since 1.1\n- * @version $Revision$ $Date$\n- */\n-public class FractionFormat extends Format implements Serializable {\n-    \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -6337346779577272306L;\n-\n-    /** The format used for the denominator. */\n-    private NumberFormat denominatorFormat;\n-\n-    /** The format used for the numerator. */\n-    private NumberFormat numeratorFormat;\n-    \n-    /**\n-     * Create an improper formatting instance with the default number format\n-     * for the numerator and denominator.  \n-     */\n-    public FractionFormat() {\n-        this(getDefaultNumberFormat());\n-    }\n-\n-    /**\n-     * Create an improper formatting instance with a custom number format for\n-     * both the numerator and denominator.\n-     * @param format the custom format for both the numerator and denominator.\n-     */\n-    public FractionFormat(NumberFormat format) {\n-        this(format, (NumberFormat)format.clone());\n-    }\n-\n-    /**\n-     * Create an improper formatting instance with a custom number format for\n-     * the numerator and a custom number format for the denominator.\n-     * @param numeratorFormat the custom format for the numerator.\n-     * @param denominatorFormat the custom format for the denominator.\n-     */\n-    public FractionFormat(NumberFormat numeratorFormat,\n-            NumberFormat denominatorFormat)\n-    {\n-        super();\n-        this.numeratorFormat = numeratorFormat;\n-        this.denominatorFormat = denominatorFormat;\n-    }\n-\n-    /**\n-     * This static method calls formatFraction() on a default instance of\n-     * FractionFormat.\n-     *\n-     * @param f Fraction object to format\n-     * @return A formatted fraction in proper form.\n-     */\n-    public static String formatFraction(Fraction f) {\n-        return getImproperInstance().format(f);\n-    }\n-    \n-    /**\n-     * Get the set of locales for which complex formats are available.  This\n-     * is the same set as the {@link NumberFormat} set. \n-     * @return available complex format locales.\n-     */\n-    public static Locale[] getAvailableLocales() {\n-        return NumberFormat.getAvailableLocales();\n-    }\n-    \n-    /**\n-     * Returns the default complex format for the current locale.\n-     * @return the default complex format.\n-     */\n-    public static FractionFormat getImproperInstance() {\n-        return getImproperInstance(Locale.getDefault());\n-    }\n-    \n-    /**\n-     * Returns the default complex format for the given locale.\n-     * @param locale the specific locale used by the format.\n-     * @return the complex format specific to the given locale.\n-     */\n-    public static FractionFormat getImproperInstance(Locale locale) {\n-        NumberFormat f = getDefaultNumberFormat(locale);\n-        return new FractionFormat(f);\n-    }\n-    \n-    /**\n-     * Returns the default complex format for the current locale.\n-     * @return the default complex format.\n-     */\n-    public static FractionFormat getProperInstance() {\n-        return getProperInstance(Locale.getDefault());\n-    }\n-    \n-    /**\n-     * Returns the default complex format for the given locale.\n-     * @param locale the specific locale used by the format.\n-     * @return the complex format specific to the given locale.\n-     */\n-    public static FractionFormat getProperInstance(Locale locale) {\n-        NumberFormat f = getDefaultNumberFormat(locale);\n-        return new ProperFractionFormat(f);\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of fraction digits, which is set to 0.  \n-     * @return the default number format.\n-     */\n-    protected static NumberFormat getDefaultNumberFormat() {\n-        return getDefaultNumberFormat(Locale.getDefault());\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of fraction digits, which is set to 0.  \n-     * @param locale the specific locale used by the format.\n-     * @return the default number format specific to the given locale.\n-     */\n-    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n-        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n-        nf.setMaximumFractionDigits(0);\n-        nf.setParseIntegerOnly(true);\n-        return nf;\n-    }\n-    \n-    /**\n-     * Formats a {@link Fraction} object to produce a string.  The fraction is\n-     * output in improper format.\n-     *\n-     * @param fraction the object to format.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     */\n-    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n-            FieldPosition pos) {\n-        \n-        pos.setBeginIndex(0);\n-        pos.setEndIndex(0);\n-\n-        getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);\n-        toAppendTo.append(\" / \");\n-        getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,\n-            pos);\n-        \n-        return toAppendTo;\n-    }\n-    \n-    /**\n-     * Formats a object to produce a string.  <code>obj</code> must be either a \n-     * {@link Fraction} object or a {@link Number} object.  Any other type of\n-     * object will result in an {@link IllegalArgumentException} being thrown.\n-     *\n-     * @param obj the object to format.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n-     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n-     */\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-            FieldPosition pos)\n-    {\n-        StringBuffer ret = null;\n-        \n-        if (obj instanceof Fraction) {\n-            ret = format( (Fraction)obj, toAppendTo, pos);\n-        } else if (obj instanceof Number) {\n-            try {\n-                ret = format( new Fraction(((Number)obj).doubleValue()),\n-                    toAppendTo, pos);\n-            } catch (ConvergenceException ex) {\n-                throw new IllegalArgumentException(\n-                    \"Cannot convert given object to a fraction.\");\n-            }\n-        } else { \n-            throw new IllegalArgumentException(\n-                \"Cannot format given object as a fraction\");\n-        }\n-        \n-        return ret;\n-    }\n-\n-    /**\n-     * Access the denominator format.\n-     * @return the denominator format.\n-     */\n-    public NumberFormat getDenominatorFormat() {\n-        return denominatorFormat;\n-    }\n-    \n-    /**\n-     * Access the numerator format.\n-     * @return the numerator format.\n-     */\n-    public NumberFormat getNumeratorFormat() {\n-        return numeratorFormat;\n-    }\n-\n-    /**\n-     * Parses a string to produce a {@link Fraction} object.\n-     * @param source the string to parse\n-     * @return the parsed {@link Fraction} object.\n-     * @exception ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     */\n-    public Fraction parse(String source) throws ParseException {\n-        ParsePosition parsePosition = new ParsePosition(0);\n-        Fraction result = parse(source, parsePosition);\n-        if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable fraction number: \\\"\" +\n-                source + \"\\\"\", parsePosition.getErrorIndex());\n-        }\n-        return result;\n-    }\n-    \n-    /**\n-     * Parses a string to produce a {@link Fraction} object.  This method\n-     * expects the string to be formatted as an improper fraction.  \n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed {@link Fraction} object.\n-     */\n-    public Fraction parse(String source, ParsePosition pos) {\n-        int initialIndex = pos.getIndex();\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse numerator\n-        Number num = getNumeratorFormat().parse(source, pos);\n-        if (num == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse '/'\n-        int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n-        switch (c) {\n-        case 0 :\n-            // no '/'\n-            // return num as a fraction\n-            return new Fraction(num.intValue(), 1);\n-        case '/' :\n-            // found '/', continue parsing denominator\n-            break;\n-        default :\n-            // invalid '/'\n-            // set index back to initial, error index should be the last\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse denominator\n-        Number den = getDenominatorFormat().parse(source, pos);\n-        if (den == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        return new Fraction(num.intValue(), den.intValue());\n-    }\n-\n-    /**\n-     * Parses a string to produce a object.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed object.\n-     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n-     */\n-    public Object parseObject(String source, ParsePosition pos) {\n-        return parse(source, pos);\n-    }\n-    \n-    /**\n-     * Modify the denominator format.\n-     * @param format the new denominator format value.\n-     * @throws IllegalArgumentException if <code>format</code> is\n-     *         <code>null</code>.\n-     */\n-    public void setDenominatorFormat(NumberFormat format) {\n-        if (format == null) {\n-            throw new IllegalArgumentException(\n-                \"denominator format can not be null.\");\n-        }\n-        this.denominatorFormat = format;\n-    }\n-    \n-    /**\n-     * Modify the numerator format.\n-     * @param format the new numerator format value.\n-     * @throws IllegalArgumentException if <code>format</code> is\n-     *         <code>null</code>.\n-     */\n-    public void setNumeratorFormat(NumberFormat format) {\n-        if (format == null) {\n-            throw new IllegalArgumentException(\n-                \"numerator format can not be null.\");\n-        }\n-        this.numeratorFormat = format;\n-    }\n-     \n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n-     *        holds the index of the next non-whitespace character.\n-     */\n-    protected static void parseAndIgnoreWhitespace(\n-        String source, ParsePosition pos)\n-    {\n-        parseNextCharacter(source, pos);\n-        pos.setIndex(pos.getIndex() - 1);\n-    }\n-\n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the first non-whitespace character.\n-     */\n-    protected static char parseNextCharacter(String source, ParsePosition pos) {\n-         int index = pos.getIndex();\n-         int n = source.length();\n-         char ret = 0;\n-\n-         if (index < n) {\n-             char c;\n-             do {\n-                 c = source.charAt(index++);\n-             } while (Character.isWhitespace(c) && index < n);\n-             pos.setIndex(index);\n-         \n-             if (index < n) {\n-                 ret = c;\n-             }\n-         }\n-         \n-         return ret;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Formats a Fraction number in proper format or improper format.  The number\n+ * format for each of the whole number, numerator and, denominator can be\n+ * configured.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class FractionFormat extends Format implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6337346779577272306L;\n+\n+    /** The format used for the denominator. */\n+    private NumberFormat denominatorFormat;\n+\n+    /** The format used for the numerator. */\n+    private NumberFormat numeratorFormat;\n+    \n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    public FractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    public FractionFormat(NumberFormat format) {\n+        this(format, (NumberFormat)format.clone());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public FractionFormat(NumberFormat numeratorFormat,\n+            NumberFormat denominatorFormat)\n+    {\n+        super();\n+        this.numeratorFormat = numeratorFormat;\n+        this.denominatorFormat = denominatorFormat;\n+    }\n+\n+    /**\n+     * This static method calls formatFraction() on a default instance of\n+     * FractionFormat.\n+     *\n+     * @param f Fraction object to format\n+     * @return A formatted fraction in proper form.\n+     */\n+    public static String formatFraction(Fraction f) {\n+        return getImproperInstance().format(f);\n+    }\n+    \n+    /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static FractionFormat getImproperInstance() {\n+        return getImproperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static FractionFormat getImproperInstance(Locale locale) {\n+        NumberFormat f = getDefaultNumberFormat(locale);\n+        return new FractionFormat(f);\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static FractionFormat getProperInstance() {\n+        return getProperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static FractionFormat getProperInstance(Locale locale) {\n+        NumberFormat f = getDefaultNumberFormat(locale);\n+        return new ProperFractionFormat(f);\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of fraction digits, which is set to 0.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of fraction digits, which is set to 0.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n+        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n+        nf.setMaximumFractionDigits(0);\n+        nf.setParseIntegerOnly(true);\n+        return nf;\n+    }\n+    \n+    /**\n+     * Formats a {@link Fraction} object to produce a string.  The fraction is\n+     * output in improper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,\n+            pos);\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats a object to produce a string.  <code>obj</code> must be either a \n+     * {@link Fraction} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos)\n+    {\n+        StringBuffer ret = null;\n+        \n+        if (obj instanceof Fraction) {\n+            ret = format( (Fraction)obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            try {\n+                ret = format( new Fraction(((Number)obj).doubleValue()),\n+                    toAppendTo, pos);\n+            } catch (ConvergenceException ex) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot convert given object to a fraction.\");\n+            }\n+        } else { \n+            throw new IllegalArgumentException(\n+                \"Cannot format given object as a fraction\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the denominator format.\n+     * @return the denominator format.\n+     */\n+    public NumberFormat getDenominatorFormat() {\n+        return denominatorFormat;\n+    }\n+    \n+    /**\n+     * Access the numerator format.\n+     * @return the numerator format.\n+     */\n+    public NumberFormat getNumeratorFormat() {\n+        return numeratorFormat;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Fraction} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Fraction} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Fraction parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Fraction result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable fraction number: \\\"\" +\n+                source + \"\\\"\", parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Fraction} object.  This method\n+     * expects the string to be formatted as an improper fraction.  \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Fraction} object.\n+     */\n+    public Fraction parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse numerator\n+        Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        return new Fraction(num.intValue(), den.intValue());\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+    \n+    /**\n+     * Modify the denominator format.\n+     * @param format the new denominator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setDenominatorFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw new IllegalArgumentException(\n+                \"denominator format can not be null.\");\n+        }\n+        this.denominatorFormat = format;\n+    }\n+    \n+    /**\n+     * Modify the numerator format.\n+     * @param format the new numerator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setNumeratorFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw new IllegalArgumentException(\n+                \"numerator format can not be null.\");\n+        }\n+        this.numeratorFormat = format;\n+    }\n+     \n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected static void parseAndIgnoreWhitespace(\n+        String source, ParsePosition pos)\n+    {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected static char parseNextCharacter(String source, ParsePosition pos) {\n+         int index = pos.getIndex();\n+         int n = source.length();\n+         char ret = 0;\n+\n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.fraction;\n-\n-import java.text.FieldPosition;\n-import java.text.NumberFormat;\n-import java.text.ParsePosition;\n-\n-import org.apache.commons.math.util.MathUtils;\n-\n-/**\n- * Formats a Fraction number in proper format.  The number format for each of\n- * the whole number, numerator and, denominator can be configured.\n- * <p>\n- * Minus signs are only allowed in the whole number part - i.e.,\n- * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n- * will result in a <code>ParseException</code>.\n- * \n- * @since 1.1\n- * @version $Revision$ $Date$\n- */\n-public class ProperFractionFormat extends FractionFormat {\n-    \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -6337346779577272307L;\n-    \n-    /** The format used for the whole number. */\n-    private NumberFormat wholeFormat;\n-\n-    /**\n-     * Create a proper formatting instance with the default number format for\n-     * the whole, numerator, and denominator.  \n-     */\n-    public ProperFractionFormat() {\n-        this(getDefaultNumberFormat());\n-    }\n-    \n-    /**\n-     * Create a proper formatting instance with a custom number format for the\n-     * whole, numerator, and denominator.\n-     * @param format the custom format for the whole, numerator, and\n-     *        denominator.\n-     */\n-    public ProperFractionFormat(NumberFormat format) {\n-        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n-    }\n-    \n-    /**\n-     * Create a proper formatting instance with a custom number format for each\n-     * of the whole, numerator, and denominator.\n-     * @param wholeFormat the custom format for the whole.\n-     * @param numeratorFormat the custom format for the numerator.\n-     * @param denominatorFormat the custom format for the denominator.\n-     */\n-    public ProperFractionFormat(NumberFormat wholeFormat,\n-            NumberFormat numeratorFormat,\n-            NumberFormat denominatorFormat)\n-    {\n-        super(numeratorFormat, denominatorFormat);\n-        setWholeFormat(wholeFormat);\n-    }\n-    \n-    /**\n-     * Formats a {@link Fraction} object to produce a string.  The fraction\n-     * is output in proper format.\n-     *\n-     * @param fraction the object to format.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     */\n-    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n-            FieldPosition pos) {\n-        \n-        pos.setBeginIndex(0);\n-        pos.setEndIndex(0);\n-\n-        int num = fraction.getNumerator();\n-        int den = fraction.getDenominator();\n-        int whole = num / den;\n-        num = num % den;\n-        \n-        if (whole != 0) {\n-            getWholeFormat().format(whole, toAppendTo, pos);\n-            toAppendTo.append(' ');\n-            num = Math.abs(num);\n-        }\n-        getNumeratorFormat().format(num, toAppendTo, pos);\n-        toAppendTo.append(\" / \");\n-        getDenominatorFormat().format(den, toAppendTo,\n-            pos);\n-        \n-        return toAppendTo;\n-    }\n-\n-    /**\n-     * Access the whole format.\n-     * @return the whole format.\n-     */\n-    public NumberFormat getWholeFormat() {\n-        return wholeFormat;\n-    }\n-    \n-    /**\n-     * Parses a string to produce a {@link Fraction} object.  This method\n-     * expects the string to be formatted as a proper fraction.\n-     * <p>\n-     * Minus signs are only allowed in the whole number part - i.e.,\n-     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n-     * will result in a <code>ParseException</code>.\n-     * \n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed {@link Fraction} object.\n-     */\n-    public Fraction parse(String source, ParsePosition pos) {\n-        // try to parse improper fraction\n-        Fraction ret = super.parse(source, pos);\n-        if (ret != null) {\n-            return ret;\n-        }\n-        \n-        int initialIndex = pos.getIndex();\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse whole\n-        Number whole = getWholeFormat().parse(source, pos);\n-        if (whole == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-        \n-        // parse numerator\n-        Number num = getNumeratorFormat().parse(source, pos);\n-        if (num == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-        \n-        if (num.intValue() < 0) {\n-            // minus signs should be leading, invalid expression\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse '/'\n-        int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n-        switch (c) {\n-        case 0 :\n-            // no '/'\n-            // return num as a fraction\n-            return new Fraction(num.intValue(), 1);\n-        case '/' :\n-            // found '/', continue parsing denominator\n-            break;\n-        default :\n-            // invalid '/'\n-            // set index back to initial, error index should be the last\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse denominator\n-        Number den = getDenominatorFormat().parse(source, pos);\n-        if (den == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-        \n-        if (den.intValue() < 0) {\n-            // minus signs must be leading, invalid\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        int w = whole.intValue();\n-        int n = num.intValue();\n-        int d = den.intValue();\n-        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n-    }\n-    \n-    /**\n-     * Modify the whole format.\n-     * @param format The new whole format value.\n-     * @throws IllegalArgumentException if <code>format</code> is\n-     *         <code>null</code>.\n-     */\n-    public void setWholeFormat(NumberFormat format) {\n-        if (format == null) {\n-            throw new IllegalArgumentException(\n-                \"whole format can not be null.\");\n-        }\n-        this.wholeFormat = format;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Formats a Fraction number in proper format.  The number format for each of\n+ * the whole number, numerator and, denominator can be configured.\n+ * <p>\n+ * Minus signs are only allowed in the whole number part - i.e.,\n+ * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+ * will result in a <code>ParseException</code>.\n+ * \n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class ProperFractionFormat extends FractionFormat {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6337346779577272307L;\n+    \n+    /** The format used for the whole number. */\n+    private NumberFormat wholeFormat;\n+\n+    /**\n+     * Create a proper formatting instance with the default number format for\n+     * the whole, numerator, and denominator.  \n+     */\n+    public ProperFractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for the\n+     * whole, numerator, and denominator.\n+     * @param format the custom format for the whole, numerator, and\n+     *        denominator.\n+     */\n+    public ProperFractionFormat(NumberFormat format) {\n+        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for each\n+     * of the whole, numerator, and denominator.\n+     * @param wholeFormat the custom format for the whole.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public ProperFractionFormat(NumberFormat wholeFormat,\n+            NumberFormat numeratorFormat,\n+            NumberFormat denominatorFormat)\n+    {\n+        super(numeratorFormat, denominatorFormat);\n+        setWholeFormat(wholeFormat);\n+    }\n+    \n+    /**\n+     * Formats a {@link Fraction} object to produce a string.  The fraction\n+     * is output in proper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        int num = fraction.getNumerator();\n+        int den = fraction.getDenominator();\n+        int whole = num / den;\n+        num = num % den;\n+        \n+        if (whole != 0) {\n+            getWholeFormat().format(whole, toAppendTo, pos);\n+            toAppendTo.append(' ');\n+            num = Math.abs(num);\n+        }\n+        getNumeratorFormat().format(num, toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(den, toAppendTo,\n+            pos);\n+        \n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Access the whole format.\n+     * @return the whole format.\n+     */\n+    public NumberFormat getWholeFormat() {\n+        return wholeFormat;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Fraction} object.  This method\n+     * expects the string to be formatted as a proper fraction.\n+     * <p>\n+     * Minus signs are only allowed in the whole number part - i.e.,\n+     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+     * will result in a <code>ParseException</code>.\n+     * \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Fraction} object.\n+     */\n+    public Fraction parse(String source, ParsePosition pos) {\n+        // try to parse improper fraction\n+        Fraction ret = super.parse(source, pos);\n+        if (ret != null) {\n+            return ret;\n+        }\n+        \n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse whole\n+        Number whole = getWholeFormat().parse(source, pos);\n+        if (whole == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+        \n+        // parse numerator\n+        Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (num.intValue() < 0) {\n+            // minus signs should be leading, invalid expression\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (den.intValue() < 0) {\n+            // minus signs must be leading, invalid\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        int w = whole.intValue();\n+        int n = num.intValue();\n+        int d = den.intValue();\n+        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n+    }\n+    \n+    /**\n+     * Modify the whole format.\n+     * @param format The new whole format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setWholeFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw new IllegalArgumentException(\n+                \"whole format can not be null.\");\n+        }\n+        this.wholeFormat = format;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/analysis/DividedDifferenceInterpolatorTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Divided Difference interpolator.\n- * <p>\n- * The error of polynomial interpolation is\n- *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n- * where f^(n) is the n-th derivative of the approximated function and\n- * zeta is some point in the interval determined by x[] and z.\n- * <p>\n- * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n- * it and use the absolute value upper bound for estimates. For reference,\n- * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class DividedDifferenceInterpolatorTest extends TestCase {\n-\n-    /**\n-     * Test of interpolator for the sine function.\n-     * <p>\n-     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n-        double x[], y[], z, expected, result, tolerance;\n-\n-        // 6 interpolating points on interval [0, 2*PI]\n-        int n = 6;\n-        double min = 0.0, max = 2 * Math.PI;\n-        x = new double[n];\n-        y = new double[n];\n-        for (int i = 0; i < n; i++) {\n-            x[i] = min + i * (max - min) / n;\n-            y[i] = f.value(x[i]);\n-        }\n-        double derivativebound = 1.0;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n-\n-        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-\n-        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of interpolator for the exponential function.\n-     * <p>\n-     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n-     */\n-    public void testExpm1Function() throws MathException {\n-        UnivariateRealFunction f = new Expm1Function();\n-        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n-        double x[], y[], z, expected, result, tolerance;\n-\n-        // 5 interpolating points on interval [-1, 1]\n-        int n = 5;\n-        double min = -1.0, max = 1.0;\n-        x = new double[n];\n-        y = new double[n];\n-        for (int i = 0; i < n; i++) {\n-            x[i] = min + i * (max - min) / n;\n-            y[i] = f.value(x[i]);\n-        }\n-        double derivativebound = Math.E;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n-\n-        z = 0.0; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-\n-        z = -0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the interpolator.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n-\n-        try {\n-            // bad abscissas array\n-            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n-            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n-            UnivariateRealFunction p = interpolator.interpolate(x, y);\n-            p.value(0.0);\n-            fail(\"Expecting MathException - bad abscissas array\");\n-        } catch (MathException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /**\n-     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n-     */\n-    protected double partialerror(double x[], double z) throws\n-        IllegalArgumentException {\n-\n-        if (x.length < 1) {\n-            throw new IllegalArgumentException\n-                (\"Interpolation array cannot be empty.\");\n-        }\n-        double out = 1;\n-        for (int i = 0; i < x.length; i++) {\n-            out *= (z - x[i]) / (i + 1);\n-        }\n-        return out;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Divided Difference interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class DividedDifferenceInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/Expm1Function.java\n+++ b/src/test/org/apache/commons/math/analysis/Expm1Function.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.FunctionEvaluationException;\n-\n-/**\n- * Auxillary class for testing purposes.\n- *\n- * @version $Revision$ $Date$\n- */\n-public class Expm1Function implements DifferentiableUnivariateRealFunction {\n-\n-    public double value(double x) throws FunctionEvaluationException {\n-        // Math.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n-        return Math.exp(x) - 1.0;\n-    }\n-\n-    public UnivariateRealFunction derivative() {\n-        return new UnivariateRealFunction() {\n-            public double value(double x) throws FunctionEvaluationException {\n-                return Math.exp(x);\n-            }\n-        };\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * Auxillary class for testing purposes.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Expm1Function implements DifferentiableUnivariateRealFunction {\n+\n+    public double value(double x) throws FunctionEvaluationException {\n+        // Math.expm1() is available in jdk 1.5 but not in jdk 1.4.2.\n+        return Math.exp(x) - 1.0;\n+    }\n+\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            public double value(double x) throws FunctionEvaluationException {\n+                return Math.exp(x);\n+            }\n+        };\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/LaguerreSolverTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.complex.Complex;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Laguerre solver.\n- * <p>\n- * Laguerre's method is very efficient in solving polynomials. Test runs\n- * show that for a default absolute accuracy of 1E-6, it generally takes\n- * less than 5 iterations to find one root, provided solveAll() is not\n- * invoked, and 15 to 20 iterations to find all roots for quintic function.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class LaguerreSolverTest extends TestCase {\n-\n-    /**\n-     * Test of solver for the linear function.\n-     */\n-    public void testLinearFunction() throws MathException {\n-        double min, max, expected, result, tolerance;\n-\n-        // p(x) = 4x - 1\n-        double coefficients[] = { -1.0, 4.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n-\n-        min = 0.0; max = 1.0; expected = 0.25;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quadratic function.\n-     */\n-    public void testQuadraticFunction() throws MathException {\n-        double min, max, expected, result, tolerance;\n-\n-        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n-        double coefficients[] = { -3.0, 5.0, 2.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n-\n-        min = 0.0; max = 2.0; expected = 0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -4.0; max = -1.0; expected = -3.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        double min, max, expected, result, tolerance;\n-\n-        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n-        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n-\n-        min = -2.0; max = 2.0; expected = -1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -5.0; max = -2.5; expected = -3.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 3.0; max = 6.0; expected = 4.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quintic function using solveAll().\n-     */\n-    public void testQuinticFunction2() throws MathException {\n-        double initial = 0.0, tolerance;\n-        Complex expected, result[];\n-\n-        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n-        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        LaguerreSolver solver = new LaguerreSolver(f);\n-        result = solver.solveAll(coefficients, initial);\n-\n-        expected = new Complex(0.0, -2.0);\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n-\n-        expected = new Complex(0.0, 2.0);\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n-\n-        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n-\n-        expected = new Complex(-1.0, 0.0);\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n-        \n-        expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n-        TestUtils.assertContains(result, expected, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the solver.\n-     */\n-    public void testParameters() throws Exception {\n-        double coefficients[] = { -3.0, 5.0, 2.0 };\n-        PolynomialFunction f = new PolynomialFunction(coefficients);\n-        UnivariateRealSolver solver = new LaguerreSolver(f);\n-\n-        try {\n-            // bad interval\n-            solver.solve(1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // no bracketing\n-            solver.solve(2, 3);\n-            fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // bad function\n-            UnivariateRealFunction f2 = new SinFunction();\n-            UnivariateRealSolver solver2 = new LaguerreSolver(f2);\n-            fail(\"Expecting IllegalArgumentException - bad function\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.complex.Complex;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Laguerre solver.\n+ * <p>\n+ * Laguerre's method is very efficient in solving polynomials. Test runs\n+ * show that for a default absolute accuracy of 1E-6, it generally takes\n+ * less than 5 iterations to find one root, provided solveAll() is not\n+ * invoked, and 15 to 20 iterations to find all roots for quintic function.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class LaguerreSolverTest extends TestCase {\n+\n+    /**\n+     * Test of solver for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = 0.0; max = 2.0; expected = 0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -4.0; max = -1.0; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n+        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = -2.0; max = 2.0; expected = -1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -5.0; max = -2.5; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 3.0; max = 6.0; expected = 4.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solveAll().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        double initial = 0.0, tolerance;\n+        Complex expected, result[];\n+\n+        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n+        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        LaguerreSolver solver = new LaguerreSolver(f);\n+        result = solver.solveAll(coefficients, initial);\n+\n+        expected = new Complex(0.0, -2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(0.0, 2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(-1.0, 0.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+        \n+        expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        try {\n+            // bad interval\n+            solver.solve(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad function\n+            UnivariateRealFunction f2 = new SinFunction();\n+            UnivariateRealSolver solver2 = new LaguerreSolver(f2);\n+            fail(\"Expecting IllegalArgumentException - bad function\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/MullerSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/MullerSolverTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Muller solver.\n- * <p>\n- * Muller's method converges almost quadratically near roots, but it can\n- * be very slow in regions far away from zeros. Test runs show that for\n- * reasonably good initial values, for a default absolute accuracy of 1E-6,\n- * it generally takes 5 to 10 iterations for the solver to converge.\n- * <p>\n- * Tests for the exponential function illustrate the situations where\n- * Muller solver performs poorly.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class MullerSolverTest extends TestCase {\n-\n-    /**\n-     * Test of solver for the sine function.\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the sine function using solve2().\n-     */\n-    public void testSinFunction2() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        MullerSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quintic function using solve2().\n-     */\n-    public void testQuinticFunction2() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        MullerSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the exponential function.\n-     * <p>\n-     * It takes 10 to 15 iterations for the last two tests to converge.\n-     * In fact, if not for the bisection alternative, the solver would\n-     * exceed the default maximal iteration of 100.\n-     */\n-    public void testExpm1Function() throws MathException {\n-        UnivariateRealFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the exponential function using solve2().\n-     * <p>\n-     * It takes 25 to 50 iterations for the last two tests to converge.\n-     */\n-    public void testExpm1Function2() throws MathException {\n-        UnivariateRealFunction f = new Expm1Function();\n-        MullerSolver solver = new MullerSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve2(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the solver.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new MullerSolver(f);\n-\n-        try {\n-            // bad interval\n-            solver.solve(1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // no bracketing\n-            solver.solve(2, 3);\n-            fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Muller solver.\n+ * <p>\n+ * Muller's method converges almost quadratically near roots, but it can\n+ * be very slow in regions far away from zeros. Test runs show that for\n+ * reasonably good initial values, for a default absolute accuracy of 1E-6,\n+ * it generally takes 5 to 10 iterations for the solver to converge.\n+ * <p>\n+ * Tests for the exponential function illustrate the situations where\n+ * Muller solver performs poorly.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class MullerSolverTest extends TestCase {\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function using solve2().\n+     */\n+    public void testSinFunction2() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solve2().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     * <p>\n+     * It takes 10 to 15 iterations for the last two tests to converge.\n+     * In fact, if not for the bisection alternative, the solver would\n+     * exceed the default maximal iteration of 100.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function using solve2().\n+     * <p>\n+     * It takes 25 to 50 iterations for the last two tests to converge.\n+     */\n+    public void testExpm1Function2() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+\n+        try {\n+            // bad interval\n+            solver.solve(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/NevilleInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/analysis/NevilleInterpolatorTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Neville interpolator.\n- * <p>\n- * The error of polynomial interpolation is\n- *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n- * where f^(n) is the n-th derivative of the approximated function and\n- * zeta is some point in the interval determined by x[] and z.\n- * <p>\n- * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n- * it and use the absolute value upper bound for estimates. For reference,\n- * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class NevilleInterpolatorTest extends TestCase {\n-\n-    /**\n-     * Test of interpolator for the sine function.\n-     * <p>\n-     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n-        double x[], y[], z, expected, result, tolerance;\n-\n-        // 6 interpolating points on interval [0, 2*PI]\n-        int n = 6;\n-        double min = 0.0, max = 2 * Math.PI;\n-        x = new double[n];\n-        y = new double[n];\n-        for (int i = 0; i < n; i++) {\n-            x[i] = min + i * (max - min) / n;\n-            y[i] = f.value(x[i]);\n-        }\n-        double derivativebound = 1.0;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n-\n-        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-\n-        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of interpolator for the exponential function.\n-     * <p>\n-     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n-     */\n-    public void testExpm1Function() throws MathException {\n-        UnivariateRealFunction f = new Expm1Function();\n-        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n-        double x[], y[], z, expected, result, tolerance;\n-\n-        // 5 interpolating points on interval [-1, 1]\n-        int n = 5;\n-        double min = -1.0, max = 1.0;\n-        x = new double[n];\n-        y = new double[n];\n-        for (int i = 0; i < n; i++) {\n-            x[i] = min + i * (max - min) / n;\n-            y[i] = f.value(x[i]);\n-        }\n-        double derivativebound = Math.E;\n-        UnivariateRealFunction p = interpolator.interpolate(x, y);\n-\n-        z = 0.0; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-\n-        z = -0.5; expected = f.value(z); result = p.value(z);\n-        tolerance = Math.abs(derivativebound * partialerror(x, z));\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the interpolator.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n-\n-        try {\n-            // bad abscissas array\n-            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n-            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n-            UnivariateRealFunction p = interpolator.interpolate(x, y);\n-            p.value(0.0);\n-            fail(\"Expecting MathException - bad abscissas array\");\n-        } catch (MathException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /**\n-     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n-     */\n-    protected double partialerror(double x[], double z) throws\n-        IllegalArgumentException {\n-\n-        if (x.length < 1) {\n-            throw new IllegalArgumentException\n-                (\"Interpolation array cannot be empty.\");\n-        }\n-        double out = 1;\n-        for (int i = 0; i < x.length; i++) {\n-            out *= (z - x[i]) / (i + 1);\n-        }\n-        return out;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Neville interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class NevilleInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/PolynomialFunctionLagrangeFormTest.java\n+++ b/src/test/org/apache/commons/math/analysis/PolynomialFunctionLagrangeFormTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Lagrange form of polynomial function.\n- * <p>\n- * We use n+1 points to interpolate a polynomial of degree n. This should\n- * give us the exact same polynomial as result. Thus we can use a very\n- * small tolerance to account only for round-off errors.\n- *\n- * @version $Revision$ $Date$ \n- */\n-public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n-\n-    /**\n-     * Test of polynomial for the linear function.\n-     */\n-    public void testLinearFunction() throws MathException {\n-        PolynomialFunctionLagrangeForm p;\n-        double c[], z, expected, result, tolerance = 1E-12;\n-\n-        // p(x) = 1.5x - 4\n-        double x[] = { 0.0, 3.0 };\n-        double y[] = { -4.0, 0.5 };\n-        p = new PolynomialFunctionLagrangeForm(x, y);\n-\n-        z = 2.0; expected = -1.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 4.5; expected = 2.75; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 6.0; expected = 5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        assertEquals(1, p.degree());\n-\n-        c = p.getCoefficients();\n-        assertEquals(2, c.length);\n-        assertEquals(-4.0, c[0], tolerance);\n-        assertEquals(1.5, c[1], tolerance);\n-    }\n-\n-    /**\n-     * Test of polynomial for the quadratic function.\n-     */\n-    public void testQuadraticFunction() throws MathException {\n-        PolynomialFunctionLagrangeForm p;\n-        double c[], z, expected, result, tolerance = 1E-12;\n-\n-        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)\n-        double x[] = { 0.0, -1.0, 0.5 };\n-        double y[] = { -3.0, -6.0, 0.0 };\n-        p = new PolynomialFunctionLagrangeForm(x, y);\n-\n-        z = 1.0; expected = 4.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 2.5; expected = 22.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = -2.0; expected = -5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        assertEquals(2, p.degree());\n-\n-        c = p.getCoefficients();\n-        assertEquals(3, c.length);\n-        assertEquals(-3.0, c[0], tolerance);\n-        assertEquals(5.0, c[1], tolerance);\n-        assertEquals(2.0, c[2], tolerance);\n-    }\n-\n-    /**\n-     * Test of polynomial for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        PolynomialFunctionLagrangeForm p;\n-        double c[], z, expected, result, tolerance = 1E-12;\n-\n-        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)\n-        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };\n-        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };\n-        p = new PolynomialFunctionLagrangeForm(x, y);\n-\n-        z = 0.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = -2.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 4.0; expected = 360.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        assertEquals(5, p.degree());\n-\n-        c = p.getCoefficients();\n-        assertEquals(6, c.length);\n-        assertEquals(0.0, c[0], tolerance);\n-        assertEquals(6.0, c[1], tolerance);\n-        assertEquals(1.0, c[2], tolerance);\n-        assertEquals(-7.0, c[3], tolerance);\n-        assertEquals(-1.0, c[4], tolerance);\n-        assertEquals(1.0, c[5], tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the polynomial.\n-     */\n-    public void testParameters() throws Exception {\n-        PolynomialFunctionLagrangeForm p;\n-\n-        try {\n-            // bad input array length\n-            double x[] = { 1.0 };\n-            double y[] = { 2.0 };\n-            p = new PolynomialFunctionLagrangeForm(x, y);\n-            fail(\"Expecting IllegalArgumentException - bad input array length\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // mismatch input arrays\n-            double x[] = { 1.0, 2.0, 3.0, 4.0 };\n-            double y[] = { 0.0, -4.0, -24.0 };\n-            p = new PolynomialFunctionLagrangeForm(x, y);\n-            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Lagrange form of polynomial function.\n+ * <p>\n+ * We use n+1 points to interpolate a polynomial of degree n. This should\n+ * give us the exact same polynomial as result. Thus we can use a very\n+ * small tolerance to account only for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4\n+        double x[] = { 0.0, 3.0 };\n+        double y[] = { -4.0, 0.5 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(2, c.length);\n+        assertEquals(-4.0, c[0], tolerance);\n+        assertEquals(1.5, c[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)\n+        double x[] = { 0.0, -1.0, 0.5 };\n+        double y[] = { -3.0, -6.0, 0.0 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(3, c.length);\n+        assertEquals(-3.0, c[0], tolerance);\n+        assertEquals(5.0, c[1], tolerance);\n+        assertEquals(2.0, c[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)\n+        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };\n+        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(6, c.length);\n+        assertEquals(0.0, c[0], tolerance);\n+        assertEquals(6.0, c[1], tolerance);\n+        assertEquals(1.0, c[2], tolerance);\n+        assertEquals(-7.0, c[3], tolerance);\n+        assertEquals(-1.0, c[4], tolerance);\n+        assertEquals(1.0, c[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+        PolynomialFunctionLagrangeForm p;\n+\n+        try {\n+            // bad input array length\n+            double x[] = { 1.0 };\n+            double y[] = { 2.0 };\n+            p = new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double x[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double y[] = { 0.0, -4.0, -24.0 };\n+            p = new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/PolynomialFunctionNewtonFormTest.java\n+++ b/src/test/org/apache/commons/math/analysis/PolynomialFunctionNewtonFormTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Newton form of polynomial function.\n- * <p>\n- * The small tolerance number is used only to account for round-off errors.\n- *\n- * @version $Revision$ $Date$ \n- */\n-public final class PolynomialFunctionNewtonFormTest extends TestCase {\n-\n-    /**\n-     * Test of polynomial for the linear function.\n-     */\n-    public void testLinearFunction() throws MathException {\n-        PolynomialFunctionNewtonForm p;\n-        double coefficients[], z, expected, result, tolerance = 1E-12;\n-\n-        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)\n-        double a[] = { 2.0, 1.5 };\n-        double c[] = { 4.0 };\n-        p = new PolynomialFunctionNewtonForm(a, c);\n-\n-        z = 2.0; expected = -1.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 4.5; expected = 2.75; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 6.0; expected = 5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        assertEquals(1, p.degree());\n-\n-        coefficients = p.getCoefficients();\n-        assertEquals(2, coefficients.length);\n-        assertEquals(-4.0, coefficients[0], tolerance);\n-        assertEquals(1.5, coefficients[1], tolerance);\n-    }\n-\n-    /**\n-     * Test of polynomial for the quadratic function.\n-     */\n-    public void testQuadraticFunction() throws MathException {\n-        PolynomialFunctionNewtonForm p;\n-        double coefficients[], z, expected, result, tolerance = 1E-12;\n-\n-        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)\n-        double a[] = { 4.0, 3.0, 2.0 };\n-        double c[] = { 1.0, -2.0 };\n-        p = new PolynomialFunctionNewtonForm(a, c);\n-\n-        z = 1.0; expected = 4.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 2.5; expected = 22.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = -2.0; expected = -5.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        assertEquals(2, p.degree());\n-\n-        coefficients = p.getCoefficients();\n-        assertEquals(3, coefficients.length);\n-        assertEquals(-3.0, coefficients[0], tolerance);\n-        assertEquals(5.0, coefficients[1], tolerance);\n-        assertEquals(2.0, coefficients[2], tolerance);\n-    }\n-\n-    /**\n-     * Test of polynomial for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        PolynomialFunctionNewtonForm p;\n-        double coefficients[], z, expected, result, tolerance = 1E-12;\n-\n-        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x\n-        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)\n-        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };\n-        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };\n-        p = new PolynomialFunctionNewtonForm(a, c);\n-\n-        z = 0.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = -2.0; expected = 0.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        z = 4.0; expected = 360.0; result = p.value(z);\n-        assertEquals(expected, result, tolerance);\n-\n-        assertEquals(5, p.degree());\n-\n-        coefficients = p.getCoefficients();\n-        assertEquals(6, coefficients.length);\n-        assertEquals(0.0, coefficients[0], tolerance);\n-        assertEquals(6.0, coefficients[1], tolerance);\n-        assertEquals(1.0, coefficients[2], tolerance);\n-        assertEquals(-7.0, coefficients[3], tolerance);\n-        assertEquals(-1.0, coefficients[4], tolerance);\n-        assertEquals(1.0, coefficients[5], tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the polynomial.\n-     */\n-    public void testParameters() throws Exception {\n-        PolynomialFunctionNewtonForm p;\n-\n-        try {\n-            // bad input array length\n-            double a[] = { 1.0 };\n-            double c[] = { 2.0 };\n-            p = new PolynomialFunctionNewtonForm(a, c);\n-            fail(\"Expecting IllegalArgumentException - bad input array length\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // mismatch input arrays\n-            double a[] = { 1.0, 2.0, 3.0, 4.0 };\n-            double c[] = { 4.0, 3.0, 2.0, 1.0 };\n-            p = new PolynomialFunctionNewtonForm(a, c);\n-            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Newton form of polynomial function.\n+ * <p>\n+ * The small tolerance number is used only to account for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionNewtonFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)\n+        double a[] = { 2.0, 1.5 };\n+        double c[] = { 4.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(2, coefficients.length);\n+        assertEquals(-4.0, coefficients[0], tolerance);\n+        assertEquals(1.5, coefficients[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)\n+        double a[] = { 4.0, 3.0, 2.0 };\n+        double c[] = { 1.0, -2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(3, coefficients.length);\n+        assertEquals(-3.0, coefficients[0], tolerance);\n+        assertEquals(5.0, coefficients[1], tolerance);\n+        assertEquals(2.0, coefficients[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x\n+        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)\n+        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };\n+        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(6, coefficients.length);\n+        assertEquals(0.0, coefficients[0], tolerance);\n+        assertEquals(6.0, coefficients[1], tolerance);\n+        assertEquals(1.0, coefficients[2], tolerance);\n+        assertEquals(-7.0, coefficients[3], tolerance);\n+        assertEquals(-1.0, coefficients[4], tolerance);\n+        assertEquals(1.0, coefficients[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+        PolynomialFunctionNewtonForm p;\n+\n+        try {\n+            // bad input array length\n+            double a[] = { 1.0 };\n+            double c[] = { 2.0 };\n+            p = new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double a[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double c[] = { 4.0, 3.0, 2.0, 1.0 };\n+            p = new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/analysis/RiddersSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/RiddersSolverTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.math.MathException;\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for Ridders solver.\n- * <p>\n- * Ridders' method converges superlinearly, more specific, its rate of\n- * convergence is sqrt(2). Test runs show that for a default absolute\n- * accuracy of 1E-6, it generally takes less than 5 iterations for close\n- * initial bracket and 5 to 10 iterations for distant initial bracket\n- * to converge.\n- * \n- * @version $Revision$ $Date$ \n- */\n-public final class RiddersSolverTest extends TestCase {\n-\n-    /**\n-     * Test of solver for the sine function.\n-     */\n-    public void testSinFunction() throws MathException {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = 3.0; max = 4.0; expected = Math.PI;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -1.0; max = 1.5; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the quintic function.\n-     */\n-    public void testQuinticFunction() throws MathException {\n-        UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -0.4; max = 0.2; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = 0.75; max = 1.5; expected = 1.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -0.9; max = -0.2; expected = -0.5;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of solver for the exponential function.\n-     */\n-    public void testExpm1Function() throws MathException {\n-        UnivariateRealFunction f = new Expm1Function();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n-        double min, max, expected, result, tolerance;\n-\n-        min = -1.0; max = 2.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -20.0; max = 10.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-\n-        min = -50.0; max = 100.0; expected = 0.0;\n-        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n-                    Math.abs(expected * solver.getRelativeAccuracy()));\n-        result = solver.solve(min, max);\n-        assertEquals(expected, result, tolerance);\n-    }\n-\n-    /**\n-     * Test of parameters for the solver.\n-     */\n-    public void testParameters() throws Exception {\n-        UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealSolver solver = new RiddersSolver(f);\n-\n-        try {\n-            // bad interval\n-            solver.solve(1, -1);\n-            fail(\"Expecting IllegalArgumentException - bad interval\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-        try {\n-            // no bracketing\n-            solver.solve(2, 3);\n-            fail(\"Expecting IllegalArgumentException - no bracketing\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Ridders solver.\n+ * <p>\n+ * Ridders' method converges superlinearly, more specific, its rate of\n+ * convergence is sqrt(2). Test runs show that for a default absolute\n+ * accuracy of 1E-6, it generally takes less than 5 iterations for close\n+ * initial bracket and 5 to 10 iterations for distant initial bracket\n+ * to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RiddersSolverTest extends TestCase {\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+\n+        try {\n+            // bad interval\n+            solver.solve(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/CauchyDistributionTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-/**\n- * Test cases for CauchyDistribution.\n- * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n- * ContinuousDistributionAbstractTest for details.\n- * \n- * @version $Revision$ $Date$\n- */\n-public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n-    \n-    /**\n-     * Constructor for CauchyDistributionTest.\n-     * @param arg0\n-     */\n-    public CauchyDistributionTest(String arg0) {\n-        super(arg0);\n-    }\n-    \n-    //-------------- Implementations for abstract methods -----------------------\n-    \n-    /** Creates the default continuous distribution instance to use in tests. */\n-    public ContinuousDistribution makeDistribution() {\n-        return DistributionFactory.newInstance().createCauchyDistribution(1.2, 2.1);\n-    }   \n-    \n-    /** Creates the default cumulative probability distribution test input values */\n-    public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using Mathematica \n-        return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,\n-                -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,\n-                27.88302995d, 68.0230835d, 669.6485619d};\n-    }\n-    \n-    /** Creates the default cumulative probability density test expected values */\n-    public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n-                0.975d, 0.990d, 0.999d};\n-    }\n-    \n-    //---------------------------- Additional test cases -------------------------\n-    \n-    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n-        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n-        setInverseCumulativeTestValues(\n-                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n-        verifyInverseCumulativeProbabilities();\n-    }\n-    \n-    public void testMedian() {\n-        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        double expected = Math.random();\n-        distribution.setMedian(expected);\n-        assertEquals(expected, distribution.getMedian(), 0.0);\n-    }\n-    \n-    public void testScale() {\n-        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        double expected = Math.random();\n-        distribution.setScale(expected);\n-        assertEquals(expected, distribution.getScale(), 0.0);\n-    }\n-    \n-    public void testSetScale() {\n-        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n-        try {\n-            distribution.setScale(0.0);\n-            fail(\"Can not have 0.0 scale.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-        \n-        try {\n-            distribution.setScale(-1.0);\n-            fail(\"Can not have negative scale.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for CauchyDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n+    \n+    /**\n+     * Constructor for CauchyDistributionTest.\n+     * @param arg0\n+     */\n+    public CauchyDistributionTest(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    public ContinuousDistribution makeDistribution() {\n+        return DistributionFactory.newInstance().createCauchyDistribution(1.2, 2.1);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using Mathematica \n+        return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,\n+                -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,\n+                27.88302995d, 68.0230835d, 669.6485619d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n+                0.975d, 0.990d, 0.999d};\n+    }\n+    \n+    //---------------------------- Additional test cases -------------------------\n+    \n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n+        setInverseCumulativeTestValues(\n+                new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testMedian() {\n+        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setMedian(expected);\n+        assertEquals(expected, distribution.getMedian(), 0.0);\n+    }\n+    \n+    public void testScale() {\n+        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setScale(expected);\n+        assertEquals(expected, distribution.getScale(), 0.0);\n+    }\n+    \n+    public void testSetScale() {\n+        CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n+        try {\n+            distribution.setScale(0.0);\n+            fail(\"Can not have 0.0 scale.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setScale(-1.0);\n+            fail(\"Can not have negative scale.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.distribution;\n-\n-/**\n- * Test cases for WeibullDistribution.\n- * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n- * ContinuousDistributionAbstractTest for details.\n- * \n- * @version $Revision: 1.8 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n- */\n-public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n-    \n-    /**\n-     * Constructor for CauchyDistributionTest.\n-     * @param arg0\n-     */\n-    public WeibullDistributionTest(String arg0) {\n-        super(arg0);\n-    }\n-    \n-    //-------------- Implementations for abstract methods -----------------------\n-    \n-    /** Creates the default continuous distribution instance to use in tests. */\n-    public ContinuousDistribution makeDistribution() {\n-        return DistributionFactory.newInstance().createWeibullDistribution(1.2, 2.1);\n-    }   \n-    \n-    /** Creates the default cumulative probability distribution test input values */\n-    public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using Mathematica \n-        return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n-                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,\n-                6.232056007d, 7.497630467d, 10.51154969d};\n-    }\n-    \n-    /** Creates the default cumulative probability density test expected values */\n-    public double[] makeCumulativeTestValues() {\n-        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n-                0.975d, 0.990d, 0.999d};\n-    }\n-    \n-    //---------------------------- Additional test cases -------------------------\n-    \n-    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n-        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n-        setInverseCumulativeTestValues(\n-                new double[] {0.0, Double.POSITIVE_INFINITY});\n-        verifyInverseCumulativeProbabilities();\n-    }\n-    \n-    public void testAlpha() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        double expected = Math.random();\n-        distribution.setShape(expected);\n-        assertEquals(expected, distribution.getShape(), 0.0);\n-    }\n-    \n-    public void testBeta() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        double expected = Math.random();\n-        distribution.setScale(expected);\n-        assertEquals(expected, distribution.getScale(), 0.0);\n-    }\n-    \n-    public void testSetAlpha() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        try {\n-            distribution.setShape(0.0);\n-            fail(\"Can not have 0.0 alpha.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-        \n-        try {\n-            distribution.setShape(-1.0);\n-            fail(\"Can not have negative alpha.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-    \n-    public void testSetBeta() {\n-        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n-        try {\n-            distribution.setScale(0.0);\n-            fail(\"Can not have 0.0 beta.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-        \n-        try {\n-            distribution.setScale(-1.0);\n-            fail(\"Can not have negative beta.\");\n-        } catch (IllegalArgumentException ex) {\n-            // success\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Test cases for WeibullDistribution.\n+ * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n+ * ContinuousDistributionAbstractTest for details.\n+ * \n+ * @version $Revision: 1.8 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n+ */\n+public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n+    \n+    /**\n+     * Constructor for CauchyDistributionTest.\n+     * @param arg0\n+     */\n+    public WeibullDistributionTest(String arg0) {\n+        super(arg0);\n+    }\n+    \n+    //-------------- Implementations for abstract methods -----------------------\n+    \n+    /** Creates the default continuous distribution instance to use in tests. */\n+    public ContinuousDistribution makeDistribution() {\n+        return DistributionFactory.newInstance().createWeibullDistribution(1.2, 2.1);\n+    }   \n+    \n+    /** Creates the default cumulative probability distribution test input values */\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using Mathematica \n+        return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n+                0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,\n+                6.232056007d, 7.497630467d, 10.51154969d};\n+    }\n+    \n+    /** Creates the default cumulative probability density test expected values */\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n+                0.975d, 0.990d, 0.999d};\n+    }\n+    \n+    //---------------------------- Additional test cases -------------------------\n+    \n+    public void testInverseCumulativeProbabilityExtremes() throws Exception {\n+        setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n+        setInverseCumulativeTestValues(\n+                new double[] {0.0, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+    \n+    public void testAlpha() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setShape(expected);\n+        assertEquals(expected, distribution.getShape(), 0.0);\n+    }\n+    \n+    public void testBeta() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        double expected = Math.random();\n+        distribution.setScale(expected);\n+        assertEquals(expected, distribution.getScale(), 0.0);\n+    }\n+    \n+    public void testSetAlpha() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        try {\n+            distribution.setShape(0.0);\n+            fail(\"Can not have 0.0 alpha.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setShape(-1.0);\n+            fail(\"Can not have negative alpha.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testSetBeta() {\n+        WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n+        try {\n+            distribution.setScale(0.0);\n+            fail(\"Can not have 0.0 beta.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+        \n+        try {\n+            distribution.setScale(-1.0);\n+            fail(\"Can not have negative beta.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionFormatTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.commons.math.fraction;\n-\n-import java.text.NumberFormat;\n-import java.text.ParseException;\n-import java.util.Locale;\n-\n-import junit.framework.TestCase;\n-\n-public class FractionFormatTest extends TestCase {\n- \n-    FractionFormat properFormat = null;\n-    FractionFormat improperFormat = null;\n-\n-    protected Locale getLocale() {\n-        return Locale.getDefault();\n-    }\n-\n-    protected void setUp() throws Exception {\n-        properFormat = FractionFormat.getProperInstance(getLocale());\n-        improperFormat = FractionFormat.getImproperInstance(getLocale());\n-    }\n-   \n-    public void testFormat() {\n-        Fraction c = new Fraction(1, 2);\n-        String expected = \"1 / 2\";\n-        \n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c);\n-        assertEquals(expected, actual);\n-    }\n-\n-    public void testFormatNegative() {\n-        Fraction c = new Fraction(-1, 2);\n-        String expected = \"-1 / 2\";\n-\n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c); \n-        assertEquals(expected, actual);\n-    }\n-\n-    public void testFormatZero() {\n-        Fraction c = new Fraction(0, 1);\n-        String expected = \"0 / 1\";\n-\n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n-    public void testFormatImproper() {\n-        Fraction c = new Fraction(5, 3);\n-\n-        String actual = properFormat.format(c); \n-        assertEquals(\"1 2 / 3\", actual);\n-\n-        actual = improperFormat.format(c); \n-        assertEquals(\"5 / 3\", actual);\n-    }\n-    \n-    public void testFormatImproperNegative() {\n-        Fraction c = new Fraction(-5, 3);\n-\n-        String actual = properFormat.format(c); \n-        assertEquals(\"-1 2 / 3\", actual);\n-\n-        actual = improperFormat.format(c); \n-        assertEquals(\"-5 / 3\", actual);\n-    }\n-    \n-    public void testParse() {\n-        String source = \"1 / 2\";\n-\n-        try {\n-            Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-            \n-            c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n-    public void testParseInteger() {\n-        String source = \"10\";\n-        try {\n-            Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(10, c.getNumerator());\n-            assertEquals(1, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-        try {\n-            Fraction c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(10, c.getNumerator());\n-            assertEquals(1, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n-    public void testParseInvalid() {\n-        String source = \"a\";\n-        String msg = \"should not be able to parse '10 / a'.\";\n-        try {\n-            properFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-        try {\n-            improperFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-    \n-    public void testParseInvalidDenominator() {\n-        String source = \"10 / a\";\n-        String msg = \"should not be able to parse '10 / a'.\";\n-        try {\n-            properFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-        try {\n-            improperFormat.parse(source);\n-            fail(msg);\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-    \n-    public void testParseNegative() {\n-\n-        try {\n-            String source = \"-1 / 2\";\n-            Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-            \n-            c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-\n-            source = \"1 / -2\";\n-            c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-            \n-            c = improperFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-1, c.getNumerator());\n-            assertEquals(2, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n-    public void testParseProper() {\n-        String source = \"1 2 / 3\";\n-\n-        try {\n-            Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(5, c.getNumerator());\n-            assertEquals(3, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-        \n-        try {\n-            improperFormat.parse(source);\n-            fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-    \n-    public void testParseProperNegative() {\n-        String source = \"-1 2 / 3\";\n-        try {\n-            Fraction c = properFormat.parse(source);\n-            assertNotNull(c);\n-            assertEquals(-5, c.getNumerator());\n-            assertEquals(3, c.getDenominator());\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-        \n-        try {\n-            improperFormat.parse(source);\n-            fail(\"invalid improper fraction.\");\n-        } catch (ParseException ex) {\n-            // success\n-        }\n-    }\n-    \n-    public void testParseProperInvalidMinus() {\n-        String source = \"2 -2 / 3\";\n-        try {\n-            Fraction c = properFormat.parse(source);\n-            fail(\"invalid minus in improper fraction.\");\n-        } catch (ParseException ex) {\n-            // expected\n-        }\n-        source = \"2 2 / -3\";\n-        try {\n-            Fraction c = properFormat.parse(source);\n-            fail(\"invalid minus in improper fraction.\");\n-        } catch (ParseException ex) {\n-            // expected\n-        }\n-    }\n-    \n-    public void testNumeratorFormat() {\n-        NumberFormat old = properFormat.getNumeratorFormat();\n-        NumberFormat nf = NumberFormat.getInstance();\n-        nf.setParseIntegerOnly(true);\n-        properFormat.setNumeratorFormat(nf);\n-        assertEquals(nf, properFormat.getNumeratorFormat());\n-        properFormat.setNumeratorFormat(old);\n-\n-        old = improperFormat.getNumeratorFormat();\n-        nf = NumberFormat.getInstance();\n-        nf.setParseIntegerOnly(true);\n-        improperFormat.setNumeratorFormat(nf);\n-        assertEquals(nf, improperFormat.getNumeratorFormat());\n-        improperFormat.setNumeratorFormat(old);\n-    }\n-    \n-    public void testDenominatorFormat() {\n-        NumberFormat old = properFormat.getDenominatorFormat();\n-        NumberFormat nf = NumberFormat.getInstance();\n-        nf.setParseIntegerOnly(true);\n-        properFormat.setDenominatorFormat(nf);\n-        assertEquals(nf, properFormat.getDenominatorFormat());\n-        properFormat.setDenominatorFormat(old);\n-\n-        old = improperFormat.getDenominatorFormat();\n-        nf = NumberFormat.getInstance();\n-        nf.setParseIntegerOnly(true);\n-        improperFormat.setDenominatorFormat(nf);\n-        assertEquals(nf, improperFormat.getDenominatorFormat());\n-        improperFormat.setDenominatorFormat(old);\n-    }\n-    \n-    public void testWholeFormat() {\n-        ProperFractionFormat format = (ProperFractionFormat)properFormat;\n-        \n-        NumberFormat old = format.getWholeFormat();\n-        NumberFormat nf = NumberFormat.getInstance();\n-        nf.setParseIntegerOnly(true);\n-        format.setWholeFormat(nf);\n-        assertEquals(nf, format.getWholeFormat());\n-        format.setWholeFormat(old);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+public class FractionFormatTest extends TestCase {\n+ \n+    FractionFormat properFormat = null;\n+    FractionFormat improperFormat = null;\n+\n+    protected Locale getLocale() {\n+        return Locale.getDefault();\n+    }\n+\n+    protected void setUp() throws Exception {\n+        properFormat = FractionFormat.getProperInstance(getLocale());\n+        improperFormat = FractionFormat.getImproperInstance(getLocale());\n+    }\n+   \n+    public void testFormat() {\n+        Fraction c = new Fraction(1, 2);\n+        String expected = \"1 / 2\";\n+        \n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatNegative() {\n+        Fraction c = new Fraction(-1, 2);\n+        String expected = \"-1 / 2\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testFormatZero() {\n+        Fraction c = new Fraction(0, 1);\n+        String expected = \"0 / 1\";\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testFormatImproper() {\n+        Fraction c = new Fraction(5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"5 / 3\", actual);\n+    }\n+    \n+    public void testFormatImproperNegative() {\n+        Fraction c = new Fraction(-5, 3);\n+\n+        String actual = properFormat.format(c); \n+        assertEquals(\"-1 2 / 3\", actual);\n+\n+        actual = improperFormat.format(c); \n+        assertEquals(\"-5 / 3\", actual);\n+    }\n+    \n+    public void testParse() {\n+        String source = \"1 / 2\";\n+\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInteger() {\n+        String source = \"10\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(10, c.getNumerator());\n+            assertEquals(1, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        try {\n+            Fraction c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(10, c.getNumerator());\n+            assertEquals(1, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseInvalid() {\n+        String source = \"a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseInvalidDenominator() {\n+        String source = \"10 / a\";\n+        String msg = \"should not be able to parse '10 / a'.\";\n+        try {\n+            properFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+        try {\n+            improperFormat.parse(source);\n+            fail(msg);\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseNegative() {\n+\n+        try {\n+            String source = \"-1 / 2\";\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+\n+            source = \"1 / -2\";\n+            c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+            \n+            c = improperFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-1, c.getNumerator());\n+            assertEquals(2, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseProper() {\n+        String source = \"1 2 / 3\";\n+\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(5, c.getNumerator());\n+            assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperNegative() {\n+        String source = \"-1 2 / 3\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            assertNotNull(c);\n+            assertEquals(-5, c.getNumerator());\n+            assertEquals(3, c.getDenominator());\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+        \n+        try {\n+            improperFormat.parse(source);\n+            fail(\"invalid improper fraction.\");\n+        } catch (ParseException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testParseProperInvalidMinus() {\n+        String source = \"2 -2 / 3\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+        source = \"2 2 / -3\";\n+        try {\n+            Fraction c = properFormat.parse(source);\n+            fail(\"invalid minus in improper fraction.\");\n+        } catch (ParseException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testNumeratorFormat() {\n+        NumberFormat old = properFormat.getNumeratorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, properFormat.getNumeratorFormat());\n+        properFormat.setNumeratorFormat(old);\n+\n+        old = improperFormat.getNumeratorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setNumeratorFormat(nf);\n+        assertEquals(nf, improperFormat.getNumeratorFormat());\n+        improperFormat.setNumeratorFormat(old);\n+    }\n+    \n+    public void testDenominatorFormat() {\n+        NumberFormat old = properFormat.getDenominatorFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        properFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, properFormat.getDenominatorFormat());\n+        properFormat.setDenominatorFormat(old);\n+\n+        old = improperFormat.getDenominatorFormat();\n+        nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        improperFormat.setDenominatorFormat(nf);\n+        assertEquals(nf, improperFormat.getDenominatorFormat());\n+        improperFormat.setDenominatorFormat(old);\n+    }\n+    \n+    public void testWholeFormat() {\n+        ProperFractionFormat format = (ProperFractionFormat)properFormat;\n+        \n+        NumberFormat old = format.getWholeFormat();\n+        NumberFormat nf = NumberFormat.getInstance();\n+        nf.setParseIntegerOnly(true);\n+        format.setWholeFormat(nf);\n+        assertEquals(nf, format.getWholeFormat());\n+        format.setWholeFormat(old);\n+    }\n+}\n--- a/src/test/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.math.fraction;\n-\n-import org.apache.commons.math.ConvergenceException;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * @version $Revision$ $Date$\n- */\n-public class FractionTest extends TestCase {\n-\n-    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {\n-        assertEquals(expectedNumerator, actual.getNumerator());\n-        assertEquals(expectedDenominator, actual.getDenominator());\n-    }\n-    \n-    public void testConstructor() {\n-        assertFraction(0, 1, new Fraction(0, 1));\n-        assertFraction(0, 1, new Fraction(0, 2));\n-        assertFraction(0, 1, new Fraction(0, -1));\n-        assertFraction(1, 2, new Fraction(1, 2));\n-        assertFraction(1, 2, new Fraction(2, 4));\n-        assertFraction(-1, 2, new Fraction(-1, 2));\n-        assertFraction(-1, 2, new Fraction(1, -2));\n-        assertFraction(-1, 2, new Fraction(-2, 4));\n-        assertFraction(-1, 2, new Fraction(2, -4));\n-        \n-        // overflow\n-        try {\n-            new Fraction(Integer.MIN_VALUE, -1);\n-            fail();\n-        } catch (ArithmeticException ex) {\n-            // success\n-        }\n-        try {\n-            new Fraction(1, Integer.MIN_VALUE);\n-            fail();\n-        } catch (ArithmeticException ex) {\n-            // success\n-        }\n-        try {        \n-            assertFraction(0, 1, new Fraction(0.00000000000001));\n-            assertFraction(2, 5, new Fraction(0.40000000000001));\n-            assertFraction(15, 1, new Fraction(15.0000000000001));\n-            \n-        } catch (ConvergenceException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n-    public void testCompareTo() {\n-        Fraction first = new Fraction(1, 2);\n-        Fraction second = new Fraction(1, 3);\n-        Fraction third = new Fraction(1, 2);\n-        \n-        assertEquals(0, first.compareTo(first));\n-        assertEquals(0, first.compareTo(third));\n-        assertEquals(1, first.compareTo(second));\n-        assertEquals(-1, second.compareTo(first));\n-    }\n-    \n-    public void testDoubleValue() {\n-        Fraction first = new Fraction(1, 2);\n-        Fraction second = new Fraction(1, 3);\n-\n-        assertEquals(0.5, first.doubleValue(), 0.0);\n-        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n-    }\n-    \n-    public void testFloatValue() {\n-        Fraction first = new Fraction(1, 2);\n-        Fraction second = new Fraction(1, 3);\n-\n-        assertEquals(0.5f, first.floatValue(), 0.0f);\n-        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);\n-    }\n-    \n-    public void testIntValue() {\n-        Fraction first = new Fraction(1, 2);\n-        Fraction second = new Fraction(3, 2);\n-\n-        assertEquals(0, first.intValue());\n-        assertEquals(1, second.intValue());\n-    }\n-    \n-    public void testLongValue() {\n-        Fraction first = new Fraction(1, 2);\n-        Fraction second = new Fraction(3, 2);\n-\n-        assertEquals(0L, first.longValue());\n-        assertEquals(1L, second.longValue());\n-    }\n-    \n-    public void testConstructorDouble() {\n-        try {\n-            assertFraction(1, 2, new Fraction(0.5));\n-            assertFraction(1, 3, new Fraction(1.0 / 3.0));\n-            assertFraction(17, 100, new Fraction(17.0 / 100.0));\n-            assertFraction(317, 100, new Fraction(317.0 / 100.0));\n-            assertFraction(-1, 2, new Fraction(-0.5));\n-            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));\n-            assertFraction(-17, 100, new Fraction(17.0 / -100.0));\n-            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));\n-        } catch (ConvergenceException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n-    public void testAbs() {\n-        Fraction a = new Fraction(10, 21);\n-        Fraction b = new Fraction(-10, 21);\n-        Fraction c = new Fraction(10, -21);\n-        \n-        assertFraction(10, 21, a.abs());\n-        assertFraction(10, 21, b.abs());\n-        assertFraction(10, 21, c.abs());\n-    }\n-    \n-    public void testReciprocal() {\n-        Fraction f = null;\n-        \n-        f = new Fraction(50, 75);\n-        f = f.reciprocal();\n-        assertEquals(3, f.getNumerator());\n-        assertEquals(2, f.getDenominator());\n-        \n-        f = new Fraction(4, 3);\n-        f = f.reciprocal();\n-        assertEquals(3, f.getNumerator());\n-        assertEquals(4, f.getDenominator());\n-        \n-        f = new Fraction(-15, 47);\n-        f = f.reciprocal();\n-        assertEquals(-47, f.getNumerator());\n-        assertEquals(15, f.getDenominator());\n-        \n-        f = new Fraction(0, 3);\n-        try {\n-            f = f.reciprocal();\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-\n-        // large values\n-        f = new Fraction(Integer.MAX_VALUE, 1);\n-        f = f.reciprocal();\n-        assertEquals(1, f.getNumerator());\n-        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n-    }\n-    \n-    public void testNegate() {\n-        Fraction f = null;\n-        \n-        f = new Fraction(50, 75);\n-        f = f.negate();\n-        assertEquals(-2, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n-        \n-        f = new Fraction(-50, 75);\n-        f = f.negate();\n-        assertEquals(2, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n-\n-        // large values\n-        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n-        f = f.negate();\n-        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n-        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n-\n-        f = new Fraction(Integer.MIN_VALUE, 1);\n-        try {\n-            f = f.negate();\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-    }\n-    \n-    public void testAdd() {\n-        Fraction a = new Fraction(1, 2);\n-        Fraction b = new Fraction(2, 3);\n-        \n-        assertFraction(1, 1, a.add(a));\n-        assertFraction(7, 6, a.add(b));\n-        assertFraction(7, 6, b.add(a));\n-        assertFraction(4, 3, b.add(b));\n-        \n-        Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n-        Fraction f2 = Fraction.ONE;\n-        Fraction f = f1.add(f2);\n-        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n-        \n-        f1 = new Fraction(-1, 13*13*2*2);\n-        f2 = new Fraction(-2, 13*17*2);\n-        f = f1.add(f2);\n-        assertEquals(13*13*17*2*2, f.getDenominator());\n-        assertEquals(-17 - 2*13*2, f.getNumerator());\n-        \n-        try {\n-            f.add(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n-        \n-        // if this fraction is added naively, it will overflow.\n-        // check that it doesn't.\n-        f1 = new Fraction(1,32768*3);\n-        f2 = new Fraction(1,59049);\n-        f = f1.add(f2);\n-        assertEquals(52451, f.getNumerator());\n-        assertEquals(1934917632, f.getDenominator());\n-\n-        f1 = new Fraction(Integer.MIN_VALUE, 3);\n-        f2 = new Fraction(1,3);\n-        f = f1.add(f2);\n-        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n-        \n-        f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n-        f2 = Fraction.ONE;\n-        f = f1.add(f2);\n-        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n-        \n-        try {\n-            f = f.add(Fraction.ONE); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n-        \n-        // denominator should not be a multiple of 2 or 3 to trigger overflow\n-        f1 = new Fraction(Integer.MIN_VALUE, 5);\n-        f2 = new Fraction(-1,5);\n-        try {\n-            f = f1.add(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n-        \n-        try {\n-            f= new Fraction(-Integer.MAX_VALUE, 1);\n-            f = f.add(f);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-        \n-        try {\n-            f= new Fraction(-Integer.MAX_VALUE, 1);\n-            f = f.add(f);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-        \n-        f1 = new Fraction(3,327680);\n-        f2 = new Fraction(2,59049);\n-        try {\n-            f = f1.add(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n-    }\n-    \n-    public void testDivide() {\n-        Fraction a = new Fraction(1, 2);\n-        Fraction b = new Fraction(2, 3);\n-        \n-        assertFraction(1, 1, a.divide(a));\n-        assertFraction(3, 4, a.divide(b));\n-        assertFraction(4, 3, b.divide(a));\n-        assertFraction(1, 1, b.divide(b));\n-        \n-        Fraction f1 = new Fraction(3, 5);\n-        Fraction f2 = Fraction.ZERO;\n-        try {\n-            Fraction f = f1.divide(f2);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-        \n-        f1 = new Fraction(0, 5);\n-        f2 = new Fraction(2, 7);\n-        Fraction f = f1.divide(f2);\n-        assertSame(Fraction.ZERO, f);\n-        \n-        f1 = new Fraction(2, 7);\n-        f2 = Fraction.ONE;\n-        f = f1.divide(f2);\n-        assertEquals(2, f.getNumerator());\n-        assertEquals(7, f.getDenominator());\n-        \n-        f1 = new Fraction(1, Integer.MAX_VALUE);\n-        f = f1.divide(f1);  \n-        assertEquals(1, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n-        \n-        f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        f2 = new Fraction(1, Integer.MAX_VALUE);\n-        f = f1.divide(f2);\n-        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n-\n-        try {\n-            f.divide(null);\n-            fail(\"IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n-        \n-        try {\n-            f1 = new Fraction(1, Integer.MAX_VALUE);\n-            f = f1.divide(f1.reciprocal());  // should overflow\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-        try {\n-            f1 = new Fraction(1, -Integer.MAX_VALUE);\n-            f = f1.divide(f1.reciprocal());  // should overflow\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-    }\n-    \n-    public void testMultiply() {\n-        Fraction a = new Fraction(1, 2);\n-        Fraction b = new Fraction(2, 3);\n-        \n-        assertFraction(1, 4, a.multiply(a));\n-        assertFraction(1, 3, a.multiply(b));\n-        assertFraction(1, 3, b.multiply(a));\n-        assertFraction(4, 9, b.multiply(b));\n-        \n-        Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);\n-        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        Fraction f = f1.multiply(f2);\n-        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n-\n-        try {\n-            f.multiply(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-    \n-    public void testSubtract() {\n-        Fraction a = new Fraction(1, 2);\n-        Fraction b = new Fraction(2, 3);\n-        \n-        assertFraction(0, 1, a.subtract(a));\n-        assertFraction(-1, 6, a.subtract(b));\n-        assertFraction(1, 6, b.subtract(a));\n-        assertFraction(0, 1, b.subtract(b));\n-        \n-        Fraction f = new Fraction(1,1);\n-        try {\n-            f.subtract(null);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n-        \n-        // if this fraction is subtracted naively, it will overflow.\n-        // check that it doesn't.\n-        Fraction f1 = new Fraction(1,32768*3);\n-        Fraction f2 = new Fraction(1,59049);\n-        f = f1.subtract(f2);\n-        assertEquals(-13085, f.getNumerator());\n-        assertEquals(1934917632, f.getDenominator());\n-\n-        f1 = new Fraction(Integer.MIN_VALUE, 3);\n-        f2 = new Fraction(1,3).negate();\n-        f = f1.subtract(f2);\n-        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n-        assertEquals(3, f.getDenominator());\n-        \n-        f1 = new Fraction(Integer.MAX_VALUE, 1);\n-        f2 = Fraction.ONE;\n-        f = f1.subtract(f2);\n-        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n-        assertEquals(1, f.getDenominator());\n-\n-        try {\n-            f1 = new Fraction(1, Integer.MAX_VALUE);\n-            f2 = new Fraction(1, Integer.MAX_VALUE - 1);\n-            f = f1.subtract(f2);\n-            fail(\"expecting ArithmeticException\");  //should overflow\n-        } catch (ArithmeticException ex) {}\n-        \n-        // denominator should not be a multiple of 2 or 3 to trigger overflow\n-        f1 = new Fraction(Integer.MIN_VALUE, 5);\n-        f2 = new Fraction(1,5);\n-        try {\n-            f = f1.subtract(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n-        \n-        try {\n-            f= new Fraction(Integer.MIN_VALUE, 1);\n-            f = f.subtract(Fraction.ONE);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-        \n-        try {\n-            f= new Fraction(Integer.MAX_VALUE, 1);\n-            f = f.subtract(Fraction.ONE.negate());\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n-        \n-        f1 = new Fraction(3,327680);\n-        f2 = new Fraction(2,59049);\n-        try {\n-            f = f1.subtract(f2); // should overflow\n-            fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n-    }\n-    \n-    public void testEqualsAndHashCode() {\n-        Fraction zero  = new Fraction(0,1);\n-        Fraction nullFraction = null;\n-        int zeroHash = zero.hashCode();\n-        assertTrue( zero.equals(zero));\n-        assertFalse(zero.equals(nullFraction));\n-        assertFalse(zero.equals(new Double(0)));\n-        Fraction zero2 = new Fraction(0,2);\n-        assertTrue(zero.equals(zero2));\n-        assertEquals(zero.hashCode(), zero2.hashCode());\n-        Fraction one = new Fraction(1,1);\n-        assertFalse((one.equals(zero) ||zero.equals(one)));\n-    }\n-    \n-    public void testGetReducedFraction() {\n-        Fraction threeFourths = new Fraction(3, 4);\n-        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));\n-        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));\n-        try {\n-            Fraction f = Fraction.getReducedFraction(1, 0);\n-            fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n-            // expected\n-        }\n-        assertEquals(Fraction.getReducedFraction\n-                (2, Integer.MIN_VALUE).getNumerator(),-1);\n-        assertEquals(Fraction.getReducedFraction\n-                (1, -1).getNumerator(), -1);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class FractionTest extends TestCase {\n+\n+    private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) {\n+        assertEquals(expectedNumerator, actual.getNumerator());\n+        assertEquals(expectedDenominator, actual.getDenominator());\n+    }\n+    \n+    public void testConstructor() {\n+        assertFraction(0, 1, new Fraction(0, 1));\n+        assertFraction(0, 1, new Fraction(0, 2));\n+        assertFraction(0, 1, new Fraction(0, -1));\n+        assertFraction(1, 2, new Fraction(1, 2));\n+        assertFraction(1, 2, new Fraction(2, 4));\n+        assertFraction(-1, 2, new Fraction(-1, 2));\n+        assertFraction(-1, 2, new Fraction(1, -2));\n+        assertFraction(-1, 2, new Fraction(-2, 4));\n+        assertFraction(-1, 2, new Fraction(2, -4));\n+        \n+        // overflow\n+        try {\n+            new Fraction(Integer.MIN_VALUE, -1);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+        try {\n+            new Fraction(1, Integer.MIN_VALUE);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+        try {        \n+            assertFraction(0, 1, new Fraction(0.00000000000001));\n+            assertFraction(2, 5, new Fraction(0.40000000000001));\n+            assertFraction(15, 1, new Fraction(15.0000000000001));\n+            \n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testCompareTo() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(1, 3);\n+        Fraction third = new Fraction(1, 2);\n+        \n+        assertEquals(0, first.compareTo(first));\n+        assertEquals(0, first.compareTo(third));\n+        assertEquals(1, first.compareTo(second));\n+        assertEquals(-1, second.compareTo(first));\n+    }\n+    \n+    public void testDoubleValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(1, 3);\n+\n+        assertEquals(0.5, first.doubleValue(), 0.0);\n+        assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n+    }\n+    \n+    public void testFloatValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(1, 3);\n+\n+        assertEquals(0.5f, first.floatValue(), 0.0f);\n+        assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);\n+    }\n+    \n+    public void testIntValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(3, 2);\n+\n+        assertEquals(0, first.intValue());\n+        assertEquals(1, second.intValue());\n+    }\n+    \n+    public void testLongValue() {\n+        Fraction first = new Fraction(1, 2);\n+        Fraction second = new Fraction(3, 2);\n+\n+        assertEquals(0L, first.longValue());\n+        assertEquals(1L, second.longValue());\n+    }\n+    \n+    public void testConstructorDouble() {\n+        try {\n+            assertFraction(1, 2, new Fraction(0.5));\n+            assertFraction(1, 3, new Fraction(1.0 / 3.0));\n+            assertFraction(17, 100, new Fraction(17.0 / 100.0));\n+            assertFraction(317, 100, new Fraction(317.0 / 100.0));\n+            assertFraction(-1, 2, new Fraction(-0.5));\n+            assertFraction(-1, 3, new Fraction(-1.0 / 3.0));\n+            assertFraction(-17, 100, new Fraction(17.0 / -100.0));\n+            assertFraction(-317, 100, new Fraction(-317.0 / 100.0));\n+        } catch (ConvergenceException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testAbs() {\n+        Fraction a = new Fraction(10, 21);\n+        Fraction b = new Fraction(-10, 21);\n+        Fraction c = new Fraction(10, -21);\n+        \n+        assertFraction(10, 21, a.abs());\n+        assertFraction(10, 21, b.abs());\n+        assertFraction(10, 21, c.abs());\n+    }\n+    \n+    public void testReciprocal() {\n+        Fraction f = null;\n+        \n+        f = new Fraction(50, 75);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = new Fraction(4, 3);\n+        f = f.reciprocal();\n+        assertEquals(3, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n+        f = new Fraction(-15, 47);\n+        f = f.reciprocal();\n+        assertEquals(-47, f.getNumerator());\n+        assertEquals(15, f.getDenominator());\n+        \n+        f = new Fraction(0, 3);\n+        try {\n+            f = f.reciprocal();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // large values\n+        f = new Fraction(Integer.MAX_VALUE, 1);\n+        f = f.reciprocal();\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+    }\n+    \n+    public void testNegate() {\n+        Fraction f = null;\n+        \n+        f = new Fraction(50, 75);\n+        f = f.negate();\n+        assertEquals(-2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f = new Fraction(-50, 75);\n+        f = f.negate();\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+\n+        // large values\n+        f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        f = new Fraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.negate();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testAdd() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 1, a.add(a));\n+        assertFraction(7, 6, a.add(b));\n+        assertFraction(7, 6, b.add(a));\n+        assertFraction(4, 3, b.add(b));\n+        \n+        Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n+        Fraction f2 = Fraction.ONE;\n+        Fraction f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = new Fraction(-1, 13*13*2*2);\n+        f2 = new Fraction(-2, 13*17*2);\n+        f = f1.add(f2);\n+        assertEquals(13*13*17*2*2, f.getDenominator());\n+        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        \n+        try {\n+            f.add(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = new Fraction(1,32768*3);\n+        f2 = new Fraction(1,59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = new Fraction(Integer.MIN_VALUE, 3);\n+        f2 = new Fraction(1,3);\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        try {\n+            f = f.add(Fraction.ONE); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = new Fraction(Integer.MIN_VALUE, 5);\n+        f2 = new Fraction(-1,5);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(3,327680);\n+        f2 = new Fraction(2,59049);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testDivide() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 1, a.divide(a));\n+        assertFraction(3, 4, a.divide(b));\n+        assertFraction(4, 3, b.divide(a));\n+        assertFraction(1, 1, b.divide(b));\n+        \n+        Fraction f1 = new Fraction(3, 5);\n+        Fraction f2 = Fraction.ZERO;\n+        try {\n+            Fraction f = f1.divide(f2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(0, 5);\n+        f2 = new Fraction(2, 7);\n+        Fraction f = f1.divide(f2);\n+        assertSame(Fraction.ZERO, f);\n+        \n+        f1 = new Fraction(2, 7);\n+        f2 = Fraction.ONE;\n+        f = f1.divide(f2);\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(7, f.getDenominator());\n+        \n+        f1 = new Fraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f1);  \n+        assertEquals(1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = new Fraction(1, Integer.MAX_VALUE);\n+        f = f1.divide(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.divide(null);\n+            fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            f1 = new Fraction(1, Integer.MAX_VALUE);\n+            f = f1.divide(f1.reciprocal());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f1 = new Fraction(1, -Integer.MAX_VALUE);\n+            f = f1.divide(f1.reciprocal());  // should overflow\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testMultiply() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(1, 4, a.multiply(a));\n+        assertFraction(1, 3, a.multiply(b));\n+        assertFraction(1, 3, b.multiply(a));\n+        assertFraction(4, 9, b.multiply(b));\n+        \n+        Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);\n+        Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        Fraction f = f1.multiply(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f.multiply(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void testSubtract() {\n+        Fraction a = new Fraction(1, 2);\n+        Fraction b = new Fraction(2, 3);\n+        \n+        assertFraction(0, 1, a.subtract(a));\n+        assertFraction(-1, 6, a.subtract(b));\n+        assertFraction(1, 6, b.subtract(a));\n+        assertFraction(0, 1, b.subtract(b));\n+        \n+        Fraction f = new Fraction(1,1);\n+        try {\n+            f.subtract(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        Fraction f1 = new Fraction(1,32768*3);\n+        Fraction f2 = new Fraction(1,59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = new Fraction(Integer.MIN_VALUE, 3);\n+        f2 = new Fraction(1,3).negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = new Fraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        try {\n+            f1 = new Fraction(1, Integer.MAX_VALUE);\n+            f2 = new Fraction(1, Integer.MAX_VALUE - 1);\n+            f = f1.subtract(f2);\n+            fail(\"expecting ArithmeticException\");  //should overflow\n+        } catch (ArithmeticException ex) {}\n+        \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = new Fraction(Integer.MIN_VALUE, 5);\n+        f2 = new Fraction(1,5);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(Integer.MIN_VALUE, 1);\n+            f = f.subtract(Fraction.ONE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= new Fraction(Integer.MAX_VALUE, 1);\n+            f = f.subtract(Fraction.ONE.negate());\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        \n+        f1 = new Fraction(3,327680);\n+        f2 = new Fraction(2,59049);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        Fraction zero  = new Fraction(0,1);\n+        Fraction nullFraction = null;\n+        int zeroHash = zero.hashCode();\n+        assertTrue( zero.equals(zero));\n+        assertFalse(zero.equals(nullFraction));\n+        assertFalse(zero.equals(new Double(0)));\n+        Fraction zero2 = new Fraction(0,2);\n+        assertTrue(zero.equals(zero2));\n+        assertEquals(zero.hashCode(), zero2.hashCode());\n+        Fraction one = new Fraction(1,1);\n+        assertFalse((one.equals(zero) ||zero.equals(one)));\n+    }\n+    \n+    public void testGetReducedFraction() {\n+        Fraction threeFourths = new Fraction(3, 4);\n+        assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));\n+        assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1)));\n+        try {\n+            Fraction f = Fraction.getReducedFraction(1, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+        assertEquals(Fraction.getReducedFraction\n+                (2, Integer.MIN_VALUE).getNumerator(),-1);\n+        assertEquals(Fraction.getReducedFraction\n+                (1, -1).getNumerator(), -1);\n+    }\n+}", "timestamp": 1171319708, "metainfo": ""}