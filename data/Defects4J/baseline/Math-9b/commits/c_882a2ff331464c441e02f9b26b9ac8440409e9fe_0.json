{"sha": "882a2ff331464c441e02f9b26b9ac8440409e9fe", "log": "MATH-707 Renamed classes in package \"interpolation\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n  * @since 2.2\n  */\n public class BicubicSplineInterpolator\n-    implements BivariateRealGridInterpolator {\n+    implements BivariateGridInterpolator {\n     /**\n      * {@inheritDoc}\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BivariateGridInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.BivariateFunction;\n+\n+/**\n+ * Interface representing a bivariate real interpolating function where the\n+ * sample points must be specified on a regular grid.\n+ *\n+ * @version $Id$\n+ */\n+public interface BivariateGridInterpolator {\n+    /**\n+     * Compute an interpolating function for the dataset.\n+     *\n+     * @param xval All the x-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param yval All the y-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param fval The values of the interpolation points on all the grid knots:\n+     * {@code fval[i][j] = f(xval[i], yval[j])}.\n+     * @return a function which interpolates the dataset.\n+     * @throws org.apache.commons.math.exception.NoDataException if any of\n+     * the arrays has zero length.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array lengths are inconsistent.\n+     */\n+    BivariateFunction interpolate(double[] xval, double[] yval,\n+                                      double[][] fval);\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n  * @since 1.2\n  */\n public class DividedDifferenceInterpolator\n-    implements UnivariateRealInterpolator, Serializable {\n+    implements UnivariateInterpolator, Serializable {\n     /** serializable version identifier */\n     private static final long serialVersionUID = 107049519551235069L;\n \n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n  * Implements a linear function for interpolation of real univariate functions.\n  * @version $Id$\n  */\n-public class LinearInterpolator implements UnivariateRealInterpolator {\n+public class LinearInterpolator implements UnivariateInterpolator {\n     /**\n      * Computes a linear interpolating function for the data set.\n      * @param x the arguments for the interpolation points\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n  * @since 2.0\n  */\n public class LoessInterpolator\n-        implements UnivariateRealInterpolator, Serializable {\n+        implements UnivariateInterpolator, Serializable {\n     /** Default value of the bandwidth parameter. */\n     public static final double DEFAULT_BANDWIDTH = 0.3;\n     /** Default value of the number of robustness iterations. */\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n  * @version $Id$\n  */\n public class MicrosphereInterpolator\n-    implements MultivariateRealInterpolator {\n+    implements MultivariateInterpolator {\n     /**\n      * Default number of surface elements that composes the microsphere.\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MultivariateInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.MultivariateFunction;\n+\n+/**\n+ * Interface representing a univariate real interpolating function.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public interface MultivariateInterpolator {\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param xval the arguments for the interpolation points.\n+     * {@code xval[i][0]} is the first component of interpolation point\n+     * {@code i}, {@code xval[i][1]} is the second component, and so on\n+     * until {@code xval[i][d-1]}, the last component of that interpolation\n+     * point (where {@code d} is thus the dimension of the space).\n+     * @param yval the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments violate assumptions made by the interpolation\n+     * algorithm.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * when the array dimensions are not consistent.\n+     * @throws org.apache.commons.math.exception.NoDataException if an\n+     * array has zero-length.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * the arguments are {@code null}.\n+     */\n+    MultivariateFunction interpolate(double[][] xval, double[] yval);\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolator.java\n  * @version $Id$\n  * @since 1.2\n  */\n-public class NevilleInterpolator implements UnivariateRealInterpolator,\n+public class NevilleInterpolator implements UnivariateInterpolator,\n     Serializable {\n \n     /** serializable version identifier */\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n  * @version $Id$\n  *\n  */\n-public class SplineInterpolator implements UnivariateRealInterpolator {\n+public class SplineInterpolator implements UnivariateInterpolator {\n \n     /**\n      * Computes an interpolating function for the data set.\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolator.java\n  * @since 2.2\n  */\n public class TricubicSplineInterpolator\n-    implements TrivariateRealGridInterpolator {\n+    implements TrivariateGridInterpolator {\n     /**\n      * {@inheritDoc}\n      */\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/TrivariateGridInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.TrivariateFunction;\n+\n+/**\n+ * Interface representing a trivariate real interpolating function where the\n+ * sample points must be specified on a regular grid.\n+ *\n+ * @version $Id$\n+ * @since 2.2\n+ */\n+public interface TrivariateGridInterpolator {\n+    /**\n+     * Compute an interpolating function for the dataset.\n+     *\n+     * @param xval All the x-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param yval All the y-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param zval All the z-coordinates of the interpolation points, sorted\n+     * in increasing order.\n+     * @param fval the values of the interpolation points on all the grid knots:\n+     * {@code fval[i][j][k] = f(xval[i], yval[j], zval[k])}.\n+     * @return a function that interpolates the data set.\n+     * @throws org.apache.commons.math.exception.NoDataException if any of\n+     * the arrays has zero length.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array lengths are inconsistent.\n+     */\n+    TrivariateFunction interpolate(double[] xval, double[] yval, double[] zval,\n+                                       double[][][] fval);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+\n+/**\n+ * Interface representing a univariate real interpolating function.\n+ *\n+ * @version $Id$\n+ */\n+public interface UnivariateInterpolator {\n+    /**\n+     * Compute an interpolating function for the dataset.\n+     *\n+     * @param xval Arguments for the interpolation points.\n+     * @param yval Values for the interpolation points.\n+     * @return a function which interpolates the dataset.\n+     * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n+     * if the arguments violate assumptions made by the interpolation\n+     * algorithm.\n+     */\n+    UnivariateFunction interpolate(double xval[], double yval[]);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariatePeriodicInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.MathArrays;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+\n+/**\n+ * Adapter for classes implementing the {@link UnivariateInterpolator}\n+ * interface.\n+ * The data to be interpolated is assumed to be periodic. Thus values that are\n+ * outside of the range can be passed to the interpolation function: They will\n+ * be wrapped into the initial range before being passed to the class that\n+ * actually computes the interpolation.\n+ *\n+ * @version $Id$\n+ */\n+public class UnivariatePeriodicInterpolator\n+    implements UnivariateInterpolator {\n+    /** Default number of extension points of the samples array. */\n+    public static final int DEFAULT_EXTEND = 5;\n+    /** Interpolator. */\n+    private final UnivariateInterpolator interpolator;\n+    /** Period. */\n+    private final double period;\n+    /** Number of extension points. */\n+    private final int extend;\n+\n+    /**\n+     * Builds an interpolator.\n+     *\n+     * @param interpolator Interpolator.\n+     * @param period Period.\n+     * @param extend Number of points to be appended at the beginning and\n+     * end of the sample arrays in order to avoid interpolation failure at\n+     * the (periodic) boundaries of the orginal interval. The value is the\n+     * number of sample points which the original {@code interpolator} needs\n+     * on each side of the interpolated point.\n+     */\n+    public UnivariatePeriodicInterpolator(UnivariateInterpolator interpolator,\n+                                              double period,\n+                                              int extend) {\n+        this.interpolator = interpolator;\n+        this.period = period;\n+        this.extend = extend;\n+    }\n+\n+    /**\n+     * Builds an interpolator.\n+     * Uses {@link #DEFAULT_EXTEND} as the number of extension points on each side\n+     * of the original abscissae range.\n+     *\n+     * @param interpolator Interpolator.\n+     * @param period Period.\n+     */\n+    public UnivariatePeriodicInterpolator(UnivariateInterpolator interpolator,\n+                                              double period) {\n+        this(interpolator, period, DEFAULT_EXTEND);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws NumberIsTooSmallException if the number of extension points\n+     * iss larger then the size of {@code xval}.\n+     */\n+    public UnivariateFunction interpolate(double[] xval,\n+                                              double[] yval) {\n+        if (xval.length < extend) {\n+            throw new NumberIsTooSmallException(xval.length, extend, true);\n+        }\n+\n+        MathArrays.checkOrder(xval);\n+        final double offset = xval[0];\n+\n+        final int len = xval.length + extend * 2;\n+        final double[] x = new double[len];\n+        final double[] y = new double[len];\n+        for (int i = 0; i < xval.length; i++) {\n+            final int index = i + extend;\n+            x[index] = MathUtils.reduce(xval[i], period, offset);\n+            y[index] = yval[i];\n+        }\n+\n+        // Wrap to enable interpolation at the boundaries.\n+        for (int i = 0; i < extend; i++) {\n+            int index = xval.length - extend + i;\n+            x[i] = MathUtils.reduce(xval[index], period, offset) - period;\n+            y[i] = yval[index];\n+\n+            index = len - extend + i;\n+            x[index] = MathUtils.reduce(xval[i], period, offset) + period;\n+            y[index] = yval[i];\n+        }\n+\n+        MathArrays.sortInPlace(x, y);\n+\n+        final UnivariateFunction f = interpolator.interpolate(x, y);\n+        return new UnivariateFunction() {\n+            public double value(final double x) {\n+                return f.value(MathUtils.reduce(x, period, offset));\n+            }\n+        };\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatorTest.java\n         double[] yval = new double[] {-4, -3, -1, 2.5};\n         double[][] zval = new double[xval.length][yval.length];\n \n-        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();\n+        BivariateGridInterpolator interpolator = new BicubicSplineInterpolator();\n         \n         @SuppressWarnings(\"unused\")\n         BivariateFunction p = interpolator.interpolate(xval, yval, zval);\n                 }\n             };\n \n-        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();\n+        BivariateGridInterpolator interpolator = new BicubicSplineInterpolator();\n \n         double[] xval = new double[] {3, 4, 5, 6.5};\n         double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n                 }\n             };\n \n-        BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator();\n+        BivariateGridInterpolator interpolator = new BicubicSplineInterpolator();\n \n         double[] xval = new double[] {3, 4, 5, 6.5};\n         double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        UnivariateInterpolator interpolator = new DividedDifferenceInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n         // 6 interpolating points on interval [0, 2*PI]\n     @Test\n     public void testExpm1Function() {\n         UnivariateFunction f = new Expm1Function();\n-        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        UnivariateInterpolator interpolator = new DividedDifferenceInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n         // 5 interpolating points on interval [-1, 1]\n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        UnivariateInterpolator interpolator = new DividedDifferenceInterpolator();\n \n         try {\n             // bad abscissas array\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LinearInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LinearInterpolatorTest.java\n         throws Exception {\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 1.0 };\n-        UnivariateRealInterpolator i = new LinearInterpolator();\n+        UnivariateInterpolator i = new LinearInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n         throws Exception {\n         double x[] = { 0.0, 0.5, 1.0, 1.5 };\n         double y[] = { 0.0, 0.5, 1.0, 1.5 };\n-        UnivariateRealInterpolator i = new LinearInterpolator();\n+        UnivariateInterpolator i = new LinearInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n     public void testInterpolateLinear() throws Exception {\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 0.0 };\n-        UnivariateRealInterpolator i = new LinearInterpolator();\n+        UnivariateInterpolator i = new LinearInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n     @Test\n     public void testIllegalArguments() {\n         // Data set arrays of different size.\n-        UnivariateRealInterpolator i = new LinearInterpolator();\n+        UnivariateInterpolator i = new LinearInterpolator();\n         try {\n             double xval[] = { 0.0, 1.0 };\n             double yval[] = { 0.0, 1.0, 2.0 };\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatorTest.java\n                 }\n             };\n \n-        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();\n+        MultivariateInterpolator interpolator = new MicrosphereInterpolator();\n \n         // Interpolating points in [-1, 1][-1, 1] by steps of 1.\n         final int n = 9;\n                 }\n             };\n \n-        MultivariateRealInterpolator interpolator = new MicrosphereInterpolator();\n+        MultivariateInterpolator interpolator = new MicrosphereInterpolator();\n \n         // Interpolating points in [-10, 10][-10, 10] by steps of 2.\n         final int n = 121;\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n     @Test\n     public void testSinFunction() {\n         UnivariateFunction f = new SinFunction();\n-        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        UnivariateInterpolator interpolator = new NevilleInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n         // 6 interpolating points on interval [0, 2*PI]\n     @Test\n     public void testExpm1Function() {\n         UnivariateFunction f = new Expm1Function();\n-        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        UnivariateInterpolator interpolator = new NevilleInterpolator();\n         double x[], y[], z, expected, result, tolerance;\n \n         // 5 interpolating points on interval [-1, 1]\n      */\n     @Test\n     public void testParameters() throws Exception {\n-        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        UnivariateInterpolator interpolator = new NevilleInterpolator();\n \n         try {\n             // bad abscissas array\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolatorTest.java\n         double[] yval = new double[] {-4, -3, -1, 2.5};\n         double[][] zval = new double[xval.length][yval.length];\n \n-        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0);\n+        BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0);\n         \n         @SuppressWarnings(\"unused\")\n         BivariateFunction p = interpolator.interpolate(xval, yval, zval);\n                 }\n             };\n \n-        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1);\n+        BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1);\n \n         double[] xval = new double[] {3, 4, 5, 6.5};\n         double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n                 }\n             };\n \n-        BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4);\n+        BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4);\n \n         double[] xval = new double[] {3, 4, 5, 6.5};\n         double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5};\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n         throws Exception {\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 1.0 };\n-        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateInterpolator i = new SplineInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n         throws Exception {\n         double x[] = { 0.0, 0.5, 1.0, 1.5 };\n         double y[] = { 0.0, 0.5, 1.0, 1.5 };\n-        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateInterpolator i = new SplineInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n \n     public void testInterpolateLinear() throws Exception {\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 0.0 };\n-        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateInterpolator i = new SplineInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n                 11d * FastMath.PI / 6d,\n                 2.d * FastMath.PI };\n         double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };\n-        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateInterpolator i = new SplineInterpolator();\n         UnivariateFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n     @Test\n     public void testIllegalArguments() {\n         // Data set arrays of different size.\n-        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateInterpolator i = new SplineInterpolator();\n         try {\n             double xval[] = { 0.0, 1.0 };\n             double yval[] = { 0.0, 1.0, 2.0 };\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/TricubicSplineInterpolatorTest.java\n         double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5};\n         double[][][] fval = new double[xval.length][yval.length][zval.length];\n \n-        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();\n+        TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator();\n         \n         @SuppressWarnings(\"unused\")\n         TrivariateFunction p = interpolator.interpolate(xval, yval, zval, fval);\n                 }\n             };\n \n-        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();\n+        TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator();\n \n         double[] xval = new double[] {3, 4, 5, 6.5};\n         double[] yval = new double[] {-4, -3, -1, 2, 2.5};\n             }\n         }\n \n-        TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator();\n+        TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator();\n \n         TrivariateFunction p = interpolator.interpolate(xval, yval, zval, fval);\n         double x, y, z;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/UnivariatePeriodicInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.util.Random;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Test for {@link UnivariatePeriodicInterpolator}.\n+ */\n+public class UnivariatePeriodicInterpolatorTest {\n+    private final Random rng = new Random(1224465L);\n+\n+    @Test\n+    public void testSine() {\n+        final int n = 30;\n+        final double[] xval = new double[n];\n+        final double[] yval = new double[n];\n+        final double period = 12.3;\n+        final double offset = 45.67;\n+\n+        double delta = 0;\n+        for (int i = 0; i < n; i++) {\n+            delta += rng.nextDouble() * period / n;\n+            xval[i] = offset + delta;\n+            yval[i] = FastMath.sin(xval[i]);\n+        }\n+\n+        final UnivariateInterpolator inter = new LinearInterpolator();\n+        final UnivariateFunction f = inter.interpolate(xval, yval);\n+\n+        final UnivariateInterpolator interP\n+            = new UnivariatePeriodicInterpolator(new LinearInterpolator(),\n+                                                     period, 1);\n+        final UnivariateFunction fP = interP.interpolate(xval, yval);\n+\n+        // Comparing with original interpolation algorithm.\n+        final double xMin = xval[0];\n+        final double xMax = xval[n - 1];\n+        for (int i = 0; i < n; i++) {\n+            final double x = xMin + (xMax - xMin) * rng.nextDouble();\n+            final double y = f.value(x);\n+            final double yP = fP.value(x);\n+\n+            Assert.assertEquals(\"x=\" + x, y, yP, Math.ulp(1d));\n+        }\n+\n+        // Test interpolation outside the primary interval.\n+        for (int i = 0; i < n; i++) {\n+            final double xIn = offset + rng.nextDouble() * period;\n+            final double xOut = xIn + rng.nextInt(123456789) * period;\n+            final double yIn = fP.value(xIn);\n+            final double yOut = fP.value(xOut);\n+\n+            Assert.assertEquals(yIn, yOut, 1e-7);\n+        }\n+    }\n+\n+    @Test\n+    public void testLessThanOnePeriodCoverage() {\n+        final int n = 30;\n+        final double[] xval = new double[n];\n+        final double[] yval = new double[n];\n+        final double period = 12.3;\n+        final double offset = 45.67;\n+\n+        double delta = period / 2;\n+        for (int i = 0; i < n; i++) {\n+            delta += period / (2 * n) * rng.nextDouble();\n+            xval[i] = offset + delta;\n+            yval[i] = FastMath.sin(xval[i]);\n+        }\n+\n+        final UnivariateInterpolator interP\n+            = new UnivariatePeriodicInterpolator(new LinearInterpolator(),\n+                                                     period, 1);\n+        final UnivariateFunction fP = interP.interpolate(xval, yval);\n+\n+        // Test interpolation outside the sample data interval.\n+        for (int i = 0; i < n; i++) {\n+            final double xIn = offset + rng.nextDouble() * period;\n+            final double xOut = xIn + rng.nextInt(123456789) * period;\n+            final double yIn = fP.value(xIn);\n+            final double yOut = fP.value(xOut);\n+\n+            Assert.assertEquals(yIn, yOut, 1e-7);\n+        }\n+    }\n+\n+    @Test\n+    public void testMoreThanOnePeriodCoverage() {\n+        final int n = 30;\n+        final double[] xval = new double[n];\n+        final double[] yval = new double[n];\n+        final double period = 12.3;\n+        final double offset = 45.67;\n+\n+        double delta = period / 2;\n+        for (int i = 0; i < n; i++) {\n+            delta += 10 * period / n * rng.nextDouble();\n+            xval[i] = offset + delta;\n+            yval[i] = FastMath.sin(xval[i]);\n+        }\n+\n+        final UnivariateInterpolator interP\n+            = new UnivariatePeriodicInterpolator(new LinearInterpolator(),\n+                                                     period, 1);\n+        final UnivariateFunction fP = interP.interpolate(xval, yval);\n+\n+        // Test interpolation outside the sample data interval.\n+        for (int i = 0; i < n; i++) {\n+            final double xIn = offset + rng.nextDouble() * period;\n+            final double xOut = xIn + rng.nextInt(123456789) * period;\n+            final double yIn = fP.value(xIn);\n+            final double yOut = fP.value(xOut);\n+\n+            Assert.assertEquals(yIn, yOut, 1e-6);\n+        }\n+    }\n+\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testTooFewSamples() {\n+        final double[] xval = { 2, 3, 7 };\n+        final double[] yval = { 1, 6, 5 };\n+        final double period = 10;\n+\n+        final UnivariateInterpolator interpolator\n+            = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period);\n+        interpolator.interpolate(xval, yval);\n+    }\n+\n+    @Test(expected=NonMonotonicSequenceException.class)\n+    public void testUnsortedSamples() {\n+        final double[] xval = { 2, 3, 7, 4, 6 };\n+        final double[] yval = { 1, 6, 5, -1, -2 };\n+        final double period = 10;\n+\n+        final UnivariateInterpolator interpolator\n+            = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period);\n+        interpolator.interpolate(xval, yval);\n+    }\n+}", "timestamp": 1328000179, "metainfo": ""}