{"sha": "7ac9b6556ac3e1cc64b99a20b4139214746dfc58", "log": "MATH-887 Renamed \"computeJacobian\" to \"computeWeightedJacobian\" to relect what is actually done. Made \"setCost\" a \"protected\" method (as it should only be modified according to the optimum found by the subclass's algorithm (defined in \"doOptimize()\").   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n      * in the derived class (the {@link LevenbergMarquardtOptimizer\n      * Levenberg-Marquardt optimizer} does this).\n      * @deprecated As of 3.1. To be removed in 4.0. Please use\n-     * {@link #computeJacobian(double[])} instead.\n+     * {@link #computeWeightedJacobian(double[])} instead.\n      */\n     @Deprecated\n     protected double[][] weightedResidualJacobian;\n      *\n      * @throws DimensionMismatchException if the Jacobian dimension does not\n      * match problem dimension.\n-     * @deprecated As of 3.1. Please use {@link #computeJacobian(double[])}\n+     * @deprecated As of 3.1. Please use {@link #computeWeightedJacobian(double[])}\n      * instead.\n      */\n     @Deprecated\n     protected void updateJacobian() {\n-        computeJacobian(point);\n+        computeWeightedJacobian(point);\n     }\n \n     /**\n      * match problem dimension.\n      * @since 3.1\n      */\n-    protected RealMatrix computeJacobian(double[] params) {\n+    protected RealMatrix computeWeightedJacobian(double[] params) {\n         ++jacobianEvaluations;\n \n         final DerivativeStructure[] dsPoint = new DerivativeStructure[params.length];\n      * @param cost Cost value.\n      * @since 3.1\n      */\n-    public void setCost(double cost) {\n+    protected void setCost(double cost) {\n         this.cost = cost;\n     }\n \n     public double[][] computeCovariances(double[] params,\n                                          double threshold) {\n         // Set up the Jacobian.\n-        final RealMatrix j = computeJacobian(params);\n+        final RealMatrix j = computeWeightedJacobian(params);\n \n         // Compute transpose(J)J.\n         final RealMatrix jTj = j.transpose().multiply(j);\n--- a/src/main/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/GaussNewtonOptimizer.java\n             // Value of the objective function at \"currentPoint\".\n             final double[] currentObjective = computeObjectiveValue(currentPoint);\n             final double[] currentResiduals = computeResiduals(currentObjective);\n-            final RealMatrix weightedJacobian = computeJacobian(currentPoint);\n+            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n             current = new PointVectorValuePair(currentPoint, currentObjective);\n \n             // build the linear problem\n--- a/src/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.java\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n-            qrDecomposition(computeJacobian(currentPoint));\n+            qrDecomposition(computeWeightedJacobian(currentPoint));\n \n             weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n             for (int i = 0; i < nR; i++) {", "timestamp": 1352473030, "metainfo": ""}