{"sha": "0df6e2de90497d6b38a1d58b445fa103d6ff1912", "log": "Added fix for MATH-597: Implemented faster generation of random exponential distributed values with algorithm from Ahrens and Dieter (1972): Computer methods for sampling from the exponential and normal distributions. Test case was improved, too.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.ResizableDoubleArray;\n \n /**\n  * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -626730818244969716L;\n \n+    /** Used when generating Exponential samples\n+     * [1] writes:\n+     * One table containing the constants\n+     * q_i = sum_{j=1}^i (ln 2)^j/j! = ln 2 + (ln 2)^2/2 + ... + (ln 2)^i/i!\n+     * until the largest representable fraction below 1 is exceeded.\n+     *\n+     * Note that\n+     * 1 = 2 - 1 = exp(ln 2) - 1 = sum_{n=1}^infty (ln 2)^n / n!\n+     * thus q_i -> 1 as i -> infty,\n+     * so the higher 1, the closer to one we get (the series is not alternating).\n+     *\n+     * By trying, n = 16 in Java is enough to reach 1.0.\n+     */\n+    private static double[] EXPONENTIAL_SA_QI = null;\n+\n     /** underlying random number generator */\n     private RandomGenerator rand = null;\n \n     /** underlying secure random number generator */\n     private SecureRandom secRand = null;\n+\n+    /**\n+     * Initialize tables\n+     */\n+    static {\n+        /**\n+         * Filling EXPONENTIAL_SA_QI table.\n+         * Note that we don't want qi = 0 in the table.\n+         */\n+        final double LN2 = FastMath.log(2);\n+        double qi = 0;\n+        int i = 1;\n+\n+        /**\n+         * MathUtils provides factorials up to 20, so let's use that limit together\n+         * with MathUtils.EPSILON to generate the following code (a priori, we know that\n+         * there will be 16 elements, but instead of hardcoding that, this is\n+         * prettier):\n+         */\n+        final ResizableDoubleArray ra = new ResizableDoubleArray(20);\n+\n+        while (qi < 1) {\n+            qi += FastMath.pow(LN2, i) / MathUtils.factorial(i);\n+            ra.addElement(qi);\n+            ++i;\n+        }\n+\n+        EXPONENTIAL_SA_QI = ra.getElements();\n+    }\n \n     /**\n      * Construct a RandomDataImpl.\n      * Returns a random value from an Exponential distribution with the given\n      * mean.\n      * <p>\n-     * <strong>Algorithm Description</strong>: Uses the <a\n-     * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n-     * Method</a> to generate exponentially distributed random values from\n-     * uniform deviates.\n+     * <strong>Algorithm Description</strong>: Uses the Algorithm SA (Ahrens)\n+     * from p. 876 in:\n+     * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for\n+     * sampling from the exponential and normal distributions.\n+     * Communications of the ACM, 15, 873-882.\n      * </p>\n      *\n      * @param mean the mean of the distribution\n         if (mean <= 0.0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);\n         }\n-        final RandomGenerator generator = getRan();\n-        double unif = generator.nextDouble();\n-        while (unif == 0.0d) {\n-            unif = generator.nextDouble();\n-        }\n-        return -mean * FastMath.log(unif);\n+\n+        // Step 1:\n+        double a = 0;\n+        double u = this.nextUniform(0, 1);\n+\n+        // Step 2 and 3:\n+        while (u < 0.5) {\n+            a += EXPONENTIAL_SA_QI[0];\n+            u *= 2;\n+        }\n+\n+        // Step 4 (now u >= 0.5):\n+        u += u - 1;\n+\n+        // Step 5:\n+        if (u <= EXPONENTIAL_SA_QI[0]) {\n+            return mean * (a + u);\n+        }\n+\n+        // Step 6:\n+        int i = 0; // Should be 1, be we iterate before it in while using 0\n+        double u2 = this.nextUniform(0, 1);\n+        double umin = u2;\n+\n+        // Step 7 and 8:\n+        do {\n+            ++i;\n+            u2 = this.nextUniform(0, 1);\n+\n+            if (u2 < umin) {\n+                umin = u2;\n+            }\n+\n+            // Step 8:\n+        } while (u > EXPONENTIAL_SA_QI[i]); // Ensured to exit since EXPONENTIAL_SA_QI[MAX] = 1\n+\n+        return mean * (a + umin * EXPONENTIAL_SA_QI[0]);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.distribution.BinomialDistributionTest;\n import org.apache.commons.math.distribution.CauchyDistributionImpl;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+import org.apache.commons.math.distribution.ExponentialDistributionImpl;\n import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.distribution.GammaDistributionImpl;\n import org.apache.commons.math.distribution.HypergeometricDistributionImpl;\n \n     @Test\n     public void testNextPoissonConsistency() throws Exception {\n-        \n+\n         // Reseed randomGenerator to get fixed sequence\n-        randomData.reSeed(1000);  \n-        \n+        randomData.reSeed(1000);\n+\n         // Small integral means\n         for (int i = 1; i < 100; i++) {\n             checkNextPoissonConsistency(i);\n \n     /** test failure modes and distribution of nextExponential() */\n     @Test\n-    public void testNextExponential() {\n+    public void testNextExponential() throws Exception {\n         try {\n             randomData.nextExponential(-1);\n             Assert.fail(\"negative mean -- expecting MathIllegalArgumentException\");\n          */\n         Assert.assertEquals(\"exponential cumulative distribution\", (double) cumFreq\n                 / (double) largeSampleSize, 0.8646647167633873, .2);\n+\n+        /**\n+         * Proposal on improving the test of generating exponentials\n+         */\n+        double[] quartiles;\n+        long[] counts;\n+\n+        // Mean 1\n+        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistributionImpl(1));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextExponential(1);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+\n+        // Mean 5\n+        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistributionImpl(5));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextExponential(5);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n \n     /** test reseeding, algorithm/provider games */\n         Assert.fail(\"permutation not found\");\n         return -1;\n     }\n-    \n+\n     @Test\n     public void testNextInversionDeviate() throws Exception {\n         // Set the seed for the default random generator\n         for (int i = 0; i < 10; i++) {\n             double value = randomData.nextInversionDeviate(betaDistribution);\n             Assert.assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);\n-        } \n-    }\n-    \n+        }\n+    }\n+\n     @Test\n     public void testNextBeta() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistributionImpl(2,5));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextCauchy() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistributionImpl(1.2, 2.1));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextChiSquare() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistributionImpl(12));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextF() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new FDistributionImpl(12, 5));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextGamma() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new GammaDistributionImpl(4, 2));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextT() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new TDistributionImpl(10));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextWeibull() throws Exception {\n         double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistributionImpl(1.2, 2.1));\n         }\n         TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n     }\n-    \n+\n     @Test\n     public void testNextBinomial() throws Exception {\n         BinomialDistributionTest testInstance = new BinomialDistributionTest();\n         }\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n-    \n+\n     @Test\n     public void testNextHypergeometric() throws Exception {\n         HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest();\n         }\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n-    \n+\n     @Test\n     public void testNextPascal() throws Exception {\n         PascalDistributionTest testInstance = new PascalDistributionTest();\n         }\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n-    \n+\n     @Test\n     public void testNextZipf() throws Exception {\n         ZipfDistributionTest testInstance = new ZipfDistributionTest();\n         }\n         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n     }\n-    \n+\n }", "timestamp": 1308606168, "metainfo": ""}