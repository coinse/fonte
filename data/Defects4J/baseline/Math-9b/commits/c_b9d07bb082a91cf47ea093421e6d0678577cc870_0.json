{"sha": "b9d07bb082a91cf47ea093421e6d0678577cc870", "log": "Added support for population variance computation.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n \n /**\n- * Computes the (unbiased) sample variance.  Uses the definitional formula: \n+ * Computes the variance of the available values.   By default, the unbiased\n+ * \"sample variance\" definitional formula is used: \n  * <p>\n  * variance = sum((x_i - mean)^2) / (n - 1)\n  * <p>\n  * as described in <a href=\"http://doi.acm.org/10.1145/359146.359152\">\n  * Chan, T. F. andJ. G. Lewis 1979, <i>Communications of the ACM</i>,\n  * vol. 22 no. 9, pp. 526-531.</a>.\n-* <p>\n+ * <p>\n+ * The \"population variance\"  ( sum((x_i - mean)^2) / n ) can also\n+ * be computed using this statistic.  The <code>isBiasCorrected</code>\n+ * property determines whether the \"population\" or \"sample\" value is\n+ * returned by the <code>evaluate</code> and <code>getResult</code> methods.\n+ * To compute population variances, set this property to <code>false.</code>\n+ *\n  * <strong>Note that this implementation is not synchronized.</strong> If \n  * multiple threads access an instance of this class concurrently, and at least\n  * one of the threads invokes the <code>increment()</code> or \n  * <code>clear()</code> method, it must be synchronized externally.\n  * \n- * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ * @version $Revision: 1.2 $ $Date: 2004/10/10 20:40:52 $\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n      * constructed with an external SecondMoment as a parameter.\n      */\n     protected boolean incMoment = true;\n+    \n+    /**\n+     * Determines whether or not bias correction is applied when computing the\n+     * value of the statisic.  True means that bias is corrected.  See \n+     * {@link Variance} for details on the formula.\n+     */\n+    private boolean isBiasCorrected = true;\n \n     /**\n      * Constructs a Variance.\n \n     /**\n      * Constructs a Variance based on an external second moment.\n+     * \n      * @param m2 the SecondMoment (Thrid or Fourth moments work\n      * here as well.)\n      */\n         incMoment = false;\n         this.moment = m2;\n     }\n+    \n+    /**\n+     * Constructs a Variance with the specified <code>isBiasCorrected</code>\n+     * property\n+     * \n+     * @param isBiasCorrected  setting for bias correction - true means\n+     * bias will be corrected and is equivalent to using the argumentless\n+     * constructor\n+     */\n+    public Variance(boolean isBiasCorrected) {\n+        moment = new SecondMoment();\n+        this.isBiasCorrected = isBiasCorrected;\n+    }\n+    \n+    /**\n+     * Constructs a Variance with the specified <code>isBiasCorrected</code>\n+     * property and the supplied external second moment.\n+     * \n+     * @param isBiasCorrected  setting for bias correction - true means\n+     * bias will be corrected and is equivalent to using the argumentless\n+     * constructor\n+     * @param m2 the SecondMoment (Thrid or Fourth moments work\n+     * here as well.)\n+     */\n+    public Variance(boolean isBiasCorrected, SecondMoment m2) {\n+        incMoment = false;\n+        this.moment = m2;\n+        this.isBiasCorrected = isBiasCorrected;      \n+    }\n+   \n     /**\n      * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n      */\n             } else if (moment.n == 1) {\n                 return 0d;\n             } else {\n-                return moment.m2 / ((double) moment.n - 1d);\n+                if (isBiasCorrected) {\n+                    return moment.m2 / ((double) moment.n - 1d);\n+                } else {\n+                    return moment.m2 / ((double) moment.n);\n+                }\n             }\n     }\n \n                     accum += Math.pow((values[i] - mean), 2.0);\n                     accum2 += (values[i] - mean);\n                 }\n-                var = (accum - (Math.pow(accum2, 2) / ((double) length))) /\n-                (double) (length - 1);\n+                if (isBiasCorrected) {\n+                    var = (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                    (double) (length - 1);\n+                } else {\n+                    var = (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                    (double) length;\n+                }\n             }\n         }\n         return var;\n      * <p>\n      * See {@link Variance} for details on the computing algorithm.\n      * <p>\n-     * The formula used assumes that the supplied mean value is the arithmetic\n-     * mean of the sample data, not a known population parameter.  This method\n-     * is supplied only to save computation when the mean has already been\n-     * computed.\n+     * If <code>isBiasCorrected</code> is <code>true</code> the formula used\n+     * assumes that the supplied mean value is the arithmetic mean of the\n+     * sample data, not a known population parameter.  If the mean is a known\n+     * population parameter, or if the \"population\" version of the variance is\n+     * desired, set <code>isBiasCorrected</code> to <code>false</code> before\n+     * invoking this method.\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.\n      * <p>\n         return evaluate(values, mean, 0, values.length);\n     }\n \n+    /**\n+     * @return Returns the isBiasCorrected.\n+     */\n+    public boolean isBiasCorrected() {\n+        return isBiasCorrected;\n+    }\n+\n+    /**\n+     * @param isBiasCorrected The isBiasCorrected to set.\n+     */\n+    public void setBiasCorrected(boolean isBiasCorrected) {\n+        this.isBiasCorrected = isBiasCorrected;\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n  * \n- * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ * @version $Revision: 1.2 $ $Date: 2004/10/10 20:40:52 $\n  */\n public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{\n \n         std.increment(1d);\n         assertEquals(0d, std.getResult(), 0);\n     }\n+    \n+    /**\n+     * Test population version of variance\n+     */ \n+    public void testPopulation() {\n+        double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n+        SecondMoment m = new SecondMoment();\n+        m.evaluate(values);  // side effect is to add values\n+        Variance v1 = new Variance();\n+        v1.setBiasCorrected(false);\n+        assertEquals(populationVariance(values), v1.evaluate(values), 1E-14);\n+        v1.incrementAll(values);\n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);\n+        v1 = new Variance(false, m);\n+        assertEquals(populationVariance(values), v1.getResult(), 1E-14);     \n+    }\n+    \n+    /**\n+     * Definitional formula for population variance\n+     */\n+    protected double populationVariance(double[] v) {\n+        double mean = new Mean().evaluate(v);\n+        double sum = 0;\n+        for (int i = 0; i < v.length; i++) {\n+           sum += (v[i] - mean) * (v[i] - mean); \n+        }\n+        return sum / (double) v.length;\n+    }\n \n }", "timestamp": 1097440852, "metainfo": ""}