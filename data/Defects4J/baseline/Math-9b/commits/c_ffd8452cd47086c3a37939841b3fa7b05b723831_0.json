{"sha": "ffd8452cd47086c3a37939841b3fa7b05b723831", "log": "Javadoc cleanup of linear optimization package.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/AbstractLinearOptimizer.java\n \n /**\n  * Base class for implementing linear optimizers.\n- * <p>This base class handles the boilerplate methods associated to thresholds\n- * settings and iterations counters.</p>\n+ * <p>\n+ * This base class handles the boilerplate methods associated to thresholds\n+ * settings and iterations counters.\n+ *\n  * @version $Id$\n  * @since 2.0\n- *\n  */\n public abstract class AbstractLinearOptimizer implements LinearOptimizer {\n \n     /** Number of iterations already performed. */\n     private int iterations;\n \n-    /** Simple constructor with default settings.\n+    /**\n+     * Simple constructor with default settings.\n      * <p>The maximal number of evaluation is set to its default value.</p>\n      */\n     protected AbstractLinearOptimizer() {\n         return iterations;\n     }\n \n-    /** Increment the iterations counter by 1.\n-     * @exception MaxCountExceededException if the maximal number\n-     * of iterations is exceeded\n+    /**\n+     * Increment the iterations counter by 1.\n+     * @exception MaxCountExceededException if the maximal number of iterations is exceeded\n      */\n     protected void incrementIterationsCounter()\n         throws MaxCountExceededException {\n \n     /** {@inheritDoc} */\n     public PointValuePair optimize(final LinearObjectiveFunction f,\n-                                       final Collection<LinearConstraint> constraints,\n-                                       final GoalType goalType, final boolean restrictToNonNegative)\n-         throws MathIllegalStateException {\n+                                   final Collection<LinearConstraint> constraints,\n+                                   final GoalType goalType, final boolean restrictToNonNegative)\n+        throws MathIllegalStateException {\n \n         // store linear problem characteristics\n         this.function          = f;\n \n     }\n \n-    /** Perform the bulk of optimization algorithm.\n+    /**\n+     * Perform the bulk of optimization algorithm.\n      * @return the point/value pair giving the optimal value for objective function\n      * @exception MathIllegalStateException if no solution fulfilling the constraints\n      * can be found in the allowed number of iterations\n      */\n-    protected abstract PointValuePair doOptimize()\n-        throws MathIllegalStateException;\n+    protected abstract PointValuePair doOptimize() throws MathIllegalStateException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/LinearConstraint.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/LinearConstraint.java\n         return value;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object other) {\n \n       return false;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n         return relationship.hashCode() ^\n                coefficients.hashCode();\n     }\n \n-    /** Serialize the instance.\n+    /**\n+     * Serialize the instance.\n      * @param oos stream where object should be written\n      * @throws IOException if object cannot be written to stream\n      */\n         MatrixUtils.serializeRealVector(coefficients, oos);\n     }\n \n-    /** Deserialize the instance.\n+    /**\n+     * Deserialize the instance.\n      * @param ois stream from which the object should be read\n      * @throws ClassNotFoundException if a class in the stream cannot be found\n      * @throws IOException if object cannot be read from the stream\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/LinearObjectiveFunction.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/LinearObjectiveFunction.java\n         return coefficients.dotProduct(point) + constantTerm;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object other) {\n \n       return false;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n         return Double.valueOf(constantTerm).hashCode() ^ coefficients.hashCode();\n     }\n \n-    /** Serialize the instance.\n+    /**\n+     * Serialize the instance.\n      * @param oos stream where object should be written\n      * @throws IOException if object cannot be written to stream\n      */\n         MatrixUtils.serializeRealVector(coefficients, oos);\n     }\n \n-    /** Deserialize the instance.\n+    /**\n+     * Deserialize the instance.\n      * @param ois stream from which the object should be read\n      * @throws ClassNotFoundException if a class in the stream cannot be found\n      * @throws IOException if object cannot be read from the stream\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/LinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/LinearOptimizer.java\n  */\n public interface LinearOptimizer {\n \n-    /** Set the maximal number of iterations of the algorithm.\n+    /**\n+     * Set the maximal number of iterations of the algorithm.\n      * @param maxIterations maximal number of function calls\n      */\n     void setMaxIterations(int maxIterations);\n \n-    /** Get the maximal number of iterations of the algorithm.\n+    /**\n+     * Get the maximal number of iterations of the algorithm.\n      * @return maximal number of iterations\n      */\n     int getMaxIterations();\n \n-    /** Get the number of iterations realized by the algorithm.\n+    /**\n+     * Get the number of iterations realized by the algorithm.\n      * <p>\n      * The number of evaluations corresponds to the last call to the\n      * {@link #optimize(LinearObjectiveFunction, Collection, GoalType, boolean) optimize}\n      */\n     int getIterations();\n \n-    /** Optimizes an objective function.\n+    /**\n+     * Optimizes an objective function.\n      * @param f linear objective function\n      * @param constraints linear constraints\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n      * @return point/value pair giving the optimal value for objective function\n      * @exception MathIllegalStateException if no solution fulfilling the constraints\n-     * can be found in the allowed number of iterations\n+     *   can be found in the allowed number of iterations\n      */\n    PointValuePair optimize(LinearObjectiveFunction f, Collection<LinearConstraint> constraints,\n-                               GoalType goalType, boolean restrictToNonNegative)\n-        throws MathIllegalStateException;\n+                               GoalType goalType, boolean restrictToNonNegative) throws MathIllegalStateException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/NoFeasibleSolutionException.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/NoFeasibleSolutionException.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n- * This class represents exceptions thrown by optimizers when no solution\n- * fulfills the constraints.\n+ * This class represents exceptions thrown by optimizers when no solution fulfills the constraints.\n+ *\n  * @version $Id$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/Relationship.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/Relationship.java\n         this.stringValue = stringValue;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public String toString() {\n         return stringValue;\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n \n /**\n  * Solves a linear problem using the Two-Phase Simplex Method.\n+ *\n  * @version $Id$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n      * @param constraints linear constraints\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n      * @param epsilon amount of error to accept when checking for optimality\n      */\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n      * @param constraints linear constraints\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n      * @param epsilon amount of error to accept when checking for optimality\n      * @param maxUlps amount of error to accept in floating point comparisons\n \n     /**\n      * Get the current solution.\n-     *\n      * @return current solution\n      */\n     protected PointValuePair getSolution() {\n      * Subtracts a multiple of one row from another.\n      * <p>\n      * After application of this operation, the following will hold:\n-     *   minuendRow = minuendRow - multiple * subtrahendRow\n-     * </p>\n+     * <pre>minuendRow = minuendRow - multiple * subtrahendRow</pre>\n+     *\n      * @param dividendRow index of the row\n      * @param divisor value of the divisor\n      */\n      * Subtracts a multiple of one row from another.\n      * <p>\n      * After application of this operation, the following will hold:\n-     *   minuendRow = minuendRow - multiple * subtrahendRow\n-     * </p>\n+     * <pre>minuendRow = minuendRow - multiple * subtrahendRow</pre>\n+     *\n      * @param minuendRow row index\n      * @param subtrahendRow row index\n      * @param multiple multiplication factor\n         return tableau.getRowDimension();\n     }\n \n-    /** Get an entry of the tableau.\n+    /**\n+     * Get an entry of the tableau.\n      * @param row row index\n      * @param column column index\n      * @return entry at (row, column)\n         return tableau.getEntry(row, column);\n     }\n \n-    /** Set an entry of the tableau.\n+    /**\n+     * Set an entry of the tableau.\n      * @param row row index\n      * @param column column index\n      * @param value for the entry\n     /**\n      * Get the number of decision variables.\n      * <p>\n-     * If variables are not restricted to positive values, this will include 1\n-     * extra decision variable to represent the absolute value of the most\n-     * negative variable.\n-     * </p>\n+     * If variables are not restricted to positive values, this will include 1 extra decision variable to represent\n+     * the absolute value of the most negative variable.\n+     *\n      * @return number of decision variables\n      * @see #getOriginalNumDecisionVariables()\n      */\n         return tableau.getData();\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object other) {\n \n       return false;\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n         return Boolean.valueOf(restrictToNonNegative).hashCode() ^\n                tableau.hashCode();\n     }\n \n-    /** Serialize the instance.\n+    /**\n+     * Serialize the instance.\n      * @param oos stream where object should be written\n      * @throws IOException if object cannot be written to stream\n      */\n         MatrixUtils.serializeRealMatrix(tableau, oos);\n     }\n \n-    /** Deserialize the instance.\n+    /**\n+     * Deserialize the instance.\n      * @param ois stream from which the object should be read\n      * @throws ClassNotFoundException if a class in the stream cannot be found\n      * @throws IOException if object cannot be read from the stream\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/UnboundedSolutionException.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/UnboundedSolutionException.java\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n- * This class represents exceptions thrown by optimizers when a solution\n- * escapes to infinity.\n+ * This class represents exceptions thrown by optimizers when a solution escapes to infinity.\n+ *\n  * @version $Id$\n  * @since 2.0\n  */", "timestamp": 1347812395, "metainfo": ""}