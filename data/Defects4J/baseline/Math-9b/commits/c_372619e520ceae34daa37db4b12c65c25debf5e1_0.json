{"sha": "372619e520ceae34daa37db4b12c65c25debf5e1", "log": "added interfaces for eigen decomposition and for singular value decomposition the implementation for this interfaces is not ready yet, but it seems important to show what the interface will look like. JIRA: MATH-220  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n /**\n  * A base interface to decomposition algorithms that can solve A &times; X = B.\n  * <p>This interface is the common base of decomposition algorithms like\n- * {@link QRDecomposition}, {@link LUDecomposition} or {@link\n- * SingularValueDecomposition}. All these algorithms decompose an A matrix has a\n- * product of several specific matrices from which they can solve A &times; X = B\n- * in least squares sense: they find X such that ||A &times; X - B|| is minimal.</p>\n+ * {@link QRDecomposition}, {@link LUDecomposition}, {@link\n+ * SingularValueDecomposition} or {@link EigenDecomposition}. All these\n+ * algorithms decompose an A matrix has a product of several specific matrices\n+ * from which they can solve A &times; X = B in least squares sense: they find X\n+ * such that ||A &times; X - B|| is minimal.</p>\n  * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n  * square matrices and when the solution is an exact linear solution, i.e. when\n  * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * eigen decomposition of a real symmetric matrix.\n+ * <p>The eigen decomposition of matrix A is a set of two matrices:\n+ * V and D such that A = V &times; D &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then V is an m &times; m orthogonal matrix\n+ * and D is a m &times; n diagonal matrix.</p>\n+ * <p>This interface is similar in spirit to the <code>EigenvalueDecomposition</code>\n+ * class from the now defunct <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a>\n+ * library, with the following changes:</p>\n+ * <ul>\n+ *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n+ *   method has been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n+ *   been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n+ *   added (in the superinterface),</li>\n+ *   <li>a {@link #getVt() getVt} method has been added,</li>\n+ *   <li>the <code>getRealEigenvalues</code> method has been renamed as {@link\n+ *   #getEigenValues() getEigenValues},</li>\n+ *   <li>the <code>getImagEigenvalues</code> method has been removed</li>\n+ * </ul>\n+ * @see <a href=\"http://mathworld.wolfram.com/EigenDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface EigenDecomposition extends DecompositionSolver {\n+\n+    /**\n+     * Returns the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n+     * @return the V matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getV() throws IllegalStateException;\n+\n+    /**\n+     * Returns the diagonal matrix D of the decomposition. \n+     * <p>D is a diagonal matrix.</p>\n+     * <p>The values on the diagonal are the eigenvalues of the original matrix.</p>\n+     * @return the D matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getEigenValues()\n+     */\n+    RealMatrix getD() throws IllegalStateException;\n+\n+    /**\n+     * Returns the transpose of the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n+     * @return the transpose of the V matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getVt() throws IllegalStateException;\n+\n+    /**\n+     * Returns the eigenvalues of the original matrix.\n+     * @return eigenvalues of the original matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getD()\n+     */\n+    double[] getEigenValues() throws IllegalStateException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * Singular Value Decomposition of a real matrix.\n+ * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n+ * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then U is an m &times; m orthogonal matrix,\n+ * &Sigma; is a m &times; n diagonal matrix with positive diagonal elements,\n+ * and V is an n &times; n orthogonal matrix.</p>\n+ * <p>This interface is similar to the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n+ *   method has been added (in the superinterface),</li>\n+ *   <li>a {@link #decompose(RealMatrix, int) decompose(RealMatrix), int)} method\n+ *   has been added,</li>\n+ *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n+ *   been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n+ *   added (in the superinterface),</li>\n+ *   <li>the <code>norm2</code> method which has been renamed as {@link #getNorm()\n+ *   getNorm},</li>\n+ *   <li>the <code>cond</code> method which has been renamed as {@link\n+ *   #getConditionNumber() getConditionNumber},</li>\n+ *   <li>the <code>rank</code> method which has been renamed as {@link #getRank()\n+ *   getRank}</li>\n+ * </ul>\n+ * @see <a href=\"http://mathworld.wolfram.com/SingularValueDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Singular_value_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface SingularValueDecomposition extends DecompositionSolver {\n+\n+    /**\n+     * Decompose a matrix to find its largest singular values.\n+     * @param matrix\n+     * @param maxSingularValues maximal number of singular values to compute\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    void decompose(RealMatrix matrix, int maxSingularValues)\n+      throws InvalidMatrixException;\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    RealMatrix getU() throws IllegalStateException;\n+\n+    /**\n+     * Returns the diagonal matrix &Sigma; of the decomposition. \n+     * <p>&Sigma; is a diagonal matrix.</p>\n+     * @return the &Sigma; matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    RealMatrix getS() throws IllegalStateException;\n+\n+    /**\n+     * Returns the diagonal elements of the matrix &Sigma; of the decomposition. \n+     * @return the diagonal elements of the &Sigma; matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    double[] getSingularValues() throws IllegalStateException;\n+\n+    /**\n+     * Returns the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    RealMatrix getV() throws IllegalStateException;\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the matrix.\n+     * <p>The L<sub>2</sub> norm is max(|A &times; u|<sub>2</sub> /\n+     * |u|<sub>2</sub>), where |.|<sub>2</sub> denotes the vectorial 2-norm\n+     * (i.e. the traditional euclidian norm).</p>\n+     * @return norm\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    double getNorm() throws IllegalStateException;\n+\n+    /**\n+     * Return the condition number of the matrix.\n+     * @return condition number of the matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    double getConditionNumber() throws IllegalStateException;\n+\n+    /**\n+     * Return the effective numerical matrix rank.\n+     * <p>The effective numerical rank is the number of non-negligible\n+     * singular values. The threshold used to identify non-negligible\n+     * terms is max(m,n) &times; ulp(s<sub>1</sub>) where ulp(s<sub>1</sub>)\n+     * is the least significant bit of the largest singular value.</p>\n+     * @return effective numerical matrix rank\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    int getRank() throws IllegalStateException;\n+\n+}", "timestamp": 1222787357, "metainfo": ""}