{"sha": "31b83843dd1661425e4b6785cc6a995a20aa6c54", "log": "MATH-653 Removed methods taking a \"double[]\" argument.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n \n     /**\n      * Construct a vector from an array.\n-     * @param d array of Doubles.\n+     *\n+     * @param d Array of {@code Double}s.\n      */\n     public ArrayRealVector(Double[] d) {\n         data = new double[d.length];\n     @Override\n     public ArrayRealVector add(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return add(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            final int dim = vData.length;\n+            checkVectorDimensions(dim);\n+            ArrayRealVector result = new ArrayRealVector(dim);\n+            double[] resultData = result.data;\n+            for (int i = 0; i < dim; i++) {\n+                resultData[i] = data[i] + vData[i];\n+            }\n+            return result;\n         } else {\n             checkVectorDimensions(v);\n             double[] out = data.clone();\n         }\n     }\n \n-    /**\n-     * Compute the sum of this vector and {@code v}.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param v Vector to be added.\n-     * @return {@code this} + {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public ArrayRealVector add(double[] v) {\n-        final int dim = v.length;\n-        checkVectorDimensions(dim);\n-        ArrayRealVector result = new ArrayRealVector(dim);\n-        double[] resultData = result.data;\n-        for (int i = 0; i < dim; i++) {\n-            resultData[i] = data[i] + v[i];\n-        }\n-        return result;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public ArrayRealVector subtract(RealVector v) {\n-        if (v instanceof ArrayRealVector) {\n-            return subtract(((ArrayRealVector) v).data);\n+        if (v instanceof ArrayRealVector) { \n+            final double[] vData = ((ArrayRealVector) v).data;\n+            final int dim = vData.length;\n+            checkVectorDimensions(dim);\n+            ArrayRealVector result = new ArrayRealVector(dim);\n+            double[] resultData = result.data;\n+            for (int i = 0; i < dim; i++) {\n+                resultData[i] = data[i] - vData[i];\n+            }\n+            return result;\n         } else {\n             checkVectorDimensions(v);\n             double[] out = data.clone();\n         }\n     }\n \n-    /**\n-     * Subtract {@code v} from this vector.\n-     * Returns a new vector. Does not change instance data.\n-     *\n-     * @param v Vector to be subtracted.\n-     * @return {@code this} - {@code v}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code v} is not the same size as this vector.\n-     */\n-    public ArrayRealVector subtract(double[] v) {\n-        final int dim = v.length;\n-        checkVectorDimensions(dim);\n-        ArrayRealVector result = new ArrayRealVector(dim);\n-        double[] resultData = result.data;\n-        for (int i = 0; i < dim; i++) {\n-            resultData[i] = data[i] - v[i];\n-        }\n-        return result;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public ArrayRealVector map(UnivariateRealFunction function) {\n     @Override\n     public ArrayRealVector ebeMultiply(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return ebeMultiply(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            final int dim = vData.length;\n+            checkVectorDimensions(dim);\n+            ArrayRealVector result = new ArrayRealVector(dim);\n+            double[] resultData = result.data;\n+            for (int i = 0; i < dim; i++) {\n+                resultData[i] = data[i] * vData[i];\n+            }\n+            return result;\n         } else {\n             checkVectorDimensions(v);\n             double[] out = data.clone();\n         }\n     }\n \n-    /**\n-     * Element-by-element multiplication.\n-     *\n-     * @param v Vector by which instance elements must be multiplied.\n-     * @return a Vector containing {@code this[i] * v[i]} for all {@code i}.\n-     * @throws DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public ArrayRealVector ebeMultiply(double[] v) {\n-        final int dim = v.length;\n-        checkVectorDimensions(dim);\n-        ArrayRealVector result = new ArrayRealVector(dim);\n-        double[] resultData = result.data;\n-        for (int i = 0; i < dim; i++) {\n-            resultData[i] = data[i] * v[i];\n-        }\n-        return result;\n-    }\n-\n     /** {@inheritDoc} */\n     public ArrayRealVector ebeDivide(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return ebeDivide(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            final int dim = vData.length;\n+            checkVectorDimensions(dim);\n+            ArrayRealVector result = new ArrayRealVector(dim);\n+            double[] resultData = result.data;\n+            for (int i = 0; i < dim; i++) {\n+                resultData[i] = data[i] / vData[i];\n+            }\n+            return result;\n         } else {\n             checkVectorDimensions(v);\n             double[] out = data.clone();\n         }\n     }\n \n-    /**\n-     * Element-by-element division.\n-     *\n-     * @param v Vector by which instance elements must be divided.\n-     * @return a vector containing {@code this[i] / v[i]} for all {@code i}.\n-     * @exception DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public ArrayRealVector ebeDivide(double[] v) {\n-        final int dim = v.length;\n-        checkVectorDimensions(dim);\n-        ArrayRealVector result = new ArrayRealVector(dim);\n-        double[] resultData = result.data;\n-        for (int i = 0; i < dim; i++) {\n-            resultData[i] = data[i] / v[i];\n-        }\n-        return result;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public double[] getData() {\n     @Override\n     public double dotProduct(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return dotProduct(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            checkVectorDimensions(vData.length);\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * vData[i];\n+            }\n+            return dot;\n         } else {\n             checkVectorDimensions(v);\n             double dot = 0;\n         }\n     }\n \n-    /**\n-     * Compute the dot product.\n-     *\n-     * @param v Vector with which dot product should be computed\n-     * @return the scalar dot product between instance and {@code v}.\n-     * @throws DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public double dotProduct(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double dot = 0;\n-        for (int i = 0; i < data.length; i++) {\n-            dot += data[i] * v[i];\n-        }\n-        return dot;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public double getNorm() {\n     @Override\n     public double getDistance(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return getDistance(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            checkVectorDimensions(vData.length);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - vData[i];\n+                sum += delta * delta;\n+            }\n+            return FastMath.sqrt(sum);\n         } else {\n             checkVectorDimensions(v);\n             double sum = 0;\n         }\n     }\n \n-    /**\n-     * Distance between two vectors.\n-     * This method computes the distance consistent with the\n-     * L<sub>2</sub> norm, i.e. the square root of the sum of\n-     * elements differences, or euclidian distance.\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @throws DimensionMismatchException if {@code v} is not the same size as\n-     * this vector.\n-     * @see #getDistance(RealVector)\n-     * @see #getNorm()\n-     */\n-    public double getDistance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double sum = 0;\n-        for (int i = 0; i < data.length; ++i) {\n-            final double delta = data[i] - v[i];\n-            sum += delta * delta;\n-        }\n-        return FastMath.sqrt(sum);\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public double getL1Distance(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return getL1Distance(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            checkVectorDimensions(vData.length);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - vData[i];\n+                sum += FastMath.abs(delta);\n+            }\n+            return sum;\n         } else {\n             checkVectorDimensions(v);\n             double sum = 0;\n         }\n     }\n \n-    /**\n-     * Distance between two vectors.\n-     * This method computes the distance consistent with\n-     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n-     * elements differences.\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @throws DimensionMismatchException if {@code v} is not the same size\n-     * as this vector.\n-     * @see #getDistance(RealVector)\n-     * @see #getNorm()\n-     */\n-    public double getL1Distance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double sum = 0;\n-        for (int i = 0; i < data.length; ++i) {\n-            final double delta = data[i] - v[i];\n-            sum += FastMath.abs(delta);\n-        }\n-        return sum;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public double getLInfDistance(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return getLInfDistance(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            checkVectorDimensions(vData.length);\n+            double max = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - vData[i];\n+                max = FastMath.max(max, FastMath.abs(delta));\n+            }\n+            return max;\n         } else {\n             checkVectorDimensions(v);\n             double max = 0;\n         }\n     }\n \n-    /**\n-     * Distance between two vectors.\n-     * This method computes the distance consistent with\n-     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n-     * elements differences.\n-     *\n-     * @param v Vector to which distance is requested.\n-     * @return the distance between two vectors.\n-     * @exception IllegalArgumentException if {@code v} is not the same size as this\n-     * @see #getDistance(RealVector)\n-     * @see #getNorm()\n-     */\n-    public double getLInfDistance(double[] v) {\n-        checkVectorDimensions(v.length);\n-        double max = 0;\n-        for (int i = 0; i < data.length; ++i) {\n-            final double delta = data[i] - v[i];\n-            max = FastMath.max(max, FastMath.abs(delta));\n-        }\n-        return max;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public RealVector unitVector() {\n     @Override\n     public RealMatrix outerProduct(RealVector v) {\n         if (v instanceof ArrayRealVector) {\n-            return outerProduct(((ArrayRealVector) v).data);\n+            final double[] vData = ((ArrayRealVector) v).data;\n+            final int m = data.length;\n+            final int n = vData.length;\n+            final RealMatrix out = MatrixUtils.createRealMatrix(m, n);\n+            for (int i = 0; i < m; i++) {\n+                for (int j = 0; j < n; j++) {\n+                    out.setEntry(i, j, data[i] * vData[j]);\n+                }\n+            }\n+            return out;\n         } else {\n             final int m = data.length;\n             final int n = v.getDimension();\n         }\n     }\n \n-    /**\n-     * Compute the outer product.\n-     * @param v Vector with which outer product should be computed.\n-     * @return the square matrix outer product between this instance and {@code v}.\n-     * @throws DimensionMismatchException if {@code v} is not the same\n-     * size as this vector.\n-     */\n-    public RealMatrix outerProduct(double[] v) {\n-        final int m = data.length;\n-        final int n = v.length;\n-        final RealMatrix out = MatrixUtils.createRealMatrix(m, n);\n-        for (int i = 0; i < m; i++) {\n-            for (int j = 0; j < n; j++) {\n-                out.setEntry(i, j, data[i] * v[j]);\n-            }\n-        }\n-        return out;\n-    }\n-\n     /** {@inheritDoc} */\n     public double getEntry(int index) {\n         return data[index];\n         return MathUtils.hash(data);\n     }\n \n-    /**\n-     * Updates {@code this} with the linear combination of {@code this} and\n-     * {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return {@code this}, with components equal to\n-     * {@code a * this[i] + b * y[i]} for all {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    public ArrayRealVector combine(double a, double b, double[] y) {\n-        return copy().combineToSelf(a, b, y);\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public ArrayRealVector combine(double a, double b, RealVector y) {\n         return copy().combineToSelf(a, b, y);\n     }\n \n-    /**\n-     * Updates {@code this} with the linear combination of {@code this} and\n-     * {@code y}.\n-     *\n-     * @param a Weight of {@code this}.\n-     * @param b Weight of {@code y}.\n-     * @param y Vector with which {@code this} is linearly combined.\n-     * @return {@code this}, with components equal to\n-     * {@code a * this[i] + b * y[i]} for all {@code i}.\n-     * @throws org.apache.commons.math.exception.DimensionMismatchException\n-     * if {@code y} is not the same size as this vector.\n-     */\n-    public ArrayRealVector combineToSelf(double a, double b, double[] y) {\n-        checkVectorDimensions(y.length);\n-        for (int i = 0; i < this.data.length; i++) {\n-            data[i] = a * data[i] + b * y[i];\n-        }\n-        return this;\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public ArrayRealVector combineToSelf(double a, double b, RealVector y) {\n         if (y instanceof ArrayRealVector) {\n-            return combineToSelf(a, b, ((ArrayRealVector) y).data);\n+            final double[] yData = ((ArrayRealVector) y).data;\n+            checkVectorDimensions(yData.length);\n+            for (int i = 0; i < this.data.length; i++) {\n+                data[i] = a * data[i] + b * yData[i];\n+            }\n         } else {\n             checkVectorDimensions(y);\n             for (int i = 0; i < this.data.length; i++) {\n                 data[i] = a * data[i] + b * y.getEntry(i);\n             }\n-            return this;\n-        }\n+        }\n+        return this;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n             }\n \n             final double[] bp = new double[m];\n+            final ArrayRealVector bVector = new ArrayRealVector(b, false);\n             for (int i = 0; i < m; ++i) {\n                 final ArrayRealVector v = eigenvectors[i];\n                 final double[] vData = v.getDataRef();\n-                final double s = v.dotProduct(b) / realEigenvalues[i];\n+                final double s = v.dotProduct(bVector) / realEigenvalues[i];\n                 for (int j = 0; j < m; ++j) {\n                     bp[j] += s * vData[j];\n                 }\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n     }\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void testCombinePreconditionArray() {\n-        final double a = 1d;\n-        final double b = 2d;\n-        double[] aux = new double[] { 3d, 4d, 5d };\n-        final ArrayRealVector x = new ArrayRealVector(aux, false);\n-        final double[] y = new double[] { 6d, 7d };\n-        x.combine(a, b, y);\n-    }\n-\n-    @Test\n-    public void testCombineArray() {\n-        final Random random = new Random(20110726);\n-        final int dim = 10;\n-        final double a = (2 * random.nextDouble() - 1);\n-        final double b = (2 * random.nextDouble() - 1);\n-        final ArrayRealVector x = new ArrayRealVector(dim);\n-        final double[] y = new double[dim];\n-        final double[] expected = new double[dim];\n-        for (int i = 0; i < dim; i++) {\n-            final double xi = 2 * random.nextDouble() - 1;\n-            final double yi = 2 * random.nextDouble() - 1;\n-            x.setEntry(i, xi);\n-            y[i] = yi;\n-            expected[i] = a * xi + b * yi;\n-        }\n-        final double[] actual = x.combine(a, b, y).getData();\n-        for (int i = 0; i < dim; i++) {\n-            final double delta;\n-            if (expected[i] == 0d) {\n-                delta = Math.ulp(1d);\n-            } else {\n-                delta = Math.ulp(expected[i]);\n-            }\n-            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n-                                expected[i],\n-                                actual[i],\n-                                delta);\n-        }\n-    }\n-\n-    @Test(expected=DimensionMismatchException.class)\n     public void testCombinePreconditionSameType() {\n         final double a = 1d;\n         final double b = 2d;\n     }\n \n     @Test(expected=DimensionMismatchException.class)\n-    public void testCombineToSelfPreconditionArray() {\n-        final double a = 1d;\n-        final double b = 2d;\n-        double[] aux = new double[] { 3d, 4d, 5d };\n-        final ArrayRealVector x = new ArrayRealVector(aux, false);\n-        final double[] y = new double[] { 6d, 7d };\n-        x.combineToSelf(a, b, y);\n-    }\n-\n-    @Test\n-    public void testCombineToSelfArray() {\n-        final Random random = new Random(20110726);\n-        final int dim = 10;\n-        final double a = (2 * random.nextDouble() - 1);\n-        final double b = (2 * random.nextDouble() - 1);\n-        final ArrayRealVector x = new ArrayRealVector(dim);\n-        final double[] y = new double[dim];\n-        final double[] expected = new double[dim];\n-        for (int i = 0; i < dim; i++) {\n-            final double xi = 2 * random.nextDouble() - 1;\n-            final double yi = 2 * random.nextDouble() - 1;\n-            x.setEntry(i, xi);\n-            y[i] = yi;\n-            expected[i] = a * xi + b * yi;\n-        }\n-        Assert.assertSame(x, x.combineToSelf(a, b, y));\n-        final double[] actual = x.getData();\n-        for (int i = 0; i < dim; i++) {\n-            final double delta;\n-            if (expected[i] == 0d) {\n-                delta = Math.ulp(1d);\n-            } else {\n-                delta = Math.ulp(expected[i]);\n-            }\n-            Assert.assertEquals(\"elements [\" + i + \"] differ\",\n-                                expected[i],\n-                                actual[i],\n-                                delta);\n-        }\n-    }\n-\n-    @Test(expected=DimensionMismatchException.class)\n     public void testCombineToSelfPreconditionSameType() {\n         final double a = 1d;\n         final double b = 2d;", "timestamp": 1314625762, "metainfo": ""}