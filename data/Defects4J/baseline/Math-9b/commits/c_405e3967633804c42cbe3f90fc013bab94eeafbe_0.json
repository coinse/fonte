{"sha": "405e3967633804c42cbe3f90fc013bab94eeafbe", "log": "MATH-361 MATH-382   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolatingFunction.java\n \n import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.DimensionMismatchException;\n import org.apache.commons.math.analysis.BivariateRealFunction;\n      * every grid point.\n      * @throws DimensionMismatchException if the various arrays do not contain\n      * the expected number of elements.\n-     * @throws IllegalArgumentException if {@code x} or {@code y} are not strictly\n+     * @throws NonMonotonousSequenceException if {@code x} or {@code y} are not strictly\n      * increasing.\n+     * @throws NoDataException if any of the arrays has zero length.\n      */\n     public BicubicSplineInterpolatingFunction(double[] x,\n                                               double[] y,\n         final int yLen = y.length;\n \n         if (xLen == 0 || yLen == 0 || f.length == 0 || f[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xLen != f.length) {\n             throw new DimensionMismatchException(xLen, f.length);\n     public double value(double x, double y) {\n         final int i = searchIndex(x, xval);\n         if (i == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  x, xval[0], xval[xval.length - 1]);\n+            throw new OutOfRangeException(x, xval[0], xval[xval.length - 1]);\n         }\n         final int j = searchIndex(y, yval);\n         if (j == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                  y, yval[0], yval[yval.length - 1]);\n+            throw new OutOfRangeException(y, yval[0], yval[yval.length - 1]);\n         }\n \n         final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n \n         final int i = searchIndex(x, xval);\n         if (i == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      x, xval[0], xval[xval.length - 1]);\n+            throw new OutOfRangeException(x, xval[0], xval[xval.length - 1]);\n         }\n         final int j = searchIndex(y, yval);\n         if (j == -1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      y, yval[0], yval[yval.length - 1]);\n+            throw new OutOfRangeException(y, yval[0], yval[yval.length - 1]);\n         }\n \n         final double xN = (x - xval[i]) / (xval[i + 1] - xval[i]);\n      */\n     public double value(double x, double y) {\n         if (x < 0 || x > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      x, 0, 1);\n+            throw new OutOfRangeException(x, 0, 1);\n         }\n         if (y < 0 || y > 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.OUT_OF_RANGE_SIMPLE,\n-                                                                      y, 0, 1);\n+            throw new OutOfRangeException(y, 0, 1);\n         }\n \n         final double x2 = x * x;\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/BicubicSplineInterpolator.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n                                                           final double[][] fval)\n         throws MathException, IllegalArgumentException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n         if (xval.length != fval.length) {\n             throw new DimensionMismatchException(xval.length, fval.length);\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LinearInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Implements a linear function for interpolation of real univariate functions.\n      * @param x the arguments for the interpolation points\n      * @param y the values for the interpolation points\n      * @return a function which interpolates the data set\n-    */\n+     * @throws DimensionMismatchException if {@code x} and {@code y}\n+     * have different sizes.\n+     * @throws NonMonotonousSequenceException if {@code x} is not sorted in\n+     * strict increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is smaller\n+     * than 2.\n+     */\n     public PolynomialSplineFunction interpolate(double x[], double y[]) {\n         if (x.length != y.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n+            throw new DimensionMismatchException(x.length, y.length);\n         }\n \n         if (x.length < 2) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length);\n+            throw new NumberIsTooSmallException(x.length, 2, true);\n         }\n \n         // Number of intervals.  The number of data points is n + 1.\n         int n = x.length - 1;\n \n-        for (int i = 0; i < n; i++) {\n-            if (x[i] >= x[i + 1]) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n-                i, i+1, x[i], x[i+1]);\n-            }\n-        }\n+        MathUtils.checkOrder(x);\n \n         // Slope of the lines between the datapoints.\n         final double m[] = new double[n];\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n import java.util.Map;\n \n import org.apache.commons.math.DimensionMismatchException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.linear.ArrayRealVector;\n import org.apache.commons.math.linear.RealVector;\n      * {@code xval} (equal to {@code n}, the number of interpolation points)\n      * do not match, or the the arrays {@code xval[0]} ... {@code xval[n]},\n      * have lengths different from {@code dimension}.\n-     * @throws IllegalArgumentException if there are no data (xval null or zero length)\n+     * @throws NoDataException if there are no data (xval null or zero length)\n      */\n     public MicrosphereInterpolatingFunction(double[][] xval,\n                                             double[] yval,\n                                             UnitSphereRandomVectorGenerator rand)\n         throws DimensionMismatchException, IllegalArgumentException {\n         if (xval.length == 0 || xval[0] == null) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NO_DATA);\n+            throw new NoDataException();\n         }\n \n         if (xval.length != yval.length) {\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolator.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.UnitSphereRandomVectorGenerator;\n import org.apache.commons.math.util.LocalizedFormats;\n /**\n  * Interpolator that implements the algorithm described in\n  * <em>William Dudziak</em>'s\n- * <a href=\"http://www.dudziak.com/microsphere.pdf\">MS thesis</a>\n+ * <a href=\"http://www.dudziak.com/microsphere.pdf\">MS thesis</a>.\n  * @since 2.1\n  *\n  * @version $Revision$ $Date$\n      * #MicrosphereInterpolator(int, int)\n      * MicrosphereInterpolator(MicrosphereInterpolator.DEFAULT_MICROSPHERE_ELEMENTS,\n      * MicrosphereInterpolator.DEFAULT_BRIGHTNESS_EXPONENT)}.</p>\n-     * weights of the sample data\n      */\n     public MicrosphereInterpolator() {\n         this(DEFAULT_MICROSPHERE_ELEMENTS, DEFAULT_BRIGHTNESS_EXPONENT);\n     }\n \n     /** Create a microsphere interpolator.\n-     * @param microsphereElements number of surface elements of the microsphere\n+     * @param microsphereElements number of surface elements of the microsphere.\n      * @param brightnessExponent exponent used in the power law that computes the\n-     * weights of the sample data\n-     * @throws IllegalArgumentException if {@code microsphereElements <= 0}\n-     * or {@code brightnessExponent < 0}\n+     * weights of the sample data.\n+     * @throws NotPositiveException if {@code microsphereElements <= 0}\n+     * or {@code brightnessExponent < 0}.\n      */\n     public MicrosphereInterpolator(final int microsphereElements,\n                                    final int brightnessExponent) {\n \n     /**\n      * Set the brightness exponent.\n-     * @param brightnessExponent Exponent for computing the distance dimming\n+     * @param exponent Exponent for computing the distance dimming\n      * factor.\n-     * @throws IllegalArgumentException if {@code brightnessExponent < 0}.\n+     * @throws NotPositiveException if {@code exponent < 0}.\n      */\n-    public void setBrightnessExponent(final int brightnessExponent) {\n-        if (brightnessExponent < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.NEGATIVE_BRIGHTNESS_EXPONENT,\n-                brightnessExponent);\n+    public void setBrightnessExponent(final int exponent) {\n+        if (exponent < 0) {\n+            throw new NotPositiveException(exponent);\n         }\n-        this.brightnessExponent = brightnessExponent;\n+        brightnessExponent = exponent;\n     }\n \n     /**\n      * Set the number of microsphere elements.\n      * @param elements Number of surface elements of the microsphere.\n-     * @throws IllegalArgumentException if {@code microsphereElements <= 0}.\n+     * @throws NotStrictlyPositiveException if {@code elements <= 0}.\n      */\n     public void setMicropshereElements(final int elements) {\n-        if (microsphereElements < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                LocalizedFormats.NON_POSITIVE_MICROSPHERE_ELEMENTS,\n-                microsphereElements);\n+        if (elements <= 0) {\n+            throw new NotStrictlyPositiveException(elements);\n         }\n-        this.microsphereElements = elements;\n+        microsphereElements = elements;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n-import org.apache.commons.math.util.LocalizedFormats;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n      * @param x the arguments for the interpolation points\n      * @param y the values for the interpolation points\n      * @return a function which interpolates the data set\n+     * @throws DimensionMismatchException if {@code x} and {@code y}\n+     * have different sizes.\n+     * @throws NonMonotonousSequenceException if {@code x} is not sorted in\n+     * strict increasing order.\n+     * @throws NumberIsTooSmallException if the size of {@code x} is smaller\n+     * than 3.\n      */\n     public PolynomialSplineFunction interpolate(double x[], double y[]) {\n         if (x.length != y.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, x.length, y.length);\n+            throw new DimensionMismatchException(x.length, y.length);\n         }\n \n         if (x.length < 3) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.WRONG_NUMBER_OF_POINTS, 3, x.length);\n+            throw new NumberIsTooSmallException(x.length, 3, true);\n         }\n \n         // Number of intervals.  The number of data points is n + 1.\n         int n = x.length - 1;\n \n-        for (int i = 0; i < n; i++) {\n-            if (x[i] >= x[i + 1]) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                      LocalizedFormats.NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS,\n-                      i, i+1, x[i], x[i+1]);\n-            }\n-        }\n+        MathUtils.checkOrder(x);\n \n         // Differences between knot points\n         double h[] = new double[n];\n--- a/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotPositiveException.java\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class NotPositiveException extends MathIllegalNumberException {\n+public class NotPositiveException extends NumberIsTooSmallException {\n     /**\n      * Construct the exception.\n      *\n      * @param value Argument.\n      */\n     public NotPositiveException(Number value) {\n-        super(LocalizedFormats.NOT_POSITIVE, value);\n+        super(value, 0, true);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\n+++ b/src/main/java/org/apache/commons/math/exception/NotStrictlyPositiveException.java\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n-public class NotStrictlyPositiveException extends MathIllegalNumberException {\n+public class NotStrictlyPositiveException extends NumberIsTooSmallException {\n     /**\n      * Construct the exception.\n      *\n      * @param value Argument.\n      */\n     public NotStrictlyPositiveException(Number value) {\n-        super(LocalizedFormats.NOT_STRICTLY_POSITIVE, value);\n+        super(value, 0, false);\n     }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooLargeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a number is too large.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class NumberIsTooLargeException extends MathIllegalNumberException {\n+    /**\n+     * Higher bound.\n+     */\n+    private final Number max;\n+    /**\n+     * Whether the maximum is included in the allowed range.\n+     */\n+    private final boolean boundIsAllowed;\n+\n+    /**\n+     * Construct the exception.\n+     *\n+     * @param wrong Value that is larger than the maximum.\n+     * @param max maximum.\n+     */\n+    public NumberIsTooLargeException(Number wrong,\n+                                     Number max,\n+                                     boolean boundIsAllowed) {\n+        super((boundIsAllowed ?\n+               LocalizedFormats.NUMBER_TOO_LARGE :\n+               LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED),\n+              wrong, max);\n+\n+        this.max = max;\n+        this.boundIsAllowed = boundIsAllowed;\n+    }\n+\n+    /**\n+     * @return {@code true} if the maximum is included in the allowed range.\n+     **/\n+    public boolean getBoundIsAllowed() {\n+        return boundIsAllowed;\n+    }\n+\n+    /**\n+     * @return the maximum.\n+     **/\n+    public Number getMax() {\n+        return max;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NumberIsTooSmallException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a number is too small.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class NumberIsTooSmallException extends MathIllegalNumberException {\n+    /**\n+     * Higher bound.\n+     */\n+    private final Number min;\n+    /**\n+     * Whether the maximum is included in the allowed range.\n+     */\n+    private final boolean boundIsAllowed;\n+\n+    /**\n+     * Construct the exception.\n+     *\n+     * @param wrong Value that is smaller than the minimum.\n+     * @param min minimum.\n+     */\n+    public NumberIsTooSmallException(Number wrong,\n+                                     Number min,\n+                                     boolean boundIsAllowed) {\n+        super((boundIsAllowed ?\n+               LocalizedFormats.NUMBER_TOO_SMALL :\n+               LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED),\n+              wrong, min);\n+\n+        this.min = min;\n+        this.boundIsAllowed = boundIsAllowed;\n+    }\n+\n+    /**\n+     * @return {@code true} if the minimum is included in the allowed range.\n+     **/\n+    public boolean getBoundIsAllowed() {\n+        return boundIsAllowed;\n+    }\n+\n+    /**\n+     * @return the minimum.\n+     **/\n+    public Number getMin() {\n+        return min;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n     NOT_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not increasing ({2} > {3})\"),\n     NOT_INCREASING_SEQUENCE(\"points {3} and {2} are not increasing ({1} > {0})\"), /* keep */\n     NOT_MULTIPLICATION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\"),\n-    NOT_STRICTLY_POSITIVE(\"{0} is not strictly positive\"), /* keep */\n-    NOT_POSITIVE(\"{0} is not positive\"), /* keep */\n     NOT_POSITIVE_ALPHA(\"alpha must be positive ({0})\"),\n     NOT_POSITIVE_BETA(\"beta must be positive ({0})\"),\n     NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n     NULL_OBJECT_TRANSFORMATION(\"Conversion Exception in Transformation, Object is null\"),\n     NULL_REAL_FORMAT(\"null real format\"),\n     NULL_WHOLE_FORMAT(\"whole format can not be null\"),\n+    NUMBER_TOO_LARGE(\"{0} is larger than the maximum ({1})\"), /* keep */\n+    NUMBER_TOO_SMALL(\"{0} is smaller than the minimum ({1})\"), /* keep */\n+    NUMBER_TOO_LARGE_BOUND_EXCLUDED(\"{0} is larger than, or equal to, the maximum ({1})\"), /* keep */\n+    NUMBER_TOO_SMALL_BOUND_EXCLUDED(\"{0} is smaller than, or equal to, the minimum ({1})\"), /* keep */\n     NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE(\"number of successes ({0}) must be less than or equal to population size ({1})\"),\n     NUMERATOR_OVERFLOW_AFTER_MULTIPLY(\"overflow, numerator too large after multiply: {0}\"),\n     N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED(\"{0} points Legendre-Gauss integrator not supported, number of points must be in the {1}-{2} range\"),\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/LinearInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/LinearInterpolatorTest.java\n package org.apache.commons.math.analysis.interpolation;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n             double yval[] = { 0.0, 1.0, 2.0 };\n             i.interpolate(xval, yval);\n             Assert.fail(\"Failed to detect data set array with different sizes.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (DimensionMismatchException iae) {\n             // Expected.\n         }\n         // X values not sorted.\n             double yval[] = { 0.0, 1.0, 2.0 };\n             i.interpolate(xval, yval);\n             Assert.fail(\"Failed to detect unsorted arguments.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (NonMonotonousSequenceException iae) {\n+            // Expected.\n+        }\n+        // Not enough data to interpolate.\n+        try {\n+            double xval[] = { 0.0 };\n+            double yval[] = { 0.0 };\n+            i.interpolate(xval, yval);\n+            Assert.fail(\"Failed to detect unsorted arguments.\");\n+        } catch (NumberIsTooSmallException iae) {\n             // Expected.\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n  */\n package org.apache.commons.math.analysis.interpolation;\n \n-import junit.framework.TestCase;\n-\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.NonMonotonousSequenceException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Test the SplineInterpolator.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class SplineInterpolatorTest extends TestCase {\n+public class SplineInterpolatorTest {\n \n     /** error tolerance for spline interpolator value at knot points */\n     protected double knotTolerance = 1E-12;\n     /** error tolerance for interpolated values -- high value is from sin test */\n     protected double interpolationTolerance = 1E-2;\n \n-    public SplineInterpolatorTest(String name) {\n-        super(name);\n-    }\n-\n+    @Test\n     public void testInterpolateLinearDegenerateTwoSegment()\n         throws Exception {\n         double x[] = { 0.0, 0.5, 1.0 };\n         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n \n         // Check interpolation\n-        assertEquals(0.0,f.value(0.0), interpolationTolerance);\n-        assertEquals(0.4,f.value(0.4), interpolationTolerance);\n-        assertEquals(1.0,f.value(1.0), interpolationTolerance);\n-    }\n-\n+        Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance);\n+        Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance);\n+        Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance);\n+    }\n+\n+    @Test\n     public void testInterpolateLinearDegenerateThreeSegment()\n         throws Exception {\n         double x[] = { 0.0, 0.5, 1.0, 1.5 };\n         TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);\n \n         // Check interpolation\n-        assertEquals(0,f.value(0), interpolationTolerance);\n-        assertEquals(1.4,f.value(1.4), interpolationTolerance);\n-        assertEquals(1.5,f.value(1.5), interpolationTolerance);\n-    }\n-\n+        Assert.assertEquals(0,f.value(0), interpolationTolerance);\n+        Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance);\n+        Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance);\n+    }\n+\n+    @Test\n     public void testInterpolateLinear() throws Exception {\n         double x[] = { 0.0, 0.5, 1.0 };\n         double y[] = { 0.0, 0.5, 0.0 };\n         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n     }\n \n+    @Test\n     public void testInterpolateSin() throws Exception {\n         double x[] =\n             {\n         TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);\n \n         //Check interpolation\n-        assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);\n-        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);\n-    }\n-\n-\n+        Assert.assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);\n+        Assert.assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);\n+    }\n+\n+    @Test\n     public void testIllegalArguments() throws MathException {\n         // Data set arrays of different size.\n         UnivariateRealInterpolator i = new SplineInterpolator();\n             double xval[] = { 0.0, 1.0 };\n             double yval[] = { 0.0, 1.0, 2.0 };\n             i.interpolate(xval, yval);\n-            fail(\"Failed to detect data set array with different sizes.\");\n-        } catch (IllegalArgumentException iae) {\n+            Assert.fail(\"Failed to detect data set array with different sizes.\");\n+        } catch (DimensionMismatchException iae) {\n+            // Expected.\n         }\n         // X values not sorted.\n         try {\n             double xval[] = { 0.0, 1.0, 0.5 };\n             double yval[] = { 0.0, 1.0, 2.0 };\n             i.interpolate(xval, yval);\n-            fail(\"Failed to detect unsorted arguments.\");\n-        } catch (IllegalArgumentException iae) {\n+            Assert.fail(\"Failed to detect unsorted arguments.\");\n+        } catch (NonMonotonousSequenceException iae) {\n+            // Expected.\n+        }\n+        // Not enough data to interpolate.\n+        try {\n+            double xval[] = { 0.0, 1.0 };\n+            double yval[] = { 0.0, 1.0 };\n+            i.interpolate(xval, yval);\n+            Assert.fail(\"Failed to detect unsorted arguments.\");\n+        } catch (NumberIsTooSmallException iae) {\n+            // Expected.\n         }\n     }\n \n     protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])\n         throws Exception{\n         for (int i = 0; i < x.length; i++) {\n-            assertEquals(f.value(x[i]), y[i], knotTolerance);\n+            Assert.assertEquals(f.value(x[i]), y[i], knotTolerance);\n         }\n     }\n \n         PolynomialFunction polynomials[] = f.getPolynomials();\n         for (int i = 1; i < x.length - 2; i++) {\n             // evaluate polynomials and derivatives at x[i + 1]\n-            assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);\n-            assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),\n-                    polynomials[i + 1].derivative().value(0), 0.5);\n-            assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),\n-                    polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);\n+            Assert.assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);\n+            Assert.assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),\n+                                polynomials[i + 1].derivative().value(0), 0.5);\n+            Assert.assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),\n+                                polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/exception/NotPositiveExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/exception/NotPositiveExceptionTest.java\n     public void testAccessors() {\n         final NotPositiveException e = new NotPositiveException(-1);\n         Assert.assertEquals(-1, e.getArgument());\n+        Assert.assertEquals(0, e.getMin());\n+        Assert.assertTrue(e.getBoundIsAllowed());\n     }\n }\n--- a/src/test/java/org/apache/commons/math/exception/NotStrictlyPositiveExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/exception/NotStrictlyPositiveExceptionTest.java\n     public void testAccessors() {\n         final NotStrictlyPositiveException e = new NotStrictlyPositiveException(0);\n         Assert.assertEquals(0, e.getArgument());\n+        Assert.assertEquals(0, e.getMin());\n+        Assert.assertFalse(e.getBoundIsAllowed());\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/exception/NumberIsTooLargeExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link NumberIsTooLargeException}.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public class NumberIsTooLargeExceptionTest {\n+    @Test\n+    public void testAccessors() {\n+        final NumberIsTooLargeException e = new NumberIsTooLargeException(1, 0, true);\n+        Assert.assertEquals(1, e.getArgument());\n+        Assert.assertEquals(0, e.getMax());\n+        Assert.assertTrue(e.getBoundIsAllowed());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/exception/NumberIsTooSmallExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link NumberIsTooSmallException}.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public class NumberIsTooSmallExceptionTest {\n+    @Test\n+    public void testAccessors() {\n+        final NumberIsTooSmallException e = new NumberIsTooSmallException(0, 0, false);\n+        Assert.assertEquals(0, e.getArgument());\n+        Assert.assertEquals(0, e.getMin());\n+        Assert.assertFalse(e.getBoundIsAllowed());\n+    }\n+}", "timestamp": 1278339010, "metainfo": ""}