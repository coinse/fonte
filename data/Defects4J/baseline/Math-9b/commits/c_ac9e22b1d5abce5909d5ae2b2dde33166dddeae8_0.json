{"sha": "ac9e22b1d5abce5909d5ae2b2dde33166dddeae8", "log": "Replaced normal CDF routine with one based on the error function.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Normal (Gauss) Distribution.\n+ * Instances of NormalDistribution objects should be created using\n+ * {@link DistributionFactory#createNormalDistribution(double, double)}.<p>\n+ * \n+ * <p>\n+ * References:<p>\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">\n+ * Normal Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @version $Revision: 1.7 $ $Date: 2004/05/05 19:59:11 $\n+ */\n+public interface NormalDistribution extends ContinuousDistribution {\n+\t/**\n+\t * Access the mean.\n+\t * @return mean for this distribution\n+\t */\n+\tdouble getMean();\n+\t/**\n+\t * Modify the mean.\n+\t * @param mean for this distribution\n+\t */\n+\tvoid setMean(double mean);\n+\t/**\n+\t * Access the standard deviation.\n+\t * @return standard deviation for this distribution\n+\t */\n+\tdouble getStandardDeviation();\n+\t/**\n+\t * Modify the standard deviation.\n+\t * @param sd standard deviation for this distribution\n+\t */\n+\tvoid setStandardDeviation(double sd);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.special.Erf;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.NormalDistribution}.<p>\n+ * You can choose the algorithm used to calculate cumulative probability\n+ * using method {@link #setCdfAlgorithm}. The deafault is the Cody algorithm \n+ * {@link org.apache.commons.math.distribution.NormalCDFPreciseAlgorithm}\n+ * \n+ * @version $Revision: 1.8 $ $Date: 2004/05/05 19:59:11 $\n+ */\n+public class NormalDistributionImpl extends AbstractContinuousDistribution \n+\t\timplements NormalDistribution, Serializable {\n+    \n+    /** The mean of this distribution. */\n+\tprivate double mean = 0;\n+    \n+    /** The standard deviation of this distribution. */\n+\tprivate double standardDeviation = 1;\n+\t\n+\t/**\n+\t * Create a normal distribution using the given mean and standard deviation.\n+\t * @param mean mean for this distribution\n+\t * @param sd standard deviation for this distribution\n+\t */\n+\tpublic NormalDistributionImpl(double mean, double sd){\n+\t\tsuper();\n+\t\tsetMean(mean);\n+\t\tsetStandardDeviation(sd);\n+\t}\n+\t/**\n+\t * Creates normal distribution with the mean equal to zero and standard\n+\t * deviation equal to one. \n+\t */\n+\tpublic NormalDistributionImpl(){\n+\t\tthis(0.0, 1.0);\n+\t}\t\n+\t/**\n+\t * Access the mean.\n+\t * @return mean for this distribution\n+\t */\t\n+\tpublic double getMean() {\n+\t\treturn mean;\n+\t}\n+\t/**\n+\t * Modify the mean.\n+\t * @param mean for this distribution\n+\t */\n+\tpublic void setMean(double mean) {\n+\t\tthis.mean = mean;\n+\t}\n+\n+\t/**\n+\t * Access the standard deviation.\n+\t * @return standard deviation for this distribution\n+\t */\n+\tpublic double getStandardDeviation() {\n+\t\treturn standardDeviation;\n+\t}\n+\n+\t/**\n+\t * Modify the standard deviation.\n+\t * @param sd standard deviation for this distribution\n+\t */\n+\tpublic void setStandardDeviation(double sd) {\n+\t\tif (sd <= 0.0) {\n+\t\t\tthrow new IllegalArgumentException(\n+                \"Standard deviation must be positive.\");\n+\t\t}\t\t\n+\t\tstandardDeviation = sd;\n+\t}\n+\n+\t/**\n+\t * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n+\t * @param x the value at which the CDF is evaluated.\n+\t * @return CDF evaluted at <code>x</code>. \n+\t * @throws MathException if the algorithm fails to converge.\n+\t */\n+\tpublic double cumulativeProbability(double x) throws MathException {\n+        return 0.5 * (1.0 + Erf.erf((x - mean) /\n+                (standardDeviation * Math.sqrt(2.0))));\n+\t}\n+\t\n+\t/**\n+\t * Access the domain value lower bound, based on <code>p</code>, used to\n+\t * bracket a CDF root.  This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p the desired probability for the critical value\n+\t * @return domain value lower bound, i.e.\n+\t *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+\t */\n+\tprotected double getDomainLowerBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = -Double.MAX_VALUE;\n+        } else {\n+            ret = getMean();\n+        }\n+        \n+        return ret;\n+    }\n+\n+\t/**\n+\t * Access the domain value upper bound, based on <code>p</code>, used to\n+\t * bracket a CDF root.  This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p the desired probability for the critical value\n+\t * @return domain value upper bound, i.e.\n+\t *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+\t */\n+\tprotected double getDomainUpperBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMean();\n+        } else {\n+            ret = Double.MAX_VALUE;\n+        }\n+        \n+        return ret;\n+    }\n+\n+\t/**\n+\t * Access the initial domain value, based on <code>p</code>, used to\n+\t * bracket a CDF root.  This method is used by\n+\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n+\t * \n+\t * @param p the desired probability for the critical value\n+\t * @return initial domain value\n+\t */\n+\tprotected double getInitialDomain(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMean() - getStandardDeviation();\n+        } else if (p > .5) {\n+            ret = getMean() + getStandardDeviation();\n+        } else {\n+            ret = getMean();\n+        }\n+        \n+        return ret;\n+\t}\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/special/Erf.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.special;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This is a utility class that provides computation methods related to the\n+ * error functions.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/05/05 19:54:58 $\n+ */\n+public class Erf implements Serializable {\n+\n+    /**\n+     * Default constructor.  Prohibit instantiation.\n+     */\n+    private Erf() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the error function erf(x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/Erf.html\">\n+     * Erf</a>, equation (3).</li>\n+     * </ul>\n+     * \n+     * @param x the value.\n+     * @return the error function erf(x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double erf(double x) throws MathException {\n+        double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n+        if (x < 0) {\n+            ret = -ret;\n+        }\n+        return ret;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/TestUtils.java\n+++ b/src/test/org/apache/commons/math/TestUtils.java\n import org.apache.commons.math.complex.Complex;\n \n /**\n- * @version $Revision: 1.12 $ $Date: 2004/04/02 21:30:08 $\n+ * @version $Revision: 1.13 $ $Date: 2004/05/05 19:55:14 $\n  */\n public class TestUtils {\n     /**\n     public static void assertEquals(String msg, double expected, double actual, double delta) {\n     \t// check for NaN\n     \tif(Double.isNaN(expected)){\n-    \t\tAssert.assertTrue(msg, Double.isNaN(actual));\n+    \t\tAssert.assertTrue(\"\" + actual + \" is not NaN.\",\n+    \t\t    Double.isNaN(actual));\n     \t} else {\n     \t\tAssert.assertEquals(msg, expected, actual, delta);\n     \t}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ *  Tests for NormalDistribution implementation\n+ * \n+ * \"True\" results are taken from R - the same as in Mathematica\n+ *\n+ */\n+public class NormalDistributionTest extends TestCase {\n+\t\n+\tprivate NormalDistribution z;\n+\tprivate static final double PRECISION = 10e-6;\t\n+\tprivate static final double M = 2.1;\n+\tprivate static final double SD = 1.4;\n+\t\n+\t/**\n+\t * Constructor for NormalDistributionTest.\n+\t * @param arg0\n+\t */\n+\tpublic NormalDistributionTest(String arg0) {\n+\t\tsuper(arg0);\n+\t}\n+\n+\tpublic static void main(String[] args) {\n+\t\tjunit.swingui.TestRunner.run(NormalDistributionTest.class);\n+\t}\n+\n+\tprotected void setUp() throws Exception {\n+\t\tsuper.setUp();\n+\t\tz = DistributionFactory.newInstance().createNormalDistribution(M, SD);\n+\t}\n+\n+\tprotected void tearDown() throws Exception {\n+\t\tsuper.tearDown();\n+\t\tz = null;\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM_MINUS_2SD() throws MathException {\n+\t\ttestProbability(M - 2*SD, 0.02275013);\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM_MINUS_SD() throws MathException {\n+\t\ttestProbability(M - SD, 0.1586553);\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM() throws MathException {\n+\t\ttestProbability(M, 0.5);\n+\t}\n+\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_SD() throws MathException {\n+\t\ttestProbability(M + SD, 0.8413447);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_2SD() throws MathException {\n+\t\ttestProbability(M + 2*SD, 0.9772499);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_3SD() throws MathException {\n+\t\ttestProbability(M + 3*SD, 0.9986501);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_4SD() throws MathException {\n+\t\ttestProbability(M + 4*SD, 0.9999683);\n+\t}\n+\t\n+\tpublic void testCumulativeProbabilitydoubleM_PLUS_5SD() throws MathException {\n+\t\ttestProbability(M + 5*SD, 0.9999997);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability001() throws MathException {\n+\t\ttestValue(-2.226325, .001);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability010() throws MathException{\n+\t\ttestValue(-1.156887, .010);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability025() throws MathException{\n+\t\ttestValue(-0.6439496, .025);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability050() throws MathException{\n+\t\ttestValue(-0.2027951, .050);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability100() throws MathException{\n+\t\ttestValue(0.3058278, .100);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability900() throws MathException{\n+\t\ttestValue(3.894172, .900);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability950() throws MathException{\n+\t\ttestValue(4.402795, .950);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability975() throws MathException{\n+\t\ttestValue(4.84395, .975);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability990() throws MathException{\n+\t\ttestValue(5.356887, .990);\n+\t}\n+\n+\tpublic void testInverseCumulativeProbability999() throws MathException{\n+\t\ttestValue(6.426325, .999);\n+\t}\n+\n+\tpublic void testGetMean() {\n+\t\tassertEquals(M, z.getMean(), 0);\n+\t}\n+\n+\tpublic void testSetMean() throws MathException {\n+\t\tdouble mu = Math.random();\n+\t\tz.setMean(mu);\n+\t\tassertEquals(mu, z.getMean(), 0);\n+\t\tassertEquals(0.5d, z.cumulativeProbability(mu), PRECISION);\n+\t}\n+\n+\tpublic void testGetStandardDeviation() {\n+\t\tassertEquals(SD, z.getStandardDeviation(), 0);\t\n+\t}\n+\n+\tpublic void testSetStandardDeviation() throws MathException{\n+\t\tdouble sigma = 0.1d + Math.random();\n+\t\tz.setStandardDeviation(sigma);\n+\t\tassertEquals(sigma, z.getStandardDeviation(), 0);\n+\t\tassertEquals(0.84134475, z.cumulativeProbability(z.getMean() + z.getStandardDeviation()), PRECISION );\n+\t}\n+\t\n+\tprivate void testProbability(double x, double expected) throws MathException {\n+\t\tdouble actual = Double.NaN;\n+\t\tactual =  z.cumulativeProbability(x);\n+\t\tassertEquals(expected, actual, PRECISION);\n+\t}\n+\n+\tprivate void testValue(double expected, double p) throws MathException {\n+\t\tdouble actual = z.inverseCumulativeProbability(p);\n+\t\tTestUtils.assertEquals(expected, actual, PRECISION);\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/special/ErfTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2004/05/05 19:54:58 $\n+ */\n+public class ErfTest extends TestCase {\n+\n+    public void testErf0() throws MathException {\n+        double actual = Erf.erf(0.0);\n+        double expected = 0.0;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf1960() throws MathException {\n+        double x = 1.960 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.95;\n+        assertEquals(expected, actual, 1.0e-5);\n+\n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf2576() throws MathException {\n+        double x = 2.576 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.99;\n+        assertEquals(expected, actual, 1.0e-5);\n+    \n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf2807() throws MathException {\n+        double x = 2.807 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.995;\n+        assertEquals(expected, actual, 1.0e-5);\n+        \n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+\n+    public void testErf3291() throws MathException {\n+        double x = 3.291 / Math.sqrt(2.0);\n+        double actual = Erf.erf(x);\n+        double expected = 0.999;\n+        assertEquals(expected, actual, 1.0e-5);\n+        \n+        actual = Erf.erf(-x);\n+        expected = -expected;\n+        assertEquals(expected, actual, 1.0e-5);\n+    }\n+}", "timestamp": 1083787151, "metainfo": ""}