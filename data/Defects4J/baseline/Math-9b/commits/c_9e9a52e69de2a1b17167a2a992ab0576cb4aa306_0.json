{"sha": "9e9a52e69de2a1b17167a2a992ab0576cb4aa306", "log": "MATH-866 Method to test for equality with a given relative tolerance (due to Yannick Tanguy and Julien Anxionnat). Original patch provided in JIRA MATH-863 and committed with a few changes.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n     }\n \n     /**\n+     * Returns {@code true} if there is no double value strictly between the\n+     * arguments or the reltaive difference between them is smaller or equal\n+     * to the given tolerance.\n+     *\n+     * @param x First value.\n+     * @param y Second value.\n+     * @param eps Amount of allowed relative error.\n+     * @return {@code true} if the values are two adjacent floating point\n+     * numbers or they are within range of each other.\n+     */\n+    public static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n+        if (equals(x, y, 1)) {\n+            return true;\n+        }\n+\n+        final double absoluteMax = FastMath.max(FastMath.abs(x), FastMath.abs(y));\n+        final double relativeDifference = FastMath.abs((x - y) / absoluteMax);\n+\n+        return relativeDifference <= eps;\n+    }\n+\n+    /**\n      * Returns true if both arguments are NaN or are equal or within the range\n      * of allowed error (inclusive).\n      *\n--- a/src/test/java/org/apache/commons/math3/util/PrecisionTest.java\n+++ b/src/test/java/org/apache/commons/math3/util/PrecisionTest.java\n  * @version $Id$\n  */\n public class PrecisionTest {\n+    @Test\n+    public void testEqualsWithRelativeTolerance() {\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(0d, 0d, 0d));\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(0d, 1 / Double.NEGATIVE_INFINITY, 0d));\n+\n+        final double eps = 1e-14;\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654988, eps));\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654987, eps));\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654948, eps));\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654949, eps));\n+\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(Precision.SAFE_MIN, 0.0, eps));\n+\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(1.0000000000001e-300, 1e-300, eps));\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(1.00000000000001e-300, 1e-300, eps));\n+\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NEGATIVE_INFINITY, 1.23, eps));\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.POSITIVE_INFINITY, 1.23, eps));\n+\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, eps));\n+        Assert.assertTrue(Precision.equalsWithRelativeTolerance(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, eps));\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, eps));\n+\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NaN, 1.23, eps));\n+        Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NaN, Double.NaN, eps));\n+    }\n+\n     @Test\n     public void testEqualsIncludingNaN() {\n         double[] testArray = {", "timestamp": 1348135777, "metainfo": ""}