{"sha": "b631eb68a8aa659e0760de672edfbfb9f9ac246d", "log": "removed unnecessary parentheses  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n                 double sumX = 0, sumXSquared = 0, sumY = 0, sumXY = 0;\n                 double denom = Math.abs(1.0 / (xval[edge] - x));\n                 for (int k = ileft; k <= iright; ++k) {\n-                    final double xk = xval[k];\n-                    final double yk = yval[k];\n-                    double dist;\n-                    if (k < i) {\n-                        dist = (x - xk);\n-                    } else {\n-                        dist = (xk - x);\n-                    }\n-                    final double w = tricube(dist * denom) * robustnessWeights[k];\n-                    final double xkw = xk * w;\n+                    final double xk   = xval[k];\n+                    final double yk   = yval[k];\n+                    final double dist = (k < i) ? x - xk : xk - x;\n+                    final double w    = tricube(dist * denom) * robustnessWeights[k];\n+                    final double xkw  = xk * w;\n                     sumWeights += w;\n                     sumX += xkw;\n                     sumXSquared += xk * xkw;\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n             for (j = i; j > 0; j--) {\n                 c[j] = c[j-1] - c[j] * x[i];\n             }\n-            c[0] *= (-x[i]);\n+            c[0] *= -x[i];\n             c[i+1] = 1;\n         }\n \n             d = 1;\n             for (j = 0; j < n; j++) {\n                 if (i != j) {\n-                    d *= (x[i] - x[j]);\n+                    d *= x[i] - x[j];\n                 }\n             }\n             if (d == 0.0) {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n                 setResult(x1, i);\n                 return result;\n             }\n-            double dx = (x2 - x1);\n+            double dx = x2 - x1;\n             double tolerance =\n                 Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n             if (Math.abs(dx) <= tolerance) {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n         throws ConvergenceException, FunctionEvaluationException {\n \n         // check for zeros before verifying bracketing\n-        if (f.value(min) == 0.0) { return min; }\n-        if (f.value(max) == 0.0) { return max; }\n-        if (f.value(initial) == 0.0) { return initial; }\n+        if (f.value(min) == 0.0) {\n+            return min;\n+        }\n+        if (f.value(max) == 0.0) {\n+            return max;\n+        }\n+        if (f.value(initial) == 0.0) {\n+            return initial;\n+        }\n \n         verifyBracketing(min, max, f);\n         verifySequence(min, initial, max);\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"polynomial degree must be positive: degree={0}\", n);\n         }\n-        Complex N = new Complex(n, 0.0);\n-        Complex N1 = new Complex((n-1), 0.0);\n+        Complex N  = new Complex(n,     0.0);\n+        Complex N1 = new Complex(n - 1, 0.0);\n \n         int i = 1;\n         Complex pv = null;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n         throws FunctionEvaluationException {\n         final double f1 = function.value(lower);\n         final double f2 = function.value(upper);\n-        return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n+        return (f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n                 return Math.abs(real);\n             }\n             double q = real / imaginary;\n-            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n+            return Math.abs(imaginary) * Math.sqrt(1 + q * q);\n         } else {\n             if (real == 0.0) {\n                 return Math.abs(imaginary);\n             }\n             double q = imaginary / real;\n-            return (Math.abs(real) * Math.sqrt(1 + q*q));\n+            return Math.abs(real) * Math.sqrt(1 + q * q);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n \n     /** {@inheritDoc} */\n     public boolean isSquare() {\n-        return (getColumnDimension() == getRowDimension());\n+        return getColumnDimension() == getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n \n     /** {@inheritDoc} */\n     public boolean isSquare() {\n-        return (getColumnDimension() == getRowDimension());\n+        return getColumnDimension() == getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n             return ZERO;\n         } else {\n             BigDecimal det = (parity == 1) ? ONE : ONE.negate();\n-            for (int i = 0; i < this.getRowDimension(); i++) {\n+            for (int i = 0; i < getRowDimension(); i++) {\n                 det = det.multiply(lu[i][i]);\n             }\n             return det;\n      * @return true if the matrix is square (rowDimension = columnDimension)\n      */\n     public boolean isSquare() {\n-        return (this.getColumnDimension() == this.getRowDimension());\n+        return getColumnDimension() == getRowDimension();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n         throws EventException {\n         t0 = tStart;\n         g0 = handler.g(tStart, yStart);\n-        g0Positive = (g0 >= 0);\n+        g0Positive = g0 >= 0;\n     }\n \n     /** Evaluate the impact of the proposed step on the event handler.\n                     // there is a sign change: an event is expected during this step\n \n                     // variation direction, with respect to the integration direction\n-                    increasing = (gb >= ga);\n+                    increasing = gb >= ga;\n \n                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n                         public double value(final double t) throws FunctionEvaluationException {\n             g0Positive        = increasing;\n             nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n         } else {\n-            g0Positive = (g0 >= 0);\n+            g0Positive = g0 >= 0;\n             nextAction = EventHandler.CONTINUE;\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n         sanityChecks(equations, t0, y0, t, y);\n         setEquations(equations);\n         resetEvaluations();\n-        final boolean forward = (t > t0);\n+        final boolean forward = t > t0;\n \n         // initialize working arrays\n         if (y != y0) {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n         sanityChecks(equations, t0, y0, t, y);\n         setEquations(equations);\n         resetEvaluations();\n-        final boolean forward = (t > t0);\n+        final boolean forward = t > t0;\n \n         // initialize working arrays\n         if (y != y0) {\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n     resetEvaluations();\n-    final boolean forward = (t > t0);\n+    final boolean forward = t > t0;\n \n     // create some internal working arrays\n     final int stages = c.length + 1;\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n     resetEvaluations();\n-    final boolean forward = (t > t0);\n+    final boolean forward = t > t0;\n \n     // create some internal working arrays\n     final double[] yDot0   = new double[y0.length];\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n     sanityChecks(equations, t0, y0, t, y);\n     setEquations(equations);\n     resetEvaluations();\n-    final boolean forward = (t > t0);\n+    final boolean forward = t > t0;\n \n     // create some internal working arrays\n     final int stages = c.length + 1;\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n             lastDerivatives = interpolator.getInterpolatedDerivatives().clone();\n \n             // take the integration direction into account\n-            forward = (interpolator.getCurrentTime() >= lastTime);\n+            forward = interpolator.getCurrentTime() >= lastTime;\n             if (! forward) {\n                 h = -h;\n             }\n--- a/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n+++ b/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n         y = mt[mti++];\n \n         // tempering\n-        y ^= (y >>> 11);\n+        y ^=  y >>> 11;\n         y ^= (y <<   7) & 0x9d2c5680;\n         y ^= (y <<  15) & 0xefc60000;\n-        y ^= (y >>> 18);\n+        y ^=  y >>> 18;\n \n         return y >>> (32 - bits);\n \n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n                     x = Math.ceil(y);\n                     w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n                 }\n-                accept = (w <= x * Math.log(mu) -\n-                         MathUtils.factorialLog((int) (mu + x)) /\n-                         muFactorialLog);\n+                accept = w <= x * Math.log(mu) -\n+                         MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n             }\n             // cast to long is acceptable because both x and mu are whole\n             // numbers.\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n          */\n         @SuppressWarnings(\"unchecked\")\n         public int compare(Comparable<T> o1, Comparable<T> o2) {\n-            return (o1.compareTo((T) o2));\n+            return o1.compareTo((T) o2);\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n             return false;\n         }\n         AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;\n-        return (MathUtils.equals(stat.getResult(), this.getResult()) &&\n-                MathUtils.equals(stat.getN(), this.getN()));\n+        return MathUtils.equals(stat.getResult(), this.getResult()) &&\n+               MathUtils.equals(stat.getN(), this.getN());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n      * @see #createContributingStatistics()\n      */\n     public AggregateSummaryStatistics(SummaryStatistics prototypeStatistics) {\n-        this(prototypeStatistics, (prototypeStatistics == null ? null :\n-                new SummaryStatistics(prototypeStatistics)));\n+        this(prototypeStatistics,\n+             prototypeStatistics == null ? null : new SummaryStatistics(prototypeStatistics));\n     }\n \n     /**\n      * @see #createContributingStatistics()\n      */\n     public AggregateSummaryStatistics(SummaryStatistics prototypeStatistics,\n-            SummaryStatistics initialStatistics) {\n-        this.statisticsPrototype = ((prototypeStatistics == null) ?\n-                new SummaryStatistics() : prototypeStatistics);\n-        this.statistics = ((initialStatistics == null) ?\n-                new SummaryStatistics() : initialStatistics);\n+                                      SummaryStatistics initialStatistics) {\n+        this.statisticsPrototype =\n+            (prototypeStatistics == null) ? new SummaryStatistics() : prototypeStatistics;\n+        this.statistics =\n+            (initialStatistics == null) ? new SummaryStatistics() : initialStatistics;\n     }\n \n     /**\n                 return false;\n             }\n             AggregatingSummaryStatistics stat = (AggregatingSummaryStatistics)object;\n-            return (super.equals(stat) &&\n-                    aggregateStatistics.equals(stat.aggregateStatistics));\n+            return super.equals(stat) &&\n+                   aggregateStatistics.equals(stat.aggregateStatistics);\n         }\n \n         /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n                 stdDev = 0.0;\n             }\n         }\n-        return (stdDev);\n+        return stdDev;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n             return false;\n         }\n         MultivariateSummaryStatistics stat = (MultivariateSummaryStatistics) object;\n-        return (MathUtils.equals(stat.getGeometricMean(),\n-                this.getGeometricMean()) &&\n-                MathUtils.equals(stat.getMax(), this.getMax()) &&\n-                MathUtils.equals(stat.getMean(),this.getMean()) &&\n-                MathUtils.equals(stat.getMin(),this.getMin()) &&\n-                MathUtils.equals(stat.getN(), this.getN()) &&\n-                MathUtils.equals(stat.getSum(), this.getSum()) &&\n-                MathUtils.equals(stat.getSumSq(),this.getSumSq()) &&\n-                MathUtils.equals(stat.getSumLog(),this.getSumLog()) &&\n-                stat.getCovariance().equals(this.getCovariance()));\n+        return MathUtils.equals(stat.getGeometricMean(), getGeometricMean()) &&\n+               MathUtils.equals(stat.getMax(),           getMax())           &&\n+               MathUtils.equals(stat.getMean(),          getMean())          &&\n+               MathUtils.equals(stat.getMin(),           getMin())           &&\n+               MathUtils.equals(stat.getN(),             getN())             &&\n+               MathUtils.equals(stat.getSum(),           getSum())           &&\n+               MathUtils.equals(stat.getSumSq(),         getSumSq())         &&\n+               MathUtils.equals(stat.getSumLog(),        getSumLog())        &&\n+               stat.getCovariance().equals( getCovariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n             return false;\n         }\n         StatisticalSummaryValues stat = (StatisticalSummaryValues) object;\n-        return (MathUtils.equals(stat.getMax(), this.getMax()) &&\n-                MathUtils.equals(stat.getMean(),this.getMean()) &&\n-                MathUtils.equals(stat.getMin(),this.getMin()) &&\n-                MathUtils.equals(stat.getN(), this.getN()) &&\n-                MathUtils.equals(stat.getSum(), this.getSum()) &&\n-                MathUtils.equals(stat.getVariance(),this.getVariance()));\n+        return MathUtils.equals(stat.getMax(),      getMax())  &&\n+               MathUtils.equals(stat.getMean(),     getMean()) &&\n+               MathUtils.equals(stat.getMin(),      getMin())  &&\n+               MathUtils.equals(stat.getN(),        getN())    &&\n+               MathUtils.equals(stat.getSum(),      getSum())  &&\n+               MathUtils.equals(stat.getVariance(), getVariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n                 stdDev = 0.0;\n             }\n         }\n-        return (stdDev);\n+        return stdDev;\n     }\n \n     /**\n             return false;\n         }\n         SummaryStatistics stat = (SummaryStatistics)object;\n-        return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) &&\n-                MathUtils.equals(stat.getMax(), this.getMax()) &&\n-                MathUtils.equals(stat.getMean(), this.getMean()) &&\n-                MathUtils.equals(stat.getMin(), this.getMin()) &&\n-                MathUtils.equals(stat.getN(), this.getN()) &&\n-                MathUtils.equals(stat.getSum(), this.getSum()) &&\n-                MathUtils.equals(stat.getSumsq(), this.getSumsq()) &&\n-                MathUtils.equals(stat.getVariance(),\n-            this.getVariance()));\n+        return MathUtils.equals(stat.getGeometricMean(), getGeometricMean()) &&\n+               MathUtils.equals(stat.getMax(),           getMax())           &&\n+               MathUtils.equals(stat.getMean(),          getMean())          &&\n+               MathUtils.equals(stat.getMin(),           getMin())           &&\n+               MathUtils.equals(stat.getN(),             getN())             &&\n+               MathUtils.equals(stat.getSum(),           getSum())           &&\n+               MathUtils.equals(stat.getSumsq(),         getSumsq())         &&\n+               MathUtils.equals(stat.getVariance(),      getVariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n             // standard deviation\n             double accum3 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n-                accum3 += Math.pow((values[i] - mean), 4.0);\n+                accum3 += Math.pow(values[i] - mean, 4.0);\n             }\n             accum3 /= Math.pow(stdDev, 4.0d);\n \n             double coefficientOne =\n                 (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));\n             double termTwo =\n-                ((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));\n+                (3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3));\n \n             // Calculate kurtosis\n             kurt = (coefficientOne * accum3) - termTwo;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n             // Compute correction factor in second pass\n             double correction = 0;\n             for (int i = begin; i < begin + length; i++) {\n-                correction += (values[i] - xbar);\n+                correction += values[i] - xbar;\n             }\n             return xbar + (correction/sampleSize);\n         }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n             double accum = 0.0;\n             double accum2 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n-                accum += Math.pow((values[i] - m), 2.0);\n-                accum2 += (values[i] - m);\n+                final double d = values[i] - m;\n+                accum  += d * d;\n+                accum2 += d;\n             }\n-            double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / length)) /\n-                    (length - 1));\n+            final double variance = (accum - (accum2 * accum2 / length)) / (length - 1);\n \n             double accum3 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n-                accum3 += Math.pow(values[i] - m, 3.0d);\n+                final double d = values[i] - m;\n+                accum3 += d * d * d;\n             }\n-            accum3 /= Math.pow(stdDev, 3.0d);\n+            accum3 /= variance * Math.sqrt(variance);\n \n             // Get N\n             double n0 = length;\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n         if (test(values, weights, begin, length)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n-                sum += (values[i] * weights[i]);\n+                sum += values[i] * weights[i];\n             }\n         }\n         return sum;\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n             rescale = true;\n         }\n         double sumSq = 0.0d;\n-        double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n             if (rescale) {\n-                dev = (observed[i] - ratio * expected[i]);\n+                final double dev = observed[i] - ratio * expected[i];\n                 sumSq += dev * dev / (ratio * expected[i]);\n             } else {\n-                dev = (observed[i] - expected[i]);\n+                final double dev = observed[i] - expected[i];\n                 sumSq += dev * dev / expected[i];\n             }\n         }\n                   \"out of bounds significance level {0}, must be between {1} and {2}\",\n                   alpha, 0, 0.5);\n         }\n-        return (chiSquareTest(expected, observed) < alpha);\n+        return chiSquareTest(expected, observed) < alpha;\n     }\n \n     /**\n                   \"out of bounds significance level {0}, must be between {1} and {2}\",\n                   alpha, 0.0, 0.5);\n         }\n-        return (chiSquareTest(counts) < alpha);\n+        return chiSquareTest(counts) < alpha;\n     }\n \n     /**\n                   \"observed counts are all 0 in second observed array\");\n         }\n         // Compare and compute weight only if different\n-        unequalCounts = (countSum1 != countSum2);\n+        unequalCounts = countSum1 != countSum2;\n         if (unequalCounts) {\n             weight = Math.sqrt((double) countSum1 / (double) countSum2);\n         }\n                   \"out of bounds significance level {0}, must be between {1} and {2}\",\n                   alpha, 0.0, 0.5);\n         }\n-        return (chiSquareTestDataSetsComparison(observed1, observed2) < alpha);\n+        return chiSquareTestDataSetsComparison(observed1, observed2) < alpha;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n                   \"out of bounds significance level {0}, must be between {1} and {2}\",\n                   alpha, 0, 0.5);\n         }\n-        return (anovaPValue(categoryData) < alpha);\n+        return anovaPValue(categoryData) < alpha;\n     }\n \n \n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n     public boolean pairedTTest(double[] sample1, double[] sample2, double alpha)\n         throws IllegalArgumentException, MathException {\n         checkSignificanceLevel(alpha);\n-        return (pairedTTest(sample1, sample2) < alpha);\n+        return pairedTTest(sample1, sample2) < alpha;\n     }\n \n     /**\n     public boolean tTest(double mu, double[] sample, double alpha)\n     throws IllegalArgumentException, MathException {\n         checkSignificanceLevel(alpha);\n-        return (tTest(mu, sample) < alpha);\n+        return tTest(mu, sample) < alpha;\n     }\n \n     /**\n             double alpha)\n     throws IllegalArgumentException, MathException {\n         checkSignificanceLevel(alpha);\n-        return (tTest(mu, sampleStats) < alpha);\n+        return tTest(mu, sampleStats) < alpha;\n     }\n \n     /**\n             double alpha)\n     throws IllegalArgumentException, MathException {\n         checkSignificanceLevel(alpha);\n-        return (tTest(sample1, sample2) < alpha);\n+        return tTest(sample1, sample2) < alpha;\n     }\n \n     /**\n             double alpha)\n     throws IllegalArgumentException, MathException {\n         checkSignificanceLevel(alpha);\n-        return (homoscedasticTTest(sample1, sample2) < alpha);\n+        return homoscedasticTTest(sample1, sample2) < alpha;\n     }\n \n      /**\n             StatisticalSummary sampleStats2, double alpha)\n     throws IllegalArgumentException, MathException {\n         checkSignificanceLevel(alpha);\n-        return (tTest(sampleStats1, sampleStats2) < alpha);\n+        return tTest(sampleStats1, sampleStats2) < alpha;\n     }\n \n     //----------------------------------------------- Protected methods\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n                   \"cannot compute 0-th root of unity, indefinite result\");\n         }\n \n-        isForward = (n > 0);\n+        isForward = n > 0;\n \n         // avoid repetitive calculations\n         final int absN = Math.abs(n);\n                   k, 0, omegaCount - 1);\n         }\n \n-        return (isForward) ?\n-            omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n+        return isForward ? omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n \n       }\n \n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n             // unnecessary.\n             for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                 long d = gcd(i, j);\n-                result = mulAndCheck((result / (j / d)), (i / d));\n+                result = mulAndCheck(result / (j / d), i / d);\n             }\n         }\n         return result;\n      * @return true if the values are equal or both are NaN\n      */\n     public static boolean equals(double x, double y) {\n-        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n+        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n     }\n \n     /**\n                         \"overflow: gcd({0}, {1}) is 2^31\",\n                         p, q);\n             }\n-            return (Math.abs(u) + Math.abs(v));\n+            return Math.abs(u) + Math.abs(v);\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n      * @return the length of the internal storage array.\n      */\n     synchronized int getInternalLength() {\n-        return (internalArray.length);\n+        return internalArray.length;\n     }\n \n     /**\n      * @return number of elements\n      */\n     public synchronized int getNumElements() {\n-        return (numElements);\n+        return numElements;\n     }\n \n     /**\n      */\n     @Deprecated\n     public synchronized double[] getValues() {\n-        return (internalArray);\n+        return internalArray;\n     }\n \n     /**\n      * @since 2.0\n      */\n     public synchronized double[] getInternalValues() {\n-        return (internalArray);\n+        return internalArray;\n     }\n \n     /**", "timestamp": 1252254470, "metainfo": ""}