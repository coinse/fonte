{"sha": "04bcaf9fd60b6c8a29de187330db125c63e2435b", "log": "Unnecessary casts  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/IntervalsSet.java\n             if ((checkPoint(low,  loc) == Location.INSIDE) &&\n                 (checkPoint(high, loc) == Location.INSIDE)) {\n                 // merge the last interval added and the first one of the high sub-tree\n-                x = ((Interval) list.remove(list.size() - 1)).getLower();\n+                x = list.remove(list.size() - 1).getLower();\n             }\n             recurseList(high, list, x, upper);\n \n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/OutlineExtractor.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/OutlineExtractor.java\n                 for (Vector2D[] loop : vertices) {\n                     final boolean closed = loop[0] != null;\n                     int previous         = closed ? (loop.length - 1) : 1;\n-                    Vector3D previous3D  = (Vector3D) plane.toSpace(loop[previous]);\n+                    Vector3D previous3D  = plane.toSpace(loop[previous]);\n                     int current          = (previous + 1) % loop.length;\n                     Vector2D pPoint       = new Vector2D(previous3D.dotProduct(u),\n                                                          previous3D.dotProduct(v));\n                     while (current < loop.length) {\n \n-                        final Vector3D current3D = (Vector3D) plane.toSpace(loop[current]);\n+                        final Vector3D current3D = plane.toSpace(loop[current]);\n                         final Vector2D  cPoint    = new Vector2D(current3D.dotProduct(u),\n                                                                  current3D.dotProduct(v));\n                         final org.apache.commons.math.geometry.euclidean.twod.Line line =\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n         if (FastMath.abs(dot) < 1.0e-10) {\n             return null;\n         }\n-        final Vector3D point = (Vector3D) line.toSpace(Vector1D.ZERO);\n+        final Vector3D point = line.toSpace(Vector1D.ZERO);\n         final double   k     = -(originOffset + w.dotProduct(point)) / dot;\n         return new Vector3D(1.0, point, k, direction);\n     }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n \n         final Plane otherPlane = (Plane) hyperplane;\n         final Plane thisPlane  = (Plane) getHyperplane();\n-        final Line  inter      = (Line) otherPlane.intersection(thisPlane);\n+        final Line  inter      = otherPlane.intersection(thisPlane);\n \n         if (inter == null) {\n             // the hyperplanes are parallel,\n \n         final Plane otherPlane = (Plane) hyperplane;\n         final Plane thisPlane  = (Plane) getHyperplane();\n-        final Line  inter      = (Line) otherPlane.intersection(thisPlane);\n+        final Line  inter      = otherPlane.intersection(thisPlane);\n \n         if (inter == null) {\n             // the hyperplanes are parallel\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/SubLine.java\n \n         // the lines do intersect\n         final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n-        final Vector1D x = (Vector1D) thisLine.toSubSpace(crossing);\n+        final Vector1D x = thisLine.toSubSpace(crossing);\n         return getRemainingRegion().side(new OrientedPoint(x, direct));\n \n     }\n \n         // the lines do intersect\n         final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n-        final Vector1D x      = (Vector1D) thisLine.toSubSpace(crossing);\n+        final Vector1D x      = thisLine.toSubSpace(crossing);\n         final SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\n         final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n \n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n      * transform to the instance\n      */\n     public AbstractRegion<S, T> applyTransform(final Transform<S, T> transform) {\n-        return (AbstractRegion<S, T>) buildNew(recurseTransform(getTree(false), transform));\n+        return buildNew(recurseTransform(getTree(false), transform));\n     }\n \n     /** Recursively transform an inside/outside BSP-tree.\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n         Assert.assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2, normTolerance);\n \n         //octave =  sqrt(sumsq(v1-v2))\n-        double dist_3 = v1.getDistance((RealVector) v2);\n+        double dist_3 = v1.getDistance(v2);\n         Assert.assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3, normTolerance);\n \n         //octave =  ???\n         double d_getL1Distance_2 = v1.getL1Distance(v2_t);\n         Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance_2, normTolerance);\n \n-        double d_getL1Distance_3 = v1.getL1Distance((RealVector) v2);\n+        double d_getL1Distance_3 = v1.getL1Distance(v2);\n         Assert.assertEquals(\"compare values  \", 9d, d_getL1Distance_3, normTolerance);\n \n         //octave =  ???\n         double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n         Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance_2, normTolerance);\n \n-        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n+        double d_getLInfDistance_3 = v1. getLInfDistance(v2);\n         Assert.assertEquals(\"compare values  \", 3d, d_getLInfDistance_3, normTolerance);\n \n         //octave =  v1 + v2\n         double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n         assertClose(\"compare vect\" ,v_ebeMultiply_2.toArray(),result_ebeMultiply_2,normTolerance);\n \n-        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n+        RealVector  v_ebeMultiply_3 = v1.ebeMultiply(v2);\n         double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n         assertClose(\"compare vect\" ,v_ebeMultiply_3.toArray(),result_ebeMultiply_3,normTolerance);\n \n         double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n         assertClose(\"compare vect\" ,v_ebeDivide_2.toArray(),result_ebeDivide_2,normTolerance);\n \n-        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n+        RealVector  v_ebeDivide_3 = v1.ebeDivide(v2);\n         double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n         assertClose(\"compare vect\" ,v_ebeDivide_3.toArray(),result_ebeDivide_3,normTolerance);\n \n         RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n         Assert.assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0), normTolerance);\n \n-        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n+        RealMatrix m_outerProduct_3 = v1.outerProduct(v2);\n         Assert.assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0), normTolerance);\n \n         RealVector v_unitVector = v1.unitVector();\n--- a/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n         Assert.assertEquals(empiricalDistribution2.getSampleStats().getStandardDeviation(),\n                 1.0173699343977738,10E-7);\n \n-        double[] bounds = ((EmpiricalDistributionImpl) empiricalDistribution2).getGeneratorUpperBounds();\n+        double[] bounds = empiricalDistribution2.getGeneratorUpperBounds();\n         Assert.assertEquals(bounds.length, 100);\n         Assert.assertEquals(bounds[99], 1.0, 10e-12);\n ", "timestamp": 1320400470, "metainfo": ""}