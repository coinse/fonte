{"sha": "b59e97464fc8d910c06b90c06598d7176ce1924a", "log": "MATH-689 Moved \"equals...\" and \"compareTo\" methods from \"MathUtils\" over to a new \"Precision\" class.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * This class implements a modification of the <a\n \n         // evaluate initial guess\n         y[1] = computeObjectiveValue(x[1]);\n-        if (MathUtils.equals(y[1], 0.0, 1)) {\n+        if (Precision.equals(y[1], 0.0, 1)) {\n             // return the initial guess if it is a perfect root.\n             return x[1];\n         }\n \n         // evaluate first  endpoint\n         y[0] = computeObjectiveValue(x[0]);\n-        if (MathUtils.equals(y[0], 0.0, 1)) {\n+        if (Precision.equals(y[0], 0.0, 1)) {\n             // return the first endpoint if it is a perfect root.\n             return x[0];\n         }\n \n             // evaluate second endpoint\n             y[2] = computeObjectiveValue(x[2]);\n-            if (MathUtils.equals(y[2], 0.0, 1)) {\n+            if (Precision.equals(y[2], 0.0, 1)) {\n                 // return the second endpoint if it is a perfect root.\n                 return x[2];\n             }\n \n             // evaluate the function at the guessed root\n             final double nextY = computeObjectiveValue(nextX);\n-            if (MathUtils.equals(nextY, 0.0, 1)) {\n+            if (Precision.equals(nextY, 0.0, 1)) {\n                 // we have found an exact root, since it is not an approximation\n                 // we don't need to bother about the allowed solutions setting\n                 return nextX;\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n \n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * This class implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n             final double m = 0.5 * (c - b);\n \n             if (FastMath.abs(m) <= tol ||\n-                MathUtils.equals(fb, 0))  {\n+                Precision.equals(fb, 0))  {\n                 return b;\n             }\n             if (FastMath.abs(e) < tol ||\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n  * Note that this is in contradiction with the IEEE-754 standard for floating\n  * point numbers (according to which the test {@code x == x} must fail if\n  * {@code x} is {@code NaN}). The method\n- * {@link MathUtils#equals(double,double,int) equals for primitive double} in\n- * {@link MathUtils} conforms with IEEE-754 while this class conforms with\n- * the standard behavior for Java object types.\n+ * {@link org.apache.commons.math.util.Precision#equals(double,double,int)\n+ * equals for primitive double} in {@link org.apache.commons.math.util.Precision}\n+ * conforms with IEEE-754 while this class conforms with the standard behavior\n+ * for Java object types.\n  * <br/>\n  * Implements Serializable since 2.0\n  *\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * Base class managing common boilerplate for all integrators.\n                 state.stepAccepted(currentT, currentY);\n                 isLastStep = isLastStep || state.stop();\n             }\n-            isLastStep = isLastStep || MathUtils.equals(currentT, tEnd, 1);\n+            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n \n             // handle the remaining part of the step, after all events if any\n             for (StepHandler handler : stepHandlers) {\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * This class wraps an object implementing {@link FixedStepHandler}\n                           lastTime + h :\n                           (FastMath.floor(lastTime / h) + 1) * h;\n         if (mode == StepNormalizerMode.MULTIPLES &&\n-            MathUtils.equals(nextTime, lastTime, 1)) {\n+            Precision.equals(nextTime, lastTime, 1)) {\n             nextTime += h;\n         }\n \n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n \n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n \n /**\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (MathUtils.compareTo(entry, minValue, maxUlps) < 0) {\n+            if (Precision.compareTo(entry, minValue, maxUlps) < 0) {\n                 minValue = entry;\n                 minPos = i;\n             }\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n \n-            if (MathUtils.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 final double ratio = rhs / entry;\n-                final int cmp = MathUtils.compareTo(ratio, minRatio, maxUlps);\n+                final int cmp = Precision.compareTo(ratio, minRatio, maxUlps);\n                 if (cmp == 0) {\n                     minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n             for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n               int column = i + tableau.getArtificialVariableOffset();\n               final double entry = tableau.getEntry(row, column);\n-              if (MathUtils.equals(entry, 1d, maxUlps) &&\n+              if (Precision.equals(entry, 1d, maxUlps) &&\n                   row.equals(tableau.getBasicRow(column))) {\n                 return row;\n               }\n         }\n \n         // if W is not zero then we have no feasible solution\n-        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n+        if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n             throw new NoFeasibleSolutionException();\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  * A tableau for use in the Simplex method.\n         Integer row = null;\n         for (int i = 0; i < getHeight(); i++) {\n             final double entry = getEntry(i, col);\n-            if (MathUtils.equals(entry, 1d, maxUlps) && (row == null)) {\n+            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {\n                 row = i;\n-            } else if (!MathUtils.equals(entry, 0d, maxUlps)) {\n+            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                 return null;\n             }\n         }\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (MathUtils.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n     boolean isOptimal() {\n         for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (MathUtils.compareTo(entry, 0d, epsilon) < 0) {\n+            if (Precision.compareTo(entry, 0d, epsilon) < 0) {\n                 return false;\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n                         b = u;\n                     }\n                     if (fu <= fw ||\n-                        MathUtils.equals(w, x)) {\n+                        Precision.equals(w, x)) {\n                         v = w;\n                         fv = fw;\n                         w = u;\n                         fw = fu;\n                     } else if (fu <= fv ||\n-                               MathUtils.equals(v, x) ||\n-                               MathUtils.equals(v, w)) {\n+                               Precision.equals(v, x) ||\n+                               Precision.equals(v, w)) {\n                         v = u;\n                         fv = fu;\n                     }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  *\n             return false;\n         }\n         AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;\n-        return MathUtils.equalsIncludingNaN(stat.getResult(), this.getResult()) &&\n-               MathUtils.equalsIncludingNaN(stat.getN(), this.getN());\n+        return Precision.equalsIncludingNaN(stat.getResult(), this.getResult()) &&\n+               Precision.equalsIncludingNaN(stat.getN(), this.getN());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n \n /**\n                MathUtils.equalsIncludingNaN(stat.getMax(),           getMax())           &&\n                MathUtils.equalsIncludingNaN(stat.getMean(),          getMean())          &&\n                MathUtils.equalsIncludingNaN(stat.getMin(),           getMin())           &&\n-               MathUtils.equalsIncludingNaN(stat.getN(),             getN())             &&\n+               Precision.equalsIncludingNaN(stat.getN(),             getN())             &&\n                MathUtils.equalsIncludingNaN(stat.getSum(),           getSum())           &&\n                MathUtils.equalsIncludingNaN(stat.getSumSq(),         getSumSq())         &&\n                MathUtils.equalsIncludingNaN(stat.getSumLog(),        getSumLog())        &&\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n /**\n  *  Value object representing the results of a univariate statistical summary.\n             return false;\n         }\n         StatisticalSummaryValues stat = (StatisticalSummaryValues) object;\n-        return MathUtils.equalsIncludingNaN(stat.getMax(),      getMax())  &&\n-               MathUtils.equalsIncludingNaN(stat.getMean(),     getMean()) &&\n-               MathUtils.equalsIncludingNaN(stat.getMin(),      getMin())  &&\n-               MathUtils.equalsIncludingNaN(stat.getN(),        getN())    &&\n-               MathUtils.equalsIncludingNaN(stat.getSum(),      getSum())  &&\n-               MathUtils.equalsIncludingNaN(stat.getVariance(), getVariance());\n+        return Precision.equalsIncludingNaN(stat.getMax(),      getMax())  &&\n+               Precision.equalsIncludingNaN(stat.getMean(),     getMean()) &&\n+               Precision.equalsIncludingNaN(stat.getMin(),      getMin())  &&\n+               Precision.equalsIncludingNaN(stat.getN(),        getN())    &&\n+               Precision.equalsIncludingNaN(stat.getSum(),      getSum())  &&\n+               Precision.equalsIncludingNaN(stat.getVariance(), getVariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.util.FastMath;\n \n /**\n             return false;\n         }\n         SummaryStatistics stat = (SummaryStatistics)object;\n-        return MathUtils.equalsIncludingNaN(stat.getGeometricMean(), getGeometricMean()) &&\n-               MathUtils.equalsIncludingNaN(stat.getMax(),           getMax())           &&\n-               MathUtils.equalsIncludingNaN(stat.getMean(),          getMean())          &&\n-               MathUtils.equalsIncludingNaN(stat.getMin(),           getMin())           &&\n-               MathUtils.equalsIncludingNaN(stat.getN(),             getN())             &&\n-               MathUtils.equalsIncludingNaN(stat.getSum(),           getSum())           &&\n-               MathUtils.equalsIncludingNaN(stat.getSumsq(),         getSumsq())         &&\n-               MathUtils.equalsIncludingNaN(stat.getVariance(),      getVariance());\n+        return Precision.equalsIncludingNaN(stat.getGeometricMean(), getGeometricMean()) &&\n+               Precision.equalsIncludingNaN(stat.getMax(),           getMax())           &&\n+               Precision.equalsIncludingNaN(stat.getMean(),          getMean())          &&\n+               Precision.equalsIncludingNaN(stat.getMin(),           getMin())           &&\n+               Precision.equalsIncludingNaN(stat.getN(),             getN())             &&\n+               Precision.equalsIncludingNaN(stat.getSum(),           getSum())           &&\n+               Precision.equalsIncludingNaN(stat.getSumsq(),         getSumsq())         &&\n+               Precision.equalsIncludingNaN(stat.getVariance(),      getVariance());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     /** 0.0 cast as a short. */\n     private static final short ZS = (short)0;\n \n-    /** Offset to order signed double numbers lexicographically. */\n-    private static final long SGN_MASK = 0x8000000000000000L;\n-\n-    /** Offset to order signed double numbers lexicographically. */\n-    private static final int SGN_MASK_FLOAT = 0x80000000;\n-\n     /** All long-representable factorials */\n     private static final long[] FACTORIALS = new long[] {\n                        1l,                  1l,                   2l,\n     }\n \n     /**\n-     * Compares two numbers given some amount of allowed error.\n-     *\n-     * @param x the first number\n-     * @param y the second number\n-     * @param eps the amount of error to allow when checking for equality\n-     * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n-     *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n-     *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>\n-     */\n-    public static int compareTo(double x, double y, double eps) {\n-        if (equals(x, y, eps)) {\n-            return 0;\n-        } else if (x < y) {\n-            return -1;\n-        }\n-        return 1;\n-    }\n-\n-    /**\n-     * Compares two numbers given some amount of allowed error.\n-     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n-     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n-     * point numbers are considered equal.\n-     * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n-     * Bruce Dawson</a>\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n-     * values between {@code x} and {@code y}.\n-     * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n-     *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n-     *       <li>> 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y</li></ul>\n-     */\n-    public static int compareTo(final double x, final double y, final int maxUlps) {\n-        if (equals(x, y, maxUlps)) {\n-            return 0;\n-        } else if (x < y) {\n-            return -1;\n-        }\n-        return 1;\n-    }\n-\n-    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n      * hyperbolic cosine</a> of x.\n      *\n     }\n \n     /**\n-     * Returns true iff they are equal as defined by\n-     * {@link #equals(float,float,int) equals(x, y, 1)}.\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @return {@code true} if the values are equal.\n-     */\n-    public static boolean equals(float x, float y) {\n-        return equals(x, y, 1);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are NaN or neither is NaN and they are\n-     * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @return {@code true} if the values are equal or both are NaN.\n-     * @since 2.2\n-     */\n-    public static boolean equalsIncludingNaN(float x, float y) {\n-        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, 1);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are equal or within the range of allowed\n-     * error (inclusive).\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param eps the amount of absolute error to allow.\n-     * @return {@code true} if the values are equal or within range of each other.\n-     * @since 2.2\n-     */\n-    public static boolean equals(float x, float y, float eps) {\n-        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n-    }\n-\n-    /**\n-     * Returns true if both arguments are NaN or are equal or within the range\n-     * of allowed error (inclusive).\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param eps the amount of absolute error to allow.\n-     * @return {@code true} if the values are equal or within range of each other,\n-     * or both are NaN.\n-     * @since 2.2\n-     */\n-    public static boolean equalsIncludingNaN(float x, float y, float eps) {\n-        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are equal or within the range of allowed\n-     * error (inclusive).\n-     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n-     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n-     * point numbers are considered equal.\n-     * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n-     * Bruce Dawson</a>\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n-     * values between {@code x} and {@code y}.\n-     * @return {@code true} if there are fewer than {@code maxUlps} floating\n-     * point values between {@code x} and {@code y}.\n-     * @since 2.2\n-     */\n-    public static boolean equals(float x, float y, int maxUlps) {\n-        int xInt = Float.floatToIntBits(x);\n-        int yInt = Float.floatToIntBits(y);\n-\n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK_FLOAT - xInt;\n-        }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK_FLOAT - yInt;\n-        }\n-\n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n-\n-        return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are NaN or if they are equal as defined\n-     * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n-     * values between {@code x} and {@code y}.\n-     * @return {@code true} if both arguments are NaN or if there are less than\n-     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n-     * @since 2.2\n-     */\n-    public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n-        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, maxUlps);\n-    }\n-\n-    /**\n      * Returns true iff both arguments are null or have same dimensions and all\n      * their elements are equal as defined by\n-     * {@link #equals(float,float)}.\n+     * {@link Precision#equals(float,float)}.\n      *\n      * @param x first array\n      * @param y second array\n             return false;\n         }\n         for (int i = 0; i < x.length; ++i) {\n-            if (!equals(x[i], y[i])) {\n+            if (!Precision.equals(x[i], y[i])) {\n                 return false;\n             }\n         }\n     /**\n      * Returns true iff both arguments are null or have same dimensions and all\n      * their elements are equal as defined by\n-     * {@link #equalsIncludingNaN(double,double) this method}.\n+     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n      *\n      * @param x first array\n      * @param y second array\n             return false;\n         }\n         for (int i = 0; i < x.length; ++i) {\n-            if (!equalsIncludingNaN(x[i], y[i])) {\n+            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                 return false;\n             }\n         }\n         return true;\n-    }\n-\n-    /**\n-     * Returns true iff they are equal as defined by\n-     * {@link #equals(double,double,int) equals(x, y, 1)}.\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @return {@code true} if the values are equal.\n-     */\n-    public static boolean equals(double x, double y) {\n-        return equals(x, y, 1);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are NaN or neither is NaN and they are\n-     * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @return {@code true} if the values are equal or both are NaN.\n-     * @since 2.2\n-     */\n-    public static boolean equalsIncludingNaN(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n-    }\n-\n-    /**\n-     * Returns {@code true} if there is no double value strictly between the\n-     * arguments or the difference between them is within the range of allowed\n-     * error (inclusive).\n-     *\n-     * @param x First value.\n-     * @param y Second value.\n-     * @param eps Amount of allowed absolute error.\n-     * @return {@code true} if the values are two adjacent floating point\n-     * numbers or they are within range of each other.\n-     */\n-    public static boolean equals(double x, double y, double eps) {\n-        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n-    }\n-\n-    /**\n-     * Returns true if both arguments are NaN or are equal or within the range\n-     * of allowed error (inclusive).\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param eps the amount of absolute error to allow.\n-     * @return {@code true} if the values are equal or within range of each other,\n-     * or both are NaN.\n-     * @since 2.2\n-     */\n-    public static boolean equalsIncludingNaN(double x, double y, double eps) {\n-        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are equal or within the range of allowed\n-     * error (inclusive).\n-     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n-     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n-     * point numbers are considered equal.\n-     * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n-     * Bruce Dawson</a>\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n-     * values between {@code x} and {@code y}.\n-     * @return {@code true} if there are fewer than {@code maxUlps} floating\n-     * point values between {@code x} and {@code y}.\n-     */\n-    public static boolean equals(double x, double y, int maxUlps) {\n-        long xInt = Double.doubleToLongBits(x);\n-        long yInt = Double.doubleToLongBits(y);\n-\n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK - xInt;\n-        }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK - yInt;\n-        }\n-\n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n-\n-        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n-    }\n-\n-    /**\n-     * Returns true if both arguments are NaN or if they are equal as defined\n-     * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n-     * values between {@code x} and {@code y}.\n-     * @return {@code true} if both arguments are NaN or if there are less than\n-     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n-     * @since 2.2\n-     */\n-    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n     }\n \n     /**\n      * Returns {@code true} iff both arguments are {@code null} or have same\n      * dimensions and all their elements are equal as defined by\n-     * {@link #equals(double,double)}.\n+     * {@link Precision#equals(double,double)}.\n      *\n      * @param x First array.\n      * @param y Second array.\n             return false;\n         }\n         for (int i = 0; i < x.length; ++i) {\n-            if (!equals(x[i], y[i])) {\n+            if (!Precision.equals(x[i], y[i])) {\n                 return false;\n             }\n         }\n     /**\n      * Returns {@code true} iff both arguments are {@code null} or have same\n      * dimensions and all their elements are equal as defined by\n-     * {@link #equalsIncludingNaN(double,double) this method}.\n+     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n      *\n      * @param x First array.\n      * @param y Second array.\n             return false;\n         }\n         for (int i = 0; i < x.length; ++i) {\n-            if (!equalsIncludingNaN(x[i], y[i])) {\n+            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                 return false;\n             }\n         }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/Precision.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+/**\n+ * Utilities for comparing numbers.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class Precision {\n+    /** Offset to order signed double numbers lexicographically. */\n+    private static final long SGN_MASK = 0x8000000000000000L;\n+\n+    /** Offset to order signed double numbers lexicographically. */\n+    private static final int SGN_MASK_FLOAT = 0x80000000;\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private Precision() {}\n+\n+    /**\n+     * Compares two numbers given some amount of allowed error.\n+     *\n+     * @param x the first number\n+     * @param y the second number\n+     * @param eps the amount of error to allow when checking for equality\n+     * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n+     *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n+     *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>\n+     */\n+    public static int compareTo(double x, double y, double eps) {\n+        if (equals(x, y, eps)) {\n+            return 0;\n+        } else if (x < y) {\n+            return -1;\n+        }\n+        return 1;\n+    }\n+\n+    /**\n+     * Compares two numbers given some amount of allowed error.\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n+     * point numbers are considered equal.\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n+     *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n+     *       <li>> 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y</li></ul>\n+     */\n+    public static int compareTo(final double x, final double y, final int maxUlps) {\n+        if (equals(x, y, maxUlps)) {\n+            return 0;\n+        } else if (x < y) {\n+            return -1;\n+        }\n+        return 1;\n+    }\n+\n+    /**\n+     * Returns true iff they are equal as defined by\n+     * {@link #equals(float,float,int) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal.\n+     */\n+    public static boolean equals(float x, float y) {\n+        return equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or neither is NaN and they are\n+     * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal or both are NaN.\n+     * @since 2.2\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other.\n+     * @since 2.2\n+     */\n+    public static boolean equals(float x, float y, float eps) {\n+        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or are equal or within the range\n+     * of allowed error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other,\n+     * or both are NaN.\n+     * @since 2.2\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, float eps) {\n+        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n+     * point numbers are considered equal.\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are fewer than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}.\n+     * @since 2.2\n+     */\n+    public static boolean equals(float x, float y, int maxUlps) {\n+        int xInt = Float.floatToIntBits(x);\n+        int yInt = Float.floatToIntBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK_FLOAT - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK_FLOAT - yInt;\n+        }\n+\n+        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+\n+        return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or if they are equal as defined\n+     * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if both arguments are NaN or if there are less than\n+     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     * @since 2.2\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, maxUlps);\n+    }\n+\n+    /**\n+     * Returns true iff they are equal as defined by\n+     * {@link #equals(double,double,int) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal.\n+     */\n+    public static boolean equals(double x, double y) {\n+        return equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or neither is NaN and they are\n+     * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal or both are NaN.\n+     * @since 2.2\n+     */\n+    public static boolean equalsIncludingNaN(double x, double y) {\n+        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns {@code true} if there is no double value strictly between the\n+     * arguments or the difference between them is within the range of allowed\n+     * error (inclusive).\n+     *\n+     * @param x First value.\n+     * @param y Second value.\n+     * @param eps Amount of allowed absolute error.\n+     * @return {@code true} if the values are two adjacent floating point\n+     * numbers or they are within range of each other.\n+     */\n+    public static boolean equals(double x, double y, double eps) {\n+        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or are equal or within the range\n+     * of allowed error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other,\n+     * or both are NaN.\n+     * @since 2.2\n+     */\n+    public static boolean equalsIncludingNaN(double x, double y, double eps) {\n+        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n+     * point numbers are considered equal.\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are fewer than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equals(double x, double y, int maxUlps) {\n+        long xInt = Double.doubleToLongBits(x);\n+        long yInt = Double.doubleToLongBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK - yInt;\n+        }\n+\n+        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+\n+        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or if they are equal as defined\n+     * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if both arguments are NaN or if there are less than\n+     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     * @since 2.2\n+     */\n+    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n+        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n import org.apache.commons.math.stat.inference.ChiSquareTest;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n \n /**\n     public static void assertContains(String msg, Complex[] values,\n                                       Complex z, double epsilon) {\n         for (Complex value : values) {\n-            if (MathUtils.equals(value.getReal(), z.getReal(), epsilon) &&\n-                MathUtils.equals(value.getImaginary(), z.getImaginary(), epsilon)) {\n+            if (Precision.equals(value.getReal(), z.getReal(), epsilon) &&\n+                Precision.equals(value.getImaginary(), z.getImaginary(), epsilon)) {\n                 return;\n             }\n         }\n     public static void assertContains(String msg, double[] values,\n             double x, double epsilon) {\n         for (double value : values) {\n-            if (MathUtils.equals(value, x, epsilon)) {\n+            if (Precision.equals(value, x, epsilon)) {\n                 return;\n             }\n         }\n         }\n         boolean failure = false;\n         for (int i=0; i < expected.length; i++) {\n-            if (!MathUtils.equalsIncludingNaN(expected[i], observed[i], tolerance)) {\n+            if (!Precision.equalsIncludingNaN(expected[i], observed[i], tolerance)) {\n                 failure = true;\n                 out.append(\"\\n Elements at index \");\n                 out.append(i);\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n import org.apache.commons.math.analysis.integration.LegendreGaussIntegrator;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n \n                 for (int i = 0; i < 10; ++i) {\n                     PolynomialFunction jacobi = PolynomialsUtils.createJacobiPolynomial(i, v, w);\n                     double binomial = MathUtils.binomialCoefficient(v + i, i);\n-                    Assert.assertTrue(MathUtils.equals(binomial, jacobi.value(1.0), 1));\n+                    Assert.assertTrue(Precision.equals(binomial, jacobi.value(1.0), 1));\n                 }\n             }\n         }\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n package org.apache.commons.math.distribution;\n \n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.junit.Assert;\n import org.junit.Test;\n     @Test\n     public void testDensity() {\n         ExponentialDistribution d1 = new ExponentialDistributionImpl(1);\n-        Assert.assertTrue(MathUtils.equals(0.0, d1.density(-1e-9), 1));\n-        Assert.assertTrue(MathUtils.equals(1.0, d1.density(0.0), 1));\n-        Assert.assertTrue(MathUtils.equals(0.0, d1.density(1000.0), 1));\n-        Assert.assertTrue(MathUtils.equals(FastMath.exp(-1), d1.density(1.0), 1));\n-        Assert.assertTrue(MathUtils.equals(FastMath.exp(-2), d1.density(2.0), 1));\n+        Assert.assertTrue(Precision.equals(0.0, d1.density(-1e-9), 1));\n+        Assert.assertTrue(Precision.equals(1.0, d1.density(0.0), 1));\n+        Assert.assertTrue(Precision.equals(0.0, d1.density(1000.0), 1));\n+        Assert.assertTrue(Precision.equals(FastMath.exp(-1), d1.density(1.0), 1));\n+        Assert.assertTrue(Precision.equals(FastMath.exp(-2), d1.density(2.0), 1));\n \n         ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n-        Assert.assertTrue(MathUtils.equals(1/3.0, d2.density(0.0), 1));\n+        Assert.assertTrue(Precision.equals(1/3.0, d2.density(0.0), 1));\n         // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5\n         Assert.assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n \n--- a/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n+++ b/src/test/java/org/apache/commons/math/filter/KalmanFilterTest.java\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.random.JDKRandomGenerator;\n import org.apache.commons.math.random.RandomGenerator;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n \n             // state estimate should be larger than measurement noise\n             double diff = Math.abs(constantValue - filter.getStateEstimation()[0]);\n             // System.out.println(diff);\n-            Assert.assertTrue(MathUtils.compareTo(diff, measurementNoise, 1e-6) < 0);\n+            Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0);\n         }\n \n         // error covariance should be already very low (< 0.02)\n-        Assert.assertTrue(MathUtils.compareTo(filter.getErrorCovariance()[0][0],\n+        Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[0][0],\n                                               0.02d, 1e-6) < 0);\n     }\n \n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n \n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Test;\n \n public class SimplexSolverTest {\n         SimplexSolver solver = new SimplexSolver();\n         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false);\n         \n-        Assert.assertTrue(MathUtils.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);\n+        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0);\n         Assert.assertEquals(0.0050, solution.getValue(), epsilon);\n     }\n \n         SimplexSolver simplex = new SimplexSolver();\n         RealPointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false);\n         \n-        Assert.assertTrue(MathUtils.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);\n+        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0);\n         Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon);        \n         Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon);\n         Assert.assertEquals(1.0d, solution.getValue(), epsilon);\n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.junit.Assert;\n import org.junit.Test;\n         double expectedSample[] = { -25 / Math.sqrt(1250), 25 / Math.sqrt(1250) };\n         double[] out = StatUtils.normalize(sample);\n         for (int i = 0; i < out.length; i++) {\n-            Assert.assertTrue(MathUtils.equals(out[i], expectedSample[i], 1));\n+            Assert.assertTrue(Precision.equals(out[i], expectedSample[i], 1));\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.random.RandomData;\n import org.apache.commons.math.random.RandomDataImpl;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n \n         setOneStats.addValue(7);\n         setOneStats.addValue(11);\n         Assert.assertEquals(\"Wrong number of set one values\", 5, setOneStats.getN());\n-        Assert.assertTrue(\"Wrong sum of set one values\", MathUtils.equals(28.0, setOneStats.getSum(), 1));\n+        Assert.assertTrue(\"Wrong sum of set one values\", Precision.equals(28.0, setOneStats.getSum(), 1));\n \n         setTwoStats.addValue(2);\n         setTwoStats.addValue(4);\n         setTwoStats.addValue(8);\n         Assert.assertEquals(\"Wrong number of set two values\", 3, setTwoStats.getN());\n-        Assert.assertTrue(\"Wrong sum of set two values\", MathUtils.equals(14.0, setTwoStats.getSum(), 1));\n+        Assert.assertTrue(\"Wrong sum of set two values\", Precision.equals(14.0, setTwoStats.getSum(), 1));\n \n         Assert.assertEquals(\"Wrong number of aggregate values\", 8, aggregate.getN());\n-        Assert.assertTrue(\"Wrong aggregate sum\", MathUtils.equals(42.0, aggregate.getSum(), 1));\n+        Assert.assertTrue(\"Wrong aggregate sum\", Precision.equals(42.0, aggregate.getSum(), 1));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n \n \n import org.apache.commons.math.stat.descriptive.rank.Percentile;\n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n \n             dstat.addValue(i);\n         }\n \n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean1, dstat.getMean()));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(mean1, dstat.getMean()));\n         dstat.replaceMostRecentValue(0);\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean2, dstat.getMean()));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(mean2, dstat.getMean()));\n         dstat.removeMostRecentValue();\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(mean3, dstat.getMean()));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(mean3, dstat.getMean()));\n \n     }\n \n--- a/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n import org.junit.Test;\n \n         double dResult[] = transformer.transform(dX);\n         for (int i = 0; i < dResult.length; i++) {\n             // compare computed results to precomputed results\n-            Assert.assertTrue(MathUtils.equals((double) y[i], dResult[i], 1));\n+            Assert.assertTrue(Precision.equals((double) y[i], dResult[i], 1));\n         }\n     }\n \n         double dResult[] = transformer.inversetransform(dY);\n         for (int i = 0; i < dResult.length; i++) {\n             // compare computed results to precomputed results\n-            Assert.assertTrue(MathUtils.equals((double) x[i], dResult[i], 1));\n+            Assert.assertTrue(Precision.equals((double) x[i], dResult[i], 1));\n         }\n \n     }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n     }\n \n     @Test\n-    public void testCompareToEpsilon() {\n-        Assert.assertEquals(0, MathUtils.compareTo(152.33, 152.32, .011));\n-        Assert.assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);\n-        Assert.assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);\n-        Assert.assertEquals(0, MathUtils.compareTo(Double.MIN_VALUE, +0.0, Double.MIN_VALUE));\n-        Assert.assertEquals(0, MathUtils.compareTo(Double.MIN_VALUE, -0.0, Double.MIN_VALUE));\n-    }\n-\n-    @Test\n-    public void testCompareToMaxUlps() {\n-        double a     = 152.32;\n-        double delta = FastMath.ulp(a);\n-        for (int i = 0; i <= 10; ++i) {\n-            if (i <= 5) {\n-                Assert.assertEquals( 0, MathUtils.compareTo(a, a + i * delta, 5));\n-                Assert.assertEquals( 0, MathUtils.compareTo(a, a - i * delta, 5));\n-            } else {\n-                Assert.assertEquals(-1, MathUtils.compareTo(a, a + i * delta, 5));\n-                Assert.assertEquals(+1, MathUtils.compareTo(a, a - i * delta, 5));\n-            }\n-        }\n-\n-        Assert.assertEquals( 0, MathUtils.compareTo(-0.0, 0.0, 0));\n-\n-        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, -0.0, 0));\n-        Assert.assertEquals( 0, MathUtils.compareTo(-Double.MIN_VALUE, -0.0, 1));\n-        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, +0.0, 0));\n-        Assert.assertEquals( 0, MathUtils.compareTo(-Double.MIN_VALUE, +0.0, 1));\n-\n-        Assert.assertEquals(+1, MathUtils.compareTo( Double.MIN_VALUE, -0.0, 0));\n-        Assert.assertEquals( 0, MathUtils.compareTo( Double.MIN_VALUE, -0.0, 1));\n-        Assert.assertEquals(+1, MathUtils.compareTo( Double.MIN_VALUE, +0.0, 0));\n-        Assert.assertEquals( 0, MathUtils.compareTo( Double.MIN_VALUE, +0.0, 1));\n-\n-        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 0));\n-        Assert.assertEquals(-1, MathUtils.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 1));\n-        Assert.assertEquals( 0, MathUtils.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 2));\n-\n-        Assert.assertEquals( 0, MathUtils.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n-        Assert.assertEquals(-1, MathUtils.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 0));\n-\n-        Assert.assertEquals(+1, MathUtils.compareTo(Double.MAX_VALUE, Double.NaN, Integer.MAX_VALUE));\n-        Assert.assertEquals(+1, MathUtils.compareTo(Double.NaN, Double.MAX_VALUE, Integer.MAX_VALUE));\n-\n-    }\n-\n-    @Test\n     public void testCosh() {\n         double x = 3.0;\n         double expected = 10.06766;\n     @Test\n     public void testCoshNaN() {\n         Assert.assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n-    }\n-\n-    @Test\n-    public void testEqualsIncludingNaN() {\n-        double[] testArray = {\n-            Double.NaN,\n-            Double.POSITIVE_INFINITY,\n-            Double.NEGATIVE_INFINITY,\n-            1d,\n-            0d };\n-        for (int i = 0; i < testArray.length; i++) {\n-            for (int j = 0; j < testArray.length; j++) {\n-                if (i == j) {\n-                    Assert.assertTrue(MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n-                    Assert.assertTrue(MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n-                } else {\n-                    Assert.assertTrue(!MathUtils.equalsIncludingNaN(testArray[i], testArray[j]));\n-                    Assert.assertTrue(!MathUtils.equalsIncludingNaN(testArray[j], testArray[i]));\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testEqualsWithAllowedDelta() {\n-        Assert.assertTrue(MathUtils.equals(153.0000, 153.0000, .0625));\n-        Assert.assertTrue(MathUtils.equals(153.0000, 153.0625, .0625));\n-        Assert.assertTrue(MathUtils.equals(152.9375, 153.0000, .0625));\n-        Assert.assertFalse(MathUtils.equals(153.0000, 153.0625, .0624));\n-        Assert.assertFalse(MathUtils.equals(152.9374, 153.0000, .0625));\n-        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1.0));\n-        Assert.assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-        Assert.assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n-        Assert.assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-    }\n-\n-    @Test\n-    public void testMath475() {\n-        final double a = 1.7976931348623182E16;\n-        final double b = FastMath.nextUp(a);\n-\n-        double diff = FastMath.abs(a - b);\n-        // Because they are adjacent floating point numbers, \"a\" and \"b\" are\n-        // considered equal even though the allowed error is smaller than\n-        // their difference.\n-        Assert.assertTrue(MathUtils.equals(a, b, 0.5 * diff));\n-\n-        final double c = FastMath.nextUp(b);\n-        diff = FastMath.abs(a - c);\n-        // Because \"a\" and \"c\" are not adjacent, the tolerance is taken into\n-        // account for assessing equality.\n-        Assert.assertTrue(MathUtils.equals(a, c, diff));\n-        Assert.assertFalse(MathUtils.equals(a, c, (1 - 1e-16) * diff));\n-    }\n-\n-    @Test\n-    public void testEqualsIncludingNaNWithAllowedDelta() {\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0000, .0625));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0625));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(152.9375, 153.0000, .0625));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(153.0000, 153.0625, .0624));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(152.9374, 153.0000, .0625));\n-    }\n-\n-    // Tests for floating point equality\n-    @Test\n-    public void testFloatEqualsWithAllowedUlps() {\n-        Assert.assertTrue(\"+0.0f == -0.0f\",MathUtils.equals(0.0f, -0.0f));\n-        Assert.assertTrue(\"+0.0f == -0.0f (1 ulp)\",MathUtils.equals(0.0f, -0.0f, 1));\n-        float oneFloat = 1.0f;\n-        Assert.assertTrue(\"1.0f == 1.0f + 1 ulp\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));\n-        Assert.assertTrue(\"1.0f == 1.0f + 1 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1));\n-        Assert.assertFalse(\"1.0f != 1.0f + 2 ulp (1 ulp)\",MathUtils.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1));\n-\n-        Assert.assertTrue(MathUtils.equals(153.0f, 153.0f, 1));\n-\n-        // These tests need adjusting for floating point precision\n-//        Assert.assertTrue(MathUtils.equals(153.0f, 153.00000000000003f, 1));\n-//        Assert.assertFalse(MathUtils.equals(153.0f, 153.00000000000006f, 1));\n-//        Assert.assertTrue(MathUtils.equals(153.0f, 152.99999999999997f, 1));\n-//        Assert.assertFalse(MathUtils.equals(153f, 152.99999999999994f, 1));\n-//\n-//        Assert.assertTrue(MathUtils.equals(-128.0f, -127.99999999999999f, 1));\n-//        Assert.assertFalse(MathUtils.equals(-128.0f, -127.99999999999997f, 1));\n-//        Assert.assertTrue(MathUtils.equals(-128.0f, -128.00000000000003f, 1));\n-//        Assert.assertFalse(MathUtils.equals(-128.0f, -128.00000000000006f, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1));\n-        Assert.assertTrue(MathUtils.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1));\n-        Assert.assertTrue(MathUtils.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1));\n-\n-        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 1));\n-        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NaN, 0));\n-        Assert.assertFalse(MathUtils.equals(Float.NaN, 0, 0));\n-        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.POSITIVE_INFINITY, 0));\n-        Assert.assertFalse(MathUtils.equals(Float.NaN, Float.NEGATIVE_INFINITY, 0));\n-\n-        Assert.assertFalse(MathUtils.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000));\n-    }\n-\n-    @Test\n-    public void testEqualsWithAllowedUlps() {\n-        Assert.assertTrue(MathUtils.equals(0.0, -0.0, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(1.0, 1 + FastMath.ulp(1d), 1));\n-        Assert.assertFalse(MathUtils.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n-\n-        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n-        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n-        Assert.assertTrue(MathUtils.equals(1.0, nUp1, 1));\n-        Assert.assertTrue(MathUtils.equals(nUp1, nnUp1, 1));\n-        Assert.assertFalse(MathUtils.equals(1.0, nnUp1, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(0.0, FastMath.ulp(0d), 1));\n-        Assert.assertTrue(MathUtils.equals(0.0, -FastMath.ulp(0d), 1));\n-\n-        Assert.assertTrue(MathUtils.equals(153.0, 153.0, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(153.0, 153.00000000000003, 1));\n-        Assert.assertFalse(MathUtils.equals(153.0, 153.00000000000006, 1));\n-        Assert.assertTrue(MathUtils.equals(153.0, 152.99999999999997, 1));\n-        Assert.assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(-128.0, -127.99999999999999, 1));\n-        Assert.assertFalse(MathUtils.equals(-128.0, -127.99999999999997, 1));\n-        Assert.assertTrue(MathUtils.equals(-128.0, -128.00000000000003, 1));\n-        Assert.assertFalse(MathUtils.equals(-128.0, -128.00000000000006, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n-        Assert.assertTrue(MathUtils.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n-\n-        Assert.assertTrue(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n-        Assert.assertTrue(MathUtils.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n-\n-        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 1));\n-        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NaN, 0));\n-        Assert.assertFalse(MathUtils.equals(Double.NaN, 0, 0));\n-        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.POSITIVE_INFINITY, 0));\n-        Assert.assertFalse(MathUtils.equals(Double.NaN, Double.NEGATIVE_INFINITY, 0));\n-\n-        Assert.assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n-    }\n-\n-    @Test\n-    public void testEqualsIncludingNaNWithAllowedUlps() {\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, -0.0, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n-\n-        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n-        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(1.0, nUp1, 1));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(nUp1, nnUp1, 1));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(1.0, nnUp1, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.0, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 153.00000000000003, 1));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(153.0, 153.00000000000006, 1));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(153.0, 152.99999999999997, 1));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(153, 152.99999999999994, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999999, 1));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(-128.0, -127.99999999999997, 1));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000003, 1));\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(-128.0, -128.00000000000006, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n-\n-        Assert.assertTrue(MathUtils.equalsIncludingNaN(Double.NaN, Double.NaN, 1));\n-\n-        Assert.assertFalse(MathUtils.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n     }\n \n     @Test\n     public void testL1DistanceDouble() {\n         double[] p1 = { 2.5,  0.0 };\n         double[] p2 = { -0.5, 4.0 };\n-        Assert.assertTrue(MathUtils.equals(7.0, MathUtils.distance1(p1, p2), 1));\n+        Assert.assertTrue(Precision.equals(7.0, MathUtils.distance1(p1, p2), 1));\n     }\n \n     @Test\n     public void testL2DistanceDouble() {\n         double[] p1 = { 2.5,  0.0 };\n         double[] p2 = { -0.5, 4.0 };\n-        Assert.assertTrue(MathUtils.equals(5.0, MathUtils.distance(p1, p2), 1));\n+        Assert.assertTrue(Precision.equals(5.0, MathUtils.distance(p1, p2), 1));\n     }\n \n     @Test\n     public void testL2DistanceInt() {\n         int[] p1 = { 3, 0 };\n         int[] p2 = { 0, 4 };\n-        Assert.assertTrue(MathUtils.equals(5, MathUtils.distance(p1, p2), 1));\n+        Assert.assertTrue(Precision.equals(5, MathUtils.distance(p1, p2), 1));\n     }\n \n     @Test\n     public void testLInfDistanceDouble() {\n         double[] p1 = { 2.5,  0.0 };\n         double[] p2 = { -0.5, 4.0 };\n-        Assert.assertTrue(MathUtils.equals(4.0, MathUtils.distanceInf(p1, p2), 1));\n+        Assert.assertTrue(Precision.equals(4.0, MathUtils.distanceInf(p1, p2), 1));\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n             if (!keysInMap.contains(mapEntry.getKey()))\n                 ++mapSize;\n             Assert.assertEquals(mapSize, map.size());\n-            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n+            Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n         }\n     }\n \n         for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n             Assert.assertEquals(++size, map.size());\n-            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n+            Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n         }\n     }\n \n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) {\n             map.put(mapEntry.getKey(), mapEntry.getValue());\n             Assert.assertEquals(javaMap.size(), map.size());\n-            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n+            Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1));\n         }\n     }\n \n         Assert.assertEquals(javaMap.size(), copy.size());\n \n         for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet())\n-            Assert.assertTrue(MathUtils.equals(mapEntry.getValue(), copy.get(mapEntry.getKey()), 1));\n+            Assert.assertTrue(Precision.equals(mapEntry.getValue(), copy.get(mapEntry.getKey()), 1));\n     }\n \n     @Test\n         map.put(key2, value1);\n         int key3 = 1008859686;\n         map.put(key3, value1);\n-        Assert.assertTrue(MathUtils.equals(value1, map.get(key3), 1));\n+        Assert.assertTrue(Precision.equals(value1, map.get(key3), 1));\n         Assert.assertEquals(3, map.size());\n \n         map.remove(key2);\n         double value2 = 2.0;\n         map.put(key3, value2);\n-        Assert.assertTrue(MathUtils.equals(value2, map.get(key3), 1));\n+        Assert.assertTrue(Precision.equals(value2, map.get(key3), 1));\n         Assert.assertEquals(2, map.size());\n     }\n \n         int key2 = 476463321;\n         map.put(key2, value1);\n         Assert.assertEquals(2, map.size());\n-        Assert.assertTrue(MathUtils.equals(value1, map.get(key2), 1));\n+        Assert.assertTrue(Precision.equals(value1, map.get(key2), 1));\n \n         map.remove(key1);\n         double value2 = 2.0;\n         map.put(key2, value2);\n         Assert.assertEquals(1, map.size());\n-        Assert.assertTrue(MathUtils.equals(value2, map.get(key2), 1));\n+        Assert.assertTrue(Precision.equals(value2, map.get(key2), 1));\n     }\n \n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/PrecisionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for the {@link Precision} class.\n+ *\n+ * @version $Id$\n+ */\n+public class PrecisionTest {\n+    @Test\n+    public void testEqualsIncludingNaN() {\n+        double[] testArray = {\n+            Double.NaN,\n+            Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY,\n+            1d,\n+            0d };\n+        for (int i = 0; i < testArray.length; i++) {\n+            for (int j = 0; j < testArray.length; j++) {\n+                if (i == j) {\n+                    Assert.assertTrue(Precision.equalsIncludingNaN(testArray[i], testArray[j]));\n+                    Assert.assertTrue(Precision.equalsIncludingNaN(testArray[j], testArray[i]));\n+                } else {\n+                    Assert.assertTrue(!Precision.equalsIncludingNaN(testArray[i], testArray[j]));\n+                    Assert.assertTrue(!Precision.equalsIncludingNaN(testArray[j], testArray[i]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEqualsWithAllowedDelta() {\n+        Assert.assertTrue(Precision.equals(153.0000, 153.0000, .0625));\n+        Assert.assertTrue(Precision.equals(153.0000, 153.0625, .0625));\n+        Assert.assertTrue(Precision.equals(152.9375, 153.0000, .0625));\n+        Assert.assertFalse(Precision.equals(153.0000, 153.0625, .0624));\n+        Assert.assertFalse(Precision.equals(152.9374, 153.0000, .0625));\n+        Assert.assertFalse(Precision.equals(Double.NaN, Double.NaN, 1.0));\n+        Assert.assertTrue(Precision.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        Assert.assertTrue(Precision.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n+        Assert.assertFalse(Precision.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+    }\n+\n+    @Test\n+    public void testMath475() {\n+        final double a = 1.7976931348623182E16;\n+        final double b = FastMath.nextUp(a);\n+\n+        double diff = FastMath.abs(a - b);\n+        // Because they are adjacent floating point numbers, \"a\" and \"b\" are\n+        // considered equal even though the allowed error is smaller than\n+        // their difference.\n+        Assert.assertTrue(Precision.equals(a, b, 0.5 * diff));\n+\n+        final double c = FastMath.nextUp(b);\n+        diff = FastMath.abs(a - c);\n+        // Because \"a\" and \"c\" are not adjacent, the tolerance is taken into\n+        // account for assessing equality.\n+        Assert.assertTrue(Precision.equals(a, c, diff));\n+        Assert.assertFalse(Precision.equals(a, c, (1 - 1e-16) * diff));\n+    }\n+\n+    @Test\n+    public void testEqualsIncludingNaNWithAllowedDelta() {\n+        Assert.assertTrue(Precision.equalsIncludingNaN(153.0000, 153.0000, .0625));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(153.0000, 153.0625, .0625));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(152.9375, 153.0000, .0625));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(153.0000, 153.0625, .0624));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(152.9374, 153.0000, .0625));\n+    }\n+\n+    // Tests for floating point equality\n+    @Test\n+    public void testFloatEqualsWithAllowedUlps() {\n+        Assert.assertTrue(\"+0.0f == -0.0f\",Precision.equals(0.0f, -0.0f));\n+        Assert.assertTrue(\"+0.0f == -0.0f (1 ulp)\",Precision.equals(0.0f, -0.0f, 1));\n+        float oneFloat = 1.0f;\n+        Assert.assertTrue(\"1.0f == 1.0f + 1 ulp\",Precision.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat))));\n+        Assert.assertTrue(\"1.0f == 1.0f + 1 ulp (1 ulp)\",Precision.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1));\n+        Assert.assertFalse(\"1.0f != 1.0f + 2 ulp (1 ulp)\",Precision.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1));\n+\n+        Assert.assertTrue(Precision.equals(153.0f, 153.0f, 1));\n+\n+        // These tests need adjusting for floating point precision\n+//        Assert.assertTrue(Precision.equals(153.0f, 153.00000000000003f, 1));\n+//        Assert.assertFalse(Precision.equals(153.0f, 153.00000000000006f, 1));\n+//        Assert.assertTrue(Precision.equals(153.0f, 152.99999999999997f, 1));\n+//        Assert.assertFalse(Precision.equals(153f, 152.99999999999994f, 1));\n+//\n+//        Assert.assertTrue(Precision.equals(-128.0f, -127.99999999999999f, 1));\n+//        Assert.assertFalse(Precision.equals(-128.0f, -127.99999999999997f, 1));\n+//        Assert.assertTrue(Precision.equals(-128.0f, -128.00000000000003f, 1));\n+//        Assert.assertFalse(Precision.equals(-128.0f, -128.00000000000006f, 1));\n+\n+        Assert.assertTrue(Precision.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1));\n+        Assert.assertTrue(Precision.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(Precision.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1));\n+        Assert.assertTrue(Precision.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1));\n+\n+        Assert.assertFalse(Precision.equals(Float.NaN, Float.NaN, 1));\n+        Assert.assertFalse(Precision.equals(Float.NaN, Float.NaN, 0));\n+        Assert.assertFalse(Precision.equals(Float.NaN, 0, 0));\n+        Assert.assertFalse(Precision.equals(Float.NaN, Float.POSITIVE_INFINITY, 0));\n+        Assert.assertFalse(Precision.equals(Float.NaN, Float.NEGATIVE_INFINITY, 0));\n+\n+        Assert.assertFalse(Precision.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    @Test\n+    public void testEqualsWithAllowedUlps() {\n+        Assert.assertTrue(Precision.equals(0.0, -0.0, 1));\n+\n+        Assert.assertTrue(Precision.equals(1.0, 1 + FastMath.ulp(1d), 1));\n+        Assert.assertFalse(Precision.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n+\n+        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n+        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n+        Assert.assertTrue(Precision.equals(1.0, nUp1, 1));\n+        Assert.assertTrue(Precision.equals(nUp1, nnUp1, 1));\n+        Assert.assertFalse(Precision.equals(1.0, nnUp1, 1));\n+\n+        Assert.assertTrue(Precision.equals(0.0, FastMath.ulp(0d), 1));\n+        Assert.assertTrue(Precision.equals(0.0, -FastMath.ulp(0d), 1));\n+\n+        Assert.assertTrue(Precision.equals(153.0, 153.0, 1));\n+\n+        Assert.assertTrue(Precision.equals(153.0, 153.00000000000003, 1));\n+        Assert.assertFalse(Precision.equals(153.0, 153.00000000000006, 1));\n+        Assert.assertTrue(Precision.equals(153.0, 152.99999999999997, 1));\n+        Assert.assertFalse(Precision.equals(153, 152.99999999999994, 1));\n+\n+        Assert.assertTrue(Precision.equals(-128.0, -127.99999999999999, 1));\n+        Assert.assertFalse(Precision.equals(-128.0, -127.99999999999997, 1));\n+        Assert.assertTrue(Precision.equals(-128.0, -128.00000000000003, 1));\n+        Assert.assertFalse(Precision.equals(-128.0, -128.00000000000006, 1));\n+\n+        Assert.assertTrue(Precision.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        Assert.assertTrue(Precision.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(Precision.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        Assert.assertTrue(Precision.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+        Assert.assertFalse(Precision.equals(Double.NaN, Double.NaN, 1));\n+        Assert.assertFalse(Precision.equals(Double.NaN, Double.NaN, 0));\n+        Assert.assertFalse(Precision.equals(Double.NaN, 0, 0));\n+        Assert.assertFalse(Precision.equals(Double.NaN, Double.POSITIVE_INFINITY, 0));\n+        Assert.assertFalse(Precision.equals(Double.NaN, Double.NEGATIVE_INFINITY, 0));\n+\n+        Assert.assertFalse(Precision.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    @Test\n+    public void testEqualsIncludingNaNWithAllowedUlps() {\n+        Assert.assertTrue(Precision.equalsIncludingNaN(0.0, -0.0, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1));\n+\n+        final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY);\n+        final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY);\n+        Assert.assertTrue(Precision.equalsIncludingNaN(1.0, nUp1, 1));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(nUp1, nnUp1, 1));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(1.0, nnUp1, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(153.0, 153.0, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(153.0, 153.00000000000003, 1));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(153.0, 153.00000000000006, 1));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(153.0, 152.99999999999997, 1));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(153, 152.99999999999994, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(-128.0, -127.99999999999999, 1));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(-128.0, -127.99999999999997, 1));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(-128.0, -128.00000000000003, 1));\n+        Assert.assertFalse(Precision.equalsIncludingNaN(-128.0, -128.00000000000006, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1));\n+        Assert.assertTrue(Precision.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1));\n+\n+        Assert.assertTrue(Precision.equalsIncludingNaN(Double.NaN, Double.NaN, 1));\n+\n+        Assert.assertFalse(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n+    }\n+\n+    @Test\n+    public void testCompareToEpsilon() {\n+        Assert.assertEquals(0, Precision.compareTo(152.33, 152.32, .011));\n+        Assert.assertTrue(Precision.compareTo(152.308, 152.32, .011) < 0);\n+        Assert.assertTrue(Precision.compareTo(152.33, 152.318, .011) > 0);\n+        Assert.assertEquals(0, Precision.compareTo(Double.MIN_VALUE, +0.0, Double.MIN_VALUE));\n+        Assert.assertEquals(0, Precision.compareTo(Double.MIN_VALUE, -0.0, Double.MIN_VALUE));\n+    }\n+\n+    @Test\n+    public void testCompareToMaxUlps() {\n+        double a     = 152.32;\n+        double delta = FastMath.ulp(a);\n+        for (int i = 0; i <= 10; ++i) {\n+            if (i <= 5) {\n+                Assert.assertEquals( 0, Precision.compareTo(a, a + i * delta, 5));\n+                Assert.assertEquals( 0, Precision.compareTo(a, a - i * delta, 5));\n+            } else {\n+                Assert.assertEquals(-1, Precision.compareTo(a, a + i * delta, 5));\n+                Assert.assertEquals(+1, Precision.compareTo(a, a - i * delta, 5));\n+            }\n+        }\n+\n+        Assert.assertEquals( 0, Precision.compareTo(-0.0, 0.0, 0));\n+\n+        Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, -0.0, 0));\n+        Assert.assertEquals( 0, Precision.compareTo(-Double.MIN_VALUE, -0.0, 1));\n+        Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, +0.0, 0));\n+        Assert.assertEquals( 0, Precision.compareTo(-Double.MIN_VALUE, +0.0, 1));\n+\n+        Assert.assertEquals(+1, Precision.compareTo( Double.MIN_VALUE, -0.0, 0));\n+        Assert.assertEquals( 0, Precision.compareTo( Double.MIN_VALUE, -0.0, 1));\n+        Assert.assertEquals(+1, Precision.compareTo( Double.MIN_VALUE, +0.0, 0));\n+        Assert.assertEquals( 0, Precision.compareTo( Double.MIN_VALUE, +0.0, 1));\n+\n+        Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 0));\n+        Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 1));\n+        Assert.assertEquals( 0, Precision.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 2));\n+\n+        Assert.assertEquals( 0, Precision.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1));\n+        Assert.assertEquals(-1, Precision.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 0));\n+\n+        Assert.assertEquals(+1, Precision.compareTo(Double.MAX_VALUE, Double.NaN, Integer.MAX_VALUE));\n+        Assert.assertEquals(+1, Precision.compareTo(Double.NaN, Double.MAX_VALUE, Integer.MAX_VALUE));\n+\n+    }\n+}", "timestamp": 1318286154, "metainfo": ""}