{"sha": "1fbd10671e6dc5c5d1ec966d657ca35f3fe81316", "log": "MATH-120: finished review of pascal distribution.  ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactory.java\n      * @param numberOfSuccesses the number of successes.\n      * @param probabilityOfSuccess the probability of success\n      * @return a new Pascal distribution\n-     */\n-    public abstract PascalDistribution createPascalDistribution(\n-        int numberOfSuccesses, double probabilityOfSuccess);\n+     * @since 1.2\n+     */\n+    public PascalDistribution createPascalDistribution(\n+        int numberOfSuccesses, double probabilityOfSuccess) {\n+        return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);\n+    }\n     \n     /**\n      * Create a new cauchy distribution with the given median and scale.\n--- a/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/DistributionFactoryImpl.java\n     public PoissonDistribution  createPoissonDistribution(double lambda) {\n         return new PoissonDistributionImpl(lambda);\n     }\n-\n-    /**\n-     * Create a Pascal distribution with the given number of successes and\n-     * probability of success.\n-     * \n-     * @param numberOfSuccesses the number of successes.\n-     * @param probabilityOfSuccess the probability of success\n-     * @return a new Pascal distribution\n-     */\n-    public PascalDistribution createPascalDistribution(int numberOfSuccesses, double probabilityOfSuccess) {\n-        return new PascalDistributionImpl(numberOfSuccesses, probabilityOfSuccess);\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/PascalDistribution.java\n package org.apache.commons.math.distribution;\n \n /**\n- * The Pascal Distribution.\n+ * The Pascal distribution.  The Pascal distribution is a special case of the\n+ * Negative Binomial distribution where the number of successes parameter is an\n+ * integer.\n+ * \n+ * There are various ways to express the probability mass and distribution\n+ * functions for the Pascal distribution.  The convention employed by the\n+ * library is to express these functions in terms of the number of failures in\n+ * a Bernoulli experiment [2].\n  *\n  * Instances of PascalDistribution objects should be created using\n  * {@link DistributionFactory#createPascalDistribution(int, double)}.\n  *\n  * <p>\n  * References:\n- * <ul>\n+ * <ol>\n  * <li><a href=\"http://mathworld.wolfram.com/NegativeBinomialDistribution.html\">\n  * Negative Binomial Distribution</a></li>\n+ * <oi><a href=\"http://en.wikipedia.org/wiki/Negative_binomial_distribution#Waiting_time_in_a_Bernoulli_process\">Waiting Time in a Bernoulli Process</a></li>\n  * </ul>\n  * </p>\n  *\n  * @version $Revision:$\n+ * @since 1.2\n  */\n public interface PascalDistribution extends IntegerDistribution {\n     /**\n--- a/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n \n /**\n  * The default implementation of {@link PascalDistribution}.\n- *\n  * @version $Revision:$\n+ * @since 1.2\n  */\n-public class PascalDistributionImpl\n-    extends AbstractIntegerDistribution\n+public class PascalDistributionImpl extends AbstractIntegerDistribution\n     implements PascalDistribution, Serializable {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 6751309484392813623L;\n \n-    /** The number of trials */\n+    /** The number of successes */\n     private int numberOfSuccesses;\n \n     /** The probability of success */\n     /**\n      * Create a binomial distribution with the given number of trials and\n      * probability of success.\n-     * \n      * @param r the number of successes\n      * @param p the probability of success\n      */\n     }\n \n     /**\n-     * Access the number of trials for this distribution.\n-     * \n-     * @return the number of trials\n+     * Access the number of successes for this distribution.\n+     * @return the number of successes\n      */\n     public int getNumberOfSuccesses() {\n         return numberOfSuccesses;\n \n     /**\n      * Access the probability of success for this distribution.\n-     * \n      * @return the probability of success\n      */\n     public double getProbabilityOfSuccess() {\n     }\n \n     /**\n-     * Change the number of trials for this distribution.\n-     * \n-     * @param successes the new number of trials\n-     * @throws IllegalArgumentException if <code>trials</code> is not positive.\n+     * Change the number of successes for this distribution.\n+     * @param successes the new number of successes\n+     * @throws IllegalArgumentException if <code>successes</code> is not\n+     *         positive.\n      */\n     public void setNumberOfSuccesses(int successes) {\n         if (successes < 0) {\n-            throw new IllegalArgumentException(\"number of trials must be non-negative.\");\n+            throw new IllegalArgumentException(\n+                \"number of successes must be non-negative.\");\n         }\n         numberOfSuccesses = successes;\n     }\n \n     /**\n      * Change the probability of success for this distribution.\n-     * \n      * @param p the new probability of success\n      * @throws IllegalArgumentException if <code>p</code> is not a valid\n      *         probability.\n      */\n     public void setProbabilityOfSuccess(double p) {\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\"probability of success must be between 0.0 and 1.0, inclusive.\");\n+            throw new IllegalArgumentException(\n+                \"probability of success must be between 0.0 and 1.0, inclusive.\");\n         }\n         probabilityOfSuccess = p;\n     }\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n      * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n+     *         <code>p</code>\n      */\n     protected int getDomainLowerBound(double p) {\n         return -1;\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n      * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n+     *         <code>p</code>\n      */\n     protected int getDomainUpperBound(double p) {\n-      // use MAX - 1 because MAX causes loop\n-      return Integer.MAX_VALUE - 1;\n+        // use MAX - 1 because MAX causes loop\n+        return Integer.MAX_VALUE - 1;\n     }\n \n     /**\n      * For this distribution, X, this method returns P(X &le; x).\n-     * \n      * @param x the value at which the PDF is evaluated\n      * @return PDF for this distribution\n-     * @throws MathException if the cumulative probability can not be\n-     *            computed due to convergence or other numerical errors\n+     * @throws MathException if the cumulative probability can not be computed\n+     *         due to convergence or other numerical errors\n      */\n     public double cumulativeProbability(int x) throws MathException {\n         double ret;\n         if (x < 0) {\n             ret = 0.0;\n         } else {\n-            ret = Beta.regularizedBeta(\n-                        getProbabilityOfSuccess(),\n-                        getNumberOfSuccesses(),\n-                        x + 1);\n+            ret = Beta.regularizedBeta(getProbabilityOfSuccess(),\n+                getNumberOfSuccesses(), x + 1);\n         }\n         return ret;\n     }\n \n     /**\n      * For this distribution, X, this method returns P(X = x).\n-     * \n      * @param x the value at which the PMF is evaluated\n-     * @return PMF for this distribution \n+     * @return PMF for this distribution\n      */\n     public double probability(int x) {\n         double ret;\n         if (x < 0) {\n             ret = 0.0;\n         } else {\n-            ret = MathUtils.binomialCoefficientDouble(x + getNumberOfSuccesses() - 1,\n-                    getNumberOfSuccesses() - 1) *\n-                  Math.pow(getProbabilityOfSuccess(), getNumberOfSuccesses()) *\n-                  Math.pow(1.0 - getProbabilityOfSuccess(),\n-                        x);\n+            ret = MathUtils.binomialCoefficientDouble(x\n+                + getNumberOfSuccesses() - 1, getNumberOfSuccesses() - 1)\n+                * Math.pow(getProbabilityOfSuccess(), getNumberOfSuccesses())\n+                * Math.pow(1.0 - getProbabilityOfSuccess(), x);\n         }\n         return ret;\n     }\n-    \n+\n     /**\n-     * For this distribution, X, this method returns the largest x, such\n-     * that P(X &le; x) &le; <code>p</code>.\n+     * For this distribution, X, this method returns the largest x, such that\n+     * P(X &le; x) &le; <code>p</code>.\n      * <p>\n-     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code> for\n-     * p=1.\n-     *\n+     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code>\n+     * for p=1.\n      * @param p the desired probability\n      * @return the largest x such that P(X &le; x) <= p\n      * @throws MathException if the inverse cumulative probability can not be\n-     *            computed due to convergence or other numerical errors.\n+     *         computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if p < 0 or p > 1\n      */\n-    public int inverseCumulativeProbability(final double p) throws MathException {\n+    public int inverseCumulativeProbability(final double p)\n+        throws MathException {\n+        int ret;\n+\n         // handle extreme values explicitly\n         if (p == 0) {\n-            return -1;\n-        } \n-        if (p == 1) {\n-            return Integer.MAX_VALUE; \n+            ret = -1;\n+        } else if (p == 1) {\n+            ret = Integer.MAX_VALUE;\n+        } else {\n+            ret = super.inverseCumulativeProbability(p);\n         }\n-        \n-        // use default bisection impl\n-        return super.inverseCumulativeProbability(p);\n+\n+        return ret;\n     }\n }", "timestamp": 1175784528, "metainfo": ""}