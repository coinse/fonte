{"sha": "c48b86ec87c50896f9c272b5475430dd8ac06f2f", "log": "Updated throws declaration for random package (and part of distribution).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n      *\n      * @param shape the shape parameter\n      * @param scale the scale parameter\n-     */\n-    public GammaDistribution(double shape, double scale) {\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n+     */\n+    public GammaDistribution(double shape, double scale) throws NotStrictlyPositiveException {\n         this(shape, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/exception/NotANumberException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.exception;\n+\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a number is not a n umber.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class NotANumberException extends MathIllegalNumberException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = 20120906L;\n+\n+    /**\n+     * Construct the exception.\n+     */\n+    public NotANumberException() {\n+        super(LocalizedFormats.NAN_NOT_ALLOWED, Double.NaN);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n     INITIAL_CAPACITY_NOT_POSITIVE(\"initial capacity ({0}) is not positive\"),\n     INITIAL_COLUMN_AFTER_FINAL_COLUMN(\"initial column {1} after final column {0}\"),\n     INITIAL_ROW_AFTER_FINAL_ROW(\"initial row {1} after final row {0}\"),\n+    @Deprecated\n     INPUT_DATA_FROM_UNSUPPORTED_DATASOURCE(\"input data comes from unsupported datasource: {0}, supported sources: {1}, {2}\"),\n     INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES(\"instance of class {0} not comparable to existing values\"),\n     INSUFFICIENT_DATA_FOR_T_STATISTIC(\"insufficient data for t statistic, needs at least 2, got {0}\"),\n--- a/src/main/java/org/apache/commons/math3/random/RandomData.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomData.java\n package org.apache.commons.math3.random;\n import java.util.Collection;\n \n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+\n /**\n  * Random data generation utilities.\n  * @deprecated to be removed in 4.0.  Use {@link RandomDataGenerator} directly\n      *\n      * @param len the length of the string to be generated\n      * @return a random string of hex characters of length {@code len}\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n+     * @throws NotStrictlyPositiveException\n      * if {@code len <= 0}\n      */\n-    String nextHexString(int len);\n+    String nextHexString(int len) throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a uniformly distributed random integer between {@code lower}\n      * @param upper upper bound for generated integer\n      * @return a random integer greater than or equal to {@code lower}\n      * and less than or equal to {@code upper}\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code lower >= upper}\n-     */\n-    int nextInt(int lower, int upper);\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     */\n+    int nextInt(int lower, int upper) throws NumberIsTooLargeException;\n \n     /**\n      * Generates a uniformly distributed random long integer between\n      * @param upper upper bound for generated long integer\n      * @return a random long integer greater than or equal to {@code lower} and\n      * less than or equal to {@code upper}\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code lower >= upper}.\n-     */\n-    long nextLong(long lower, long upper);\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     */\n+    long nextLong(long lower, long upper) throws NumberIsTooLargeException;\n \n     /**\n      * Generates a random string of hex characters from a secure random\n      *\n      * @param len the length of the string to be generated\n      * @return a random string of hex characters of length {@code len}\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if {@code len <= 0}\n-     */\n-    String nextSecureHexString(int len);\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}\n+     */\n+    String nextSecureHexString(int len) throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a uniformly distributed random integer between {@code lower}\n      * @param upper upper bound for generated integer\n      * @return a random integer greater than or equal to {@code lower} and less\n      * than or equal to {@code upper}.\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code lower >= upper}.\n-     */\n-    int nextSecureInt(int lower, int upper);\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    int nextSecureInt(int lower, int upper) throws NumberIsTooLargeException;\n \n     /**\n      * Generates a uniformly distributed random long integer between\n      * @param upper upper bound for generated integer\n      * @return a random long integer greater than or equal to {@code lower} and\n      * less than or equal to {@code upper}.\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code lower >= upper}.\n-     */\n-    long nextSecureLong(long lower, long upper);\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     */\n+    long nextSecureLong(long lower, long upper) throws NumberIsTooLargeException;\n \n     /**\n      * Generates a random value from the Poisson distribution with the given\n      *\n      * @param mean the mean of the Poisson distribution\n      * @return a random value following the specified Poisson distribution\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if {@code mean <= 0}.\n-     */\n-    long nextPoisson(double mean);\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n+     */\n+    long nextPoisson(double mean) throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a random value from the Normal (or Gaussian) distribution with\n      * @param mu the mean of the distribution\n      * @param sigma the standard deviation of the distribution\n      * @return a random value following the specified Gaussian distribution\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if {@code sigma <= 0}.\n-     */\n-    double nextGaussian(double mu, double sigma);\n+     * @throws NotStrictlyPositiveException if {@code sigma <= 0}.\n+     */\n+    double nextGaussian(double mu, double sigma) throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a random value from the exponential distribution\n      *\n      * @param mean the mean of the distribution\n      * @return a random value following the specified exponential distribution\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if {@code mean <= 0}.\n-     */\n-    double nextExponential(double mean);\n+     * @throws NotStrictlyPositiveException if {@code mean <= 0}.\n+     */\n+    double nextExponential(double mean) throws NotStrictlyPositiveException;\n \n     /**\n      * Generates a uniformly distributed random value from the open interval\n      * @param upper the exclusive upper bound of the support\n      * @return a uniformly distributed random value between lower and upper\n      * (exclusive)\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code lower >= upper}\n-     */\n-    double nextUniform(double lower, double upper);\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     * @throws NotFiniteNumberException if one of the bounds is infinite\n+     * @throws NotANumberException if one of the bounds is infinite\n+     */\n+    double nextUniform(double lower, double upper)\n+        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException;\n \n     /**\n      * Generates a uniformly distributed random value from the interval\n      * interval, if {@code lowerInclusive} is {@code false}, or in the\n      * {@code [lower, upper)} interval, if {@code lowerInclusive} is\n      * {@code true}\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code lower >= upper}\n-     */\n-    double nextUniform(double lower, double upper, boolean lowerInclusive);\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     * @throws NotFiniteNumberException if one of the bounds is infinite\n+     * @throws NotANumberException if one of the bounds is infinite\n+     */\n+    double nextUniform(double lower, double upper, boolean lowerInclusive)\n+        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException;\n \n     /**\n      * Generates an integer array of length {@code k} whose entries are selected\n      * @param k the size of the permutation\n      * @return a random {@code k}-permutation of {@code n}, as an array of\n      * integers\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code k > n}.\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if {@code k <= 0}.\n-     */\n-    int[] nextPermutation(int n, int k);\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n+     */\n+    int[] nextPermutation(int n, int k)\n+        throws NumberIsTooLargeException, NotStrictlyPositiveException;\n \n     /**\n      * Returns an array of {@code k} objects selected randomly from the\n      * @param c the collection to be sampled\n      * @param k the size of the sample\n      * @return a random sample of {@code k} elements from {@code c}\n-     * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n-     * if {@code k > c.size()}.\n-     * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n-     * if {@code k <= 0}.\n-     */\n-    Object[] nextSample(Collection<?> c, int k);\n+     * @throws NumberIsTooLargeException if {@code k > c.size()}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n+     */\n+    Object[] nextSample(Collection<?> c, int k)\n+        throws NumberIsTooLargeException, NotStrictlyPositiveException;\n+\n }\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n import org.apache.commons.math3.distribution.WeibullDistribution;\n import org.apache.commons.math3.distribution.ZipfDistribution;\n import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n \n      * @return the random string.\n      * @throws NotStrictlyPositiveException if {@code len <= 0}.\n      */\n-    public String nextHexString(int len) {\n+    public String nextHexString(int len) throws NotStrictlyPositiveException {\n         if (len <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n         }\n     }\n \n     /** {@inheritDoc} */\n-    public int nextInt(int lower, int upper) {\n+    public int nextInt(int lower, int upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n     }\n \n     /** {@inheritDoc} */\n-    public long nextLong(long lower, long upper) {\n+    public long nextLong(long lower, long upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n      * Each byte of the binary digest is converted to 2 hex digits.</li>\n      * </ol>\n      * </p>\n-     */\n-    public String nextSecureHexString(int len) {\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}\n+     */\n+    public String nextSecureHexString(int len) throws NotStrictlyPositiveException {\n         if (len <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);\n         }\n     }\n \n     /**  {@inheritDoc} */\n-    public int nextSecureInt(int lower, int upper) {\n+    public int nextSecureInt(int lower, int upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n     }\n \n     /** {@inheritDoc} */\n-    public long nextSecureLong(long lower, long upper) {\n+    public long nextSecureLong(long lower, long upper) throws NumberIsTooLargeException {\n         if (lower >= upper) {\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n      * <li> For large means, uses the rejection algorithm described in <br/>\n      * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n      * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n-     */\n-    public long nextPoisson(double mean) {\n+     * @throws NotStrictlyPositiveException if {@code len <= 0}\n+     */\n+    public long nextPoisson(double mean) throws NotStrictlyPositiveException {\n         return new PoissonDistribution(getRan(), mean,\n                 PoissonDistribution.DEFAULT_EPSILON,\n                 PoissonDistribution.DEFAULT_MAX_ITERATIONS).sample();\n     }\n \n     /** {@inheritDoc} */\n-    public double nextGaussian(double mu, double sigma) {\n+    public double nextGaussian(double mu, double sigma) throws NotStrictlyPositiveException {\n         if (sigma <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);\n         }\n      * Communications of the ACM, 15, 873-882.\n      * </p>\n      */\n-    public double nextExponential(double mean) {\n+    public double nextExponential(double mean) throws NotStrictlyPositiveException {\n         return new ExponentialDistribution(getRan(), mean,\n                 ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n      * @param shape the median of the Gamma distribution\n      * @param scale the scale parameter of the Gamma distribution\n      * @return random value sampled from the Gamma(shape, scale) distribution\n-     */\n-    public double nextGamma(double shape, double scale) {\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n+     */\n+    public double nextGamma(double shape, double scale) throws NotStrictlyPositiveException {\n         return new GammaDistribution(getRan(),shape, scale,\n                 GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n      * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution\n      * @param sampleSize the sample size of the Hypergeometric distribution\n      * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution\n-     */\n-    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {\n+     * @throws NumberIsTooLargeException  if {@code numberOfSuccesses > populationSize},\n+     * or {@code sampleSize > populationSize}.\n+     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n+     * @throws NotPositiveException  if {@code numberOfSuccesses < 0}.\n+     */\n+    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n         return new HypergeometricDistribution(getRan(),populationSize,\n                 numberOfSuccesses, sampleSize).sample();\n     }\n      * @param r the number of successes of the Pascal distribution\n      * @param p the probability of success of the Pascal distribution\n      * @return random value sampled from the Pascal(r, p) distribution\n-     */\n-    public int nextPascal(int r, double p) {\n+     * @throws NotStrictlyPositiveException if the number of successes is not positive\n+     * @throws OutOfRangeException if the probability of success is not in the\n+     * range {@code [0, 1]}.\n+     */\n+    public int nextPascal(int r, double p) throws NotStrictlyPositiveException, OutOfRangeException {\n         return new PascalDistribution(getRan(), r, p).sample();\n     }\n \n      *\n      * @param df the degrees of freedom of the T distribution\n      * @return random value from the T(df) distribution\n-     */\n-    public double nextT(double df) {\n+     * @throws NotStrictlyPositiveException if {@code df <= 0}\n+     */\n+    public double nextT(double df) throws NotStrictlyPositiveException {\n         return new TDistribution(getRan(), df,\n                 TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n      * @param shape the shape parameter of the Weibull distribution\n      * @param scale the scale parameter of the Weibull distribution\n      * @return random value sampled from the Weibull(shape, size) distribution\n-     */\n-    public double nextWeibull(double shape, double scale) {\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n+     */\n+    public double nextWeibull(double shape, double scale) throws NotStrictlyPositiveException {\n         return new WeibullDistribution(getRan(), shape, scale,\n                 WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n      * @param numberOfElements the number of elements of the ZipfDistribution\n      * @param exponent the exponent of the ZipfDistribution\n      * @return random value sampled from the Zipf(numberOfElements, exponent) distribution\n-     */\n-    public int nextZipf(int numberOfElements, double exponent) {\n+     * @exception NotStrictlyPositiveException if {@code numberOfElements <= 0}\n+     * or {@code exponent <= 0}.\n+     */\n+    public int nextZipf(int numberOfElements, double exponent) throws NotStrictlyPositiveException {\n         return new ZipfDistribution(getRan(), numberOfElements, exponent).sample();\n     }\n \n      * @param numeratorDf the numerator degrees of freedom of the F distribution\n      * @param denominatorDf the denominator degrees of freedom of the F distribution\n      * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n-     */\n-    public double nextF(double numeratorDf, double denominatorDf) {\n+     * @throws NotStrictlyPositiveException if\n+     * {@code numeratorDf <= 0} or {@code denominatorDf <= 0}.\n+     */\n+    public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException {\n         return new FDistribution(getRan(), numeratorDf, denominatorDf,\n                 FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY).sample();\n     }\n      * random double if Random.nextDouble() returns 0). This is necessary to\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n-     *\n-     * @throws MathIllegalArgumentException if one of the bounds is infinite or\n-     * {@code NaN} or either bound is infinite or NaN\n-     */\n-    public double nextUniform(double lower, double upper) {\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     * @throws NotFiniteNumberException if one of the bounds is infinite\n+     * @throws NotANumberException if one of the bounds is not a number\n+     */\n+    public double nextUniform(double lower, double upper)\n+        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n         return nextUniform(lower, upper, false);\n     }\n \n      * endpoints excluded).\n      * </p>\n      *\n-     * @throws MathIllegalArgumentException if one of the bounds is infinite or\n+     * @throws N if one of the bounds is infinite or\n      * {@code NaN}\n-     */\n-    public double nextUniform(double lower, double upper,\n-        boolean lowerInclusive) {\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}\n+     * @throws NotFiniteNumberException if one of the bounds is infinite\n+     * @throws NotANumberException if one of the bounds is not a number\n+     */\n+    public double nextUniform(double lower, double upper, boolean lowerInclusive)\n+        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n \n         if (lower >= upper) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n \n-        if (Double.isInfinite(lower) || Double.isInfinite(upper)) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);\n+        if (Double.isInfinite(lower)) {\n+            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, lower);\n+        }\n+        if (Double.isInfinite(upper)) {\n+            throw new NotFiniteNumberException(LocalizedFormats.INFINITE_BOUND, upper);\n         }\n \n         if (Double.isNaN(lower) || Double.isNaN(upper)) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n+            throw new NotANumberException();\n         }\n \n         final RandomGenerator generator = getRan();\n      * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>.\n      * </p>\n-     */\n-    public int[] nextPermutation(int n, int k) {\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n+     * @throws NotStrictlyPositiveException if {@code k <= 0}.\n+     */\n+    public int[] nextPermutation(int n, int k)\n+        throws NumberIsTooLargeException, NotStrictlyPositiveException {\n         if (k > n) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n+            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                                 k, n, true);\n         }\n         if (k <= 0) {\n      * here</a>\n      * </p>\n      */\n-    public Object[] nextSample(Collection<?> c, int k) {\n+    public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException {\n \n         int len = c.size();\n         if (k > len) {\n      * @param list list to be shuffled\n      * @param end element past which shuffling begins\n      */\n-    private void shuffle(int[] list, int end) {\n+    private void shuffle(int[] list, int end) throws NumberIsTooLargeException {\n         int target = 0;\n         for (int i = list.length - 1; i >= end; i--) {\n             if (i == 0) {\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataImpl.java\n \n import org.apache.commons.math3.distribution.IntegerDistribution;\n import org.apache.commons.math3.distribution.RealDistribution;\n+import org.apache.commons.math3.exception.NotANumberException;\n+import org.apache.commons.math3.exception.NotFiniteNumberException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n \n /**\n  * Generates random deviates and other random data using a {@link RandomGenerator}\n      * @return the random string.\n      * @throws NotStrictlyPositiveException if {@code len <= 0}.\n      */\n-    public String nextHexString(int len) {\n+    public String nextHexString(int len) throws NotStrictlyPositiveException {\n         return delegate.nextHexString(len);\n     }\n \n     /** {@inheritDoc} */\n-    public int nextInt(int lower, int upper) {\n+    public int nextInt(int lower, int upper) throws NumberIsTooLargeException {\n        return delegate.nextInt(lower, upper);\n     }\n \n     /** {@inheritDoc} */\n-    public long nextLong(long lower, long upper) {\n+    public long nextLong(long lower, long upper) throws NumberIsTooLargeException {\n         return delegate.nextLong(lower, upper);\n     }\n \n      * </ol>\n      * </p>\n      */\n-    public String nextSecureHexString(int len) {\n+    public String nextSecureHexString(int len) throws NotStrictlyPositiveException {\n         return delegate.nextSecureHexString(len);\n     }\n \n     /**  {@inheritDoc} */\n-    public int nextSecureInt(int lower, int upper) {\n+    public int nextSecureInt(int lower, int upper) throws NumberIsTooLargeException {\n         return delegate.nextSecureInt(lower, upper);\n     }\n \n     /** {@inheritDoc} */\n-    public long nextSecureLong(long lower, long upper) {\n+    public long nextSecureLong(long lower, long upper) throws NumberIsTooLargeException {\n         return delegate.nextSecureLong(lower,upper);\n     }\n \n      * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n      * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n      */\n-    public long nextPoisson(double mean) {\n+    public long nextPoisson(double mean) throws NotStrictlyPositiveException {\n         return delegate.nextPoisson(mean);\n     }\n \n     /** {@inheritDoc} */\n-    public double nextGaussian(double mu, double sigma) {\n+    public double nextGaussian(double mu, double sigma) throws NotStrictlyPositiveException {\n         return delegate.nextGaussian(mu,sigma);\n     }\n \n      * Communications of the ACM, 15, 873-882.\n      * </p>\n      */\n-    public double nextExponential(double mean) {\n+    public double nextExponential(double mean) throws NotStrictlyPositiveException {\n         return delegate.nextExponential(mean);\n     }\n \n      * random double if Random.nextDouble() returns 0). This is necessary to\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n-     *\n-     * @throws MathIllegalArgumentException if one of the bounds is infinite or\n-     * {@code NaN} or either bound is infinite or NaN\n-     */\n-    public double nextUniform(double lower, double upper) {\n+     */\n+    public double nextUniform(double lower, double upper)\n+        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n         return delegate.nextUniform(lower, upper);\n     }\n \n      * This is necessary to provide a symmetric output interval (both\n      * endpoints excluded).\n      * </p>\n-     *\n-     * @throws MathIllegalArgumentException if one of the bounds is infinite or\n-     * {@code NaN}\n      * @since 3.0\n      */\n-    public double nextUniform(double lower, double upper,\n-        boolean lowerInclusive) {\n+    public double nextUniform(double lower, double upper, boolean lowerInclusive)\n+        throws NumberIsTooLargeException, NotFiniteNumberException, NotANumberException {\n         return delegate.nextUniform(lower, upper, lowerInclusive);\n     }\n \n      * @param numeratorDf the numerator degrees of freedom of the F distribution\n      * @param denominatorDf the denominator degrees of freedom of the F distribution\n      * @return random value sampled from the F(numeratorDf, denominatorDf) distribution\n-     * @since 2.2\n-     */\n-    public double nextF(double numeratorDf, double denominatorDf) {\n+     * @throws NotStrictlyPositiveException if\n+     * {@code numeratorDf <= 0} or {@code denominatorDf <= 0}.\n+     * @since 2.2\n+     */\n+    public double nextF(double numeratorDf, double denominatorDf) throws NotStrictlyPositiveException {\n         return delegate.nextF(numeratorDf, denominatorDf);\n     }\n \n      * @param shape the median of the Gamma distribution\n      * @param scale the scale parameter of the Gamma distribution\n      * @return random value sampled from the Gamma(shape, scale) distribution\n-     * @since 2.2\n-     */\n-    public double nextGamma(double shape, double scale) {\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n+     * @since 2.2\n+     */\n+    public double nextGamma(double shape, double scale) throws NotStrictlyPositiveException {\n         return delegate.nextGamma(shape, scale);\n     }\n \n      * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution\n      * @param sampleSize the sample size of the Hypergeometric distribution\n      * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution\n-     * @since 2.2\n-     */\n-    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {\n+     * @throws NumberIsTooLargeException  if {@code numberOfSuccesses > populationSize},\n+     * or {@code sampleSize > populationSize}.\n+     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n+     * @throws NotPositiveException  if {@code numberOfSuccesses < 0}.\n+     * @since 2.2\n+     */\n+    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize)\n+        throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n         return delegate.nextHypergeometric(populationSize, numberOfSuccesses, sampleSize);\n     }\n \n      * @param p the probability of success of the Pascal distribution\n      * @return random value sampled from the Pascal(r, p) distribution\n      * @since 2.2\n-     */\n-    public int nextPascal(int r, double p) {\n+     * @throws NotStrictlyPositiveException if the number of successes is not positive\n+     * @throws OutOfRangeException if the probability of success is not in the\n+     * range {@code [0, 1]}.\n+     */\n+    public int nextPascal(int r, double p)\n+        throws NotStrictlyPositiveException, OutOfRangeException {\n         return delegate.nextPascal(r, p);\n     }\n \n      * @param df the degrees of freedom of the T distribution\n      * @return random value from the T(df) distribution\n      * @since 2.2\n-     */\n-    public double nextT(double df) {\n+     * @throws NotStrictlyPositiveException if {@code df <= 0}\n+     */\n+    public double nextT(double df) throws NotStrictlyPositiveException {\n         return delegate.nextT(df);\n     }\n \n      * @param scale the scale parameter of the Weibull distribution\n      * @return random value sampled from the Weibull(shape, size) distribution\n      * @since 2.2\n-     */\n-    public double nextWeibull(double shape, double scale) {\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n+     */\n+    public double nextWeibull(double shape, double scale) throws NotStrictlyPositiveException {\n         return delegate.nextWeibull(shape, scale);\n     }\n \n      * @param exponent the exponent of the ZipfDistribution\n      * @return random value sampled from the Zipf(numberOfElements, exponent) distribution\n      * @since 2.2\n-     */\n-    public int nextZipf(int numberOfElements, double exponent) {\n+     * @exception NotStrictlyPositiveException if {@code numberOfElements <= 0}\n+     * or {@code exponent <= 0}.\n+     */\n+    public int nextZipf(int numberOfElements, double exponent) throws NotStrictlyPositiveException {\n         return delegate.nextZipf(numberOfElements, exponent);\n     }\n \n      * here</a>.\n      * </p>\n      */\n-    public int[] nextPermutation(int n, int k) {\n+    public int[] nextPermutation(int n, int k)\n+        throws NotStrictlyPositiveException, NumberIsTooLargeException {\n         return delegate.nextPermutation(n, k);\n     }\n \n      * here</a>\n      * </p>\n      */\n-    public Object[] nextSample(Collection<?> c, int k) {\n+    public Object[] nextSample(Collection<?> c, int k)\n+        throws NotStrictlyPositiveException, NumberIsTooLargeException {\n         return delegate.nextSample(c, k);\n     }\n \n      *\n      * @param distribution Continuous distribution to generate a random value from\n      * @return a random value sampled from the given distribution\n+     * @throws MathIllegalArgumentException if the underlynig distribution throws one \n      * @since 2.2\n      * @deprecated use the distribution's sample() method\n      */\n-    public double nextInversionDeviate(RealDistribution distribution) {\n+    public double nextInversionDeviate(RealDistribution distribution)\n+        throws MathIllegalArgumentException {\n         return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n \n     }\n      *\n      * @param distribution Integer distribution to generate a random value from\n      * @return a random value sampled from the given distribution\n+     * @throws MathIllegalArgumentException if the underlynig distribution throws one \n      * @since 2.2\n      * @deprecated use the distribution's sample() method\n      */\n-    public int nextInversionDeviate(IntegerDistribution distribution) {\n+    public int nextInversionDeviate(IntegerDistribution distribution)\n+        throws MathIllegalArgumentException {\n         return distribution.inverseCumulativeProbability(nextUniform(0, 1));\n     }\n \n--- a/src/main/java/org/apache/commons/math3/random/StableRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/StableRandomGenerator.java\n      * @param generator underlying random generator to use\n      * @param alpha Stability parameter. Must be in range (0, 2]\n      * @param beta Skewness parameter. Must be in range [-1, 1]\n+     * @throws NullArgumentException if generator is null\n+     * @throws OutOfRangeException if {@code alpha <= 0} or {@code alpha > 2} \n+     * or {@code beta < -1} or {@code beta > 1} \n      */\n-    public StableRandomGenerator(final RandomGenerator generator, double alpha,\n-            double beta) {\n+    public StableRandomGenerator(final RandomGenerator generator,\n+                                 final double alpha, final double beta)\n+        throws NullArgumentException, OutOfRangeException {\n         if (generator == null) {\n             throw new NullArgumentException();\n         }\n--- a/src/main/java/org/apache/commons/math3/random/ValueServer.java\n+++ b/src/main/java/org/apache/commons/math3/random/ValueServer.java\n import java.net.MalformedURLException;\n import java.net.URL;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n      *\n      * @return generated value\n      * @throws IOException in REPLAY_MODE if a file I/O error occurs\n-     */\n-    public double getNext() throws IOException {\n+     * @throws MathIllegalStateException if mode is not recognized\n+     * @throws MathIllegalArgumentException if the underlying random generator thwrows one\n+     */\n+    public double getNext() throws IOException, MathIllegalStateException, MathIllegalArgumentException {\n         switch (mode) {\n             case DIGEST_MODE: return getNextDigest();\n             case REPLAY_MODE: return getNextReplay();\n      *\n      * @param values array to be filled\n      * @throws IOException in REPLAY_MODE if a file I/O error occurs\n-     */\n-    public void fill(double[] values) throws IOException {\n+     * @throws MathIllegalStateException if mode is not recognized\n+     * @throws MathIllegalArgumentException if the underlying random generator thwrows one\n+     */\n+    public void fill(double[] values)\n+        throws IOException, MathIllegalStateException, MathIllegalArgumentException {\n         for (int i = 0; i < values.length; i++) {\n             values[i] = getNext();\n         }\n      * @param length length of output array\n      * @return array of generated values\n      * @throws IOException in REPLAY_MODE if a file I/O error occurs\n-     */\n-    public double[] fill(int length) throws IOException {\n+     * @throws MathIllegalStateException if mode is not recognized\n+     * @throws MathIllegalArgumentException if the underlying random generator thwrows one\n+     */\n+    public double[] fill(int length)\n+        throws IOException, MathIllegalStateException, MathIllegalArgumentException {\n         double[] out = new double[length];\n         for (int i = 0; i < length; i++) {\n             out[i] = getNext();\n      * with <code>mode = DIGEST_MODE</code></p>\n      *\n      * @throws IOException if an I/O error occurs reading the input file\n-     */\n-    public void computeDistribution() throws IOException {\n+     * @throws NullArgumentException \n+      * @throws ZeroException if URL contains no data\n+     */\n+    public void computeDistribution() throws IOException, ZeroException, NullArgumentException {\n         computeDistribution(EmpiricalDistribution.DEFAULT_BIN_COUNT);\n     }\n \n      *\n      * @param binCount the number of bins used in computing the empirical\n      * distribution\n+     * @throws NullArgumentException \n      * @throws IOException if an error occurs reading the input file\n-     */\n-    public void computeDistribution(int binCount)\n-            throws IOException {\n+     * @throws ZeroException if URL contains no data\n+     */\n+    public void computeDistribution(int binCount) throws NullArgumentException, IOException, ZeroException {\n         empiricalDistribution = new EmpiricalDistribution(binCount, randomData);\n         empiricalDistribution.load(valuesFileURL);\n         mu = empiricalDistribution.getSampleStats().getMean();\n      * <code>IllegalStateException</code> will be thrown</li></ul></p>\n      *\n      * @return next random value from the empirical distribution digest\n-     */\n-    private double getNextDigest() {\n+     * @throws MathIllegalStateException if digest has not been initialized\n+     */\n+    private double getNextDigest() throws MathIllegalStateException {\n         if ((empiricalDistribution == null) ||\n             (empiricalDistribution.getBinStats().size() == 0)) {\n             throw new MathIllegalStateException(LocalizedFormats.DIGEST_NOT_INITIALIZED);\n      *\n      * @return next value from the replay file\n      * @throws IOException if there is a problem reading from the file\n+     * @throws MathIllegalStateException if URL contains no data\n      * @throws NumberFormatException if an invalid numeric string is\n      *   encountered in the file\n      */\n-    private double getNextReplay() throws IOException {\n+    private double getNextReplay() throws IOException, MathIllegalStateException {\n         String str = null;\n         if (filePointer == null) {\n             resetReplayFile();\n      * Gets a uniformly distributed random value with mean = mu.\n      *\n      * @return random uniform value\n-     */\n-    private double getNextUniform() {\n+     * @throws MathIllegalArgumentException if the underlying random generator thwrows one\n+     */\n+    private double getNextUniform() throws MathIllegalArgumentException {\n         return randomData.nextUniform(0, 2 * mu);\n     }\n \n      * Gets an exponentially distributed random value with mean = mu.\n      *\n      * @return random exponential value\n-     */\n-    private double getNextExponential() {\n+     * @throws MathIllegalArgumentException if the underlying random generator thwrows one\n+     */\n+    private double getNextExponential() throws MathIllegalArgumentException {\n         return randomData.nextExponential(mu);\n     }\n \n      * and standard deviation = sigma.\n      *\n      * @return random Gaussian value\n-     */\n-    private double getNextGaussian() {\n+     * @throws MathIllegalArgumentException if the underlying random generator thwrows one\n+     */\n+    private double getNextGaussian() throws MathIllegalArgumentException {\n         return randomData.nextGaussian(mu, sigma);\n     }\n ", "timestamp": 1347288465, "metainfo": ""}