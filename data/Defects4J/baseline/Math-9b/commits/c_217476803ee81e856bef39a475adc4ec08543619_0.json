{"sha": "217476803ee81e856bef39a475adc4ec08543619", "log": "MATH-697 Added \"optimize\" method to allow passing simple bounds.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n     public RealPointValuePair optimize(int maxEval, final FUNC f,\n                                        final GoalType goal,\n                                        double[] startPoint) {\n+        return optimize(maxEval, f, goal, startPoint, null, null);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public RealPointValuePair optimize(int maxEval, final FUNC f,\n+                                       final GoalType goal,\n+                                       double[] startPoint,\n+                                       double[] lowerBound, double[] upperBound) {\n         maxEvaluations = maxEval;\n         RuntimeException lastException = null;\n         optima = new RealPointValuePair[starts];\n             // CHECKSTYLE: stop IllegalCatch\n             try {\n                 optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal,\n-                                               i == 0 ? startPoint : generator.nextVector());\n+                                               i == 0 ? startPoint : generator.nextVector(),\n+                                               lowerBound, upperBound);\n             } catch (RuntimeException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n      */\n     RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                 double[] startPoint);\n+\n+    /**\n+     * Optimize an objective function.\n+     *\n+     * @param f Objective function.\n+     * @param goalType Type of optimization goal: either\n+     * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n+     * @param startPoint Start point for optimization.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @param lowerBound Lower bound for each of the parameters.\n+     * @param upperBound Upper bound for each of the parameters.\n+     * @return the point/value pair giving the optimal value for objective\n+     * function.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the array sizes are wrong.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.NullArgumentException if\n+     * {@code f}, {@code goalType} or {@code startPoint} is {@code null}.\n+     */\n+    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                double[] startPoint,\n+                                double[] lowerBound, double[] upperBound);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n     private GoalType goal;\n     /** Initial guess. */\n     private double[] start;\n+    /** Lower bounds. */\n+    private double[] lowerBound;\n+    /** Upper bounds. */\n+    private double[] upperBound;\n     /** Objective function. */\n     private MultivariateRealFunction function;\n \n     /** {@inheritDoc} */\n     public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                        double[] startPoint) {\n+        return optimize(maxEval, f, goalType, startPoint, null, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                       double[] startPoint,\n+                                       double[] lower, double[] upper) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n         function = f;\n         goal = goalType;\n         start = startPoint.clone();\n+        final int dim = startPoint.length;\n+        if (lower == null) {\n+            lowerBound = new double[dim];\n+            for (int i = 0; i < dim; i++) {\n+                lowerBound[i] = Double.NEGATIVE_INFINITY;\n+            }\n+        } else {\n+            lowerBound = lower.clone();\n+        }\n+        if (upper == null) {\n+            upperBound = new double[dim];\n+            for (int i = 0; i < dim; i++) {\n+                upperBound[i] = Double.POSITIVE_INFINITY;\n+            }\n+        } else {\n+            upperBound = upper.clone();\n+        }\n \n         // Perform computation.\n         return doOptimize();\n     }\n \n     /**\n+     * @return the lower bounds.\n+     */\n+    public double[] getLowerBound() {\n+        return lowerBound.clone();\n+    }\n+\n+    /**\n+     * @return the upper bounds.\n+     */\n+    public double[] getUpperBound() {\n+        return upperBound.clone();\n+    }\n+\n+    /**\n      * Perform the bulk of the optimization algorithm.\n      *\n      * @return the point/value pair giving the optimal value for the\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n                                        final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n                                        final double[] startPoint) {\n+        return optimize(maxEval, f, goalType, startPoint, null, null);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealPointValuePair optimize(int maxEval,\n+                                       final DifferentiableMultivariateRealFunction f,\n+                                       final GoalType goalType,\n+                                       final double[] startPoint,\n+                                       double[] lowerBound, double[] upperBound) {\n         // Store optimization problem characteristics.\n         gradient = f.gradient();\n \n-        return super.optimize(maxEval, f, goalType, startPoint);\n+        return super.optimize(maxEval, f, goalType,\n+                              startPoint,\n+                              lowerBound, upperBound);\n     }\n }", "timestamp": 1319834649, "metainfo": ""}