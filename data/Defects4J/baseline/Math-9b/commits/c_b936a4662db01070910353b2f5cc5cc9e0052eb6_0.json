{"sha": "b936a4662db01070910353b2f5cc5cc9e0052eb6", "log": "Merged BetaDistribution and BetaDistributionImpl (MATH-711).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n  */\n package org.apache.commons.math.distribution;\n \n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.FastMath;\n+\n /**\n- * Computes the cumulative, inverse cumulative and density functions for the beta distribuiton.\n+ * Implements the Beta distribution.\n  *\n- * @see <a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">Beta_distribution</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">Beta distribution</a>\n  * @version $Id$\n- * @since 2.0\n+ * @since 2.0 (changed to concrete class in 3.0)\n  */\n-public interface BetaDistribution extends ContinuousDistribution {\n-     /**\n-      * Access the alpha shape parameter.\n-      *\n-      * @return alpha.\n-      */\n-     double getAlpha();\n-\n-     /**\n-      * Access the beta shape parameter.\n-      *\n-      * @return beta.\n-      */\n-     double getBeta();\n+public class BetaDistribution extends AbstractContinuousDistribution {\n+    /**\n+     * Default inverse cumulative probability accuracy.\n+     * @since 2.1\n+     */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1221965979403477668L;\n+    /** First shape parameter. */\n+    private final double alpha;\n+    /** Second shape parameter. */\n+    private final double beta;\n+    /** Normalizing factor used in density computations.\n+     * updated whenever alpha or beta are changed.\n+     */\n+    private double z;\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Build a new instance.\n+     *\n+     * @param alpha First shape parameter (must be positive).\n+     * @param beta Second shape parameter (must be positive).\n+     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @since 2.1\n+     */\n+    public BetaDistribution(double alpha, double beta, double inverseCumAccuracy) {\n+        this.alpha = alpha;\n+        this.beta = beta;\n+        z = Double.NaN;\n+        solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Build a new instance.\n+     *\n+     * @param alpha First shape parameter (must be positive).\n+     * @param beta Second shape parameter (must be positive).\n+     */\n+    public BetaDistribution(double alpha, double beta) {\n+        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Access the first shape parameter, {@code alpha}.\n+     *\n+     * @return the first shape parameter.\n+     */\n+    public double getAlpha() {\n+        return alpha;\n+    }\n+\n+    /**\n+     * Access the second shape parameter, {@code beta}.\n+     *\n+     * @return the second shape parameter.\n+     */\n+    public double getBeta() {\n+        return beta;\n+    }\n+\n+    /** Recompute the normalization factor. */\n+    private void recomputeZ() {\n+        if (Double.isNaN(z)) {\n+            z = Gamma.logGamma(alpha) + Gamma.logGamma(beta) - Gamma.logGamma(alpha + beta);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(double x) {\n+        recomputeZ();\n+        if (x < 0 || x > 1) {\n+            return 0;\n+        } else if (x == 0) {\n+            if (alpha < 1) {\n+                throw new NumberIsTooSmallException(LocalizedFormats.CANNOT_COMPUTE_BETA_DENSITY_AT_0_FOR_SOME_ALPHA, alpha, 1, false);\n+            }\n+            return 0;\n+        } else if (x == 1) {\n+            if (beta < 1) {\n+                throw new NumberIsTooSmallException(LocalizedFormats.CANNOT_COMPUTE_BETA_DENSITY_AT_1_FOR_SOME_BETA, beta, 1, false);\n+            }\n+            return 0;\n+        } else {\n+            double logX = FastMath.log(x);\n+            double log1mX = FastMath.log1p(-x);\n+            return FastMath.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double inverseCumulativeProbability(double p)  {\n+        if (p == 0) {\n+            return 0;\n+        } else if (p == 1) {\n+            return 1;\n+        } else {\n+            return super.inverseCumulativeProbability(p);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        return p;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x)  {\n+        if (x <= 0) {\n+            return 0;\n+        } else if (x >= 1) {\n+            return 1;\n+        } else {\n+            return Beta.regularizedBeta(x, alpha, beta);\n+        }\n+    }\n+\n+    /**\n+     * Return the absolute accuracy setting of the solver used to estimate\n+     * inverse cumulative probabilities.\n+     *\n+     * @return the solver absolute accuracy.\n+     * @since 2.1\n+     */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The lower bound of the support is always 0 no matter the parameters.\n+     *\n+     * @return lower bound of the support (always 0)\n+     */\n+    @Override\n+    public double getSupportLowerBound() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The upper bound of the support is always 1 no matter the parameters.\n+     *\n+     * @return upper bound of the support (always 1)\n+     */\n+    @Override\n+    public double getSupportUpperBound() {\n+        return 1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For first shape parameter {@code alpha} and second shape parameter {@code beta}, the\n+     * mean is {@code alpha / (alpha + beta)}.\n+     */\n+    @Override\n+    protected double calculateNumericalMean() {\n+        final double a = getAlpha();\n+        return a / (a + getBeta());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * For first shape parameter {@code alpha} and second shape parameter\n+     * {@code beta}, the variance is\n+     * {@code (alpha * beta) / [(alpha + beta)^2 * (alpha + beta + 1)]}.\n+     */\n+    @Override\n+    protected double calculateNumericalVariance() {\n+        final double a = getAlpha();\n+        final double b = getBeta();\n+        final double alphabetasum = a + b;\n+        return (a * b) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportLowerBoundInclusive() {\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.security.SecureRandom;\n import java.util.Collection;\n \n-import org.apache.commons.math.distribution.BetaDistributionImpl;\n+import org.apache.commons.math.distribution.BetaDistribution;\n import org.apache.commons.math.distribution.BinomialDistributionImpl;\n import org.apache.commons.math.distribution.CauchyDistributionImpl;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n     }\n \n     /**\n-     * Generates a random value from the {@link BetaDistributionImpl Beta Distribution}.\n+     * Generates a random value from the {@link BetaDistribution Beta Distribution}.\n      * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}\n      * to generate random values.\n      *\n      * @since 2.2\n      */\n     public double nextBeta(double alpha, double beta) {\n-        return nextInversionDeviate(new BetaDistributionImpl(alpha, beta));\n+        return nextInversionDeviate(new BetaDistribution(alpha, beta));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BetaDistributionTest.java\n     }\n \n     private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) {\n-        BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n+        BetaDistribution d = new BetaDistribution(alpha, beta);\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);\n         }\n     }\n \n     private void checkDensity(double alpha, double beta, double[] x, double[] expected) {\n-        BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n+        BetaDistribution d = new BetaDistribution(alpha, beta);\n         for (int i = 0; i < x.length; i++) {\n             Assert.assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n         }\n     public void testMoments() {\n         final double tol = 1e-9;\n         BetaDistribution dist;\n-        \n-        dist = new BetaDistributionImpl(1, 1);\n+\n+        dist = new BetaDistribution(1, 1);\n         Assert.assertEquals(dist.getNumericalMean(), 0.5, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol); \n-        \n-        dist = new BetaDistributionImpl(2, 5);\n+        Assert.assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol);\n+\n+        dist = new BetaDistribution(2, 5);\n         Assert.assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol);\n-        Assert.assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol); \n+        Assert.assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.Retry;\n import org.apache.commons.math.RetryRunner;\n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.distribution.BetaDistributionImpl;\n+import org.apache.commons.math.distribution.BetaDistribution;\n import org.apache.commons.math.distribution.BinomialDistributionImpl;\n import org.apache.commons.math.distribution.BinomialDistributionTest;\n import org.apache.commons.math.distribution.CauchyDistributionImpl;\n         }\n         // Reseed again so the inversion generator gets the same sequence\n         randomData.reSeed(100);\n-        BetaDistributionImpl betaDistribution = new BetaDistributionImpl(2, 4);\n+        BetaDistribution betaDistribution = new BetaDistribution(2, 4);\n         /*\n          *  Generate a sequence of deviates using inversion - the distribution function\n          *  evaluated at the random value from the distribution should match the uniform\n \n     @Test\n     public void testNextBeta() throws Exception {\n-        double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistributionImpl(2,5));\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistribution(2,5));\n         long[] counts = new long[4];\n         randomData.reSeed(1000);\n         for (int i = 0; i < 1000; i++) {", "timestamp": 1322118452, "metainfo": ""}