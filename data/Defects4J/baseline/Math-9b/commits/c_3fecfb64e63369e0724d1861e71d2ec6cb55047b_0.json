{"sha": "3fecfb64e63369e0724d1861e71d2ec6cb55047b", "log": "MATH-650 move static setup methods to helper class  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.util;\n-\n-import org.apache.commons.math.exception.DimensionMismatchException;\n \n /**\n  * Faster, more accurate, portable alternative to {@link Math} and\n \n                 // Populate expIntTable\n                 for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n-                    expint(i, tmp);\n+                    FastMathCalc.expint(i, tmp);\n                     EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n                     EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n \n                     if (i != 0) {\n                         // Negative integer powers\n-                        splitReciprocal(tmp, recip);\n+                        FastMathCalc.splitReciprocal(tmp, recip);\n                         EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n                         EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n                     }\n \n                   // Populate expFracTable\n                   for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n-                      slowexp(i/1024.0, tmp); // TWO_POWER_10\n+                      FastMathCalc.slowexp(i/1024.0, tmp); // TWO_POWER_10\n                       EXP_FRAC_TABLE_A[i] = tmp[0];\n                       EXP_FRAC_TABLE_B[i] = tmp[1];\n                   }\n           }\n       }\n \n-    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n-    private static final double FACT[] = new double[] \n-        {\n-        +1.0d,                        // 0               \n-        +1.0d,                        // 1\n-        +2.0d,                        // 2\n-        +6.0d,                        // 3\n-        +24.0d,                       // 4\n-        +120.0d,                      // 5\n-        +720.0d,                      // 6\n-        +5040.0d,                     // 7\n-        +40320.0d,                    // 8\n-        +362880.0d,                   // 9\n-        +3628800.0d,                  // 10\n-        +39916800.0d,                 // 11\n-        +479001600.0d,                // 12\n-        +6227020800.0d,               // 13\n-        +87178291200.0d,              // 14\n-        +1307674368000.0d,            // 15\n-        +20922789888000.0d,           // 16\n-        +355687428096000.0d,          // 17\n-        +6402373705728000.0d,         // 18\n-        +121645100408832000.0d,       // 19\n-        };\n-\n     private static final int LN_MANT_LEN = 1024; // MAGIC NUMBER\n \n     // Enclose large data table in nested static class so it's only loaded on first access\n                   // Populate lnMant table\n                   for (int i = 0; i < LN_MANT.length; i++) {\n                       final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n-                      LN_MANT[i] = slowLog(d);\n+                      LN_MANT[i] = FastMathCalc.slowLog(d);\n                   }\n               } else {\n                   LN_MANT = new double[][] { \n     /** log(2) (low bits). */\n     private static final double LN_2_B = 1.17304635250823482e-7;\n \n-    /** Coefficients for slowLog. */\n-    private static final double LN_SPLIT_COEF[][] = {\n-        {2.0, 0.0},\n-        {0.6666666269302368, 3.9736429850260626E-8},\n-        {0.3999999761581421, 2.3841857910019882E-8},\n-        {0.2857142686843872, 1.7029898543501842E-8},\n-        {0.2222222089767456, 1.3245471311735498E-8},\n-        {0.1818181574344635, 2.4384203044354907E-8},\n-        {0.1538461446762085, 9.140260083262505E-9},\n-        {0.13333332538604736, 9.220590270857665E-9},\n-        {0.11764700710773468, 1.2393345855018391E-8},\n-        {0.10526403784751892, 8.251545029714408E-9},\n-        {0.0952233225107193, 1.2675934823758863E-8},\n-        {0.08713622391223907, 1.1430250008909141E-8},\n-        {0.07842259109020233, 2.404307984052299E-9},\n-        {0.08371849358081818, 1.176342548272881E-8},\n-        {0.030589580535888672, 1.2958646899018938E-9},\n-        {0.14982303977012634, 1.225743062930824E-8},\n-    };\n-\n     /** Coefficients for log, when input 0.99 < x < 1.01. */\n     private static final double LN_QUICK_COEF[][] = {\n         {1.0, 5.669184079525E-24},\n     // }\n \n     public static void main(String[] a){\n-        printarray(\"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n-        printarray(\"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n-        printarray(\"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n-        printarray(\"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n-        printarray(\"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n-        printarray(\"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n-        printarray(\"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n-        printarray(\"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n-        printarray(\"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n-        printarray(\"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n-        printarray(\"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n-    }\n-\n-    private static void printarray(String string, int expectedLen, double[][] array2d) {\n-        System.out.println(string);\n-        checkLen(expectedLen, array2d.length);\n-        System.out.println(\"    { \");\n-        int i = 0;\n-        for(double array[] : array2d) {\n-            System.out.print(\"        {\");\n-            for(double d : array) { // assume inner array has very few entries\n-                String ds = d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n-                System.out.printf(\"%-25.25s\",ds); // multiple entries per line\n-            }\n-            System.out.println(\"}, // \"+i++);\n-        }\n-        System.out.println(\"    };\");\n-    }\n-\n-    private static void printarray(String string, int expectedLen, double[] array) {\n-        System.out.println(string+\"=\");\n-        checkLen(expectedLen, array.length);\n-        System.out.println(\"    {\");\n-        for(double d : array){\n-            String ds = d!=d ? \"Double.NaN,\" : d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n-            System.out.printf(\"        %s%n\",ds); // one entry per line\n-        }\n-        System.out.println(\"    };\");\n-    }\n-\n-    private static void checkLen(int expectedLen, int actual) {\n-        if (expectedLen != actual) {\n-            throw new DimensionMismatchException(actual, expectedLen);\n-        }\n+        FastMathCalc.printarray(\"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n+        FastMathCalc.printarray(\"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n+        FastMathCalc.printarray(\"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n+        FastMathCalc.printarray(\"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n+        FastMathCalc.printarray(\"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n+        FastMathCalc.printarray(\"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n+        FastMathCalc.printarray(\"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n+        FastMathCalc.printarray(\"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n+        FastMathCalc.printarray(\"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n+        FastMathCalc.printarray(\"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n+        FastMathCalc.printarray(\"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n     }\n \n     /**\n     }\n \n     /**\n-     *  For x between 0 and 1, returns exp(x), uses extended precision\n-     *  @param x argument of exponential\n-     *  @param result placeholder where to place exp(x) split in two terms\n-     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n-     *  @return exp(x)\n-     */\n-    private static double slowexp(final double x, final double result[]) {\n-        final double xs[] = new double[2];\n-        final double ys[] = new double[2];\n-        final double facts[] = new double[2];\n-        final double as[] = new double[2];\n-        split(x, xs);\n-        ys[0] = ys[1] = 0.0;\n-\n-        for (int i = FACT.length-1; i >= 0; i--) {\n-            splitMult(xs, ys, as);\n-            ys[0] = as[0];\n-            ys[1] = as[1];\n-\n-            split(FACT[i], as);\n-            splitReciprocal(as, facts);\n-\n-            splitAdd(ys, facts, as);\n-            ys[0] = as[0];\n-            ys[1] = as[1];\n-        }\n-\n-        if (result != null) {\n-            result[0] = ys[0];\n-            result[1] = ys[1];\n-        }\n-\n-        return ys[0] + ys[1];\n-    }\n-\n-    /** Compute split[0], split[1] such that their sum is equal to d,\n-     * and split[0] has its 30 least significant bits as zero.\n-     * @param d number to split\n-     * @param split placeholder where to place the result\n-     */\n-    private static void split(final double d, final double split[]) {\n-        if (d < 8e298 && d > -8e298) {\n-            final double a = d * HEX_40000000;\n-            split[0] = (d + a) - a;\n-            split[1] = d - split[0];\n-        } else {\n-            final double a = d * 9.31322574615478515625E-10;\n-            split[0] = (d + a - d) * HEX_40000000;\n-            split[1] = d - split[0];\n-        }\n-    }\n-\n-    /** Recompute a split.\n-     * @param a input/out array containing the split, changed\n-     * on output\n-     */\n-    private static void resplit(final double a[]) {\n-        final double c = a[0] + a[1];\n-        final double d = -(c - a[0] - a[1]);\n-\n-        if (c < 8e298 && c > -8e298) { // MAGIC NUMBER\n-            double z = c * HEX_40000000;\n-            a[0] = (c + z) - z;\n-            a[1] = c - a[0] + d;\n-        } else {\n-            double z = c * 9.31322574615478515625E-10;\n-            a[0] = (c + z - c) * HEX_40000000;\n-            a[1] = c - a[0] + d;\n-        }\n-    }\n-\n-    /** Multiply two numbers in split form.\n-     * @param a first term of multiplication\n-     * @param b second term of multiplication\n-     * @param ans placeholder where to put the result\n-     */\n-    private static void splitMult(double a[], double b[], double ans[]) {\n-        ans[0] = a[0] * b[0];\n-        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n-\n-        /* Resplit */\n-        resplit(ans);\n-    }\n-\n-    /** Add two numbers in split form.\n-     * @param a first term of addition\n-     * @param b second term of addition\n-     * @param ans placeholder where to put the result\n-     */\n-    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n-        ans[0] = a[0] + b[0];\n-        ans[1] = a[1] + b[1];\n-\n-        resplit(ans);\n-    }\n-\n-    /** Compute the reciprocal of in.  Use the following algorithm.\n-     *  in = c + d.\n-     *  want to find x + y such that x+y = 1/(c+d) and x is much\n-     *  larger than y and x has several zero bits on the right.\n-     *\n-     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n-     *  Use following identity to compute (a+b)/(c+d)\n-     *\n-     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n-     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n-     *  This will be close to the right answer, but there will be\n-     *  some rounding in the calculation of X.  So by carefully\n-     *  computing 1 - (c+d)(x+y) we can compute an error and\n-     *  add that back in.   This is done carefully so that terms\n-     *  of similar size are subtracted first.\n-     *  @param in initial number, in split form\n-     *  @param result placeholder where to put the result\n-     */\n-    private static void splitReciprocal(final double in[], final double result[]) {\n-        final double b = 1.0/4194304.0;\n-        final double a = 1.0 - b;\n-\n-        if (in[0] == 0.0) {\n-            in[0] = in[1];\n-            in[1] = 0.0;\n-        }\n-\n-        result[0] = a / in[0];\n-        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n-\n-        if (result[1] != result[1]) { // can happen if result[1] is NAN\n-            result[1] = 0.0;\n-        }\n-\n-        /* Resplit */\n-        resplit(result);\n-\n-        for (int i = 0; i < 2; i++) {\n-            /* this may be overkill, probably once is enough */\n-            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n-            result[1] * in[0] - result[1] * in[1];\n-            /*err = 1.0 - err; */\n-            err = err * (result[0] + result[1]);\n-            /*printf(\"err = %16e\\n\", err); */\n-            result[1] += err;\n-        }\n-    }\n-\n-    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n-     * @param a first term of the multiplication\n-     * @param b second term of the multiplication\n-     * @param result placeholder where to put the result\n-     */\n-    private static void quadMult(final double a[], final double b[], final double result[]) {\n-        final double xs[] = new double[2];\n-        final double ys[] = new double[2];\n-        final double zs[] = new double[2];\n-\n-        /* a[0] * b[0] */\n-        split(a[0], xs);\n-        split(b[0], ys);\n-        splitMult(xs, ys, zs);\n-\n-        result[0] = zs[0];\n-        result[1] = zs[1];\n-\n-        /* a[0] * b[1] */\n-        split(b[1], ys);\n-        splitMult(xs, ys, zs);\n-\n-        double tmp = result[0] + zs[0];\n-        result[1] = result[1] - (tmp - result[0] - zs[0]);\n-        result[0] = tmp;\n-        tmp = result[0] + zs[1];\n-        result[1] = result[1] - (tmp - result[0] - zs[1]);\n-        result[0] = tmp;\n-\n-        /* a[1] * b[0] */\n-        split(a[1], xs);\n-        split(b[0], ys);\n-        splitMult(xs, ys, zs);\n-\n-        tmp = result[0] + zs[0];\n-        result[1] = result[1] - (tmp - result[0] - zs[0]);\n-        result[0] = tmp;\n-        tmp = result[0] + zs[1];\n-        result[1] = result[1] - (tmp - result[0] - zs[1]);\n-        result[0] = tmp;\n-\n-        /* a[1] * b[0] */\n-        split(a[1], xs);\n-        split(b[1], ys);\n-        splitMult(xs, ys, zs);\n-\n-        tmp = result[0] + zs[0];\n-        result[1] = result[1] - (tmp - result[0] - zs[0]);\n-        result[0] = tmp;\n-        tmp = result[0] + zs[1];\n-        result[1] = result[1] - (tmp - result[0] - zs[1]);\n-        result[0] = tmp;\n-    }\n-\n-    /** Compute exp(p) for a integer p in extended precision.\n-     * @param p integer whose exponential is requested\n-     * @param result placeholder where to put the result in extended precision\n-     * @return exp(p) in standard precision (equal to result[0] + result[1])\n-     */\n-    private static double expint(int p, final double result[]) {\n-        //double x = M_E;\n-        final double xs[] = new double[2];\n-        final double as[] = new double[2];\n-        final double ys[] = new double[2];\n-        //split(x, xs);\n-        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n-        //xs[0] = 2.71827697753906250000;\n-        //xs[1] = 4.85091998273542816811e-06;\n-        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n-        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n-\n-        /* E */\n-        xs[0] = 2.718281828459045;\n-        xs[1] = 1.4456468917292502E-16;\n-\n-        split(1.0, ys);\n-\n-        while (p > 0) {\n-            if ((p & 1) != 0) {\n-                quadMult(ys, xs, as);\n-                ys[0] = as[0]; ys[1] = as[1];\n-            }\n-\n-            quadMult(xs, xs, as);\n-            xs[0] = as[0]; xs[1] = as[1];\n-\n-            p >>= 1;\n-        }\n-\n-        if (result != null) {\n-            result[0] = ys[0];\n-            result[1] = ys[1];\n-\n-            resplit(result);\n-        }\n-\n-        return ys[0] + ys[1];\n-    }\n-\n-\n-    /**\n      * Natural logarithm.\n      *\n      * @param x   a double\n         return result;\n     }\n \n-    /** xi in the range of [1, 2].\n-     *                                3        5        7\n-     *      x+1           /          x        x        x          \\\n-     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n-     *      1-x           \\          3        5        7          /\n-     *\n-     * So, compute a Remez approximation of the following function\n-     *\n-     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n-     *\n-     * This will be an even function with only positive coefficents.\n-     * x is in the range [0 - 1/3].\n-     *\n-     * Transform xi for input to the above function by setting\n-     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n-     * the result is multiplied by x.\n-     * @param xi number from which log is requested\n-     * @return log(xi)\n-     */\n-    private static double[] slowLog(double xi) {\n-        double x[] = new double[2];\n-        double x2[] = new double[2];\n-        double y[] = new double[2];\n-        double a[] = new double[2];\n-\n-        split(xi, x);\n-\n-        /* Set X = (x-1)/(x+1) */\n-        x[0] += 1.0;\n-        resplit(x);\n-        splitReciprocal(x, a);\n-        x[0] -= 2.0;\n-        resplit(x);\n-        splitMult(x, a, y);\n-        x[0] = y[0];\n-        x[1] = y[1];\n-\n-        /* Square X -> X2*/\n-        splitMult(x, x, x2);\n-\n-\n-        //x[0] -= 1.0;\n-        //resplit(x);\n-\n-        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n-        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n-\n-        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n-            splitMult(y, x2, a);\n-            y[0] = a[0];\n-            y[1] = a[1];\n-            splitAdd(y, LN_SPLIT_COEF[i], a);\n-            y[0] = a[0];\n-            y[1] = a[1];\n-        }\n-\n-        splitMult(y, x, a);\n-        y[0] = a[0];\n-        y[1] = a[1];\n-\n-        return y;\n-    }\n-\n-    /**\n-     * For x between 0 and pi/4 compute sine using Taylor expansion:\n-     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n-     * @param x number from which sine is requested\n-     * @param result placeholder where to put the result in extended precision\n-     * (may be null)\n-     * @return sin(x)\n-     */\n-    private static double slowSin(final double x, final double result[]) {\n-        final double xs[] = new double[2];\n-        final double ys[] = new double[2];\n-        final double facts[] = new double[2];\n-        final double as[] = new double[2];\n-        split(x, xs);\n-        ys[0] = ys[1] = 0.0;\n-\n-        for (int i = FACT.length-1; i >= 0; i--) {\n-            splitMult(xs, ys, as);\n-            ys[0] = as[0]; ys[1] = as[1];\n-\n-            if ( (i & 1) == 0) { // Ignore even numbers\n-                continue;\n-            }\n-\n-            split(FACT[i], as);\n-            splitReciprocal(as, facts);\n-\n-            if ( (i & 2) != 0 ) { // alternate terms are negative\n-                facts[0] = -facts[0];\n-                facts[1] = -facts[1];\n-            }\n-\n-            splitAdd(ys, facts, as);\n-            ys[0] = as[0]; ys[1] = as[1];\n-        }\n-\n-        if (result != null) {\n-            result[0] = ys[0];\n-            result[1] = ys[1];\n-        }\n-\n-        return ys[0] + ys[1];\n-    }\n-\n-    /**\n-     *  For x between 0 and pi/4 compute cosine using Talor series\n-     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n-     * @param x number from which cosine is requested\n-     * @param result placeholder where to put the result in extended precision\n-     * (may be null)\n-     * @return cos(x)\n-     */\n-    private static double slowCos(final double x, final double result[]) {\n-\n-        final double xs[] = new double[2];\n-        final double ys[] = new double[2];\n-        final double facts[] = new double[2];\n-        final double as[] = new double[2];\n-        split(x, xs);\n-        ys[0] = ys[1] = 0.0;\n-\n-        for (int i = FACT.length-1; i >= 0; i--) {\n-            splitMult(xs, ys, as);\n-            ys[0] = as[0]; ys[1] = as[1];\n-\n-            if ( (i & 1) != 0) { // skip odd entries\n-                continue;\n-            }\n-\n-            split(FACT[i], as);\n-            splitReciprocal(as, facts);\n-\n-            if ( (i & 2) != 0 ) { // alternate terms are negative\n-                facts[0] = -facts[0];\n-                facts[1] = -facts[1];\n-            }\n-\n-            splitAdd(ys, facts, as);\n-            ys[0] = as[0]; ys[1] = as[1];\n-        }\n-\n-        if (result != null) {\n-            result[0] = ys[0];\n-            result[1] = ys[1];\n-        }\n-\n-        return ys[0] + ys[1];\n-    }\n-\n-    /** Build the sine and cosine tables.\n-     */\n-    @SuppressWarnings(\"unused\")\n-    private static void buildSinCosTables() {\n-        final double result[] = new double[2];\n-\n-        /* Use taylor series for 0 <= x <= 6/8 */\n-        for (int i = 0; i < 7; i++) {\n-            double x = i / 8.0;\n-\n-            slowSin(x, result);\n-            SINE_TABLE_A[i] = result[0];\n-            SINE_TABLE_B[i] = result[1];\n-\n-            slowCos(x, result);\n-            COSINE_TABLE_A[i] = result[0];\n-            COSINE_TABLE_B[i] = result[1];\n-        }\n-\n-        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n-        for (int i = 7; i < SINE_TABLE_LEN; i++) {\n-            double xs[] = new double[2];\n-            double ys[] = new double[2];\n-            double as[] = new double[2];\n-            double bs[] = new double[2];\n-            double temps[] = new double[2];\n-\n-            if ( (i & 1) == 0) {\n-                // Even, use double angle\n-                xs[0] = SINE_TABLE_A[i/2];\n-                xs[1] = SINE_TABLE_B[i/2];\n-                ys[0] = COSINE_TABLE_A[i/2];\n-                ys[1] = COSINE_TABLE_B[i/2];\n-\n-                /* compute sine */\n-                splitMult(xs, ys, result);\n-                SINE_TABLE_A[i] = result[0] * 2.0;\n-                SINE_TABLE_B[i] = result[1] * 2.0;\n-\n-                /* Compute cosine */\n-                splitMult(ys, ys, as);\n-                splitMult(xs, xs, temps);\n-                temps[0] = -temps[0];\n-                temps[1] = -temps[1];\n-                splitAdd(as, temps, result);\n-                COSINE_TABLE_A[i] = result[0];\n-                COSINE_TABLE_B[i] = result[1];\n-            } else {\n-                xs[0] = SINE_TABLE_A[i/2];\n-                xs[1] = SINE_TABLE_B[i/2];\n-                ys[0] = COSINE_TABLE_A[i/2];\n-                ys[1] = COSINE_TABLE_B[i/2];\n-                as[0] = SINE_TABLE_A[i/2+1];\n-                as[1] = SINE_TABLE_B[i/2+1];\n-                bs[0] = COSINE_TABLE_A[i/2+1];\n-                bs[1] = COSINE_TABLE_B[i/2+1];\n-\n-                /* compute sine */\n-                splitMult(xs, bs, temps);\n-                splitMult(ys, as, result);\n-                splitAdd(result, temps, result);\n-                SINE_TABLE_A[i] = result[0];\n-                SINE_TABLE_B[i] = result[1];\n-\n-                /* Compute cosine */\n-                splitMult(ys, bs, result);\n-                splitMult(xs, as, temps);\n-                temps[0] = -temps[0];\n-                temps[1] = -temps[1];\n-                splitAdd(result, temps, result);\n-                COSINE_TABLE_A[i] = result[0];\n-                COSINE_TABLE_B[i] = result[1];\n-            }\n-        }\n-\n-        /* Compute tangent = sine/cosine */\n-        for (int i = 0; i < SINE_TABLE_LEN; i++) {\n-            double xs[] = new double[2];\n-            double ys[] = new double[2];\n-            double as[] = new double[2];\n-\n-            as[0] = COSINE_TABLE_A[i];\n-            as[1] = COSINE_TABLE_B[i];\n-\n-            splitReciprocal(as, ys);\n-\n-            xs[0] = SINE_TABLE_A[i];\n-            xs[1] = SINE_TABLE_B[i];\n-\n-            splitMult(xs, ys, as);\n-\n-            TANGENT_TABLE_A[i] = as[0];\n-            TANGENT_TABLE_B[i] = as[1];\n-        }\n-\n-    }\n \n     /**\n      *  Computes sin(x) - x, where |x| < 1/16.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/FastMathCalc.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+\n+class FastMathCalc {\n+\n+    /**\n+     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n+     * Equivalent to 2^30.\n+     */\n+    private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n+\n+    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n+    private static final double FACT[] = new double[] \n+        {\n+        +1.0d,                        // 0               \n+        +1.0d,                        // 1\n+        +2.0d,                        // 2\n+        +6.0d,                        // 3\n+        +24.0d,                       // 4\n+        +120.0d,                      // 5\n+        +720.0d,                      // 6\n+        +5040.0d,                     // 7\n+        +40320.0d,                    // 8\n+        +362880.0d,                   // 9\n+        +3628800.0d,                  // 10\n+        +39916800.0d,                 // 11\n+        +479001600.0d,                // 12\n+        +6227020800.0d,               // 13\n+        +87178291200.0d,              // 14\n+        +1307674368000.0d,            // 15\n+        +20922789888000.0d,           // 16\n+        +355687428096000.0d,          // 17\n+        +6402373705728000.0d,         // 18\n+        +121645100408832000.0d,       // 19\n+        };\n+\n+    /** Coefficients for slowLog. */\n+    private static final double LN_SPLIT_COEF[][] = {\n+        {2.0, 0.0},\n+        {0.6666666269302368, 3.9736429850260626E-8},\n+        {0.3999999761581421, 2.3841857910019882E-8},\n+        {0.2857142686843872, 1.7029898543501842E-8},\n+        {0.2222222089767456, 1.3245471311735498E-8},\n+        {0.1818181574344635, 2.4384203044354907E-8},\n+        {0.1538461446762085, 9.140260083262505E-9},\n+        {0.13333332538604736, 9.220590270857665E-9},\n+        {0.11764700710773468, 1.2393345855018391E-8},\n+        {0.10526403784751892, 8.251545029714408E-9},\n+        {0.0952233225107193, 1.2675934823758863E-8},\n+        {0.08713622391223907, 1.1430250008909141E-8},\n+        {0.07842259109020233, 2.404307984052299E-9},\n+        {0.08371849358081818, 1.176342548272881E-8},\n+        {0.030589580535888672, 1.2958646899018938E-9},\n+        {0.14982303977012634, 1.225743062930824E-8},\n+    };\n+\n+    /** Build the sine and cosine tables.\n+     * @param SINE_TABLE_A \n+     * @param SINE_TABLE_B \n+     * @param COSINE_TABLE_A \n+     * @param COSINE_TABLE_B \n+     * @param SINE_TABLE_LEN \n+     * @param TANGENT_TABLE_A \n+     * @param TANGENT_TABLE_B \n+     */\n+    @SuppressWarnings(\"unused\")\n+    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n+        final double result[] = new double[2];\n+\n+        /* Use taylor series for 0 <= x <= 6/8 */\n+        for (int i = 0; i < 7; i++) {\n+            double x = i / 8.0;\n+\n+            slowSin(x, result);\n+            SINE_TABLE_A[i] = result[0];\n+            SINE_TABLE_B[i] = result[1];\n+\n+            slowCos(x, result);\n+            COSINE_TABLE_A[i] = result[0];\n+            COSINE_TABLE_B[i] = result[1];\n+        }\n+\n+        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n+        for (int i = 7; i < SINE_TABLE_LEN; i++) {\n+            double xs[] = new double[2];\n+            double ys[] = new double[2];\n+            double as[] = new double[2];\n+            double bs[] = new double[2];\n+            double temps[] = new double[2];\n+\n+            if ( (i & 1) == 0) {\n+                // Even, use double angle\n+                xs[0] = SINE_TABLE_A[i/2];\n+                xs[1] = SINE_TABLE_B[i/2];\n+                ys[0] = COSINE_TABLE_A[i/2];\n+                ys[1] = COSINE_TABLE_B[i/2];\n+\n+                /* compute sine */\n+                splitMult(xs, ys, result);\n+                SINE_TABLE_A[i] = result[0] * 2.0;\n+                SINE_TABLE_B[i] = result[1] * 2.0;\n+\n+                /* Compute cosine */\n+                splitMult(ys, ys, as);\n+                splitMult(xs, xs, temps);\n+                temps[0] = -temps[0];\n+                temps[1] = -temps[1];\n+                splitAdd(as, temps, result);\n+                COSINE_TABLE_A[i] = result[0];\n+                COSINE_TABLE_B[i] = result[1];\n+            } else {\n+                xs[0] = SINE_TABLE_A[i/2];\n+                xs[1] = SINE_TABLE_B[i/2];\n+                ys[0] = COSINE_TABLE_A[i/2];\n+                ys[1] = COSINE_TABLE_B[i/2];\n+                as[0] = SINE_TABLE_A[i/2+1];\n+                as[1] = SINE_TABLE_B[i/2+1];\n+                bs[0] = COSINE_TABLE_A[i/2+1];\n+                bs[1] = COSINE_TABLE_B[i/2+1];\n+\n+                /* compute sine */\n+                splitMult(xs, bs, temps);\n+                splitMult(ys, as, result);\n+                splitAdd(result, temps, result);\n+                SINE_TABLE_A[i] = result[0];\n+                SINE_TABLE_B[i] = result[1];\n+\n+                /* Compute cosine */\n+                splitMult(ys, bs, result);\n+                splitMult(xs, as, temps);\n+                temps[0] = -temps[0];\n+                temps[1] = -temps[1];\n+                splitAdd(result, temps, result);\n+                COSINE_TABLE_A[i] = result[0];\n+                COSINE_TABLE_B[i] = result[1];\n+            }\n+        }\n+\n+        /* Compute tangent = sine/cosine */\n+        for (int i = 0; i < SINE_TABLE_LEN; i++) {\n+            double xs[] = new double[2];\n+            double ys[] = new double[2];\n+            double as[] = new double[2];\n+\n+            as[0] = COSINE_TABLE_A[i];\n+            as[1] = COSINE_TABLE_B[i];\n+\n+            splitReciprocal(as, ys);\n+\n+            xs[0] = SINE_TABLE_A[i];\n+            xs[1] = SINE_TABLE_B[i];\n+\n+            splitMult(xs, ys, as);\n+\n+            TANGENT_TABLE_A[i] = as[0];\n+            TANGENT_TABLE_B[i] = as[1];\n+        }\n+\n+    }\n+\n+    /**\n+     *  For x between 0 and pi/4 compute cosine using Talor series\n+     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n+     * @param x number from which cosine is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * (may be null)\n+     * @return cos(x)\n+     */\n+    static double slowCos(final double x, final double result[]) {\n+\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = FACT.length-1; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+\n+            if ( (i & 1) != 0) { // skip odd entries\n+                continue;\n+            }\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            if ( (i & 2) != 0 ) { // alternate terms are negative\n+                facts[0] = -facts[0];\n+                facts[1] = -facts[1];\n+            }\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /**\n+     * For x between 0 and pi/4 compute sine using Taylor expansion:\n+     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n+     * @param x number from which sine is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * (may be null)\n+     * @return sin(x)\n+     */\n+    static double slowSin(final double x, final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = FACT.length-1; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+\n+            if ( (i & 1) == 0) { // Ignore even numbers\n+                continue;\n+            }\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            if ( (i & 2) != 0 ) { // alternate terms are negative\n+                facts[0] = -facts[0];\n+                facts[1] = -facts[1];\n+            }\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0]; ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+\n+    /**\n+     *  For x between 0 and 1, returns exp(x), uses extended precision\n+     *  @param x argument of exponential\n+     *  @param result placeholder where to place exp(x) split in two terms\n+     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n+     *  @return exp(x)\n+     */\n+    static double slowexp(final double x, final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double facts[] = new double[2];\n+        final double as[] = new double[2];\n+        split(x, xs);\n+        ys[0] = ys[1] = 0.0;\n+\n+        for (int i = FACT.length-1; i >= 0; i--) {\n+            splitMult(xs, ys, as);\n+            ys[0] = as[0];\n+            ys[1] = as[1];\n+\n+            split(FACT[i], as);\n+            splitReciprocal(as, facts);\n+\n+            splitAdd(ys, facts, as);\n+            ys[0] = as[0];\n+            ys[1] = as[1];\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+\n+    /** Compute split[0], split[1] such that their sum is equal to d,\n+     * and split[0] has its 30 least significant bits as zero.\n+     * @param d number to split\n+     * @param split placeholder where to place the result\n+     */\n+    private static void split(final double d, final double split[]) {\n+        if (d < 8e298 && d > -8e298) {\n+            final double a = d * HEX_40000000;\n+            split[0] = (d + a) - a;\n+            split[1] = d - split[0];\n+        } else {\n+            final double a = d * 9.31322574615478515625E-10;\n+            split[0] = (d + a - d) * HEX_40000000;\n+            split[1] = d - split[0];\n+        }\n+    }\n+\n+    /** Recompute a split.\n+     * @param a input/out array containing the split, changed\n+     * on output\n+     */\n+    private static void resplit(final double a[]) {\n+        final double c = a[0] + a[1];\n+        final double d = -(c - a[0] - a[1]);\n+\n+        if (c < 8e298 && c > -8e298) { // MAGIC NUMBER\n+            double z = c * HEX_40000000;\n+            a[0] = (c + z) - z;\n+            a[1] = c - a[0] + d;\n+        } else {\n+            double z = c * 9.31322574615478515625E-10;\n+            a[0] = (c + z - c) * HEX_40000000;\n+            a[1] = c - a[0] + d;\n+        }\n+    }\n+\n+    /** Multiply two numbers in split form.\n+     * @param a first term of multiplication\n+     * @param b second term of multiplication\n+     * @param ans placeholder where to put the result\n+     */\n+    private static void splitMult(double a[], double b[], double ans[]) {\n+        ans[0] = a[0] * b[0];\n+        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n+\n+        /* Resplit */\n+        resplit(ans);\n+    }\n+\n+    /** Add two numbers in split form.\n+     * @param a first term of addition\n+     * @param b second term of addition\n+     * @param ans placeholder where to put the result\n+     */\n+    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n+        ans[0] = a[0] + b[0];\n+        ans[1] = a[1] + b[1];\n+\n+        resplit(ans);\n+    }\n+\n+    /** Compute the reciprocal of in.  Use the following algorithm.\n+     *  in = c + d.\n+     *  want to find x + y such that x+y = 1/(c+d) and x is much\n+     *  larger than y and x has several zero bits on the right.\n+     *\n+     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n+     *  Use following identity to compute (a+b)/(c+d)\n+     *\n+     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n+     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n+     *  This will be close to the right answer, but there will be\n+     *  some rounding in the calculation of X.  So by carefully\n+     *  computing 1 - (c+d)(x+y) we can compute an error and\n+     *  add that back in.   This is done carefully so that terms\n+     *  of similar size are subtracted first.\n+     *  @param in initial number, in split form\n+     *  @param result placeholder where to put the result\n+     */\n+    static void splitReciprocal(final double in[], final double result[]) {\n+        final double b = 1.0/4194304.0;\n+        final double a = 1.0 - b;\n+\n+        if (in[0] == 0.0) {\n+            in[0] = in[1];\n+            in[1] = 0.0;\n+        }\n+\n+        result[0] = a / in[0];\n+        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n+\n+        if (result[1] != result[1]) { // can happen if result[1] is NAN\n+            result[1] = 0.0;\n+        }\n+\n+        /* Resplit */\n+        resplit(result);\n+\n+        for (int i = 0; i < 2; i++) {\n+            /* this may be overkill, probably once is enough */\n+            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n+            result[1] * in[0] - result[1] * in[1];\n+            /*err = 1.0 - err; */\n+            err = err * (result[0] + result[1]);\n+            /*printf(\"err = %16e\\n\", err); */\n+            result[1] += err;\n+        }\n+    }\n+\n+    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n+     * @param a first term of the multiplication\n+     * @param b second term of the multiplication\n+     * @param result placeholder where to put the result\n+     */\n+    private static void quadMult(final double a[], final double b[], final double result[]) {\n+        final double xs[] = new double[2];\n+        final double ys[] = new double[2];\n+        final double zs[] = new double[2];\n+\n+        /* a[0] * b[0] */\n+        split(a[0], xs);\n+        split(b[0], ys);\n+        splitMult(xs, ys, zs);\n+\n+        result[0] = zs[0];\n+        result[1] = zs[1];\n+\n+        /* a[0] * b[1] */\n+        split(b[1], ys);\n+        splitMult(xs, ys, zs);\n+\n+        double tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+\n+        /* a[1] * b[0] */\n+        split(a[1], xs);\n+        split(b[0], ys);\n+        splitMult(xs, ys, zs);\n+\n+        tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+\n+        /* a[1] * b[0] */\n+        split(a[1], xs);\n+        split(b[1], ys);\n+        splitMult(xs, ys, zs);\n+\n+        tmp = result[0] + zs[0];\n+        result[1] = result[1] - (tmp - result[0] - zs[0]);\n+        result[0] = tmp;\n+        tmp = result[0] + zs[1];\n+        result[1] = result[1] - (tmp - result[0] - zs[1]);\n+        result[0] = tmp;\n+    }\n+\n+    /** Compute exp(p) for a integer p in extended precision.\n+     * @param p integer whose exponential is requested\n+     * @param result placeholder where to put the result in extended precision\n+     * @return exp(p) in standard precision (equal to result[0] + result[1])\n+     */\n+    static double expint(int p, final double result[]) {\n+        //double x = M_E;\n+        final double xs[] = new double[2];\n+        final double as[] = new double[2];\n+        final double ys[] = new double[2];\n+        //split(x, xs);\n+        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n+        //xs[0] = 2.71827697753906250000;\n+        //xs[1] = 4.85091998273542816811e-06;\n+        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n+        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n+\n+        /* E */\n+        xs[0] = 2.718281828459045;\n+        xs[1] = 1.4456468917292502E-16;\n+\n+        split(1.0, ys);\n+\n+        while (p > 0) {\n+            if ((p & 1) != 0) {\n+                quadMult(ys, xs, as);\n+                ys[0] = as[0]; ys[1] = as[1];\n+            }\n+\n+            quadMult(xs, xs, as);\n+            xs[0] = as[0]; xs[1] = as[1];\n+\n+            p >>= 1;\n+        }\n+\n+        if (result != null) {\n+            result[0] = ys[0];\n+            result[1] = ys[1];\n+\n+            resplit(result);\n+        }\n+\n+        return ys[0] + ys[1];\n+    }\n+    /** xi in the range of [1, 2].\n+     *                                3        5        7\n+     *      x+1           /          x        x        x          \\\n+     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n+     *      1-x           \\          3        5        7          /\n+     *\n+     * So, compute a Remez approximation of the following function\n+     *\n+     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n+     *\n+     * This will be an even function with only positive coefficents.\n+     * x is in the range [0 - 1/3].\n+     *\n+     * Transform xi for input to the above function by setting\n+     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n+     * the result is multiplied by x.\n+     * @param xi number from which log is requested\n+     * @return log(xi)\n+     */\n+    static double[] slowLog(double xi) {\n+        double x[] = new double[2];\n+        double x2[] = new double[2];\n+        double y[] = new double[2];\n+        double a[] = new double[2];\n+\n+        split(xi, x);\n+\n+        /* Set X = (x-1)/(x+1) */\n+        x[0] += 1.0;\n+        resplit(x);\n+        splitReciprocal(x, a);\n+        x[0] -= 2.0;\n+        resplit(x);\n+        splitMult(x, a, y);\n+        x[0] = y[0];\n+        x[1] = y[1];\n+\n+        /* Square X -> X2*/\n+        splitMult(x, x, x2);\n+\n+\n+        //x[0] -= 1.0;\n+        //resplit(x);\n+\n+        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n+        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n+\n+        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n+            splitMult(y, x2, a);\n+            y[0] = a[0];\n+            y[1] = a[1];\n+            splitAdd(y, LN_SPLIT_COEF[i], a);\n+            y[0] = a[0];\n+            y[1] = a[1];\n+        }\n+\n+        splitMult(y, x, a);\n+        y[0] = a[0];\n+        y[1] = a[1];\n+\n+        return y;\n+    }\n+\n+\n+    static void printarray(String string, int expectedLen, double[][] array2d) {\n+        System.out.println(string);\n+        checkLen(expectedLen, array2d.length);\n+        System.out.println(\"    { \");\n+        int i = 0;\n+        for(double array[] : array2d) {\n+            System.out.print(\"        {\");\n+            for(double d : array) { // assume inner array has very few entries\n+                String ds = d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n+                System.out.printf(\"%-25.25s\",ds); // multiple entries per line\n+            }\n+            System.out.println(\"}, // \"+i++);\n+        }\n+        System.out.println(\"    };\");\n+    }\n+\n+    static void printarray(String string, int expectedLen, double[] array) {\n+        System.out.println(string+\"=\");\n+        checkLen(expectedLen, array.length);\n+        System.out.println(\"    {\");\n+        for(double d : array){\n+            String ds = d!=d ? \"Double.NaN,\" : d >= 0 ? \"+\"+Double.toString(d)+\"d,\" : Double.toString(d)+\"d,\";\n+            System.out.printf(\"        %s%n\",ds); // one entry per line\n+        }\n+        System.out.println(\"    };\");\n+    }\n+\n+    private static void checkLen(int expectedLen, int actual) {\n+        if (expectedLen != actual) {\n+            throw new DimensionMismatchException(actual, expectedLen);\n+        }\n+    }\n+\n+}", "timestamp": 1315773807, "metainfo": ""}