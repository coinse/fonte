{"sha": "d7d514b6debdd76f4d49498edbda6f8c8a6305cd", "log": "MATH-425 Removed usage of exceptions defined in the package \"linear\". Added replacements in package \"exception\". Modified tests to catch the new exception type. Deleted the deprecated package \"estimation\" (test failed because of the changes). Deprecated \"MaxIterationsExceededException\". Changes in package \"optimization.general\" were necessary to comply with the new exceptions and to be consistent in reporting the actual cause of failure.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MaxIterationsExceededException.java\n+++ b/src/main/java/org/apache/commons/math/MaxIterationsExceededException.java\n  *\n  * @version $Revision$ $Date$\n  * @since 1.2\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.MaxCountExceededException}\n+ * instead.\n  */\n public class MaxIterationsExceededException extends ConvergenceException {\n \n--- a/src/main/java/org/apache/commons/math/exception/DimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/exception/DimensionMismatchException.java\n package org.apache.commons.math.exception;\n \n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.util.Localizable;\n \n /**\n  * Exception to be thrown when two dimensions differ.\n  * @version $Revision$ $Date$\n  */\n public class DimensionMismatchException extends MathIllegalNumberException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -8415396756375798143L;\n-\n     /** Correct dimension. */\n     private final int dimension;\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param specific Specific context information pattern.\n+     * @param wrong Wrong dimension.\n+     * @param expected Expected dimension.\n+     */\n+    public DimensionMismatchException(Localizable specific,\n+                                      int wrong,\n+                                      int expected) {\n+        super(specific,\n+              LocalizedFormats.DIMENSIONS_MISMATCH,\n+              wrong, expected);\n+        dimension = expected;\n+    }\n \n     /**\n      * Construct an exception from the mismatched dimensions.\n      */\n     public DimensionMismatchException(int wrong,\n                                       int expected) {\n-        super(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-              LocalizedFormats.DIMENSIONS_MISMATCH,\n-              wrong, expected);\n-        dimension = expected;\n+        this(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, wrong, expected);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MathIllegalNumberException.java\n      *\n      * @param specific Localizable pattern.\n      * @param general Localizable pattern.\n-     * @param wrong wrong number\n+     * @param wrong Wrong number.\n      * @param arguments Arguments.\n      */\n     protected MathIllegalNumberException(Localizable specific,\n      * Construct an exception.\n      *\n      * @param general Localizable pattern.\n-     * @param wrong wrong number\n+     * @param wrong Wrong number.\n      * @param arguments Arguments.\n      */\n     protected MathIllegalNumberException(Localizable general,\n--- a/src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MaxCountExceededException.java\n public class MaxCountExceededException extends MathIllegalStateException {\n     /** Serializable version Id. */\n     private static final long serialVersionUID = 4330003017885151975L;\n-\n     /**\n      * Maximum number of evaluations.\n      */\n      */\n     public MaxCountExceededException(Localizable specific,\n                                      Number max) {\n-        super(specific,\n-              LocalizedFormats.MAX_COUNT_EXCEEDED,\n-              max);\n-\n+        super(specific, LocalizedFormats.MAX_COUNT_EXCEEDED, max);\n         this.max = max;\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NonPositiveDefiniteMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a symmetric matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NonPositiveDefiniteMatrixException extends MathIllegalArgumentException {\n+    /** Index (diagonal element). */\n+    private final int index;\n+    /** Threshold. */\n+    private final double threshold;\n+\n+    /**\n+     * Construct an exception.\n+     *\n+     * @param index Row (and column) index.\n+     * @param threshold Absolute positivity threshold.\n+     */\n+    public NonPositiveDefiniteMatrixException(int index,\n+                                              double threshold) {\n+        super(LocalizedFormats.NON_POSITIVE_DEFINITE_MATRIX, index, threshold);\n+        this.index = index;\n+        this.threshold = threshold;\n+    }\n+\n+    /**\n+     * @return the row index.\n+     */\n+    public int getRow() {\n+        return index;\n+    }\n+    /**\n+     * @return the column index.\n+     */\n+    public int getColumn() {\n+        return index;\n+    }\n+    /**\n+     * @return the absolute positivity threshold.\n+     */\n+    public double getThreshold() {\n+        return threshold;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NonSquareMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a square matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NonSquareMatrixException extends DimensionMismatchException {\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param wrong Row dimension.\n+     * @param expected Column dimension.\n+     */\n+    public NonSquareMatrixException(int wrong,\n+                                    int expected) {\n+        super(LocalizedFormats.NON_SQUARE_MATRIX, wrong, expected);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/NonSymmetricMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a symmetric matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NonSymmetricMatrixException extends MathIllegalArgumentException {\n+    /** Row. */\n+    private final int row;\n+    /** Column. */\n+    private final int column;\n+    /** Threshold. */\n+    private final double threshold;\n+\n+    /**\n+     * Construct an exception.\n+     *\n+     * @param row Row index.\n+     * @param column Column index.\n+     * @param threshold Relative symmetry threshold.\n+     */\n+    public NonSymmetricMatrixException(int row,\n+                                       int column,\n+                                       double threshold) {\n+        super(LocalizedFormats.NON_SYMMETRIC_MATRIX, row, column, threshold);\n+        this.row = row;\n+        this.column = column;\n+        this.threshold = threshold;\n+    }\n+\n+    /**\n+     * @return the row index of the entry.\n+     */\n+    public int getRow() {\n+        return row;\n+    }\n+    /**\n+     * @return the column index of the entry.\n+     */\n+    public int getColumn() {\n+        return column;\n+    }\n+    /**\n+     * @return the relative symmetry threshold.\n+     */\n+    public double getThreshold() {\n+        return threshold;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/SingularMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when a non-singular matrix is expected.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class SingularMatrixException extends MathIllegalArgumentException {\n+    /**\n+     * Construct an exception.\n+     */\n+    public SingularMatrixException() {\n+        super(LocalizedFormats.SINGULAR_MATRIX);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     BETA(\"beta\"), /* keep */\n     NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix\"),\n+    NON_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix: diagonal element at ({0},{0}) is larger than {2}\"), /* keep */\n     DEGREES_OF_FREEDOM(\"degrees of freedom ({0})\"), /* keep */\n     NOT_POSITIVE_DEGREES_OF_FREEDOM(\"degrees of freedom must be positive ({0})\"),\n     NOT_POSITIVE_ELEMENT_AT_INDEX(\"element {0} is not positive: {1}\"),\n     NOT_STRICTLY_INCREASING_SEQUENCE(\"points {3} and {2} are not strictly increasing ({1} >= {0})\"), /* keep */\n     NOT_SUBTRACTION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not subtraction compatible\"),\n     NOT_SYMMETRIC_MATRIX(\"not symmetric matrix\"),\n+    NON_SYMMETRIC_MATRIX(\"non symmetric matrix: the difference between entries at ({0},{1}) and ({1},{0}) is larger than {2}\"), /* keep */\n     NO_BIN_SELECTED(\"no bin selected\"),\n     NO_CONVERGENCE_WITH_ANY_START_POINT(\"none of the {0} start points lead to convergence\"), /* keep */\n     NO_DATA(\"no data\"), /* keep */\n     SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE(\"sample size ({0}) must be less than or equal to population size ({1})\"),\n     SIMPLEX_NEED_ONE_POINT(\"simplex must contain at least one point\"),\n     SIMPLE_MESSAGE(\"{0}\"),\n-    SINGULAR_MATRIX(\"matrix is singular\"),\n+    SINGULAR_MATRIX(\"matrix is singular\"), /* keep */\n     SUBARRAY_ENDS_AFTER_ARRAY_END(\"subarray ends after array end\"),\n     TOO_LARGE_CUTOFF_SINGULAR_VALUE(\"cutoff singular value is {0}, should be at most {1}\"),\n     TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY(\"cannot discard {0} elements from a {1} elements array\"),\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.OutOfRangeException;\n     public abstract int getColumnDimension();\n \n     /** {@inheritDoc} */\n-    public T getTrace()\n-        throws NonSquareMatrixException {\n+    public T getTrace() {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (nRows != nCols) {\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n     public abstract int getColumnDimension();\n \n     /** {@inheritDoc} */\n-    public double getTrace()\n-        throws NonSquareMatrixException {\n+    public double getTrace() {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (nRows != nCols) {\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.NonSymmetricMatrixException;\n+import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n \n  * @since 2.0\n  */\n public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n-\n-    /** Default threshold above which off-diagonal elements are considered too different\n-     * and matrix not symmetric. */\n+    /**\n+     * Default threshold above which off-diagonal elements are considered too different\n+     * and matrix not symmetric.\n+     */\n     public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n-\n-    /** Default threshold below which diagonal elements are considered null\n-     * and matrix not positive definite. */\n+    /**\n+     * Default threshold below which diagonal elements are considered null\n+     * and matrix not positive definite.\n+     */\n     public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n-\n     /** Row-oriented storage for L<sup>T</sup> matrix data. */\n     private double[][] lTData;\n-\n     /** Cached value of L. */\n     private RealMatrix cachedL;\n-\n     /** Cached value of LT. */\n     private RealMatrix cachedLT;\n \n      * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n      * </p>\n      * @param matrix the matrix to decompose\n-     * @exception NonSquareMatrixException if matrix is not square\n-     * @exception NotSymmetricMatrixException if matrix is not symmetric\n-     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n-     * strictly positive definite\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite.\n      * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n      */\n-    public CholeskyDecompositionImpl(final RealMatrix matrix)\n-        throws NonSquareMatrixException,\n-               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n+    public CholeskyDecompositionImpl(final RealMatrix matrix) {\n         this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n              DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n     }\n      * elements are considered too different and matrix not symmetric\n      * @param absolutePositivityThreshold threshold below which diagonal\n      * elements are considered null and matrix not positive definite\n-     * @exception NonSquareMatrixException if matrix is not square\n-     * @exception NotSymmetricMatrixException if matrix is not symmetric\n-     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n-     * strictly positive definite\n+     * @throws NonSquareMatrixException if the matrix is not square.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws NonPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite.\n      * @see #CholeskyDecompositionImpl(RealMatrix)\n      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n      */\n     public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                      final double relativeSymmetryThreshold,\n-                                     final double absolutePositivityThreshold)\n-        throws NonSquareMatrixException,\n-               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n-\n+                                     final double absolutePositivityThreshold) {\n         if (!matrix.isSquare()) {\n             throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                                matrix.getColumnDimension());\n \n         // check the matrix before transformation\n         for (int i = 0; i < order; ++i) {\n-\n             final double[] lI = lTData[i];\n \n             // check off-diagonal elements (and reset them to 0)\n                 final double maxDelta =\n                     relativeSymmetryThreshold * FastMath.max(FastMath.abs(lIJ), FastMath.abs(lJI));\n                 if (FastMath.abs(lIJ - lJI) > maxDelta) {\n-                    throw new NotSymmetricMatrixException();\n+                    throw new NonSymmetricMatrixException(i, j, relativeSymmetryThreshold);\n                 }\n                 lJ[i] = 0;\n            }\n \n             // check diagonal element\n             if (ltI[i] < absolutePositivityThreshold) {\n-                throw new NotPositiveDefiniteMatrixException();\n+                throw new NonPositiveDefiniteMatrixException(i, absolutePositivityThreshold);\n             }\n \n             ltI[i] = FastMath.sqrt(ltI[i]);\n                     ltQ[p] -= ltI[q] * ltI[p];\n                 }\n             }\n-\n-        }\n-\n+        }\n     }\n \n     /** {@inheritDoc} */\n \n         // return the cached matrix\n         return cachedLT;\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-\n         /** Row-oriented storage for L<sup>T</sup> matrix data. */\n         private final double[][] lTData;\n \n         }\n \n         /** {@inheritDoc} */\n-        public double[] solve(double[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public double[] solve(double[] b) {\n             final int m = lTData.length;\n             if (b.length != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        b.length, m);\n+                throw new DimensionMismatchException(b.length, m);\n             }\n \n             final double[] x = b.clone();\n             }\n \n             return x;\n-\n-        }\n-\n-        /** {@inheritDoc} */\n-        public RealVector solve(RealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b) {\n             try {\n                 return solve((ArrayRealVector) b);\n             } catch (ClassCastException cce) {\n \n                 final int m = lTData.length;\n                 if (b.getDimension() != m) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                            b.getDimension(), m);\n+                    throw new DimensionMismatchException(b.getDimension(), m);\n                 }\n \n                 final double[] x = b.getData();\n                 }\n \n                 return new ArrayRealVector(x, false);\n-\n             }\n         }\n \n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X such that A &times; X = B\n-         * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n+         * @throws IllegalArgumentException if matrices dimensions don't match\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public ArrayRealVector solve(ArrayRealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix solve(RealMatrix b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public RealMatrix solve(RealMatrix b) {\n             final int m = lTData.length;\n             if (b.getRowDimension() != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n             }\n \n             final int nColB = b.getColumnDimension();\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix getInverse() throws InvalidMatrixException {\n+        public RealMatrix getInverse() {\n             return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.SingularMatrixException;\n+import org.apache.commons.math.exception.NonSymmetricMatrixException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n     /**\n      * Calculates the eigen decomposition of the given symmetric matrix.\n-     * @param matrix The <strong>symmetric</strong> matrix to decompose.\n-     * @param splitTolerance dummy parameter, present for backward compatibility only.\n-     * @exception InvalidMatrixException (wrapping a\n-     * {@link org.apache.commons.math.ConvergenceException} if algorithm\n-     * fails to converge\n-     */\n-    public EigenDecompositionImpl(final RealMatrix matrix,final double splitTolerance)\n-            throws InvalidMatrixException {\n-        if (isSymmetric(matrix)) {\n+     *\n+     * @param matrix Matrix to decompose. It <em>must</em> be symmetric.\n+     * @param splitTolerance Dummy parameter (present for backward\n+     * compatibility only).\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric.\n+     * @throws MaxCountExceededException if the algorithm fails to converge.\n+     */\n+    public EigenDecompositionImpl(final RealMatrix matrix,\n+                                  final double splitTolerance)  {\n+        if (isSymmetric(matrix, true)) {\n             transformToTridiagonal(matrix);\n             findEigenVectors(transformer.getQ().getData());\n-        } else {\n-            // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are\n-            // NOT supported\n-            // see issue https://issues.apache.org/jira/browse/MATH-235\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.ASSYMETRIC_EIGEN_NOT_SUPPORTED);\n         }\n     }\n \n     /**\n      * Calculates the eigen decomposition of the symmetric tridiagonal\n      * matrix.  The Householder matrix is assumed to be the identity matrix.\n+     *\n      * @param main Main diagonal of the symmetric triadiagonal form\n      * @param secondary Secondary of the tridiagonal form\n-     * @param splitTolerance dummy parameter, present for backward compatibility only.\n-     * @exception InvalidMatrixException (wrapping a\n-     * {@link org.apache.commons.math.ConvergenceException} if algorithm\n-     * fails to converge\n+     * @param splitTolerance Dummy parameter (present for backward\n+     * compatibility only).\n+     * @throws MaxCountExceededException if the algorithm fails to converge.\n      */\n     public EigenDecompositionImpl(final double[] main,final double[] secondary,\n-            final double splitTolerance)\n-            throws InvalidMatrixException {\n+                                  final double splitTolerance) {\n         this.main      = main.clone();\n         this.secondary = secondary.clone();\n         transformer    = null;\n \n     /**\n      * Check if a matrix is symmetric.\n-     * @param matrix\n-     *            matrix to check\n-     * @return true if matrix is symmetric\n-     */\n-    private boolean isSymmetric(final RealMatrix matrix) {\n+     *\n+     * @param matrix Matrix to check.\n+     * @param raiseException If {@code true}, the method will throw an\n+     * exception if {@code matrix} is not symmetric.\n+     * @return {@code true} if {@code matrix} is symmetric.\n+     * @throws NonSymmetricMatrixException if the matrix is not symmetric and\n+     * {@code raiseException} is {@code true}.\n+     */\n+    private boolean isSymmetric(final RealMatrix matrix,\n+                                boolean raiseException) {\n         final int rows = matrix.getRowDimension();\n         final int columns = matrix.getColumnDimension();\n         final double eps = 10 * rows * columns * MathUtils.EPSILON;\n                 final double mji = matrix.getEntry(j, i);\n                 if (FastMath.abs(mij - mji) >\n                     (FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * eps)) {\n+                    if (raiseException) {\n+                        throw new NonSymmetricMatrixException(i, j, eps);\n+                    }\n                     return false;\n                 }\n             }\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getV() throws InvalidMatrixException {\n+    public RealMatrix getV() {\n \n         if (cachedV == null) {\n             final int m = eigenvectors.length;\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getD() throws InvalidMatrixException {\n+    public RealMatrix getD() {\n         if (cachedD == null) {\n             // cache the matrix for subsequent calls\n             cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getVT() throws InvalidMatrixException {\n+    public RealMatrix getVT() {\n \n         if (cachedVt == null) {\n             final int m = eigenvectors.length;\n     }\n \n     /** {@inheritDoc} */\n-    public double[] getRealEigenvalues() throws InvalidMatrixException {\n+    public double[] getRealEigenvalues() {\n         return realEigenvalues.clone();\n     }\n \n     /** {@inheritDoc} */\n-    public double getRealEigenvalue(final int i) throws InvalidMatrixException,\n-            ArrayIndexOutOfBoundsException {\n+    public double getRealEigenvalue(final int i) {\n         return realEigenvalues[i];\n     }\n \n     /** {@inheritDoc} */\n-    public double[] getImagEigenvalues() throws InvalidMatrixException {\n+    public double[] getImagEigenvalues() {\n         return imagEigenvalues.clone();\n     }\n \n     /** {@inheritDoc} */\n-    public double getImagEigenvalue(final int i) throws InvalidMatrixException,\n-            ArrayIndexOutOfBoundsException {\n+    public double getImagEigenvalue(final int i) {\n         return imagEigenvalues[i];\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector getEigenvector(final int i)\n-            throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+    public RealVector getEigenvector(final int i) {\n         return eigenvectors[i].copy();\n     }\n \n          * @exception InvalidMatrixException\n          *                if decomposed matrix is singular\n          */\n-        public double[] solve(final double[] b)\n-                throws IllegalArgumentException, InvalidMatrixException {\n+        public double[] solve(final double[] b) {\n \n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n \n             final int m = realEigenvalues.length;\n             if (b.length != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        b.length, m);\n+                throw new DimensionMismatchException(b.length, m);\n             }\n \n             final double[] bp = new double[m];\n          * This method only find exact linear solutions, i.e. solutions for\n          * which ||A &times; X - B|| is exactly 0.\n          * </p>\n-         * @param b\n-         *            right-hand side of the equation A &times; X = B\n-         * @return a vector X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalArgumentException\n-         *                if matrices dimensions don't match\n-         * @exception InvalidMatrixException\n-         *                if decomposed matrix is singular\n+         * @param b Right-hand side of the equation A &times; X = B\n+         * @return a Vector X that minimizes the two norm of A &times; X - B\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n-        public RealVector solve(final RealVector b)\n-                throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public RealVector solve(final RealVector b) {\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n             }\n \n             final int m = realEigenvalues.length;\n             if (b.getDimension() != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH, b\n-                                .getDimension(), m);\n+                throw new DimensionMismatchException(b.getDimension(), m);\n             }\n \n             final double[] bp = new double[m];\n             }\n \n             return new ArrayRealVector(bp, false);\n-\n         }\n \n         /**\n          * This method only find exact linear solutions, i.e. solutions for\n          * which ||A &times; X - B|| is exactly 0.\n          * </p>\n-         * @param b\n-         *            right-hand side of the equation A &times; X = B\n-         * @return a matrix X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalArgumentException\n-         *                if matrices dimensions don't match\n-         * @exception InvalidMatrixException\n-         *                if decomposed matrix is singular\n+         * @param b Right-hand side of the equation A &times; X = B\n+         * @return a Matrix X that minimizes the two norm of A &times; X - B\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n-        public RealMatrix solve(final RealMatrix b)\n-                throws IllegalArgumentException, InvalidMatrixException {\n+        public RealMatrix solve(final RealMatrix b) {\n \n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n \n             final int m = realEigenvalues.length;\n             if (b.getRowDimension() != m) {\n-                throw MathRuntimeException\n-                        .createIllegalArgumentException(\n-                                LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                                b.getRowDimension(), b.getColumnDimension(), m,\n-                                \"n\");\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n             }\n \n             final int nColB = b.getColumnDimension();\n \n         /**\n          * Get the inverse of the decomposed matrix.\n-         * @return inverse matrix\n-         * @throws InvalidMatrixException\n-         *             if decomposed matrix is singular\n+         *\n+         * @return the inverse matrix.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n-        public RealMatrix getInverse() throws InvalidMatrixException {\n-\n+        public RealMatrix getInverse() {\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n             }\n                 }\n             }\n             return MatrixUtils.createRealMatrix(invData);\n-\n-        }\n-\n+        }\n     }\n \n     /**\n      * Transform matrix to tridiagonal.\n-     * @param matrix\n-     *            matrix to transform\n+     *\n+     * @param matrix Matrix to transform.\n      */\n     private void transformToTridiagonal(final RealMatrix matrix) {\n-\n         // transform the matrix to tridiagonal\n         transformer = new TriDiagonalTransformer(matrix);\n         main = transformer.getMainDiagonalRef();\n         secondary = transformer.getSecondaryDiagonalRef();\n-\n     }\n \n     /**\n      * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\n+     *\n      * @param householderMatrix Householder matrix of the transformation\n-     *  to tri-diagonal form.\n+     * to tri-diagonal form.\n      */\n     private void findEigenVectors(double[][] householderMatrix) {\n-\n         double[][]z = householderMatrix.clone();\n         final int n = main.length;\n         realEigenvalues = new double[n];\n                     }\n                 }\n                 if (m != j) {\n-                    if (its == maxIter)\n-                        throw new InvalidMatrixException(\n-                                new MaxIterationsExceededException(maxIter));\n+                    if (its == maxIter) {\n+                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n+                                                            maxIter);\n+                    }\n                     its++;\n                     double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n                     double t = FastMath.sqrt(1 + q * q);\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.SingularMatrixException;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n     /**\n      * Calculates the LU-decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n-     * @exception NonSquareMatrixException if matrix is not square\n+     * @throws NonSquareMatrixException if matrix is not square\n      */\n-    public FieldLUDecompositionImpl(FieldMatrix<T> matrix)\n-        throws NonSquareMatrixException {\n-\n+    public FieldLUDecompositionImpl(FieldMatrix<T> matrix) {\n         if (!matrix.isSquare()) {\n-            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n         }\n \n         final int m = matrix.getColumnDimension();\n         }\n \n         /** {@inheritDoc} */\n-        public T[] solve(T[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public T[] solve(T[] b) {\n             final int m = pivot.length;\n             if (b.length != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        b.length, m);\n+                throw new DimensionMismatchException(b.length, m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n         }\n \n         /** {@inheritDoc} */\n-        public FieldVector<T> solve(FieldVector<T> b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        public FieldVector<T> solve(FieldVector<T> b) {\n             try {\n                 return solve((ArrayFieldVector<T>) b);\n             } catch (ClassCastException cce) {\n \n                 final int m = pivot.length;\n                 if (b.getDimension() != m) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                            b.getDimension(), m);\n+                    throw new DimensionMismatchException(b.getDimension(), m);\n                 }\n                 if (singular) {\n                     throw new SingularMatrixException();\n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X such that A &times; X = B\n-         * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n+         * @throws IllegalArgumentException if matrices dimensions don't match\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public ArrayFieldVector<T> solve(ArrayFieldVector<T> b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        public ArrayFieldVector<T> solve(ArrayFieldVector<T> b) {\n             return new ArrayFieldVector<T>(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n-        public FieldMatrix<T> solve(FieldMatrix<T> b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public FieldMatrix<T> solve(FieldMatrix<T> b) {\n             final int m = pivot.length;\n             if (b.getRowDimension() != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n             }\n             return solve(identity);\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      * @return trace\n-     * @throws NonSquareMatrixException if the matrix is not square\n+     * @throws org.apache.commons.math.exception.NonSquareMatrixException\n+     * if the matrix is not square.\n      */\n     T getTrace();\n \n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * @since 2.0\n  */\n public class LUDecompositionImpl implements LUDecomposition {\n-\n     /** Default bound to determine effective singularity in LU decomposition */\n     private static final double DEFAULT_TOO_SMALL = 10E-12;\n-\n     /** Entries of LU decomposition. */\n     private double lu[][];\n-\n     /** Pivot permutation associated with LU decomposition */\n     private int[] pivot;\n-\n     /** Parity of the permutation associated with the LU decomposition */\n     private boolean even;\n-\n     /** Singularity indicator. */\n     private boolean singular;\n-\n     /** Cached value of L. */\n     private RealMatrix cachedL;\n-\n     /** Cached value of U. */\n     private RealMatrix cachedU;\n-\n     /** Cached value of P. */\n     private RealMatrix cachedP;\n \n     /**\n      * Calculates the LU-decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n-     * @exception InvalidMatrixException if matrix is not square\n+     * @throws InvalidMatrixException if matrix is not square\n      */\n     public LUDecompositionImpl(RealMatrix matrix)\n         throws InvalidMatrixException {\n      * @param matrix The matrix to decompose.\n      * @param singularityThreshold threshold (based on partial row norm)\n      * under which a matrix is considered singular\n-     * @exception NonSquareMatrixException if matrix is not square\n+     * @throws NonSquareMatrixException if matrix is not square\n      */\n-    public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n-        throws NonSquareMatrixException {\n-\n+    public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold) {\n         if (!matrix.isSquare()) {\n-            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n         }\n \n         final int m = matrix.getColumnDimension();\n                 lu[row][col] /= luDiag;\n             }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         /** {@inheritDoc} */\n-        public double[] solve(double[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public double[] solve(double[] b) {\n             final int m = pivot.length;\n             if (b.length != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH, b.length, m);\n+                throw new DimensionMismatchException(b.length, m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n             }\n \n             return bp;\n-\n         }\n \n         /** {@inheritDoc} */\n-        public RealVector solve(RealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        public RealVector solve(RealVector b) {\n             try {\n                 return solve((ArrayRealVector) b);\n             } catch (ClassCastException cce) {\n \n                 final int m = pivot.length;\n                 if (b.getDimension() != m) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.VECTOR_LENGTH_MISMATCH, b.getDimension(), m);\n+                    throw new DimensionMismatchException(b.getDimension(), m);\n                 }\n                 if (singular) {\n                     throw new SingularMatrixException();\n                 }\n \n                 return new ArrayRealVector(bp, false);\n-\n             }\n         }\n \n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X such that A &times; X = B\n-         * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n+         * @throws DimensionMismatchException if the matrices dimensions\n+         * do not match.\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public ArrayRealVector solve(ArrayRealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix solve(RealMatrix b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n+        public RealMatrix solve(RealMatrix b) {\n \n             final int m = pivot.length;\n             if (b.getRowDimension() != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n             }\n             if (singular) {\n                 throw new SingularMatrixException();\n             }\n \n             return new Array2DRowRealMatrix(bp, false);\n-\n         }\n \n         /** {@inheritDoc} */\n         public RealMatrix getInverse() throws InvalidMatrixException {\n             return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n  * Thrown when an operation defined only for square matrices is applied to non-square ones.\n  * @version $Revision$ $Date$\n  * @since 2.0\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.DimensionMismatchException} instead.\n  */\n public class NonSquareMatrixException extends InvalidMatrixException {\n \n--- a/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n  *\n  * @since 1.2\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.NonPositiveDefiniteMatrixException} instead.\n  */\n \n public class NotPositiveDefiniteMatrixException extends MathException {\n--- a/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n  *\n  * @since 2.0\n  * @version $Revision$ $Date$\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.NonSymmetricMatrixException} instead.\n  */\n \n public class NotSymmetricMatrixException extends MathException {\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.MathRuntimeException;\n-import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n \n                     cachedR.setEntry(row, col, qrt[col][row]);\n                 }\n             }\n-\n         }\n \n         // return the cached matrix\n         return cachedR;\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public RealMatrix getQT() {\n-\n         if (cachedQT == null) {\n \n             // QT is supposed to be m x m\n                     }\n                 }\n             }\n-\n         }\n \n         // return the cached matrix\n         return cachedQT;\n-\n     }\n \n     /** {@inheritDoc} */\n     public RealMatrix getH() {\n-\n         if (cachedH == null) {\n \n             final int n = qrt.length;\n                     cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);\n                 }\n             }\n-\n         }\n \n         // return the cached matrix\n         return cachedH;\n-\n     }\n \n     /** {@inheritDoc} */\n                 }\n             }\n             return true;\n-\n         }\n \n         /** {@inheritDoc} */\n-        public double[] solve(double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public double[] solve(double[] b) {\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n             if (b.length != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        b.length, m);\n+                throw new DimensionMismatchException(b.length, m);\n             }\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n                 for (int row = minor; row < m; row++) {\n                     y[row] += dotProduct * qrtMinor[row];\n                 }\n-\n             }\n \n             // solve triangular system R.x = y\n             }\n \n             return x;\n-\n         }\n \n         /** {@inheritDoc} */\n-        public RealVector solve(RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        public RealVector solve(RealVector b) {\n             try {\n                 return solve((ArrayRealVector) b);\n             } catch (ClassCastException cce) {\n          * @throws IllegalArgumentException if matrices dimensions don't match\n          * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public ArrayRealVector solve(ArrayRealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n+        public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix solve(RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n+        public RealMatrix solve(RealMatrix b) {\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n             if (b.getRowDimension() != m) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+                throw new DimensionMismatchException(b.getRowDimension(), m);\n             }\n             if (!isNonSingular()) {\n                 throw new SingularMatrixException();\n                             yRow[k] += alpha[k] * d;\n                         }\n                     }\n-\n                 }\n \n                 // solve triangular system R.x = y\n                             yI[k] -= yJ[k] * rIJ;\n                         }\n                     }\n-\n-                }\n-\n+                }\n             }\n \n             return new BlockRealMatrix(n, columns, xBlocks, false);\n-\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix getInverse()\n-        throws InvalidMatrixException {\n+        public RealMatrix getInverse() {\n             return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n         }\n-\n-    }\n-\n+    }\n }\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n-     * @return trace\n-     * @throws NonSquareMatrixException if the matrix is not square\n+     * @return the trace.\n+     * @throws org.apache.commons.math.exception.NonSquareMatrixException\n+     * if the matrix is not square.\n      */\n     double getTrace();\n \n--- a/src/main/java/org/apache/commons/math/linear/SingularMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularMatrixException.java\n  * Thrown when a matrix is singular.\n  * @version $Revision$ $Date$\n  * @since 2.0\n+ * @deprecated in 2.2 (to be removed in 3.0). Please use\n+ * {@link org.apache.commons.math.exception.SingularMatrixException} instead.\n  */\n public class SingularMatrixException extends InvalidMatrixException {\n \n--- a/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n \n import java.util.Arrays;\n \n+import org.apache.commons.math.exception.NonSquareMatrixException;\n import org.apache.commons.math.util.FastMath;\n \n \n  * @since 2.0\n  */\n class TriDiagonalTransformer {\n-\n     /** Householder vectors. */\n     private final double householderVectors[][];\n-\n     /** Main diagonal. */\n     private final double[] main;\n-\n     /** Secondary diagonal. */\n     private final double[] secondary;\n-\n     /** Cached value of Q. */\n     private RealMatrix cachedQ;\n-\n     /** Cached value of Qt. */\n     private RealMatrix cachedQt;\n-\n     /** Cached value of T. */\n     private RealMatrix cachedT;\n \n      * Build the transformation to tridiagonal shape of a symmetrical matrix.\n      * <p>The specified matrix is assumed to be symmetrical without any check.\n      * Only the upper triangular part of the matrix is used.</p>\n-     * @param matrix the symmetrical matrix to transform.\n-     * @exception InvalidMatrixException if matrix is not square\n-     */\n-    public TriDiagonalTransformer(RealMatrix matrix)\n-        throws InvalidMatrixException {\n+     *\n+     * @param matrix Symmetrical matrix to transform.\n+     * @exception NonSquareMatrixException if the matrix is not square.\n+     */\n+    public TriDiagonalTransformer(RealMatrix matrix) {\n         if (!matrix.isSquare()) {\n             throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n         }\n \n         // transform matrix\n         transform();\n-\n     }\n \n     /**\n      * @return the Q matrix\n      */\n     public RealMatrix getQT() {\n-\n         if (cachedQt == null) {\n-\n             final int m = householderVectors.length;\n             cachedQt = MatrixUtils.createRealMatrix(m, m);\n \n                 }\n             }\n             cachedQt.setEntry(0, 0, 1);\n-\n         }\n \n         // return the cached matrix\n         return cachedQt;\n-\n     }\n \n     /**\n      * @return the T matrix\n      */\n     public RealMatrix getT() {\n-\n         if (cachedT == null) {\n-\n             final int m = main.length;\n             cachedT = MatrixUtils.createRealMatrix(m, m);\n             for (int i = 0; i < m; ++i) {\n \n         // return the cached matrix\n         return cachedT;\n-\n     }\n \n     /**\n      * <p>Transformation is done using Householder transforms.</p>\n      */\n     private void transform() {\n-\n         final int m = householderVectors.length;\n         final double[] z = new double[m];\n         for (int k = 0; k < m - 1; k++) {\n                         hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n                     }\n                 }\n-\n-            }\n-\n+            }\n         }\n         main[m - 1] = householderVectors[m - 1][m - 1];\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-import org.apache.commons.math.exception.ConvergenceException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n \n     /**\n      * Update the jacobian matrix.\n-     * @exception FunctionEvaluationException if the function jacobian\n-     * cannot be evaluated or its dimension doesn't match problem dimension\n-     */\n-    protected void updateJacobian() throws FunctionEvaluationException {\n+     *\n+     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n+     * if the function Jacobian cannot be evaluated.\n+     * @throws DimensionMismatchException if the Jacobian dimension does not\n+     * match problem dimension.\n+     */\n+    protected void updateJacobian() {\n         ++jacobianEvaluations;\n         weightedResidualJacobian = jF.value(point);\n         if (weightedResidualJacobian.length != rows) {\n-            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                                                  weightedResidualJacobian.length, rows);\n+            throw new DimensionMismatchException(weightedResidualJacobian.length, rows);\n         }\n \n         final double[] residualsWeights = getWeightRef();\n \n     /**\n      * Update the residuals array and cost function value.\n-     * @exception FunctionEvaluationException if the function cannot be evaluated\n-     * or its dimension doesn't match problem dimension or maximal number of\n-     * of evaluations is exceeded\n-     */\n-    protected void updateResidualsAndCost() throws FunctionEvaluationException {\n+     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n+     * if the function cannot be evaluated.\n+     * @throws DimensionMismatchException if the dimension does not match the\n+     * problem dimension.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the maximal number of evaluations is exceeded.\n+     */\n+    protected void updateResidualsAndCost() {\n         objective = computeObjectiveValue(point);\n         if (objective.length != rows) {\n-            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                                                  objective.length, rows);\n+            throw new DimensionMismatchException(objective.length, rows);\n         }\n \n         final double[] targetValues = getTargetRef();\n     }\n \n     /**\n-     * Get the covariance matrix of optimized parameters.\n-     * @return covariance matrix\n-     * @exception FunctionEvaluationException if the function jacobian cannot\n-     * be evaluated\n-     * @exception ConvergenceException if the covariance matrix\n-     * cannot be computed (singular problem)\n-     */\n-    public double[][] getCovariances()\n-        throws FunctionEvaluationException {\n-\n+     * Get the covariance matrix of the optimized parameters.\n+     *\n+     * @return the covariance matrix.\n+     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n+     * if the function Jacobian cannot be evaluated.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the covariance matrix cannot be computed (singular problem).\n+     */\n+    public double[][] getCovariances() {\n         // set up the jacobian\n         updateJacobian();\n \n             }\n         }\n \n-        try {\n-            // compute the covariances matrix\n-            RealMatrix inverse =\n-                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n-            return inverse.getData();\n-        } catch (InvalidMatrixException ime) {\n-            throw new ConvergenceException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n-        }\n-\n+        // compute the covariances matrix\n+        RealMatrix inverse =\n+            new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n+        return inverse.getData();\n     }\n \n     /**\n      * Guess the errors in optimized parameters.\n-     * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n+     * Guessing is covariance-based: It only gives a rough order of magnitude.\n+     *\n      * @return errors in optimized parameters\n-     * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\n-     * @exception ConvergenceException if the covariances matrix cannot be computed\n-     * or the number of degrees of freedom is not positive (number of measurements\n-     * lesser or equal to number of parameters)\n-     */\n-    public double[] guessParametersErrors()\n-        throws FunctionEvaluationException {\n+     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n+     * if the function Jacobian cannot be evaluated.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException if\n+     * the covariances matrix cannot be computed.\n+     * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n+     * positive, i.e. the number of measurements is less or equal to the number of\n+     * parameters.\n+     */\n+    public double[] guessParametersErrors() {\n         if (rows <= cols) {\n-            throw new ConvergenceException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n-                                           rows, cols);\n+            throw new NumberIsTooSmallException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n+                                                rows, cols, false);\n         }\n         double[] errors = new double[cols];\n         final double c = FastMath.sqrt(getChiSquare() / (rows - cols));\n     @Override\n     public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                             final double[] target, final double[] weights,\n-                                            final double[] startPoint)\n-        throws FunctionEvaluationException {\n+                                            final double[] startPoint) {\n         // Reset counter.\n         jacobianEvaluations = 0;\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.FunctionEvaluationException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.BlockRealMatrix;\n import org.apache.commons.math.linear.DecompositionSolver;\n-import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n \n                 for (int i = 0; i < cols; ++i) {\n                     point[i] += dX[i];\n                 }\n-            } catch (InvalidMatrixException e) {\n+            } catch (SingularMatrixException e) {\n                 throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n             }\n \n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link Array2DRowRealMatrix} class.\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link BlockFieldMatrix} class.\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link BlockRealMatrix} class.\n--- a/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n import static org.junit.Assert.assertTrue;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.linear.CholeskyDecomposition;\n-import org.apache.commons.math.linear.CholeskyDecompositionImpl;\n-import org.apache.commons.math.linear.MatrixUtils;\n-import org.apache.commons.math.linear.NonSquareMatrixException;\n-import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;\n-import org.apache.commons.math.linear.NotSymmetricMatrixException;\n-import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n+import org.apache.commons.math.exception.NonPositiveDefiniteMatrixException;\n+import org.apache.commons.math.exception.NonSymmetricMatrixException;\n import org.junit.Test;\n \n public class CholeskyDecompositionImplTest {\n     }\n \n     /** test non-symmetric matrix */\n-    @Test(expected = NotSymmetricMatrixException.class)\n+    @Test(expected = NonSymmetricMatrixException.class)\n     public void testNotSymmetricMatrixException() throws MathException {\n         double[][] changed = testData.clone();\n         changed[0][changed[0].length - 1] += 1.0e-5;\n     }\n \n     /** test non positive definite matrix */\n-    @Test(expected = NotPositiveDefiniteMatrixException.class)\n+    @Test(expected = NonPositiveDefiniteMatrixException.class)\n     public void testNotPositiveDefinite() throws MathException {\n         new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n                 { 14, 11, 13, 15, 24 },\n         }));\n     }\n \n-    @Test(expected = NotPositiveDefiniteMatrixException.class)\n+    @Test(expected = NonPositiveDefiniteMatrixException.class)\n     public void testMath274() throws MathException {\n         new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n                 { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n--- a/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n import junit.framework.TestCase;\n \n import org.apache.commons.math.util.MathUtils;\n         try {\n             es.getInverse();\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n+        } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n public class FieldLUDecompositionImplTest extends TestCase {\n     private Fraction[][] testData = {\n                     { Fraction.ZERO, Fraction.ZERO },\n                     { Fraction.ZERO, Fraction.ZERO }\n             }));\n-        } catch (InvalidMatrixException ime) {\n+        } catch (NonSquareMatrixException ime) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link Array2DRowFieldMatrix} class.\n--- a/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.exception.NonSquareMatrixException;\n import junit.framework.TestCase;\n \n public class LUDecompositionImplTest extends TestCase {\n     public void testNonSquare() {\n         try {\n             new LUDecompositionImpl(MatrixUtils.createRealMatrix(new double[3][2]));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ime) {\n+            fail(\"Expecting NonSquareMatrixException\");\n+        } catch (NonSquareMatrixException ime) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n import junit.framework.TestCase;\n \n public class LUSolverTest extends TestCase {\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n+        } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n+        } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumnVector(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n+        } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n         try {\n             solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0)));\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n+        } catch (SingularMatrixException ime) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n \n import java.util.Random;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n import junit.framework.TestCase;\n \n public class QRSolverTest extends TestCase {\n         try {\n             solver.solve(b);\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException iae) {\n+        } catch (SingularMatrixException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumn(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException iae) {\n+        } catch (SingularMatrixException iae) {\n             // expected behavior\n         }\n         try {\n             solver.solve(b.getColumnVector(0));\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException iae) {\n+        } catch (SingularMatrixException iae) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link SparseFieldMatrix} class.\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n /**\n  * Test cases for the {@link OpenMapRealMatrix} class.\n--- a/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n import java.util.Arrays;\n \n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.NonSquareMatrixException;\n \n import junit.framework.TestCase;\n \n         try {\n             new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2]));\n             fail(\"an exception should have been thrown\");\n-        } catch (InvalidMatrixException ime) {\n+        } catch (NonSquareMatrixException ime) {\n             // expected behavior\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n-\n     }\n \n     public void testMoreEstimatedParametersUnsorted() throws Exception {\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (FunctionEvaluationException oe) {\n+        } catch (DimensionMismatchException oe) {\n             // expected behavior\n         }\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.math.exception.SingularMatrixException;\n import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.BlockRealMatrix;\n         super(name);\n     }\n \n-    public void testTrivial() throws FunctionEvaluationException {\n+    public void testTrivial() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         try {\n             optimizer.guessParametersErrors();\n             fail(\"an exception should have been thrown\");\n-        } catch (ConvergenceException ee) {\n+        } catch (NumberIsTooSmallException ee) {\n             // expected behavior\n         }\n         assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testQRColumnsPermutation() throws FunctionEvaluationException {\n+    public void testQRColumnsPermutation() {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n         assertEquals(1.0, optimum.getValue()[2], 1.0e-10);\n     }\n \n-    public void testNoDependency() throws FunctionEvaluationException {\n+    public void testNoDependency() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws FunctionEvaluationException {\n+    public void testOneSet() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n         assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n     }\n \n-    public void testTwoSets() throws FunctionEvaluationException {\n+    public void testTwoSets() {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n         assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10);\n     }\n \n-    public void testNonInversible() throws FunctionEvaluationException {\n+    public void testNonInvertible() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n         try {\n             optimizer.getCovariances();\n             fail(\"an exception should have been thrown\");\n-        } catch (ConvergenceException ee) {\n+        } catch (SingularMatrixException ee) {\n             // expected behavior\n         }\n     }\n \n-    public void testIllConditioned() throws FunctionEvaluationException {\n+    public void testIllConditioned() {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n         assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-8);\n     }\n \n-    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException {\n+    public void testMoreEstimatedParametersSimple() {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n     }\n \n-    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException {\n+    public void testMoreEstimatedParametersUnsorted() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n         assertEquals(6.0, optimum.getPointRef()[5], 1.0e-10);\n     }\n \n-    public void testRedundantEquations() throws FunctionEvaluationException {\n+    public void testRedundantEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         assertEquals(1.0, optimum.getPointRef()[1], 1.0e-10);\n     }\n \n-    public void testInconsistentEquations() throws FunctionEvaluationException {\n+    public void testInconsistentEquations() {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n         assertTrue(optimizer.getRMS() > 0.1);\n     }\n \n-    public void testInconsistentSizes() throws FunctionEvaluationException {\n+    public void testInconsistentSizes() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (FunctionEvaluationException oe) {\n+        } catch (DimensionMismatchException oe) {\n             // expected behavior\n         }\n     }\n             optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n             assertTrue(!shouldFail);\n-        } catch (FunctionEvaluationException ee) {\n+        } catch (DimensionMismatchException ee) {\n             assertTrue(shouldFail);\n         } catch (TooManyEvaluationsException ee) {\n             assertTrue(shouldFail);\n         }\n     }\n \n-    public void testCircleFitting() throws FunctionEvaluationException {\n+    public void testCircleFitting() {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         assertEquals(0.004, errors[1], 0.001);\n     }\n \n-    public void testCircleFittingBadInit() throws FunctionEvaluationException {\n+    public void testCircleFittingBadInit() {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n         assertEquals( 0.2075001, center.y,      1.0e-6);\n     }\n \n-    public void testMath199() throws FunctionEvaluationException {\n+    public void testMath199() {\n         try {\n             QuadraticProblem problem = new QuadraticProblem();\n             problem.addPoint (0, -3.182591015485607);", "timestamp": 1289399016, "metainfo": ""}