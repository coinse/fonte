{"sha": "126b3e5e783890bb967f5f831d56e62e19df567d", "log": "MATH-621 Function \"altmov\": All local variables defined at initialization.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n         final ArrayRealVector work1 = new ArrayRealVector(n);\n         final ArrayRealVector work2 = new ArrayRealVector(n);\n \n-        double alpha = Double.NaN;\n-        double cauchy = Double.NaN;\n-\n-        // System generated locals\n-        double d__1, d__2, d__3, d__4;\n-\n-        // Local variables\n-        double ha, gw, diff;\n-        int ilbd, isbd;\n-        double slbd;\n-        int iubd;\n-        double vlag, subd, temp;\n-        int ksav = 0;\n-        double step = 0, curv = 0;\n-        int iflag;\n-        double scale = 0, csave = 0, tempa = 0, tempb = 0, tempd = 0, const__ = 0, sumin = 0, \n-        ggfree = 0;\n-        int ibdsav = 0;\n-        double dderiv = 0, bigstp = 0, predsq = 0, presav = 0, distsq = 0, stpsav = 0, wfixsq = 0, wsqsav = 0;\n-\n-\n-        // Function Body\n-        const__ = ONE + Math.sqrt(2.);\n         for (int k = 0; k < npt; k++) {\n             hcol.setEntry(k, ZERO);\n         }\n         for (int j = 0, max = npt - n - 1; j < max; j++) {\n-            temp = zmat.getEntry(knew, j);\n+            final double tmp = zmat.getEntry(knew, j);\n             for (int k = 0; k < npt; k++) {\n-                hcol.setEntry(k, hcol.getEntry(k) + temp * zmat.getEntry(k, j));\n-            }\n-        }\n-        alpha = hcol.getEntry(knew);\n-        ha = HALF * alpha;\n+                hcol.setEntry(k, hcol.getEntry(k) + tmp * zmat.getEntry(k, j));\n+            }\n+        }\n+        final double alpha = hcol.getEntry(knew);\n+        final double ha = HALF * alpha;\n \n         // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n \n             glag.setEntry(i, bmat.getEntry(knew, i));\n         }\n         for (int k = 0; k < npt; k++) {\n-            temp = ZERO;\n+            double tmp = ZERO;\n             for (int j = 0; j < n; j++) {\n-                temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n-            }\n-            temp = hcol.getEntry(k) * temp;\n+                tmp += xpt.getEntry(k, j) * xopt.getEntry(j);\n+            }\n+            tmp *= hcol.getEntry(k);\n             for (int i = 0; i < n; i++) {\n-                glag.setEntry(i, glag.getEntry(i) + temp * xpt.getEntry(k, i));\n+                glag.setEntry(i, glag.getEntry(i) + tmp * xpt.getEntry(k, i));\n             }\n         }\n \n         // set to the square of the predicted denominator for each line. PRESAV\n         // will be set to the largest admissible value of PREDSQ that occurs.\n \n-        presav = ZERO;\n+        double presav = ZERO;\n+        double step = Double.NaN;\n+        int ksav = 0;\n+        int ibdsav = 0;\n+        double stpsav = 0;\n         for (int k = 0; k < npt; k++) {\n             if (k == trustRegionCenterInterpolationPointIndex) {\n                 continue;\n             }\n-            dderiv = ZERO;\n-            distsq = ZERO;\n+            double dderiv = ZERO;\n+            double distsq = ZERO;\n             for (int i = 0; i < n; i++) {\n-                temp = xpt.getEntry(k, i) - xopt.getEntry(i);\n-                dderiv += glag.getEntry(i) * temp;\n-                distsq += temp * temp;\n-            }\n-            subd = adelt / Math.sqrt(distsq);\n-            slbd = -subd;\n-            ilbd = 0;\n-            iubd = 0;\n-            sumin = Math.min(ONE, subd);\n+                final double tmp = xpt.getEntry(k, i) - xopt.getEntry(i);\n+                dderiv += glag.getEntry(i) * tmp;\n+                distsq += tmp * tmp;\n+            }\n+            double subd = adelt / Math.sqrt(distsq);\n+            double slbd = -subd;\n+            int ilbd = 0;\n+            int iubd = 0;\n+            final double sumin = Math.min(ONE, subd);\n \n             // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n \n             for (int i = 0; i < n; i++) {\n-                temp = xpt.getEntry(k, i) - xopt.getEntry(i);\n-                if (temp > ZERO) {\n-                    if (slbd * temp < sl.getEntry(i) - xopt.getEntry(i)) {\n-                        slbd = (sl.getEntry(i) - xopt.getEntry(i)) / temp;\n+                final double tmp = xpt.getEntry(k, i) - xopt.getEntry(i);\n+                if (tmp > ZERO) {\n+                    if (slbd * tmp < sl.getEntry(i) - xopt.getEntry(i)) {\n+                        slbd = (sl.getEntry(i) - xopt.getEntry(i)) / tmp;\n                         ilbd = -i - 1;\n                     }\n-                    if (subd * temp > su.getEntry(i) - xopt.getEntry(i)) {\n+                    if (subd * tmp > su.getEntry(i) - xopt.getEntry(i)) {\n                         // Computing MAX\n-                        d__1 = sumin;\n-                        d__2 = (su.getEntry(i) - xopt.getEntry(i)) / temp;\n-                        subd = Math.max(d__1, d__2);\n-                        iubd = i+1;\n-                    }\n-                } else if (temp < ZERO) {\n-                    if (slbd * temp > su.getEntry(i) - xopt.getEntry(i)) {\n-                        slbd = (su.getEntry(i) - xopt.getEntry(i)) / temp;\n-                        ilbd = i+1;\n-                    }\n-                    if (subd * temp < sl.getEntry(i) - xopt.getEntry(i)) {\n+                        subd = Math.max(sumin,\n+                                        (su.getEntry(i) - xopt.getEntry(i)) / tmp);\n+                        iubd = i + 1;\n+                    }\n+                } else if (tmp < ZERO) {\n+                    if (slbd * tmp > su.getEntry(i) - xopt.getEntry(i)) {\n+                        slbd = (su.getEntry(i) - xopt.getEntry(i)) / tmp;\n+                        ilbd = i + 1;\n+                    }\n+                    if (subd * tmp < sl.getEntry(i) - xopt.getEntry(i)) {\n                         // Computing MAX\n-                        d__1 = sumin;\n-                        d__2 = (sl.getEntry(i) - xopt.getEntry(i)) / temp;\n-                        subd = Math.max(d__1, d__2);\n+                        subd = Math.max(sumin,\n+                                        (sl.getEntry(i) - xopt.getEntry(i)) / tmp);\n                         iubd = -i - 1;\n                     }\n                 }\n             // Seek a large modulus of the KNEW-th Lagrange function when the index\n             // of the other interpolation point on the line through XOPT is KNEW.\n \n+            step = slbd;\n+            int isbd = ilbd;\n+            double vlag = Double.NaN;\n             if (k == knew) {\n-                diff = dderiv - ONE;\n-                step = slbd;\n+                final double diff = dderiv - ONE;\n                 vlag = slbd * (dderiv - slbd * diff);\n-                isbd = ilbd;\n-                temp = subd * (dderiv - subd * diff);\n-                if (Math.abs(temp) > Math.abs(vlag)) {\n+                final double d1 = subd * (dderiv - subd * diff);\n+                if (Math.abs(d1) > Math.abs(vlag)) {\n                     step = subd;\n-                    vlag = temp;\n+                    vlag = d1;\n                     isbd = iubd;\n                 }\n-                tempd = HALF * dderiv;\n-                tempa = tempd - diff * slbd;\n-                tempb = tempd - diff * subd;\n-                if (tempa * tempb < ZERO) {\n-                    temp = tempd * tempd / diff;\n-                    if (Math.abs(temp) > Math.abs(vlag)) {\n-                        step = tempd / diff;\n-                        vlag = temp;\n+                final double d2 = HALF * dderiv;\n+                final double d3 = d2 - diff * slbd;\n+                final double d4 = d2 - diff * subd;\n+                if (d3 * d4 < ZERO) {\n+                    final double d5 = d2 * d2 / diff;\n+                    if (Math.abs(d5) > Math.abs(vlag)) {\n+                        step = d2 / diff;\n+                        vlag = d5;\n                         isbd = 0;\n                     }\n                 }\n                 // Search along each of the other lines through XOPT and another point.\n \n             } else {\n-                step = slbd;\n                 vlag = slbd * (ONE - slbd);\n-                isbd = ilbd;\n-                temp = subd * (ONE - subd);\n-                if (Math.abs(temp) > Math.abs(vlag)) {\n+                final double tmp = subd * (ONE - subd);\n+                if (Math.abs(tmp) > Math.abs(vlag)) {\n                     step = subd;\n-                    vlag = temp;\n+                    vlag = tmp;\n                     isbd = iubd;\n                 }\n                 if (subd > HALF) {\n-                    if (Math.abs(vlag) < .25) {\n+                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n                         step = HALF;\n                         vlag = ONE_OVER_FOUR;\n                         isbd = 0;\n \n             // Calculate PREDSQ for the current line search and maintain PRESAV.\n \n-            temp = step * (ONE - step) * distsq;\n-            predsq = vlag * vlag * (vlag * vlag + ha * temp * temp);\n+            final double tmp = step * (ONE - step) * distsq;\n+            final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);\n             if (predsq > presav) {\n                 presav = predsq;\n                 ksav = k;\n         // Construct XNEW in a way that satisfies the bound constraints exactly.\n \n         for (int i = 0; i < n; i++) {\n-            temp = xopt.getEntry(i) + stpsav * (xpt.getEntry(ksav, i) - xopt.getEntry(i));\n-            // Computing MAX\n-            // Computing MIN\n-            d__3 = su.getEntry(i);\n-            d__1 = sl.getEntry(i);\n-            d__2 = Math.min(d__3, temp);\n-            xnew.setEntry(i, Math.max(d__1, d__2));\n+            final double tmp = xopt.getEntry(i) + stpsav * (xpt.getEntry(ksav, i) - xopt.getEntry(i));\n+            xnew.setEntry(i, Math.max(sl.getEntry(i),\n+                                      Math.min(su.getEntry(i), tmp)));\n         }\n         if (ibdsav < 0) {\n             xnew.setEntry(-ibdsav - 1, sl.getEntry(-ibdsav - 1));\n         // step in W. The sum of squares of the fixed components of W is formed in\n         // WFIXSQ, and the free components of W are set to BIGSTP.\n \n-        bigstp = adelt + adelt;\n-        iflag = 0;\n-\n+        final double bigstp = adelt + adelt;\n+        int iflag = 0;\n+        double cauchy = Double.NaN;\n+        double csave = ZERO;\n         L100: for(;;) {\n-            wfixsq = ZERO;\n-            ggfree = ZERO;\n+            double wfixsq = ZERO;\n+            double ggfree = ZERO;\n             for (int i = 0; i < n; i++) {\n+                final double glagValue = glag.getEntry(i);\n                 work1.setEntry(i, ZERO);\n-                // Computing MIN\n-                d__1 = xopt.getEntry(i) - sl.getEntry(i);\n-                d__2 = glag.getEntry(i);\n-                tempa = Math.min(d__1, d__2);\n-                // Computing MAX\n-                d__1 = xopt.getEntry(i) - su.getEntry(i);\n-                d__2 = glag.getEntry(i);\n-                tempb = Math.max(d__1, d__2);\n-                if (tempa > ZERO || tempb < ZERO) {\n+                if (Math.min(xopt.getEntry(i) - sl.getEntry(i), glagValue) > ZERO ||\n+                    Math.max(xopt.getEntry(i) - su.getEntry(i), glagValue) < ZERO) {\n                     work1.setEntry(i, bigstp);\n                     // Computing 2nd power\n-                    final double d1 = glag.getEntry(i);\n-                    ggfree += d1 * d1;\n+                    ggfree += glagValue * glagValue;\n                 }\n             }\n             if (ggfree == ZERO) {\n-                cauchy = ZERO;\n-                return new double[] { alpha, cauchy };\n+                return new double[] { alpha, ZERO };\n             }\n \n             // Investigate whether more components of W can be fixed.\n             L120: {\n-                temp = adelt * adelt - wfixsq;\n-                if (temp > ZERO) {\n-                    wsqsav = wfixsq;\n-                    step = Math.sqrt(temp / ggfree);\n+                final double tmp = adelt * adelt - wfixsq;\n+                if (tmp > ZERO) {\n+                    final double wsqsav = wfixsq;\n+                    step = Math.sqrt(tmp / ggfree);\n                     ggfree = ZERO;\n                     for (int i = 0; i < n; i++) {\n                         if (work1.getEntry(i) == bigstp) {\n-                            temp = xopt.getEntry(i) - step * glag.getEntry(i);\n-                            if (temp <= sl.getEntry(i)) {\n+                            final double tmp2 = xopt.getEntry(i) - step * glag.getEntry(i);\n+                            if (tmp2 <= sl.getEntry(i)) {\n                                 work1.setEntry(i, sl.getEntry(i) - xopt.getEntry(i));\n                                 // Computing 2nd power\n                                 final double d1 = work1.getEntry(i);\n                                 wfixsq += d1 * d1;\n-                            } else if (temp >= su.getEntry(i)) {\n+                            } else if (tmp2 >= su.getEntry(i)) {\n                                 work1.setEntry(i, su.getEntry(i) - xopt.getEntry(i));\n                                 // Computing 2nd power\n                                 final double d1 = work1.getEntry(i);\n                             }\n                         }\n                     }\n-                    if (!(wfixsq > wsqsav && ggfree > ZERO)) {\n+                    if (!(wfixsq > wsqsav &&\n+                          ggfree > ZERO)) {\n                         break L120;\n                     }\n                 }} // end L120\n             // Set the remaining free components of W and all components of XALT,\n             // except that W may be scaled later.\n \n-            gw = ZERO;\n+            double gw = ZERO;\n             for (int i = 0; i < n; i++) {\n+                final double glagValue = glag.getEntry(i);\n                 if (work1.getEntry(i) == bigstp) {\n-                    work1.setEntry(i, -step * glag.getEntry(i));\n+                    work1.setEntry(i, -step * glagValue);\n                     final double min = Math.min(su.getEntry(i),\n                                                 xopt.getEntry(i) + work1.getEntry(i));\n                     xalt.setEntry(i, Math.max(sl.getEntry(i), min));\n                 } else if (work1.getEntry(i) == ZERO) {\n                     xalt.setEntry(i, xopt.getEntry(i));\n-                } else if (glag.getEntry(i) > ZERO) {\n+                } else if (glagValue > ZERO) {\n                     xalt.setEntry(i, sl.getEntry(i));\n                 } else {\n                     xalt.setEntry(i, su.getEntry(i));\n                 }\n-                gw += glag.getEntry(i) * work1.getEntry(i);\n+                gw += glagValue * work1.getEntry(i);\n             }\n \n             // Set CURV to the curvature of the KNEW-th Lagrange function along W.\n             // the Lagrange function at XOPT+W. Set CAUCHY to the final value of\n             // the square of this function.\n \n-            curv = ZERO;\n+            double curv = ZERO;\n             for (int k = 0; k < npt; k++) {\n-                temp = ZERO;\n+                double tmp = ZERO;\n                 for (int j = 0; j < n; j++) {\n-                    temp += xpt.getEntry(k, j) * work1.getEntry(j);\n-                }\n-                curv += hcol.getEntry(k) * temp * temp;\n+                    tmp += xpt.getEntry(k, j) * work1.getEntry(j);\n+                }\n+                curv += hcol.getEntry(k) * tmp * tmp;\n             }\n             if (iflag == 1) {\n                 curv = -curv;\n             }\n-            if (curv > -gw && curv < -const__ * gw) {\n-                scale = -gw / curv;\n+            if (curv > -gw &&\n+                curv < -gw * (ONE + Math.sqrt(TWO))) {\n+                final double scale = -gw / curv;\n                 for (int i = 0; i < n; i++) {\n-                    temp = xopt.getEntry(i) + scale * work1.getEntry(i);\n-                    // Computing MAX\n-                    // Computing MIN\n-                    d__3 = su.getEntry(i);\n-                    d__2 = Math.min(d__3, temp);\n-                    xalt.setEntry(i, Math.max(sl.getEntry(i), d__2));\n+                    final double tmp = xopt.getEntry(i) + scale * work1.getEntry(i);\n+                    xalt.setEntry(i, Math.max(sl.getEntry(i),\n+                                              Math.min(su.getEntry(i), tmp)));\n                 }\n                 // Computing 2nd power\n                 final double d1 = HALF * gw * scale;", "timestamp": 1313589656, "metainfo": ""}