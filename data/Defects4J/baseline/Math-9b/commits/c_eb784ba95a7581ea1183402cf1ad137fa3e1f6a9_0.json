{"sha": "eb784ba95a7581ea1183402cf1ad137fa3e1f6a9", "log": "MATH-599 Name change to avoid test failure on the automated build system (\"gump\").   ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.XMinus5Function;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Base class for root-finding algorithms tests derived from\n+ * {@link BaseSecantSolver}.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class BaseSecantSolverAbstractTest {\n+    /** Returns the solver to use to perform the tests.\n+     * @return the solver to use to perform the tests\n+     */\n+    protected abstract UnivariateRealSolver getSolver();\n+\n+    /** Returns the expected number of evaluations for the\n+     * {@link #testQuinticZero} unit test. A value of {@code -1} indicates that\n+     * the test should be skipped for that solver.\n+     * @return the expected number of evaluations for the\n+     * {@link #testQuinticZero} unit test\n+     */\n+    protected abstract int[] getQuinticEvalCounts();\n+\n+    @Test\n+    public void testSinZero() {\n+        // The sinus function is behaved well around the root at pi. The second\n+        // order derivative is zero, which means linear approximating methods\n+        // still converge quadratically.\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = getSolver();\n+\n+        result = solver.solve(100, f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 6);\n+        result = solver.solve(100, f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+        Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy());\n+        Assert.assertTrue(solver.getEvaluations() <= 7);\n+    }\n+\n+    @Test\n+    public void testQuinticZero() {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second\n+        // derivative of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1,\n+        // because the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613\n+        // and 0.82221643, intervals containing these values are harder for\n+        // the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        UnivariateRealSolver solver = getSolver();\n+        double atol = solver.getAbsoluteAccuracy();\n+        int[] counts = getQuinticEvalCounts();\n+\n+        // Tests data: initial bounds, and expected solution, per test case.\n+        double[][] testsData = {{-0.2,  0.2,  0.0},\n+                                {-0.1,  0.3,  0.0},\n+                                {-0.3,  0.45, 0.0},\n+                                { 0.3,  0.7,  0.5},\n+                                { 0.2,  0.6,  0.5},\n+                                { 0.05, 0.95, 0.5},\n+                                { 0.85, 1.25, 1.0},\n+                                { 0.8,  1.2,  1.0},\n+                                { 0.85, 1.75, 1.0},\n+                                { 0.55, 1.45, 1.0},\n+                                { 0.85, 5.0,  1.0},\n+                               };\n+        int maxIter = 500;\n+\n+        for(int i = 0; i < testsData.length; i++) {\n+            // Skip test, if needed.\n+            if (counts[i] == -1) continue;\n+\n+            // Compute solution.\n+            double[] testData = testsData[i];\n+            result = solver.solve(maxIter, f, testData[0], testData[1]);\n+            //System.out.println(\n+            //    \"Root: \" + result + \" Evaluations: \" + solver.getEvaluations());\n+\n+            // Check solution.\n+            Assert.assertEquals(result, testData[2], atol);\n+            Assert.assertTrue(solver.getEvaluations() <= counts[i] + 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testRootEndpoints() {\n+        UnivariateRealFunction f = new XMinus5Function();\n+        UnivariateRealSolver solver = getSolver();\n+\n+        // End-point is root. This should be a special case in the solver, and\n+        // the initial end-point should be returned exactly.\n+        double result = solver.solve(100, f, 5.0, 6.0);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 4.0, 5.0);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 5.0, 6.0, 5.5);\n+        Assert.assertEquals(5.0, result, 0.0);\n+\n+        result = solver.solve(100, f, 4.0, 5.0, 4.5);\n+        Assert.assertEquals(5.0, result, 0.0);\n+    }\n+\n+    @Test\n+    public void testBadEndpoints() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        try {  // bad interval\n+            solver.solve(100, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(100, f, 1, 1.5);\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(100, f, 1, 1.5, 1.2);\n+            Assert.fail(\"Expecting NoBracketingException - non-bracketing\");\n+        } catch (NoBracketingException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionLeftSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedSolution)) return;\n+        ((BracketedSolution)solver).setAllowedSolutions(AllowedSolutions.LEFT_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(solution <= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionRightSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedSolution)) return;\n+        ((BracketedSolution)solver).setAllowedSolutions(AllowedSolutions.RIGHT_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(solution >= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/IllinoisSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class IllinoisSolverTest extends BaseSecantSolverTest {\n+public final class IllinoisSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new IllinoisSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/PegasusSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class PegasusSolverTest extends BaseSecantSolverTest {\n+public final class PegasusSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new PegasusSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class RegulaFalsiSolverTest extends BaseSecantSolverTest {\n+public final class RegulaFalsiSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new RegulaFalsiSolver();\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/SecantSolverTest.java\n  *\n  * @version $Id$\n  */\n-public final class SecantSolverTest extends BaseSecantSolverTest {\n+public final class SecantSolverTest extends BaseSecantSolverAbstractTest {\n     /** {@inheritDoc} */\n     protected UnivariateRealSolver getSolver() {\n         return new SecantSolver();", "timestamp": 1309107740, "metainfo": ""}