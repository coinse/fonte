{"sha": "0054e338d755f10572c96b32024e5f0bcc9f5431", "log": "Removed references to MathRuntimeException (MATH-677).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n \n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.complex.Complex;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n  * factory method {@link #createUnitary()}.\n  * </p>\n  *\n- * @version $Id: FastFourierTransformer.java 1212260 2011-12-09 06:45:09Z\n- * celestin $\n+ * @version $Id$\n  * @since 1.2\n  */\n public class FastFourierTransformer implements Serializable {\n      *\n      * @param f the real data array to be transformed\n      * @return the complex transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n      */\n     public Complex[] transform(double[] f)\n-        throws IllegalArgumentException {\n+            throws MathIllegalArgumentException {\n+\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(f.length);\n             return scaleArray(fft(f, false), s);\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws NonMonotonicSequenceException if the lower bound is greater\n+     * than, or equal to the upper bound\n+     * @throws NotStrictlyPositiveException if the number of sample points\n+     * {@code n} is negative\n+     * @throws MathIllegalArgumentException if the number of sample points\n+     * {@code n} is not a power of two\n      */\n     public Complex[] transform(UnivariateFunction f,\n-                               double min, double max, int n)\n-        throws IllegalArgumentException {\n+            double min, double max, int n) throws\n+            NonMonotonicSequenceException,\n+            NotStrictlyPositiveException,\n+            MathIllegalArgumentException {\n+\n         final double[] data = sample(f, min, max, n);\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(n);\n      *\n      * @param f the complex data array to be transformed\n      * @return the complex transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n      */\n     public Complex[] transform(Complex[] f)\n-        throws IllegalArgumentException {\n+            throws MathIllegalArgumentException {\n+\n+        // TODO Is this necessary?\n         roots.computeOmega(f.length);\n         if (unitary) {\n             final double s = 1.0 / FastMath.sqrt(f.length);\n      *\n      * @param f the real data array to be inversely transformed\n      * @return the complex inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n      */\n     public Complex[] inverseTransform(double[] f)\n-        throws IllegalArgumentException {\n+            throws MathIllegalArgumentException {\n \n         final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n         return scaleArray(fft(f, true), s);\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the complex inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws NonMonotonicSequenceException if the lower bound is greater\n+     * than, or equal to the upper bound\n+     * @throws NotStrictlyPositiveException if the number of sample points\n+     * {@code n} is negative\n+     * @throws MathIllegalArgumentException if the number of sample points\n+     * {@code n} is not a power of two\n      */\n     public Complex[] inverseTransform(UnivariateFunction f,\n-                                      double min, double max, int n)\n-        throws IllegalArgumentException {\n+            double min, double max, int n) throws\n+            NonMonotonicSequenceException,\n+            NotStrictlyPositiveException,\n+            MathIllegalArgumentException {\n \n         final double[] data = sample(f, min, max, n);\n         final double s = 1.0 / (unitary ? FastMath.sqrt(n) : n);\n      *\n      * @param f the complex data array to be inversely transformed\n      * @return the complex inversely transformed array\n-     * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws MathIllegalArgumentException if the length of the data array is\n+     * not a power of two\n      */\n     public Complex[] inverseTransform(Complex[] f)\n-        throws IllegalArgumentException {\n+            throws MathIllegalArgumentException {\n \n         roots.computeOmega(-f.length);    // pass negative argument\n         final double s = 1.0 / (unitary ? FastMath.sqrt(f.length) : f.length);\n      * @param isInverse the indicator of forward or inverse transform\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws MathIllegalArgumentException if array length is not a power of 2\n      */\n     protected Complex[] fft(double[] f, boolean isInverse)\n-        throws IllegalArgumentException {\n+            throws MathIllegalArgumentException {\n \n         verifyDataSet(f);\n         Complex[] transformed = new Complex[f.length];\n      * @param data the complex data array to be transformed\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n+     * @throws MathIllegalArgumentException if array length is not a power of 2\n      */\n     protected Complex[] fft(Complex[] data)\n-        throws IllegalArgumentException {\n+            throws MathIllegalArgumentException {\n+\n+        verifyDataSet(data);\n \n         final int n = data.length;\n         final Complex[] f = new Complex[n];\n \n         // initial simple cases\n-        verifyDataSet(data);\n         if (n == 1) {\n             f[0] = data[0];\n             return f;\n      * @param max the (exclusive) upper bound for the interval\n      * @param n the number of sample points\n      * @return the samples array\n-     * @throws IllegalArgumentException if any parameters are invalid\n-     */\n-    public static double[] sample(UnivariateFunction f, double min, double max, int n)\n-        throws IllegalArgumentException {\n+     * @throws NonMonotonicSequenceException if the lower bound is greater\n+     * than, or equal to the upper bound\n+     * @throws NotStrictlyPositiveException if the number of sample points\n+     * {@code n} is negative\n+     */\n+    public static double[] sample(UnivariateFunction f,\n+            double min, double max, int n) throws\n+            NonMonotonicSequenceException,\n+            NotStrictlyPositiveException {\n \n         if (n <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n+            throw new NotStrictlyPositiveException(\n                     LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES,\n-                    n);\n+                    Integer.valueOf(n));\n         }\n         verifyInterval(min, max);\n \n      * @return a reference to the scaled array\n      */\n     public static double[] scaleArray(double[] f, double d) {\n+\n         for (int i = 0; i < f.length; i++) {\n             f[i] *= d;\n         }\n      * @return a reference to the scaled array\n      */\n     public static Complex[] scaleArray(Complex[] f, double d) {\n+\n         for (int i = 0; i < f.length; i++) {\n             f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n         }\n      * Verifies that the data set has length of power of 2.\n      *\n      * @param d the data array\n-     * @throws IllegalArgumentException if array length is not power of 2\n-     */\n-    public static void verifyDataSet(double[] d) throws IllegalArgumentException {\n+     * @throws MathIllegalArgumentException if array length is not a power of 2\n+     */\n+    public static void verifyDataSet(double[] d)\n+        throws MathIllegalArgumentException {\n+\n         if (!isPowerOf2(d.length)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, d.length);\n+            throw new MathIllegalArgumentException(\n+                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n+                    Integer.valueOf(d.length));\n         }\n     }\n \n      * Verifies that the data set has length of power of 2.\n      *\n      * @param o the data array\n-     * @throws IllegalArgumentException if array length is not power of 2\n-     */\n-    public static void verifyDataSet(Object[] o) throws IllegalArgumentException {\n+     * @throws MathIllegalArgumentException if array length is not a power of 2\n+     */\n+    public static void verifyDataSet(Object[] o)\n+        throws MathIllegalArgumentException {\n+\n         if (!isPowerOf2(o.length)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, o.length);\n-        }\n-    }\n-\n-    /**\n-     * Verifies that the endpoints specify an interval.\n-     *\n-     * @param lower lower endpoint\n-     * @param upper upper endpoint\n-     * @throws IllegalArgumentException if not interval\n+            throw new MathIllegalArgumentException(\n+                    LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n+                    Integer.valueOf(o.length));\n+        }\n+    }\n+\n+    /**\n+     * Verifies that the end-points specify an interval.\n+     *\n+     * @param lower the lower end-point\n+     * @param upper the upper end-point\n+     * @throws NonMonotonicSequenceException if the lower end-point is greater\n+     * than, or equal to the upper end-point\n      */\n     public static void verifyInterval(double lower, double upper)\n-        throws IllegalArgumentException {\n+        throws NonMonotonicSequenceException {\n \n         if (lower >= upper) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n-                    lower, upper);\n+            throw new NonMonotonicSequenceException(\n+                    Double.valueOf(upper),\n+                    Double.valueOf(lower),\n+                    1);\n         }\n     }\n \n      */\n     public Object mdfft(Object mdca, boolean forward)\n         throws IllegalArgumentException {\n+\n         MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n                 new MultiDimensionalComplexMatrix(mdca).clone();\n         int[] dimensionSize = mdcm.getDimensionSizes();\n      * @param subVector recursion subvector\n      * @throws IllegalArgumentException if any dimension is not a power of two\n      */\n-    private void mdfft(MultiDimensionalComplexMatrix mdcm, boolean forward,\n-                       int d, int[] subVector)\n-        throws IllegalArgumentException {\n+    private void mdfft(MultiDimensionalComplexMatrix mdcm,\n+            boolean forward, int d, int[] subVector) throws\n+            IllegalArgumentException {\n+\n         int[] dimensionSize = mdcm.getDimensionSizes();\n         //if done\n         if (subVector.length == dimensionSize.length) {\n     }\n \n     /**\n-     * Complex matrix implementation.\n-     * Not designed for synchronized access\n-     * may eventually be replaced by jsr-83 of the java community process\n+     * Complex matrix implementation. Not designed for synchronized access may\n+     * eventually be replaced by jsr-83 of the java community process\n      * http://jcp.org/en/jsr/detail?id=83\n      * may require additional exception throws for other basic requirements.\n      */\n         /** Storage array. */\n         protected Object multiDimensionalComplexArray;\n \n-        /** Simple constructor.\n-         * @param multiDimensionalComplexArray array containing the matrix elements\n-         */\n-        public MultiDimensionalComplexMatrix(Object multiDimensionalComplexArray) {\n+        /**\n+         * Simple constructor.\n+         *\n+         * @param multiDimensionalComplexArray array containing the matrix\n+         * elements\n+         */\n+        public MultiDimensionalComplexMatrix(\n+                Object multiDimensionalComplexArray) {\n \n             this.multiDimensionalComplexArray = multiDimensionalComplexArray;\n \n \n         /**\n          * Get a matrix element.\n+         *\n          * @param vector indices of the element\n          * @return matrix element\n-         * @exception IllegalArgumentException if dimensions do not match\n+         * @exception DimensionMismatchException if dimensions do not match\n          */\n         public Complex get(int... vector)\n-            throws IllegalArgumentException {\n+                throws DimensionMismatchException {\n+\n             if (vector == null) {\n                 if (dimensionSize.length > 0) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, 0, dimensionSize.length);\n+                    throw new DimensionMismatchException(\n+                            0,\n+                            dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector.length != dimensionSize.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, vector.length, dimensionSize.length);\n+                throw new DimensionMismatchException(\n+                        vector.length,\n+                        dimensionSize.length);\n             }\n \n             Object lastDimension = multiDimensionalComplexArray;\n \n         /**\n          * Set a matrix element.\n+         *\n          * @param magnitude magnitude of the element\n          * @param vector indices of the element\n          * @return the previous value\n-         * @exception IllegalArgumentException if dimensions do not match\n+         * @exception DimensionMismatchException if dimensions do not match\n          */\n         public Complex set(Complex magnitude, int... vector)\n-            throws IllegalArgumentException {\n+                throws DimensionMismatchException {\n+\n             if (vector == null) {\n                 if (dimensionSize.length > 0) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, 0, dimensionSize.length);\n+                    throw new DimensionMismatchException(\n+                            0,\n+                            dimensionSize.length);\n                 }\n                 return null;\n             }\n             if (vector.length != dimensionSize.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, vector.length, dimensionSize.length);\n+                throw new DimensionMismatchException(\n+                        vector.length,\n+                        dimensionSize.length);\n             }\n \n             Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n \n         /**\n          * Get the size in all dimensions.\n+         *\n          * @return size in all dimensions\n          */\n         public int[] getDimensionSizes() {\n \n         /**\n          * Get the underlying storage array.\n+         *\n          * @return underlying storage array\n          */\n         public Object getArray() {\n \n         /**\n          * Copy contents of current array into mdcm.\n+         *\n          * @param mdcm array where to copy data\n          */\n         private void clone(MultiDimensionalComplexMatrix mdcm) {\n+\n             int[] vector = new int[dimensionSize.length];\n             int size = 1;\n             for (int i = 0; i < dimensionSize.length; i++) {\n     }\n \n \n-    /** Computes the n<sup>th</sup> roots of unity.\n-     * A cache of already computed values is maintained.\n+    /**\n+     * Computes the {@code n}<sup>th</sup> roots of unity. A cache of already\n+     * computed values is maintained.\n      */\n     private static class RootsOfUnity implements Serializable {\n \n-      /** Serializable version id. */\n-      private static final long serialVersionUID = 6404784357747329667L;\n-\n-      /** Number of roots of unity. */\n-      private int      omegaCount;\n-\n-      /** Real part of the roots. */\n-      private double[] omegaReal;\n-\n-      /** Imaginary part of the roots for forward transform. */\n-      private double[] omegaImaginaryForward;\n-\n-      /** Imaginary part of the roots for reverse transform. */\n-      private double[] omegaImaginaryInverse;\n-\n-      /** Forward/reverse indicator. */\n-      private boolean  isForward;\n-\n-      /**\n-       * Build an engine for computing then <sup>th</sup> roots of unity.\n-       */\n-      public RootsOfUnity() {\n-\n-        omegaCount = 0;\n-        omegaReal = null;\n-        omegaImaginaryForward = null;\n-        omegaImaginaryInverse = null;\n-        isForward = true;\n-\n-      }\n-\n-      /**\n-       * Check if computation has been done for forward or reverse transform.\n-       * @return true if computation has been done for forward transform\n-       * @throws IllegalStateException if no roots of unity have been computed yet\n-       */\n-      public synchronized boolean isForward() throws IllegalStateException {\n-\n-        if (omegaCount == 0) {\n-          throw MathRuntimeException.createIllegalStateException(LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n-        }\n-        return isForward;\n-\n-      }\n-\n-      /** Computes the n<sup>th</sup> roots of unity.\n-       * <p>The computed omega[] = { 1, w, w<sup>2</sup>, ... w<sup>(n-1)</sup> } where\n-       * w = exp(-2 &pi; i / n), i = &sqrt;(-1).</p>\n-       * <p>Note that n is positive for\n-       * forward transform and negative for inverse transform.</p>\n-       * @param n number of roots of unity to compute,\n-       * positive for forward transform, negative for inverse transform\n-       * @throws IllegalArgumentException if n = 0\n-       */\n-      public synchronized void computeOmega(int n) throws IllegalArgumentException {\n-\n-        if (n == 0) {\n-          throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);\n-        }\n-\n-        isForward = n > 0;\n-\n-        // avoid repetitive calculations\n-        final int absN = FastMath.abs(n);\n-\n-        if (absN == omegaCount) {\n-            return;\n-        }\n-\n-        // calculate everything from scratch, for both forward and inverse versions\n-        final double t    = 2.0 * FastMath.PI / absN;\n-        final double cosT = FastMath.cos(t);\n-        final double sinT = FastMath.sin(t);\n-        omegaReal             = new double[absN];\n-        omegaImaginaryForward = new double[absN];\n-        omegaImaginaryInverse = new double[absN];\n-        omegaReal[0]             = 1.0;\n-        omegaImaginaryForward[0] = 0.0;\n-        omegaImaginaryInverse[0] = 0.0;\n-        for (int i = 1; i < absN; i++) {\n-          omegaReal[i] = omegaReal[i - 1] * cosT +\n-                         omegaImaginaryForward[i - 1] * sinT;\n-          omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT -\n-                                     omegaReal[i - 1] * sinT;\n-          omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n-        }\n-        omegaCount = absN;\n-\n-      }\n-\n-      /**\n-       * Get the real part of the k<sup>th</sup> n<sup>th</sup> root of unity.\n-       * @param k index of the n<sup>th</sup> root of unity\n-       * @return real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n-       * @throws IllegalStateException if no roots of unity have been computed yet\n-       * @throws IllegalArgumentException if k is out of range\n-       */\n-      public synchronized double getOmegaReal(int k)\n-        throws IllegalStateException, IllegalArgumentException {\n-\n-        if (omegaCount == 0) {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n-        }\n-        if ((k < 0) || (k >= omegaCount)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX, k, 0, omegaCount - 1);\n-        }\n-\n-        return omegaReal[k];\n-\n-      }\n-\n-      /**\n-       * Get the imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity.\n-       * @param k index of the n<sup>th</sup> root of unity\n-       * @return imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n-       * @throws IllegalStateException if no roots of unity have been computed yet\n-       * @throws IllegalArgumentException if k is out of range\n-       */\n-      public synchronized double getOmegaImaginary(int k)\n-        throws IllegalStateException, IllegalArgumentException {\n-\n-        if (omegaCount == 0) {\n-            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n-        }\n-        if ((k < 0) || (k >= omegaCount)) {\n-          throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX, k, 0, omegaCount - 1);\n-        }\n-\n-        return isForward ? omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n-\n-      }\n-\n-    }\n-\n+        /** Serializable version id. */\n+        private static final long serialVersionUID = 6404784357747329667L;\n+\n+        /** Number of roots of unity. */\n+        private int omegaCount;\n+\n+        /** Real part of the roots. */\n+        private double[] omegaReal;\n+\n+        /** Imaginary part of the roots for forward transform. */\n+        private double[] omegaImaginaryForward;\n+\n+        /** Imaginary part of the roots for reverse transform. */\n+        private double[] omegaImaginaryInverse;\n+\n+        /** Forward/reverse indicator. */\n+        private boolean isForward;\n+\n+        /**\n+         * Build an engine for computing the {@code n}<sup>th</sup> roots of\n+         * unity.\n+         */\n+        public RootsOfUnity() {\n+\n+            omegaCount = 0;\n+            omegaReal = null;\n+            omegaImaginaryForward = null;\n+            omegaImaginaryInverse = null;\n+            isForward = true;\n+        }\n+\n+        /**\n+         * Check if computation has been done for forward or reverse transform.\n+         *\n+         * @return {@code true} if computation has been done for forward transform\n+         * @throws MathIllegalStateException if no roots of unity have been computed\n+         * yet\n+         */\n+        public synchronized boolean isForward()\n+                throws MathIllegalStateException {\n+\n+            if (omegaCount == 0) {\n+                throw new MathIllegalStateException(\n+                        LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n+            }\n+            return isForward;\n+        }\n+\n+        /**\n+         * <p>\n+         * Computes the {@code n}<sup>th</sup> roots of unity. The roots are\n+         * stored in {@code omega[]}, such that {@code omega[k] = w ^ k}, where\n+         * {@code k = 0, ..., n - 1}, {@code w = exp(-2 &pi; i / n)} and\n+         * {@code i = sqrt(-1)}.\n+         * </p>\n+         * <p>\n+         * Note that {@code n} is positive for forward transform and negative\n+         * for inverse transform.\n+         * </p>\n+         *\n+         * @param n number of roots of unity to compute, positive for forward\n+         * transform, negative for inverse transform\n+         * @throws ZeroException if {@code n = 0}\n+         */\n+        public synchronized void computeOmega(int n) throws ZeroException {\n+\n+            if (n == 0) {\n+                throw new ZeroException(\n+                        LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);\n+            }\n+\n+            isForward = n > 0;\n+\n+            // avoid repetitive calculations\n+            final int absN = FastMath.abs(n);\n+\n+            if (absN == omegaCount) {\n+                return;\n+            }\n+\n+            // calculate everything from scratch, for both forward and inverse\n+            // versions\n+            final double t = 2.0 * FastMath.PI / absN;\n+            final double cosT = FastMath.cos(t);\n+            final double sinT = FastMath.sin(t);\n+            omegaReal = new double[absN];\n+            omegaImaginaryForward = new double[absN];\n+            omegaImaginaryInverse = new double[absN];\n+            omegaReal[0] = 1.0;\n+            omegaImaginaryForward[0] = 0.0;\n+            omegaImaginaryInverse[0] = 0.0;\n+            for (int i = 1; i < absN; i++) {\n+                omegaReal[i] = omegaReal[i - 1] * cosT +\n+                        omegaImaginaryForward[i - 1] * sinT;\n+                omegaImaginaryForward[i] = omegaImaginaryForward[i - 1] * cosT -\n+                        omegaReal[i - 1] * sinT;\n+                omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n+            }\n+            omegaCount = absN;\n+        }\n+\n+        /**\n+         * Get the real part of the {@code k}<sup>th</sup>\n+         * {@code n}<sup>th</sup> root of unity.\n+         *\n+         * @param k index of the {@code n}<sup>th</sup> root of unity\n+         * @return real part of the {@code k}<sup>th</sup>\n+         * {@code n}<sup>th</sup> root of unity\n+         * @throws MathIllegalStateException if no roots of unity have been\n+         * computed yet\n+         * @throws MathIllegalArgumentException if {@code k} is out of range\n+         */\n+        public synchronized double getOmegaReal(int k)\n+                throws MathIllegalStateException, MathIllegalArgumentException {\n+\n+            if (omegaCount == 0) {\n+                throw new MathIllegalStateException(\n+                        LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n+            }\n+            if ((k < 0) || (k >= omegaCount)) {\n+                throw new OutOfRangeException(\n+                        LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX,\n+                        Integer.valueOf(k),\n+                        Integer.valueOf(0),\n+                        Integer.valueOf(omegaCount - 1));\n+            }\n+\n+            return omegaReal[k];\n+        }\n+\n+        /**\n+         * Get the imaginary part of the {@code k}<sup>th</sup>\n+         * {@code n}<sup>th</sup> root of unity.\n+         *\n+         * @param k index of the {@code n}<sup>th</sup> root of unity\n+         * @return imaginary part of the {@code k}<sup>th</sup>\n+         * {@code n}<sup>th</sup> root of unity\n+         * @throws MathIllegalStateException if no roots of unity have been\n+         * computed yet\n+         * @throws OutOfRangeException if {@code k} is out of range\n+         */\n+        public synchronized double getOmegaImaginary(int k)\n+                throws MathIllegalStateException, OutOfRangeException {\n+\n+            if (omegaCount == 0) {\n+                throw new MathIllegalStateException(\n+                        LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET);\n+            }\n+            if ((k < 0) || (k >= omegaCount)) {\n+                throw new OutOfRangeException(\n+                        LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX,\n+                        Integer.valueOf(k),\n+                        Integer.valueOf(0),\n+                        Integer.valueOf(omegaCount - 1));\n+            }\n+\n+            return isForward ? omegaImaginaryForward[k] :\n+                omegaImaginaryInverse[k];\n+        }\n+    }\n }", "timestamp": 1325324291, "metainfo": ""}