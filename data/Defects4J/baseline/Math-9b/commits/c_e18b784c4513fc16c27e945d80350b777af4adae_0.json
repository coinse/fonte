{"sha": "e18b784c4513fc16c27e945d80350b777af4adae", "log": "Improved type safety for Binary Space Partitioning and reduced complexity, using generics where it was relevant and reorganizing interfaces.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractRegion.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.geometry.Vector;\n+\n+/** Abstract class for all regions, independently of geometry type or dimension.\n+\n+ * @param <S> Type of the space.\n+ * @param <T> Type of the sub-space.\n+\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public abstract class AbstractRegion<S extends Space, T extends Space> implements Region<S> {\n+\n+    /** Inside/Outside BSP tree. */\n+    private BSPTree<S> tree;\n+\n+    /** Size of the instance. */\n+    private double size;\n+\n+    /** Barycenter. */\n+    private Vector<S> barycenter;\n+\n+    /** Build a region representing the whole space.\n+     */\n+    protected AbstractRegion() {\n+        tree = new BSPTree<S>(Boolean.TRUE);\n+    }\n+\n+    /** Build a region from an inside/outside BSP tree.\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n+     * tree also <em>must</em> have either null internal nodes or\n+     * internal nodes representing the boundary as specified in the\n+     * {@link #getTree getTree} method).</p>\n+     * @param tree inside/outside BSP tree representing the region\n+     */\n+    protected AbstractRegion(final BSPTree<S> tree) {\n+        this.tree = tree;\n+    }\n+\n+    /** Build a Region from a Boundary REPresentation (B-rep).\n+     * <p>The boundary is provided as a collection of {@link\n+     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n+     * interior part of the region on its minus side and the exterior on\n+     * its plus side.</p>\n+     * <p>The boundary elements can be in any order, and can form\n+     * several non-connected sets (like for example polygons with holes\n+     * or a set of disjoints polyhedrons considered as a whole). In\n+     * fact, the elements do not even need to be connected together\n+     * (their topological connections are not used here). However, if the\n+     * boundary does not really separate an inside open from an outside\n+     * open (open having here its topological meaning), then subsequent\n+     * calls to the {@link #checkPoint(Vector) checkPoint} method will not be\n+     * meaningful anymore.</p>\n+     * <p>If the boundary is empty, the region will represent the whole\n+     * space.</p>\n+     * @param boundary collection of boundary elements, as a\n+     * collection of {@link SubHyperplane SubHyperplane} objects\n+     */\n+    protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {\n+\n+        if (boundary.size() == 0) {\n+\n+            // the tree represents the whole space\n+            tree = new BSPTree<S>(Boolean.TRUE);\n+\n+        } else {\n+\n+            // sort the boundary elements in decreasing size order\n+            // (we don't want equal size elements to be removed, so\n+            // we use a trick to fool the TreeSet)\n+            final TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {\n+                public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {\n+                    final double size1 = o1.getSize();\n+                    final double size2 = o2.getSize();\n+                    return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n+                }\n+            });\n+            ordered.addAll(boundary);\n+\n+            // build the tree top-down\n+            tree = new BSPTree<S>();\n+            insertCuts(tree, ordered);\n+\n+            // set up the inside/outside flags\n+            tree.visit(new BSPTreeVisitor<S>() {\n+\n+                /** {@inheritDoc} */\n+                public Order visitOrder(final BSPTree<S> node) {\n+                    return Order.PLUS_SUB_MINUS;\n+                }\n+\n+                /** {@inheritDoc} */\n+                public void visitInternalNode(final BSPTree<S> node) {\n+                }\n+\n+                /** {@inheritDoc} */\n+                public void visitLeafNode(final BSPTree<S> node) {\n+                    node.setAttribute((node == node.getParent().getPlus()) ?\n+                                                                            Boolean.FALSE : Boolean.TRUE);\n+                }\n+            });\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree);\n+\n+    /** Recursively build a tree by inserting cut sub-hyperplanes.\n+     * @param node current tree node (it is a leaf node at the beginning\n+     * of the call)\n+     * @param boundary collection of edges belonging to the cell defined\n+     * by the node\n+     */\n+    private void insertCuts(final BSPTree<S> node, final Collection<SubHyperplane<S>> boundary) {\n+\n+        final Iterator<SubHyperplane<S>> iterator = boundary.iterator();\n+\n+        // build the current level\n+        Hyperplane<S> inserted = null;\n+        while ((inserted == null) && iterator.hasNext()) {\n+            inserted = iterator.next().getHyperplane();\n+            if (!node.insertCut(inserted.copySelf())) {\n+                inserted = null;\n+            }\n+        }\n+\n+        if (!iterator.hasNext()) {\n+            return;\n+        }\n+\n+        // distribute the remaining edges in the two sub-trees\n+        final ArrayList<SubHyperplane<S>> plusList  = new ArrayList<SubHyperplane<S>>();\n+        final ArrayList<SubHyperplane<S>> minusList = new ArrayList<SubHyperplane<S>>();\n+        while (iterator.hasNext()) {\n+            final SubHyperplane<S> other = iterator.next();\n+            switch (other.side(inserted)) {\n+            case PLUS:\n+                plusList.add(other);\n+                break;\n+            case MINUS:\n+                minusList.add(other);\n+                break;\n+            case BOTH:\n+                final SubHyperplane.SplitSubHyperplane<S> split = other.split(inserted);\n+                plusList.add(split.getPlus());\n+                minusList.add(split.getMinus());\n+                break;\n+            default:\n+                // ignore the sub-hyperplanes belonging to the cut hyperplane\n+            }\n+        }\n+\n+        // recurse through lower levels\n+        insertCuts(node.getPlus(),  plusList);\n+        insertCuts(node.getMinus(), minusList);\n+\n+    }\n+\n+    /** Build a convex region from an array of bounding hyperplanes.\n+     * @param hyperplanes array of bounding hyperplanes (if null, an\n+     * empty region will be built)\n+     * @return a new convex region, or null if the collection is empty\n+     */\n+    public AbstractRegion(final Hyperplane<S>[] hyperplanes) {\n+        if ((hyperplanes == null) || (hyperplanes.length == 0)) {\n+            tree = new BSPTree<S>(Boolean.FALSE);\n+        } else {\n+\n+            // use the first hyperplane to build the right class\n+            tree = hyperplanes[0].wholeSpace().getTree(false);\n+\n+            // chop off parts of the space\n+            BSPTree<S> node = tree;\n+            node.setAttribute(Boolean.TRUE);\n+            for (final Hyperplane<S> hyperplane : hyperplanes) {\n+                if (node.insertCut(hyperplane)) {\n+                    node.setAttribute(null);\n+                    node.getPlus().setAttribute(Boolean.FALSE);\n+                    node = node.getMinus();\n+                    node.setAttribute(Boolean.TRUE);\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public AbstractRegion<S, T> copySelf() {\n+        return buildNew(tree.copySelf());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isEmpty() {\n+        return isEmpty(tree);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isEmpty(final BSPTree<S> node) {\n+\n+        // we use a recursive function rather than the BSPTreeVisitor\n+        // interface because we can stop visiting the tree as soon as we\n+        // have found an inside cell\n+\n+        if (node.getCut() == null) {\n+            // if we find an inside node, the region is not empty\n+            return !((Boolean) node.getAttribute());\n+        }\n+\n+        // check both sides of the sub-tree\n+        return isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean contains(final Region<S> region) {\n+        return new RegionFactory<S>().difference(region, this).isEmpty();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Location checkPoint(final Vector<S> point) {\n+        return checkPoint(tree, point);\n+    }\n+\n+    /** Check a point with respect to the region starting at a given node.\n+     * @param node root node of the region\n+     * @param point point to check\n+     * @return a code representing the point status: either {@link\n+     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n+     */\n+    protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) {\n+        final BSPTree<S> cell = node.getCell(point);\n+        if (cell.getCut() == null) {\n+            // the point is in the interior of a cell, just check the attribute\n+            return ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;\n+        }\n+\n+        // the point is on a cut-sub-hyperplane, is it on a boundary ?\n+        final Location minusCode = checkPoint(cell.getMinus(), point);\n+        final Location plusCode  = checkPoint(cell.getPlus(),  point);\n+        return (minusCode == plusCode) ? minusCode : Location.BOUNDARY;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BSPTree<S> getTree(final boolean includeBoundaryAttributes) {\n+        if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n+            // we need to compute the boundary attributes\n+            recurseBuildBoundary(tree);\n+        }\n+        return tree;\n+    }\n+\n+    /** Recursively build the boundary shell tree.\n+     * @param node current node in the inout tree\n+     */\n+    private void recurseBuildBoundary(final BSPTree<S> node) {\n+        if (node.getCut() != null) {\n+\n+            SubHyperplane<S> plusOutside = null;\n+            SubHyperplane<S> plusInside  = null;\n+\n+            // characterize the cut sub-hyperplane,\n+            // first with respect to the plus sub-tree\n+            final Characterization<S> plusChar = new Characterization<S>();\n+            characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n+\n+            if (plusChar.hasOut()) {\n+                // plusChar.out corresponds to a subset of the cut\n+                // sub-hyperplane known to have outside cells on its plus\n+                // side, we want to check if parts of this subset do have\n+                // inside cells on their minus side\n+                final Characterization<S> minusChar = new Characterization<S>();\n+                characterize(node.getMinus(), plusChar.getOut(), minusChar);\n+                if (minusChar.hasIn()) {\n+                    plusOutside = minusChar.getIn();\n+                }\n+            }\n+\n+            if (plusChar.hasIn()) {\n+                // plusChar.in corresponds to a subset of the cut\n+                // sub-hyperplane known to have inside cells on its plus\n+                // side, we want to check if parts of this subset do have\n+                // outside cells on their minus side\n+                final Characterization<S> minusChar = new Characterization<S>();\n+                characterize(node.getMinus(), plusChar.getIn(), minusChar);\n+                if (minusChar.hasOut()) {\n+                    plusInside = minusChar.getOut();\n+                }\n+            }\n+\n+            node.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside));\n+            recurseBuildBoundary(node.getPlus());\n+            recurseBuildBoundary(node.getMinus());\n+\n+        }\n+    }\n+\n+    /** Filter the parts of an hyperplane belonging to the boundary.\n+     * <p>The filtering consist in splitting the specified\n+     * sub-hyperplane into several parts lying in inside and outside\n+     * cells of the tree. The principle is to call this method twice for\n+     * each cut sub-hyperplane in the tree, once one the plus node and\n+     * once on the minus node. The parts that have the same flag\n+     * (inside/inside or outside/outside) do not belong to the boundary\n+     * while parts that have different flags (inside/outside or\n+     * outside/inside) do belong to the boundary.</p>\n+     * @param node current BSP tree node\n+     * @param sub sub-hyperplane to characterize\n+     * @param characterization placeholder where to put the characterized parts\n+     */\n+    private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,\n+                              final Characterization<S> characterization) {\n+        if (node.getCut() == null) {\n+            // we have reached a leaf node\n+            final boolean inside = (Boolean) node.getAttribute();\n+            characterization.add(sub, inside);\n+        } else {\n+            final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n+            switch (sub.side(hyperplane)) {\n+            case PLUS:\n+                characterize(node.getPlus(), sub, characterization);\n+                break;\n+            case MINUS:\n+                characterize(node.getMinus(), sub, characterization);\n+                break;\n+            case BOTH:\n+                final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n+                characterize(node.getPlus(),  split.getPlus(),  characterization);\n+                characterize(node.getMinus(), split.getMinus(), characterization);\n+                break;\n+            default:\n+                // this should not happen\n+                throw new RuntimeException(\"internal error\");\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getBoundarySize() {\n+        final BoundarySizeVisitor<S> visitor = new BoundarySizeVisitor<S>();\n+        getTree(true).visit(visitor);\n+        return visitor.getSize();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSize() {\n+        if (barycenter == null) {\n+            computeGeometricalProperties();\n+        }\n+        return size;\n+    }\n+\n+    /** Set the size of the instance.\n+     * @param size size of the instance\n+     */\n+    protected void setSize(final double size) {\n+        this.size = size;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector<S> getBarycenter() {\n+        if (barycenter == null) {\n+            computeGeometricalProperties();\n+        }\n+        return barycenter;\n+    }\n+\n+    /** Set the barycenter of the instance.\n+     * @param barycenter barycenter of the instance\n+     */\n+    protected void setBarycenter(final Vector<S> barycenter) {\n+        this.barycenter = barycenter;\n+    }\n+\n+    /** Compute some geometrical properties.\n+     * <p>The properties to compute are the barycenter and the size.</p>\n+     */\n+    protected abstract void computeGeometricalProperties();\n+\n+    /** {@inheritDoc} */\n+    public Side side(final Hyperplane<S> hyperplane) {\n+        final Sides sides = new Sides();\n+        recurseSides(tree, hyperplane.wholeHyperplane(), sides);\n+        return sides.plusFound() ?\n+              (sides.minusFound() ? Side.BOTH  : Side.PLUS) :\n+              (sides.minusFound() ? Side.MINUS : Side.HYPER);\n+    }\n+\n+    /** Search recursively for inside leaf nodes on each side of the given hyperplane.\n+\n+     * <p>The algorithm used here is directly derived from the one\n+     * described in section III (<i>Binary Partitioning of a BSP\n+     * Tree</i>) of the Bruce Naylor, John Amanatides and William\n+     * Thibault paper <a\n+     * href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging\n+     * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph\n+     * '90, Computer Graphics 24(4), August 1990, pp 115-124, published\n+     * by the Association for Computing Machinery (ACM)..</p>\n+\n+     * @param node current BSP tree node\n+     * @param sub sub-hyperplane\n+     * @param sides object holding the sides found\n+     */\n+    private void recurseSides(final BSPTree<S> node, final SubHyperplane<S> sub, final Sides sides) {\n+\n+        if (node.getCut() == null) {\n+            if ((Boolean) node.getAttribute()) {\n+                // this is an inside cell expanding across the hyperplane\n+                sides.rememberPlusFound();\n+                sides.rememberMinusFound();\n+            }\n+            return;\n+        }\n+\n+        final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n+        switch (sub.side(hyperplane)) {\n+        case PLUS :\n+            // the sub-hyperplane is entirely in the plus sub-tree\n+            if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\n+                if (!isEmpty(node.getMinus())) {\n+                    sides.rememberPlusFound();\n+                }\n+            } else {\n+                if (!isEmpty(node.getMinus())) {\n+                    sides.rememberMinusFound();\n+                }\n+            }\n+            if (!(sides.plusFound() && sides.minusFound())) {\n+                recurseSides(node.getPlus(), sub, sides);\n+            }\n+            break;\n+        case MINUS :\n+            // the sub-hyperplane is entirely in the minus sub-tree\n+            if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\n+                if (!isEmpty(node.getPlus())) {\n+                    sides.rememberPlusFound();\n+                }\n+            } else {\n+                if (!isEmpty(node.getPlus())) {\n+                    sides.rememberMinusFound();\n+                }\n+            }\n+            if (!(sides.plusFound() && sides.minusFound())) {\n+                recurseSides(node.getMinus(), sub, sides);\n+            }\n+            break;\n+        case BOTH :\n+            // the sub-hyperplane extends in both sub-trees\n+            final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n+\n+            // explore first the plus sub-tree\n+            recurseSides(node.getPlus(), split.getPlus(), sides);\n+\n+            // if needed, explore the minus sub-tree\n+            if (!(sides.plusFound() && sides.minusFound())) {\n+                recurseSides(node.getMinus(), split.getMinus(), sides);\n+            }\n+            break;\n+        default :\n+            // the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\n+            if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\n+                if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\n+                    sides.rememberPlusFound();\n+                }\n+                if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\n+                    sides.rememberMinusFound();\n+                }\n+            } else {\n+                if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\n+                    sides.rememberMinusFound();\n+                }\n+                if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\n+                    sides.rememberPlusFound();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** Utility class holding the already found sides. */\n+    private static final class Sides {\n+\n+        /** Indicator of inside leaf nodes found on the plus side. */\n+        private boolean plusFound;\n+\n+        /** Indicator of inside leaf nodes found on the plus side. */\n+        private boolean minusFound;\n+\n+        /** Simple constructor.\n+         */\n+        public Sides() {\n+            plusFound  = false;\n+            minusFound = false;\n+        }\n+\n+        /** Remember the fact that inside leaf nodes have been found on the plus side.\n+         */\n+        public void rememberPlusFound() {\n+            plusFound = true;\n+        }\n+\n+        /** Check if inside leaf nodes have been found on the plus side.\n+         * @return true if inside leaf nodes have been found on the plus side\n+         */\n+        public boolean plusFound() {\n+            return plusFound;\n+        }\n+\n+        /** Remember the fact that inside leaf nodes have been found on the minus side.\n+         */\n+        public void rememberMinusFound() {\n+            minusFound = true;\n+        }\n+\n+        /** Check if inside leaf nodes have been found on the minus side.\n+         * @return true if inside leaf nodes have been found on the minus side\n+         */\n+        public boolean minusFound() {\n+            return minusFound;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public SubHyperplane<S> intersection(final SubHyperplane<S> sub) {\n+        return recurseIntersection(tree, sub);\n+    }\n+\n+    /** Recursively compute the parts of a sub-hyperplane that are\n+     * contained in the region.\n+     * @param node current BSP tree node\n+     * @param sub sub-hyperplane traversing the region\n+     * @return filtered sub-hyperplane\n+     */\n+    private SubHyperplane<S> recurseIntersection(final BSPTree<S> node, final SubHyperplane<S> sub) {\n+\n+        if (node.getCut() == null) {\n+            return (Boolean) node.getAttribute() ? sub.copySelf() : null;\n+        }\n+\n+        final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n+        switch (sub.side(hyperplane)) {\n+        case PLUS :\n+            return recurseIntersection(node.getPlus(), sub);\n+        case MINUS :\n+            return recurseIntersection(node.getMinus(), sub);\n+        case BOTH :\n+            final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n+            final SubHyperplane<S> plus  = recurseIntersection(node.getPlus(),  split.getPlus());\n+            final SubHyperplane<S> minus = recurseIntersection(node.getMinus(), split.getMinus());\n+            if (plus == null) {\n+                return minus;\n+            } else if (minus == null) {\n+                return plus;\n+            } else {\n+                return plus.reunite(minus);\n+            }\n+        default :\n+            return recurseIntersection(node.getPlus(),\n+                                       recurseIntersection(node.getMinus(), sub));\n+        }\n+\n+    }\n+\n+    /** Transform a region.\n+     * <p>Applying a transform to a region consist in applying the\n+     * transform to all the hyperplanes of the underlying BSP tree and\n+     * of the boundary (and also to the sub-hyperplanes embedded in\n+     * these hyperplanes) and to the barycenter. The instance is not\n+     * modified, a new instance is built.</p>\n+     * @param transform transform to apply\n+     * @return a new region, resulting from the application of the\n+     * transform to the instance\n+     */\n+    public AbstractRegion<S, T> applyTransform(final Transform<S, T> transform) {\n+        return (AbstractRegion<S, T>) buildNew(recurseTransform(getTree(false), transform));\n+    }\n+\n+    /** Recursively transform an inside/outside BSP-tree.\n+     * @param node current BSP tree node\n+     * @param transform transform to apply\n+     * @return a new tree\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private BSPTree<S> recurseTransform(final BSPTree<S> node, final Transform<S, T> transform) {\n+\n+        if (node.getCut() == null) {\n+            return new BSPTree<S>(node.getAttribute());\n+        }\n+\n+        final SubHyperplane<S>  sub = node.getCut();\n+        final SubHyperplane<S> tSub = ((AbstractSubHyperplane<S, T>) sub).applyTransform(transform);\n+        BoundaryAttribute<S> attribute = (BoundaryAttribute<S>) node.getAttribute();\n+        if (attribute != null) {\n+            final SubHyperplane<S> tPO = (attribute.getPlusOutside() == null) ?\n+                null : ((AbstractSubHyperplane<S, T>) attribute.getPlusOutside()).applyTransform(transform);\n+            final SubHyperplane<S> tPI = (attribute.getPlusInside()  == null) ?\n+                null  : ((AbstractSubHyperplane<S, T>) attribute.getPlusInside()).applyTransform(transform);\n+            attribute = new BoundaryAttribute<S>(tPO, tPI);\n+        }\n+\n+        return new BSPTree<S>(tSub,\n+                                    recurseTransform(node.getPlus(),  transform),\n+                                    recurseTransform(node.getMinus(), transform),\n+                                    attribute);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/AbstractSubHyperplane.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+\n+/** This class implements the dimension-independent parts of {@link SubHyperplane}.\n+\n+ * <p>sub-hyperplanes are obtained when parts of an {@link\n+ * Hyperplane hyperplane} are chopped off by other hyperplanes that\n+ * intersect it. The remaining part is a convex region. Such objects\n+ * appear in {@link BSPTree BSP trees} as the intersection of a cut\n+ * hyperplane with the convex region which it splits, the chopping\n+ * hyperplanes are the cut hyperplanes closer to the tree root.</p>\n+\n+ * @param <S> Type of the embedding space.\n+\n+ * @version $Revision$\n+ * @since 3.0\n+ */\n+public abstract class AbstractSubHyperplane<S extends Space, T extends Space>\n+    implements SubHyperplane<S> {\n+\n+    /** Underlying hyperplane. */\n+    private final Hyperplane<S> hyperplane;\n+\n+    /** Remaining region of the hyperplane. */\n+    private final Region<T> remainingRegion;\n+\n+    /** Build a sub-hyperplane from an hyperplane and a region.\n+     * @param hyperplane underlying hyperplane\n+     * @param remainingRegion remaining region of the hyperplane\n+     */\n+    protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\n+                                    final Region<T> remainingRegion) {\n+        this.hyperplane      = hyperplane;\n+        this.remainingRegion = remainingRegion;\n+    }\n+\n+    /** Build a sub-hyperplane from an hyperplane and a region.\n+     * @param hyperplane underlying hyperplane\n+     * @param remainingRegion remaining region of the hyperplane\n+     */\n+    protected abstract AbstractSubHyperplane<S, T> buildNew(final Hyperplane<S> hyperplane,\n+                                                            final Region<T> remainingRegion);\n+\n+    /** {@inheritDoc} */\n+    public AbstractSubHyperplane<S, T> copySelf() {\n+        return buildNew(hyperplane, remainingRegion);\n+    }\n+\n+    /** Get the underlying hyperplane.\n+     * @return underlying hyperplane\n+     */\n+    public Hyperplane<S> getHyperplane() {\n+        return hyperplane;\n+    }\n+\n+    /** Get the remaining region of the hyperplane.\n+     * <p>The returned region is expressed in the canonical hyperplane\n+     * frame and has the hyperplane dimension. For example a chopped\n+     * hyperplane in the 3D euclidean is a 2D plane and the\n+     * corresponding region is a convex 2D polygon.</p>\n+     * @return remaining region of the hyperplane\n+     */\n+    public Region<T> getRemainingRegion() {\n+        return remainingRegion;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getSize() {\n+        return remainingRegion.getSize();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) {\n+        @SuppressWarnings(\"unchecked\")\n+        AbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other;\n+        return buildNew(hyperplane,\n+                        new RegionFactory<T>().union(remainingRegion, o.remainingRegion));\n+    }\n+\n+    /** Apply a transform to the instance.\n+     * <p>The instance must be a (D-1)-dimension sub-hyperplane with\n+     * respect to the transform <em>not</em> a (D-2)-dimension\n+     * sub-hyperplane the transform knows how to transform by\n+     * itself. The transform will consist in transforming first the\n+     * hyperplane and then the all region using the various methods\n+     * provided by the transform.</p>\n+     * @param transform D-dimension transform to apply\n+     * @return the transformed instance\n+     */\n+    public AbstractSubHyperplane<S, T> applyTransform(final Transform<S, T> transform) {\n+        final Hyperplane<S> tHyperplane = transform.apply(hyperplane);\n+        final BSPTree<T> tTree =\n+            recurseTransform(remainingRegion.getTree(false), tHyperplane, transform);\n+        return buildNew(tHyperplane, remainingRegion.buildNew(tTree));\n+    }\n+\n+    /** Recursively transform a BSP-tree from a sub-hyperplane.\n+     * @param node current BSP tree node\n+     * @param transformed image of the instance hyperplane by the transform\n+     * @param transform transform to apply\n+     * @return a new tree\n+     */\n+    private BSPTree<T> recurseTransform(final BSPTree<T> node,\n+                                        final Hyperplane<S> transformed,\n+                                        final Transform<S, T> transform) {\n+        if (node.getCut() == null) {\n+            return new BSPTree<T>(node.getAttribute());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        BoundaryAttribute<T> attribute =\n+            (BoundaryAttribute<T>) node.getAttribute();\n+        if (attribute != null) {\n+            final SubHyperplane<T> tPO = (attribute.getPlusOutside() == null) ?\n+                null : transform.apply(attribute.getPlusOutside(), hyperplane, transformed);\n+            final SubHyperplane<T> tPI = (attribute.getPlusInside() == null) ?\n+                null : transform.apply(attribute.getPlusInside(), hyperplane, transformed);\n+            attribute = new BoundaryAttribute<T>(tPO, tPI);\n+        }\n+\n+        return new BSPTree<T>(transform.apply(node.getCut(), hyperplane, transformed),\n+                              recurseTransform(node.getPlus(), transformed, transform),\n+                              recurseTransform(node.getMinus(), transformed, transform),\n+                              attribute);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract Side side(Hyperplane<S> hyperplane);\n+\n+    /** {@inheritDoc} */\n+    public abstract SplitSubHyperplane<S> split(Hyperplane<S> hyperplane);\n+\n+    /** {@inheritDoc} */\n+    public boolean isEmpty() {\n+        return remainingRegion.isEmpty();\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n  */\n package org.apache.commons.math.geometry.partitioning;\n \n-import org.apache.commons.math.geometry.partitioning.Hyperplane.Side;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.Space;\n import org.apache.commons.math.util.FastMath;\n \n /** This class represent a Binary Space Partition tree.\n  * Computer Graphics 24(4), August 1990, pp 115-124, published by the\n  * Association for Computing Machinery (ACM).</p>\n \n- * @version $Revision$ $Date$\n+ * @param <S> Type of the space.\n+\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class BSPTree {\n+public class BSPTree<S extends Space> {\n \n     /** Cut sub-hyperplane. */\n-    private SubHyperplane cut;\n+    private SubHyperplane<S> cut;\n \n     /** Tree at the plus side of the cut hyperplane. */\n-    private BSPTree plus;\n+    private BSPTree<S> plus;\n \n     /** Tree at the minus side of the cut hyperplane. */\n-    private BSPTree minus;\n+    private BSPTree<S> minus;\n \n     /** Parent tree. */\n-    private BSPTree parent;\n+    private BSPTree<S> parent;\n \n     /** Application-defined attribute. */\n     private Object attribute;\n      * @param attribute attribute associated with the node (may be null)\n      * @see #insertCut\n      */\n-    public BSPTree(final SubHyperplane cut, final BSPTree plus, final BSPTree minus,\n+    public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\n                    final Object attribute) {\n         this.cut       = cut;\n         this.plus      = plus;\n      * the cell now has two leaf child nodes)\n      * @see #BSPTree(SubHyperplane, BSPTree, BSPTree, Object)\n      */\n-    public boolean insertCut(final Hyperplane hyperplane) {\n+    public boolean insertCut(final Hyperplane<S> hyperplane) {\n \n         if (cut != null) {\n             plus.parent  = null;\n             minus.parent = null;\n         }\n \n-        final SubHyperplane chopped = fitToCell(new SubHyperplane(hyperplane));\n-        if (chopped.getRemainingRegion().isEmpty()) {\n+        final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane());\n+        if (chopped.isEmpty()) {\n             cut          = null;\n             plus         = null;\n             minus        = null;\n         }\n \n         cut          = chopped;\n-        plus         = new BSPTree();\n+        plus         = new BSPTree<S>();\n         plus.parent  = this;\n-        minus        = new BSPTree();\n+        minus        = new BSPTree<S>();\n         minus.parent = this;\n         return true;\n \n      * objects).</p>\n      * @return a new tree, copy of the instance\n      */\n-    public BSPTree copySelf() {\n+    public BSPTree<S> copySelf() {\n \n         if (cut == null) {\n-            return new BSPTree(attribute);\n-        }\n-\n-        return new BSPTree(cut.copySelf(), plus.copySelf(), minus.copySelf(),\n+            return new BSPTree<S>(attribute);\n+        }\n+\n+        return new BSPTree<S>(cut.copySelf(), plus.copySelf(), minus.copySelf(),\n                            attribute);\n \n     }\n     /** Get the cut sub-hyperplane.\n      * @return cut sub-hyperplane, null if this is a leaf tree\n      */\n-    public SubHyperplane getCut() {\n+    public SubHyperplane<S> getCut() {\n         return cut;\n     }\n \n      * @return tree on the plus side of the cut hyperplane, null if this\n      * is a leaf tree\n      */\n-    public BSPTree getPlus() {\n+    public BSPTree<S> getPlus() {\n         return plus;\n     }\n \n      * @return tree on the minus side of the cut hyperplane, null if this\n      * is a leaf tree\n      */\n-    public BSPTree getMinus() {\n+    public BSPTree<S> getMinus() {\n         return minus;\n     }\n \n     /** Get the parent node.\n      * @return parent node, null if the node has no parents\n      */\n-    public BSPTree getParent() {\n+    public BSPTree<S> getParent() {\n         return parent;\n     }\n \n     /** Visit the BSP tree nodes.\n      * @param visitor object visiting the tree nodes\n      */\n-    public void visit(final BSPTreeVisitor visitor) {\n+    public void visit(final BSPTreeVisitor<S> visitor) {\n         if (cut == null) {\n             visitor.visitLeafNode(this);\n         } else {\n      * @return a new sub-hyperplane, gueranteed to have no part outside\n      * of the instance cell\n      */\n-    private SubHyperplane fitToCell(final SubHyperplane sub) {\n-        SubHyperplane s = sub;\n-        for (BSPTree tree = this; tree.parent != null; tree = tree.parent) {\n+    private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n+        SubHyperplane<S> s = sub;\n+        for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n             if (tree == tree.parent.plus) {\n-                s = tree.parent.cut.getHyperplane().split(s).getPlus();\n+                s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n             } else {\n-                s = tree.parent.cut.getHyperplane().split(s).getMinus();\n+                s = s.split(tree.parent.cut.getHyperplane()).getMinus();\n             }\n         }\n         return s;\n      * @param point point to check\n      * @return the tree cell to which the point belongs (can be\n      */\n-    public BSPTree getCell(final Point point) {\n+    public BSPTree<S> getCell(final Vector<S> point) {\n \n         if (cut == null) {\n             return this;\n      * tree</code>, this value can be ignored if parentTree is not null\n      * since all connections have already been established\n      */\n-    public BSPTree merge(final BSPTree tree, final LeafMerger leafMerger) {\n+    public BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger) {\n         return merge(tree, leafMerger, null, false);\n     }\n \n      * tree</code>, this value can be ignored if parentTree is not null\n      * since all connections have already been established\n      */\n-    private BSPTree merge(final BSPTree tree, final LeafMerger leafMerger,\n-                          final BSPTree parentTree, final boolean isPlusChild) {\n+    private BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger,\n+                             final BSPTree<S> parentTree, final boolean isPlusChild) {\n         if (cut == null) {\n             // cell/tree operation\n             return leafMerger.merge(this, tree, parentTree, isPlusChild, true);\n             return leafMerger.merge(tree, this, parentTree, isPlusChild, false);\n         } else {\n             // tree/tree operation\n-            final BSPTree merged = tree.split(cut);\n+            final BSPTree<S> merged = tree.split(cut);\n             if (parentTree != null) {\n                 merged.parent = parentTree;\n                 if (isPlusChild) {\n             merged.condense();\n             if (merged.cut != null) {\n                 merged.cut =\n-                    merged.fitToCell(new SubHyperplane(merged.cut.getHyperplane()));\n+                    merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());\n             }\n \n             return merged;\n      * cells would use four different objects to implement the final\n      * merging phase of the four set operations union, intersection,\n      * difference and symmetric difference (exclusive or).</p>\n+     * @param <SpacePoint> Type of the space points.\n+     * @param <SubSpacePoint> Type of the sub-space points.\n      * @version $Revision$ $Date$\n      */\n-    public static interface LeafMerger {\n+    public static interface LeafMerger<S extends Space> {\n \n         /** Merge a leaf node and a tree node.\n          * <p>This method is called at the end of a recursive merging\n          * @return the BSP tree resulting from the merging (may be one of\n          * the arguments)\n          */\n-        BSPTree merge(BSPTree leaf, BSPTree tree,\n-                      BSPTree parentTree, boolean isPlusChild,\n-                      boolean leafFromInstance);\n+        BSPTree<S> merge(BSPTree<S> leaf, BSPTree<S> tree, BSPTree<S> parentTree,\n+                         boolean isPlusChild, boolean leafFromInstance);\n \n     }\n \n      * sub-hyperplane, the two parts of the split instance as its two\n      * sub-trees and a null parent\n      */\n-    public BSPTree split(final SubHyperplane sub) {\n+    public BSPTree<S> split(final SubHyperplane<S> sub) {\n \n         if (cut == null) {\n-            return new BSPTree(sub, copySelf(), new BSPTree(attribute), null);\n-        }\n-\n-        final Hyperplane cHyperplane = cut.getHyperplane();\n-        final Hyperplane sHyperplane = sub.getHyperplane();\n-        switch (cHyperplane.side(sub)) {\n+            return new BSPTree<S>(sub, copySelf(),\n+                    new BSPTree<S>(attribute), null);\n+        }\n+\n+        final Hyperplane<S> cHyperplane = cut.getHyperplane();\n+        final Hyperplane<S> sHyperplane = sub.getHyperplane();\n+        switch (sub.side(cHyperplane)) {\n         case PLUS :\n         { // the partitioning sub-hyperplane is entirely in the plus sub-tree\n-            final BSPTree split = plus.split(sub);\n-            if (sHyperplane.side(cut) == Side.PLUS) {\n-                split.plus = new BSPTree(cut.copySelf(),\n-                                         split.plus, minus.copySelf(), attribute);\n+            final BSPTree<S> split = plus.split(sub);\n+            if (cut.side(sHyperplane) == Side.PLUS) {\n+                split.plus =\n+                    new BSPTree<S>(cut.copySelf(), split.plus, minus.copySelf(), attribute);\n                 split.plus.condense();\n                 split.plus.parent = split;\n             } else {\n-                split.minus = new BSPTree(cut.copySelf(),\n-                                          split.minus, minus.copySelf(), attribute);\n+                split.minus =\n+                    new BSPTree<S>(cut.copySelf(), split.minus, minus.copySelf(), attribute);\n                 split.minus.condense();\n                 split.minus.parent = split;\n             }\n         }\n         case MINUS :\n         { // the partitioning sub-hyperplane is entirely in the minus sub-tree\n-            final BSPTree split = minus.split(sub);\n-            if (sHyperplane.side(cut) == Side.PLUS) {\n-                split.plus = new BSPTree(cut.copySelf(),\n-                                         plus.copySelf(), split.plus, attribute);\n+            final BSPTree<S> split = minus.split(sub);\n+            if (cut.side(sHyperplane) == Side.PLUS) {\n+                split.plus =\n+                    new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.plus, attribute);\n                 split.plus.condense();\n                 split.plus.parent = split;\n             } else {\n-                split.minus = new BSPTree(cut.copySelf(),\n-                                          plus.copySelf(), split.minus, attribute);\n+                split.minus =\n+                    new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.minus, attribute);\n                 split.minus.condense();\n                 split.minus.parent = split;\n             }\n         }\n         case BOTH :\n         {\n-            final Hyperplane.SplitSubHyperplane cutParts = sHyperplane.split(cut);\n-            final Hyperplane.SplitSubHyperplane subParts = cHyperplane.split(sub);\n-            final BSPTree split = new BSPTree(sub,\n-                                              plus.split(subParts.getPlus()),\n-                                              minus.split(subParts.getMinus()),\n-                                              null);\n+            final SubHyperplane.SplitSubHyperplane<S> cutParts = cut.split(sHyperplane);\n+            final SubHyperplane.SplitSubHyperplane<S> subParts = sub.split(cHyperplane);\n+            final BSPTree<S> split =\n+                new BSPTree<S>(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),\n+                               null);\n             split.plus.cut          = cutParts.getPlus();\n             split.minus.cut         = cutParts.getMinus();\n-            final BSPTree tmp       = split.plus.minus;\n+            final BSPTree<S> tmp    = split.plus.minus;\n             split.plus.minus        = split.minus.plus;\n             split.plus.minus.parent = split.plus;\n             split.minus.plus        = tmp;\n         }\n         default :\n             return cHyperplane.sameOrientationAs(sHyperplane) ?\n-                    new BSPTree(sub, plus.copySelf(), minus.copySelf(), attribute) :\n-                        new BSPTree(sub, minus.copySelf(), plus.copySelf(), attribute);\n+                   new BSPTree<S>(sub, plus.copySelf(),  minus.copySelf(), attribute) :\n+                   new BSPTree<S>(sub, minus.copySelf(), plus.copySelf(),  attribute);\n         }\n \n     }\n      * parentTree is null\n      * @see LeafMerger\n      */\n-    public void insertInTree(final BSPTree parentTree, final boolean isPlusChild) {\n+    public void insertInTree(final BSPTree<S> parentTree, final boolean isPlusChild) {\n \n         // set up parent/child links\n         parent = parentTree;\n         if (cut != null) {\n \n             // explore the parent nodes from here towards tree root\n-            for (BSPTree tree = this; tree.parent != null; tree = tree.parent) {\n+            for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n \n                 // this is an hyperplane of some parent node\n-                final Hyperplane hyperplane = tree.parent.cut.getHyperplane();\n+                final Hyperplane<S> hyperplane = tree.parent.cut.getHyperplane();\n \n                 // chop off the parts of the inserted tree that extend\n                 // on the wrong side of this parent hyperplane\n                 if (tree == tree.parent.plus) {\n-                    cut = hyperplane.split(cut).getPlus();\n+                    cut = cut.split(hyperplane).getPlus();\n                     plus.chopOffMinus(hyperplane);\n                     minus.chopOffMinus(hyperplane);\n                 } else {\n-                    cut = hyperplane.split(cut).getMinus();\n+                    cut = cut.split(hyperplane).getMinus();\n                     plus.chopOffPlus(hyperplane);\n                     minus.chopOffPlus(hyperplane);\n                 }\n \n     /** Chop off parts of the tree.\n      * <p>The instance is modified in place, all the parts that are on\n-     * the minus side of the chopping hyperplane are disgarded, only the\n+     * the minus side of the chopping hyperplane are discarded, only the\n      * parts on the plus side remain.</p>\n      * @param hyperplane chopping hyperplane\n      */\n-    private void chopOffMinus(final Hyperplane hyperplane) {\n+    private void chopOffMinus(final Hyperplane<S> hyperplane) {\n         if (cut != null) {\n-            cut = hyperplane.split(cut).getPlus();\n+            cut = cut.split(hyperplane).getPlus();\n             plus.chopOffMinus(hyperplane);\n             minus.chopOffMinus(hyperplane);\n         }\n \n     /** Chop off parts of the tree.\n      * <p>The instance is modified in place, all the parts that are on\n-     * the plus side of the chopping hyperplane are disgarded, only the\n+     * the plus side of the chopping hyperplane are discarded, only the\n      * parts on the minus side remain.</p>\n      * @param hyperplane chopping hyperplane\n      */\n-    private void chopOffPlus(final Hyperplane hyperplane) {\n+    private void chopOffPlus(final Hyperplane<S> hyperplane) {\n         if (cut != null) {\n-            cut = hyperplane.split(cut).getMinus();\n+            cut = cut.split(hyperplane).getMinus();\n             plus.chopOffPlus(hyperplane);\n             minus.chopOffPlus(hyperplane);\n         }\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.Space;\n \n /** This interface is used to visit {@link BSPTree BSP tree} nodes.\n \n  *   </li>\n  * </ul>\n \n+ * @param <SpacePoint> Type of the space points.\n+ * @param <SubSpacePoint> Type of the sub-space points.\n+\n  * @see BSPTree\n  * @see SubHyperplane\n \n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public interface BSPTreeVisitor {\n+public interface BSPTreeVisitor<S extends Space> {\n \n     /** Enumerate for visit order with respect to plus sub-tree, minus sub-tree and cut sub-hyperplane. */\n     enum Order {\n      * {@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n      * {@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}\n      */\n-    Order visitOrder(BSPTree node);\n+    Order visitOrder(BSPTree<S> node);\n \n     /** Visit a BSP tree node node having a non-null sub-hyperplane.\n      * <p>It is guaranteed that this method will be called after {@link\n      * @param node BSP node guaranteed to have a non null cut sub-hyperplane\n      * @see #visitLeafNode\n      */\n-    void visitInternalNode(BSPTree node);\n+    void visitInternalNode(BSPTree<S> node);\n \n     /** Visit a leaf BSP tree node node having a null sub-hyperplane.\n      * @param node leaf BSP node having a null sub-hyperplane\n      * @see #visitInternalNode\n      */\n-    void visitLeafNode(BSPTree node);\n+    void visitLeafNode(BSPTree<S> node);\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BoundaryAttribute.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.Space;\n+\n+/** Class holding boundary attributes.\n+ * <p>This class is used for the attributes associated with the\n+ * nodes of region boundary shell trees returned by the {@link\n+ * Region#getTree Region.getTree}. It contains the\n+ * parts of the node cut sub-hyperplane that belong to the\n+ * boundary.</p>\n+ * <p>This class is a simple placeholder, it does not provide any\n+ * processing methods.</p>\n+ * @param <S> Type of the space.\n+ * @see Region#getTree\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class BoundaryAttribute<S extends Space> {\n+\n+    /** Part of the node cut sub-hyperplane that belongs to the\n+     * boundary and has the outside of the region on the plus side of\n+     * its underlying hyperplane (may be null).\n+     */\n+    final SubHyperplane<S> plusOutside;\n+\n+    /** Part of the node cut sub-hyperplane that belongs to the\n+     * boundary and has the inside of the region on the plus side of\n+     * its underlying hyperplane (may be null).\n+     */\n+    final SubHyperplane<S> plusInside;\n+\n+    /** Simple constructor.\n+     * @param plusOutside part of the node cut sub-hyperplane that\n+     * belongs to the boundary and has the outside of the region on\n+     * the plus side of its underlying hyperplane (may be null)\n+     * @param plusInside part of the node cut sub-hyperplane that\n+     * belongs to the boundary and has the inside of the region on the\n+     * plus side of its underlying hyperplane (may be null)\n+     */\n+    public BoundaryAttribute(final SubHyperplane<S> plusOutside,\n+                             final SubHyperplane<S> plusInside) {\n+        this.plusOutside = plusOutside;\n+        this.plusInside  = plusInside;\n+    }\n+\n+    /** Get the part of the node cut sub-hyperplane that belongs to the\n+     * boundary and has the outside of the region on the plus side of\n+     * its underlying hyperplane.\n+     * @return part of the node cut sub-hyperplane that belongs to the\n+     * boundary and has the outside of the region on the plus side of\n+     * its underlying hyperplane\n+     */\n+    public SubHyperplane<S> getPlusOutside() {\n+        return plusOutside;\n+    }\n+\n+    /** Get the part of the node cut sub-hyperplane that belongs to the\n+     * boundary and has the inside of the region on the plus side of\n+     * its underlying hyperplane.\n+     * @return part of the node cut sub-hyperplane that belongs to the\n+     * boundary and has the inside of the region on the plus side of\n+     * its underlying hyperplane\n+     */\n+    public SubHyperplane<S> getPlusInside() {\n+        return plusInside;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BoundarySizeVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.Space;\n+\n+/** Visitor computing the boundary size.\n+ * @param <S> Type of the space.\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+class BoundarySizeVisitor<S extends Space> implements BSPTreeVisitor<S> {\n+\n+    /** Size of the boundary. */\n+    private double boundarySize;\n+\n+    /** Simple constructor.\n+     */\n+    public BoundarySizeVisitor() {\n+        boundarySize = 0;\n+    }\n+\n+    /** {@inheritDoc}*/\n+    public Order visitOrder(final BSPTree<S> node) {\n+        return Order.MINUS_SUB_PLUS;\n+    }\n+\n+    /** {@inheritDoc}*/\n+    public void visitInternalNode(final BSPTree<S> node) {\n+        @SuppressWarnings(\"unchecked\")\n+        final BoundaryAttribute<S> attribute =\n+            (BoundaryAttribute<S>) node.getAttribute();\n+        if (attribute.plusOutside != null) {\n+            boundarySize += attribute.plusOutside.getSize();\n+        }\n+        if (attribute.plusInside != null) {\n+            boundarySize += attribute.plusInside.getSize();\n+        }\n+    }\n+\n+    /** {@inheritDoc}*/\n+    public void visitLeafNode(final BSPTree<S> node) {\n+    }\n+\n+    /** Get the size of the boundary.\n+     * @return size of the boundary\n+     */\n+    public double getSize() {\n+        return boundarySize;\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java\n  */\n package org.apache.commons.math.geometry.partitioning;\n \n+import org.apache.commons.math.geometry.Space;\n+\n /** Characterization of a sub-hyperplane.\n- * @version $Revision$ $Date$\n+ * @param <S> Type of the space.\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-class Characterization {\n+class Characterization<S extends Space> {\n \n     /** Parts of the sub-hyperplane that have inside cells on the tested side. */\n-    private SubHyperplane in;\n+    private SubHyperplane<S> in;\n \n     /** Parts of the sub-hyperplane that have outside cells on the tested side. */\n-    private SubHyperplane out;\n+    private SubHyperplane<S> out;\n \n     /** Create an empty characterization of a sub-hyperplane.\n      */\n      * @return true if the sub-hyperplane that have inside cells on the tested side\n      */\n     public boolean hasIn() {\n-        return (in != null) && (!in.getRemainingRegion().isEmpty());\n+        return (in != null) && (!in.isEmpty());\n     }\n \n     /** Get the parts of the sub-hyperplane that have inside cells on the tested side.\n      * @return parts of the sub-hyperplane that have inside cells on the tested side\n      */\n-    public SubHyperplane getIn() {\n+    public SubHyperplane<S> getIn() {\n         return in;\n     }\n \n      * @return true if the sub-hyperplane that have outside cells on the tested side\n      */\n     public boolean hasOut() {\n-        return (out != null) && (!out.getRemainingRegion().isEmpty());\n+        return (out != null) && (!out.isEmpty());\n     }\n \n     /** Get the parts of the sub-hyperplane that have outside cells on the tested side.\n      * @return parts of the sub-hyperplane that have outside cells on the tested side\n      */\n-    public SubHyperplane getOut() {\n+    public SubHyperplane<S> getOut() {\n         return out;\n     }\n \n      * @param inside if true, the part added as an inside cell on the tested side, otherwise\n      * it has an outside cell on the tested side\n      */\n-    public void add(final SubHyperplane sub, final boolean inside) {\n+    public void add(final SubHyperplane<S> sub, final boolean inside) {\n         if (inside) {\n             if (in == null) {\n                 in = sub;\n             } else {\n-                in = new SubHyperplane(in.getHyperplane(),\n-                                       Region.union(in.getRemainingRegion(),\n-                                                    sub.getRemainingRegion()));\n+                in = in.reunite(sub);\n             }\n         } else {\n             if (out == null) {\n                 out = sub;\n             } else {\n-                out = new SubHyperplane(out.getHyperplane(),\n-                                        Region.union(out.getRemainingRegion(),\n-                                                     sub.getRemainingRegion()));\n+                out = out.reunite(sub);\n             }\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java\n  */\n package org.apache.commons.math.geometry.partitioning;\n \n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.Space;\n+\n /** This interface represents an hyperplane of a space.\n \n  * <p>The most prominent place where hyperplane appears in space\n  * space). They can be more exotic objects in specific fields, for\n  * example a circle on the surface of the unit sphere.</p>\n \n- * @version $Revision$ $Date$\n+ * @param <SpacePoint> Type of the space points.\n+\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public interface Hyperplane extends SubSpace {\n-\n-    /** Enumerate for specifying sides of the hyperplane. */\n-    enum Side {\n-\n-        /** Code for the plus side of the hyperplane. */\n-        PLUS,\n-\n-        /** Code for the minus side of the hyperplane. */\n-        MINUS,\n-\n-        /** Code for elements crossing the hyperplane from plus to minus side. */\n-        BOTH,\n-\n-        /** Code for the hyperplane itself. */\n-        HYPER;\n-\n-    }\n+public interface Hyperplane<S extends Space> {\n \n     /** Copy the instance.\n      * <p>The instance created is completely independant of the original\n      * shared (except for immutable objects).</p>\n      * @return a new hyperplane, copy of the instance\n      */\n-    Hyperplane copySelf();\n+    Hyperplane<S> copySelf();\n \n     /** Get the offset (oriented distance) of a point.\n      * <p>The offset is 0 if the point is on the underlying hyperplane,\n      * @param point point to check\n      * @return offset of the point\n      */\n-    double getOffset(Point point);\n+    double getOffset(Vector<S> point);\n \n     /** Check if the instance has the same orientation as another hyperplane.\n      * <p>This method is expected to be called on parallel hyperplanes\n      * @return true if the instance and the other hyperplane have\n      * the same orientation\n      */\n-    boolean sameOrientationAs(Hyperplane other);\n+    boolean sameOrientationAs(Hyperplane<S> other);\n \n-    /** Build the sub-space shared by the instance and another hyperplane.\n-     * @param other other hyperplane\n-     * @return a sub-space at the intersection of the instance and the\n-     * other sub-space (it has a dimension one unit less than the\n-     * instance)\n+    /** Build a sub-hyperplane covering the whole hyperplane.\n+     * @return a sub-hyperplane covering the whole hyperplane\n      */\n-    SubSpace intersection(Hyperplane other);\n-\n-    /** Build a region covering the whole hyperplane.\n-     * <p>The region build is restricted to the sub-space defined by the\n-     * hyperplane. This means that the regions points are consistent\n-     * with the argument of the {@link SubSpace#toSpace toSpace} method\n-     * and with the return value of the {@link SubSpace#toSubSpace\n-     * toSubSpace} method.<p>\n-     * @return a region covering the whole hyperplane\n-     */\n-    Region wholeHyperplane();\n+    SubHyperplane<S> wholeHyperplane();\n \n     /** Build a region covering the whole space.\n      * @return a region containing the instance\n      */\n-    Region wholeSpace();\n-\n-    /** Compute the relative position of a sub-hyperplane with respect\n-     * to the instance.\n-     * @param sub sub-hyperplane to check\n-     * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},\n-     * {@link Side#HYPER}\n-     */\n-    Side side(SubHyperplane sub);\n-\n-    /** Split a sub-hyperplane in two parts by the instance.\n-     * @param sub sub-hyperplane to split\n-     * @return an object containing both the part of the sub-hyperplane\n-     * on the plus side of the instance and the part of the\n-     * sub-hyperplane on the minus side of the instance\n-     */\n-    SplitSubHyperplane split(SubHyperplane sub);\n-\n-    /** Class holding the results of the {@link Hyperplane#split Hyperplane.split}\n-     * method. */\n-    class SplitSubHyperplane {\n-\n-        /** Part of the sub-hyperplane on the plus side of the splitting hyperplane. */\n-        private final SubHyperplane plus;\n-\n-        /** Part of the sub-hyperplane on the minus side of the splitting hyperplane. */\n-        private final SubHyperplane minus;\n-\n-        /** Build a SplitSubHyperplane from its parts.\n-         * @param plus part of the sub-hyperplane on the plus side of the\n-         * splitting hyperplane\n-         * @param minus part of the sub-hyperplane on the minus side of the\n-         * splitting hyperplane\n-         */\n-        public SplitSubHyperplane(final SubHyperplane plus, final SubHyperplane minus) {\n-            this.plus  = plus;\n-            this.minus = minus;\n-        }\n-\n-        /** Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.\n-         * @return part of the sub-hyperplane on the plus side of the splitting hyperplane\n-         */\n-        public SubHyperplane getPlus() {\n-            return plus;\n-        }\n-\n-        /** Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.\n-         * @return part of the sub-hyperplane on the minus side of the splitting hyperplane\n-         */\n-        public SubHyperplane getMinus() {\n-            return minus;\n-        }\n-\n-    }\n+    Region<S> wholeSpace();\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/Region.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Region.java\n  */\n package org.apache.commons.math.geometry.partitioning;\n \n-import java.util.Collection;\n-import java.util.TreeSet;\n-import java.util.Comparator;\n-import java.util.Iterator;\n-import java.util.ArrayList;\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.geometry.Vector;\n \n-/** This class represent a region of a space as a partition.\n+/** This interface represents a region of a space as a partition.\n \n  * <p>Region are subsets of a space, they can be infinite (whole\n  * space, half space, infinite stripe ...) or finite (polygons in 2D,\n  * or) for the binary operations, complement for the unary\n  * operation.</p>\n \n- * @version $Revision$ $Date$\n+ * @param <S> Type of the space.\n+\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public abstract class Region {\n+public interface Region<S extends Space> {\n \n     /** Enumerate for the location of a point with respect to the region. */\n     public static enum Location {\n \n         /** Code for points on the partition boundary. */\n         BOUNDARY;\n-    }\n-\n-    /** Inside/Outside BSP tree. */\n-    private BSPTree tree;\n-\n-    /** Size of the instance. */\n-    private double size;\n-\n-    /** Barycenter. */\n-    private Point barycenter;\n-\n-    /** Build a region representing the whole space.\n-     */\n-    protected Region() {\n-        tree = new BSPTree(Boolean.TRUE);\n-    }\n-\n-    /** Build a region from an inside/outside BSP tree.\n-     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n-     * {@code Boolean} attribute representing the inside status of\n-     * the corresponding cell (true for inside cells, false for outside\n-     * cells). In order to avoid building too many small objects, it is\n-     * recommended to use the predefined constants\n-     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n-     * tree also <em>must</em> have either null internal nodes or\n-     * internal nodes representing the boundary as specified in the\n-     * {@link #getTree getTree} method).</p>\n-     * @param tree inside/outside BSP tree representing the region\n-     */\n-    protected Region(final BSPTree tree) {\n-        this.tree = tree;\n-    }\n-\n-    /** Build a Region from a Boundary REPresentation (B-rep).\n-     * <p>The boundary is provided as a collection of {@link\n-     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n-     * interior part of the region on its minus side and the exterior on\n-     * its plus side.</p>\n-     * <p>The boundary elements can be in any order, and can form\n-     * several non-connected sets (like for example polygons with holes\n-     * or a set of disjoints polyhedrons considered as a whole). In\n-     * fact, the elements do not even need to be connected together\n-     * (their topological connections are not used here). However, if the\n-     * boundary does not really separate an inside open from an outside\n-     * open (open having here its topological meaning), then subsequent\n-     * calls to the {@link #checkPoint(Point) checkPoint} method will not be\n-     * meaningful anymore.</p>\n-     * <p>If the boundary is empty, the region will represent the whole\n-     * space.</p>\n-     * @param boundary collection of boundary elements, as a\n-     * collection of {@link SubHyperplane SubHyperplane} objects\n-     */\n-    protected Region(final Collection<SubHyperplane> boundary) {\n-\n-        if (boundary.size() == 0) {\n-\n-            // the tree represents the whole space\n-            tree = new BSPTree(Boolean.TRUE);\n-\n-        } else {\n-\n-            // sort the boundary elements in decreasing size order\n-            // (we don't want equal size elements to be removed, so\n-            // we use a trick to fool the TreeSet)\n-            final TreeSet<SubHyperplane> ordered = new TreeSet<SubHyperplane>(new Comparator<SubHyperplane>() {\n-                public int compare(final SubHyperplane o1, final SubHyperplane o2) {\n-                    final double size1 = o1.getRemainingRegion().getSize();\n-                    final double size2 = o2.getRemainingRegion().getSize();\n-                    return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n-                }\n-            });\n-            ordered.addAll(boundary);\n-\n-            // build the tree top-down\n-            tree = new BSPTree();\n-            insertCuts(tree, ordered);\n-\n-            // set up the inside/outside flags\n-            tree.visit(new BSPTreeVisitor() {\n-\n-                /** {@inheritDoc} */\n-                public Order visitOrder(final BSPTree node) {\n-                    return Order.PLUS_SUB_MINUS;\n-                }\n-\n-                /** {@inheritDoc} */\n-                public void visitInternalNode(final BSPTree node) {\n-                }\n-\n-                /** {@inheritDoc} */\n-                public void visitLeafNode(final BSPTree node) {\n-                    node.setAttribute((node == node.getParent().getPlus()) ?\n-                                                                            Boolean.FALSE : Boolean.TRUE);\n-                }\n-            });\n-\n-        }\n-\n     }\n \n     /** Build a region using the instance as a prototype.\n      * @param newTree inside/outside BSP tree representing the new region\n      * @return the built region\n      */\n-    public abstract Region buildNew(BSPTree newTree);\n-\n-    /** Recursively build a tree by inserting cut sub-hyperplanes.\n-     * @param node current tree node (it is a leaf node at the beginning\n-     * of the call)\n-     * @param boundary collection of edges belonging to the cell defined\n-     * by the node\n-     */\n-    private void insertCuts(final BSPTree node, final Collection<SubHyperplane> boundary) {\n-\n-        final Iterator<SubHyperplane> iterator = boundary.iterator();\n-\n-        // build the current level\n-        Hyperplane inserted = null;\n-        while ((inserted == null) && iterator.hasNext()) {\n-            inserted = iterator.next().getHyperplane();\n-            if (!node.insertCut(inserted.copySelf())) {\n-                inserted = null;\n-            }\n-        }\n-\n-        if (!iterator.hasNext()) {\n-            return;\n-        }\n-\n-        // distribute the remaining edges in the two sub-trees\n-        final ArrayList<SubHyperplane> plusList  = new ArrayList<SubHyperplane>();\n-        final ArrayList<SubHyperplane> minusList = new ArrayList<SubHyperplane>();\n-        while (iterator.hasNext()) {\n-            final SubHyperplane other = iterator.next();\n-            switch (inserted.side(other)) {\n-            case PLUS:\n-                plusList.add(other);\n-                break;\n-            case MINUS:\n-                minusList.add(other);\n-                break;\n-            case BOTH:\n-                final Hyperplane.SplitSubHyperplane split = inserted.split(other);\n-                plusList.add(split.getPlus());\n-                minusList.add(split.getMinus());\n-                break;\n-            default:\n-                // ignore the sub-hyperplanes belonging to the cut hyperplane\n-            }\n-        }\n-\n-        // recurse through lower levels\n-        insertCuts(node.getPlus(),  plusList);\n-        insertCuts(node.getMinus(), minusList);\n-\n-    }\n-\n-    /** Build a convex region from a collection of bounding hyperplanes.\n-     * @param hyperplanes collection of bounding hyperplanes\n-     * @return a new convex region, or null if the collection is empty\n-     */\n-    public static Region buildConvex(final Collection<Hyperplane> hyperplanes) {\n-        if (hyperplanes.isEmpty()) {\n-            return null;\n-        }\n-\n-        // use the first hyperplane to build the right class\n-        final Region region = hyperplanes.iterator().next().wholeSpace();\n-\n-        // chop off parts of the space\n-        BSPTree node = region.tree;\n-        node.setAttribute(Boolean.TRUE);\n-        for (final Hyperplane hyperplane : hyperplanes) {\n-            if (node.insertCut(hyperplane)) {\n-                node.setAttribute(null);\n-                node.getPlus().setAttribute(Boolean.FALSE);\n-                node = node.getMinus();\n-                node.setAttribute(Boolean.TRUE);\n-            }\n-        }\n-\n-        return region;\n-\n-    }\n+    Region<S> buildNew(BSPTree<S> newTree);\n \n     /** Copy the instance.\n      * <p>The instance created is completely independant of the original\n      * attributes and immutable objects).</p>\n      * @return a new region, copy of the instance\n      */\n-    public Region copySelf() {\n-        return buildNew(tree.copySelf());\n-    }\n+    Region<S> copySelf();\n \n     /** Check if the instance is empty.\n      * @return true if the instance is empty\n      */\n-    public boolean isEmpty() {\n-        return isEmpty(tree);\n-    }\n+    boolean isEmpty();\n \n     /** Check if the sub-tree starting at a given node is empty.\n      * @param node root node of the sub-tree (<em>must</em> have {@link\n      * property)\n      * @return true if the sub-tree starting at the given node is empty\n      */\n-    public static boolean isEmpty(final BSPTree node) {\n-\n-        // we use a recursive function rather than the BSPTreeVisitor\n-        // interface because we can stop visiting the tree as soon as we\n-        // have found an inside cell\n-\n-        if (node.getCut() == null) {\n-            // if we find an inside node, the region is not empty\n-            return !isInside(node);\n-        }\n-\n-        // check both sides of the sub-tree\n-        return isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n-\n-    }\n-\n-    /** Check a leaf node inside attribute.\n-     * @param node leaf node to check\n-     * @return true if the leaf node is an inside node\n-     */\n-    private static boolean isInside(final BSPTree node) {\n-        return (Boolean) node.getAttribute();\n-    }\n+    boolean isEmpty(final BSPTree<S> node);\n \n     /** Check if the instance entirely contains another region.\n      * @param region region to check against the instance\n      * @return true if the instance contains the specified tree\n      */\n-    public boolean contains(final Region region) {\n-        return difference(region, this).isEmpty();\n-    }\n+    boolean contains(final Region<S> region);\n \n     /** Check a point with respect to the region.\n      * @param point point to check\n      * @return a code representing the point status: either {@link\n      * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n      */\n-    public Location checkPoint(final Point point) {\n-        return checkPoint(tree, point);\n-    }\n-\n-    /** Check a point with respect to the region starting at a given node.\n-     * @param node root node of the region\n-     * @param point point to check\n-     * @return a code representing the point status: either {@link\n-     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n-     */\n-    protected Location checkPoint(final BSPTree node, final Point point) {\n-        final BSPTree cell = node.getCell(point);\n-        if (cell.getCut() == null) {\n-            // the point is in the interior of a cell, just check the attribute\n-            return isInside(cell) ? Location.INSIDE : Location.OUTSIDE;\n-        }\n-\n-        // the point is on a cut-sub-hyperplane, is it on a boundary ?\n-        final Location minusCode = checkPoint(cell.getMinus(), point);\n-        final Location plusCode  = checkPoint(cell.getPlus(),  point);\n-        return (minusCode == plusCode) ? minusCode : Location.BOUNDARY;\n-\n-    }\n-\n-    /** Get the complement of the region (exchanged interior/exterior).\n-     * <p>The instance is not modified, a new region is built.</p>\n-     * @return a new region, complement of the instance\n-     */\n-    public Region getComplement() {\n-        return buildNew(recurseComplement(tree));\n-    }\n-\n-    /** Recursively build the complement of a BSP tree.\n-     * @param node current node of the original tree\n-     * @return new tree, complement of the node\n-     */\n-    private static BSPTree recurseComplement(final BSPTree node) {\n-        if (node.getCut() == null) {\n-            return new BSPTree(isInside(node) ? Boolean.FALSE : Boolean.TRUE);\n-        }\n-\n-        BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n-        if (attribute != null) {\n-            final SubHyperplane plusOutside =\n-                (attribute.plusInside == null) ? null : attribute.plusInside.copySelf();\n-            final SubHyperplane plusInside  =\n-                (attribute.plusOutside == null) ? null : attribute.plusOutside.copySelf();\n-            attribute = new BoundaryAttribute(plusOutside, plusInside);\n-        }\n-\n-        return new BSPTree(node.getCut().copySelf(),\n-                           recurseComplement(node.getPlus()),\n-                           recurseComplement(node.getMinus()),\n-                           attribute);\n-\n-    }\n+    Location checkPoint(final Vector<S> point);\n \n     /** Get the underlying BSP tree.\n \n      * @return underlying BSP tree\n      * @see BoundaryAttribute\n      */\n-    public BSPTree getTree(final boolean includeBoundaryAttributes) {\n-        if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n-            // we need to compute the boundary attributes\n-            recurseBuildBoundary(tree);\n-        }\n-        return tree;\n-    }\n-\n-    /** Class holding boundary attributes.\n-     * <p>This class is used for the attributes associated with the\n-     * nodes of region boundary shell trees returned by the {@link\n-     * Region#getTree Region.getTree}. It contains the\n-     * parts of the node cut sub-hyperplane that belong to the\n-     * boundary.</p>\n-     * <p>This class is a simple placeholder, it does not provide any\n-     * processing methods.</p>\n-     * @see Region#getTree\n-     */\n-    public static class BoundaryAttribute {\n-\n-        /** Part of the node cut sub-hyperplane that belongs to the\n-         * boundary and has the outside of the region on the plus side of\n-         * its underlying hyperplane (may be null).\n-         */\n-        private final SubHyperplane plusOutside;\n-\n-        /** Part of the node cut sub-hyperplane that belongs to the\n-         * boundary and has the inside of the region on the plus side of\n-         * its underlying hyperplane (may be null).\n-         */\n-        private final SubHyperplane plusInside;\n-\n-        /** Simple constructor.\n-         * @param plusOutside part of the node cut sub-hyperplane that\n-         * belongs to the boundary and has the outside of the region on\n-         * the plus side of its underlying hyperplane (may be null)\n-         * @param plusInside part of the node cut sub-hyperplane that\n-         * belongs to the boundary and has the inside of the region on the\n-         * plus side of its underlying hyperplane (may be null)\n-         */\n-        public BoundaryAttribute(final SubHyperplane plusOutside,\n-                                 final SubHyperplane plusInside) {\n-            this.plusOutside = plusOutside;\n-            this.plusInside  = plusInside;\n-        }\n-\n-        /** Get the part of the node cut sub-hyperplane that belongs to the\n-         * boundary and has the outside of the region on the plus side of\n-         * its underlying hyperplane.\n-         * @return part of the node cut sub-hyperplane that belongs to the\n-         * boundary and has the outside of the region on the plus side of\n-         * its underlying hyperplane\n-         */\n-        public SubHyperplane getPlusOutside() {\n-            return plusOutside;\n-        }\n-\n-        /** Get the part of the node cut sub-hyperplane that belongs to the\n-         * boundary and has the inside of the region on the plus side of\n-         * its underlying hyperplane.\n-         * @return part of the node cut sub-hyperplane that belongs to the\n-         * boundary and has the inside of the region on the plus side of\n-         * its underlying hyperplane\n-         */\n-        public SubHyperplane getPlusInside() {\n-            return plusInside;\n-        }\n-\n-\n-    }\n-\n-    /** Recursively build the boundary shell tree.\n-     * @param node current node in the inout tree\n-     */\n-    private void recurseBuildBoundary(final BSPTree node) {\n-        if (node.getCut() != null) {\n-\n-            SubHyperplane plusOutside = null;\n-            SubHyperplane plusInside  = null;\n-\n-            // characterize the cut sub-hyperplane,\n-            // first with respect to the plus sub-tree\n-            final Characterization plusChar = new Characterization();\n-            characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n-\n-            if (plusChar.hasOut()) {\n-                // plusChar.out corresponds to a subset of the cut\n-                // sub-hyperplane known to have outside cells on its plus\n-                // side, we want to check if parts of this subset do have\n-                // inside cells on their minus side\n-                final Characterization minusChar = new Characterization();\n-                characterize(node.getMinus(), plusChar.getOut(), minusChar);\n-                if (minusChar.hasIn()) {\n-                    plusOutside = minusChar.getIn();\n-                }\n-            }\n-\n-            if (plusChar.hasIn()) {\n-                // plusChar.in corresponds to a subset of the cut\n-                // sub-hyperplane known to have inside cells on its plus\n-                // side, we want to check if parts of this subset do have\n-                // outside cells on their minus side\n-                final Characterization minusChar = new Characterization();\n-                characterize(node.getMinus(), plusChar.getIn(), minusChar);\n-                if (minusChar.hasOut()) {\n-                    plusInside = minusChar.getOut();\n-                }\n-            }\n-\n-            node.setAttribute(new BoundaryAttribute(plusOutside, plusInside));\n-            recurseBuildBoundary(node.getPlus());\n-            recurseBuildBoundary(node.getMinus());\n-\n-        }\n-    }\n-\n-    /** Filter the parts of an hyperplane belonging to the boundary.\n-     * <p>The filtering consist in splitting the specified\n-     * sub-hyperplane into several parts lying in inside and outside\n-     * cells of the tree. The principle is to call this method twice for\n-     * each cut sub-hyperplane in the tree, once one the plus node and\n-     * once on the minus node. The parts that have the same flag\n-     * (inside/inside or outside/outside) do not belong to the boundary\n-     * while parts that have different flags (inside/outside or\n-     * outside/inside) do belong to the boundary.</p>\n-     * @param node current BSP tree node\n-     * @param sub sub-hyperplane to characterize\n-     * @param characterization placeholder where to put the characterized parts\n-     */\n-    private static void characterize(final BSPTree node, final SubHyperplane sub,\n-                                     final Characterization characterization) {\n-        if (node.getCut() == null) {\n-            // we have reached a leaf node\n-            final boolean inside = (Boolean) node.getAttribute();\n-            characterization.add(sub, inside);\n-        } else {\n-            final Hyperplane hyperplane = node.getCut().getHyperplane();\n-            switch (hyperplane.side(sub)) {\n-            case PLUS:\n-                characterize(node.getPlus(), sub, characterization);\n-                break;\n-            case MINUS:\n-                characterize(node.getMinus(), sub, characterization);\n-                break;\n-            case BOTH:\n-                final Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);\n-                characterize(node.getPlus(),  split.getPlus(),  characterization);\n-                characterize(node.getMinus(), split.getMinus(), characterization);\n-                break;\n-            default:\n-                // this should not happen\n-                throw new RuntimeException(\"internal error\");\n-            }\n-        }\n-    }\n+    BSPTree<S> getTree(final boolean includeBoundaryAttributes);\n \n     /** Get the size of the boundary.\n      * @return the size of the boundary (this is 0 in 1D, a length in\n      * 2D, an area in 3D ...)\n      */\n-    public double getBoundarySize() {\n-        final BoundarySizeVisitor visitor = new BoundarySizeVisitor();\n-        getTree(true).visit(visitor);\n-        return visitor.getSize();\n-    }\n-\n-    /** Visitor computing the boundary size. */\n-    private static class BoundarySizeVisitor implements BSPTreeVisitor {\n-\n-        /** Size of the boundary. */\n-        private double boundarySize;\n-\n-        /** Simple constructor.\n-         */\n-        public BoundarySizeVisitor() {\n-            boundarySize = 0;\n-        }\n-\n-        /** {@inheritDoc}*/\n-        public Order visitOrder(final BSPTree node) {\n-            return Order.MINUS_SUB_PLUS;\n-        }\n-\n-        /** {@inheritDoc}*/\n-        public void visitInternalNode(final BSPTree node) {\n-            final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n-            if (attribute.plusOutside != null) {\n-                boundarySize += attribute.plusOutside.getRemainingRegion().getSize();\n-            }\n-            if (attribute.plusInside != null) {\n-                boundarySize += attribute.plusInside.getRemainingRegion().getSize();\n-            }\n-        }\n-\n-        /** {@inheritDoc}*/\n-        public void visitLeafNode(final BSPTree node) {\n-        }\n-\n-        /** Get the size of the boundary.\n-         * @return size of the boundary\n-         */\n-        public double getSize() {\n-            return boundarySize;\n-        }\n-\n-    }\n+    double getBoundarySize();\n \n     /** Get the size of the instance.\n      * @return the size of the instance (this is a length in 1D, an area\n      * in 2D, a volume in 3D ...)\n      */\n-    public double getSize() {\n-        if (barycenter == null) {\n-            computeGeometricalProperties();\n-        }\n-        return size;\n-    }\n-\n-    /** Set the size of the instance.\n-     * @param size size of the instance\n-     */\n-    protected void setSize(final double size) {\n-        this.size = size;\n-    }\n+    double getSize();\n \n     /** Get the barycenter of the instance.\n      * @return an object representing the barycenter\n      */\n-    public Point getBarycenter() {\n-        if (barycenter == null) {\n-            computeGeometricalProperties();\n-        }\n-        return barycenter;\n-    }\n-\n-    /** Set the barycenter of the instance.\n-     * @param barycenter barycenter of the instance\n-     */\n-    protected void setBarycenter(final Point barycenter) {\n-        this.barycenter = barycenter;\n-    }\n-\n-    /** Compute some geometrical properties.\n-     * <p>The properties to compute are the barycenter and the size.</p>\n-     */\n-    protected abstract void computeGeometricalProperties();\n-\n-    /** Transform a region.\n-     * <p>Applying a transform to a region consist in applying the\n-     * transform to all the hyperplanes of the underlying BSP tree and\n-     * of the boundary (and also to the sub-hyperplanes embedded in\n-     * these hyperplanes) and to the barycenter. The instance is not\n-     * modified, a new instance is built.</p>\n-     * @param transform transform to apply\n-     * @return a new region, resulting from the application of the\n-     * transform to the instance\n-     */\n-    public Region applyTransform(final Transform transform) {\n-\n-        // transform the BSP tree\n-        final Region tRegion = buildNew(recurseTransform(tree, transform));\n-\n-        // transform the barycenter\n-        if (barycenter != null) {\n-            tRegion.size = size;\n-            tRegion.barycenter = transform.apply(barycenter);\n-        }\n-\n-        return tRegion;\n-\n-    }\n-\n-    /** Recursively transform an inside/outside BSP-tree.\n-     * @param node current BSP tree node\n-     * @param transform transform to apply\n-     * @return a new tree\n-     */\n-    private BSPTree recurseTransform(final BSPTree node, final Transform transform) {\n-\n-        if (node.getCut() == null) {\n-            return new BSPTree(node.getAttribute());\n-        }\n-\n-        final SubHyperplane  sub = node.getCut();\n-        final SubHyperplane tSub = sub.applyTransform(transform);\n-        BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n-        if (attribute != null) {\n-            final SubHyperplane tPO =\n-                (attribute.getPlusOutside() == null) ? null : attribute.getPlusOutside().applyTransform(transform);\n-            final SubHyperplane tPI =\n-                (attribute.getPlusInside()  == null) ? null  : attribute.getPlusInside().applyTransform(transform);\n-            attribute = new BoundaryAttribute(tPO, tPI);\n-        }\n-\n-        return new BSPTree(tSub,\n-                           recurseTransform(node.getPlus(),  transform),\n-                           recurseTransform(node.getMinus(), transform),\n-                           attribute);\n-\n-    }\n+    Vector<S> getBarycenter();\n \n     /** Compute the relative position of the instance with respect to an\n      * hyperplane.\n      * (the latter result can occur only if the tree contains only one\n      * cut hyperplane)\n      */\n-    public Hyperplane.Side side(final Hyperplane hyperplane) {\n-        final Sides sides = new Sides();\n-        recurseSides(tree, new SubHyperplane(hyperplane), sides);\n-        return sides.plusFound() ?\n-              (sides.minusFound() ? Hyperplane.Side.BOTH  : Hyperplane.Side.PLUS) :\n-              (sides.minusFound() ? Hyperplane.Side.MINUS : Hyperplane.Side.HYPER);\n-    }\n-\n-    /** Search recursively for inside leaf nodes on each side of the given hyperplane.\n-\n-     * <p>The algorithm used here is directly derived from the one\n-     * described in section III (<i>Binary Partitioning of a BSP\n-     * Tree</i>) of the Bruce Naylor, John Amanatides and William\n-     * Thibault paper <a\n-     * href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging\n-     * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph\n-     * '90, Computer Graphics 24(4), August 1990, pp 115-124, published\n-     * by the Association for Computing Machinery (ACM)..</p>\n-\n-     * @param node current BSP tree node\n-     * @param sub sub-hyperplane\n-     * @param sides object holding the sides found\n-     */\n-    private void recurseSides(final BSPTree node, final SubHyperplane sub, final Sides sides) {\n-\n-        if (node.getCut() == null) {\n-            if (isInside(node)) {\n-                // this is an inside cell expanding across the hyperplane\n-                sides.rememberPlusFound();\n-                sides.rememberMinusFound();\n-            }\n-            return;\n-        }\n-\n-        final Hyperplane hyperplane = node.getCut().getHyperplane();\n-        switch (hyperplane.side(sub)) {\n-        case PLUS :\n-            // the sub-hyperplane is entirely in the plus sub-tree\n-            if (sub.getHyperplane().side(node.getCut()) == Hyperplane.Side.PLUS) {\n-                if (!isEmpty(node.getMinus())) {\n-                    sides.rememberPlusFound();\n-                }\n-            } else {\n-                if (!isEmpty(node.getMinus())) {\n-                    sides.rememberMinusFound();\n-                }\n-            }\n-            if (!(sides.plusFound() && sides.minusFound())) {\n-                recurseSides(node.getPlus(), sub, sides);\n-            }\n-            break;\n-        case MINUS :\n-            // the sub-hyperplane is entirely in the minus sub-tree\n-            if (sub.getHyperplane().side(node.getCut()) == Hyperplane.Side.PLUS) {\n-                if (!isEmpty(node.getPlus())) {\n-                    sides.rememberPlusFound();\n-                }\n-            } else {\n-                if (!isEmpty(node.getPlus())) {\n-                    sides.rememberMinusFound();\n-                }\n-            }\n-            if (!(sides.plusFound() && sides.minusFound())) {\n-                recurseSides(node.getMinus(), sub, sides);\n-            }\n-            break;\n-        case BOTH :\n-            // the sub-hyperplane extends in both sub-trees\n-            final Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);\n-\n-            // explore first the plus sub-tree\n-            recurseSides(node.getPlus(), split.getPlus(), sides);\n-\n-            // if needed, explore the minus sub-tree\n-            if (!(sides.plusFound() && sides.minusFound())) {\n-                recurseSides(node.getMinus(), split.getMinus(), sides);\n-            }\n-            break;\n-        default :\n-            // the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\n-            if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\n-                if ((node.getPlus().getCut() != null) || isInside(node.getPlus())) {\n-                    sides.rememberPlusFound();\n-                }\n-                if ((node.getMinus().getCut() != null) || isInside(node.getMinus())) {\n-                    sides.rememberMinusFound();\n-                }\n-            } else {\n-                if ((node.getPlus().getCut() != null) || isInside(node.getPlus())) {\n-                    sides.rememberMinusFound();\n-                }\n-                if ((node.getMinus().getCut() != null) || isInside(node.getMinus())) {\n-                    sides.rememberPlusFound();\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    /** Utility class holding the already found sides. */\n-    private static final class Sides {\n-\n-        /** Indicator of inside leaf nodes found on the plus side. */\n-        private boolean plusFound;\n-\n-        /** Indicator of inside leaf nodes found on the plus side. */\n-        private boolean minusFound;\n-\n-        /** Simple constructor.\n-         */\n-        public Sides() {\n-            plusFound  = false;\n-            minusFound = false;\n-        }\n-\n-        /** Remember the fact that inside leaf nodes have been found on the plus side.\n-         */\n-        public void rememberPlusFound() {\n-            plusFound = true;\n-        }\n-\n-        /** Check if inside leaf nodes have been found on the plus side.\n-         * @return true if inside leaf nodes have been found on the plus side\n-         */\n-        public boolean plusFound() {\n-            return plusFound;\n-        }\n-\n-        /** Remember the fact that inside leaf nodes have been found on the minus side.\n-         */\n-        public void rememberMinusFound() {\n-            minusFound = true;\n-        }\n-\n-        /** Check if inside leaf nodes have been found on the minus side.\n-         * @return true if inside leaf nodes have been found on the minus side\n-         */\n-        public boolean minusFound() {\n-            return minusFound;\n-        }\n-\n-    }\n+    Side side(final Hyperplane<S> hyperplane);\n \n     /** Get the parts of a sub-hyperplane that are contained in the region.\n      * <p>The parts of the sub-hyperplane that belong to the boundary are\n      * @param sub sub-hyperplane traversing the region\n      * @return filtered sub-hyperplane\n      */\n-    public SubHyperplane intersection(final SubHyperplane sub) {\n-        return recurseIntersection(tree, sub);\n-    }\n-\n-    /** Recursively compute the parts of a sub-hyperplane that are\n-     * contained in the region.\n-     * @param node current BSP tree node\n-     * @param sub sub-hyperplane traversing the region\n-     * @return filtered sub-hyperplane\n-     */\n-    private SubHyperplane recurseIntersection(final BSPTree node, final SubHyperplane sub) {\n-\n-        if (node.getCut() == null) {\n-            return isInside(node) ? sub.copySelf() : null;\n-        }\n-\n-        final Hyperplane hyperplane = node.getCut().getHyperplane();\n-        switch (hyperplane.side(sub)) {\n-        case PLUS :\n-            return recurseIntersection(node.getPlus(), sub);\n-        case MINUS :\n-            return recurseIntersection(node.getMinus(), sub);\n-        case BOTH :\n-            final Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);\n-            final SubHyperplane plus  = recurseIntersection(node.getPlus(),  split.getPlus());\n-            final SubHyperplane minus = recurseIntersection(node.getMinus(), split.getMinus());\n-            if (plus == null) {\n-                return minus;\n-            } else if (minus == null) {\n-                return plus;\n-            } else {\n-                return new SubHyperplane(plus.getHyperplane(),\n-                                         Region.union(plus.getRemainingRegion(),\n-                                                      minus.getRemainingRegion()));\n-            }\n-        default :\n-            return recurseIntersection(node.getPlus(),\n-                                       recurseIntersection(node.getMinus(), sub));\n-        }\n-\n-    }\n-\n-    /** Compute the union of two regions.\n-     * @param region1 first region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @param region2 second region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @return a new region, result of {@code region1 union region2}\n-     */\n-    public static Region union(final Region region1, final Region region2) {\n-        final BSPTree tree = region1.tree.merge(region2.tree, new UnionMerger());\n-        tree.visit(new InternalNodesCleaner());\n-        return region1.buildNew(tree);\n-    }\n-\n-    /** Compute the intersection of two regions.\n-     * @param region1 first region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @param region2 second region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @return a new region, result of {@code region1 intersection region2}\n-     */\n-    public static Region intersection(final Region region1, final Region region2) {\n-        final BSPTree tree = region1.tree.merge(region2.tree, new IntersectionMerger());\n-        tree.visit(new InternalNodesCleaner());\n-        return region1.buildNew(tree);\n-    }\n-\n-    /** Compute the symmetric difference (exclusive or) of two regions.\n-     * @param region1 first region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @param region2 second region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @return a new region, result of {@code region1 xor region2}\n-     */\n-    public static Region xor(final Region region1, final Region region2) {\n-        final BSPTree tree = region1.tree.merge(region2.tree, new XORMerger());\n-        tree.visit(new InternalNodesCleaner());\n-        return region1.buildNew(tree);\n-    }\n-\n-    /** Compute the difference of two regions.\n-     * @param region1 first region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @param region2 second region (will be unusable after the operation as\n-     * parts of it will be reused in the new region)\n-     * @return a new region, result of {@code region1 minus region2}\n-     */\n-    public static Region difference(final Region region1, final Region region2) {\n-        final BSPTree tree = region1.tree.merge(region2.tree, new DifferenceMerger());\n-        tree.visit(new InternalNodesCleaner());\n-        return region1.buildNew(tree);\n-    }\n-\n-    /** Leaf node / tree merger for union operation. */\n-    private static final class UnionMerger implements BSPTree.LeafMerger {\n-        /** {@inheritDoc} */\n-        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n-                             final BSPTree parentTree, final boolean isPlusChild,\n-                             final boolean leafFromInstance) {\n-            if (isInside(leaf)) {\n-                // the leaf node represents an inside cell\n-                leaf.insertInTree(parentTree, isPlusChild);\n-                return leaf;\n-            }\n-            // the leaf node represents an outside cell\n-            tree.insertInTree(parentTree, isPlusChild);\n-            return tree;\n-        }\n-    };\n-\n-    /** Leaf node / tree merger for intersection operation. */\n-    private static final class IntersectionMerger implements BSPTree.LeafMerger {\n-        /** {@inheritDoc} */\n-        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n-                             final BSPTree parentTree, final boolean isPlusChild,\n-                             final boolean leafFromInstance) {\n-            if (isInside(leaf)) {\n-                // the leaf node represents an inside cell\n-                tree.insertInTree(parentTree, isPlusChild);\n-                return tree;\n-            }\n-            // the leaf node represents an outside cell\n-            leaf.insertInTree(parentTree, isPlusChild);\n-            return leaf;\n-        }\n-    };\n-\n-    /** Leaf node / tree merger for xor operation. */\n-    private static final class XORMerger implements BSPTree.LeafMerger {\n-        /** {@inheritDoc} */\n-        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n-                             final BSPTree parentTree, final boolean isPlusChild,\n-                             final boolean leafFromInstance) {\n-            BSPTree t = tree;\n-            if (isInside(leaf)) {\n-                // the leaf node represents an inside cell\n-                t = recurseComplement(t);\n-            }\n-            t.insertInTree(parentTree, isPlusChild);\n-            return t;\n-        }\n-    };\n-\n-    /** Leaf node / tree merger for difference operation.\n-     * <p>The algorithm used here is directly derived from the one\n-     * described in section III (<i>Binary Partitioning of a BSP\n-     * Tree</i>) of the Naylor, Amanatides and Thibault paper. An error\n-     * was detected and corrected in the figure 5.1 of the article for\n-     * merging leaf nodes with complete trees. Contrary to what is said\n-     * in the figure, the {@code ELSE} part of if is not the same\n-     * as the first part with {@code T1} and {@codeT2}\n-     * swapped. {@code T1} and {@codeT2} must be swapped\n-     * everywhere <em>except</em> in the {@code RETURN} part of the\n-     * {@code DIFFERENCE} operation: if {@codeT2} is an\n-     * in-cell, we must return {@code Complement_Bspt(T2)}, not\n-     * {@code Complement_Bspt(T1)}, and if {@codeT2} is an\n-     * out-cell, we must return {@code T1}, not {@codeT2}</p>\n-     */\n-    private static final class DifferenceMerger implements BSPTree.LeafMerger {\n-        /** {@inheritDoc} */\n-        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n-                             final BSPTree parentTree, final boolean isPlusChild,\n-                             final boolean leafFromInstance) {\n-            if (isInside(leaf)) {\n-                // the leaf node represents an inside cell\n-                final BSPTree argTree = recurseComplement(leafFromInstance ? tree : leaf);\n-                argTree.insertInTree(parentTree, isPlusChild);\n-                return argTree;\n-            }\n-            // the leaf node represents an outside cell\n-            final BSPTree instanceTree = leafFromInstance ? leaf : tree;\n-            instanceTree.insertInTree(parentTree, isPlusChild);\n-            return instanceTree;\n-        }\n-    };\n-\n-    /** Visitor removing internal nodes attributes. */\n-    private static final class InternalNodesCleaner implements BSPTreeVisitor {\n-\n-        /** {@inheritDoc} */\n-        public Order visitOrder(final BSPTree node) {\n-            return Order.PLUS_SUB_MINUS;\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void visitInternalNode(final BSPTree node) {\n-            node.setAttribute(null);\n-        }\n-\n-        /** {@inheritDoc} */\n-        public void visitLeafNode(final BSPTree node) {\n-        }\n-\n-    }\n+    SubHyperplane<S> intersection(final SubHyperplane<S> sub);\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/RegionFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.Space;\n+\n+/** This class is a factory for {@link Region}.\n+\n+ * @param <S> Type of the space.\n+\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class RegionFactory<S extends Space> {\n+\n+    /** Visitor removing internal nodes attributes. */\n+    private final NodesCleaner nodeCleaner;\n+\n+    /** Simple constructor.\n+     */\n+    public RegionFactory() {\n+        nodeCleaner = new NodesCleaner();\n+    }\n+\n+    /** Build a convex region from a collection of bounding hyperplanes.\n+     * @param hyperplanes collection of bounding hyperplanes\n+     * @return a new convex region, or null if the collection is empty\n+     */\n+    public Region<S> buildConvex(final Hyperplane<S> ... hyperplanes) {\n+        if ((hyperplanes == null) || (hyperplanes.length == 0)) {\n+            return null;\n+        }\n+\n+        // use the first hyperplane to build the right class\n+        final Region<S> region = hyperplanes[0].wholeSpace();\n+\n+        // chop off parts of the space\n+        BSPTree<S> node = region.getTree(false);\n+        node.setAttribute(Boolean.TRUE);\n+        for (final Hyperplane<S> hyperplane : hyperplanes) {\n+            if (node.insertCut(hyperplane)) {\n+                node.setAttribute(null);\n+                node.getPlus().setAttribute(Boolean.FALSE);\n+                node = node.getMinus();\n+                node.setAttribute(Boolean.TRUE);\n+            }\n+        }\n+\n+        return region;\n+\n+    }\n+\n+    /** Compute the union of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 union region2}\n+     */\n+    public Region<S> union(final Region<S> region1, final Region<S> region2) {\n+        final BSPTree<S> tree =\n+            region1.getTree(false).merge(region2.getTree(false), new UnionMerger());\n+        tree.visit(nodeCleaner);\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Compute the intersection of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 intersection region2}\n+     */\n+    public Region<S> intersection(final Region<S> region1, final Region<S> region2) {\n+        final BSPTree<S> tree =\n+            region1.getTree(false).merge(region2.getTree(false), new IntersectionMerger());\n+        tree.visit(nodeCleaner);\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Compute the symmetric difference (exclusive or) of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 xor region2}\n+     */\n+    public Region<S> xor(final Region<S> region1, final Region<S> region2) {\n+        final BSPTree<S> tree =\n+            region1.getTree(false).merge(region2.getTree(false), new XorMerger());\n+        tree.visit(nodeCleaner);\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Compute the difference of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 minus region2}\n+     */\n+    public Region<S> difference(final Region<S> region1, final Region<S> region2) {\n+        final BSPTree<S> tree =\n+            region1.getTree(false).merge(region2.getTree(false), new DifferenceMerger());\n+        tree.visit(nodeCleaner);\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Get the complement of the region (exchanged interior/exterior).\n+     * @param region region to complement, it will not modified, a new\n+     * region independent region will be built\n+     * @return a new region, complement of the specified one\n+     */\n+    public Region<S> getComplement(final Region<S> region) {\n+        return region.buildNew(recurseComplement(region.getTree(false)));\n+    }\n+\n+    /** Recursively build the complement of a BSP tree.\n+     * @param node current node of the original tree\n+     * @return new tree, complement of the node\n+     */\n+    private BSPTree<S> recurseComplement(final BSPTree<S> node) {\n+        if (node.getCut() == null) {\n+            return new BSPTree<S>(((Boolean) node.getAttribute()) ? Boolean.FALSE : Boolean.TRUE);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        BoundaryAttribute<S> attribute = (BoundaryAttribute<S>) node.getAttribute();\n+        if (attribute != null) {\n+            final SubHyperplane<S> plusOutside =\n+                (attribute.getPlusInside() == null) ? null : attribute.getPlusInside().copySelf();\n+            final SubHyperplane<S> plusInside  =\n+                (attribute.getPlusOutside() == null) ? null : attribute.getPlusOutside().copySelf();\n+            attribute = new BoundaryAttribute<S>(plusOutside, plusInside);\n+        }\n+\n+        return new BSPTree<S>(node.getCut().copySelf(),\n+                              recurseComplement(node.getPlus()),\n+                              recurseComplement(node.getMinus()),\n+                              attribute);\n+\n+    }\n+\n+    /** BSP tree leaf merger computing union of two regions. */\n+    private class UnionMerger implements BSPTree.LeafMerger<S> {\n+        /** {@inheritDoc} */\n+        public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\n+                                final BSPTree<S> parentTree,\n+                                final boolean isPlusChild, final boolean leafFromInstance) {\n+            if ((Boolean) leaf.getAttribute()) {\n+                // the leaf node represents an inside cell\n+                leaf.insertInTree(parentTree, isPlusChild);\n+                return leaf;\n+            }\n+            // the leaf node represents an outside cell\n+            tree.insertInTree(parentTree, isPlusChild);\n+            return tree;\n+        }\n+    }\n+\n+    /** BSP tree leaf merger computing union of two regions. */\n+    private class IntersectionMerger implements BSPTree.LeafMerger<S> {\n+        /** {@inheritDoc} */\n+        public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\n+                                final BSPTree<S> parentTree,\n+                                final boolean isPlusChild, final boolean leafFromInstance) {\n+            if ((Boolean) leaf.getAttribute()) {\n+                // the leaf node represents an inside cell\n+                tree.insertInTree(parentTree, isPlusChild);\n+                return tree;\n+            }\n+            // the leaf node represents an outside cell\n+            leaf.insertInTree(parentTree, isPlusChild);\n+            return leaf;\n+        }\n+    }\n+\n+    /** BSP tree leaf merger computing union of two regions. */\n+    private class XorMerger implements BSPTree.LeafMerger<S> {\n+        /** {@inheritDoc} */\n+        public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\n+                                final BSPTree<S> parentTree, final boolean isPlusChild,\n+                                final boolean leafFromInstance) {\n+            BSPTree<S> t = tree;\n+            if ((Boolean) leaf.getAttribute()) {\n+                // the leaf node represents an inside cell\n+                t = recurseComplement(t);\n+            }\n+            t.insertInTree(parentTree, isPlusChild);\n+            return t;\n+        }\n+    }\n+\n+    /** BSP tree leaf merger computing union of two regions. */\n+    private class DifferenceMerger implements BSPTree.LeafMerger<S> {\n+        /** {@inheritDoc} */\n+        public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\n+                                final BSPTree<S> parentTree, final boolean isPlusChild,\n+                                final boolean leafFromInstance) {\n+            if ((Boolean) leaf.getAttribute()) {\n+                // the leaf node represents an inside cell\n+                final BSPTree<S> argTree =\n+                    recurseComplement(leafFromInstance ? tree : leaf);\n+                argTree.insertInTree(parentTree, isPlusChild);\n+                return argTree;\n+            }\n+            // the leaf node represents an outside cell\n+            final BSPTree<S> instanceTree =\n+                leafFromInstance ? leaf : tree;\n+            instanceTree.insertInTree(parentTree, isPlusChild);\n+            return instanceTree;\n+        }\n+    }\n+\n+    /** Visitor removing internal nodes attributes. */\n+    private class NodesCleaner implements  BSPTreeVisitor<S> {\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(final BSPTree<S> node) {\n+            return Order.PLUS_SUB_MINUS;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitInternalNode(final BSPTree<S> node) {\n+            node.setAttribute(null);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitLeafNode(final BSPTree<S> node) {\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Side.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+/** Enumerate representing the location of an element with respect to an\n+ * {@link Hyperplane hyperplane} of a space.\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public enum Side {\n+\n+    /** Code for the plus side of the hyperplane. */\n+    PLUS,\n+\n+    /** Code for the minus side of the hyperplane. */\n+    MINUS,\n+\n+    /** Code for elements crossing the hyperplane from plus to minus side. */\n+    BOTH,\n+\n+    /** Code for the hyperplane itself. */\n+    HYPER;\n+\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java\n  */\n package org.apache.commons.math.geometry.partitioning;\n \n+import org.apache.commons.math.geometry.Space;\n+\n /** This interface represents the remaining parts of an hyperplane after\n  * other parts have been chopped off.\n \n  * hyperplane with the convex region which it splits, the chopping\n  * hyperplanes are the cut hyperplanes closer to the tree root.</p>\n \n- * @version $Revision$ $Date$\n+ * @param <S> Type of the embedding space.\n+\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public class SubHyperplane {\n-\n-    /** Underlying hyperplane. */\n-    private final Hyperplane hyperplane;\n-\n-    /** Remaining region of the hyperplane. */\n-    private final Region remainingRegion;\n-\n-    /** Build a chopped hyperplane that is not chopped at all.\n-     * @param hyperplane underlying hyperplane\n-     */\n-    public SubHyperplane(final Hyperplane hyperplane) {\n-        this.hyperplane = hyperplane;\n-        remainingRegion = hyperplane.wholeHyperplane();\n-    }\n-\n-    /** Build a sub-hyperplane from an hyperplane and a region.\n-     * @param hyperplane underlying hyperplane\n-     * @param remainingRegion remaining region of the hyperplane\n-     */\n-    public SubHyperplane(final Hyperplane hyperplane, final Region remainingRegion) {\n-        this.hyperplane      = hyperplane;\n-        this.remainingRegion = remainingRegion;\n-    }\n+public interface SubHyperplane<S extends Space> {\n \n     /** Copy the instance.\n      * <p>The instance created is completely independant of the original\n      * objects).</p>\n      * @return a new sub-hyperplane, copy of the instance\n      */\n-    public SubHyperplane copySelf() {\n-        return new SubHyperplane(hyperplane.copySelf(), remainingRegion.copySelf());\n-    }\n+    SubHyperplane<S> copySelf();\n \n     /** Get the underlying hyperplane.\n      * @return underlying hyperplane\n      */\n-    public Hyperplane getHyperplane() {\n-        return hyperplane;\n-    }\n+    Hyperplane<S> getHyperplane();\n \n-    /** Get the remaining region of the hyperplane.\n-     * <p>The returned region is expressed in the canonical hyperplane\n-     * frame and has the hyperplane dimension. For example a chopped\n-     * hyperplane in the 3D euclidean is a 2D plane and the\n-     * corresponding region is a convex 2D polygon.</p>\n-     * @return remaining region of the hyperplane\n+    /** Check if the instance is empty.\n+     * @return true if the instance is empty\n      */\n-    public Region getRemainingRegion() {\n-        return remainingRegion;\n-    }\n+    boolean isEmpty();\n \n-    /** Apply a transform to the instance.\n-     * <p>The instance must be a (D-1)-dimension sub-hyperplane with\n-     * respect to the transform <em>not</em> a (D-2)-dimension\n-     * sub-hyperplane the transform knows how to transform by\n-     * itself. The transform will consist in transforming first the\n-     * hyperplane and then the all region using the various methods\n-     * provided by the transform.</p>\n-     * @param transform D-dimension transform to apply\n-     * @return the transformed instance\n+    /** Get the size of the instance.\n+     * @return the size of the instance (this is a length in 1D, an area\n+     * in 2D, a volume in 3D ...)\n      */\n-    public SubHyperplane applyTransform(final Transform transform) {\n-        final Hyperplane tHyperplane = transform.apply(hyperplane);\n-        final BSPTree tTree =\n-            recurseTransform(remainingRegion.getTree(false), tHyperplane, transform);\n-        return new SubHyperplane(tHyperplane, remainingRegion.buildNew(tTree));\n-    }\n+    double getSize();\n \n-    /** Recursively transform a BSP-tree from a sub-hyperplane.\n-     * @param node current BSP tree node\n-     * @param transformed image of the instance hyperplane by the transform\n-     * @param transform transform to apply\n-     * @return a new tree\n+    /** Compute the relative position of the instance with respect\n+     * to an hyperplane.\n+     * @param hyperplane hyperplane to check instane against\n+     * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},\n+     * {@link Side#HYPER}\n      */\n-    private BSPTree recurseTransform(final BSPTree node, final Hyperplane transformed,\n-                                     final Transform transform) {\n-        if (node.getCut() == null) {\n-            return new BSPTree(node.getAttribute());\n+    Side side(Hyperplane<S> hyperplane);\n+\n+    /** Split the instance in two parts by an hyperplane.\n+     * @param hyperplane splitting hyperplane\n+     * @return an object containing both the part of the instance\n+     * on the plus side of the instance and the part of the\n+     * instance on the minus side of the instance\n+     */\n+    SplitSubHyperplane<S> split(Hyperplane<S> hyperplane);\n+\n+    /** Compute the union of the instance and another sub-hyperplane.\n+     * @param other other sub-hyperplane to union (<em>must</em> be in the\n+     * same hyperplane as the instance)\n+     * @return a new sub-hyperplane, union of the instane and other\n+     */\n+    SubHyperplane<S> reunite(SubHyperplane<S> other);\n+\n+    /** Class holding the results of the {@link Hyperplane#split Hyperplane.split}\n+     * method.\n+     * @param <S> Type of the embedding space.\n+     * @param <T> Type of the embedded sub-space.\n+     */\n+    public static class SplitSubHyperplane<U extends Space> {\n+\n+        /** Part of the sub-hyperplane on the plus side of the splitting hyperplane. */\n+        private final SubHyperplane<U> plus;\n+\n+        /** Part of the sub-hyperplane on the minus side of the splitting hyperplane. */\n+        private final SubHyperplane<U> minus;\n+\n+        /** Build a SplitSubHyperplane from its parts.\n+         * @param plus part of the sub-hyperplane on the plus side of the\n+         * splitting hyperplane\n+         * @param minus part of the sub-hyperplane on the minus side of the\n+         * splitting hyperplane\n+         */\n+        public SplitSubHyperplane(final SubHyperplane<U> plus,\n+                                  final SubHyperplane<U> minus) {\n+            this.plus  = plus;\n+            this.minus = minus;\n         }\n \n-        Region.BoundaryAttribute attribute =\n-            (Region.BoundaryAttribute) node.getAttribute();\n-        if (attribute != null) {\n-            final SubHyperplane tPO = (attribute.getPlusOutside() == null) ?\n-                                      null :\n-                                      transform.apply(attribute.getPlusOutside(),\n-                                                      hyperplane, transformed);\n-            final SubHyperplane tPI = (attribute.getPlusInside() == null) ?\n-                                      null :\n-                                      transform.apply(attribute.getPlusInside(),\n-                                                      hyperplane, transformed);\n-            attribute = new Region.BoundaryAttribute(tPO, tPI);\n+        /** Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.\n+         * @return part of the sub-hyperplane on the plus side of the splitting hyperplane\n+         */\n+        public SubHyperplane<U> getPlus() {\n+            return plus;\n         }\n \n-        return new BSPTree(transform.apply(node.getCut(),\n-                                           hyperplane, transformed),\n-                                           recurseTransform(node.getPlus(), transformed,\n-                                                            transform),\n-                                                            recurseTransform(node.getMinus(), transformed,\n-                                                                             transform),\n-                                                                             attribute);\n+        /** Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.\n+         * @return part of the sub-hyperplane on the minus side of the splitting hyperplane\n+         */\n+        public SubHyperplane<U> getMinus() {\n+            return minus;\n+        }\n \n     }\n \n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java\n  */\n package org.apache.commons.math.geometry.partitioning;\n \n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.Space;\n+\n \n /** This interface represents an inversible affine transform in a space.\n  * <p>Inversible affine transform include for example scalings,\n  * <ul>\n  *   <li>\n  *     the transform can be applied to a point in the\n- *     D-dimension space using its {@link #apply(Point)}\n+ *     D-dimension space using its {@link #apply(Vector)}\n  *     method\n  *   </li>\n  *   <li>\n  *   </li>\n  * </ul>\n \n- * @version $Revision$ $Date$\n+ * @param <S> Type of the embedding space.\n+ * @param <T> Type of the embedded sub-space.\n+\n+ * @version $Id:$\n+ * @since 3.0\n  */\n-public interface Transform {\n+public interface Transform<S extends Space, T extends Space> {\n \n     /** Transform a point of a space.\n      * @param point point to transform\n      * @return a new object representing the transformed point\n      */\n-    Point apply(Point point);\n+    Vector<S> apply(Vector<S> point);\n \n     /** Transform an hyperplane of a space.\n      * @param hyperplane hyperplane to transform\n      * @return a new object representing the transformed hyperplane\n      */\n-    Hyperplane apply(Hyperplane hyperplane);\n+    Hyperplane<S> apply(Hyperplane<S> hyperplane);\n \n     /** Transform a sub-hyperplane embedded in an hyperplane.\n      * @param sub sub-hyperplane to transform\n      * <em>has</em> been applied to it)\n      * @return a new object representing the transformed sub-hyperplane\n      */\n-    SubHyperplane apply(SubHyperplane sub, Hyperplane original, Hyperplane transformed);\n+    SubHyperplane<T> apply(SubHyperplane<T> sub, Hyperplane<S> original, Hyperplane<S> transformed);\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java\n \n  * @param <T> the type of the elements\n \n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n public class AVLTree<T extends Comparable<T>> {\n \n--- a/src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java\n  * components</li>\n  * </ul>\n \n- * @version $Revision$ $Date$\n+ * @version $Id:$\n+ * @since 3.0\n  */\n public class OrderedTuple implements Comparable<OrderedTuple> {\n ", "timestamp": 1307124381, "metainfo": ""}