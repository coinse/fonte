{"sha": "4a91d0338ff80489a1a105633607857435eecd90", "log": "MATH-902 Added a constructor in the custom checkers that enables normal termination of an optimization algorithm (i.e. returning the curent best point after a selected number of iterations have been performed).   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/SimplePointChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimplePointChecker.java\n \n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n  * difference between each point coordinate are smaller than a threshold\n  * or if either the absolute difference between the point coordinates are\n  * smaller than another threshold.\n+ * <br/>\n+ * The {@link #converged(int,Pair,Pair) converged} method will also return\n+ * {@code true} if the number of iterations has been set (see\n+ * {@link #SimplePointChecker(double,double,int) this constructor}).\n  *\n  * @param <PAIR> Type of the (point, value) pair.\n  * The type of the \"value\" part of the pair (not used by this class).\n public class SimplePointChecker<PAIR extends Pair<double[], ? extends Object>>\n     extends AbstractConvergenceChecker<PAIR> {\n     /**\n+     * If {@link #maxIterationCount} is set to this value, the number of\n+     * iterations will never cause {@link #converged(int,Pair,Pair>)}\n+     * to return {@code true}.\n+     */\n+    private static final int ITERATION_CHECK_DISABLED = -1;\n+    /**\n+     * Number of iterations after which the\n+     * {@link #converged(int,PointVectorValuePair,PointVectorValuePair)} method\n+     * will return true (unless the check is disabled).\n+     */\n+    private final int maxIterationCount;\n+\n+    /**\n      * Build an instance with default threshold.\n      * @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()}\n      */\n     @Deprecated\n-    public SimplePointChecker() {}\n+    public SimplePointChecker() {\n+        maxIterationCount = ITERATION_CHECK_DISABLED;\n+    }\n \n     /**\n      * Build an instance with specified thresholds.\n     public SimplePointChecker(final double relativeThreshold,\n                               final double absoluteThreshold) {\n         super(relativeThreshold, absoluteThreshold);\n+        maxIterationCount = ITERATION_CHECK_DISABLED;\n+    }\n+\n+    /**\n+     * Builds an instance with specified thresholds.\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold Relative tolerance threshold.\n+     * @param absoluteThreshold Absolute tolerance threshold.\n+     * @param maxIter Maximum iteration count. Setting it to a negative\n+     * value will disable this stopping criterion.\n+     * @throws NotStrictlyPositiveException if {@code maxIter <= 0}.\n+     *\n+     * @since 3.1\n+     */\n+    public SimplePointChecker(final double relativeThreshold,\n+                              final double absoluteThreshold,\n+                              final int maxIter) {\n+        super(relativeThreshold, absoluteThreshold);\n+\n+        if (maxIter <= 0) {\n+            throw new NotStrictlyPositiveException(maxIter);\n+        }\n+        maxIterationCount = maxIter;\n     }\n \n     /**\n      * Check if the optimization algorithm has converged considering the\n      * last two points.\n-     * This method may be called several time from the same algorithm\n+     * This method may be called several times from the same algorithm\n      * iteration with different points. This can be detected by checking the\n      * iteration number at each call if needed. Each time this method is\n      * called, the previous and current point correspond to points with the\n      * @param iteration Index of current iteration\n      * @param previous Best point in the previous iteration.\n      * @param current Best point in the current iteration.\n-     * @return {@code true} if the algorithm has converged.\n+     * @return {@code true} if the arguments satify the convergence criterion.\n      */\n     @Override\n     public boolean converged(final int iteration,\n                              final PAIR previous,\n                              final PAIR current) {\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n+            if (iteration >= maxIterationCount) {\n+                return true;\n+            }\n+        }\n+\n         final double[] p = previous.getKey();\n         final double[] c = current.getKey();\n         for (int i = 0; i < p.length; ++i) {\n--- a/src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java\n package org.apache.commons.math3.optimization;\n \n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n  * difference between the objective function values is smaller than a\n  * threshold or if either the absolute difference between the objective\n  * function values is smaller than another threshold.\n+ * <br/>\n+ * The {@link #converged(int,PointValuePair,PointValuePair) converged}\n+ * method will also return {@code true} if the number of iterations has been set\n+ * (see {@link #SimpleValueChecker(double,double,int) this constructor}).\n  *\n  * @version $Id$\n  * @since 3.0\n public class SimpleValueChecker\n     extends AbstractConvergenceChecker<PointValuePair> {\n     /**\n+     * If {@link #maxIterationCount} is set to this value, the number of\n+     * iterations will never cause\n+     * {@link #converged(int,PointValuePair,PointValuePair)}\n+     * to return {@code true}.\n+     */\n+    private static final int ITERATION_CHECK_DISABLED = -1;\n+    /**\n+     * Number of iterations after which the\n+     * {@link #converged(int,PointValuePair,PointValuePair)} method\n+     * will return true (unless the check is disabled).\n+     */\n+    private final int maxIterationCount;\n+\n+    /**\n      * Build an instance with default thresholds.\n      * @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()}\n      */\n     @Deprecated\n-    public SimpleValueChecker() {}\n+    public SimpleValueChecker() {\n+        maxIterationCount = ITERATION_CHECK_DISABLED;\n+    }\n \n     /** Build an instance with specified thresholds.\n      *\n     public SimpleValueChecker(final double relativeThreshold,\n                               final double absoluteThreshold) {\n         super(relativeThreshold, absoluteThreshold);\n+        maxIterationCount = ITERATION_CHECK_DISABLED;\n+    }\n+\n+    /**\n+     * Builds an instance with specified thresholds.\n+     *\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     * @param maxIter Maximum iteration count. Setting it to a negative\n+     * value will disable this stopping criterion.\n+     * @throws NotStrictlyPositiveException if {@code maxIter <= 0}.\n+     *\n+     * @since 3.1\n+     */\n+    public SimpleValueChecker(final double relativeThreshold,\n+                              final double absoluteThreshold,\n+                              final int maxIter) {\n+        super(relativeThreshold, absoluteThreshold);\n+\n+        if (maxIter <= 0) {\n+            throw new NotStrictlyPositiveException(maxIter);\n+        }\n+        maxIterationCount = maxIter;\n     }\n \n     /**\n     public boolean converged(final int iteration,\n                              final PointValuePair previous,\n                              final PointValuePair current) {\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n+            if (iteration >= maxIterationCount) {\n+                return true;\n+            }\n+        }\n+\n         final double p = previous.getValue();\n         final double c = current.getValue();\n         final double difference = FastMath.abs(p - c);\n--- a/src/main/java/org/apache/commons/math3/optimization/SimpleVectorValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimpleVectorValueChecker.java\n package org.apache.commons.math3.optimization;\n \n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n \n /**\n  * Simple implementation of the {@link ConvergenceChecker} interface using\n  * difference between the objective function values is smaller than a\n  * threshold or if either the absolute difference between the objective\n  * function values is smaller than another threshold for all vectors elements.\n+ * <br/>\n+ * The {@link #converged(int,PointVectorValuePair,PointVectorValuePair) converged}\n+ * method will also return {@code true} if the number of iterations has been set\n+ * (see {@link #SimpleVectorValueChecker(double,double,int) this constructor}).\n  *\n  * @version $Id$\n  * @since 3.0\n public class SimpleVectorValueChecker\n     extends AbstractConvergenceChecker<PointVectorValuePair> {\n     /**\n+     * If {@link #maxIterationCount} is set to this value, the number of\n+     * iterations will never cause\n+     * {@link #converged(int,PointVectorValuePair,PointVectorValuePair)}\n+     * to return {@code true}.\n+     */\n+    private static final int ITERATION_CHECK_DISABLED = -1;\n+    /**\n+     * Number of iterations after which the\n+     * {@link #converged(int,PointVectorValuePair,PointVectorValuePair)} method\n+     * will return true (unless the check is disabled).\n+     */\n+    private final int maxIterationCount;\n+\n+    /**\n      * Build an instance with default thresholds.\n      * @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()}\n      */\n     @Deprecated\n-    public SimpleVectorValueChecker() {}\n+    public SimpleVectorValueChecker() {\n+        maxIterationCount = ITERATION_CHECK_DISABLED;\n+    }\n \n     /**\n      * Build an instance with specified thresholds.\n      * @param absoluteThreshold absolute tolerance threshold\n      */\n     public SimpleVectorValueChecker(final double relativeThreshold,\n-                                       final double absoluteThreshold) {\n+                                    final double absoluteThreshold) {\n         super(relativeThreshold, absoluteThreshold);\n+        maxIterationCount = ITERATION_CHECK_DISABLED;\n+    }\n+\n+    /**\n+     * Builds an instance with specified tolerance thresholds and\n+     * iteration count.\n+     *\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold Relative tolerance threshold.\n+     * @param absoluteThreshold Absolute tolerance threshold.\n+     * @param maxIter Maximum iteration count. Setting it to a negative\n+     * value will disable this stopping criterion.\n+     * @throws NotStrictlyPositiveException if {@code maxIter <= 0}.\n+     *\n+     * @since 3.1\n+     */\n+    public SimpleVectorValueChecker(final double relativeThreshold,\n+                                    final double absoluteThreshold,\n+                                    final int maxIter) {\n+        super(relativeThreshold, absoluteThreshold);\n+\n+        if (maxIter <= 0) {\n+            throw new NotStrictlyPositiveException(maxIter);\n+        }\n+        maxIterationCount = maxIter;\n     }\n \n     /**\n      * Check if the optimization algorithm has converged considering the\n      * last two points.\n-     * This method may be called several time from the same algorithm\n+     * This method may be called several times from the same algorithm\n      * iteration with different points. This can be detected by checking the\n      * iteration number at each call if needed. Each time this method is\n      * called, the previous and current point correspond to points with the\n      * @param iteration Index of current iteration\n      * @param previous Best point in the previous iteration.\n      * @param current Best point in the current iteration.\n-     * @return {@code true} if the algorithm has converged.\n+     * @return {@code true} if the arguments satify the convergence criterion.\n      */\n     @Override\n     public boolean converged(final int iteration,\n                              final PointVectorValuePair previous,\n                              final PointVectorValuePair current) {\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n+            if (iteration >= maxIterationCount) {\n+                return true;\n+            }\n+        }\n+\n         final double[] p = previous.getValueRef();\n         final double[] c = current.getValueRef();\n         for (int i = 0; i < p.length; ++i) {\n--- a/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java\n \n         for (int i = 0; i <= 1; i++) {\n             Assert.assertEquals(lm[i], gn[i], tol);\n+        }\n+    }\n+\n+    /**\n+     * This test shows that the user can set the maximum number of iterations\n+     * to avoid running for too long.\n+     * Even if the real problem is that the tolerance is way too stringent, it\n+     * is possible to get the best solution so far, i.e. a checker will return\n+     * the point when the maximum iteration count has been reached.\n+     */\n+    @Test\n+    public void testMath798WithToleranceTooLowButNoException() {\n+        final double tol = 1e-100;\n+        final double[] init = new double[] { 0, 0 };\n+        final int maxEval = 10000; // Trying hard to fit.\n+        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol, maxEval);\n+\n+        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);\n+        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);\n+\n+        for (int i = 0; i <= 1; i++) {\n+            Assert.assertEquals(lm[i], gn[i], 1e-15);\n         }\n     }\n ", "timestamp": 1353439756, "metainfo": ""}