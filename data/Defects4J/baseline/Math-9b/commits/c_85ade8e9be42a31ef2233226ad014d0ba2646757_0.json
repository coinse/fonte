{"sha": "85ade8e9be42a31ef2233226ad014d0ba2646757", "log": "Implemented convenience classes for easy access to NIST Statistical Reference Datasets (StRD). These classes are used for unit testing of AbstractLeastSquaresOptimizer.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.math3.optimization.general;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import junit.framework.Assert;\n+\n+import org.apache.commons.math3.optimization.PointVectorValuePair;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Test;\n+\n+public class AbstractLeastSquaresOptimizerTest {\n+\n+    public static AbstractLeastSquaresOptimizer createOptimizer() {\n+        return new AbstractLeastSquaresOptimizer() {\n+\n+            @Override\n+            protected PointVectorValuePair doOptimize() {\n+                updateResidualsAndCost();\n+                updateJacobian();\n+                return null;\n+            }\n+        };\n+    }\n+\n+    @Test\n+    public void testGetChiSquare() throws IOException {\n+        final StatisticalReferenceDataset dataset;\n+        dataset = StatisticalReferenceDatasetFactory.createKirby2();\n+        final AbstractLeastSquaresOptimizer optimizer;\n+        optimizer = createOptimizer();\n+        final double[] a = dataset.getParameters();\n+        final double[] y = dataset.getData()[1];\n+        final double[] w = new double[y.length];\n+        Arrays.fill(w, 1.0);\n+\n+        optimizer.optimize(1, dataset.getLeastSquaresProblem(), y, w, a);\n+        final double expected = dataset.getResidualSumOfSquares();\n+        final double actual = optimizer.getChiSquare();\n+        Assert.assertEquals(dataset.getName(), expected, actual,\n+                            1E-11 * expected);\n+    }\n+\n+    @Test\n+    public void testGetRMS() throws IOException {\n+        final StatisticalReferenceDataset dataset;\n+        dataset = StatisticalReferenceDatasetFactory.createKirby2();\n+        final AbstractLeastSquaresOptimizer optimizer;\n+        optimizer = createOptimizer();\n+        final double[] a = dataset.getParameters();\n+        final double[] y = dataset.getData()[1];\n+        final double[] w = new double[y.length];\n+        Arrays.fill(w, 1.0);\n+\n+        optimizer.optimize(1, dataset.getLeastSquaresProblem(), y, w, a);\n+        final double expected = FastMath\n+            .sqrt(dataset.getResidualSumOfSquares() /\n+                  dataset.getNumObservations());\n+        final double actual = optimizer.getRMS();\n+        Assert.assertEquals(dataset.getName(), expected, actual,\n+                            1E-11 * expected);\n+    }\n+\n+    @Test\n+    public void testGuessParametersErrors() throws IOException {\n+        final StatisticalReferenceDataset dataset;\n+        dataset = StatisticalReferenceDatasetFactory.createKirby2();\n+        final AbstractLeastSquaresOptimizer optimizer;\n+        optimizer = createOptimizer();\n+        final double[] a = dataset.getParameters();\n+        final double[] y = dataset.getData()[1];\n+        final double[] w = new double[y.length];\n+        Arrays.fill(w, 1.0);\n+\n+        optimizer.optimize(1, dataset.getLeastSquaresProblem(), y, w, a);\n+        final double[] actual = optimizer.guessParametersErrors();\n+        final double[] expected = dataset.getParametersStandardDeviations();\n+        for (int i = 0; i < actual.length; i++) {\n+            Assert.assertEquals(dataset.getName() + \", parameter #\" + i,\n+                                actual[i], expected[i], 1E-8 * expected[i]);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/StatisticalReferenceDataset.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.optimization.general;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * This class gives access to the statistical reference datasets provided by the\n+ * NIST (available\n+ * <a href=\"http://www.itl.nist.gov/div898/strd/general/dataarchive.html\">here</a>).\n+ * Instances of this class can be created by invocation of the\n+ * {@link StatisticalReferenceDatasetFactory}.\n+ */\n+public abstract class StatisticalReferenceDataset {\n+\n+    /** The name of this dataset. */\n+    private final String name;\n+\n+    /** The total number of observations (data points). */\n+    private final int numObservations;\n+\n+    /** The total number of parameters. */\n+    private final int numParameters;\n+\n+    /** The total number of starting points for the optimizations. */\n+    private final int numStartingPoints;\n+\n+    /** The values of the predictor. */\n+    private final double[] x;\n+\n+    /** The values of the response. */\n+    private final double[] y;\n+\n+    /**\n+     * The starting values. {@code startingValues[j][i]} is the value of the\n+     * {@code i}-th parameter in the {@code j}-th set of starting values.\n+     */\n+    private final double[][] startingValues;\n+\n+    /** The certified values of the parameters. */\n+    private final double[] a;\n+\n+    /** The certified values of the standard deviation of the parameters. */\n+    private final double[] sigA;\n+\n+    /** The certified value of the residual sum of squares. */\n+    private double residualSumOfSquares;\n+\n+    /** The least-squares problem. */\n+    private final DifferentiableMultivariateVectorFunction problem;\n+\n+    /**\n+     * Creates a new instance of this class from the specified data file. The\n+     * file must follow the StRD format.\n+     *\n+     * @param in the data file\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public StatisticalReferenceDataset(final BufferedReader in)\n+        throws IOException {\n+\n+        final ArrayList<String> lines = new ArrayList<String>();\n+        for (String line = in.readLine(); line != null; line = in.readLine()) {\n+            lines.add(line);\n+        }\n+        int[] index = findLineNumbers(\"Data\", lines);\n+        if (index == null) {\n+            throw new AssertionError(\"could not find line indices for data\");\n+        }\n+        this.numObservations = index[1] - index[0] + 1;\n+        this.x = new double[this.numObservations];\n+        this.y = new double[this.numObservations];\n+        for (int i = 0; i < this.numObservations; i++) {\n+            final String line = lines.get(index[0] + i - 1);\n+            final String[] tokens = line.trim().split(\" ++\");\n+            // Data columns are in reverse order!!!\n+            this.y[i] = Double.parseDouble(tokens[0]);\n+            this.x[i] = Double.parseDouble(tokens[1]);\n+        }\n+\n+        index = findLineNumbers(\"Starting Values\", lines);\n+        if (index == null) {\n+            throw new AssertionError(\n+                                     \"could not find line indices for starting values\");\n+        }\n+        this.numParameters = index[1] - index[0] + 1;\n+\n+        double[][] start = null;\n+        this.a = new double[numParameters];\n+        this.sigA = new double[numParameters];\n+        for (int i = 0; i < numParameters; i++) {\n+            final String line = lines.get(index[0] + i - 1);\n+            final String[] tokens = line.trim().split(\" ++\");\n+            if (start == null) {\n+                start = new double[tokens.length - 4][numParameters];\n+            }\n+            for (int j = 2; j < tokens.length - 2; j++) {\n+                start[j - 2][i] = Double.parseDouble(tokens[j]);\n+            }\n+            this.a[i] = Double.parseDouble(tokens[tokens.length - 2]);\n+            this.sigA[i] = Double.parseDouble(tokens[tokens.length - 1]);\n+        }\n+        if (start == null) {\n+            throw new IOException(\"could not find starting values\");\n+        }\n+        this.numStartingPoints = start.length;\n+        this.startingValues = start;\n+\n+        double dummyDouble = Double.NaN;\n+        String dummyString = null;\n+        for (String line : lines) {\n+            if (line.contains(\"Dataset Name:\")) {\n+                dummyString = line\n+                    .substring(line.indexOf(\"Dataset Name:\") + 13,\n+                               line.indexOf(\"(\")).trim();\n+            }\n+            if (line.contains(\"Residual Sum of Squares\")) {\n+                final String[] tokens = line.split(\" ++\");\n+                dummyDouble = Double.parseDouble(tokens[4].trim());\n+            }\n+        }\n+        if (Double.isNaN(dummyDouble)) {\n+            throw new IOException(\n+                                  \"could not find certified value of residual sum of squares\");\n+        }\n+        this.residualSumOfSquares = dummyDouble;\n+\n+        if (dummyString == null) {\n+            throw new IOException(\"could not find dataset name\");\n+        }\n+        this.name = dummyString;\n+\n+        this.problem = new DifferentiableMultivariateVectorFunction() {\n+            public double[] value(final double[] a) {\n+                final int n = getNumObservations();\n+                final double[] yhat = new double[n];\n+                for (int i = 0; i < n; i++) {\n+                    yhat[i] = getModelValue(getX(i), a);\n+                }\n+                return yhat;\n+            }\n+\n+            public MultivariateMatrixFunction jacobian() {\n+                return new MultivariateMatrixFunction() {\n+                    public double[][] value(final double[] a)\n+                        throws IllegalArgumentException {\n+                        final int n = getNumObservations();\n+                        final double[][] j = new double[n][];\n+                        for (int i = 0; i < n; i++) {\n+                            j[i] = getModelDerivatives(getX(i), a);\n+                        }\n+                        return j;\n+                    }\n+                };\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns the name of this dataset.\n+     *\n+     * @return the name of the dataset\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the total number of observations (data points).\n+     *\n+     * @return the number of observations\n+     */\n+    public int getNumObservations() {\n+        return numObservations;\n+    }\n+\n+    /**\n+     * Returns a copy of the data arrays. The data is laid out as follows <li>\n+     * {@code data[0][i] = x[i]},</li> <li>{@code data[1][i] = y[i]},</li>\n+     *\n+     * @return the array of data points.\n+     */\n+    public double[][] getData() {\n+        return new double[][] {\n+            MathArrays.copyOf(x), MathArrays.copyOf(y)\n+        };\n+    }\n+\n+    /**\n+     * Returns the x-value of the {@code i}-th data point.\n+     *\n+     * @param i the index of the data point\n+     * @return the x-value\n+     */\n+    public double getX(final int i) {\n+        return x[i];\n+    }\n+\n+    /**\n+     * Returns the y-value of the {@code i}-th data point.\n+     *\n+     * @param i the index of the data point\n+     * @return the y-value\n+     */\n+    public double getY(final int i) {\n+        return y[i];\n+    }\n+\n+    /**\n+     * Returns the total number of parameters.\n+     *\n+     * @return the number of parameters\n+     */\n+    public int getNumParameters() {\n+        return numParameters;\n+    }\n+\n+    /**\n+     * Returns the certified values of the paramters.\n+     *\n+     * @return the values of the parameters\n+     */\n+    public double[] getParameters() {\n+        return MathArrays.copyOf(a);\n+    }\n+\n+    /**\n+     * Returns the certified value of the {@code i}-th parameter.\n+     *\n+     * @param i the index of the parameter\n+     * @return the value of the parameter\n+     */\n+    public double getParameter(final int i) {\n+        return a[i];\n+    }\n+\n+    /**\n+     * Reurns the certified values of the standard deviations of the parameters.\n+     *\n+     * @return the standard deviations of the parameters\n+     */\n+    public double[] getParametersStandardDeviations() {\n+        return MathArrays.copyOf(sigA);\n+    }\n+\n+    /**\n+     * Returns the certified value of the standard deviation of the {@code i}-th\n+     * parameter.\n+     *\n+     * @param i the index of the parameter\n+     * @return the standard deviation of the parameter\n+     */\n+    public double getParameterStandardDeviation(final int i) {\n+        return sigA[i];\n+    }\n+\n+    /**\n+     * Returns the certified value of the residual sum of squares.\n+     *\n+     * @return the residual sum of squares\n+     */\n+    public double getResidualSumOfSquares() {\n+        return residualSumOfSquares;\n+    }\n+\n+    /**\n+     * Returns the total number of starting points (initial guesses for the\n+     * optimization process).\n+     *\n+     * @return the number of starting points\n+     */\n+    public int getNumStartingPoints() {\n+        return numStartingPoints;\n+    }\n+\n+    /**\n+     * Returns the {@code i}-th set of initial values of the parameters.\n+     *\n+     * @param i the index of the starting point\n+     * @return the starting point\n+     */\n+    public double[] getStartingPoint(final int i) {\n+        return MathArrays.copyOf(startingValues[i]);\n+    }\n+\n+    /**\n+     * Returns the least-squares problem corresponding to fitting the model to\n+     * the specified data.\n+     *\n+     * @return the least-squares problem\n+     */\n+    public DifferentiableMultivariateVectorFunction getLeastSquaresProblem() {\n+        return problem;\n+    }\n+\n+    /**\n+     * Returns the value of the model for the specified values of the predictor\n+     * variable and the parameters.\n+     *\n+     * @param x the predictor variable\n+     * @param a the parameters\n+     * @return the value of the model\n+     */\n+    public abstract double getModelValue(final double x, final double[] a);\n+\n+    /**\n+     * Returns the values of the partial derivatives of the model with respect\n+     * to the parameters.\n+     *\n+     * @param x the predictor variable\n+     * @param a the parameters\n+     * @return the partial derivatives\n+     */\n+    public abstract double[] getModelDerivatives(final double x,\n+                                                 final double[] a);\n+\n+    /**\n+     * <p>\n+     * Parses the specified text lines, and extracts the indices of the first\n+     * and last lines of the data defined by the specified {@code key}. This key\n+     * must be one of\n+     * </p>\n+     * <ul>\n+     * <li>{@code \"Starting Values\"},</li>\n+     * <li>{@code \"Certified Values\"},</li>\n+     * <li>{@code \"Data\"}.</li>\n+     * </ul>\n+     * <p>\n+     * In the NIST data files, the line indices are separated by the keywords\n+     * {@code \"lines\"} and {@code \"to\"}.\n+     * </p>\n+     *\n+     * @param lines the line of text to be parsed\n+     * @return an array of two {@code int}s. First value is the index of the\n+     *         first line, second value is the index of the last line.\n+     *         {@code null} if the line could not be parsed.\n+     */\n+    private static int[] findLineNumbers(final String key,\n+                                         final Iterable<String> lines) {\n+        for (String text : lines) {\n+            boolean flag = text.contains(key) && text.contains(\"lines\") &&\n+                           text.contains(\"to\") && text.contains(\")\");\n+            if (flag) {\n+                final int[] numbers = new int[2];\n+                final String from = text.substring(text.indexOf(\"lines\") + 5,\n+                                                   text.indexOf(\"to\"));\n+                numbers[0] = Integer.parseInt(from.trim());\n+                final String to = text.substring(text.indexOf(\"to\") + 2,\n+                                                 text.indexOf(\")\"));\n+                numbers[1] = Integer.parseInt(to.trim());\n+                return numbers;\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/optimization/general/StatisticalReferenceDatasetFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.optimization.general;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * A factory to create instances of {@link StatisticalReferenceDataset} from\n+ * available resources.\n+ */\n+public class StatisticalReferenceDatasetFactory {\n+\n+    private StatisticalReferenceDatasetFactory() {\n+        // Do nothing\n+    }\n+\n+    /**\n+     * Creates a new buffered reader from the specified resource name.\n+     *\n+     * @param name the name of the resource\n+     * @return a buffered reader\n+     * @throws IOException if an I/O error occured\n+     */\n+    public static BufferedReader createBufferedReaderFromResource(final String name)\n+        throws IOException {\n+        final InputStream resourceAsStream;\n+        resourceAsStream = StatisticalReferenceDatasetFactory.class\n+            .getResourceAsStream(name);\n+        if (resourceAsStream == null) {\n+            throw new IOException(\"could not find resource \" + name);\n+        }\n+        return new BufferedReader(new InputStreamReader(resourceAsStream));\n+    }\n+\n+    public static StatisticalReferenceDataset createKirby2()\n+        throws IOException {\n+        final BufferedReader in = createBufferedReaderFromResource(\"Kirby2.dat\");\n+        StatisticalReferenceDataset dataset = null;\n+        try {\n+            dataset = new StatisticalReferenceDataset(in) {\n+\n+                @Override\n+                public double getModelValue(final double x, final double[] a) {\n+                    final double p = a[0] + x * (a[1] + x * a[2]);\n+                    final double q = 1.0 + x * (a[3] + x * a[4]);\n+                    return p / q;\n+                }\n+\n+                @Override\n+                public double[] getModelDerivatives(final double x,\n+                                                    final double[] a) {\n+                    final double[] dy = new double[5];\n+                    final double p = a[0] + x * (a[1] + x * a[2]);\n+                    final double q = 1.0 + x * (a[3] + x * a[4]);\n+                    dy[0] = 1.0 / q;\n+                    dy[1] = x / q;\n+                    dy[2] = x * dy[1];\n+                    dy[3] = -x * p / (q * q);\n+                    dy[4] = x * dy[3];\n+                    return dy;\n+                }\n+            };\n+        } finally {\n+            in.close();\n+        }\n+        return dataset;\n+    }\n+\n+    public static StatisticalReferenceDataset createHahn1()\n+        throws IOException {\n+        final BufferedReader in = createBufferedReaderFromResource(\"Hahn1.dat\");\n+        StatisticalReferenceDataset dataset = null;\n+        try {\n+            dataset = new StatisticalReferenceDataset(in) {\n+\n+                @Override\n+                public double getModelValue(final double x, final double[] a) {\n+                    final double p = a[0] + x * (a[1] + x * (a[2] + x * a[3]));\n+                    final double q = 1.0 + x * (a[4] + x * (a[5] + x * a[6]));\n+                    return p / q;\n+                }\n+\n+                @Override\n+                public double[] getModelDerivatives(final double x,\n+                                                    final double[] a) {\n+                    final double[] dy = new double[7];\n+                    final double p = a[0] + x * (a[1] + x * (a[2] + x * a[3]));\n+                    final double q = 1.0 + x * (a[4] + x * (a[5] + x * a[6]));\n+                    dy[0] = 1.0 / q;\n+                    dy[1] = x * dy[0];\n+                    dy[2] = x * dy[1];\n+                    dy[3] = x * dy[2];\n+                    dy[4] = -x * p / (q * q);\n+                    dy[5] = x * dy[4];\n+                    dy[6] = x * dy[5];\n+                    return dy;\n+                }\n+            };\n+        } finally {\n+            in.close();\n+        }\n+        return dataset;\n+    }\n+\n+    public static StatisticalReferenceDataset createMGH17()\n+        throws IOException {\n+        final BufferedReader in = createBufferedReaderFromResource(\"MGH17.dat\");\n+        StatisticalReferenceDataset dataset = null;\n+        try {\n+            dataset = new StatisticalReferenceDataset(in) {\n+\n+                @Override\n+                public double getModelValue(final double x, final double[] a) {\n+                    return a[0] + a[1] * FastMath.exp(-a[3] * x) + a[2] *\n+                           FastMath.exp(-a[4] * x);\n+                }\n+\n+                @Override\n+                public double[] getModelDerivatives(final double x,\n+                                                    final double[] a) {\n+                    final double[] dy = new double[5];\n+                    dy[0] = 1.0;\n+                    dy[1] = FastMath.exp(-x * a[3]);\n+                    dy[2] = FastMath.exp(-x * a[4]);\n+                    dy[3] = -x * a[1] * dy[1];\n+                    dy[4] = -x * a[2] * dy[2];\n+                    return dy;\n+                }\n+            };\n+        } finally {\n+            in.close();\n+        }\n+        return dataset;\n+    }\n+\n+    /**\n+     * Returns an array with all available reference datasets.\n+     *\n+     * @return the array of datasets\n+     * @throws IOException if an I/O error occurs\n+     */\n+    public StatisticalReferenceDataset[] createAll()\n+        throws IOException {\n+        return new StatisticalReferenceDataset[] {\n+            createKirby2(), createMGH17()\n+        };\n+    }\n+}", "timestamp": 1335771718, "metainfo": ""}