{"sha": "9be0992c0d829f45d0473127efdceda3c54a317d", "log": "MATH-454 Pass the number of allowed function evaluations as a parameter to the \"optimize\" methods.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateRealOptimizer.java\n \n     /**\n      * Get all the optima found during the last call to {@link\n-     * #optimize(MultivariateRealFunction,GoalType,double[]) optimize}.\n+     * #optimize(int,MultivariateRealFunction,GoalType,double[]) optimize}.\n      * The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(MultivariateRealFunction,GoalType,double[])\n+     * restarts. The {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n      * optimize} method returns the best point only. This method\n      * returns all the points found at the end of each starts,\n      * including the best one already returned by the {@link\n-     * #optimize(MultivariateRealFunction,GoalType,double[]) optimize} method.\n+     * #optimize(int,MultivariateRealFunction,GoalType,double[]) optimize} method.\n      * <br/>\n      * The returned array as one element for each start as specified\n      * in the constructor. It is ordered with the results from the\n      * objective value (i.e in ascending order if minimizing and in\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n-     * elements will be null if the {@link #optimize(MultivariateRealFunction,GoalType,double[])\n+     * elements will be null if the {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n      * optimize} method did throw a {@link MathUserException}).\n      * This also means that if the first element is not {@code null}, it\n      * is the best point found across all starts.\n      *\n      * @return an array containing the optima.\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(MultivariateRealFunction,GoalType,double[]) optimize}\n+     * #optimize(int,MultivariateRealFunction,GoalType,double[]) optimize}\n      * has not been called.\n      */\n     public RealPointValuePair[] getOptima() {\n     }\n \n     /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-        optimizer.setMaxEvaluations(maxEvaluations);\n-    }\n-\n-    /** {@inheritDoc} */\n     public void setConvergenceChecker(ConvergenceChecker<RealPointValuePair> checker) {\n         optimizer.setConvergenceChecker(checker);\n     }\n     /**\n      * {@inheritDoc}\n      */\n-    public RealPointValuePair optimize(final FUNC f,\n+    public RealPointValuePair optimize(int maxEval, final FUNC f,\n                                        final GoalType goal,\n-                                       double[] startPoint) throws MathUserException {\n+                                       double[] startPoint) {\n+        maxEvaluations = maxEval;\n         MathUserException lastException = null;\n         optima = new RealPointValuePair[starts];\n         totalEvaluations = 0;\n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n             try {\n-                optima[i] = optimizer.optimize(f, goal,\n+                optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal,\n                                                i == 0 ? startPoint : generator.nextVector());\n             } catch (MathUserException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n             }\n \n-            final int usedEvaluations = optimizer.getEvaluations();\n-            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n-            totalEvaluations += usedEvaluations;\n+            totalEvaluations += optimizer.getEvaluations();\n         }\n \n         sortPairs(goal);\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultiStartMultivariateVectorialOptimizer.java\n \n     /**\n      * Get all the optima found during the last call to {@link\n-     * #optimize(MultivariateVectorialFunction,double[],double[],double[]) optimize}.\n+     * #optimize(int,MultivariateVectorialFunction,double[],double[],double[]) optimize}.\n      * The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(MultivariateVectorialFunction,double[],double[],double[])\n+     * restarts. The {@link #optimize(int,MultivariateVectorialFunction,double[],double[],double[])\n      * optimize} method returns the best point only. This method\n      * returns all the points found at the end of each starts, including\n      * the best one already returned by the {@link\n-     * #optimize(MultivariateVectorialFunction,double[],double[],double[]) optimize} method.\n+     * #optimize(int,MultivariateVectorialFunction,double[],double[],double[]) optimize} method.\n      * <br/>\n      * The returned array as one element for each start as specified\n      * in the constructor. It is ordered with the results from the\n      * descending order if maximizing), followed by and null elements\n      * corresponding to the runs that did not converge. This means all\n      * elements will be null if the {@link\n-     * #optimize(MultivariateVectorialFunction,double[],double[],double[]) optimize} method did\n+     * #optimize(int,MultivariateVectorialFunction,double[],double[],double[]) optimize} method did\n      * throw a {@link ConvergenceException}). This also means that if\n      * the first element is not {@code null}, it is the best point found\n      * across all starts.\n      *\n      * @return array containing the optima\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(MultivariateVectorialFunction,double[],double[],double[]) optimize} has not been\n+     * #optimize(int,MultivariateVectorialFunction,double[],double[],double[]) optimize} has not been\n      * called.\n      */\n     public VectorialPointValuePair[] getOptima() {\n     }\n \n     /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-        optimizer.setMaxEvaluations(maxEvaluations);\n-    }\n-\n-    /** {@inheritDoc} */\n     public void setConvergenceChecker(ConvergenceChecker<VectorialPointValuePair> checker) {\n         optimizer.setConvergenceChecker(checker);\n     }\n     /**\n      * {@inheritDoc}\n      */\n-    public VectorialPointValuePair optimize(final FUNC f,\n+    public VectorialPointValuePair optimize(int maxEval, final FUNC f,\n                                             double[] target, double[] weights,\n-                                            double[] startPoint)\n-        throws MathUserException {\n-\n+                                            double[] startPoint) {\n+        maxEvaluations = maxEval;\n         MathUserException lastException = null;\n         optima = new VectorialPointValuePair[starts];\n+        totalEvaluations = 0;\n \n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n \n             try {\n-                optima[i] = optimizer.optimize(f, target, weights,\n+                optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, target, weights,\n                                                i == 0 ? startPoint : generator.nextVector());\n             } catch (MathUserException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n             }\n \n-            final int usedEvaluations = optimizer.getEvaluations();\n-            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n-            totalEvaluations += usedEvaluations;\n+            totalEvaluations += optimizer.getEvaluations();\n         }\n \n         sortPairs(target, weights);\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n      * @param goalType Type of optimization goal: either\n      * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n      * @param startPoint Start point for optimization.\n+     * @param maxEval Maximum number of function evaluations.\n      * @return the point/value pair giving the optimal value for objective\n      * function.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n-     * @throws MathUserException if objective function throws one during search\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * objective function throws one during search.\n      */\n-    RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint) throws MathUserException;\n+    RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                double[] startPoint);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n package org.apache.commons.math.optimization;\n \n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n-import org.apache.commons.math.exception.MathUserException;\n \n /**\n  * This interface is mainly intended to enforce the internal coherence of\n      * @param startPoint Start point for optimization.\n      * @return the point/value pair giving the optimal value for objective\n      * function.\n+     * @param maxEval Maximum number of function evaluations.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n-     * @throws MathUserException if function throws one during search.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * function throws one during search.\n      */\n-    VectorialPointValuePair optimize(FUNC f, double[] target, double[] weight,\n-                                     double[] startPoint) throws MathUserException;\n+    VectorialPointValuePair optimize(int maxEval, FUNC f, double[] target,\n+                                     double[] weight, double[] startPoint);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseOptimizer.java\n  */\n public interface BaseOptimizer<PAIR> {\n     /**\n-     * Set the maximal number of function evaluations.\n-     *\n-     * @param maxEvaluations Maximal number of function evaluations.\n-     */\n-    void setMaxEvaluations(int maxEvaluations);\n-\n-    /**\n      * Get the maximal number of function evaluations.\n      *\n      * @return the maximal number of function evaluations.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n      * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      */\n     protected BaseAbstractScalarOptimizer() {\n-        this(new SimpleScalarValueChecker(), Integer.MAX_VALUE);\n+        this(new SimpleScalarValueChecker());\n     }\n     /**\n      * @param checker Convergence checker.\n-     * @param maxEvaluations Maximum number of function evaluations.\n      */\n-    protected BaseAbstractScalarOptimizer(ConvergenceChecker<RealPointValuePair> checker,\n-                                          int maxEvaluations) {\n+    protected BaseAbstractScalarOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n         this.checker = checker;\n-        evaluations.setMaximalCount(maxEvaluations);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        evaluations.setMaximalCount(maxEvaluations);\n     }\n \n     /** {@inheritDoc} */\n      * @return the objective function value at the specified point.\n      * @throws TooManyEvaluationsException if the maximal number of\n      * evaluations is exceeded.\n-     * @throws MathUserException if objective function throws one\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * objective function throws one.\n      */\n-    protected double computeObjectiveValue(double[] point) throws MathUserException {\n+    protected double computeObjectiveValue(double[] point) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     }\n \n     /** {@inheritDoc} */\n-    public RealPointValuePair optimize(FUNC f,\n-                                       GoalType goalType,\n-                                       double[] startPoint) throws MathUserException {\n+    public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                       double[] startPoint) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n         }\n \n         // Reset.\n+        evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n \n         // Store optimization problem characteristics.\n     /**\n      * Perform the bulk of the optimization algorithm.\n      *\n-     * @return the point/value pair giving the optimal value for objective function.\n-     * @throws MathUserException if objective function throws one\n+     * @return the point/value pair giving the optimal value for the\n+     * objective function.\n+     * @throws org.apache.commons.math.exception.MathUserException if\n+     * the objective function throws one.\n      */\n-    protected abstract RealPointValuePair doOptimize() throws MathUserException;\n+    protected abstract RealPointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n      * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      */\n     protected BaseAbstractVectorialOptimizer() {\n-        this(new SimpleVectorialValueChecker(),  Integer.MAX_VALUE);\n+        this(new SimpleVectorialValueChecker());\n     }\n     /**\n      * @param checker Convergence checker.\n-     * @param maxEvaluations Maximum number of function evaluations.\n      */\n-    protected BaseAbstractVectorialOptimizer(ConvergenceChecker<VectorialPointValuePair> checker,\n-                                             int maxEvaluations) {\n+    protected BaseAbstractVectorialOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n         this.checker = checker;\n-        evaluations.setMaximalCount(maxEvaluations);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        evaluations.setMaximalCount(maxEvaluations);\n     }\n \n     /** {@inheritDoc} */\n      * @return the objective function value at the specified point.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n-     * @throws MathUserException if objective function throws one\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * objective function throws one.\n      */\n-    protected double[] computeObjectiveValue(double[] point) throws MathUserException {\n+    protected double[] computeObjectiveValue(double[] point) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     }\n \n     /** {@inheritDoc} */\n-    public VectorialPointValuePair optimize(FUNC f, double[] t, double[] w, double[] startPoint)\n-        throws MathUserException {\n+    public VectorialPointValuePair optimize(int maxEval, FUNC f, double[] t, double[] w,\n+                                            double[] startPoint) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n         }\n \n         // Reset.\n+        evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n \n         // Store optimization problem characteristics.\n     /**\n      * Perform the bulk of the optimization algorithm.\n      *\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @throws MathUserException if function throws one during search.\n+     * @return the point/value pair giving the optimal value for the\n+     * objective function.\n+     * @throws org.apache.commons.math.exception.MathUserException if\n+     * the function throws one during search.\n      */\n-    protected abstract VectorialPointValuePair doOptimize() throws MathUserException;\n+    protected abstract VectorialPointValuePair doOptimize();\n \n     /**\n      * @return a reference to the {@link #target array}.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.optimization.GoalType;\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        super.setMaxEvaluations(maxEvaluations);\n-\n-        // We must allow at least as many iterations to the underlying line\n-        // search optimizer. Because the line search inner class will call\n-        // \"computeObjectiveValue\" in this class, we ensure that this class\n-        // will be the first to eventually throw \"TooManyEvaluationsException\".\n-        line.setMaxEvaluations(maxEvaluations);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    protected RealPointValuePair doOptimize() throws MathUserException {\n+    protected RealPointValuePair doOptimize() {\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n          * @return the optimum.\n          * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n          * if the number of evaluations is exceeded.\n-         * @throws MathUserException if objective function throws one.\n+         * @throws org.apache.commons.math.exception.MathUserException if the\n+         * objective function throws one.\n          */\n-        public UnivariateRealPointValuePair search(final double[] p, final double[] d)\n-            throws MathUserException {\n+        public UnivariateRealPointValuePair search(final double[] p, final double[] d) {\n             final int n = p.length;\n             final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                    public double value(double alpha) throws MathUserException {\n+                    public double value(double alpha) {\n                         final double[] x = new double[n];\n                         for (int i = 0; i < n; i++) {\n                             x[i] = p[i] + alpha * d[i];\n \n             final GoalType goal = PowellOptimizer.this.getGoalType();\n             bracket.search(f, goal, 0, 1);\n-            return optimize(f, goal, bracket.getLo(), bracket.getHi(),\n-                            bracket.getMid());\n+            // Passing \"MAX_VALUE\" as a dummy value because it is the enclosing\n+            // class that counts the number of evaluations (and will eventually\n+            // generate the exception).\n+            return optimize(Integer.MAX_VALUE, f, goal,\n+                            bracket.getLo(), bracket.getHi(), bracket.getMid());\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n  *  be called prior to calling the {@code optimize} method.\n  * </p>\n  * <p>\n- *  Each call to {@link #optimize(MultivariateRealFunction,GoalType,double[])\n+ *  Each call to {@link #optimize(int,MultivariateRealFunction,GoalType,double[])\n  *  optimize} will re-use the start configuration of the current simplex and\n  *  move it such that its first vertex is at the provided start point of the\n  *  optimization. If the {@code optimize} method is called to solve a different\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n  * @since 2.0\n  */\n public class CurveFitter {\n-\n     /** Optimizer to use for the fitting. */\n     private final DifferentiableMultivariateVectorialOptimizer optimizer;\n-\n     /** Observed points. */\n     private final List<WeightedObservedPoint> observations;\n \n         observations.clear();\n     }\n \n-    /** Fit a curve.\n-     * <p>This method compute the coefficients of the curve that best\n+    /**\n+     * Fit a curve.\n+     * This method compute the coefficients of the curve that best\n      * fit the sample of observed points previously given through calls\n      * to the {@link #addObservedPoint(WeightedObservedPoint)\n-     * addObservedPoint} method.</p>\n-     * @param f parametric function to fit\n-     * @param initialGuess first guess of the function parameters\n-     * @return fitted parameters\n-     * @exception org.apache.commons.math.exception.ConvergenceException\n-     * if the algorithm failed to converge.\n-     * @exception org.apache.commons.math.exception.DimensionMismatchException\n+     * addObservedPoint} method.\n+     *\n+     * @param f parametric function to fit.\n+     * @param initialGuess first guess of the function parameters.\n+     * @return the fitted parameters.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n-     * @throws MathUserException if the parametric function throws one\n-     */\n-    public double[] fit(final ParametricRealFunction f,\n-                        final double[] initialGuess) throws MathUserException {\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * parametric function throws one.\n+     */\n+    public double[] fit(final ParametricRealFunction f, final double[] initialGuess) {\n+        return fit(Integer.MAX_VALUE, f, initialGuess);\n+    }\n+\n+    /**\n+     * Fit a curve.\n+     * This method compute the coefficients of the curve that best\n+     * fit the sample of observed points previously given through calls\n+     * to the {@link #addObservedPoint(WeightedObservedPoint)\n+     * addObservedPoint} method.\n+     *\n+     * @param f parametric function to fit.\n+     * @param initialGuess first guess of the function parameters.\n+     * @param maxEval Maximum number of function evaluations.\n+     * @return the fitted parameters.\n+     * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n+     * if the number of allowed evaluations is exceeded.\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the start point dimension is wrong.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * parametric function throws one.\n+     */\n+    public double[] fit(int maxEval, final ParametricRealFunction f,\n+                        final double[] initialGuess) {\n         // prepare least squares problem\n         double[] target  = new double[observations.size()];\n         double[] weights = new double[observations.size()];\n \n         // perform the fit\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(new TheoreticalValuesFunction(f), target, weights, initialGuess);\n+            optimizer.optimize(maxEval, new TheoreticalValuesFunction(f),\n+                               target, weights, initialGuess);\n \n         // extract the coefficients\n         return optimum.getPointRef();\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     protected AbstractLeastSquaresOptimizer() {}\n     /**\n      * @param checker Convergence checker.\n-     * @param maxEvaluations Maximal number of function evaluations.\n-     */\n-    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<VectorialPointValuePair> checker,\n-                                            int maxEvaluations) {\n-        super(checker, maxEvaluations);\n+     */\n+    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<VectorialPointValuePair> checker) {\n+        super(checker);\n     }\n \n     /**\n \n     /** {@inheritDoc} */\n     @Override\n-    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n+    public VectorialPointValuePair optimize(int maxEval,\n+                                            final DifferentiableMultivariateVectorialFunction f,\n                                             final double[] target, final double[] weights,\n                                             final double[] startPoint) {\n         // Reset counter.\n \n         cost = Double.POSITIVE_INFINITY;\n \n-        return super.optimize(f, target, weights, startPoint);\n+        return super.optimize(maxEval, f, target, weights, startPoint);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n     protected AbstractScalarDifferentiableOptimizer() {}\n     /**\n      * @param checker Convergence checker.\n-     * @param maxEvaluations Maximum number of function evaluations.\n      */\n-    protected AbstractScalarDifferentiableOptimizer(ConvergenceChecker<RealPointValuePair> checker,\n-                                                    int maxEvaluations) {\n-        super(checker, maxEvaluations);\n+    protected AbstractScalarDifferentiableOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\n+        super(checker);\n     }\n \n     /**\n \n     /** {@inheritDoc} */\n     @Override\n-    public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n+    public RealPointValuePair optimize(int maxEval,\n+                                       final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n                                        final double[] startPoint) throws MathUserException {\n         // Store optimization problem characteristics.\n         gradient = f.gradient();\n \n-        return super.optimize(f, goalType, startPoint);\n+        return super.optimize(maxEval, f, goalType, startPoint);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.NullArgumentException;\n     private double searchStart;\n     /** Function to optimize. */\n     private UnivariateRealFunction function;\n-\n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        evaluations.setMaximalCount(maxEvaluations);\n-    }\n \n     /** {@inheritDoc} */\n     public int getMaxEvaluations() {\n      * @return the objective function value at specified point.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n-     * @throws MathUserException if objective function throws one\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * objective function throws one.\n      */\n-    protected double computeObjectiveValue(double point) throws MathUserException {\n+    protected double computeObjectiveValue(double point) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n+    public UnivariateRealPointValuePair optimize(int maxEval, UnivariateRealFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max,\n-                                                 double startValue) throws MathUserException {\n+                                                 double startValue) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n         searchStart = startValue;\n         goal = goalType;\n         function = f;\n+        evaluations.setMaximalCount(maxEval);\n         evaluations.resetCount();\n \n         // Perform computation.\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n+    public UnivariateRealPointValuePair optimize(int maxEval,\n+                                                 UnivariateRealFunction f,\n                                                  GoalType goalType,\n-                                                 double min, double max) throws MathUserException {\n-        return optimize(f, goalType, min, max, min + 0.5 * (max - min));\n+                                                 double min, double max){\n+        return optimize(maxEval, f, goalType, min, max, min + 0.5 * (max - min));\n     }\n \n     /**\n      * @return the optimum and its corresponding function value.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n-     * @throws MathUserException if the function to optimize throws one during search.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * function to optimize throws one during search.\n      */\n-    protected abstract UnivariateRealPointValuePair doOptimize() throws MathUserException;\n+    protected abstract UnivariateRealPointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n package org.apache.commons.math.optimization.univariate;\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.BaseOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n \n      * {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n+     * @param maxEval Maximum number of function evaluations.\n      * @return a (point, value) pair where the function is optimum.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximum evaluation count is exceeded.\n      * if the optimizer detects a convergence problem.\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n-     * @throws MathUserException if the function to optimize throws one during search.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * function to optimize throws one during search.\n      */\n-    UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n-                                          double min, double max) throws MathUserException;\n+    UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n+                                          double min, double max);\n \n     /**\n      * Find an optimum in the given interval, start at startValue.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n+     * @param maxEval Maximum number of function evaluations.\n      * @return a (point, value) pair where the function is optimum.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximum evaluation count is exceeded.\n      * do not satisfy the requirements specified by the optimizer.\n      * @throws org.apache.commons.math.exception.NullArgumentException if any\n      * argument is {@code null}.\n-     * @throws MathUserException if the function to optimize throws one during search.\n+     * @throws org.apache.commons.math.exception.MathUserException if the\n+     * function to optimize throws one during search.\n      */\n-    UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n+    UnivariateRealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n                                           double min, double max,\n-                                          double startValue) throws MathUserException;\n+                                          double startValue);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n         return totalEvaluations;\n     }\n \n-    /** {@inheritDoc} */\n-    public void setMaxEvaluations(int maxEvaluations) {\n-        this.maxEvaluations = maxEvaluations;\n-        optimizer.setMaxEvaluations(maxEvaluations);\n-    }\n-\n     /**\n      * Get all the optima found during the last call to {@link\n-     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize}.\n+     * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}.\n      * The optimizer stores all the optima found during a set of\n-     * restarts. The {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize}\n+     * restarts. The {@link #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n      * method returns the best point only. This method returns all the points\n      * found at the end of each starts, including the best one already\n-     * returned by the {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize}\n+     * returned by the {@link #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n      * method.\n      * <br/>\n      * The returned array as one element for each start as specified\n      * descending order if maximizing), followed by {@code null} elements\n      * corresponding to the runs that did not converge. This means all\n      * elements will be {@code null} if the {@link\n-     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize}\n-     * method did throw a {@link MathUserException}). This also means that\n-     * if the first element is not {@code null}, it is the best point found\n-     * across all starts.\n+     * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n+     * method did throw a {@link MathUserException}).\n+     * This also means that if the first element is not {@code null}, it is\n+     * the best point found across all starts.\n      *\n      * @return an array containing the optima.\n      * @throws MathIllegalStateException if {@link\n-     * #optimize(UnivariateRealFunction,GoalType,double,double) optimize}\n+     * #optimize(int,UnivariateRealFunction,GoalType,double,double) optimize}\n      * has not been called.\n      */\n     public UnivariateRealPointValuePair[] getOptima() {\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(final FUNC f,\n+    public UnivariateRealPointValuePair optimize(int maxEval, final FUNC f,\n                                                  final GoalType goal,\n-                                                 final double min, final double max)\n-        throws MathUserException {\n-        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+                                                 final double min, final double max) {\n+        return optimize(maxEval, f, goal, min, max, min + 0.5 * (max - min));\n     }\n \n     /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n+    public UnivariateRealPointValuePair optimize(int maxEval, final FUNC f,\n+                                                 final GoalType goal,\n                                                  final double min, final double max,\n-                                                 final double startValue)\n-        throws MathUserException {\n+                                                 final double startValue) {\n         MathUserException lastException = null;\n         optima = new UnivariateRealPointValuePair[starts];\n         totalEvaluations = 0;\n         for (int i = 0; i < starts; ++i) {\n             try {\n                 final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, min, max, s);\n+                optima[i] = optimizer.optimize(maxEval - totalEvaluations, f, goal, min, max, s);\n             } catch (MathUserException mue) {\n                 lastException = mue;\n                 optima[i] = null;\n             }\n \n-            final int usedEvaluations = optimizer.getEvaluations();\n-            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n-            totalEvaluations += usedEvaluations;\n+            totalEvaluations += optimizer.getEvaluations();\n         }\n \n         sortPairs(goal);\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizerTest.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.analysis.solvers.BrentSolver;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.general.ConjugateGradientFormula;\n import org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer;\n import org.apache.commons.math.random.GaussianRandomGenerator;\n public class MultiStartDifferentiableMultivariateRealOptimizerTest {\n \n     @Test\n-    public void testCircleFitting() throws MathUserException {\n+    public void testCircleFitting() {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n                                                   new GaussianRandomGenerator(g));\n         MultiStartDifferentiableMultivariateRealOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateRealOptimizer(underlying, 10, generator);\n-        optimizer.setMaxEvaluations(200);\n-        assertEquals(200, optimizer.getMaxEvaluations());\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n         BrentSolver solver = new BrentSolver();\n         RealPointValuePair optimum =\n-            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+            optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+        assertEquals(200, optimizer.getMaxEvaluations());\n         RealPointValuePair[] optima = optimizer.getOptima();\n         for (RealPointValuePair o : optima) {\n             Point2D.Double center = new Point2D.Double(o.getPointRef()[0], o.getPointRef()[1]);\n             return new double[] { dJdX, dJdY };\n         }\n \n-        public double value(double[] variables)\n-        throws IllegalArgumentException, MathUserException {\n+        public double value(double[] variables) {\n \n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n             double radius = getRadius(center);\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n public class MultiStartDifferentiableMultivariateVectorialOptimizerTest {\n \n     @Test\n-    public void testTrivial() throws MathUserException {\n+    public void testTrivial() {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n         MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n                                                                        10, generator);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n \n         // no optima before first optimization attempt\n             // expected\n         }\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n         VectorialPointValuePair[] optima = optimizer.getOptima();\n     }\n \n     @Test(expected = MathUserException.class)\n-    public void testNoOptimum() throws MathUserException {\n+    public void testNoOptimum() {\n         DifferentiableMultivariateVectorialOptimizer underlyingOptimizer =\n             new GaussNewtonOptimizer(true);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         MultiStartDifferentiableMultivariateVectorialOptimizer optimizer =\n             new MultiStartDifferentiableMultivariateVectorialOptimizer(underlyingOptimizer,\n                                                                        10, generator);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        optimizer.optimize(new DifferentiableMultivariateVectorialFunction() {\n+        optimizer.optimize(100, new DifferentiableMultivariateVectorialFunction() {\n                 public MultivariateMatrixFunction jacobian() {\n                     return null;\n                 }\n-                public double[] value(double[] point) throws MathUserException {\n+                public double[] value(double[] point) {\n                     throw new MathUserException();\n                 }\n             }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 });\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizerTest.java\n         MultiStartMultivariateRealOptimizer optimizer =\n             new MultiStartMultivariateRealOptimizer(underlying, 10, generator);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(-1, 1.0e-3));\n-        optimizer.setMaxEvaluations(1100);\n         RealPointValuePair optimum =\n-            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n+            optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 });\n \n         assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n         assertTrue(optimizer.getEvaluations() > 900);\n--- a/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/PowellOptimizerTest.java\n                         double fTol,\n                         double pointTol) {\n         final MultivariateRealOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d));\n-        optim.setMaxEvaluations(1000);\n \n-        final RealPointValuePair result = optim.optimize(func, goal, init);\n+        final RealPointValuePair result = optim.optimize(1000, func, goal, init);\n         final double[] found = result.getPoint();\n \n         for (int i = 0, dim = optimum.length; i < dim; i++) {\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n package org.apache.commons.math.optimization.direct;\n \n import org.apache.commons.math.analysis.MultivariateRealFunction;\n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n public class SimplexOptimizerMultiDirectionalTest {\n     @Test\n-    public void testMinimizeMaximize() throws MathUserException {\n+    public void testMinimizeMaximize() {\n         // the following function has 4 local extrema:\n         final double xM        = -3.841947088256863675365;\n         final double yM        = -1.391745200270734924416;\n         final double valueXpYp = -valueXpYm;                // global maximum\n         MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -7039124064449091152L;\n-                public double value(double[] variables) throws MathUserException {\n+                public double value(double[] variables) {\n                     final double x = variables[0];\n                     final double y = variables[1];\n                     return ((x == 0) || (y == 0)) ? 0 :\n             };\n \n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30);\n-        optimizer.setMaxEvaluations(200);\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n         RealPointValuePair optimum;\n \n         // minimization\n-        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n+        optimum = optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n         Assert.assertEquals(xM,        optimum.getPoint()[0], 4e-6);\n         Assert.assertEquals(yP,        optimum.getPoint()[1], 3e-6);\n         Assert.assertEquals(valueXmYp, optimum.getValue(),    8e-13);\n         Assert.assertTrue(optimizer.getEvaluations() > 120);\n         Assert.assertTrue(optimizer.getEvaluations() < 150);\n \n-        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n+        optimum = optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n         Assert.assertEquals(xP,        optimum.getPoint()[0], 2e-8);\n         Assert.assertEquals(yM,        optimum.getPoint()[1], 3e-6);\n         Assert.assertEquals(valueXpYm, optimum.getValue(),    2e-12);\n         Assert.assertTrue(optimizer.getEvaluations() < 150);\n \n         // maximization\n-        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n+        optimum = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n         Assert.assertEquals(xM,        optimum.getPoint()[0], 7e-7);\n         Assert.assertEquals(yM,        optimum.getPoint()[1], 3e-7);\n         Assert.assertEquals(valueXmYm, optimum.getValue(),    2e-14);\n         Assert.assertTrue(optimizer.getEvaluations() < 150);\n \n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1e-15, 1e-30));\n-        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n+        optimum = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n         Assert.assertEquals(xP,        optimum.getPoint()[0], 2e-8);\n         Assert.assertEquals(yP,        optimum.getPoint()[1], 3e-6);\n         Assert.assertEquals(valueXpYp, optimum.getValue(),    2e-12);\n     }\n \n     @Test\n-    public void testRosenbrock() throws MathUserException {\n+    public void testRosenbrock() {\n         MultivariateRealFunction rosenbrock =\n             new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -9044950469615237490L;\n-                public double value(double[] x) throws MathUserException {\n+                public double value(double[] x) {\n                     ++count;\n                     double a = x[1] - x[0] * x[0];\n                     double b = 1.0 - x[0];\n \n         count = 0;\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[][] {\n                     { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n                 }));\n         RealPointValuePair optimum =\n-            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n+            optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n \n         Assert.assertEquals(count, optimizer.getEvaluations());\n         Assert.assertTrue(optimizer.getEvaluations() > 50);\n     }\n \n     @Test\n-    public void testPowell() throws MathUserException {\n+    public void testPowell() {\n         MultivariateRealFunction powell =\n             new MultivariateRealFunction() {\n                 private static final long serialVersionUID = -832162886102041840L;\n-                public double value(double[] x) throws MathUserException {\n+                public double value(double[] x) {\n                     ++count;\n                     double a = x[0] + 10 * x[1];\n                     double b = x[2] - x[3];\n \n         count = 0;\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n-        optimizer.setMaxEvaluations(1000);\n         optimizer.setSimplex(new MultiDirectionalSimplex(4));\n         RealPointValuePair optimum =\n-            optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n+            optimizer.optimize(1000, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n         Assert.assertEquals(count, optimizer.getEvaluations());\n         Assert.assertTrue(optimizer.getEvaluations() > 800);\n         Assert.assertTrue(optimizer.getEvaluations() < 900);\n     }\n \n     @Test\n-    public void testMath283() throws MathUserException {\n+    public void testMath283() {\n         // fails because MultiDirectional.iterateSimplex is looping forever\n         // the while(true) should be replaced with a convergence check\n         SimplexOptimizer optimizer = new SimplexOptimizer();\n-        optimizer.setMaxEvaluations(1000);\n         optimizer.setSimplex(new MultiDirectionalSimplex(2));\n         final Gaussian2D function = new Gaussian2D(0, 0, 1);\n-        RealPointValuePair estimate = optimizer.optimize(function,\n+        RealPointValuePair estimate = optimizer.optimize(1000, function,\n                                                          GoalType.MAXIMIZE, function.getMaximumPosition());\n         final double EPSILON = 1e-5;\n         final double expectedMaximum = function.getMaximum();\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerNelderMeadTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n-import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n \n public class SimplexOptimizerNelderMeadTest {\n     @Test\n-    public void testMinimizeMaximize()\n-        throws MathUserException {\n+    public void testMinimizeMaximize() {\n \n         // the following function has 4 local extrema:\n         final double xM        = -3.841947088256863675365;\n             };\n \n         SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 }));\n         RealPointValuePair optimum;\n \n         // minimization\n-        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n+        optimum = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 });\n         assertEquals(xM,        optimum.getPoint()[0], 2e-7);\n         assertEquals(yP,        optimum.getPoint()[1], 2e-5);\n         assertEquals(valueXmYp, optimum.getValue(),    6e-12);\n         assertTrue(optimizer.getEvaluations() > 60);\n         assertTrue(optimizer.getEvaluations() < 90);\n \n-        optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n+        optimum = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 });\n         assertEquals(xP,        optimum.getPoint()[0], 5e-6);\n         assertEquals(yM,        optimum.getPoint()[1], 6e-6);\n         assertEquals(valueXpYm, optimum.getValue(),    1e-11);\n         assertTrue(optimizer.getEvaluations() < 90);\n \n         // maximization\n-        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 });\n+        optimum = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 });\n         assertEquals(xM,        optimum.getPoint()[0], 1e-5);\n         assertEquals(yM,        optimum.getPoint()[1], 3e-6);\n         assertEquals(valueXmYm, optimum.getValue(),    3e-12);\n         assertTrue(optimizer.getEvaluations() > 60);\n         assertTrue(optimizer.getEvaluations() < 90);\n \n-        optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n+        optimum = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 });\n         assertEquals(xP,        optimum.getPoint()[0], 4e-6);\n         assertEquals(yP,        optimum.getPoint()[1], 5e-6);\n         assertEquals(valueXpYp, optimum.getValue(),    7e-12);\n     }\n \n     @Test\n-    public void testRosenbrock()\n-        throws MathUserException {\n+    public void testRosenbrock() {\n \n         Rosenbrock rosenbrock = new Rosenbrock();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n                     { -1.2,  1 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n                 }));\n         RealPointValuePair optimum =\n-            optimizer.optimize(rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n+            optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 });\n \n         assertEquals(rosenbrock.getCount(), optimizer.getEvaluations());\n         assertTrue(optimizer.getEvaluations() > 40);\n     }\n \n     @Test\n-    public void testPowell()\n-        throws MathUserException {\n+    public void testPowell() {\n \n         Powell powell = new Powell();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n-        optimizer.setMaxEvaluations(200);\n         optimizer.setSimplex(new NelderMeadSimplex(4));\n         RealPointValuePair optimum =\n-            optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n+            optimizer.optimize(200, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n         assertEquals(powell.getCount(), optimizer.getEvaluations());\n         assertTrue(optimizer.getEvaluations() > 110);\n         assertTrue(optimizer.getEvaluations() < 130);\n     }\n \n     @Test\n-    public void testLeastSquares1()\n-        throws MathUserException {\n+    public void testLeastSquares1() {\n \n         final RealMatrix factors =\n             new Array2DRowRealMatrix(new double[][] {\n                 }\n             }, new double[] { 2.0, -3.0 });\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n-        optimizer.setMaxEvaluations(200);\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n         RealPointValuePair optimum =\n-            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n+            optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n         assertEquals( 2, optimum.getPointRef()[0], 3e-5);\n         assertEquals(-3, optimum.getPointRef()[1], 4e-4);\n         assertTrue(optimizer.getEvaluations() > 60);\n     }\n \n     @Test\n-    public void testLeastSquares2()\n-        throws MathUserException {\n+    public void testLeastSquares2() {\n \n         final RealMatrix factors =\n             new Array2DRowRealMatrix(new double[][] {\n                 }\n             }, new double[] { 2, -3 }, new double[] { 10, 0.1 });\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n-        optimizer.setMaxEvaluations(200);\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n         RealPointValuePair optimum =\n-            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n+            optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n         assertEquals( 2, optimum.getPointRef()[0], 5e-5);\n         assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n         assertTrue(optimizer.getEvaluations() > 60);\n     }\n \n     @Test\n-    public void testLeastSquares3()\n-        throws MathUserException {\n+    public void testLeastSquares3() {\n \n         final RealMatrix factors =\n             new Array2DRowRealMatrix(new double[][] {\n                     { 1, 1.2 }, { 1.2, 2 }\n                 }));\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6);\n-        optimizer.setMaxEvaluations(200);\n         optimizer.setSimplex(new NelderMeadSimplex(2));\n         RealPointValuePair optimum =\n-            optimizer.optimize(ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n+            optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 });\n         assertEquals( 2, optimum.getPointRef()[0], 2e-3);\n         assertEquals(-3, optimum.getPointRef()[1], 8e-4);\n         assertTrue(optimizer.getEvaluations() > 60);\n     }\n \n     @Test(expected = TooManyEvaluationsException.class)\n-    public void testMaxIterations() throws MathUserException {\n+    public void testMaxIterations() {\n         Powell powell = new Powell();\n         SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3);\n-        optimizer.setMaxEvaluations(20);\n         optimizer.setSimplex(new NelderMeadSimplex(4));\n-        optimizer.optimize(powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n+        optimizer.optimize(20, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 });\n     }\n \n     private static class Rosenbrock implements MultivariateRealFunction {\n             count = 0;\n         }\n \n-        public double value(double[] x) throws MathUserException {\n+        public double value(double[] x) {\n             ++count;\n             double a = x[1] - x[0] * x[0];\n             double b = 1.0 - x[0];\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n                               new double[] { 4.0, 6.0, 1.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n                 { 0, 0, 0, 0, 0, 2 }\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         for (int i = 0; i < problem.target.length; ++i) {\n                 {  0, -1, 1 }\n         }, new double[] { 1, 1, 1});\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n                 { -3, 0, -9 }\n         }, new double[] { 1, 1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        try {\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n             fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n                 {  7.0, 5.0,  9.0, 10.0 }\n         }, new double[] { 32, 23, 33, 31 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n         VectorialPointValuePair optimum1 =\n-            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n                 {  6.99, 4.99, 9.00, 9.98 }\n         }, new double[] { 32, 23, 33, 31 });\n         VectorialPointValuePair optimum2 =\n-            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n         }, new double[] { 7.0, 3.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        try {\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 7, 6, 5, 4 });\n             fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n                  { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        try {\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 2, 2, 2, 2, 2, 2 });\n             fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n         }, new double[] { 3.0, 1.0, 5.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 1, 1 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n         }, new double[] { 3.0, 1.0, 4.0 });\n \n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n         assertTrue(optimizer.getRMS() > 0.1);\n \n     }\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-\n-        VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n \n         try {\n-            optimizer.optimize(problem, problem.target,\n+            optimizer.optimize(100, problem, problem.target,\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n         }\n \n         try {\n-            optimizer.optimize(problem, new double[] { 1 },\n+            optimizer.optimize(100, problem, new double[] { 1 },\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialPointChecker(1.0e-30, 1.0e-30));\n         try {\n-            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n+            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n             fail(\"an exception should have been caught\");\n         circle.addPoint( 35.0,  15.0);\n         circle.addPoint( 45.0,  97.0);\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-13, 1.0e-13));\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 },\n+            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n         assertEquals(1.768262623567235,  FastMath.sqrt(circle.getN()) * optimizer.getRMS(),  1.0e-10);\n             circle.addPoint(points[i][0], points[i][1]);\n         }\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n-        try {\n-            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n+        optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-6, 1.0e-6));\n+        try {\n+            optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n             fail(\"an exception should have been caught\");\n         } catch (ConvergenceException ee) {\n             // expected behavior\n         }\n \n         VectorialPointValuePair optimum =\n-            optimizer.optimize(circle, target, weights, new double[] { 0, 0 });\n+            optimizer.optimize(100, circle, target, weights, new double[] { 0, 0 });\n         assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1.0e-6);\n         assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1.0e-6);\n         assertEquals(0.04268731682389561, optimizer.getRMS(),       1.0e-8);\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1 }, new double[] { 0 });\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         try {\n             optimizer.guessParametersErrors();\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         for (int i = 0; i < problem.target.length; ++i) {\n         }, new double[] { 1, 1, 1});\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1, 1 },\n                                new double[] { 0, 0, 0, 0, 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n         }, new double[] { 1, 1, 1 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n         try {\n             optimizer.getCovariances();\n         }, new double[] { 32, 23, 33, 31 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum1 =\n-            optimizer.optimize(problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem1, problem1.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(1.0, optimum1.getPoint()[0], 1.0e-10);\n                 {  6.99, 4.99, 9.00, 9.98 }\n         }, new double[] { 32, 23, 33, 31 });\n         VectorialPointValuePair optimum2 =\n-            optimizer.optimize(problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem2, problem2.target, new double[] { 1, 1, 1, 1 },\n                                new double[] { 0, 1, 2, 3 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-8);\n         }, new double[] { 7.0, 3.0, 5.0 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                 new double[] { 7, 6, 5, 4 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n     }\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 2, 2, 2, 2, 2, 2 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(3.0, optimum.getPointRef()[2], 1.0e-10);\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 },\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 },\n                                new double[] { 1, 1 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(2.0, optimum.getPointRef()[0], 1.0e-10);\n         }, new double[] { 3.0, 1.0, 4.0 });\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n-        optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n+        optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 1, 1 });\n         assertTrue(optimizer.getRMS() > 0.1);\n     }\n \n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n \n         VectorialPointValuePair optimum =\n-            optimizer.optimize(problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n+            optimizer.optimize(100, problem, problem.target, new double[] { 1, 1 }, new double[] { 0, 0 });\n         assertEquals(0, optimizer.getRMS(), 1.0e-10);\n         assertEquals(-1, optimum.getPoint()[0], 1.0e-10);\n         assertEquals(+1, optimum.getPoint()[1], 1.0e-10);\n \n         try {\n-            optimizer.optimize(problem, problem.target,\n+            optimizer.optimize(100, problem, problem.target,\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n         }\n \n         try {\n-            optimizer.optimize(problem, new double[] { 1 },\n+            optimizer.optimize(100, problem, new double[] { 1 },\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n                                                   parRelativeTolerance,\n                                                   orthoTolerance,\n                                                   MathUtils.SAFE_MIN);\n-            optimizer.setMaxEvaluations(maxCostEval);\n-            optimizer.optimize(problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+            optimizer.optimize(maxCostEval, problem, new double[] { 0, 0, 0, 0, 0 },\n+                               new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n             assertTrue(!shouldFail);\n         } catch (DimensionMismatchException ee) {\n         circle.addPoint( 45.0,  97.0);\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n+            optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                                new double[] { 98.680, 47.345 });\n         assertTrue(optimizer.getEvaluations() < 10);\n         assertTrue(optimizer.getJacobianEvaluations() < 10);\n         Arrays.fill(target, 0.0);\n         double[] weights = new double[circle.getN()];\n         Arrays.fill(weights, 2.0);\n-        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n+        optimizer.optimize(100, circle, target, weights, new double[] { 98.680, 47.345 });\n         cov = optimizer.getCovariances();\n         assertEquals(0.0016, cov[0][0], 0.001);\n         assertEquals(3.2e-7, cov[0][1], 1.0e-9);\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.setConvergenceChecker(new SimpleVectorialValueChecker(1.0e-8, 1.0e-8));\n         VectorialPointValuePair optimum =\n-            optimizer.optimize(circle, target, weights, new double[] { -12, -12 });\n+            optimizer.optimize(100, circle, target, weights, new double[] { -12, -12 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         assertTrue(optimizer.getEvaluations() < 25);\n         assertTrue(optimizer.getJacobianEvaluations() < 20);\n             problem.addPoint (4, 1.7785661310051026);\n             LevenbergMarquardtOptimizer optimizer\n                 = new LevenbergMarquardtOptimizer(100, 1e-10, 1e-10, 1e-10, 0);\n-            optimizer.optimize(problem,\n+            optimizer.optimize(100, problem,\n                                new double[] { 0, 0, 0, 0, 0 },\n                                new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 },\n                                new double[] { 0, 0, 0 });\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n           = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16),\n                                             FastMath.sqrt(2.22044604926e-16),\n                                             2.22044604926e-16);\n-      optimizer.setMaxEvaluations(400 * (function.getN() + 1));\n //      assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS()));\n       try {\n           VectorialPointValuePair optimum =\n-              optimizer.optimize(function,\n+              optimizer.optimize(400 * (function.getN() + 1), function,\n                                  function.getTarget(), function.getWeight(),\n                                  function.getStartPoint());\n           assertFalse(exceptionExpected);\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 });\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n     }\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10);\n         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         for (int i = 0; i < problem.target.length; ++i) {\n             Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10);\n         }\n         }, new double[] { 1, 1, 1});\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10);\n         Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setPreconditioner(new Preconditioner() {\n             public double[] precondition(double[] point, double[] r) {\n                 double[] d = r.clone();\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n \n         RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10);\n         Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10);\n         }, new double[] { 1, 1, 1 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-                optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+                optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertTrue(optimum.getValue() > 0.5);\n     }\n \n         }, new double[] { 32, 23, 33, 31 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(200);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));\n         BrentSolver solver = new BrentSolver(1e-15, 1e-15);\n         optimizer.setLineSearchSolver(solver);\n         RealPointValuePair optimum1 =\n-            optimizer.optimize(problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n+            optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);\n         Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4);\n         Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4);\n                 {  6.99, 4.99, 9.00, 9.98 }\n         }, new double[] { 32, 23, 33, 31 });\n         RealPointValuePair optimum2 =\n-            optimizer.optimize(problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n+            optimizer.optimize(200, problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n         Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1);\n         Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1);\n         Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n \n     }\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n     }\n \n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n         Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8);\n \n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n-        RealPointValuePair optimum =\n-            optimizer.optimize(problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n+        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));\n+        RealPointValuePair optimum =\n+            optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertTrue(optimum.getValue() > 0.1);\n \n     }\n         circle.addPoint( 45.0,  97.0);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);\n-        optimizer.setMaxEvaluations(100);\n         optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));\n         UnivariateRealSolver solver = new BrentSolver(1e-15, 1e-13);\n         optimizer.setLineSearchSolver(solver);\n         RealPointValuePair optimum =\n-            optimizer.optimize(circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n+            optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });\n         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n         Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8);\n         Assert.assertEquals(96.075902096, center.x, 1.0e-8);\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java\n     public void testSinMin() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n-        optimizer.setMaxEvaluations(200);\n+        assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n+        assertTrue(optimizer.getEvaluations() <= 50);\n         assertEquals(200, optimizer.getMaxEvaluations());\n-        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 4, 5).getPoint(),1e-8);\n-        assertTrue(optimizer.getEvaluations() <= 50);\n-        assertEquals(3 * Math.PI / 2, optimizer.optimize(f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);\n+        assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8);\n         assertTrue(optimizer.getEvaluations() <= 100);\n         assertTrue(optimizer.getEvaluations() >= 15);\n-        optimizer.setMaxEvaluations(10);\n         try {\n-            optimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n+            optimizer.optimize(10, f, GoalType.MINIMIZE, 4, 5);\n             fail(\"an exception should have been thrown\");\n         } catch (TooManyEvaluationsException fee) {\n             // expected\n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14);\n-        optimizer.setMaxEvaluations(200);\n-        assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n-        assertEquals( 0.82221643, optimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n+        assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8);\n+        assertEquals( 0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE,  0.3,  0.9).getPoint(), 1.0e-8);\n         assertTrue(optimizer.getEvaluations() <= 50);\n \n         // search in a large interval\n-        assertEquals(-0.27195613, optimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);\n+        assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8);\n         assertTrue(optimizer.getEvaluations() <= 50);\n     }\n \n         // The function has local minima at -0.27195613 and 0.82221643.\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14);\n-        optimizer.setMaxEvaluations(40);\n \n         final DescriptiveStatistics[] stat = new DescriptiveStatistics[2];\n         for (int i = 0; i < stat.length; i++) {\n         final double delta = (max - min) / nSamples;\n         for (int i = 0; i < nSamples; i++) {\n             final double start = min + i * delta;\n-            stat[0].addValue(optimizer.optimize(f, GoalType.MINIMIZE, min, max, start).getPoint());\n+            stat[0].addValue(optimizer.optimize(40, f, GoalType.MINIMIZE, min, max, start).getPoint());\n             stat[1].addValue(optimizer.getEvaluations());\n         }\n \n         assertEquals(23, (int) medianEval);\n     }\n \n-    @Test(expected = TooManyEvaluationsException.class)\n+    @Test\n     public void testQuinticMax() {\n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has a local maximum at 0.27195613.\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14);\n-        assertEquals(0.27195613, optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n-        optimizer.setMaxEvaluations(5);\n+        assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8);\n         try {\n-            optimizer.optimize(f, GoalType.MAXIMIZE, 0.2, 0.3);\n+            optimizer.optimize(5, f, GoalType.MAXIMIZE, 0.2, 0.3);\n             fail(\"an exception should have been thrown\");\n         } catch (TooManyEvaluationsException miee) {\n             // expected\n     }\n \n     @Test\n-    public void testMinEndpoints() throws Exception {\n+    public void testMinEndpoints() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14);\n-        optimizer.setMaxEvaluations(50);\n \n         // endpoint is minimum\n-        double result = optimizer.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();\n+        double result = optimizer.optimize(50, f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint();\n         assertEquals(3 * Math.PI / 2, result, 1e-6);\n \n-        result = optimizer.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();\n+        result = optimizer.optimize(50, f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint();\n         assertEquals(3 * Math.PI / 2, result, 1e-6);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizerTest.java\n     public void testSinMin() {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-10, 1e-14);\n-        underlying.setMaxEvaluations(300);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(44428400075l);\n         MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n             new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 10, g);\n-        optimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0);\n+        optimizer.optimize(300, f, GoalType.MINIMIZE, -100.0, 100.0);\n         UnivariateRealPointValuePair[] optima = optimizer.getOptima();\n         for (int i = 1; i < optima.length; ++i) {\n             double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI);\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         UnivariateRealFunction f = new QuinticFunction();\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n-        underlying.setMaxEvaluations(300);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(4312000053L);\n         MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n             new MultiStartUnivariateRealOptimizer<UnivariateRealFunction>(underlying, 5, g);\n \n         UnivariateRealPointValuePair optimum\n-            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n+            = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n         assertEquals(-0.2719561293, optimum.getPoint(), 1e-9);\n         assertEquals(-0.0443342695, optimum.getValue(), 1e-9);\n \n                 }\n             };\n         UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n-        underlying.setMaxEvaluations(300);\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(4312000053L);\n         MultiStartUnivariateRealOptimizer<UnivariateRealFunction> optimizer =\n  \n         try {\n             UnivariateRealPointValuePair optimum\n-                = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n+                = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2);\n             Assert.fail();\n         } catch (MathUserException e) {\n             // Expected.", "timestamp": 1291734097, "metainfo": ""}