{"sha": "cec984b0ade238f8ab2b2d100569dc2e4c1f2215", "log": "Created ArithmeticsUtils class (MATH-689), and corresponding unit tests. Moved some methods from MathUtils to ArithmeticsUtils.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n             den = -den;\n         }\n         // reduce numerator and denominator by greatest common denominator.\n-        final int d = MathUtils.gcd(num, den);\n+        final int d = ArithmeticsUtils.gcd(num, den);\n         if (d > 1) {\n             num /= d;\n             den /= d;\n         }\n         // if denominators are randomly distributed, d1 will be 1 about 61%\n         // of the time.\n-        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n+        int d1 = ArithmeticsUtils.gcd(denominator, fraction.denominator);\n         if (d1==1) {\n             // result is ( (u*v' +/- u'v) / u'v')\n             int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n             int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n             return new Fraction\n-                (isAdd ? MathUtils.addAndCheck(uvp, upv) :\n-                 MathUtils.subAndCheck(uvp, upv),\n+                (isAdd ? ArithmeticsUtils.addAndCheck(uvp, upv) :\n+                 ArithmeticsUtils.subAndCheck(uvp, upv),\n                  MathUtils.mulAndCheck(denominator, fraction.denominator));\n         }\n         // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n         // but d2 doesn't need extra precision because\n         // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n         int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n-        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n+        int d2 = (tmodd1==0)?d1:ArithmeticsUtils.gcd(tmodd1, d1);\n \n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n         }\n         // knuth 4.5.1\n         // make sure we don't overflow unless the result *must* overflow.\n-        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n-        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n+        int d1 = ArithmeticsUtils.gcd(numerator, fraction.denominator);\n+        int d2 = ArithmeticsUtils.gcd(fraction.numerator, denominator);\n         return getReducedFraction\n         (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n                 MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n             denominator = -denominator;\n         }\n         // simplify fraction.\n-        int gcd = MathUtils.gcd(numerator, denominator);\n+        int gcd = ArithmeticsUtils.gcd(numerator, denominator);\n         numerator /= gcd;\n         denominator /= gcd;\n         return new Fraction(numerator, denominator);\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.ArithmeticsUtils;\n import org.apache.commons.math.util.FastMath;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.ResizableDoubleArray;\n \n /**\n         final ResizableDoubleArray ra = new ResizableDoubleArray(20);\n \n         while (qi < 1) {\n-            qi += FastMath.pow(LN2, i) / MathUtils.factorial(i);\n+            qi += FastMath.pow(LN2, i) / ArithmeticsUtils.factorial(i);\n             ra.addElement(qi);\n             ++i;\n         }\n             final double lambda = FastMath.floor(mean);\n             final double lambdaFractional = mean - lambda;\n             final double logLambda = FastMath.log(lambda);\n-            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);\n+            final double logLambdaFactorial = ArithmeticsUtils.factorialLog((int) lambda);\n             final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n             final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));\n             final double halfDelta = delta / 2;\n                 if (v > qr) {\n                     continue;\n                 }\n-                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                if (v < y * logLambda - ArithmeticsUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n                     y = lambda + y;\n                     break;\n                 }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/ArithmeticsUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Some useful, arithmetics related, additions to the built-in functions in\n+ * {@link Math}.\n+ *\n+ * @version $Id$\n+ */\n+public final class ArithmeticsUtils {\n+\n+    /** All long-representable factorials */\n+    static final long[] FACTORIALS = new long[] {\n+                       1l,                  1l,                   2l,\n+                       6l,                 24l,                 120l,\n+                     720l,               5040l,               40320l,\n+                  362880l,            3628800l,            39916800l,\n+               479001600l,         6227020800l,         87178291200l,\n+           1307674368000l,     20922789888000l,     355687428096000l,\n+        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n+\n+    /** Private constructor. */\n+    private ArithmeticsUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Add two integers, checking for overflow.\n+     *\n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum {@code x+y}\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x + (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Add two long integers, checking for overflow.\n+     *\n+     * @param a an addend\n+     * @param b an addend\n+     * @return the sum {@code a+b}\n+     * @throws MathArithmeticException if the result can not be represented as an\n+     *         long\n+     * @since 1.2\n+     */\n+    public static long addAndCheck(long a, long b) {\n+        return ArithmeticsUtils.addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n+    }\n+\n+    /**\n+     * Add two long integers, checking for overflow.\n+     *\n+     * @param a Addend.\n+     * @param b Addend.\n+     * @param pattern Pattern to use for any thrown exception.\n+     * @return the sum {@code a + b}.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a {@code long}.\n+     * @since 1.2\n+     */\n+     private static long addAndCheck(long a, long b, Localizable pattern) {\n+        long ret;\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = addAndCheck(b, a, pattern);\n+        } else {\n+            // assert a <= b\n+\n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for negative overflow\n+                    if (Long.MIN_VALUE - b <= a) {\n+                        ret = a + b;\n+                    } else {\n+                        throw new MathArithmeticException(pattern, a, b);\n+                    }\n+                } else {\n+                    // opposite sign addition is always safe\n+                    ret = a + b;\n+                }\n+            } else {\n+                // assert a >= 0\n+                // assert b >= 0\n+\n+                // check for positive overflow\n+                if (a <= Long.MAX_VALUE - b) {\n+                    ret = a + b;\n+                } else {\n+                    throw new MathArithmeticException(pattern, a, b);\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Subtract two integers, checking for overflow.\n+     *\n+     * @param x Minuend.\n+     * @param y Subtrahend.\n+     * @return the difference {@code x - y}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x - (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Subtract two long integers, checking for overflow.\n+     *\n+     * @param a Value.\n+     * @param b Value.\n+     * @return the difference {@code a - b}.\n+     * @throws MathArithmeticException if the result can not be represented as a\n+     * {@code long}.\n+     * @since 1.2\n+     */\n+    public static long subAndCheck(long a, long b) {\n+        long ret;\n+        if (b == Long.MIN_VALUE) {\n+            if (a < 0) {\n+                ret = a - b;\n+            } else {\n+                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n+            }\n+        } else {\n+            // use additive inverse\n+            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns n!. Shorthand for {@code n} <a\n+     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n+     * product of the numbers {@code 1,...,n}.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code n >= 0} (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code long}. The\n+     * largest value of {@code n} for which {@code n!} <\n+     * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n+     * an {@code ArithMeticException } is thrown.</li>\n+     * </ul>\n+     * </p>\n+     *\n+     * @param n argument\n+     * @return {@code n!}\n+     * @throws MathArithmeticException if the result is too large to be represented\n+     * by a {@code long}.\n+     * @throws NotPositiveException if {@code n < 0}.\n+     * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n+     * large to fit in a {@code long}.\n+     */\n+    public static long factorial(final int n) {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n+        }\n+        if (n > 20) {\n+            throw new MathArithmeticException();\n+        }\n+        return FACTORIALS[n];\n+    }\n+\n+    /**\n+     * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n+     * {@code double}.\n+     * The result should be small enough to fit into a {@code double}: The\n+     * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n+     * If the computed value exceeds {@code Double.MAX_VALUE},\n+     * {@code Double.POSITIVE_INFINITY} is returned.\n+     *\n+     * @param n Argument.\n+     * @return {@code n!}\n+     * @throws NotPositiveException if {@code n < 0}.\n+     */\n+    public static double factorialDouble(final int n) {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n+        }\n+        if (n < 21) {\n+            return factorial(n);\n+        }\n+        return FastMath.floor(FastMath.exp(ArithmeticsUtils.factorialLog(n)) + 0.5);\n+    }\n+\n+    /**\n+     * Compute the natural logarithm of the factorial of {@code n}.\n+     *\n+     * @param n Argument.\n+     * @return {@code n!}\n+     * @throws NotPositiveException if {@code n < 0}.\n+     */\n+    public static double factorialLog(final int n) {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n+        }\n+        if (n < 21) {\n+            return FastMath.log(factorial(n));\n+        }\n+        double logSum = 0;\n+        for (int i = 2; i <= n; i++) {\n+            logSum += FastMath.log(i);\n+        }\n+        return logSum;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n+     * {@code gcd(Integer.MIN_VALUE, 0)} and\n+     * {@code gcd(0, Integer.MIN_VALUE)} throw an\n+     * {@code ArithmeticException}, because the result would be 2^31, which\n+     * is too large for an int value.</li>\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n+     * {@code gcd(x, 0)} is the absolute value of {@code x}, except\n+     * for the special cases above.\n+     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n+     * {@code 0}.</li>\n+     * </ul>\n+     *\n+     * @param p Number.\n+     * @param q Number.\n+     * @return the greatest common divisor, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code int} value.\n+     * @since 1.1\n+     */\n+    public static int gcd(final int p, final int q) {\n+        int u = p;\n+        int v = q;\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                                  p, q);\n+            }\n+            return FastMath.abs(u) + FastMath.abs(v);\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n+        // B1. [Find power of 2]\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 31) {\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                              p, q);\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        // one is odd.\n+        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t > 0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u) / 2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t != 0);\n+        return -u * (1 << k); // gcd is u*2^k\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n+     * {@code gcd(Long.MIN_VALUE, 0L)} and\n+     * {@code gcd(0L, Long.MIN_VALUE)} throw an\n+     * {@code ArithmeticException}, because the result would be 2^63, which\n+     * is too large for a long value.</li>\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n+     * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n+     * for the special cases above.\n+     * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n+     * {@code 0L}.</li>\n+     * </ul>\n+     *\n+     * @param p Number.\n+     * @param q Number.\n+     * @return the greatest common divisor, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code long} value.\n+     * @since 2.1\n+     */\n+    public static long gcd(final long p, final long q) {\n+        long u = p;\n+        long v = q;\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n+                                                  p, q);\n+            }\n+            return FastMath.abs(u) + FastMath.abs(v);\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^63, while positive numbers can only be as large as 2^63-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n+        // B1. [Find power of 2]\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 63) {\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n+                                              p, q);\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        // one is odd.\n+        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t > 0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u) / 2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t != 0);\n+        return -u * (1L << k); // gcd is u*2^k\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     /** 0.0 cast as a short. */\n     private static final short ZS = (short)0;\n \n-    /** All long-representable factorials */\n-    private static final long[] FACTORIALS = new long[] {\n-                       1l,                  1l,                   2l,\n-                       6l,                 24l,                 120l,\n-                     720l,               5040l,               40320l,\n-                  362880l,            3628800l,            39916800l,\n-               479001600l,         6227020800l,         87178291200l,\n-           1307674368000l,     20922789888000l,     355687428096000l,\n-        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n-\n     /**\n      * Private Constructor\n      */\n     private MathUtils() {\n         super();\n-    }\n-\n-    /**\n-     * Add two integers, checking for overflow.\n-     *\n-     * @param x an addend\n-     * @param y an addend\n-     * @return the sum {@code x+y}\n-     * @throws MathArithmeticException if the result can not be represented\n-     * as an {@code int}.\n-     * @since 1.1\n-     */\n-    public static int addAndCheck(int x, int y) {\n-        long s = (long)x + (long)y;\n-        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n-        }\n-        return (int)s;\n-    }\n-\n-    /**\n-     * Add two long integers, checking for overflow.\n-     *\n-     * @param a an addend\n-     * @param b an addend\n-     * @return the sum {@code a+b}\n-     * @throws MathArithmeticException if the result can not be represented as an\n-     *         long\n-     * @since 1.2\n-     */\n-    public static long addAndCheck(long a, long b) {\n-        return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n-    }\n-\n-    /**\n-     * Add two long integers, checking for overflow.\n-     *\n-     * @param a Addend.\n-     * @param b Addend.\n-     * @param pattern Pattern to use for any thrown exception.\n-     * @return the sum {@code a + b}.\n-     * @throws MathArithmeticException if the result cannot be represented\n-     * as a {@code long}.\n-     * @since 1.2\n-     */\n-    private static long addAndCheck(long a, long b, Localizable pattern) {\n-        long ret;\n-        if (a > b) {\n-            // use symmetry to reduce boundary cases\n-            ret = addAndCheck(b, a, pattern);\n-        } else {\n-            // assert a <= b\n-\n-            if (a < 0) {\n-                if (b < 0) {\n-                    // check for negative overflow\n-                    if (Long.MIN_VALUE - b <= a) {\n-                        ret = a + b;\n-                    } else {\n-                        throw new MathArithmeticException(pattern, a, b);\n-                    }\n-                } else {\n-                    // opposite sign addition is always safe\n-                    ret = a + b;\n-                }\n-            } else {\n-                // assert a >= 0\n-                // assert b >= 0\n-\n-                // check for positive overflow\n-                if (a <= Long.MAX_VALUE - b) {\n-                    ret = a + b;\n-                } else {\n-                    throw new MathArithmeticException(pattern, a, b);\n-                }\n-            }\n-        }\n-        return ret;\n     }\n \n     /**\n                 // result is divisible by (j/d) because (j/d)\n                 // is relative prime to (i/d) and is a divisor of\n                 // result * (i/d).\n-                final long d = gcd(i, j);\n+                final long d = ArithmeticsUtils.gcd(i, j);\n                 result = (result / (j / d)) * (i / d);\n                 i++;\n             }\n             // unnecessary.\n             int i = n - k + 1;\n             for (int j = 1; j <= k; j++) {\n-                final long d = gcd(i, j);\n+                final long d = ArithmeticsUtils.gcd(i, j);\n                 result = mulAndCheck(result / (j / d), i / d);\n                 i++;\n             }\n     }\n \n     /**\n-     * Returns n!. Shorthand for {@code n} <a\n-     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n-     * product of the numbers {@code 1,...,n}.\n-     * <p>\n-     * <Strong>Preconditions</strong>:\n-     * <ul>\n-     * <li> {@code n >= 0} (otherwise\n-     * {@code IllegalArgumentException} is thrown)</li>\n-     * <li> The result is small enough to fit into a {@code long}. The\n-     * largest value of {@code n} for which {@code n!} <\n-     * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n-     * an {@code ArithMeticException } is thrown.</li>\n-     * </ul>\n-     * </p>\n-     *\n-     * @param n argument\n-     * @return {@code n!}\n-     * @throws MathArithmeticException if the result is too large to be represented\n-     * by a {@code long}.\n-     * @throws NotPositiveException if {@code n < 0}.\n-     * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n-     * large to fit in a {@code long}.\n-     */\n-    public static long factorial(final int n) {\n-        if (n < 0) {\n-            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                                           n);\n-        }\n-        if (n > 20) {\n-            throw new MathArithmeticException();\n-        }\n-        return FACTORIALS[n];\n-    }\n-\n-    /**\n-     * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n-     * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n-     * {@code double}.\n-     * The result should be small enough to fit into a {@code double}: The\n-     * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n-     * If the computed value exceeds {@code Double.MAX_VALUE},\n-     * {@code Double.POSITIVE_INFINITY} is returned.\n-     *\n-     * @param n Argument.\n-     * @return {@code n!}\n-     * @throws NotPositiveException if {@code n < 0}.\n-     */\n-    public static double factorialDouble(final int n) {\n-        if (n < 0) {\n-            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                                           n);\n-        }\n-        if (n < 21) {\n-            return factorial(n);\n-        }\n-        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n-    }\n-\n-    /**\n-     * Compute the natural logarithm of the factorial of {@code n}.\n-     *\n-     * @param n Argument.\n-     * @return {@code n!}\n-     * @throws NotPositiveException if {@code n < 0}.\n-     */\n-    public static double factorialLog(final int n) {\n-        if (n < 0) {\n-            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                                           n);\n-        }\n-        if (n < 21) {\n-            return FastMath.log(factorial(n));\n-        }\n-        double logSum = 0;\n-        for (int i = 2; i <= n; i++) {\n-            logSum += FastMath.log(i);\n-        }\n-        return logSum;\n-    }\n-\n-    /**\n-     * <p>\n-     * Gets the greatest common divisor of the absolute value of two numbers,\n-     * using the \"binary gcd\" method which avoids division and modulo\n-     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n-     * Stein (1961).\n-     * </p>\n-     * Special cases:\n-     * <ul>\n-     * <li>The invocations\n-     * {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n-     * {@code gcd(Integer.MIN_VALUE, 0)} and\n-     * {@code gcd(0, Integer.MIN_VALUE)} throw an\n-     * {@code ArithmeticException}, because the result would be 2^31, which\n-     * is too large for an int value.</li>\n-     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n-     * {@code gcd(x, 0)} is the absolute value of {@code x}, except\n-     * for the special cases above.\n-     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n-     * {@code 0}.</li>\n-     * </ul>\n-     *\n-     * @param p Number.\n-     * @param q Number.\n-     * @return the greatest common divisor, never negative.\n-     * @throws MathArithmeticException if the result cannot be represented as\n-     * a non-negative {@code int} value.\n-     * @since 1.1\n-     */\n-    public static int gcd(final int p, final int q) {\n-        int u = p;\n-        int v = q;\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n-                                                  p, q);\n-            }\n-            return FastMath.abs(u) + FastMath.abs(v);\n-        }\n-        // keep u and v negative, as negative integers range down to\n-        // -2^31, while positive numbers can only be as large as 2^31-1\n-        // (i.e. we can't necessarily negate a negative number without\n-        // overflow)\n-        /* assert u!=0 && v!=0; */\n-        if (u > 0) {\n-            u = -u;\n-        } // make u negative\n-        if (v > 0) {\n-            v = -v;\n-        } // make v negative\n-        // B1. [Find power of 2]\n-        int k = 0;\n-        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n-                                                            // both even...\n-            u /= 2;\n-            v /= 2;\n-            k++; // cast out twos.\n-        }\n-        if (k == 31) {\n-            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n-                                              p, q);\n-        }\n-        // B2. Initialize: u and v have been divided by 2^k and at least\n-        // one is odd.\n-        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n-        // t negative: u was odd, v may be even (t replaces v)\n-        // t positive: u was even, v is odd (t replaces u)\n-        do {\n-            /* assert u<0 && v<0; */\n-            // B4/B3: cast out twos from t.\n-            while ((t & 1) == 0) { // while t is even..\n-                t /= 2; // cast out twos\n-            }\n-            // B5 [reset max(u,v)]\n-            if (t > 0) {\n-                u = -t;\n-            } else {\n-                v = t;\n-            }\n-            // B6/B3. at this point both u and v should be odd.\n-            t = (v - u) / 2;\n-            // |u| larger: t positive (replace u)\n-            // |v| larger: t negative (replace v)\n-        } while (t != 0);\n-        return -u * (1 << k); // gcd is u*2^k\n-    }\n-\n-    /**\n-     * <p>\n-     * Gets the greatest common divisor of the absolute value of two numbers,\n-     * using the \"binary gcd\" method which avoids division and modulo\n-     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n-     * Stein (1961).\n-     * </p>\n-     * Special cases:\n-     * <ul>\n-     * <li>The invocations\n-     * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n-     * {@code gcd(Long.MIN_VALUE, 0L)} and\n-     * {@code gcd(0L, Long.MIN_VALUE)} throw an\n-     * {@code ArithmeticException}, because the result would be 2^63, which\n-     * is too large for a long value.</li>\n-     * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n-     * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n-     * for the special cases above.\n-     * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n-     * {@code 0L}.</li>\n-     * </ul>\n-     *\n-     * @param p Number.\n-     * @param q Number.\n-     * @return the greatest common divisor, never negative.\n-     * @throws MathArithmeticException if the result cannot be represented as\n-     * a non-negative {@code long} value.\n-     * @since 2.1\n-     */\n-    public static long gcd(final long p, final long q) {\n-        long u = p;\n-        long v = q;\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n-                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n-                                                  p, q);\n-            }\n-            return FastMath.abs(u) + FastMath.abs(v);\n-        }\n-        // keep u and v negative, as negative integers range down to\n-        // -2^63, while positive numbers can only be as large as 2^63-1\n-        // (i.e. we can't necessarily negate a negative number without\n-        // overflow)\n-        /* assert u!=0 && v!=0; */\n-        if (u > 0) {\n-            u = -u;\n-        } // make u negative\n-        if (v > 0) {\n-            v = -v;\n-        } // make v negative\n-        // B1. [Find power of 2]\n-        int k = 0;\n-        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are\n-                                                            // both even...\n-            u /= 2;\n-            v /= 2;\n-            k++; // cast out twos.\n-        }\n-        if (k == 63) {\n-            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n-                                              p, q);\n-        }\n-        // B2. Initialize: u and v have been divided by 2^k and at least\n-        // one is odd.\n-        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n-        // t negative: u was odd, v may be even (t replaces v)\n-        // t positive: u was even, v is odd (t replaces u)\n-        do {\n-            /* assert u<0 && v<0; */\n-            // B4/B3: cast out twos from t.\n-            while ((t & 1) == 0) { // while t is even..\n-                t /= 2; // cast out twos\n-            }\n-            // B5 [reset max(u,v)]\n-            if (t > 0) {\n-                u = -t;\n-            } else {\n-                v = t;\n-            }\n-            // B6/B3. at this point both u and v should be odd.\n-            t = (v - u) / 2;\n-            // |u| larger: t positive (replace u)\n-            // |v| larger: t negative (replace v)\n-        } while (t != 0);\n-        return -u * (1L << k); // gcd is u*2^k\n-    }\n-\n-    /**\n      * Returns an integer hash code representing the given double value.\n      *\n      * @param value the value to be hashed\n         if (a == 0 || b == 0){\n             return 0;\n         }\n-        int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n+        int lcm = FastMath.abs(mulAndCheck(a / ArithmeticsUtils.gcd(a, b), b));\n         if (lcm == Integer.MIN_VALUE) {\n             throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,\n                                               a, b);\n         if (a == 0 || b == 0){\n             return 0;\n         }\n-        long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n+        long lcm = FastMath.abs(mulAndCheck(a / ArithmeticsUtils.gcd(a, b), b));\n         if (lcm == Long.MIN_VALUE){\n             throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,\n                                               a, b);\n     }\n \n     /**\n-     * Subtract two integers, checking for overflow.\n-     *\n-     * @param x Minuend.\n-     * @param y Subtrahend.\n-     * @return the difference {@code x - y}.\n-     * @throws MathArithmeticException if the result can not be represented\n-     * as an {@code int}.\n-     * @since 1.1\n-     */\n-    public static int subAndCheck(int x, int y) {\n-        long s = (long)x - (long)y;\n-        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n-            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n-        }\n-        return (int)s;\n-    }\n-\n-    /**\n-     * Subtract two long integers, checking for overflow.\n-     *\n-     * @param a Value.\n-     * @param b Value.\n-     * @return the difference {@code a - b}.\n-     * @throws MathArithmeticException if the result can not be represented as a\n-     * {@code long}.\n-     * @since 1.2\n-     */\n-    public static long subAndCheck(long a, long b) {\n-        long ret;\n-        if (b == Long.MIN_VALUE) {\n-            if (a < 0) {\n-                ret = a - b;\n-            } else {\n-                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n-            }\n-        } else {\n-            // use additive inverse\n-            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n-        }\n-        return ret;\n-    }\n-\n-    /**\n      * Raise an int to an int power.\n      *\n      * @param k Number to raise.", "timestamp": 1318400243, "metainfo": ""}