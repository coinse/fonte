{"sha": "3081ee1490074bb3ecf276137c6dc8836da8775e", "log": "Fix missing @Override and @Deprecated annotations  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java\n     /** The + operator method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction ADD = new BinaryFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double x, double y) {\n             return x + y;\n         }\n     /** The - operator method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction SUBTRACT = new BinaryFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double x, double y) {\n             return x - y;\n         }\n     /** The * operator method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction MULTIPLY = new BinaryFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double x, double y) {\n             return x * y;\n         }\n     /** The / operator method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction DIVIDE = new BinaryFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double x, double y) {\n             return x / y;\n         }\n     /** The {@code Math.pow} method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction POW = new BinaryFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double x, double y) {\n             return Math.pow(x, y);\n         }\n     /** The {@code Math.atan2} method wrapped as a {@link BinaryFunction}. */\n     public static final BinaryFunction ATAN2 = new BinaryFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double x, double y) {\n             return Math.atan2(x, y);\n         }\n--- a/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java\n     /** The constant function always returning 0. */\n     public static final ComposableFunction ZERO = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return 0;\n         }\n     /** The constant function always returning 1. */\n     public static final ComposableFunction ONE = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return 1;\n         }\n     /** The identity function. */\n     public static final ComposableFunction IDENTITY = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return d;\n         }\n     /** The {@code Math.abs} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ABS = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.abs(d);\n         }\n     /** The - operator wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction NEGATE = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return -d;\n         }\n     /** The invert operator wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction INVERT = new ComposableFunction () {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d){\n             return 1/d;\n         }\n     /** The {@code Math.sin} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SIN = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.sin(d);\n         }\n     /** The {@code Math.sqrt} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SQRT = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.sqrt(d);\n         }\n     /** The {@code Math.sinh} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SINH = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.sinh(d);\n         }\n     /** The {@code Math.exp} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction EXP = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.exp(d);\n         }\n     /** The {@code Math.expm1} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction EXPM1 = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.expm1(d);\n         }\n     /** The {@code Math.asin} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ASIN = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.asin(d);\n         }\n     /** The {@code Math.atan} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ATAN = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.atan(d);\n         }\n     /** The {@code Math.tan} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction TAN = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.tan(d);\n         }\n     /** The {@code Math.tanh} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction TANH = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.tanh(d);\n         }\n     /** The {@code Math.cbrt} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction CBRT = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.cbrt(d);\n         }\n     /** The {@code Math.ceil} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction CEIL = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.ceil(d);\n         }\n     /** The {@code Math.floor} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction FLOOR = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.floor(d);\n         }\n     /** The {@code Math.log} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction LOG = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.log(d);\n         }\n     /** The {@code Math.log10} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction LOG10 = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.log10(d);\n         }\n \n     /** The {@code Math.log1p} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction LOG1P = new ComposableFunction () {\n+        @Override\n         public double value(double d){\n             return Math.log1p(d);\n         }\n     /** The {@code Math.cos} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction COS = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.cos(d);\n         }\n     /** The {@code Math.abs} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ACOS = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.acos(d);\n         }\n     /** The {@code Math.cosh} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction COSH = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.cosh(d);\n         }\n     /** The {@code Math.rint} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction RINT = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.rint(d);\n         }\n     /** The {@code Math.signum} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction SIGNUM = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.signum(d);\n         }\n     /** The {@code Math.ulp} method wrapped as a {@link ComposableFunction}. */\n     public static final ComposableFunction ULP = new ComposableFunction() {\n         /** {@inheritDoc} */\n+        @Override\n         public double value(double d) {\n             return Math.ulp(d);\n         }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n         }\n \n         /** {@inheritDoc} */\n+        @Override\n         public double getValue() {\n             return getEntry(getIndex());\n         }\n \n         /** {@inheritDoc} */\n+        @Override\n         public void setValue(double newValue) {\n             setEntry(getIndex(), newValue);\n         }\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public AbstractRealVector copy() {\n         return new ArrayRealVector(this, true);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector add(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector add(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector subtract(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector subtract(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapAddToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] + d;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapSubtractToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] - d;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapMultiplyToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] * d;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapDivideToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = data[i] / d;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapPowToSelf(double d) {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.pow(data[i], d);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapExpToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.exp(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapExpm1ToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.expm1(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapLogToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.log(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapLog10ToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.log10(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapLog1pToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.log1p(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapCoshToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.cosh(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapSinhToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.sinh(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapTanhToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.tanh(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapCosToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.cos(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapSinToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.sin(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapTanToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.tan(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapAcosToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.acos(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapAsinToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.asin(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapAtanToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.atan(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapInvToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = 1.0 / data[i];\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapAbsToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.abs(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapSqrtToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.sqrt(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapCbrtToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.cbrt(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapCeilToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.ceil(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapFloorToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.floor(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapRintToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.rint(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapSignumToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.signum(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector mapUlpToSelf() {\n         for (int i = 0; i < data.length; i++) {\n             data[i] = Math.ulp(data[i]);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector ebeMultiply(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector ebeDivide(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] getData() {\n         return data.clone();\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double dotProduct(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double dotProduct(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getDistance(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getDistance(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getL1Distance(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getL1Distance(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getLInfDistance(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getLInfDistance(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector unitVector() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void unitize() throws ArithmeticException {\n         final double norm = getNorm();\n         if (norm == 0) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector projection(double[] v) {\n         return projection(new ArrayRealVector(v, false));\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix outerProduct(RealVector v)\n         throws IllegalArgumentException {\n         if (v instanceof ArrayRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealMatrix outerProduct(double[] v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setSubVector(int index, RealVector v) {\n         try {\n             try {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setSubVector(int index, double[] v) {\n         try {\n             System.arraycopy(v, 0, data, index, v.length);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void set(double value) {\n         Arrays.fill(data, value);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] toArray(){\n         return data.clone();\n     }\n      * @exception IllegalArgumentException if the vectors do not\n      * have the same dimension\n      */\n+    @Override\n     protected void checkVectorDimensions(RealVector v)\n         throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n      * @exception IllegalArgumentException if the dimension is\n      * inconsistent with vector size\n      */\n+    @Override\n     protected void checkVectorDimensions(int n)\n         throws IllegalArgumentException {\n         if (data.length != n) {\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public RealVector add(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector copy() {\n         return new OpenMapRealVector(this);\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double dotProduct(RealVector v) throws IllegalArgumentException {\n         if(v instanceof OpenMapRealVector) {\n             return dotProduct((OpenMapRealVector)v);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] getData() {\n         double[] res = new double[virtualSize];\n         Iterator iter = entries.iterator();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getDistance(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getDistance(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         double res = 0;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getL1Distance(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getL1Distance(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         double max = 0;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getLInfDistance(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         double max = 0;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector mapAdd(double d) {\n         return copy().mapAddToSelf(d);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector mapAddToSelf(double d) {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, getEntry(i) + d);\n     }\n \n      /** {@inheritDoc} */\n+    @Override\n     public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void setSubVector(int index, double[] v) throws MatrixIndexException {\n         checkIndex(index);\n         checkIndex(index + v.length - 1);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void set(double value) {\n         for (int i = 0; i < virtualSize; i++) {\n             setEntry(i, value);\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n         checkVectorDimensions(v.getDimension());\n         if (v instanceof OpenMapRealVector) {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n \n \n     /** {@inheritDoc} */\n+    @Override\n     public OpenMapRealVector unitVector() {\n         OpenMapRealVector res = copy();\n         res.unitize();\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void unitize() {\n         double norm = getNorm();\n         if (isDefaultValue(norm)) {\n \n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] toArray() {\n         return getData();\n     }\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public java.util.Iterator<Entry> sparseIterator() {\n         return new OpenMapSparseIterator();\n     }\n--- a/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n+++ b/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n      * generator built with the same seed.</p>\n      * @param seed the initial seed (32 bits integer)\n      */\n+    @Override\n     public void setSeed(int seed) {\n         // we use a long masked by 0xffffffffL as a poor man unsigned int\n         long longMT = seed;\n      * @param seed the initial seed (32 bits integers array), if null\n      * the seed of the generator will be related to the current time\n      */\n+    @Override\n     public void setSeed(int[] seed) {\n \n         if (seed == null) {\n      * generator built with the same seed.</p>\n      * @param seed the initial seed (64 bits integer)\n      */\n+    @Override\n     public void setSeed(long seed) {\n         setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n     }\n      * @param bits number of random bits to produce\n      * @return random bits generated\n      */\n+    @Override\n     protected int next(int bits) {\n \n         int y;\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n      * @param v the value to add.\n      * @deprecated to be removed in math 3.0\n      */\n+    @Deprecated\n     public void addValue(Integer v) {\n         addValue(Long.valueOf(v.longValue()));\n     }\n--- a/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/AbstractRealVectorTest.java\n             return new UnsupportedOperationException(\"Test implementation only supports methods necessary for testing\");\n         }\n \n+        @Override\n         public RealVector add(RealVector v) throws IllegalArgumentException {\n             RealVector result = new ArrayRealVector(v);\n             return result.add(this);\n         }\n \n+        @Override\n         public RealVector subtract(RealVector v) throws IllegalArgumentException {\n             RealVector result = new ArrayRealVector(v);\n             return result.subtract(this).mapMultiplyToSelf(-1);\n         }\n \n+        @Override\n         public RealVector mapAddToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n                 values[i] += d;\n             return this;\n         }\n \n+        @Override\n         public RealVector mapSubtractToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n                 values[i] -= d;\n             return this;\n         }\n \n+        @Override\n         public RealVector mapMultiplyToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n                 values[i] *= d;\n             return this;\n         }\n \n+        @Override\n         public RealVector mapDivideToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n                 values[i] /= d;\n             return this;\n         }\n \n+        @Override\n         public RealVector mapPowToSelf(double d) {\n             for(int i=0; i<values.length; i++) {\n                 values[i] = Math.pow(values[i], d);\n             return this;\n         }\n \n+        @Override\n         public RealVector mapInvToSelf() {\n             for(int i=0; i<values.length; i++) {\n                 values[i] = 1/values[i];\n             throw unsupported();\n         }\n \n+        @Override\n         public double dotProduct(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getNorm() {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getL1Norm() {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getLInfNorm() {\n             throw unsupported();\n         }\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n                 public Entry next() {\n                     final int j = i++;\n                     Entry e = new Entry() {\n+                        @Override\n                         public double getValue() {\n                             return data[j];\n                         }\n+                        @Override\n                         public void setValue(double newValue) {\n                             data[j] = newValue;\n                         }\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n             return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n         }\n \n+        @Override\n         public RealVector map(UnivariateRealFunction function) throws FunctionEvaluationException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapToSelf(UnivariateRealFunction function) throws FunctionEvaluationException {\n             throw unsupported();\n         }\n \n+        @Override\n         public Iterator<Entry> iterator() {\n             throw unsupported();\n         }\n \n+        @Override\n         public AbstractRealVector copy() {\n             return new SparseRealVectorTestImpl(data);\n         }\n \n+        @Override\n         public RealVector add(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector add(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector subtract(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector subtract(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAdd(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAddToSelf(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSubtract(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSubtractToSelf(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapMultiply(double d) {\n             double[] out = new double[data.length];\n             for (int i = 0; i < data.length; i++) {\n             return new OpenMapRealVector(out);\n         }\n \n+        @Override\n         public RealVector mapMultiplyToSelf(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapDivide(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapDivideToSelf(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapPow(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapPowToSelf(double d) {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapExp() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapExpToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapExpm1() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapExpm1ToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapLog() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapLogToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapLog10() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapLog10ToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapLog1p() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapLog1pToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCosh() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCoshToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSinh() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSinhToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapTanh() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapTanhToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCos() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCosToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSin() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSinToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapTan() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapTanToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAcos() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAcosToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAsin() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAsinToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAtan() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAtanToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapInv() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapInvToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAbs() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapAbsToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSqrt() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSqrtToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCbrt() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCbrtToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCeil() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapCeilToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapFloor() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapFloorToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapRint() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapRintToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSignum() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapSignumToSelf() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapUlp() {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector mapUlpToSelf() {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double[] getData() {\n             return data.clone();\n         }\n \n+        @Override\n         public double dotProduct(RealVector v) throws IllegalArgumentException {\n             double dot = 0;\n             for (int i = 0; i < data.length; i++) {\n             return dot;\n         }\n \n+        @Override\n         public double dotProduct(double[] v) throws IllegalArgumentException {\n             double dot = 0;\n             for (int i = 0; i < data.length; i++) {\n             return dot;\n         }\n \n+        @Override\n         public double getNorm() {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getL1Norm() {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getLInfNorm() {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getDistance(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getDistance(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getL1Distance(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getL1Distance(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public double getLInfDistance(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector unitVector() {\n             throw unsupported();\n         }\n \n+        @Override\n         public void unitize() {\n             throw unsupported();\n         }\n             throw unsupported();\n         }\n \n+        @Override\n         public RealVector projection(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n \n+        @Override\n         public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n             throw unsupported();\n         }\n             data[index] = value;\n         }\n \n+        @Override\n         public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n             throw unsupported();\n         }\n \n+        @Override\n         public void setSubVector(int index, double[] v) throws MatrixIndexException {\n             throw unsupported();\n         }\n \n+        @Override\n         public void set(double value) {\n             throw unsupported();\n         }\n \n+        @Override\n         public double[] toArray() {\n             throw unsupported();\n         }\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n   }\n \n   /** {@inheritDoc} */\n-  public TestProblem1 copy() {\n+  @Override\n+public TestProblem1 copy() {\n     return new TestProblem1(this);\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n   }\n \n   /** {@inheritDoc} */\n-  public TestProblem2 copy() {\n+  @Override\n+public TestProblem2 copy() {\n     return new TestProblem2(this);\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n   }\n \n   /** {@inheritDoc} */\n-  public TestProblem3 copy() {\n+  @Override\n+public TestProblem3 copy() {\n     return new TestProblem3(this);\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n   }\n \n   /** {@inheritDoc} */\n-  public TestProblem4 copy() {\n+  @Override\n+public TestProblem4 copy() {\n     return new TestProblem4(this);\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/TestProblem5.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem5.java\n   }\n \n   /** {@inheritDoc} */\n+  @Override\n   public TestProblem5 copy() {\n     return new TestProblem5();\n   }\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem6.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem6.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public TestProblem6 copy() {\n       return new TestProblem6(this);\n     }", "timestamp": 1264184861, "metainfo": ""}